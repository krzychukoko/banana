!function(a){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=a();else if("function"==typeof define&&define.amd)define([],a);else {var b;b="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this,b.localforage=a();}}(function(){return function a(b,c,d){function e(g,h){if(!c[g]){if(!b[g]){var i="function"==typeof require&&require;if(!h&&i)return i(g,!0);if(f)return f(g,!0);var j=new Error("Cannot find module '"+g+"'");throw j.code="MODULE_NOT_FOUND",j}var k=c[g]={exports:{}};b[g][0].call(k.exports,function(a){var c=b[g][1][a];return e(c||a)},k,k.exports,a,b,c,d);}return c[g].exports}for(var f="function"==typeof require&&require,g=0;g<d.length;g++)e(d[g]);return e}({1:[function(a,b,c){(function(a){"use strict";function c(){k=!0;for(var a,b,c=l.length;c;){for(b=l,l=[],a=-1;++a<c;)b[a]();c=l.length;}k=!1;}function d(a){1!==l.push(a)||k||e();}var e,f=a.MutationObserver||a.WebKitMutationObserver;if(f){var g=0,h=new f(c),i=a.document.createTextNode("");h.observe(i,{characterData:!0}),e=function(){i.data=g=++g%2;};}else if(a.setImmediate||void 0===a.MessageChannel)e="document"in a&&"onreadystatechange"in a.document.createElement("script")?function(){var b=a.document.createElement("script");b.onreadystatechange=function(){c(),b.onreadystatechange=null,b.parentNode.removeChild(b),b=null;},a.document.documentElement.appendChild(b);}:function(){setTimeout(c,0);};else {var j=new a.MessageChannel;j.port1.onmessage=c,e=function(){j.port2.postMessage(0);};}var k,l=[];b.exports=d;}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{});},{}],2:[function(a,b,c){"use strict";function d(){}function e(a){if("function"!=typeof a)throw new TypeError("resolver must be a function");this.state=s,this.queue=[],this.outcome=void 0,a!==d&&i(this,a);}function f(a,b,c){this.promise=a,"function"==typeof b&&(this.onFulfilled=b,this.callFulfilled=this.otherCallFulfilled),"function"==typeof c&&(this.onRejected=c,this.callRejected=this.otherCallRejected);}function g(a,b,c){o(function(){var d;try{d=b(c);}catch(b){return p.reject(a,b)}d===a?p.reject(a,new TypeError("Cannot resolve promise with itself")):p.resolve(a,d);});}function h(a){var b=a&&a.then;if(a&&("object"==typeof a||"function"==typeof a)&&"function"==typeof b)return function(){b.apply(a,arguments);}}function i(a,b){function c(b){f||(f=!0,p.reject(a,b));}function d(b){f||(f=!0,p.resolve(a,b));}function e(){b(d,c);}var f=!1,g=j(e);"error"===g.status&&c(g.value);}function j(a,b){var c={};try{c.value=a(b),c.status="success";}catch(a){c.status="error",c.value=a;}return c}function k(a){return a instanceof this?a:p.resolve(new this(d),a)}function l(a){var b=new this(d);return p.reject(b,a)}function m(a){function b(a,b){function d(a){g[b]=a,++h!==e||f||(f=!0,p.resolve(j,g));}c.resolve(a).then(d,function(a){f||(f=!0,p.reject(j,a));});}var c=this;if("[object Array]"!==Object.prototype.toString.call(a))return this.reject(new TypeError("must be an array"));var e=a.length,f=!1;if(!e)return this.resolve([]);for(var g=new Array(e),h=0,i=-1,j=new this(d);++i<e;)b(a[i],i);return j}function n(a){function b(a){c.resolve(a).then(function(a){f||(f=!0,p.resolve(h,a));},function(a){f||(f=!0,p.reject(h,a));});}var c=this;if("[object Array]"!==Object.prototype.toString.call(a))return this.reject(new TypeError("must be an array"));var e=a.length,f=!1;if(!e)return this.resolve([]);for(var g=-1,h=new this(d);++g<e;)b(a[g]);return h}var o=a(1),p={},q=["REJECTED"],r=["FULFILLED"],s=["PENDING"];b.exports=e,e.prototype.catch=function(a){return this.then(null,a)},e.prototype.then=function(a,b){if("function"!=typeof a&&this.state===r||"function"!=typeof b&&this.state===q)return this;var c=new this.constructor(d);if(this.state!==s){g(c,this.state===r?a:b,this.outcome);}else this.queue.push(new f(c,a,b));return c},f.prototype.callFulfilled=function(a){p.resolve(this.promise,a);},f.prototype.otherCallFulfilled=function(a){g(this.promise,this.onFulfilled,a);},f.prototype.callRejected=function(a){p.reject(this.promise,a);},f.prototype.otherCallRejected=function(a){g(this.promise,this.onRejected,a);},p.resolve=function(a,b){var c=j(h,b);if("error"===c.status)return p.reject(a,c.value);var d=c.value;if(d)i(a,d);else {a.state=r,a.outcome=b;for(var e=-1,f=a.queue.length;++e<f;)a.queue[e].callFulfilled(b);}return a},p.reject=function(a,b){a.state=q,a.outcome=b;for(var c=-1,d=a.queue.length;++c<d;)a.queue[c].callRejected(b);return a},e.resolve=k,e.reject=l,e.all=m,e.race=n;},{1:1}],3:[function(a,b,c){(function(b){"use strict";"function"!=typeof b.Promise&&(b.Promise=a(2));}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{});},{2:2}],4:[function(a,b,c){"use strict";function d(a,b){if(!(a instanceof b))throw new TypeError("Cannot call a class as a function")}function e(){try{if("undefined"!=typeof indexedDB)return indexedDB;if("undefined"!=typeof webkitIndexedDB)return webkitIndexedDB;if("undefined"!=typeof mozIndexedDB)return mozIndexedDB;if("undefined"!=typeof OIndexedDB)return OIndexedDB;if("undefined"!=typeof msIndexedDB)return msIndexedDB}catch(a){return}}function f(){try{if(!ua)return !1;var a="undefined"!=typeof openDatabase&&/(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent)&&!/Chrome/.test(navigator.userAgent)&&!/BlackBerry/.test(navigator.platform),b="function"==typeof fetch&&-1!==fetch.toString().indexOf("[native code");return (!a||b)&&"undefined"!=typeof indexedDB&&"undefined"!=typeof IDBKeyRange}catch(a){return !1}}function g(a,b){a=a||[],b=b||{};try{return new Blob(a,b)}catch(f){if("TypeError"!==f.name)throw f;for(var c="undefined"!=typeof BlobBuilder?BlobBuilder:"undefined"!=typeof MSBlobBuilder?MSBlobBuilder:"undefined"!=typeof MozBlobBuilder?MozBlobBuilder:WebKitBlobBuilder,d=new c,e=0;e<a.length;e+=1)d.append(a[e]);return d.getBlob(b.type)}}function h(a,b){b&&a.then(function(a){b(null,a);},function(a){b(a);});}function i(a,b,c){"function"==typeof b&&a.then(b),"function"==typeof c&&a.catch(c);}function j(a){return "string"!=typeof a&&(console.warn(a+" used as a key, but it is not a string."),a=String(a)),a}function k(){if(arguments.length&&"function"==typeof arguments[arguments.length-1])return arguments[arguments.length-1]}function l(a){for(var b=a.length,c=new ArrayBuffer(b),d=new Uint8Array(c),e=0;e<b;e++)d[e]=a.charCodeAt(e);return c}function m(a){return new va(function(b){var c=a.transaction(wa,Ba),d=g([""]);c.objectStore(wa).put(d,"key"),c.onabort=function(a){a.preventDefault(),a.stopPropagation(),b(!1);},c.oncomplete=function(){var a=navigator.userAgent.match(/Chrome\/(\d+)/),c=navigator.userAgent.match(/Edge\//);b(c||!a||parseInt(a[1],10)>=43);};}).catch(function(){return !1})}function n(a){return "boolean"==typeof xa?va.resolve(xa):m(a).then(function(a){return xa=a})}function o(a){var b=ya[a.name],c={};c.promise=new va(function(a,b){c.resolve=a,c.reject=b;}),b.deferredOperations.push(c),b.dbReady?b.dbReady=b.dbReady.then(function(){return c.promise}):b.dbReady=c.promise;}function p(a){var b=ya[a.name],c=b.deferredOperations.pop();if(c)return c.resolve(),c.promise}function q(a,b){var c=ya[a.name],d=c.deferredOperations.pop();if(d)return d.reject(b),d.promise}function r(a,b){return new va(function(c,d){if(ya[a.name]=ya[a.name]||B(),a.db){if(!b)return c(a.db);o(a),a.db.close();}var e=[a.name];b&&e.push(a.version);var f=ua.open.apply(ua,e);b&&(f.onupgradeneeded=function(b){var c=f.result;try{c.createObjectStore(a.storeName),b.oldVersion<=1&&c.createObjectStore(wa);}catch(c){if("ConstraintError"!==c.name)throw c;console.warn('The database "'+a.name+'" has been upgraded from version '+b.oldVersion+" to version "+b.newVersion+', but the storage "'+a.storeName+'" already exists.');}}),f.onerror=function(a){a.preventDefault(),d(f.error);},f.onsuccess=function(){c(f.result),p(a);};})}function s(a){return r(a,!1)}function t(a){return r(a,!0)}function u(a,b){if(!a.db)return !0;var c=!a.db.objectStoreNames.contains(a.storeName),d=a.version<a.db.version,e=a.version>a.db.version;if(d&&(a.version!==b&&console.warn('The database "'+a.name+"\" can't be downgraded from version "+a.db.version+" to version "+a.version+"."),a.version=a.db.version),e||c){if(c){var f=a.db.version+1;f>a.version&&(a.version=f);}return !0}return !1}function v(a){return new va(function(b,c){var d=new FileReader;d.onerror=c,d.onloadend=function(c){var d=btoa(c.target.result||"");b({__local_forage_encoded_blob:!0,data:d,type:a.type});},d.readAsBinaryString(a);})}function w(a){return g([l(atob(a.data))],{type:a.type})}function x(a){return a&&a.__local_forage_encoded_blob}function y(a){var b=this,c=b._initReady().then(function(){var a=ya[b._dbInfo.name];if(a&&a.dbReady)return a.dbReady});return i(c,a,a),c}function z(a){o(a);for(var b=ya[a.name],c=b.forages,d=0;d<c.length;d++){var e=c[d];e._dbInfo.db&&(e._dbInfo.db.close(),e._dbInfo.db=null);}return a.db=null,s(a).then(function(b){return a.db=b,u(a)?t(a):b}).then(function(d){a.db=b.db=d;for(var e=0;e<c.length;e++)c[e]._dbInfo.db=d;}).catch(function(b){throw q(a,b),b})}function A(a,b,c,d){void 0===d&&(d=1);try{var e=a.db.transaction(a.storeName,b);c(null,e);}catch(e){if(d>0&&(!a.db||"InvalidStateError"===e.name||"NotFoundError"===e.name))return va.resolve().then(function(){if(!a.db||"NotFoundError"===e.name&&!a.db.objectStoreNames.contains(a.storeName)&&a.version<=a.db.version)return a.db&&(a.version=a.db.version+1),t(a)}).then(function(){return z(a).then(function(){A(a,b,c,d-1);})}).catch(c);c(e);}}function B(){return {forages:[],db:null,dbReady:null,deferredOperations:[]}}function C(a){function b(){return va.resolve()}var c=this,d={db:null};if(a)for(var e in a)d[e]=a[e];var f=ya[d.name];f||(f=B(),ya[d.name]=f),f.forages.push(c),c._initReady||(c._initReady=c.ready,c.ready=y);for(var g=[],h=0;h<f.forages.length;h++){var i=f.forages[h];i!==c&&g.push(i._initReady().catch(b));}var j=f.forages.slice(0);return va.all(g).then(function(){return d.db=f.db,s(d)}).then(function(a){return d.db=a,u(d,c._defaultConfig.version)?t(d):a}).then(function(a){d.db=f.db=a,c._dbInfo=d;for(var b=0;b<j.length;b++){var e=j[b];e!==c&&(e._dbInfo.db=d.db,e._dbInfo.version=d.version);}})}function D(a,b){var c=this;a=j(a);var d=new va(function(b,d){c.ready().then(function(){A(c._dbInfo,Aa,function(e,f){if(e)return d(e);try{var g=f.objectStore(c._dbInfo.storeName),h=g.get(a);h.onsuccess=function(){var a=h.result;void 0===a&&(a=null),x(a)&&(a=w(a)),b(a);},h.onerror=function(){d(h.error);};}catch(a){d(a);}});}).catch(d);});return h(d,b),d}function E(a,b){var c=this,d=new va(function(b,d){c.ready().then(function(){A(c._dbInfo,Aa,function(e,f){if(e)return d(e);try{var g=f.objectStore(c._dbInfo.storeName),h=g.openCursor(),i=1;h.onsuccess=function(){var c=h.result;if(c){var d=c.value;x(d)&&(d=w(d));var e=a(d,c.key,i++);void 0!==e?b(e):c.continue();}else b();},h.onerror=function(){d(h.error);};}catch(a){d(a);}});}).catch(d);});return h(d,b),d}function F(a,b,c){var d=this;a=j(a);var e=new va(function(c,e){var f;d.ready().then(function(){return f=d._dbInfo,"[object Blob]"===za.call(b)?n(f.db).then(function(a){return a?b:v(b)}):b}).then(function(b){A(d._dbInfo,Ba,function(f,g){if(f)return e(f);try{var h=g.objectStore(d._dbInfo.storeName);null===b&&(b=void 0);var i=h.put(b,a);g.oncomplete=function(){void 0===b&&(b=null),c(b);},g.onabort=g.onerror=function(){var a=i.error?i.error:i.transaction.error;e(a);};}catch(a){e(a);}});}).catch(e);});return h(e,c),e}function G(a,b){var c=this;a=j(a);var d=new va(function(b,d){c.ready().then(function(){A(c._dbInfo,Ba,function(e,f){if(e)return d(e);try{var g=f.objectStore(c._dbInfo.storeName),h=g.delete(a);f.oncomplete=function(){b();},f.onerror=function(){d(h.error);},f.onabort=function(){var a=h.error?h.error:h.transaction.error;d(a);};}catch(a){d(a);}});}).catch(d);});return h(d,b),d}function H(a){var b=this,c=new va(function(a,c){b.ready().then(function(){A(b._dbInfo,Ba,function(d,e){if(d)return c(d);try{var f=e.objectStore(b._dbInfo.storeName),g=f.clear();e.oncomplete=function(){a();},e.onabort=e.onerror=function(){var a=g.error?g.error:g.transaction.error;c(a);};}catch(a){c(a);}});}).catch(c);});return h(c,a),c}function I(a){var b=this,c=new va(function(a,c){b.ready().then(function(){A(b._dbInfo,Aa,function(d,e){if(d)return c(d);try{var f=e.objectStore(b._dbInfo.storeName),g=f.count();g.onsuccess=function(){a(g.result);},g.onerror=function(){c(g.error);};}catch(a){c(a);}});}).catch(c);});return h(c,a),c}function J(a,b){var c=this,d=new va(function(b,d){if(a<0)return void b(null);c.ready().then(function(){A(c._dbInfo,Aa,function(e,f){if(e)return d(e);try{var g=f.objectStore(c._dbInfo.storeName),h=!1,i=g.openCursor();i.onsuccess=function(){var c=i.result;if(!c)return void b(null);0===a?b(c.key):h?b(c.key):(h=!0,c.advance(a));},i.onerror=function(){d(i.error);};}catch(a){d(a);}});}).catch(d);});return h(d,b),d}function K(a){var b=this,c=new va(function(a,c){b.ready().then(function(){A(b._dbInfo,Aa,function(d,e){if(d)return c(d);try{var f=e.objectStore(b._dbInfo.storeName),g=f.openCursor(),h=[];g.onsuccess=function(){var b=g.result;if(!b)return void a(h);h.push(b.key),b.continue();},g.onerror=function(){c(g.error);};}catch(a){c(a);}});}).catch(c);});return h(c,a),c}function L(a,b){b=k.apply(this,arguments);var c=this.config();a="function"!=typeof a&&a||{},a.name||(a.name=a.name||c.name,a.storeName=a.storeName||c.storeName);var d,e=this;if(a.name){var f=a.name===c.name&&e._dbInfo.db,g=f?va.resolve(e._dbInfo.db):s(a).then(function(b){var c=ya[a.name],d=c.forages;c.db=b;for(var e=0;e<d.length;e++)d[e]._dbInfo.db=b;return b});d=a.storeName?g.then(function(b){if(b.objectStoreNames.contains(a.storeName)){var c=b.version+1;o(a);var d=ya[a.name],e=d.forages;b.close();for(var f=0;f<e.length;f++){var g=e[f];g._dbInfo.db=null,g._dbInfo.version=c;}return new va(function(b,d){var e=ua.open(a.name,c);e.onerror=function(a){e.result.close(),d(a);},e.onupgradeneeded=function(){e.result.deleteObjectStore(a.storeName);},e.onsuccess=function(){var a=e.result;a.close(),b(a);};}).then(function(a){d.db=a;for(var b=0;b<e.length;b++){var c=e[b];c._dbInfo.db=a,p(c._dbInfo);}}).catch(function(b){throw (q(a,b)||va.resolve()).catch(function(){}),b})}}):g.then(function(b){o(a);var c=ya[a.name],d=c.forages;b.close();for(var e=0;e<d.length;e++){d[e]._dbInfo.db=null;}return new va(function(b,c){var d=ua.deleteDatabase(a.name);d.onerror=d.onblocked=function(a){var b=d.result;b&&b.close(),c(a);},d.onsuccess=function(){var a=d.result;a&&a.close(),b(a);};}).then(function(a){c.db=a;for(var b=0;b<d.length;b++)p(d[b]._dbInfo);}).catch(function(b){throw (q(a,b)||va.resolve()).catch(function(){}),b})});}else d=va.reject("Invalid arguments");return h(d,b),d}function M(){return "function"==typeof openDatabase}function N(a){var b,c,d,e,f,g=.75*a.length,h=a.length,i=0;"="===a[a.length-1]&&(g--,"="===a[a.length-2]&&g--);var j=new ArrayBuffer(g),k=new Uint8Array(j);for(b=0;b<h;b+=4)c=Da.indexOf(a[b]),d=Da.indexOf(a[b+1]),e=Da.indexOf(a[b+2]),f=Da.indexOf(a[b+3]),k[i++]=c<<2|d>>4,k[i++]=(15&d)<<4|e>>2,k[i++]=(3&e)<<6|63&f;return j}function O(a){var b,c=new Uint8Array(a),d="";for(b=0;b<c.length;b+=3)d+=Da[c[b]>>2],d+=Da[(3&c[b])<<4|c[b+1]>>4],d+=Da[(15&c[b+1])<<2|c[b+2]>>6],d+=Da[63&c[b+2]];return c.length%3==2?d=d.substring(0,d.length-1)+"=":c.length%3==1&&(d=d.substring(0,d.length-2)+"=="),d}function P(a,b){var c="";if(a&&(c=Ua.call(a)),a&&("[object ArrayBuffer]"===c||a.buffer&&"[object ArrayBuffer]"===Ua.call(a.buffer))){var d,e=Ga;a instanceof ArrayBuffer?(d=a,e+=Ia):(d=a.buffer,"[object Int8Array]"===c?e+=Ka:"[object Uint8Array]"===c?e+=La:"[object Uint8ClampedArray]"===c?e+=Ma:"[object Int16Array]"===c?e+=Na:"[object Uint16Array]"===c?e+=Pa:"[object Int32Array]"===c?e+=Oa:"[object Uint32Array]"===c?e+=Qa:"[object Float32Array]"===c?e+=Ra:"[object Float64Array]"===c?e+=Sa:b(new Error("Failed to get type for BinaryArray"))),b(e+O(d));}else if("[object Blob]"===c){var f=new FileReader;f.onload=function(){var c=Ea+a.type+"~"+O(this.result);b(Ga+Ja+c);},f.readAsArrayBuffer(a);}else try{b(JSON.stringify(a));}catch(c){console.error("Couldn't convert value into a JSON string: ",a),b(null,c);}}function Q(a){if(a.substring(0,Ha)!==Ga)return JSON.parse(a);var b,c=a.substring(Ta),d=a.substring(Ha,Ta);if(d===Ja&&Fa.test(c)){var e=c.match(Fa);b=e[1],c=c.substring(e[0].length);}var f=N(c);switch(d){case Ia:return f;case Ja:return g([f],{type:b});case Ka:return new Int8Array(f);case La:return new Uint8Array(f);case Ma:return new Uint8ClampedArray(f);case Na:return new Int16Array(f);case Pa:return new Uint16Array(f);case Oa:return new Int32Array(f);case Qa:return new Uint32Array(f);case Ra:return new Float32Array(f);case Sa:return new Float64Array(f);default:throw new Error("Unkown type: "+d)}}function R(a,b,c,d){a.executeSql("CREATE TABLE IF NOT EXISTS "+b.storeName+" (id INTEGER PRIMARY KEY, key unique, value)",[],c,d);}function S(a){var b=this,c={db:null};if(a)for(var d in a)c[d]="string"!=typeof a[d]?a[d].toString():a[d];var e=new va(function(a,d){try{c.db=openDatabase(c.name,String(c.version),c.description,c.size);}catch(a){return d(a)}c.db.transaction(function(e){R(e,c,function(){b._dbInfo=c,a();},function(a,b){d(b);});},d);});return c.serializer=Va,e}function T(a,b,c,d,e,f){a.executeSql(c,d,e,function(a,g){g.code===g.SYNTAX_ERR?a.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?",[b.storeName],function(a,h){h.rows.length?f(a,g):R(a,b,function(){a.executeSql(c,d,e,f);},f);},f):f(a,g);},f);}function U(a,b){var c=this;a=j(a);var d=new va(function(b,d){c.ready().then(function(){var e=c._dbInfo;e.db.transaction(function(c){T(c,e,"SELECT * FROM "+e.storeName+" WHERE key = ? LIMIT 1",[a],function(a,c){var d=c.rows.length?c.rows.item(0).value:null;d&&(d=e.serializer.deserialize(d)),b(d);},function(a,b){d(b);});});}).catch(d);});return h(d,b),d}function V(a,b){var c=this,d=new va(function(b,d){c.ready().then(function(){var e=c._dbInfo;e.db.transaction(function(c){T(c,e,"SELECT * FROM "+e.storeName,[],function(c,d){for(var f=d.rows,g=f.length,h=0;h<g;h++){var i=f.item(h),j=i.value;if(j&&(j=e.serializer.deserialize(j)),void 0!==(j=a(j,i.key,h+1)))return void b(j)}b();},function(a,b){d(b);});});}).catch(d);});return h(d,b),d}function W(a,b,c,d){var e=this;a=j(a);var f=new va(function(f,g){e.ready().then(function(){void 0===b&&(b=null);var h=b,i=e._dbInfo;i.serializer.serialize(b,function(b,j){j?g(j):i.db.transaction(function(c){T(c,i,"INSERT OR REPLACE INTO "+i.storeName+" (key, value) VALUES (?, ?)",[a,b],function(){f(h);},function(a,b){g(b);});},function(b){if(b.code===b.QUOTA_ERR){if(d>0)return void f(W.apply(e,[a,h,c,d-1]));g(b);}});});}).catch(g);});return h(f,c),f}function X(a,b,c){return W.apply(this,[a,b,c,1])}function Y(a,b){var c=this;a=j(a);var d=new va(function(b,d){c.ready().then(function(){var e=c._dbInfo;e.db.transaction(function(c){T(c,e,"DELETE FROM "+e.storeName+" WHERE key = ?",[a],function(){b();},function(a,b){d(b);});});}).catch(d);});return h(d,b),d}function Z(a){var b=this,c=new va(function(a,c){b.ready().then(function(){var d=b._dbInfo;d.db.transaction(function(b){T(b,d,"DELETE FROM "+d.storeName,[],function(){a();},function(a,b){c(b);});});}).catch(c);});return h(c,a),c}function $(a){var b=this,c=new va(function(a,c){b.ready().then(function(){var d=b._dbInfo;d.db.transaction(function(b){T(b,d,"SELECT COUNT(key) as c FROM "+d.storeName,[],function(b,c){var d=c.rows.item(0).c;a(d);},function(a,b){c(b);});});}).catch(c);});return h(c,a),c}function _(a,b){var c=this,d=new va(function(b,d){c.ready().then(function(){var e=c._dbInfo;e.db.transaction(function(c){T(c,e,"SELECT key FROM "+e.storeName+" WHERE id = ? LIMIT 1",[a+1],function(a,c){var d=c.rows.length?c.rows.item(0).key:null;b(d);},function(a,b){d(b);});});}).catch(d);});return h(d,b),d}function aa(a){var b=this,c=new va(function(a,c){b.ready().then(function(){var d=b._dbInfo;d.db.transaction(function(b){T(b,d,"SELECT key FROM "+d.storeName,[],function(b,c){for(var d=[],e=0;e<c.rows.length;e++)d.push(c.rows.item(e).key);a(d);},function(a,b){c(b);});});}).catch(c);});return h(c,a),c}function ba(a){return new va(function(b,c){a.transaction(function(d){d.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'",[],function(c,d){for(var e=[],f=0;f<d.rows.length;f++)e.push(d.rows.item(f).name);b({db:a,storeNames:e});},function(a,b){c(b);});},function(a){c(a);});})}function ca(a,b){b=k.apply(this,arguments);var c=this.config();a="function"!=typeof a&&a||{},a.name||(a.name=a.name||c.name,a.storeName=a.storeName||c.storeName);var d,e=this;return d=a.name?new va(function(b){var d;d=a.name===c.name?e._dbInfo.db:openDatabase(a.name,"","",0),b(a.storeName?{db:d,storeNames:[a.storeName]}:ba(d));}).then(function(a){return new va(function(b,c){a.db.transaction(function(d){function e(a){return new va(function(b,c){d.executeSql("DROP TABLE IF EXISTS "+a,[],function(){b();},function(a,b){c(b);});})}for(var f=[],g=0,h=a.storeNames.length;g<h;g++)f.push(e(a.storeNames[g]));va.all(f).then(function(){b();}).catch(function(a){c(a);});},function(a){c(a);});})}):va.reject("Invalid arguments"),h(d,b),d}function da(){try{return "undefined"!=typeof localStorage&&"setItem"in localStorage&&!!localStorage.setItem}catch(a){return !1}}function ea(a,b){var c=a.name+"/";return a.storeName!==b.storeName&&(c+=a.storeName+"/"),c}function fa(){var a="_localforage_support_test";try{return localStorage.setItem(a,!0),localStorage.removeItem(a),!1}catch(a){return !0}}function ga(){return !fa()||localStorage.length>0}function ha(a){var b=this,c={};if(a)for(var d in a)c[d]=a[d];return c.keyPrefix=ea(a,b._defaultConfig),ga()?(b._dbInfo=c,c.serializer=Va,va.resolve()):va.reject()}function ia(a){var b=this,c=b.ready().then(function(){for(var a=b._dbInfo.keyPrefix,c=localStorage.length-1;c>=0;c--){var d=localStorage.key(c);0===d.indexOf(a)&&localStorage.removeItem(d);}});return h(c,a),c}function ja(a,b){var c=this;a=j(a);var d=c.ready().then(function(){var b=c._dbInfo,d=localStorage.getItem(b.keyPrefix+a);return d&&(d=b.serializer.deserialize(d)),d});return h(d,b),d}function ka(a,b){var c=this,d=c.ready().then(function(){for(var b=c._dbInfo,d=b.keyPrefix,e=d.length,f=localStorage.length,g=1,h=0;h<f;h++){var i=localStorage.key(h);if(0===i.indexOf(d)){var j=localStorage.getItem(i);if(j&&(j=b.serializer.deserialize(j)),void 0!==(j=a(j,i.substring(e),g++)))return j}}});return h(d,b),d}function la(a,b){var c=this,d=c.ready().then(function(){var b,d=c._dbInfo;try{b=localStorage.key(a);}catch(a){b=null;}return b&&(b=b.substring(d.keyPrefix.length)),b});return h(d,b),d}function ma(a){var b=this,c=b.ready().then(function(){for(var a=b._dbInfo,c=localStorage.length,d=[],e=0;e<c;e++){var f=localStorage.key(e);0===f.indexOf(a.keyPrefix)&&d.push(f.substring(a.keyPrefix.length));}return d});return h(c,a),c}function na(a){var b=this,c=b.keys().then(function(a){return a.length});return h(c,a),c}function oa(a,b){var c=this;a=j(a);var d=c.ready().then(function(){var b=c._dbInfo;localStorage.removeItem(b.keyPrefix+a);});return h(d,b),d}function pa(a,b,c){var d=this;a=j(a);var e=d.ready().then(function(){void 0===b&&(b=null);var c=b;return new va(function(e,f){var g=d._dbInfo;g.serializer.serialize(b,function(b,d){if(d)f(d);else try{localStorage.setItem(g.keyPrefix+a,b),e(c);}catch(a){"QuotaExceededError"!==a.name&&"NS_ERROR_DOM_QUOTA_REACHED"!==a.name||f(a),f(a);}});})});return h(e,c),e}function qa(a,b){if(b=k.apply(this,arguments),a="function"!=typeof a&&a||{},!a.name){var c=this.config();a.name=a.name||c.name,a.storeName=a.storeName||c.storeName;}var d,e=this;return d=a.name?new va(function(b){b(a.storeName?ea(a,e._defaultConfig):a.name+"/");}).then(function(a){for(var b=localStorage.length-1;b>=0;b--){var c=localStorage.key(b);0===c.indexOf(a)&&localStorage.removeItem(c);}}):va.reject("Invalid arguments"),h(d,b),d}function ra(a,b){a[b]=function(){var c=arguments;return a.ready().then(function(){return a[b].apply(a,c)})};}function sa(){for(var a=1;a<arguments.length;a++){var b=arguments[a];if(b)for(var c in b)b.hasOwnProperty(c)&&($a(b[c])?arguments[0][c]=b[c].slice():arguments[0][c]=b[c]);}return arguments[0]}var ta="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(a){return typeof a}:function(a){return a&&"function"==typeof Symbol&&a.constructor===Symbol&&a!==Symbol.prototype?"symbol":typeof a},ua=e();"undefined"==typeof Promise&&a(3);var va=Promise,wa="local-forage-detect-blob-support",xa=void 0,ya={},za=Object.prototype.toString,Aa="readonly",Ba="readwrite",Ca={_driver:"asyncStorage",_initStorage:C,_support:f(),iterate:E,getItem:D,setItem:F,removeItem:G,clear:H,length:I,key:J,keys:K,dropInstance:L},Da="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",Ea="~~local_forage_type~",Fa=/^~~local_forage_type~([^~]+)~/,Ga="__lfsc__:",Ha=Ga.length,Ia="arbf",Ja="blob",Ka="si08",La="ui08",Ma="uic8",Na="si16",Oa="si32",Pa="ur16",Qa="ui32",Ra="fl32",Sa="fl64",Ta=Ha+Ia.length,Ua=Object.prototype.toString,Va={serialize:P,deserialize:Q,stringToBuffer:N,bufferToString:O},Wa={_driver:"webSQLStorage",_initStorage:S,_support:M(),iterate:V,getItem:U,setItem:X,removeItem:Y,clear:Z,length:$,key:_,keys:aa,dropInstance:ca},Xa={_driver:"localStorageWrapper",_initStorage:ha,_support:da(),iterate:ka,getItem:ja,setItem:pa,removeItem:oa,clear:ia,length:na,key:la,keys:ma,dropInstance:qa},Ya=function(a,b){return a===b||"number"==typeof a&&"number"==typeof b&&isNaN(a)&&isNaN(b)},Za=function(a,b){for(var c=a.length,d=0;d<c;){if(Ya(a[d],b))return !0;d++;}return !1},$a=Array.isArray||function(a){return "[object Array]"===Object.prototype.toString.call(a)},_a={},ab={},bb={INDEXEDDB:Ca,WEBSQL:Wa,LOCALSTORAGE:Xa},cb=[bb.INDEXEDDB._driver,bb.WEBSQL._driver,bb.LOCALSTORAGE._driver],db=["dropInstance"],eb=["clear","getItem","iterate","key","keys","length","removeItem","setItem"].concat(db),fb={description:"",driver:cb.slice(),name:"localforage",size:4980736,storeName:"keyvaluepairs",version:1},gb=function(){function a(b){d(this,a);for(var c in bb)if(bb.hasOwnProperty(c)){var e=bb[c],f=e._driver;this[c]=f,_a[f]||this.defineDriver(e);}this._defaultConfig=sa({},fb),this._config=sa({},this._defaultConfig,b),this._driverSet=null,this._initDriver=null,this._ready=!1,this._dbInfo=null,this._wrapLibraryMethodsWithReady(),this.setDriver(this._config.driver).catch(function(){});}return a.prototype.config=function(a){if("object"===(void 0===a?"undefined":ta(a))){if(this._ready)return new Error("Can't call config() after localforage has been used.");for(var b in a){if("storeName"===b&&(a[b]=a[b].replace(/\W/g,"_")),"version"===b&&"number"!=typeof a[b])return new Error("Database version must be a number.");this._config[b]=a[b];}return !("driver"in a&&a.driver)||this.setDriver(this._config.driver)}return "string"==typeof a?this._config[a]:this._config},a.prototype.defineDriver=function(a,b,c){var d=new va(function(b,c){try{var d=a._driver,e=new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");if(!a._driver)return void c(e);for(var f=eb.concat("_initStorage"),g=0,i=f.length;g<i;g++){var j=f[g];if((!Za(db,j)||a[j])&&"function"!=typeof a[j])return void c(e)}(function(){for(var b=function(a){return function(){var b=new Error("Method "+a+" is not implemented by the current driver"),c=va.reject(b);return h(c,arguments[arguments.length-1]),c}},c=0,d=db.length;c<d;c++){var e=db[c];a[e]||(a[e]=b(e));}})();var k=function(c){_a[d]&&console.info("Redefining LocalForage driver: "+d),_a[d]=a,ab[d]=c,b();};"_support"in a?a._support&&"function"==typeof a._support?a._support().then(k,c):k(!!a._support):k(!0);}catch(a){c(a);}});return i(d,b,c),d},a.prototype.driver=function(){return this._driver||null},a.prototype.getDriver=function(a,b,c){var d=_a[a]?va.resolve(_a[a]):va.reject(new Error("Driver not found."));return i(d,b,c),d},a.prototype.getSerializer=function(a){var b=va.resolve(Va);return i(b,a),b},a.prototype.ready=function(a){var b=this,c=b._driverSet.then(function(){return null===b._ready&&(b._ready=b._initDriver()),b._ready});return i(c,a,a),c},a.prototype.setDriver=function(a,b,c){function d(){g._config.driver=g.driver();}function e(a){return g._extend(a),d(),g._ready=g._initStorage(g._config),g._ready}function f(a){return function(){function b(){for(;c<a.length;){var f=a[c];return c++,g._dbInfo=null,g._ready=null,g.getDriver(f).then(e).catch(b)}d();var h=new Error("No available storage method found.");return g._driverSet=va.reject(h),g._driverSet}var c=0;return b()}}var g=this;$a(a)||(a=[a]);var h=this._getSupportedDrivers(a),j=null!==this._driverSet?this._driverSet.catch(function(){return va.resolve()}):va.resolve();return this._driverSet=j.then(function(){var a=h[0];return g._dbInfo=null,g._ready=null,g.getDriver(a).then(function(a){g._driver=a._driver,d(),g._wrapLibraryMethodsWithReady(),g._initDriver=f(h);})}).catch(function(){d();var a=new Error("No available storage method found.");return g._driverSet=va.reject(a),g._driverSet}),i(this._driverSet,b,c),this._driverSet},a.prototype.supports=function(a){return !!ab[a]},a.prototype._extend=function(a){sa(this,a);},a.prototype._getSupportedDrivers=function(a){for(var b=[],c=0,d=a.length;c<d;c++){var e=a[c];this.supports(e)&&b.push(e);}return b},a.prototype._wrapLibraryMethodsWithReady=function(){for(var a=0,b=eb.length;a<b;a++)ra(this,eb[a]);},a.prototype.createInstance=function(b){return new a(b)},a}(),hb=new gb;b.exports=hb;},{3:3}]},{},[4])(4)});

Object.defineProperty(globalThis, "IS_VTT", {
	get () { return true; },
	set (val) {  },
});

"use strict";

globalThis.Parser = {};

Parser._parse_aToB = function (abMap, a, fallback) {
	if (a === undefined || a === null) throw new TypeError("undefined or null object passed to parser");
	if (typeof a === "string") a = a.trim();
	if (abMap[a] !== undefined) return abMap[a];
	return fallback !== undefined ? fallback : a;
};

Parser._parse_bToA = function (abMap, b, fallback) {
	if (b === undefined || b === null) throw new TypeError("undefined or null object passed to parser");
	if (typeof b === "string") b = b.trim();
	for (const v in abMap) {
		if (!abMap.hasOwnProperty(v)) continue;
		if (abMap[v] === b) return v;
	}
	return fallback !== undefined ? fallback : b;
};

Parser.attrChooseToFull = function (attList) {
	if (attList.length === 1) return `${Parser.attAbvToFull(attList[0])} modifier`;
	else {
		const attsTemp = [];
		for (let i = 0; i < attList.length; ++i) {
			attsTemp.push(Parser.attAbvToFull(attList[i]));
		}
		return `${attsTemp.join(" or ")} modifier (your choice)`;
	}
};

Parser.numberToText = function (number) {
	if (number == null) throw new TypeError(`undefined or null object passed to parser`);
	if (Math.abs(number) >= 100) return `${number}`;

	function getAsText (num) {
		const abs = Math.abs(num);
		switch (abs) {
			case 0: return "zero";
			case 1: return "one";
			case 2: return "two";
			case 3: return "three";
			case 4: return "four";
			case 5: return "five";
			case 6: return "six";
			case 7: return "seven";
			case 8: return "eight";
			case 9: return "nine";
			case 10: return "ten";
			case 11: return "eleven";
			case 12: return "twelve";
			case 13: return "thirteen";
			case 14: return "fourteen";
			case 15: return "fifteen";
			case 16: return "sixteen";
			case 17: return "seventeen";
			case 18: return "eighteen";
			case 19: return "nineteen";
			case 20: return "twenty";
			case 30: return "thirty";
			case 40: return "forty";
			case 50: return "fiddy"; 			case 60: return "sixty";
			case 70: return "seventy";
			case 80: return "eighty";
			case 90: return "ninety";
			default: {
				const str = String(abs);
				return `${getAsText(Number(`${str[0]}0`))}-${getAsText(Number(str[1]))}`;
			}
		}
	}
	return `${number < 0 ? "negative " : ""}${getAsText(number)}`;
};

Parser.textToNumber = function (str) {
	str = str.trim().toLowerCase();
	if (!isNaN(str)) return Number(str);
	switch (str) {
		case "zero": return 0;
		case "one": case "a": case "an": return 1;
		case "two": case "double": return 2;
		case "three": case "triple": return 3;
		case "four": case "quadruple": return 4;
		case "five": return 5;
		case "six": return 6;
		case "seven": return 7;
		case "eight": return 8;
		case "nine": return 9;
		case "ten": return 10;
		case "eleven": return 11;
		case "twelve": return 12;
		case "thirteen": return 13;
		case "fourteen": return 14;
		case "fifteen": return 15;
		case "sixteen": return 16;
		case "seventeen": return 17;
		case "eighteen": return 18;
		case "nineteen": return 19;
		case "twenty": return 20;
		case "thirty": return 30;
		case "forty": return 40;
		case "fifty": case "fiddy": return 50;
		case "sixty": return 60;
		case "seventy": return 70;
		case "eighty": return 80;
		case "ninety": return 90;
	}
	return NaN;
};

Parser.numberToVulgar = function (number, {isFallbackOnFractional = true} = {}) {
	const isNeg = number < 0;
	const spl = `${number}`.replace(/^-/, "").split(".");
	if (spl.length === 1) return number;

	let preDot = spl[0] === "0" ? "" : spl[0];
	if (isNeg) preDot = `-${preDot}`;

	switch (spl[1]) {
		case "125": return `${preDot}⅛`;
		case "2": return `${preDot}⅕`;
		case "25": return `${preDot}¼`;
		case "375": return `${preDot}⅜`;
		case "4": return `${preDot}⅖`;
		case "5": return `${preDot}½`;
		case "6": return `${preDot}⅗`;
		case "625": return `${preDot}⅝`;
		case "75": return `${preDot}¾`;
		case "8": return `${preDot}⅘`;
		case "875": return `${preDot}⅞`;

		default: {
						const asNum = Number(`0.${spl[1]}`);

			if (asNum.toFixed(2) === (1 / 3).toFixed(2)) return `${preDot}⅓`;
			if (asNum.toFixed(2) === (2 / 3).toFixed(2)) return `${preDot}⅔`;

			if (asNum.toFixed(2) === (1 / 6).toFixed(2)) return `${preDot}⅙`;
			if (asNum.toFixed(2) === (5 / 6).toFixed(2)) return `${preDot}⅚`;
		}
	}

	return isFallbackOnFractional ? Parser.numberToFractional(number) : null;
};

Parser.vulgarToNumber = function (str) {
	const [, leading = "0", vulgar = ""] = /^(\d+)?([⅛¼⅜½⅝¾⅞⅓⅔⅙⅚])?$/.exec(str) || [];
	let out = Number(leading);
	switch (vulgar) {
		case "⅛": out += 0.125; break;
		case "¼": out += 0.25; break;
		case "⅜": out += 0.375; break;
		case "½": out += 0.5; break;
		case "⅝": out += 0.625; break;
		case "¾": out += 0.75; break;
		case "⅞": out += 0.875; break;
		case "⅓": out += 1 / 3; break;
		case "⅔": out += 2 / 3; break;
		case "⅙": out += 1 / 6; break;
		case "⅚": out += 5 / 6; break;
		case "": break;
		default: throw new Error(`Unhandled vulgar part "${vulgar}"`);
	}
	return out;
};

Parser.numberToSuperscript = function (number) {
	return `${number}`.split("").map(c => isNaN(c) ? c : Parser._NUMBERS_SUPERSCRIPT[Number(c)]).join("");
};
Parser._NUMBERS_SUPERSCRIPT = "⁰¹²³⁴⁵⁶⁷⁸⁹";

Parser.numberToSubscript = function (number) {
	return `${number}`.split("").map(c => isNaN(c) ? c : Parser._NUMBERS_SUBSCRIPT[Number(c)]).join("");
};
Parser._NUMBERS_SUBSCRIPT = "₀₁₂₃₄₅₆₇₈₉";

Parser._greatestCommonDivisor = function (a, b) {
	if (b < Number.EPSILON) return a;
	return Parser._greatestCommonDivisor(b, Math.floor(a % b));
};
Parser.numberToFractional = function (number) {
	const len = number.toString().length - 2;
	let denominator = 10 ** len;
	let numerator = number * denominator;
	const divisor = Parser._greatestCommonDivisor(numerator, denominator);
	numerator = Math.floor(numerator / divisor);
	denominator = Math.floor(denominator / divisor);

	return denominator === 1 ? String(numerator) : `${Math.floor(numerator)}/${Math.floor(denominator)}`;
};

Parser.ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

Parser.attAbvToFull = function (abv) {
	return Parser._parse_aToB(Parser.ATB_ABV_TO_FULL, abv);
};

Parser.attFullToAbv = function (full) {
	return Parser._parse_bToA(Parser.ATB_ABV_TO_FULL, full);
};

Parser.sizeAbvToFull = function (abv) {
	return Parser._parse_aToB(Parser.SIZE_ABV_TO_FULL, abv);
};

Parser.getAbilityModNumber = function (abilityScore) {
	return Math.floor((abilityScore - 10) / 2);
};

Parser.getAbilityModifier = function (abilityScore) {
	let modifier = Parser.getAbilityModNumber(abilityScore);
	if (modifier >= 0) modifier = `+${modifier}`;
	return `${modifier}`;
};

Parser.getSpeedString = (ent, {isMetric = false, isSkipZeroWalk = false} = {}) => {
	if (ent.speed == null) return "\u2014";

	const unit = isMetric ? Parser.metric.getMetricUnit({originalUnit: "ft.", isShortForm: true}) : "ft.";
	if (typeof ent.speed === "object") {
		const stack = [];
		let joiner = ", ";

		Parser.SPEED_MODES
			.filter(mode => !ent.speed.hidden?.includes(mode))
			.forEach(mode => Parser._getSpeedString_addSpeedMode({ent, prop: mode, stack, isMetric, isSkipZeroWalk, unit}));

		if (ent.speed.choose && !ent.speed.hidden?.includes("choose")) {
			joiner = "; ";
			stack.push(`${ent.speed.choose.from.sort().joinConjunct(", ", " or ")} ${ent.speed.choose.amount} ${unit}${ent.speed.choose.note ? ` ${ent.speed.choose.note}` : ""}`);
		}

		return stack.join(joiner) + (ent.speed.note ? ` ${ent.speed.note}` : "");
	}

	return (isMetric ? Parser.metric.getMetricNumber({originalValue: ent.speed, originalUnit: Parser.UNT_FEET}) : ent.speed)
		+ (ent.speed === "Varies" ? "" : ` ${unit} `);
};
Parser._getSpeedString_addSpeedMode = ({ent, prop, stack, isMetric, isSkipZeroWalk, unit}) => {
	if (ent.speed[prop] || (!isSkipZeroWalk && prop === "walk")) Parser._getSpeedString_addSpeed({prop, speed: ent.speed[prop] || 0, isMetric, unit, stack});
	if (ent.speed.alternate && ent.speed.alternate[prop]) ent.speed.alternate[prop].forEach(speed => Parser._getSpeedString_addSpeed({prop, speed, isMetric, unit, stack}));
};
Parser._getSpeedString_addSpeed = ({prop, speed, isMetric, unit, stack}) => {
	const ptName = prop === "walk" ? "" : `${prop} `;
	const ptValue = Parser._getSpeedString_getVal({prop, speed, isMetric});
	const ptUnit = speed === true ? "" : ` ${unit}`;
	const ptCondition = Parser._getSpeedString_getCondition({speed});
	stack.push([ptName, ptValue, ptUnit, ptCondition].join(""));
};
Parser._getSpeedString_getVal = ({prop, speed, isMetric}) => {
	if (speed === true && prop !== "walk") return "equal to your walking speed";

	const num = speed === true
		? 0
		: speed.number != null ? speed.number : speed;

	return isMetric ? Parser.metric.getMetricNumber({originalValue: num, originalUnit: Parser.UNT_FEET}) : num;
};
Parser._getSpeedString_getCondition = ({speed}) => speed.condition ? ` ${Renderer.get().render(speed.condition)}` : "";

Parser.SPEED_MODES = ["walk", "burrow", "climb", "fly", "swim"];

Parser.SPEED_TO_PROGRESSIVE = {
	"walk": "walking",
	"burrow": "burrowing",
	"climb": "climbing",
	"fly": "flying",
	"swim": "swimming",
};

Parser.speedToProgressive = function (prop) {
	return Parser._parse_aToB(Parser.SPEED_TO_PROGRESSIVE, prop);
};

Parser._addCommas = function (intNum) {
	return `${intNum}`.replace(/(\d)(?=(\d{3})+$)/g, "$1,");
};

Parser.raceCreatureTypesToFull = function (creatureTypes) {
	const hasSubOptions = creatureTypes.some(it => it.choose);
	return creatureTypes
		.map(it => {
			if (!it.choose) return Parser.monTypeToFullObj(it).asText;
			return [...it.choose]
				.sort(SortUtil.ascSortLower)
				.map(sub => Parser.monTypeToFullObj(sub).asText)
				.joinConjunct(", ", " or ");
		})
		.joinConjunct(hasSubOptions ? "; " : ", ", " and ");
};

Parser.crToXp = function (cr, {isDouble = false} = {}) {
	if (cr != null && cr.xp) return Parser._addCommas(`${isDouble ? cr.xp * 2 : cr.xp}`);

	const toConvert = cr ? (cr.cr || cr) : null;
	if (toConvert === "Unknown" || toConvert == null || !Parser.XP_CHART_ALT[toConvert]) return "Unknown";
	if (toConvert === "0") return "0 or 10";
	const xp = Parser.XP_CHART_ALT[toConvert];
	return Parser._addCommas(`${isDouble ? 2 * xp : xp}`);
};

Parser.crToXpNumber = function (cr) {
	if (cr != null && cr.xp) return cr.xp;
	const toConvert = cr ? (cr.cr || cr) : cr;
	if (toConvert === "Unknown" || toConvert == null) return null;
	return Parser.XP_CHART_ALT[toConvert] ?? null;
};

Parser.LEVEL_TO_XP_EASY = [0, 25, 50, 75, 125, 250, 300, 350, 450, 550, 600, 800, 1000, 1100, 1250, 1400, 1600, 2000, 2100, 2400, 2800];
Parser.LEVEL_TO_XP_MEDIUM = [0, 50, 100, 150, 250, 500, 600, 750, 900, 1100, 1200, 1600, 2000, 2200, 2500, 2800, 3200, 3900, 4100, 4900, 5700];
Parser.LEVEL_TO_XP_HARD = [0, 75, 150, 225, 375, 750, 900, 1100, 1400, 1600, 1900, 2400, 3000, 3400, 3800, 4300, 4800, 5900, 6300, 7300, 8500];
Parser.LEVEL_TO_XP_DEADLY = [0, 100, 200, 400, 500, 1100, 1400, 1700, 2100, 2400, 2800, 3600, 4500, 5100, 5700, 6400, 7200, 8800, 9500, 10900, 12700];
Parser.LEVEL_TO_XP_DAILY = [0, 300, 600, 1200, 1700, 3500, 4000, 5000, 6000, 7500, 9000, 10500, 11500, 13500, 15000, 18000, 20000, 25000, 27000, 30000, 40000];

Parser.LEVEL_XP_REQUIRED = [0, 300, 900, 2700, 6500, 14000, 23000, 34000, 48000, 64000, 85000, 100000, 120000, 140000, 165000, 195000, 225000, 265000, 305000, 355000];

Parser.CRS = ["0", "1/8", "1/4", "1/2", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "30"];

Parser.levelToXpThreshold = function (level) {
	return [Parser.LEVEL_TO_XP_EASY[level], Parser.LEVEL_TO_XP_MEDIUM[level], Parser.LEVEL_TO_XP_HARD[level], Parser.LEVEL_TO_XP_DEADLY[level]];
};

Parser.isValidCr = function (cr) {
	return Parser.CRS.includes(cr);
};

Parser.crToNumber = function (cr) {
	if (cr === "Unknown" || cr === "\u2014" || cr == null) return VeCt.CR_UNKNOWN;
	if (cr.cr) return Parser.crToNumber(cr.cr);

	const parts = cr.trim().split("/");

	if (parts.length === 1) {
		if (isNaN(parts[0])) return VeCt.CR_CUSTOM;
		return Number(parts[0]);
	} else if (parts.length === 2) {
		if (isNaN(parts[0]) || isNaN(Number(parts[1]))) return VeCt.CR_CUSTOM;
		return Number(parts[0]) / Number(parts[1]);
	} else return 0;
};

Parser.numberToCr = function (number, safe) {
		if (safe && typeof number === "string" && Parser.CRS.includes(number)) return number;

	if (number == null) return "Unknown";

	return Parser.numberToFractional(number);
};

Parser.crToPb = function (cr) {
	if (cr === "Unknown" || cr == null) return 0;
	cr = cr.cr || cr;
	if (Parser.crToNumber(cr) < 5) return 2;
	return Math.ceil(cr / 4) + 1;
};

Parser.levelToPb = function (level) {
	if (!level) return 2;
	return Math.ceil(level / 4) + 1;
};

Parser.SKILL_TO_ATB_ABV = {
	"athletics": "str",
	"acrobatics": "dex",
	"sleight of hand": "dex",
	"stealth": "dex",
	"arcana": "int",
	"history": "int",
	"investigation": "int",
	"nature": "int",
	"religion": "int",
	"animal handling": "wis",
	"insight": "wis",
	"medicine": "wis",
	"perception": "wis",
	"survival": "wis",
	"deception": "cha",
	"intimidation": "cha",
	"performance": "cha",
	"persuasion": "cha",
};

Parser.skillToAbilityAbv = function (skill) {
	return Parser._parse_aToB(Parser.SKILL_TO_ATB_ABV, skill);
};

Parser.SKILL_TO_SHORT = {
	"athletics": "ath",
	"acrobatics": "acro",
	"sleight of hand": "soh",
	"stealth": "slth",
	"arcana": "arc",
	"history": "hist",
	"investigation": "invn",
	"nature": "natr",
	"religion": "reli",
	"animal handling": "hndl",
	"insight": "ins",
	"medicine": "med",
	"perception": "perp",
	"survival": "surv",
	"deception": "decp",
	"intimidation": "intm",
	"performance": "perf",
	"persuasion": "pers",
};

Parser.skillToShort = function (skill) {
	return Parser._parse_aToB(Parser.SKILL_TO_SHORT, skill);
};

Parser.LANGUAGES_STANDARD = [
	"Common",
	"Dwarvish",
	"Elvish",
	"Giant",
	"Gnomish",
	"Goblin",
	"Halfling",
	"Orc",
];

Parser.LANGUAGES_EXOTIC = [
	"Abyssal",
	"Aquan",
	"Auran",
	"Celestial",
	"Draconic",
	"Deep Speech",
	"Ignan",
	"Infernal",
	"Primordial",
	"Sylvan",
	"Terran",
	"Undercommon",
];

Parser.LANGUAGES_SECRET = [
	"Druidic",
	"Thieves' cant",
];

Parser.LANGUAGES_ALL = [
	...Parser.LANGUAGES_STANDARD,
	...Parser.LANGUAGES_EXOTIC,
	...Parser.LANGUAGES_SECRET,
].sort();

Parser.acToFull = function (ac, renderer) {
	if (typeof ac === "string") return ac; 
	renderer = renderer || Renderer.get();

	let stack = "";
	let inBraces = false;
	for (let i = 0; i < ac.length; ++i) {
		const cur = ac[i];
		const nxt = ac[i + 1];

		if (cur.special != null) {
			if (inBraces) inBraces = false;

			stack += cur.special;
		} else if (cur.ac) {
			const isNxtBraces = nxt && nxt.braces;

			if (!inBraces && cur.braces) {
				stack += "(";
				inBraces = true;
			}

			stack += cur.ac;

			if (cur.from) {
								if (cur.braces) {
					stack += " (";
				} else {
					stack += inBraces ? "; " : " (";
				}

				inBraces = true;

				stack += cur.from.map(it => renderer.render(it)).join(", ");

				if (cur.braces) {
					stack += ")";
				} else if (!isNxtBraces) {
					stack += ")";
					inBraces = false;
				}
			}

			if (cur.condition) stack += ` ${renderer.render(cur.condition)}`;

			if (inBraces && !isNxtBraces) {
				stack += ")";
				inBraces = false;
			}
		} else {
			stack += cur;
		}

		if (nxt) {
			if (nxt.braces) {
				stack += inBraces ? "; " : " (";
				inBraces = true;
			} else stack += ", ";
		}
	}
	if (inBraces) stack += ")";

	return stack.trim();
};

Parser.MONSTER_COUNT_TO_XP_MULTIPLIER = [1, 1.5, 2, 2, 2, 2, 2.5, 2.5, 2.5, 2.5, 3, 3, 3, 3, 4];
Parser.numMonstersToXpMult = function (num, playerCount = 3) {
	const baseVal = (() => {
		if (num >= Parser.MONSTER_COUNT_TO_XP_MULTIPLIER.length) return 4;
		return Parser.MONSTER_COUNT_TO_XP_MULTIPLIER[num - 1];
	})();

	if (playerCount < 3) return baseVal >= 3 ? baseVal + 1 : baseVal + 0.5;
	else if (playerCount > 5) {
		return baseVal === 4 ? 3 : baseVal - 0.5;
	} else return baseVal;
};

Parser.armorFullToAbv = function (armor) {
	return Parser._parse_bToA(Parser.ARMOR_ABV_TO_FULL, armor);
};

Parser.weaponFullToAbv = function (weapon) {
	return Parser._parse_bToA(Parser.WEAPON_ABV_TO_FULL, weapon);
};

Parser._getSourceStringFromSource = function (source) {
	if (source && source.source) return source.source;
	return source;
};
Parser._buildSourceCache = function (dict) {
	const out = {};
	Object.entries(dict).forEach(([k, v]) => out[k.toLowerCase()] = v);
	return out;
};
Parser._sourceJsonCache = null;
Parser.hasSourceJson = function (source) {
	Parser._sourceJsonCache = Parser._sourceJsonCache || Parser._buildSourceCache(Object.keys(Parser.SOURCE_JSON_TO_FULL).mergeMap(k => ({[k]: k})));
	return !!Parser._sourceJsonCache[source.toLowerCase()];
};
Parser._sourceFullCache = null;
Parser.hasSourceFull = function (source) {
	Parser._sourceFullCache = Parser._sourceFullCache || Parser._buildSourceCache(Parser.SOURCE_JSON_TO_FULL);
	return !!Parser._sourceFullCache[source.toLowerCase()];
};
Parser._sourceAbvCache = null;
Parser.hasSourceAbv = function (source) {
	Parser._sourceAbvCache = Parser._sourceAbvCache || Parser._buildSourceCache(Parser.SOURCE_JSON_TO_ABV);
	return !!Parser._sourceAbvCache[source.toLowerCase()];
};
Parser._sourceDateCache = null;
Parser.hasSourceDate = function (source) {
	Parser._sourceDateCache = Parser._sourceDateCache || Parser._buildSourceCache(Parser.SOURCE_JSON_TO_DATE);
	return !!Parser._sourceDateCache[source.toLowerCase()];
};
Parser.sourceJsonToJson = function (source) {
	source = Parser._getSourceStringFromSource(source);
	if (Parser.hasSourceJson(source)) return Parser._sourceJsonCache[source.toLowerCase()];
	if (typeof PrereleaseUtil !== "undefined" && PrereleaseUtil.hasSourceJson(source)) return PrereleaseUtil.sourceJsonToSource(source).json;
	if (typeof BrewUtil2 !== "undefined" && BrewUtil2.hasSourceJson(source)) return BrewUtil2.sourceJsonToSource(source).json;
	return source;
};
Parser.sourceJsonToFull = function (source) {
	source = Parser._getSourceStringFromSource(source);
	if (Parser.hasSourceFull(source)) return Parser._sourceFullCache[source.toLowerCase()].replace(/'/g, "\u2019");
	if (typeof PrereleaseUtil !== "undefined" && PrereleaseUtil.hasSourceJson(source)) return PrereleaseUtil.sourceJsonToFull(source).replace(/'/g, "\u2019");
	if (typeof BrewUtil2 !== "undefined" && BrewUtil2.hasSourceJson(source)) return BrewUtil2.sourceJsonToFull(source).replace(/'/g, "\u2019");
	return Parser._parse_aToB(Parser.SOURCE_JSON_TO_FULL, source).replace(/'/g, "\u2019");
};
Parser.sourceJsonToFullCompactPrefix = function (source) {
	return Parser.sourceJsonToFull(source)
		.replace(Parser.UA_PREFIX, Parser.UA_PREFIX_SHORT)
		.replace(/^Unearthed Arcana (\d+): /, "UA$1: ")
		.replace(Parser.AL_PREFIX, Parser.AL_PREFIX_SHORT)
		.replace(Parser.PS_PREFIX, Parser.PS_PREFIX_SHORT);
};
Parser.sourceJsonToAbv = function (source) {
	source = Parser._getSourceStringFromSource(source);
	if (Parser.hasSourceAbv(source)) return Parser._sourceAbvCache[source.toLowerCase()];
	if (typeof PrereleaseUtil !== "undefined" && PrereleaseUtil.hasSourceJson(source)) return PrereleaseUtil.sourceJsonToAbv(source);
	if (typeof BrewUtil2 !== "undefined" && BrewUtil2.hasSourceJson(source)) return BrewUtil2.sourceJsonToAbv(source);
	return Parser._parse_aToB(Parser.SOURCE_JSON_TO_ABV, source);
};
Parser.sourceJsonToDate = function (source) {
	source = Parser._getSourceStringFromSource(source);
	if (Parser.hasSourceDate(source)) return Parser._sourceDateCache[source.toLowerCase()];
	if (typeof PrereleaseUtil !== "undefined" && PrereleaseUtil.hasSourceJson(source)) return PrereleaseUtil.sourceJsonToDate(source);
	if (typeof BrewUtil2 !== "undefined" && BrewUtil2.hasSourceJson(source)) return BrewUtil2.sourceJsonToDate(source);
	return Parser._parse_aToB(Parser.SOURCE_JSON_TO_DATE, source, null);
};

Parser.sourceJsonToColor = function (source) {
	return `source${Parser.sourceJsonToAbv(source)}`;
};

Parser.sourceJsonToStyle = function (source) {
	source = Parser._getSourceStringFromSource(source);
	if (Parser.hasSourceJson(source)) return "";
	if (typeof PrereleaseUtil !== "undefined" && PrereleaseUtil.hasSourceJson(source)) return PrereleaseUtil.sourceJsonToStyle(source);
	if (typeof BrewUtil2 !== "undefined" && BrewUtil2.hasSourceJson(source)) return BrewUtil2.sourceJsonToStyle(source);
	return "";
};

Parser.sourceJsonToStylePart = function (source) {
	source = Parser._getSourceStringFromSource(source);
	if (Parser.hasSourceJson(source)) return "";
	if (typeof PrereleaseUtil !== "undefined" && PrereleaseUtil.hasSourceJson(source)) return PrereleaseUtil.sourceJsonToStylePart(source);
	if (typeof BrewUtil2 !== "undefined" && BrewUtil2.hasSourceJson(source)) return BrewUtil2.sourceJsonToStylePart(source);
	return "";
};

Parser.stringToSlug = function (str) {
	return str.trim().toLowerCase().toAscii().replace(/[^\w ]+/g, "").replace(/ +/g, "-");
};

Parser.stringToCasedSlug = function (str) {
	return str.toAscii().replace(/[^\w ]+/g, "").replace(/ +/g, "-");
};

Parser.ITEM_SPELLCASTING_FOCUS_CLASSES = ["Artificer", "Bard", "Cleric", "Druid", "Paladin", "Ranger", "Sorcerer", "Warlock", "Wizard"];

Parser.itemValueToFull = function (item, opts = {isShortForm: false, isSmallUnits: false}) {
	return Parser._moneyToFull(item, "value", "valueMult", opts);
};

Parser.itemValueToFullMultiCurrency = function (item, opts = {isShortForm: false, isSmallUnits: false}) {
	return Parser._moneyToFullMultiCurrency(item, "value", "valueMult", opts);
};

Parser.itemVehicleCostsToFull = function (item, isShortForm) {
	return {
		travelCostFull: Parser._moneyToFull(item, "travelCost", "travelCostMult", {isShortForm}),
		shippingCostFull: Parser._moneyToFull(item, "shippingCost", "shippingCostMult", {isShortForm}),
	};
};

Parser.spellComponentCostToFull = function (item, isShortForm) {
	return Parser._moneyToFull(item, "cost", "costMult", {isShortForm});
};

Parser.vehicleCostToFull = function (item, isShortForm) {
	return Parser._moneyToFull(item, "cost", "costMult", {isShortForm});
};

Parser._moneyToFull = function (it, prop, propMult, opts = {isShortForm: false, isSmallUnits: false}) {
	if (it[prop] == null && it[propMult] == null) return "";
	if (it[prop] != null) {
		const {coin, mult} = Parser.getCurrencyAndMultiplier(it[prop], it.currencyConversion);
		return `${(it[prop] * mult).toLocaleString(undefined, {maximumFractionDigits: 5})}${opts.isSmallUnits ? `<span class="small ml-1">${coin}</span>` : ` ${coin}`}`;
	} else if (it[propMult] != null) return opts.isShortForm ? `×${it[propMult]}` : `base value ×${it[propMult]}`;
	return "";
};

Parser._moneyToFullMultiCurrency = function (it, prop, propMult, {isShortForm, multiplier} = {}) {
	if (it[prop]) {
		const conversionTable = Parser.getCurrencyConversionTable(it.currencyConversion);

		const simplified = it.currencyConversion
			? CurrencyUtil.doSimplifyCoins(
				{
										[conversionTable[0]?.coin || "cp"]: it[prop] * (multiplier ?? conversionTable[0]?.mult ?? 1),
				},
				{
					currencyConversionId: it.currencyConversion,
				},
			)
			: CurrencyUtil.doSimplifyCoins({
				cp: it[prop] * (multiplier ?? 1),
			});

		return [...conversionTable]
			.reverse()
			.filter(meta => simplified[meta.coin])
			.map(meta => `${simplified[meta.coin].toLocaleString(undefined, {maximumFractionDigits: 5})} ${meta.coin}`)
			.join(", ");
	}

	if (it[propMult]) return isShortForm ? `×${it[propMult]}` : `base value ×${it[propMult]}`;

	return "";
};

Parser.DEFAULT_CURRENCY_CONVERSION_TABLE = [
	{
		coin: "cp",
		mult: 1,
	},
	{
		coin: "sp",
		mult: 0.1,
	},
	{
		coin: "gp",
		mult: 0.01,
		isFallback: true,
	},
];
Parser.FULL_CURRENCY_CONVERSION_TABLE = [
	{
		coin: "cp",
		mult: 1,
	},
	{
		coin: "sp",
		mult: 0.1,
	},
	{
		coin: "ep",
		mult: 0.02,
	},
	{
		coin: "gp",
		mult: 0.01,
		isFallback: true,
	},
	{
		coin: "pp",
		mult: 0.001,
	},
];
Parser.getCurrencyConversionTable = function (currencyConversionId) {
	const fromPrerelease = currencyConversionId ? PrereleaseUtil.getMetaLookup("currencyConversions")?.[currencyConversionId] : null;
	const fromBrew = currencyConversionId ? BrewUtil2.getMetaLookup("currencyConversions")?.[currencyConversionId] : null;
	const conversionTable = fromPrerelease?.length
		? fromPrerelease
		: fromBrew?.length
			? fromBrew
			: Parser.DEFAULT_CURRENCY_CONVERSION_TABLE;
	if (conversionTable !== Parser.DEFAULT_CURRENCY_CONVERSION_TABLE) conversionTable.sort((a, b) => SortUtil.ascSort(b.mult, a.mult));
	return conversionTable;
};
Parser.getCurrencyAndMultiplier = function (value, currencyConversionId) {
	const conversionTable = Parser.getCurrencyConversionTable(currencyConversionId);

	if (!value) return conversionTable.find(it => it.isFallback) || conversionTable[0];
	if (conversionTable.length === 1) return conversionTable[0];
	if (!Number.isInteger(value) && value < conversionTable[0].mult) return conversionTable[0];

	for (let i = conversionTable.length - 1; i >= 0; --i) {
		if (Number.isInteger(value * conversionTable[i].mult)) return conversionTable[i];
	}

	return conversionTable.last();
};

Parser.COIN_ABVS = ["cp", "sp", "ep", "gp", "pp"];
Parser.COIN_ABV_TO_FULL = {
	"cp": "copper pieces",
	"sp": "silver pieces",
	"ep": "electrum pieces",
	"gp": "gold pieces",
	"pp": "platinum pieces",
};
Parser.COIN_CONVERSIONS = [1, 10, 50, 100, 1000];

Parser.coinAbvToFull = function (coin) {
	return Parser._parse_aToB(Parser.COIN_ABV_TO_FULL, coin);
};

Parser.getDisplayCurrency = function (currency, {isDisplayEmpty = false} = {}) {
	return [...Parser.COIN_ABVS]
		.reverse()
		.filter(abv => isDisplayEmpty ? currency[abv] != null : currency[abv])
		.map(abv => `${currency[abv].toLocaleString()} ${abv}`)
		.join(", ");
};

Parser.itemWeightToFull = function (item, isShortForm) {
	if (item.weight) {
				if (Math.round(item.weight) === item.weight) return `${item.weight} lb.${(item.weightNote ? ` ${item.weightNote}` : "")}`;

		const integerPart = Math.floor(item.weight);

				const vulgarGlyph = Parser.numberToVulgar(item.weight - integerPart, {isFallbackOnFractional: false});
		if (vulgarGlyph) return `${integerPart || ""}${vulgarGlyph} lb.${(item.weightNote ? ` ${item.weightNote}` : "")}`;

				return `${(item.weight < 1 ? item.weight * 16 : item.weight).toLocaleString(undefined, {maximumFractionDigits: 5})} ${item.weight < 1 ? "oz" : "lb"}.${(item.weightNote ? ` ${item.weightNote}` : "")}`;
	}
	if (item.weightMult) return isShortForm ? `×${item.weightMult}` : `base weight ×${item.weightMult}`;
	return "";
};

Parser.ITEM_RECHARGE_TO_FULL = {
	round: "Every Round",
	restShort: "Short Rest",
	restLong: "Long Rest",
	dawn: "Dawn",
	dusk: "Dusk",
	midnight: "Midnight",
	special: "Special",
};
Parser.itemRechargeToFull = function (recharge) {
	return Parser._parse_aToB(Parser.ITEM_RECHARGE_TO_FULL, recharge);
};

Parser.ITEM_MISC_TAG_TO_FULL = {
	"CF/W": "Creates Food/Water",
};
Parser.itemMiscTagToFull = function (type) {
	return Parser._parse_aToB(Parser.ITEM_MISC_TAG_TO_FULL, type);
};

Parser._decimalSeparator = (0.1).toLocaleString().substring(1, 2);
Parser._numberCleanRegexp = Parser._decimalSeparator === "." ? new RegExp(/[\s,]*/g, "g") : new RegExp(/[\s.]*/g, "g");
Parser._costSplitRegexp = Parser._decimalSeparator === "." ? new RegExp(/(\d+(\.\d+)?)([csegp]p)/) : new RegExp(/(\d+(,\d+)?)([csegp]p)/);

Parser.coinValueToNumber = function (value) {
	if (!value) return 0;
		if (value === "Varies") return 0;

	value = value
		.replace(/\s*/, "")
		.replace(Parser._numberCleanRegexp, "")
		.toLowerCase();
	const m = Parser._costSplitRegexp.exec(value);
	if (!m) throw new Error(`Badly formatted value "${value}"`);
	const ixCoin = Parser.COIN_ABVS.indexOf(m[3]);
	if (!~ixCoin) throw new Error(`Unknown coin type "${m[3]}"`);
	return Number(m[1]) * Parser.COIN_CONVERSIONS[ixCoin];
};

Parser.weightValueToNumber = function (value) {
	if (!value) return 0;

	if (Number(value)) return Number(value);
	else throw new Error(`Badly formatted value ${value}`);
};

Parser.dmgTypeToFull = function (dmgType) {
	return Parser._parse_aToB(Parser.DMGTYPE_JSON_TO_FULL, dmgType);
};

Parser.skillProficienciesToFull = function (skillProficiencies) {
	function renderSingle (skProf) {
		if (skProf.any) {
			skProf = MiscUtil.copyFast(skProf);
			skProf.choose = {"from": Object.keys(Parser.SKILL_TO_ATB_ABV), "count": skProf.any};
			delete skProf.any;
		}

		const keys = Object.keys(skProf).sort(SortUtil.ascSortLower);

		const ixChoose = keys.indexOf("choose");
		if (~ixChoose) keys.splice(ixChoose, 1);

		const baseStack = [];
		keys.filter(k => skProf[k]).forEach(k => baseStack.push(Renderer.get().render(`{@skill ${k.toTitleCase()}}`)));

		const chooseStack = [];
		if (~ixChoose) {
			const chObj = skProf.choose;
			if (chObj.from.length === 18) {
				chooseStack.push(`choose any ${!chObj.count || chObj.count === 1 ? "skill" : chObj.count}`);
			} else {
				chooseStack.push(`choose ${chObj.count || 1} from ${chObj.from.map(it => Renderer.get().render(`{@skill ${it.toTitleCase()}}`)).joinConjunct(", ", " and ")}`);
			}
		}

		const base = baseStack.joinConjunct(", ", " and ");
		const choose = chooseStack.join(""); 
		if (baseStack.length && chooseStack.length) return `${base}; and ${choose}`;
		else if (baseStack.length) return base;
		else if (chooseStack.length) return choose;
	}

	return skillProficiencies.map(renderSingle).join(" <i>or</i> ");
};

Parser.spSchoolAndSubschoolsAbvsToFull = function (school, subschools) {
	if (!subschools || !subschools.length) return Parser.spSchoolAbvToFull(school);
	else return `${Parser.spSchoolAbvToFull(school)} (${subschools.map(sub => Parser.spSchoolAbvToFull(sub)).join(", ")})`;
};

Parser.spSchoolAbvToFull = function (schoolOrSubschool) {
	const out = Parser._parse_aToB(Parser.SP_SCHOOL_ABV_TO_FULL, schoolOrSubschool);
	if (Parser.SP_SCHOOL_ABV_TO_FULL[schoolOrSubschool]) return out;
	if (PrereleaseUtil.getMetaLookup("spellSchools")?.[schoolOrSubschool]) return PrereleaseUtil.getMetaLookup("spellSchools")?.[schoolOrSubschool].full;
	if (BrewUtil2.getMetaLookup("spellSchools")?.[schoolOrSubschool]) return BrewUtil2.getMetaLookup("spellSchools")?.[schoolOrSubschool].full;
	return out;
};

Parser.spSchoolAndSubschoolsAbvsShort = function (school, subschools) {
	if (!subschools || !subschools.length) return Parser.spSchoolAbvToShort(school);
	else return `${Parser.spSchoolAbvToShort(school)} (${subschools.map(sub => Parser.spSchoolAbvToShort(sub)).join(", ")})`;
};

Parser.spSchoolAbvToShort = function (school) {
	const out = Parser._parse_aToB(Parser.SP_SCHOOL_ABV_TO_SHORT, school);
	if (Parser.SP_SCHOOL_ABV_TO_SHORT[school]) return out;
	if (PrereleaseUtil.getMetaLookup("spellSchools")?.[school]) return PrereleaseUtil.getMetaLookup("spellSchools")?.[school].short;
	if (BrewUtil2.getMetaLookup("spellSchools")?.[school]) return BrewUtil2.getMetaLookup("spellSchools")?.[school].short;
	return out;
};

Parser.spSchoolAbvToStyle = function (school) { 	const stylePart = Parser.spSchoolAbvToStylePart(school);
	if (!stylePart) return stylePart;
	return `style="${stylePart}"`;
};

Parser.spSchoolAbvToStylePart = function (school) { 	return Parser._spSchoolAbvToStylePart_prereleaseBrew({school, brewUtil: PrereleaseUtil})
		|| Parser._spSchoolAbvToStylePart_prereleaseBrew({school, brewUtil: BrewUtil2})
		|| "";
};

Parser._spSchoolAbvToStylePart_prereleaseBrew = function ({school, brewUtil}) {
	const rawColor = brewUtil.getMetaLookup("spellSchools")?.[school]?.color;
	if (!rawColor || !rawColor.trim()) return "";
	const validColor = BrewUtilShared.getValidColor(rawColor);
	if (validColor.length) return `color: #${validColor};`;
};

Parser.getOrdinalForm = function (i) {
	i = Number(i);
	if (isNaN(i)) return "";
	const j = i % 10; const k = i % 100;
	if (j === 1 && k !== 11) return `${i}st`;
	if (j === 2 && k !== 12) return `${i}nd`;
	if (j === 3 && k !== 13) return `${i}rd`;
	return `${i}th`;
};

Parser.spLevelToFull = function (level) {
	if (level === 0) return "Cantrip";
	else return Parser.getOrdinalForm(level);
};

Parser.getArticle = function (str) {
	str = `${str}`;
	str = str.replace(/\d+/g, (...m) => Parser.numberToText(m[0]));
	return /^[aeiou]/i.test(str) ? "an" : "a";
};

Parser.spLevelToFullLevelText = function (level, dash) {
	return `${Parser.spLevelToFull(level)}${(level === 0 ? "s" : `${dash ? "-" : " "}level`)}`;
};

Parser.spLevelToSpellPoints = function (lvl) {
	lvl = Number(lvl);
	if (isNaN(lvl) || lvl === 0) return 0;
	return Math.ceil(1.34 * lvl);
};

Parser.spMetaToArr = function (meta) {
	if (!meta) return [];
	return Object.entries(meta)
		.filter(([_, v]) => v)
		.sort(SortUtil.ascSort)
		.map(([k]) => k);
};

Parser.spMetaToFull = function (meta) {
	if (!meta) return "";
	const metaTags = Parser.spMetaToArr(meta);
	if (metaTags.length) return ` (${metaTags.join(", ")})`;
	return "";
};

Parser.spLevelSchoolMetaToFull = function (level, school, meta, subschools) {
	const levelPart = level === 0 ? Parser.spLevelToFull(level).toLowerCase() : `${Parser.spLevelToFull(level)}-level`;
	const levelSchoolStr = level === 0 ? `${Parser.spSchoolAbvToFull(school)} ${levelPart}` : `${levelPart} ${Parser.spSchoolAbvToFull(school).toLowerCase()}`;

	const metaArr = Parser.spMetaToArr(meta);
	if (metaArr.length || (subschools && subschools.length)) {
		const metaAndSubschoolPart = [
			(subschools || []).map(sub => Parser.spSchoolAbvToFull(sub)).join(", "),
			metaArr.join(", "),
		].filter(Boolean).join("; ").toLowerCase();
		return `${levelSchoolStr} (${metaAndSubschoolPart})`;
	}
	return levelSchoolStr;
};

Parser.spTimeListToFull = function (times, isStripTags) {
	return times.map(t => `${Parser.getTimeToFull(t)}${t.condition ? `, ${isStripTags ? Renderer.stripTags(t.condition) : Renderer.get().render(t.condition)}` : ""}`).join(" or ");
};

Parser.getTimeToFull = function (time) {
	return `${time.number ? `${time.number} ` : ""}${time.unit === "bonus" ? "bonus action" : time.unit}${time.number > 1 ? "s" : ""}`;
};

Parser.RNG_SPECIAL = "special";
Parser.RNG_POINT = "point";
Parser.RNG_LINE = "line";
Parser.RNG_CUBE = "cube";
Parser.RNG_CONE = "cone";
Parser.RNG_RADIUS = "radius";
Parser.RNG_SPHERE = "sphere";
Parser.RNG_HEMISPHERE = "hemisphere";
Parser.RNG_CYLINDER = "cylinder"; Parser.RNG_SELF = "self";
Parser.RNG_SIGHT = "sight";
Parser.RNG_UNLIMITED = "unlimited";
Parser.RNG_UNLIMITED_SAME_PLANE = "plane";
Parser.RNG_TOUCH = "touch";
Parser.SP_RANGE_TYPE_TO_FULL = {
	[Parser.RNG_SPECIAL]: "Special",
	[Parser.RNG_POINT]: "Point",
	[Parser.RNG_LINE]: "Line",
	[Parser.RNG_CUBE]: "Cube",
	[Parser.RNG_CONE]: "Cone",
	[Parser.RNG_RADIUS]: "Radius",
	[Parser.RNG_SPHERE]: "Sphere",
	[Parser.RNG_HEMISPHERE]: "Hemisphere",
	[Parser.RNG_CYLINDER]: "Cylinder",
	[Parser.RNG_SELF]: "Self",
	[Parser.RNG_SIGHT]: "Sight",
	[Parser.RNG_UNLIMITED]: "Unlimited",
	[Parser.RNG_UNLIMITED_SAME_PLANE]: "Unlimited on the same plane",
	[Parser.RNG_TOUCH]: "Touch",
};

Parser.spRangeTypeToFull = function (range) {
	return Parser._parse_aToB(Parser.SP_RANGE_TYPE_TO_FULL, range);
};

Parser.UNT_FEET = "feet";
Parser.UNT_YARDS = "yards";
Parser.UNT_MILES = "miles";
Parser.SP_DIST_TYPE_TO_FULL = {
	[Parser.UNT_FEET]: "Feet",
	[Parser.UNT_YARDS]: "Yards",
	[Parser.UNT_MILES]: "Miles",
	[Parser.RNG_SELF]: Parser.SP_RANGE_TYPE_TO_FULL[Parser.RNG_SELF],
	[Parser.RNG_TOUCH]: Parser.SP_RANGE_TYPE_TO_FULL[Parser.RNG_TOUCH],
	[Parser.RNG_SIGHT]: Parser.SP_RANGE_TYPE_TO_FULL[Parser.RNG_SIGHT],
	[Parser.RNG_UNLIMITED]: Parser.SP_RANGE_TYPE_TO_FULL[Parser.RNG_UNLIMITED],
	[Parser.RNG_UNLIMITED_SAME_PLANE]: Parser.SP_RANGE_TYPE_TO_FULL[Parser.RNG_UNLIMITED_SAME_PLANE],
};

Parser.spDistanceTypeToFull = function (range) {
	return Parser._parse_aToB(Parser.SP_DIST_TYPE_TO_FULL, range);
};

Parser.SP_RANGE_TO_ICON = {
	[Parser.RNG_SPECIAL]: "fa-star",
	[Parser.RNG_POINT]: "",
	[Parser.RNG_LINE]: "fa-grip-lines-vertical",
	[Parser.RNG_CUBE]: "fa-cube",
	[Parser.RNG_CONE]: "fa-traffic-cone",
	[Parser.RNG_RADIUS]: "fa-hockey-puck",
	[Parser.RNG_SPHERE]: "fa-globe",
	[Parser.RNG_HEMISPHERE]: "fa-globe",
	[Parser.RNG_CYLINDER]: "fa-database",
	[Parser.RNG_SELF]: "fa-street-view",
	[Parser.RNG_SIGHT]: "fa-eye",
	[Parser.RNG_UNLIMITED_SAME_PLANE]: "fa-globe-americas",
	[Parser.RNG_UNLIMITED]: "fa-infinity",
	[Parser.RNG_TOUCH]: "fa-hand-paper",
};

Parser.spRangeTypeToIcon = function (range) {
	return Parser._parse_aToB(Parser.SP_RANGE_TO_ICON, range);
};

Parser.spRangeToShortHtml = function (range) {
	switch (range.type) {
		case Parser.RNG_SPECIAL: return `<span class="fas fa-fw ${Parser.spRangeTypeToIcon(range.type)} help-subtle" title="Special"></span>`;
		case Parser.RNG_POINT: return Parser.spRangeToShortHtml._renderPoint(range);
		case Parser.RNG_LINE:
		case Parser.RNG_CUBE:
		case Parser.RNG_CONE:
		case Parser.RNG_RADIUS:
		case Parser.RNG_SPHERE:
		case Parser.RNG_HEMISPHERE:
		case Parser.RNG_CYLINDER:
			return Parser.spRangeToShortHtml._renderArea(range);
	}
};
Parser.spRangeToShortHtml._renderPoint = function (range) {
	const dist = range.distance;
	switch (dist.type) {
		case Parser.RNG_SELF:
		case Parser.RNG_SIGHT:
		case Parser.RNG_UNLIMITED:
		case Parser.RNG_UNLIMITED_SAME_PLANE:
		case Parser.RNG_SPECIAL:
		case Parser.RNG_TOUCH: return `<span class="fas fa-fw ${Parser.spRangeTypeToIcon(dist.type)} help-subtle" title="${Parser.spRangeTypeToFull(dist.type)}"></span>`;
		case Parser.UNT_FEET:
		case Parser.UNT_YARDS:
		case Parser.UNT_MILES:
		default:
			return `${dist.amount} <span class="ve-small">${Parser.getSingletonUnit(dist.type, true)}</span>`;
	}
};
Parser.spRangeToShortHtml._renderArea = function (range) {
	const size = range.distance;
	return `<span class="fas fa-fw ${Parser.spRangeTypeToIcon(Parser.RNG_SELF)} help-subtle" title="Self"></span> ${size.amount}<span class="ve-small">-${Parser.getSingletonUnit(size.type, true)}</span> ${Parser.spRangeToShortHtml._getAreaStyleString(range)}`;
};
Parser.spRangeToShortHtml._getAreaStyleString = function (range) {
	return `<span class="fas fa-fw ${Parser.spRangeTypeToIcon(range.type)} help-subtle" title="${Parser.spRangeTypeToFull(range.type)}"></span>`;
};

Parser.spRangeToFull = function (range) {
	switch (range.type) {
		case Parser.RNG_SPECIAL: return Parser.spRangeTypeToFull(range.type);
		case Parser.RNG_POINT: return Parser.spRangeToFull._renderPoint(range);
		case Parser.RNG_LINE:
		case Parser.RNG_CUBE:
		case Parser.RNG_CONE:
		case Parser.RNG_RADIUS:
		case Parser.RNG_SPHERE:
		case Parser.RNG_HEMISPHERE:
		case Parser.RNG_CYLINDER:
			return Parser.spRangeToFull._renderArea(range);
	}
};
Parser.spRangeToFull._renderPoint = function (range) {
	const dist = range.distance;
	switch (dist.type) {
		case Parser.RNG_SELF:
		case Parser.RNG_SIGHT:
		case Parser.RNG_UNLIMITED:
		case Parser.RNG_UNLIMITED_SAME_PLANE:
		case Parser.RNG_SPECIAL:
		case Parser.RNG_TOUCH: return Parser.spRangeTypeToFull(dist.type);
		case Parser.UNT_FEET:
		case Parser.UNT_YARDS:
		case Parser.UNT_MILES:
		default:
			return `${dist.amount} ${dist.amount === 1 ? Parser.getSingletonUnit(dist.type) : dist.type}`;
	}
};
Parser.spRangeToFull._renderArea = function (range) {
	const size = range.distance;
	return `Self (${size.amount}-${Parser.getSingletonUnit(size.type)}${Parser.spRangeToFull._getAreaStyleString(range)}${range.type === Parser.RNG_CYLINDER ? `${size.amountSecondary != null && size.typeSecondary != null ? `, ${size.amountSecondary}-${Parser.getSingletonUnit(size.typeSecondary)}-high` : ""} cylinder` : ""})`;
};
Parser.spRangeToFull._getAreaStyleString = function (range) {
	switch (range.type) {
		case Parser.RNG_SPHERE: return " radius";
		case Parser.RNG_HEMISPHERE: return `-radius ${range.type}`;
		case Parser.RNG_CYLINDER: return "-radius";
		default: return ` ${range.type}`;
	}
};

Parser.getSingletonUnit = function (unit, isShort) {
	switch (unit) {
		case Parser.UNT_FEET:
			return isShort ? "ft." : "foot";
		case Parser.UNT_YARDS:
			return isShort ? "yd." : "yard";
		case Parser.UNT_MILES:
			return isShort ? "mi." : "mile";
		default: {
			const fromPrerelease = Parser._getSingletonUnit_prereleaseBrew({unit, isShort, brewUtil: PrereleaseUtil});
			if (fromPrerelease) return fromPrerelease;

			const fromBrew = Parser._getSingletonUnit_prereleaseBrew({unit, isShort, brewUtil: BrewUtil2});
			if (fromBrew) return fromBrew;

			if (unit.charAt(unit.length - 1) === "s") return unit.slice(0, -1);
			return unit;
		}
	}
};

Parser._getSingletonUnit_prereleaseBrew = function ({unit, isShort, brewUtil}) {
	const fromBrew = brewUtil.getMetaLookup("spellDistanceUnits")?.[unit]?.["singular"];
	if (fromBrew) return fromBrew;
};

Parser.RANGE_TYPES = [
	{type: Parser.RNG_POINT, hasDistance: true, isRequireAmount: false},

	{type: Parser.RNG_LINE, hasDistance: true, isRequireAmount: true},
	{type: Parser.RNG_CUBE, hasDistance: true, isRequireAmount: true},
	{type: Parser.RNG_CONE, hasDistance: true, isRequireAmount: true},
	{type: Parser.RNG_RADIUS, hasDistance: true, isRequireAmount: true},
	{type: Parser.RNG_SPHERE, hasDistance: true, isRequireAmount: true},
	{type: Parser.RNG_HEMISPHERE, hasDistance: true, isRequireAmount: true},
	{type: Parser.RNG_CYLINDER, hasDistance: true, isRequireAmount: true},

	{type: Parser.RNG_SPECIAL, hasDistance: false, isRequireAmount: false},
];

Parser.DIST_TYPES = [
	{type: Parser.RNG_SELF, hasAmount: false},
	{type: Parser.RNG_TOUCH, hasAmount: false},

	{type: Parser.UNT_FEET, hasAmount: true},
	{type: Parser.UNT_YARDS, hasAmount: true},
	{type: Parser.UNT_MILES, hasAmount: true},

	{type: Parser.RNG_SIGHT, hasAmount: false},
	{type: Parser.RNG_UNLIMITED_SAME_PLANE, hasAmount: false},
	{type: Parser.RNG_UNLIMITED, hasAmount: false},
];

Parser.spComponentsToFull = function (comp, level, {isPlainText = false} = {}) {
	if (!comp) return "None";
	const out = [];
	if (comp.v) out.push("V");
	if (comp.s) out.push("S");
	if (comp.m != null) {
		const fnRender = isPlainText ? Renderer.stripTags.bind(Renderer) : Renderer.get().render.bind(Renderer.get());
		out.push(`M${comp.m !== true ? ` (${fnRender(comp.m.text != null ? comp.m.text : comp.m)})` : ""}`);
	}
	if (comp.r) out.push(`R (${level} gp)`);
	return out.join(", ") || "None";
};

Parser.SP_END_TYPE_TO_FULL = {
	"dispel": "dispelled",
	"trigger": "triggered",
	"discharge": "discharged",
};
Parser.spEndTypeToFull = function (type) {
	return Parser._parse_aToB(Parser.SP_END_TYPE_TO_FULL, type);
};

Parser.spDurationToFull = function (dur) {
	let hasSubOr = false;
	const outParts = dur.map(d => {
		switch (d.type) {
			case "special":
				return "Special";
			case "instant":
				return `Instantaneous${d.condition ? ` (${d.condition})` : ""}`;
			case "timed":
				return `${d.concentration ? "Concentration, " : ""}${d.concentration ? "u" : d.duration.upTo ? "U" : ""}${d.concentration || d.duration.upTo ? "p to " : ""}${d.duration.amount} ${d.duration.amount === 1 ? d.duration.type : `${d.duration.type}s`}`;
			case "permanent": {
				if (d.ends) {
					const endsToJoin = d.ends.map(m => Parser.spEndTypeToFull(m));
					hasSubOr = hasSubOr || endsToJoin.length > 1;
					return `Until ${endsToJoin.joinConjunct(", ", " or ")}`;
				} else {
					return "Permanent";
				}
			}
		}
	});
	return `${outParts.joinConjunct(hasSubOr ? "; " : ", ", " or ")}${dur.length > 1 ? " (see below)" : ""}`;
};

Parser.DURATION_TYPES = [
	{type: "instant", full: "Instantaneous"},
	{type: "timed", hasAmount: true},
	{type: "permanent", hasEnds: true},
	{type: "special"},
];

Parser.DURATION_AMOUNT_TYPES = [
	"turn",
	"round",
	"minute",
	"hour",
	"day",
	"week",
	"year",
];

Parser.spClassesToFull = function (sp, {isTextOnly = false, subclassLookup = {}} = {}) {
	const fromSubclassList = Renderer.spell.getCombinedClasses(sp, "fromSubclass");
	const fromSubclasses = Parser.spSubclassesToFull(fromSubclassList, {isTextOnly, subclassLookup});
	const fromClassList = Renderer.spell.getCombinedClasses(sp, "fromClassList");
	return `${Parser.spMainClassesToFull(fromClassList, {isTextOnly})}${fromSubclasses ? `, ${fromSubclasses}` : ""}`;
};

Parser.spMainClassesToFull = function (fromClassList, {isTextOnly = false} = {}) {
	return fromClassList
		.map(c => ({hash: UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES](c), c}))
		.filter(it => !ExcludeUtil.isInitialised || !ExcludeUtil.isExcluded(it.hash, "class", it.c.source))
		.sort((a, b) => SortUtil.ascSort(a.c.name, b.c.name))
		.map(it => {
			if (isTextOnly) return it.c.name;

			return `<span title="${it.c.definedInSource ? `Class source` : "Source"}: ${Parser.sourceJsonToFull(it.c.source)}${it.c.definedInSource ? `. Spell list defined in: ${Parser.sourceJsonToFull(it.c.definedInSource)}.` : ""}">${Renderer.get().render(`{@class ${it.c.name}|${it.c.source}}`)}</span>`;
		})
		.join(", ") || "";
};

Parser.spSubclassesToFull = function (fromSubclassList, {isTextOnly = false, subclassLookup = {}} = {}) {
	return fromSubclassList
		.filter(mt => {
			if (!ExcludeUtil.isInitialised) return true;
			const excludeClass = ExcludeUtil.isExcluded(UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES](mt.class), "class", mt.class.source);
			if (excludeClass) return false;

			return !ExcludeUtil.isExcluded(
				UrlUtil.URL_TO_HASH_BUILDER["subclass"]({
					shortName: mt.subclass.name,
					source: mt.subclass.source,
					className: mt.class.name,
					classSource: mt.class.source,
				}),
				"subclass",
				mt.subclass.source,
				{isNoCount: true},
			);
		})
		.sort((a, b) => {
			const byName = SortUtil.ascSort(a.class.name, b.class.name);
			return byName || SortUtil.ascSort(a.subclass.name, b.subclass.name);
		})
		.map(c => Parser._spSubclassItem({fromSubclass: c, isTextOnly}))
		.join(", ") || "";
};

Parser._spSubclassItem = function ({fromSubclass, isTextOnly}) {
	const c = fromSubclass.class;
	const sc = fromSubclass.subclass;
	const text = `${sc.shortName}${sc.subSubclass ? ` (${sc.subSubclass})` : ""}`;
	if (isTextOnly) return text;

	const classPart = `<span title="Source: ${Parser.sourceJsonToFull(c.source)}${c.definedInSource ? ` From a class spell list defined in: ${Parser.sourceJsonToFull(c.definedInSource)}` : ""}">${Renderer.get().render(`{@class ${c.name}|${c.source}}`)}</span>`;

	return `<span class="italic" title="Source: ${Parser.sourceJsonToFull(fromSubclass.subclass.source)}">${Renderer.get().render(`{@class ${c.name}|${c.source}|${text}|${sc.shortName}|${sc.source}}`)}</span> ${classPart}`;
};

Parser.SPELL_ATTACK_TYPE_TO_FULL = {};
Parser.SPELL_ATTACK_TYPE_TO_FULL["M"] = "Melee";
Parser.SPELL_ATTACK_TYPE_TO_FULL["R"] = "Ranged";
Parser.SPELL_ATTACK_TYPE_TO_FULL["O"] = "Other/Unknown";

Parser.spAttackTypeToFull = function (type) {
	return Parser._parse_aToB(Parser.SPELL_ATTACK_TYPE_TO_FULL, type);
};

Parser.SPELL_AREA_TYPE_TO_FULL = {
	ST: "Single Target",
	MT: "Multiple Targets",
	C: "Cube",
	N: "Cone",
	Y: "Cylinder",
	S: "Sphere",
	R: "Circle",
	Q: "Square",
	L: "Line",
	H: "Hemisphere",
	W: "Wall",
};
Parser.spAreaTypeToFull = function (type) {
	return Parser._parse_aToB(Parser.SPELL_AREA_TYPE_TO_FULL, type);
};

Parser.SP_MISC_TAG_TO_FULL = {
	HL: "Healing",
	THP: "Grants Temporary Hit Points",
	SGT: "Requires Sight",
	PRM: "Permanent Effects",
	SCL: "Scaling Effects",
	SMN: "Summons Creature",
	MAC: "Modifies AC",
	TP: "Teleportation",
	FMV: "Forced Movement",
	RO: "Rollable Effects",
	LGTS: "Creates Sunlight",
	LGT: "Creates Light",
	UBA: "Uses Bonus Action",
	PS: "Plane Shifting",
	OBS: "Obscures Vision",
	DFT: "Difficult Terrain",
	AAD: "Additional Attack Damage",
	OBJ: "Affects Objects",
};
Parser.spMiscTagToFull = function (type) {
	return Parser._parse_aToB(Parser.SP_MISC_TAG_TO_FULL, type);
};

Parser.SP_CASTER_PROGRESSION_TO_FULL = {
	full: "Full",
	"1/2": "Half",
	"1/3": "One-Third",
	"pact": "Pact Magic",
};
Parser.spCasterProgressionToFull = function (type) {
	return Parser._parse_aToB(Parser.SP_CASTER_PROGRESSION_TO_FULL, type);
};

Parser.monTypeToFullObj = function (type) {
	const out = {
		types: [],
		tags: [],
		asText: "",
		asTextShort: "",

		typeSidekick: null,
		tagsSidekick: [],
		asTextSidekick: null,
	};

		if (typeof type === "string") {
		out.types = [type];
		out.asText = type.toTitleCase();
		out.asTextShort = out.asText;
		return out;
	}

	if (type.type?.choose) {
		out.types = type.type.choose;
	} else {
		out.types = [type.type];
	}

	if (type.swarmSize) {
		out.tags.push("swarm");
		out.asText = `swarm of ${Parser.sizeAbvToFull(type.swarmSize)} ${out.types.map(typ => Parser.monTypeToPlural(typ).toTitleCase()).joinConjunct(", ", " or ")}`;
		out.asTextShort = out.asText;
		out.swarmSize = type.swarmSize;
	} else {
		out.asText = out.types.map(typ => typ.toTitleCase()).joinConjunct(", ", " or ");
		out.asTextShort = out.asText;
	}

	const tagMetas = Parser.monTypeToFullObj._getTagMetas(type.tags);
	if (tagMetas.length) {
		out.tags.push(...tagMetas.map(({filterTag}) => filterTag));
		const ptTags = ` (${tagMetas.map(({displayTag}) => displayTag).join(", ")})`;
		out.asText += ptTags;
		out.asTextShort += ptTags;
	}

	if (type.note) out.asText += ` ${type.note}`;

		if (type.sidekickType) {
		out.typeSidekick = type.sidekickType;
		if (!type.sidekickHidden) out.asTextSidekick = `${type.sidekickType}`;

		const tagMetas = Parser.monTypeToFullObj._getTagMetas(type.sidekickTags);
		if (tagMetas.length) {
			out.tagsSidekick.push(...tagMetas.map(({filterTag}) => filterTag));
			if (!type.sidekickHidden) out.asTextSidekick += ` (${tagMetas.map(({displayTag}) => displayTag).join(", ")})`;
		}
	}
	
	return out;
};

Parser.monTypeToFullObj._getTagMetas = (tags) => {
	return tags
		? tags.map(tag => {
			if (typeof tag === "string") { 				return {
					filterTag: tag.toLowerCase(),
					displayTag: tag.toTitleCase(),
				};
			} else { 				return {
					filterTag: tag.tag.toLowerCase(),
					displayTag: `${tag.prefix} ${tag.tag}`.toTitleCase(),
				};
			}
		})
		: [];
};

Parser.monTypeToPlural = function (type) {
	return Parser._parse_aToB(Parser.MON_TYPE_TO_PLURAL, type);
};

Parser.monTypeFromPlural = function (type) {
	return Parser._parse_bToA(Parser.MON_TYPE_TO_PLURAL, type);
};

Parser.monCrToFull = function (cr, {xp = null, isMythic = false} = {}) {
	if (cr == null) return "";

	if (typeof cr === "string") {
		if (Parser.crToNumber(cr) >= VeCt.CR_CUSTOM) return `${cr}${xp != null ? ` (${xp} XP)` : ""}`;

		xp = xp != null ? Parser._addCommas(xp) : Parser.crToXp(cr);
		return `${cr} (${xp} XP${isMythic ? `, or ${Parser.crToXp(cr, {isDouble: true})} XP as a mythic encounter` : ""})`;
	} else {
		const stack = [Parser.monCrToFull(cr.cr, {xp: cr.xp, isMythic})];
		if (cr.lair) stack.push(`${Parser.monCrToFull(cr.lair)} when encountered in lair`);
		if (cr.coven) stack.push(`${Parser.monCrToFull(cr.coven)} when part of a coven`);
		return stack.joinConjunct(", ", " or ");
	}
};

Parser.getFullImmRes = function (toParse) {
	if (!toParse?.length) return "";

	let maxDepth = 0;

	function toString (it, depth = 0) {
		maxDepth = Math.max(maxDepth, depth);
		if (typeof it === "string") {
			return it;
		} else if (it.special) {
			return it.special;
		} else {
			const stack = [];

			if (it.preNote) stack.push(it.preNote);

			const prop = it.immune ? "immune" : it.resist ? "resist" : it.vulnerable ? "vulnerable" : null;
			if (prop) {
				const toJoin = it[prop].map(nxt => toString(nxt, depth + 1));
				stack.push(depth ? toJoin.join(maxDepth ? "; " : ", ") : toJoin.joinConjunct(", ", " and "));
			}

			if (it.note) stack.push(it.note);

			return stack.join(" ");
		}
	}

	const arr = toParse.map(it => toString(it));

	if (arr.length <= 1) return arr.join("");

	let out = "";
	for (let i = 0; i < arr.length - 1; ++i) {
		const it = arr[i];
		const nxt = arr[i + 1];

		const orig = toParse[i];
		const origNxt = toParse[i + 1];

		out += it;
		out += (it.includes(",") || nxt.includes(",") || (orig && orig.cond) || (origNxt && origNxt.cond)) ? "; " : ", ";
	}
	out += arr.last();
	return out;
};

Parser.getFullCondImm = function (condImm, isPlainText) {
	if (!condImm?.length) return "";
	function render (condition) {
		return isPlainText ? condition : Renderer.get().render(`{@condition ${condition}}`);
	}
	return condImm.map(it => {
		if (it.special) return it.special;
		if (it.conditionImmune) return `${it.preNote ? `${it.preNote} ` : ""}${it.conditionImmune.map(render).join(", ")}${it.note ? ` ${it.note}` : ""}`;
		return render(it);
	}).sort(SortUtil.ascSortLower).join(", ");
};

Parser.MON_SENSE_TAG_TO_FULL = {
	"B": "blindsight",
	"D": "darkvision",
	"SD": "superior darkvision",
	"T": "tremorsense",
	"U": "truesight",
};
Parser.monSenseTagToFull = function (tag) {
	return Parser._parse_aToB(Parser.MON_SENSE_TAG_TO_FULL, tag);
};

Parser.MON_SPELLCASTING_TAG_TO_FULL = {
	"P": "Psionics",
	"I": "Innate",
	"F": "Form Only",
	"S": "Shared",
	"O": "Other",
	"CA": "Class, Artificer",
	"CB": "Class, Bard",
	"CC": "Class, Cleric",
	"CD": "Class, Druid",
	"CP": "Class, Paladin",
	"CR": "Class, Ranger",
	"CS": "Class, Sorcerer",
	"CL": "Class, Warlock",
	"CW": "Class, Wizard",
};
Parser.monSpellcastingTagToFull = function (tag) {
	return Parser._parse_aToB(Parser.MON_SPELLCASTING_TAG_TO_FULL, tag);
};

Parser.MON_MISC_TAG_TO_FULL = {
	"AOE": "Has Areas of Effect",
	"HPR": "Has HP Reduction",
	"MW": "Has Weapon Attacks, Melee",
	"RW": "Has Weapon Attacks, Ranged",
	"RNG": "Has Ranged Weapons",
	"RCH": "Has Reach Attacks",
	"THW": "Has Thrown Weapons",
};
Parser.monMiscTagToFull = function (tag) {
	return Parser._parse_aToB(Parser.MON_MISC_TAG_TO_FULL, tag);
};

Parser.MON_LANGUAGE_TAG_TO_FULL = {
	"AB": "Abyssal",
	"AQ": "Aquan",
	"AU": "Auran",
	"C": "Common",
	"CE": "Celestial",
	"CS": "Can't Speak Known Languages",
	"D": "Dwarvish",
	"DR": "Draconic",
	"DS": "Deep Speech",
	"DU": "Druidic",
	"E": "Elvish",
	"G": "Gnomish",
	"GI": "Giant",
	"GO": "Goblin",
	"GTH": "Gith",
	"H": "Halfling",
	"I": "Infernal",
	"IG": "Ignan",
	"LF": "Languages Known in Life",
	"O": "Orc",
	"OTH": "Other",
	"P": "Primordial",
	"S": "Sylvan",
	"T": "Terran",
	"TC": "Thieves' cant",
	"TP": "Telepathy",
	"U": "Undercommon",
	"X": "Any (Choose)",
	"XX": "All",
};
Parser.monLanguageTagToFull = function (tag) {
	return Parser._parse_aToB(Parser.MON_LANGUAGE_TAG_TO_FULL, tag);
};

Parser.ENVIRONMENTS = ["arctic", "coastal", "desert", "forest", "grassland", "hill", "mountain", "swamp", "underdark", "underwater", "urban"];

Parser.PSI_ABV_TYPE_TALENT = "T";
Parser.PSI_ABV_TYPE_DISCIPLINE = "D";
Parser.PSI_ORDER_NONE = "None";
Parser.psiTypeToFull = type => Parser.psiTypeToMeta(type).full;

Parser.psiTypeToMeta = type => {
	let out = {};
	if (type === Parser.PSI_ABV_TYPE_TALENT) out = {hasOrder: false, full: "Talent"};
	else if (type === Parser.PSI_ABV_TYPE_DISCIPLINE) out = {hasOrder: true, full: "Discipline"};
	else if (PrereleaseUtil.getMetaLookup("psionicTypes")?.[type]) out = MiscUtil.copyFast(PrereleaseUtil.getMetaLookup("psionicTypes")[type]);
	else if (BrewUtil2.getMetaLookup("psionicTypes")?.[type]) out = MiscUtil.copyFast(BrewUtil2.getMetaLookup("psionicTypes")[type]);
	out.full = out.full || "Unknown";
	out.short = out.short || out.full;
	return out;
};

Parser.psiOrderToFull = (order) => {
	return order === undefined ? Parser.PSI_ORDER_NONE : order;
};

Parser.prereqSpellToFull = function (spell, {isTextOnly = false} = {}) {
	if (spell) {
		const [text, suffix] = spell.split("#");
		if (!suffix) return isTextOnly ? spell : Renderer.get().render(`{@spell ${spell}}`);
		else if (suffix === "c") return (isTextOnly ? Renderer.stripTags : Renderer.get().render.bind(Renderer.get()))(`{@spell ${text}} cantrip`);
		else if (suffix === "x") return (isTextOnly ? Renderer.stripTags : Renderer.get().render.bind(Renderer.get()))("{@spell hex} spell or a warlock feature that curses");
	} else return VeCt.STR_NONE;
};

Parser.prereqPactToFull = function (pact) {
	if (pact === "Chain") return "Pact of the Chain";
	if (pact === "Tome") return "Pact of the Tome";
	if (pact === "Blade") return "Pact of the Blade";
	if (pact === "Talisman") return "Pact of the Talisman";
	return pact;
};

Parser.prereqPatronToShort = function (patron) {
	if (patron === "Any") return patron;
	const mThe = /^The (.*?)$/.exec(patron);
	if (mThe) return mThe[1];
	return patron;
};

Parser.OPT_FEATURE_TYPE_TO_FULL = {
	AI: "Artificer Infusion",
	ED: "Elemental Discipline",
	EI: "Eldritch Invocation",
	MM: "Metamagic",
	"MV": "Maneuver",
	"MV:B": "Maneuver, Battle Master",
	"MV:C2-UA": "Maneuver, Cavalier V2 (UA)",
	"AS:V1-UA": "Arcane Shot, V1 (UA)",
	"AS:V2-UA": "Arcane Shot, V2 (UA)",
	"AS": "Arcane Shot",
	OTH: "Other",
	"FS:F": "Fighting Style; Fighter",
	"FS:B": "Fighting Style; Bard",
	"FS:P": "Fighting Style; Paladin",
	"FS:R": "Fighting Style; Ranger",
	"PB": "Pact Boon",
	"OR": "Onomancy Resonant",
	"RN": "Rune Knight Rune",
	"AF": "Alchemical Formula",
};

Parser.optFeatureTypeToFull = function (type) {
	if (Parser.OPT_FEATURE_TYPE_TO_FULL[type]) return Parser.OPT_FEATURE_TYPE_TO_FULL[type];
	if (PrereleaseUtil.getMetaLookup("optionalFeatureTypes")?.[type]) return PrereleaseUtil.getMetaLookup("optionalFeatureTypes")[type];
	if (BrewUtil2.getMetaLookup("optionalFeatureTypes")?.[type]) return BrewUtil2.getMetaLookup("optionalFeatureTypes")[type];
	return type;
};

Parser.CHAR_OPTIONAL_FEATURE_TYPE_TO_FULL = {
	"SG": "Supernatural Gift",
	"OF": "Optional Feature",
	"DG": "Dark Gift",
	"RF:B": "Replacement Feature: Background",
	"CS": "Character Secret", };

Parser.charCreationOptionTypeToFull = function (type) {
	if (Parser.CHAR_OPTIONAL_FEATURE_TYPE_TO_FULL[type]) return Parser.CHAR_OPTIONAL_FEATURE_TYPE_TO_FULL[type];
	if (PrereleaseUtil.getMetaLookup("charOption")?.[type]) return PrereleaseUtil.getMetaLookup("charOption")[type];
	if (BrewUtil2.getMetaLookup("charOption")?.[type]) return BrewUtil2.getMetaLookup("charOption")[type];
	return type;
};

Parser.alignmentAbvToFull = function (alignment) {
	if (!alignment) return null; 	if (typeof alignment === "object") {
		if (alignment.special != null) {
						return alignment.special;
		} else {
						return `${alignment.alignment.map(a => Parser.alignmentAbvToFull(a)).join(" ")}${alignment.chance ? ` (${alignment.chance}%)` : ""}${alignment.note ? ` (${alignment.note})` : ""}`;
		}
	} else {
		alignment = alignment.toUpperCase();
		switch (alignment) {
			case "L":
				return "lawful";
			case "N":
				return "neutral";
			case "NX":
				return "neutral (law/chaos axis)";
			case "NY":
				return "neutral (good/evil axis)";
			case "C":
				return "chaotic";
			case "G":
				return "good";
			case "E":
				return "evil";
						case "U":
				return "unaligned";
			case "A":
				return "any alignment";
		}
		return alignment;
	}
};

Parser.alignmentListToFull = function (alignList) {
	if (!alignList) return "";
	if (alignList.some(it => typeof it !== "string")) {
		if (alignList.some(it => typeof it === "string")) throw new Error(`Mixed alignment types: ${JSON.stringify(alignList)}`);
				alignList = alignList.filter(it => it.alignment === undefined || it.alignment != null);
		return alignList.map(it => it.special != null || it.chance != null || it.note != null ? Parser.alignmentAbvToFull(it) : Parser.alignmentListToFull(it.alignment)).join(" or ");
	} else {
				if (alignList.length === 1) return Parser.alignmentAbvToFull(alignList[0]);
				if (alignList.length === 2) {
			return alignList.map(a => Parser.alignmentAbvToFull(a)).join(" ");
		}
		if (alignList.length === 3) {
			if (alignList.includes("NX") && alignList.includes("NY") && alignList.includes("N")) return "any neutral alignment";
		}
				if (alignList.length === 5) {
			if (!alignList.includes("G")) return "any non-good alignment";
			if (!alignList.includes("E")) return "any non-evil alignment";
			if (!alignList.includes("L")) return "any non-lawful alignment";
			if (!alignList.includes("C")) return "any non-chaotic alignment";
		}
		if (alignList.length === 4) {
			if (!alignList.includes("L") && !alignList.includes("NX")) return "any chaotic alignment";
			if (!alignList.includes("G") && !alignList.includes("NY")) return "any evil alignment";
			if (!alignList.includes("C") && !alignList.includes("NX")) return "any lawful alignment";
			if (!alignList.includes("E") && !alignList.includes("NY")) return "any good alignment";
		}
		throw new Error(`Unmapped alignment: ${JSON.stringify(alignList)}`);
	}
};

Parser.weightToFull = function (lbs, isSmallUnit) {
	const tons = Math.floor(lbs / 2000);
	lbs = lbs - (2000 * tons);
	return [
		tons ? `${tons}${isSmallUnit ? `<span class="ve-small ml-1">` : " "}ton${tons === 1 ? "" : "s"}${isSmallUnit ? `</span>` : ""}` : null,
		lbs ? `${lbs}${isSmallUnit ? `<span class="ve-small ml-1">` : " "}lb.${isSmallUnit ? `</span>` : ""}` : null,
	].filter(Boolean).join(", ");
};

Parser.RARITIES = ["common", "uncommon", "rare", "very rare", "legendary", "artifact"];
Parser.ITEM_RARITIES = ["none", ...Parser.RARITIES, "unknown", "unknown (magic)", "other"];

Parser.CAT_ID_CREATURE = 1;
Parser.CAT_ID_SPELL = 2;
Parser.CAT_ID_BACKGROUND = 3;
Parser.CAT_ID_ITEM = 4;
Parser.CAT_ID_CLASS = 5;
Parser.CAT_ID_CONDITION = 6;
Parser.CAT_ID_FEAT = 7;
Parser.CAT_ID_ELDRITCH_INVOCATION = 8;
Parser.CAT_ID_PSIONIC = 9;
Parser.CAT_ID_RACE = 10;
Parser.CAT_ID_OTHER_REWARD = 11;
Parser.CAT_ID_VARIANT_OPTIONAL_RULE = 12;
Parser.CAT_ID_ADVENTURE = 13;
Parser.CAT_ID_DEITY = 14;
Parser.CAT_ID_OBJECT = 15;
Parser.CAT_ID_TRAP = 16;
Parser.CAT_ID_HAZARD = 17;
Parser.CAT_ID_QUICKREF = 18;
Parser.CAT_ID_CULT = 19;
Parser.CAT_ID_BOON = 20;
Parser.CAT_ID_DISEASE = 21;
Parser.CAT_ID_METAMAGIC = 22;
Parser.CAT_ID_MANEUVER_BATTLEMASTER = 23;
Parser.CAT_ID_TABLE = 24;
Parser.CAT_ID_TABLE_GROUP = 25;
Parser.CAT_ID_MANEUVER_CAVALIER = 26;
Parser.CAT_ID_ARCANE_SHOT = 27;
Parser.CAT_ID_OPTIONAL_FEATURE_OTHER = 28;
Parser.CAT_ID_FIGHTING_STYLE = 29;
Parser.CAT_ID_CLASS_FEATURE = 30;
Parser.CAT_ID_VEHICLE = 31;
Parser.CAT_ID_PACT_BOON = 32;
Parser.CAT_ID_ELEMENTAL_DISCIPLINE = 33;
Parser.CAT_ID_ARTIFICER_INFUSION = 34;
Parser.CAT_ID_SHIP_UPGRADE = 35;
Parser.CAT_ID_INFERNAL_WAR_MACHINE_UPGRADE = 36;
Parser.CAT_ID_ONOMANCY_RESONANT = 37;
Parser.CAT_ID_RUNE_KNIGHT_RUNE = 37;
Parser.CAT_ID_ALCHEMICAL_FORMULA = 38;
Parser.CAT_ID_MANEUVER = 39;
Parser.CAT_ID_SUBCLASS = 40;
Parser.CAT_ID_SUBCLASS_FEATURE = 41;
Parser.CAT_ID_ACTION = 42;
Parser.CAT_ID_LANGUAGE = 43;
Parser.CAT_ID_BOOK = 44;
Parser.CAT_ID_PAGE = 45;
Parser.CAT_ID_LEGENDARY_GROUP = 46;
Parser.CAT_ID_CHAR_CREATION_OPTIONS = 47;
Parser.CAT_ID_RECIPES = 48;
Parser.CAT_ID_STATUS = 49;
Parser.CAT_ID_SKILLS = 50;
Parser.CAT_ID_SENSES = 51;
Parser.CAT_ID_DECK = 52;
Parser.CAT_ID_CARD = 53;

Parser.CAT_ID_TO_FULL = {};
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_CREATURE] = "Bestiary";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_SPELL] = "Spell";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_BACKGROUND] = "Background";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ITEM] = "Item";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_CLASS] = "Class";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_CONDITION] = "Condition";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_FEAT] = "Feat";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ELDRITCH_INVOCATION] = "Eldritch Invocation";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_PSIONIC] = "Psionic";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_RACE] = "Race";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_OTHER_REWARD] = "Other Reward";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_VARIANT_OPTIONAL_RULE] = "Variant/Optional Rule";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ADVENTURE] = "Adventure";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_DEITY] = "Deity";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_OBJECT] = "Object";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_TRAP] = "Trap";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_HAZARD] = "Hazard";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_QUICKREF] = "Quick Reference";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_CULT] = "Cult";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_BOON] = "Boon";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_DISEASE] = "Disease";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_METAMAGIC] = "Metamagic";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_MANEUVER_BATTLEMASTER] = "Maneuver; Battlemaster";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_TABLE] = "Table";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_TABLE_GROUP] = "Table";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_MANEUVER_CAVALIER] = "Maneuver; Cavalier";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ARCANE_SHOT] = "Arcane Shot";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_OPTIONAL_FEATURE_OTHER] = "Optional Feature";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_FIGHTING_STYLE] = "Fighting Style";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_CLASS_FEATURE] = "Class Feature";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_VEHICLE] = "Vehicle";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_PACT_BOON] = "Pact Boon";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ELEMENTAL_DISCIPLINE] = "Elemental Discipline";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ARTIFICER_INFUSION] = "Infusion";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_SHIP_UPGRADE] = "Ship Upgrade";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_INFERNAL_WAR_MACHINE_UPGRADE] = "Infernal War Machine Upgrade";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ONOMANCY_RESONANT] = "Onomancy Resonant";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_RUNE_KNIGHT_RUNE] = "Rune Knight Rune";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ALCHEMICAL_FORMULA] = "Alchemical Formula";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_MANEUVER] = "Maneuver";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_SUBCLASS] = "Subclass";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_SUBCLASS_FEATURE] = "Subclass Feature";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ACTION] = "Action";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_LANGUAGE] = "Language";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_BOOK] = "Book";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_PAGE] = "Page";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_LEGENDARY_GROUP] = "Legendary Group";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_CHAR_CREATION_OPTIONS] = "Character Creation Option";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_RECIPES] = "Recipe";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_STATUS] = "Status";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_DECK] = "Deck";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_CARD] = "Card";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_SKILLS] = "Skill";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_SENSES] = "Sense";

Parser.pageCategoryToFull = function (catId) {
	return Parser._parse_aToB(Parser.CAT_ID_TO_FULL, catId);
};

Parser.CAT_ID_TO_PROP = {};
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_CREATURE] = "monster";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_SPELL] = "spell";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_BACKGROUND] = "background";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ITEM] = "item";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_CLASS] = "class";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_CONDITION] = "condition";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_FEAT] = "feat";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_PSIONIC] = "psionic";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_RACE] = "race";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_OTHER_REWARD] = "reward";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_VARIANT_OPTIONAL_RULE] = "variantrule";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ADVENTURE] = "adventure";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_DEITY] = "deity";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_OBJECT] = "object";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_TRAP] = "trap";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_HAZARD] = "hazard";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_CULT] = "cult";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_BOON] = "boon";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_DISEASE] = "condition";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_TABLE] = "table";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_TABLE_GROUP] = "tableGroup";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_VEHICLE] = "vehicle";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ELDRITCH_INVOCATION] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_MANEUVER_CAVALIER] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ARCANE_SHOT] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_OPTIONAL_FEATURE_OTHER] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_FIGHTING_STYLE] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_METAMAGIC] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_MANEUVER_BATTLEMASTER] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_PACT_BOON] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ELEMENTAL_DISCIPLINE] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ARTIFICER_INFUSION] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_SHIP_UPGRADE] = "vehicleUpgrade";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_INFERNAL_WAR_MACHINE_UPGRADE] = "vehicleUpgrade";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ONOMANCY_RESONANT] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_RUNE_KNIGHT_RUNE] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ALCHEMICAL_FORMULA] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_MANEUVER] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_QUICKREF] = null;
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_CLASS_FEATURE] = "classFeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_SUBCLASS] = "subclass";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_SUBCLASS_FEATURE] = "subclassFeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ACTION] = "action";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_LANGUAGE] = "language";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_BOOK] = "book";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_PAGE] = null;
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_LEGENDARY_GROUP] = "legendaryGroup";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_CHAR_CREATION_OPTIONS] = "charoption";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_RECIPES] = "recipe";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_STATUS] = "status";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_DECK] = "deck";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_CARD] = "card";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_SKILLS] = "skill";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_SENSES] = "sense";

Parser.pageCategoryToProp = function (catId) {
	return Parser._parse_aToB(Parser.CAT_ID_TO_PROP, catId);
};

Parser.ABIL_ABVS = ["str", "dex", "con", "int", "wis", "cha"];

Parser.spClassesToCurrentAndLegacy = function (fromClassList) {
	const current = [];
	const legacy = [];
	fromClassList.forEach(cls => {
		if ((cls.name === "Artificer" && cls.source === "UAArtificer") || (cls.name === "Artificer (Revisited)" && cls.source === "UAArtificerRevisited")) legacy.push(cls);
		else current.push(cls);
	});
	return [current, legacy];
};

Parser.spSubclassesToCurrentAndLegacyFull = function (sp, subclassLookup) {
	return Parser._spSubclassesToCurrentAndLegacyFull({sp, subclassLookup, prop: "fromSubclass"});
};

Parser.spVariantSubclassesToCurrentAndLegacyFull = function (sp, subclassLookup) {
	return Parser._spSubclassesToCurrentAndLegacyFull({sp, subclassLookup, prop: "fromSubclassVariant"});
};

Parser._spSubclassesToCurrentAndLegacyFull = ({sp, subclassLookup, prop}) => {
	const fromSubclass = Renderer.spell.getCombinedClasses(sp, prop);
	if (!fromSubclass.length) return ["", ""];

	const current = [];
	const legacy = [];
	const curNames = new Set();
	const toCheck = [];
	fromSubclass
		.filter(c => {
			const excludeClass = ExcludeUtil.isExcluded(
				UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES]({name: c.class.name, source: c.class.source}),
				"class",
				c.class.source,
				{isNoCount: true},
			);
			if (excludeClass) return false;

			const excludeSubclass = ExcludeUtil.isExcluded(
				UrlUtil.URL_TO_HASH_BUILDER["subclass"]({
					shortName: c.subclass.shortName,
					source: c.subclass.source,
					className: c.class.name,
					classSource: c.class.source,
				}),
				"subclass",
				c.subclass.source,
				{isNoCount: true},
			);
			if (excludeSubclass) return false;

			return !Renderer.spell.isExcludedSubclassVariantSource({classDefinedInSource: c.class.definedInSource});
		})
		.sort((a, b) => {
			const byName = SortUtil.ascSort(a.subclass.name, b.subclass.name);
			return byName || SortUtil.ascSort(a.class.name, b.class.name);
		})
		.forEach(c => {
			const nm = c.subclass.name;
			const src = c.subclass.source;

			const toAdd = Parser._spSubclassItem({fromSubclass: c, isTextOnly: false});

			const fromLookup = MiscUtil.get(
				subclassLookup,
				c.class.source,
				c.class.name,
				c.subclass.source,
				c.subclass.name,
			);

			if (fromLookup && fromLookup.isReprinted) {
				legacy.push(toAdd);
			} else if (SourceUtil.isNonstandardSource(src)) {
				const cleanName = Parser._spSubclassesToCurrentAndLegacyFull.mapClassShortNameToMostRecent(
					nm.split("(")[0].trim().split(/v\d+/)[0].trim(),
				);
				toCheck.push({"name": cleanName, "ele": toAdd});
			} else {
				current.push(toAdd);
				curNames.add(nm);
			}
		});

	toCheck.forEach(n => {
		if (curNames.has(n.name)) {
			legacy.push(n.ele);
		} else {
			current.push(n.ele);
		}
	});

	return [current.join(", "), legacy.join(", ")];
};

Parser._spSubclassesToCurrentAndLegacyFull.mapClassShortNameToMostRecent = (shortName) => {
	switch (shortName) {
		case "Favored Soul": return "Divine Soul";
		case "Undying Light": return "Celestial";
		case "Deep Stalker": return "Gloom Stalker";
	}
	return shortName;
};

Parser.spVariantClassesToCurrentAndLegacy = function (fromVariantClassList) {
	const current = [];
	const legacy = [];
	fromVariantClassList.forEach(cls => {
		if (cls.definedInSource === Parser.SRC_UACFV) legacy.push(cls);
		else current.push(cls);
	});
	return [current, legacy];
};

Parser.attackTypeToFull = function (attackType) {
	return Parser._parse_aToB(Parser.ATK_TYPE_TO_FULL, attackType);
};

Parser.trapHazTypeToFull = function (type) {
	return Parser._parse_aToB(Parser.TRAP_HAZARD_TYPE_TO_FULL, type);
};

Parser.TRAP_HAZARD_TYPE_TO_FULL = {
	MECH: "Mechanical trap",
	MAG: "Magical trap",
	SMPL: "Simple trap",
	CMPX: "Complex trap",
	HAZ: "Hazard",
	WTH: "Weather",
	ENV: "Environmental Hazard",
	WLD: "Wilderness Hazard",
	GEN: "Generic",
	EST: "Eldritch Storm",
};

Parser.tierToFullLevel = function (tier) {
	return Parser._parse_aToB(Parser.TIER_TO_FULL_LEVEL, tier);
};

Parser.TIER_TO_FULL_LEVEL = {};
Parser.TIER_TO_FULL_LEVEL[1] = "level 1\u20134";
Parser.TIER_TO_FULL_LEVEL[2] = "level 5\u201310";
Parser.TIER_TO_FULL_LEVEL[3] = "level 11\u201316";
Parser.TIER_TO_FULL_LEVEL[4] = "level 17\u201320";

Parser.trapInitToFull = function (init) {
	return Parser._parse_aToB(Parser.TRAP_INIT_TO_FULL, init);
};

Parser.TRAP_INIT_TO_FULL = {};
Parser.TRAP_INIT_TO_FULL[1] = "initiative count 10";
Parser.TRAP_INIT_TO_FULL[2] = "initiative count 20";
Parser.TRAP_INIT_TO_FULL[3] = "initiative count 20 and initiative count 10";

Parser.ATK_TYPE_TO_FULL = {};
Parser.ATK_TYPE_TO_FULL["MW"] = "Melee Weapon Attack";
Parser.ATK_TYPE_TO_FULL["RW"] = "Ranged Weapon Attack";

Parser.bookOrdinalToAbv = (ordinal, preNoSuff) => {
	if (ordinal === undefined) return "";
	switch (ordinal.type) {
		case "part": return `${preNoSuff ? " " : ""}Part ${ordinal.identifier}${preNoSuff ? "" : " \u2014 "}`;
		case "chapter": return `${preNoSuff ? " " : ""}Ch. ${ordinal.identifier}${preNoSuff ? "" : ": "}`;
		case "episode": return `${preNoSuff ? " " : ""}Ep. ${ordinal.identifier}${preNoSuff ? "" : ": "}`;
		case "appendix": return `${preNoSuff ? " " : ""}App.${ordinal.identifier != null ? ` ${ordinal.identifier}` : ""}${preNoSuff ? "" : ": "}`;
		case "level": return `${preNoSuff ? " " : ""}Level ${ordinal.identifier}${preNoSuff ? "" : ": "}`;
		default: throw new Error(`Unhandled ordinal type "${ordinal.type}"`);
	}
};

Parser.IMAGE_TYPE_TO_FULL = {
	"map": "Map",
	"mapPlayer": "Map (Player)",
};
Parser.imageTypeToFull = function (imageType) {
	return Parser._parse_aToB(Parser.IMAGE_TYPE_TO_FULL, imageType, "Other");
};

Parser.nameToTokenName = function (name) {
	return name
		.toAscii()
		.replace(/"/g, "");
};

Parser.bytesToHumanReadable = function (bytes, {fixedDigits = 2} = {}) {
	if (bytes == null) return "";
	if (!bytes) return "0 B";
	const e = Math.floor(Math.log(bytes) / Math.log(1024));
	return `${(bytes / Math.pow(1024, e)).toFixed(fixedDigits)} ${`\u200bKMGTP`.charAt(e)}B`;
};

Parser.SKL_ABV_ABJ = "A";
Parser.SKL_ABV_EVO = "V";
Parser.SKL_ABV_ENC = "E";
Parser.SKL_ABV_ILL = "I";
Parser.SKL_ABV_DIV = "D";
Parser.SKL_ABV_NEC = "N";
Parser.SKL_ABV_TRA = "T";
Parser.SKL_ABV_CON = "C";
Parser.SKL_ABV_PSI = "P";
Parser.SKL_ABVS = [
	Parser.SKL_ABV_ABJ,
	Parser.SKL_ABV_CON,
	Parser.SKL_ABV_DIV,
	Parser.SKL_ABV_ENC,
	Parser.SKL_ABV_EVO,
	Parser.SKL_ABV_ILL,
	Parser.SKL_ABV_NEC,
	Parser.SKL_ABV_PSI,
	Parser.SKL_ABV_TRA,
];

Parser.SP_TM_ACTION = "action";
Parser.SP_TM_B_ACTION = "bonus";
Parser.SP_TM_REACTION = "reaction";
Parser.SP_TM_ROUND = "round";
Parser.SP_TM_MINS = "minute";
Parser.SP_TM_HRS = "hour";
Parser.SP_TIME_SINGLETONS = [Parser.SP_TM_ACTION, Parser.SP_TM_B_ACTION, Parser.SP_TM_REACTION, Parser.SP_TM_ROUND];
Parser.SP_TIME_TO_FULL = {
	[Parser.SP_TM_ACTION]: "Action",
	[Parser.SP_TM_B_ACTION]: "Bonus Action",
	[Parser.SP_TM_REACTION]: "Reaction",
	[Parser.SP_TM_ROUND]: "Rounds",
	[Parser.SP_TM_MINS]: "Minutes",
	[Parser.SP_TM_HRS]: "Hours",
};
Parser.spTimeUnitToFull = function (timeUnit) {
	return Parser._parse_aToB(Parser.SP_TIME_TO_FULL, timeUnit);
};

Parser.SP_TIME_TO_SHORT = {
	[Parser.SP_TM_ROUND]: "Rnd.",
	[Parser.SP_TM_MINS]: "Min.",
	[Parser.SP_TM_HRS]: "Hr.",
};
Parser.spTimeUnitToShort = function (timeUnit) {
	return Parser._parse_aToB(Parser.SP_TIME_TO_SHORT, timeUnit);
};

Parser.SP_TIME_TO_ABV = {
	[Parser.SP_TM_ACTION]: "A",
	[Parser.SP_TM_B_ACTION]: "BA",
	[Parser.SP_TM_REACTION]: "R",
	[Parser.SP_TM_ROUND]: "rnd",
	[Parser.SP_TM_MINS]: "min",
	[Parser.SP_TM_HRS]: "hr",
};
Parser.spTimeUnitToAbv = function (timeUnit) {
	return Parser._parse_aToB(Parser.SP_TIME_TO_ABV, timeUnit);
};

Parser.spTimeToShort = function (time, isHtml) {
	if (!time) return "";
	return (time.number === 1 && Parser.SP_TIME_SINGLETONS.includes(time.unit))
		? `${Parser.spTimeUnitToAbv(time.unit).uppercaseFirst()}${time.condition ? "*" : ""}`
		: `${time.number} ${isHtml ? `<span class="ve-small">` : ""}${Parser.spTimeUnitToAbv(time.unit)}${isHtml ? `</span>` : ""}${time.condition ? "*" : ""}`;
};

Parser.SKL_ABJ = "Abjuration";
Parser.SKL_EVO = "Evocation";
Parser.SKL_ENC = "Enchantment";
Parser.SKL_ILL = "Illusion";
Parser.SKL_DIV = "Divination";
Parser.SKL_NEC = "Necromancy";
Parser.SKL_TRA = "Transmutation";
Parser.SKL_CON = "Conjuration";
Parser.SKL_PSI = "Psionic";

Parser.SP_SCHOOL_ABV_TO_FULL = {};
Parser.SP_SCHOOL_ABV_TO_FULL[Parser.SKL_ABV_ABJ] = Parser.SKL_ABJ;
Parser.SP_SCHOOL_ABV_TO_FULL[Parser.SKL_ABV_EVO] = Parser.SKL_EVO;
Parser.SP_SCHOOL_ABV_TO_FULL[Parser.SKL_ABV_ENC] = Parser.SKL_ENC;
Parser.SP_SCHOOL_ABV_TO_FULL[Parser.SKL_ABV_ILL] = Parser.SKL_ILL;
Parser.SP_SCHOOL_ABV_TO_FULL[Parser.SKL_ABV_DIV] = Parser.SKL_DIV;
Parser.SP_SCHOOL_ABV_TO_FULL[Parser.SKL_ABV_NEC] = Parser.SKL_NEC;
Parser.SP_SCHOOL_ABV_TO_FULL[Parser.SKL_ABV_TRA] = Parser.SKL_TRA;
Parser.SP_SCHOOL_ABV_TO_FULL[Parser.SKL_ABV_CON] = Parser.SKL_CON;
Parser.SP_SCHOOL_ABV_TO_FULL[Parser.SKL_ABV_PSI] = Parser.SKL_PSI;

Parser.SP_SCHOOL_ABV_TO_SHORT = {};
Parser.SP_SCHOOL_ABV_TO_SHORT[Parser.SKL_ABV_ABJ] = "Abj.";
Parser.SP_SCHOOL_ABV_TO_SHORT[Parser.SKL_ABV_EVO] = "Evoc.";
Parser.SP_SCHOOL_ABV_TO_SHORT[Parser.SKL_ABV_ENC] = "Ench.";
Parser.SP_SCHOOL_ABV_TO_SHORT[Parser.SKL_ABV_ILL] = "Illu.";
Parser.SP_SCHOOL_ABV_TO_SHORT[Parser.SKL_ABV_DIV] = "Divin.";
Parser.SP_SCHOOL_ABV_TO_SHORT[Parser.SKL_ABV_NEC] = "Necro.";
Parser.SP_SCHOOL_ABV_TO_SHORT[Parser.SKL_ABV_TRA] = "Trans.";
Parser.SP_SCHOOL_ABV_TO_SHORT[Parser.SKL_ABV_CON] = "Conj.";
Parser.SP_SCHOOL_ABV_TO_SHORT[Parser.SKL_ABV_PSI] = "Psi.";

Parser.ATB_ABV_TO_FULL = {
	"str": "Strength",
	"dex": "Dexterity",
	"con": "Constitution",
	"int": "Intelligence",
	"wis": "Wisdom",
	"cha": "Charisma",
};

Parser.TP_ABERRATION = "aberration";
Parser.TP_BEAST = "beast";
Parser.TP_CELESTIAL = "celestial";
Parser.TP_CONSTRUCT = "construct";
Parser.TP_DRAGON = "dragon";
Parser.TP_ELEMENTAL = "elemental";
Parser.TP_FEY = "fey";
Parser.TP_FIEND = "fiend";
Parser.TP_GIANT = "giant";
Parser.TP_HUMANOID = "humanoid";
Parser.TP_MONSTROSITY = "monstrosity";
Parser.TP_OOZE = "ooze";
Parser.TP_PLANT = "plant";
Parser.TP_UNDEAD = "undead";
Parser.MON_TYPES = [Parser.TP_ABERRATION, Parser.TP_BEAST, Parser.TP_CELESTIAL, Parser.TP_CONSTRUCT, Parser.TP_DRAGON, Parser.TP_ELEMENTAL, Parser.TP_FEY, Parser.TP_FIEND, Parser.TP_GIANT, Parser.TP_HUMANOID, Parser.TP_MONSTROSITY, Parser.TP_OOZE, Parser.TP_PLANT, Parser.TP_UNDEAD];
Parser.MON_TYPE_TO_PLURAL = {};
Parser.MON_TYPE_TO_PLURAL[Parser.TP_ABERRATION] = "aberrations";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_BEAST] = "beasts";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_CELESTIAL] = "celestials";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_CONSTRUCT] = "constructs";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_DRAGON] = "dragons";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_ELEMENTAL] = "elementals";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_FEY] = "fey";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_FIEND] = "fiends";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_GIANT] = "giants";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_HUMANOID] = "humanoids";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_MONSTROSITY] = "monstrosities";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_OOZE] = "oozes";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_PLANT] = "plants";
Parser.MON_TYPE_TO_PLURAL[Parser.TP_UNDEAD] = "undead";

Parser.SZ_FINE = "F";
Parser.SZ_DIMINUTIVE = "D";
Parser.SZ_TINY = "T";
Parser.SZ_SMALL = "S";
Parser.SZ_MEDIUM = "M";
Parser.SZ_LARGE = "L";
Parser.SZ_HUGE = "H";
Parser.SZ_GARGANTUAN = "G";
Parser.SZ_COLOSSAL = "C";
Parser.SZ_VARIES = "V";
Parser.SIZE_ABVS = [Parser.SZ_TINY, Parser.SZ_SMALL, Parser.SZ_MEDIUM, Parser.SZ_LARGE, Parser.SZ_HUGE, Parser.SZ_GARGANTUAN, Parser.SZ_VARIES];
Parser.SIZE_ABV_TO_FULL = {};
Parser.SIZE_ABV_TO_FULL[Parser.SZ_FINE] = "Fine";
Parser.SIZE_ABV_TO_FULL[Parser.SZ_DIMINUTIVE] = "Diminutive";
Parser.SIZE_ABV_TO_FULL[Parser.SZ_TINY] = "Tiny";
Parser.SIZE_ABV_TO_FULL[Parser.SZ_SMALL] = "Small";
Parser.SIZE_ABV_TO_FULL[Parser.SZ_MEDIUM] = "Medium";
Parser.SIZE_ABV_TO_FULL[Parser.SZ_LARGE] = "Large";
Parser.SIZE_ABV_TO_FULL[Parser.SZ_HUGE] = "Huge";
Parser.SIZE_ABV_TO_FULL[Parser.SZ_GARGANTUAN] = "Gargantuan";
Parser.SIZE_ABV_TO_FULL[Parser.SZ_COLOSSAL] = "Colossal";
Parser.SIZE_ABV_TO_FULL[Parser.SZ_VARIES] = "Varies";

Parser.XP_CHART_ALT = {
	"0": 10,
	"1/8": 25,
	"1/4": 50,
	"1/2": 100,
	"1": 200,
	"2": 450,
	"3": 700,
	"4": 1100,
	"5": 1800,
	"6": 2300,
	"7": 2900,
	"8": 3900,
	"9": 5000,
	"10": 5900,
	"11": 7200,
	"12": 8400,
	"13": 10000,
	"14": 11500,
	"15": 13000,
	"16": 15000,
	"17": 18000,
	"18": 20000,
	"19": 22000,
	"20": 25000,
	"21": 33000,
	"22": 41000,
	"23": 50000,
	"24": 62000,
	"25": 75000,
	"26": 90000,
	"27": 105000,
	"28": 120000,
	"29": 135000,
	"30": 155000,
};

Parser.ARMOR_ABV_TO_FULL = {
	"l.": "light",
	"m.": "medium",
	"h.": "heavy",
};

Parser.WEAPON_ABV_TO_FULL = {
	"s.": "simple",
	"m.": "martial",
};

Parser.CONDITION_TO_COLOR = {
	"Blinded": "#525252",
	"Charmed": "#f01789",
	"Deafened": "#ababab",
	"Exhausted": "#947a47",
	"Frightened": "#c9ca18",
	"Grappled": "#8784a0",
	"Incapacitated": "#3165a0",
	"Invisible": "#7ad2d6",
	"Paralyzed": "#c00900",
	"Petrified": "#a0a0a0",
	"Poisoned": "#4dc200",
	"Prone": "#5e60a0",
	"Restrained": "#d98000",
	"Stunned": "#a23bcb",
	"Unconscious": "#3a40ad",

	"Concentration": "#009f7a",
};

Parser.RULE_TYPE_TO_FULL = {
	"O": "Optional",
	"V": "Variant",
	"VO": "Variant Optional",
	"VV": "Variant Variant",
	"U": "Unknown",
};

Parser.ruleTypeToFull = function (ruleType) {
	return Parser._parse_aToB(Parser.RULE_TYPE_TO_FULL, ruleType);
};

Parser.VEHICLE_TYPE_TO_FULL = {
	"SHIP": "Ship",
	"SPELLJAMMER": "Spelljammer Ship",
	"INFWAR": "Infernal War Machine",
	"CREATURE": "Creature",
	"OBJECT": "Object",
	"SHP:H": "Ship Upgrade, Hull",
	"SHP:M": "Ship Upgrade, Movement",
	"SHP:W": "Ship Upgrade, Weapon",
	"SHP:F": "Ship Upgrade, Figurehead",
	"SHP:O": "Ship Upgrade, Miscellaneous",
	"IWM:W": "Infernal War Machine Variant, Weapon",
	"IWM:A": "Infernal War Machine Upgrade, Armor",
	"IWM:G": "Infernal War Machine Upgrade, Gadget",
};

Parser.vehicleTypeToFull = function (vehicleType) {
	return Parser._parse_aToB(Parser.VEHICLE_TYPE_TO_FULL, vehicleType);
};


Parser.SRC_5ETOOLS_TMP = "Parser.SRC_5ETOOLS_TMP"; 
Parser.SRC_CoS = "CoS";
Parser.SRC_DMG = "DMG";
Parser.SRC_EEPC = "EEPC";
Parser.SRC_EET = "EET";
Parser.SRC_HotDQ = "HotDQ";
Parser.SRC_LMoP = "LMoP";
Parser.SRC_MM = "MM";
Parser.SRC_OotA = "OotA";
Parser.SRC_PHB = "PHB";
Parser.SRC_PotA = "PotA";
Parser.SRC_RoT = "RoT";
Parser.SRC_RoTOS = "RoTOS";
Parser.SRC_SCAG = "SCAG";
Parser.SRC_SKT = "SKT";
Parser.SRC_ToA = "ToA";
Parser.SRC_TLK = "TLK";
Parser.SRC_ToD = "ToD";
Parser.SRC_TTP = "TTP";
Parser.SRC_TYP = "TftYP";
Parser.SRC_TYP_AtG = "TftYP-AtG";
Parser.SRC_TYP_DiT = "TftYP-DiT";
Parser.SRC_TYP_TFoF = "TftYP-TFoF";
Parser.SRC_TYP_THSoT = "TftYP-THSoT";
Parser.SRC_TYP_TSC = "TftYP-TSC";
Parser.SRC_TYP_ToH = "TftYP-ToH";
Parser.SRC_TYP_WPM = "TftYP-WPM";
Parser.SRC_VGM = "VGM";
Parser.SRC_XGE = "XGE";
Parser.SRC_OGA = "OGA";
Parser.SRC_MTF = "MTF";
Parser.SRC_WDH = "WDH";
Parser.SRC_WDMM = "WDMM";
Parser.SRC_GGR = "GGR";
Parser.SRC_KKW = "KKW";
Parser.SRC_LLK = "LLK";
Parser.SRC_AZfyT = "AZfyT";
Parser.SRC_GoS = "GoS";
Parser.SRC_AI = "AI";
Parser.SRC_OoW = "OoW";
Parser.SRC_ESK = "ESK";
Parser.SRC_DIP = "DIP";
Parser.SRC_HftT = "HftT";
Parser.SRC_DC = "DC";
Parser.SRC_SLW = "SLW";
Parser.SRC_SDW = "SDW";
Parser.SRC_BGDIA = "BGDIA";
Parser.SRC_LR = "LR";
Parser.SRC_AL = "AL";
Parser.SRC_SAC = "SAC";
Parser.SRC_ERLW = "ERLW";
Parser.SRC_EFR = "EFR";
Parser.SRC_RMBRE = "RMBRE";
Parser.SRC_RMR = "RMR";
Parser.SRC_MFF = "MFF";
Parser.SRC_AWM = "AWM";
Parser.SRC_IMR = "IMR";
Parser.SRC_SADS = "SADS";
Parser.SRC_EGW = "EGW";
Parser.SRC_EGW_ToR = "ToR";
Parser.SRC_EGW_DD = "DD";
Parser.SRC_EGW_FS = "FS";
Parser.SRC_EGW_US = "US";
Parser.SRC_MOT = "MOT";
Parser.SRC_IDRotF = "IDRotF";
Parser.SRC_TCE = "TCE";
Parser.SRC_VRGR = "VRGR";
Parser.SRC_HoL = "HoL";
Parser.SRC_XMtS = "XMtS";
Parser.SRC_RtG = "RtG";
Parser.SRC_AitFR = "AitFR";
Parser.SRC_AitFR_ISF = "AitFR-ISF";
Parser.SRC_AitFR_THP = "AitFR-THP";
Parser.SRC_AitFR_AVT = "AitFR-AVT";
Parser.SRC_AitFR_DN = "AitFR-DN";
Parser.SRC_AitFR_FCD = "AitFR-FCD";
Parser.SRC_WBtW = "WBtW";
Parser.SRC_DoD = "DoD";
Parser.SRC_MaBJoV = "MaBJoV";
Parser.SRC_FTD = "FTD";
Parser.SRC_SCC = "SCC";
Parser.SRC_SCC_CK = "SCC-CK";
Parser.SRC_SCC_HfMT = "SCC-HfMT";
Parser.SRC_SCC_TMM = "SCC-TMM";
Parser.SRC_SCC_ARiR = "SCC-ARiR";
Parser.SRC_MPMM = "MPMM";
Parser.SRC_CRCotN = "CRCotN";
Parser.SRC_JttRC = "JttRC";
Parser.SRC_SAiS = "SAiS";
Parser.SRC_AAG = "AAG";
Parser.SRC_BAM = "BAM";
Parser.SRC_LoX = "LoX";
Parser.SRC_DoSI = "DoSI";
Parser.SRC_DSotDQ = "DSotDQ";
Parser.SRC_KftGV = "KftGV";
Parser.SRC_SCREEN = "Screen";
Parser.SRC_SCREEN_WILDERNESS_KIT = "ScreenWildernessKit";
Parser.SRC_SCREEN_DUNGEON_KIT = "ScreenDungeonKit";
Parser.SRC_SCREEN_SPELLJAMMER = "ScreenSpelljammer";
Parser.SRC_HEROES_FEAST = "HF";
Parser.SRC_CM = "CM";
Parser.SRC_NRH = "NRH";
Parser.SRC_NRH_TCMC = "NRH-TCMC";
Parser.SRC_NRH_AVitW = "NRH-AVitW";
Parser.SRC_NRH_ASS = "NRH-ASS"; Parser.SRC_NRH_CoI = "NRH-CoI";
Parser.SRC_NRH_TLT = "NRH-TLT";
Parser.SRC_NRH_AWoL = "NRH-AWoL";
Parser.SRC_NRH_AT = "NRH-AT";
Parser.SRC_MGELFT = "MGELFT";
Parser.SRC_VD = "VD";
Parser.SRC_SjA = "SjA";
Parser.SRC_HAT_TG = "HAT-TG";
Parser.SRC_HAT_LMI = "HAT-LMI";

Parser.SRC_AL_PREFIX = "AL";

Parser.SRC_ALCoS = `${Parser.SRC_AL_PREFIX}CurseOfStrahd`;
Parser.SRC_ALEE = `${Parser.SRC_AL_PREFIX}ElementalEvil`;
Parser.SRC_ALRoD = `${Parser.SRC_AL_PREFIX}RageOfDemons`;

Parser.SRC_PS_PREFIX = "PS";

Parser.SRC_PSA = `${Parser.SRC_PS_PREFIX}A`;
Parser.SRC_PSI = `${Parser.SRC_PS_PREFIX}I`;
Parser.SRC_PSK = `${Parser.SRC_PS_PREFIX}K`;
Parser.SRC_PSZ = `${Parser.SRC_PS_PREFIX}Z`;
Parser.SRC_PSX = `${Parser.SRC_PS_PREFIX}X`;
Parser.SRC_PSD = `${Parser.SRC_PS_PREFIX}D`;

Parser.SRC_UA_PREFIX = "UA";
Parser.SRC_UA_ONE_PREFIX = "XUA";
Parser.SRC_MCVX_PREFIX = "MCV";
Parser.SRC_MisMVX_PREFIX = "MisMV";

Parser.SRC_UAA = `${Parser.SRC_UA_PREFIX}Artificer`;
Parser.SRC_UAEAG = `${Parser.SRC_UA_PREFIX}EladrinAndGith`;
Parser.SRC_UAEBB = `${Parser.SRC_UA_PREFIX}Eberron`;
Parser.SRC_UAFFR = `${Parser.SRC_UA_PREFIX}FeatsForRaces`;
Parser.SRC_UAFFS = `${Parser.SRC_UA_PREFIX}FeatsForSkills`;
Parser.SRC_UAFO = `${Parser.SRC_UA_PREFIX}FiendishOptions`;
Parser.SRC_UAFT = `${Parser.SRC_UA_PREFIX}Feats`;
Parser.SRC_UAGH = `${Parser.SRC_UA_PREFIX}GothicHeroes`;
Parser.SRC_UAMDM = `${Parser.SRC_UA_PREFIX}ModernMagic`;
Parser.SRC_UASSP = `${Parser.SRC_UA_PREFIX}StarterSpells`;
Parser.SRC_UATMC = `${Parser.SRC_UA_PREFIX}TheMysticClass`;
Parser.SRC_UATOBM = `${Parser.SRC_UA_PREFIX}ThatOldBlackMagic`;
Parser.SRC_UATRR = `${Parser.SRC_UA_PREFIX}TheRangerRevised`;
Parser.SRC_UAWA = `${Parser.SRC_UA_PREFIX}WaterborneAdventures`;
Parser.SRC_UAVR = `${Parser.SRC_UA_PREFIX}VariantRules`;
Parser.SRC_UALDR = `${Parser.SRC_UA_PREFIX}LightDarkUnderdark`;
Parser.SRC_UARAR = `${Parser.SRC_UA_PREFIX}RangerAndRogue`;
Parser.SRC_UAATOSC = `${Parser.SRC_UA_PREFIX}ATrioOfSubclasses`;
Parser.SRC_UABPP = `${Parser.SRC_UA_PREFIX}BarbarianPrimalPaths`;
Parser.SRC_UARSC = `${Parser.SRC_UA_PREFIX}RevisedSubclasses`;
Parser.SRC_UAKOO = `${Parser.SRC_UA_PREFIX}KitsOfOld`;
Parser.SRC_UABBC = `${Parser.SRC_UA_PREFIX}BardBardColleges`;
Parser.SRC_UACDD = `${Parser.SRC_UA_PREFIX}ClericDivineDomains`;
Parser.SRC_UAD = `${Parser.SRC_UA_PREFIX}Druid`;
Parser.SRC_UARCO = `${Parser.SRC_UA_PREFIX}RevisedClassOptions`;
Parser.SRC_UAF = `${Parser.SRC_UA_PREFIX}Fighter`;
Parser.SRC_UAM = `${Parser.SRC_UA_PREFIX}Monk`;
Parser.SRC_UAP = `${Parser.SRC_UA_PREFIX}Paladin`;
Parser.SRC_UAMC = `${Parser.SRC_UA_PREFIX}ModifyingClasses`;
Parser.SRC_UAS = `${Parser.SRC_UA_PREFIX}Sorcerer`;
Parser.SRC_UAWAW = `${Parser.SRC_UA_PREFIX}WarlockAndWizard`;
Parser.SRC_UATF = `${Parser.SRC_UA_PREFIX}TheFaithful`;
Parser.SRC_UAWR = `${Parser.SRC_UA_PREFIX}WizardRevisited`;
Parser.SRC_UAESR = `${Parser.SRC_UA_PREFIX}ElfSubraces`;
Parser.SRC_UAMAC = `${Parser.SRC_UA_PREFIX}MassCombat`;
Parser.SRC_UA3PE = `${Parser.SRC_UA_PREFIX}ThreePillarExperience`;
Parser.SRC_UAGHI = `${Parser.SRC_UA_PREFIX}GreyhawkInitiative`;
Parser.SRC_UATSC = `${Parser.SRC_UA_PREFIX}ThreeSubclasses`;
Parser.SRC_UAOD = `${Parser.SRC_UA_PREFIX}OrderDomain`;
Parser.SRC_UACAM = `${Parser.SRC_UA_PREFIX}CentaursMinotaurs`;
Parser.SRC_UAGSS = `${Parser.SRC_UA_PREFIX}GiantSoulSorcerer`;
Parser.SRC_UARoE = `${Parser.SRC_UA_PREFIX}RacesOfEberron`;
Parser.SRC_UARoR = `${Parser.SRC_UA_PREFIX}RacesOfRavnica`;
Parser.SRC_UAWGE = `${Parser.SRC_UA_PREFIX}WGE`;
Parser.SRC_UAOSS = `${Parser.SRC_UA_PREFIX}OfShipsAndSea`;
Parser.SRC_UASIK = `${Parser.SRC_UA_PREFIX}Sidekicks`;
Parser.SRC_UAAR = `${Parser.SRC_UA_PREFIX}ArtificerRevisited`;
Parser.SRC_UABAM = `${Parser.SRC_UA_PREFIX}BarbarianAndMonk`;
Parser.SRC_UASAW = `${Parser.SRC_UA_PREFIX}SorcererAndWarlock`;
Parser.SRC_UABAP = `${Parser.SRC_UA_PREFIX}BardAndPaladin`;
Parser.SRC_UACDW = `${Parser.SRC_UA_PREFIX}ClericDruidWizard`;
Parser.SRC_UAFRR = `${Parser.SRC_UA_PREFIX}FighterRangerRogue`;
Parser.SRC_UACFV = `${Parser.SRC_UA_PREFIX}ClassFeatureVariants`;
Parser.SRC_UAFRW = `${Parser.SRC_UA_PREFIX}FighterRogueWizard`;
Parser.SRC_UAPCRM = `${Parser.SRC_UA_PREFIX}PrestigeClassesRunMagic`;
Parser.SRC_UAR = `${Parser.SRC_UA_PREFIX}Ranger`;
Parser.SRC_UA2020SC1 = `${Parser.SRC_UA_PREFIX}2020SubclassesPt1`;
Parser.SRC_UA2020SC2 = `${Parser.SRC_UA_PREFIX}2020SubclassesPt2`;
Parser.SRC_UA2020SC3 = `${Parser.SRC_UA_PREFIX}2020SubclassesPt3`;
Parser.SRC_UA2020SC4 = `${Parser.SRC_UA_PREFIX}2020SubclassesPt4`;
Parser.SRC_UA2020SC5 = `${Parser.SRC_UA_PREFIX}2020SubclassesPt5`;
Parser.SRC_UA2020SMT = `${Parser.SRC_UA_PREFIX}2020SpellsAndMagicTattoos`;
Parser.SRC_UA2020POR = `${Parser.SRC_UA_PREFIX}2020PsionicOptionsRevisited`;
Parser.SRC_UA2020SCR = `${Parser.SRC_UA_PREFIX}2020SubclassesRevisited`;
Parser.SRC_UA2020F = `${Parser.SRC_UA_PREFIX}2020Feats`;
Parser.SRC_UA2021GL = `${Parser.SRC_UA_PREFIX}2021GothicLineages`;
Parser.SRC_UA2021FF = `${Parser.SRC_UA_PREFIX}2021FolkOfTheFeywild`;
Parser.SRC_UA2021DO = `${Parser.SRC_UA_PREFIX}2021DraconicOptions`;
Parser.SRC_UA2021MoS = `${Parser.SRC_UA_PREFIX}2021MagesOfStrixhaven`;
Parser.SRC_UA2021TotM = `${Parser.SRC_UA_PREFIX}2021TravelersOfTheMultiverse`;
Parser.SRC_UA2022HoK = `${Parser.SRC_UA_PREFIX}2022HeroesOfKrynn`;
Parser.SRC_UA2022HoKR = `${Parser.SRC_UA_PREFIX}2022HeroesOfKrynnRevisited`;
Parser.SRC_UA2022GO = `${Parser.SRC_UA_PREFIX}2022GiantOptions`;
Parser.SRC_UA2022WotM = `${Parser.SRC_UA_PREFIX}2022WondersOfTheMultiverse`;
Parser.SRC_MCV1SC = `${Parser.SRC_MCVX_PREFIX}1SC`;
Parser.SRC_MCV2DC = `${Parser.SRC_MCVX_PREFIX}2DC`;
Parser.SRC_MCV3MC = `${Parser.SRC_MCVX_PREFIX}3MC`;
Parser.SRC_MisMV1 = `${Parser.SRC_MisMVX_PREFIX}1`;

Parser.AL_PREFIX = "Adventurers League: ";
Parser.AL_PREFIX_SHORT = "AL: ";
Parser.PS_PREFIX = "Plane Shift: ";
Parser.PS_PREFIX_SHORT = "PS: ";
Parser.UA_PREFIX = "Unearthed Arcana: ";
Parser.UA_PREFIX_SHORT = "UA: ";
Parser.TftYP_NAME = "Tales from the Yawning Portal";
Parser.AitFR_NAME = "Adventures in the Forgotten Realms";
Parser.NRH_NAME = "NERDS Restoring Harmony";
Parser.MCVX_PREFIX = "Monstrous Compendium Volume ";
Parser.MisMVX_PREFIX = "Misplaced Monsters: Volume ";

Parser.SOURCE_JSON_TO_FULL = {};
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_CoS] = "Curse of Strahd";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_DMG] = "Dungeon Master's Guide";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_EEPC] = "Elemental Evil Player's Companion";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_EET] = "Elemental Evil: Trinkets";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_HotDQ] = "Hoard of the Dragon Queen";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_LMoP] = "Lost Mine of Phandelver";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MM] = "Monster Manual";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_OotA] = "Out of the Abyss";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_PHB] = "Player's Handbook";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_PotA] = "Princes of the Apocalypse";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_RoT] = "The Rise of Tiamat";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_RoTOS] = "The Rise of Tiamat Online Supplement";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SCAG] = "Sword Coast Adventurer's Guide";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SKT] = "Storm King's Thunder";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_ToA] = "Tomb of Annihilation";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TLK] = "The Lost Kenku";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_ToD] = "Tyranny of Dragons";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TTP] = "The Tortle Package";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TYP] = Parser.TftYP_NAME;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TYP_AtG] = `${Parser.TftYP_NAME}: Against the Giants`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TYP_DiT] = `${Parser.TftYP_NAME}: Dead in Thay`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TYP_TFoF] = `${Parser.TftYP_NAME}: The Forge of Fury`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TYP_THSoT] = `${Parser.TftYP_NAME}: The Hidden Shrine of Tamoachan`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TYP_TSC] = `${Parser.TftYP_NAME}: The Sunless Citadel`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TYP_ToH] = `${Parser.TftYP_NAME}: Tomb of Horrors`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TYP_WPM] = `${Parser.TftYP_NAME}: White Plume Mountain`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_VGM] = "Volo's Guide to Monsters";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_XGE] = "Xanathar's Guide to Everything";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_OGA] = "One Grung Above";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MTF] = "Mordenkainen's Tome of Foes";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_WDH] = "Waterdeep: Dragon Heist";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_WDMM] = "Waterdeep: Dungeon of the Mad Mage";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_GGR] = "Guildmasters' Guide to Ravnica";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_KKW] = "Krenko's Way";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_LLK] = "Lost Laboratory of Kwalish";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AZfyT] = "A Zib for your Thoughts";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_GoS] = "Ghosts of Saltmarsh";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AI] = "Acquisitions Incorporated";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_OoW] = "The Orrery of the Wanderer";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_ESK] = "Essentials Kit";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_DIP] = "Dragon of Icespire Peak";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_HftT] = "Hunt for the Thessalhydra";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_DC] = "Divine Contention";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SLW] = "Storm Lord's Wrath";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SDW] = "Sleeping Dragon's Wake";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_BGDIA] = "Baldur's Gate: Descent Into Avernus";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_LR] = "Locathah Rising";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AL] = "Adventurers' League";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SAC] = "Sage Advice Compendium";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_ERLW] = "Eberron: Rising from the Last War";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_EFR] = "Eberron: Forgotten Relics";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_RMBRE] = "The Lost Dungeon of Rickedness: Big Rick Energy";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_RMR] = "Dungeons & Dragons vs. Rick and Morty: Basic Rules";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MFF] = "Mordenkainen's Fiendish Folio";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AWM] = "Adventure with Muk";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_IMR] = "Infernal Machine Rebuild";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SADS] = "Sapphire Anniversary Dice Set";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_EGW] = "Explorer's Guide to Wildemount";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_EGW_ToR] = "Tide of Retribution";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_EGW_DD] = "Dangerous Designs";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_EGW_FS] = "Frozen Sick";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_EGW_US] = "Unwelcome Spirits";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MOT] = "Mythic Odysseys of Theros";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_IDRotF] = "Icewind Dale: Rime of the Frostmaiden";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_TCE] = "Tasha's Cauldron of Everything";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_VRGR] = "Van Richten's Guide to Ravenloft";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_HoL] = "The House of Lament";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_RtG] = "Return to Glory";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AitFR] = Parser.AitFR_NAME;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AitFR_ISF] = `${Parser.AitFR_NAME}: In Scarlet Flames`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AitFR_THP] = `${Parser.AitFR_NAME}: The Hidden Page`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AitFR_AVT] = `${Parser.AitFR_NAME}: A Verdant Tomb`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AitFR_DN] = `${Parser.AitFR_NAME}: Deepest Night`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AitFR_FCD] = `${Parser.AitFR_NAME}: From Cyan Depths`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_WBtW] = "The Wild Beyond the Witchlight";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_DoD] = "Domains of Delight";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MaBJoV] = "Minsc and Boo's Journal of Villainy";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_FTD] = "Fizban's Treasury of Dragons";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SCC] = "Strixhaven: A Curriculum of Chaos";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SCC_CK] = "Campus Kerfuffle";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SCC_HfMT] = "Hunt for Mage Tower";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SCC_TMM] = "The Magister's Masquerade";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SCC_ARiR] = "A Reckoning in Ruins";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MPMM] = "Mordenkainen Presents: Monsters of the Multiverse";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_CRCotN] = "Critical Role: Call of the Netherdeep";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_JttRC] = "Journeys through the Radiant Citadel";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SAiS] = "Spelljammer: Adventures in Space";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_AAG] = "Astral Adventurer's Guide";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_BAM] = "Boo's Astral Menagerie";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_LoX] = "Light of Xaryxis";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_DoSI] = "Dragons of Stormwreck Isle";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_DSotDQ] = "Dragonlance: Shadow of the Dragon Queen";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_KftGV] = "Keys from the Golden Vault";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SCREEN] = "Dungeon Master's Screen";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SCREEN_WILDERNESS_KIT] = "Dungeon Master's Screen: Wilderness Kit";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SCREEN_DUNGEON_KIT] = "Dungeon Master's Screen: Dungeon Kit";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SCREEN_SPELLJAMMER] = "Dungeon Master's Screen: Spelljammer";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_HEROES_FEAST] = "Heroes' Feast";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_CM] = "Candlekeep Mysteries";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_NRH] = Parser.NRH_NAME;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_NRH_TCMC] = `${Parser.NRH_NAME}: The Candy Mountain Caper`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_NRH_AVitW] = `${Parser.NRH_NAME}: A Voice in the Wilderness`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_NRH_ASS] = `${Parser.NRH_NAME}: A Sticky Situation`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_NRH_CoI] = `${Parser.NRH_NAME}: Circus of Illusions`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_NRH_TLT] = `${Parser.NRH_NAME}: The Lost Tomb`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_NRH_AWoL] = `${Parser.NRH_NAME}: A Web of Lies`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_NRH_AT] = `${Parser.NRH_NAME}: Adventure Together`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MGELFT] = "Muk's Guide To Everything He Learned From Tasha";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_VD] = "Vecna Dossier";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_SjA] = "Spelljammer Academy";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_HAT_TG] = "Honor Among Thieves: Thieves' Gallery";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_HAT_LMI] = "Honor Among Thieves: Legendary Magic Items";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_ALCoS] = `${Parser.AL_PREFIX}Curse of Strahd`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_ALEE] = `${Parser.AL_PREFIX}Elemental Evil`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_ALRoD] = `${Parser.AL_PREFIX}Rage of Demons`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_PSA] = `${Parser.PS_PREFIX}Amonkhet`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_PSI] = `${Parser.PS_PREFIX}Innistrad`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_PSK] = `${Parser.PS_PREFIX}Kaladesh`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_PSZ] = `${Parser.PS_PREFIX}Zendikar`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_PSX] = `${Parser.PS_PREFIX}Ixalan`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_PSD] = `${Parser.PS_PREFIX}Dominaria`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_XMtS] = `X Marks the Spot`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAA] = `${Parser.UA_PREFIX}Artificer`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAEAG] = `${Parser.UA_PREFIX}Eladrin and Gith`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAEBB] = `${Parser.UA_PREFIX}Eberron`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAFFR] = `${Parser.UA_PREFIX}Feats for Races`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAFFS] = `${Parser.UA_PREFIX}Feats for Skills`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAFO] = `${Parser.UA_PREFIX}Fiendish Options`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAFT] = `${Parser.UA_PREFIX}Feats`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAGH] = `${Parser.UA_PREFIX}Gothic Heroes`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAMDM] = `${Parser.UA_PREFIX}Modern Magic`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UASSP] = `${Parser.UA_PREFIX}Starter Spells`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UATMC] = `${Parser.UA_PREFIX}The Mystic Class`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UATOBM] = `${Parser.UA_PREFIX}That Old Black Magic`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UATRR] = `${Parser.UA_PREFIX}The Ranger, Revised`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAWA] = `${Parser.UA_PREFIX}Waterborne Adventures`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAVR] = `${Parser.UA_PREFIX}Variant Rules`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UALDR] = `${Parser.UA_PREFIX}Light, Dark, Underdark!`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UARAR] = `${Parser.UA_PREFIX}Ranger and Rogue`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAATOSC] = `${Parser.UA_PREFIX}A Trio of Subclasses`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UABPP] = `${Parser.UA_PREFIX}Barbarian Primal Paths`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UARSC] = `${Parser.UA_PREFIX}Revised Subclasses`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAKOO] = `${Parser.UA_PREFIX}Kits of Old`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UABBC] = `${Parser.UA_PREFIX}Bard: Bard Colleges`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UACDD] = `${Parser.UA_PREFIX}Cleric: Divine Domains`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAD] = `${Parser.UA_PREFIX}Druid`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UARCO] = `${Parser.UA_PREFIX}Revised Class Options`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAF] = `${Parser.UA_PREFIX}Fighter`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAM] = `${Parser.UA_PREFIX}Monk`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAP] = `${Parser.UA_PREFIX}Paladin`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAMC] = `${Parser.UA_PREFIX}Modifying Classes`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAS] = `${Parser.UA_PREFIX}Sorcerer`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAWAW] = `${Parser.UA_PREFIX}Warlock and Wizard`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UATF] = `${Parser.UA_PREFIX}The Faithful`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAWR] = `${Parser.UA_PREFIX}Wizard Revisited`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAESR] = `${Parser.UA_PREFIX}Elf Subraces`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAMAC] = `${Parser.UA_PREFIX}Mass Combat`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UA3PE] = `${Parser.UA_PREFIX}Three-Pillar Experience`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAGHI] = `${Parser.UA_PREFIX}Greyhawk Initiative`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UATSC] = `${Parser.UA_PREFIX}Three Subclasses`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAOD] = `${Parser.UA_PREFIX}Order Domain`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UACAM] = `${Parser.UA_PREFIX}Centaurs and Minotaurs`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAGSS] = `${Parser.UA_PREFIX}Giant Soul Sorcerer`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UARoE] = `${Parser.UA_PREFIX}Races of Eberron`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UARoR] = `${Parser.UA_PREFIX}Races of Ravnica`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAWGE] = "Wayfinder's Guide to Eberron";
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAOSS] = `${Parser.UA_PREFIX}Of Ships and the Sea`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UASIK] = `${Parser.UA_PREFIX}Sidekicks`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAAR] = `${Parser.UA_PREFIX}Artificer Revisited`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UABAM] = `${Parser.UA_PREFIX}Barbarian and Monk`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UASAW] = `${Parser.UA_PREFIX}Sorcerer and Warlock`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UABAP] = `${Parser.UA_PREFIX}Bard and Paladin`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UACDW] = `${Parser.UA_PREFIX}Cleric, Druid, and Wizard`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAFRR] = `${Parser.UA_PREFIX}Fighter, Ranger, and Rogue`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UACFV] = `${Parser.UA_PREFIX}Class Feature Variants`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAFRW] = `${Parser.UA_PREFIX}Fighter, Rogue, and Wizard`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAPCRM] = `${Parser.UA_PREFIX}Prestige Classes and Rune Magic`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UAR] = `${Parser.UA_PREFIX}Ranger`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UA2020SC1] = `${Parser.UA_PREFIX}2020 Subclasses, Part 1`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UA2020SC2] = `${Parser.UA_PREFIX}2020 Subclasses, Part 2`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UA2020SC3] = `${Parser.UA_PREFIX}2020 Subclasses, Part 3`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UA2020SC4] = `${Parser.UA_PREFIX}2020 Subclasses, Part 4`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UA2020SC5] = `${Parser.UA_PREFIX}2020 Subclasses, Part 5`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UA2020SMT] = `${Parser.UA_PREFIX}2020 Spells and Magic Tattoos`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UA2020POR] = `${Parser.UA_PREFIX}2020 Psionic Options Revisited`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UA2020SCR] = `${Parser.UA_PREFIX}2020 Subclasses Revisited`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UA2020F] = `${Parser.UA_PREFIX}2020 Feats`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UA2021GL] = `${Parser.UA_PREFIX}2021 Gothic Lineages`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UA2021FF] = `${Parser.UA_PREFIX}2021 Folk of the Feywild`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UA2021DO] = `${Parser.UA_PREFIX}2021 Draconic Options`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UA2021MoS] = `${Parser.UA_PREFIX}2021 Mages of Strixhaven`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UA2021TotM] = `${Parser.UA_PREFIX}2021 Travelers of the Multiverse`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UA2022HoK] = `${Parser.UA_PREFIX}2022 Heroes of Krynn`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UA2022HoKR] = `${Parser.UA_PREFIX}2022 Heroes of Krynn Revisited`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UA2022GO] = `${Parser.UA_PREFIX}2022 Giant Options`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_UA2022WotM] = `${Parser.UA_PREFIX}2022 Wonders of the Multiverse`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MCV1SC] = `${Parser.MCVX_PREFIX}1: Spelljammer Creatures`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MCV2DC] = `${Parser.MCVX_PREFIX}2: Dragonlance Creatures`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MCV3MC] = `${Parser.MCVX_PREFIX}3: Minecraft Creatures`;
Parser.SOURCE_JSON_TO_FULL[Parser.SRC_MisMV1] = `${Parser.MisMVX_PREFIX}1`;

Parser.SOURCE_JSON_TO_ABV = {};
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_CoS] = "CoS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_DMG] = "DMG";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_EEPC] = "EEPC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_EET] = "EET";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_HotDQ] = "HotDQ";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_LMoP] = "LMoP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MM] = "MM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_OotA] = "OotA";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_PHB] = "PHB";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_PotA] = "PotA";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_RoT] = "RoT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_RoTOS] = "RoTOS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SCAG] = "SCAG";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SKT] = "SKT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_ToA] = "ToA";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TLK] = "TLK";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_ToD] = "ToD";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TTP] = "TTP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TYP] = "TftYP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TYP_AtG] = "TftYP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TYP_DiT] = "TftYP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TYP_TFoF] = "TftYP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TYP_THSoT] = "TftYP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TYP_TSC] = "TftYP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TYP_ToH] = "TftYP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TYP_WPM] = "TftYP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_VGM] = "VGM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_XGE] = "XGE";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_OGA] = "OGA";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MTF] = "MTF";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_WDH] = "WDH";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_WDMM] = "WDMM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_GGR] = "GGR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_KKW] = "KKW";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_LLK] = "LLK";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AZfyT] = "AZfyT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_GoS] = "GoS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AI] = "AI";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_OoW] = "OoW";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_ESK] = "ESK";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_DIP] = "DIP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_HftT] = "HftT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_DC] = "DC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SLW] = "SLW";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SDW] = "SDW";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_BGDIA] = "BGDIA";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_LR] = "LR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AL] = "AL";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SAC] = "SAC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_ERLW] = "ERLW";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_EFR] = "EFR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_RMBRE] = "RMBRE";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_RMR] = "RMR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MFF] = "MFF";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AWM] = "AWM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_IMR] = "IMR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SADS] = "SADS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_EGW] = "EGW";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_EGW_ToR] = "ToR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_EGW_DD] = "DD";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_EGW_FS] = "FS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_EGW_US] = "US";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MOT] = "MOT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_IDRotF] = "IDRotF";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_TCE] = "TCE";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_VRGR] = "VRGR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_HoL] = "HoL";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_RtG] = "RtG";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AitFR] = "AitFR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AitFR_ISF] = "AitFR-ISF";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AitFR_THP] = "AitFR-THP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AitFR_AVT] = "AitFR-AVT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AitFR_DN] = "AitFR-DN";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AitFR_FCD] = "AitFR-FCD";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_WBtW] = "WBtW";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_DoD] = "DoD";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MaBJoV] = "MaBJoV";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_FTD] = "FTD";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SCC] = "SCC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SCC_CK] = "SCC-CK";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SCC_HfMT] = "SCC-HfMT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SCC_TMM] = "SCC-TMM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SCC_ARiR] = "SCC-ARiR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MPMM] = "MPMM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_CRCotN] = "CRCotN";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_JttRC] = "JttRC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SAiS] = "SAiS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_AAG] = "AAG";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_BAM] = "BAM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_LoX] = "LoX";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_DoSI] = "DoSI";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_DSotDQ] = "DSotDQ";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_KftGV] = "KftGV";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SCREEN] = "Screen";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SCREEN_WILDERNESS_KIT] = "ScWild";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SCREEN_DUNGEON_KIT] = "ScDun";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SCREEN_SPELLJAMMER] = "ScSJ";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_HEROES_FEAST] = "HF";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_CM] = "CM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_NRH] = "NRH";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_NRH_TCMC] = "NRH-TCMC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_NRH_AVitW] = "NRH-AVitW";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_NRH_ASS] = "NRH-ASS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_NRH_CoI] = "NRH-CoI";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_NRH_TLT] = "NRH-TLT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_NRH_AWoL] = "NRH-AWoL";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_NRH_AT] = "NRH-AT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MGELFT] = "MGELFT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_VD] = "VD";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_SjA] = "SjA";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_HAT_TG] = "HAT-TG";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_HAT_LMI] = "HAT-LMI";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_ALCoS] = "ALCoS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_ALEE] = "ALEE";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_ALRoD] = "ALRoD";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_PSA] = "PSA";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_PSI] = "PSI";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_PSK] = "PSK";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_PSZ] = "PSZ";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_PSX] = "PSX";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_PSD] = "PSD";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_XMtS] = "XMtS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAA] = "UAA";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAEAG] = "UAEaG";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAEBB] = "UAEB";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAFFR] = "UAFFR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAFFS] = "UAFFS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAFO] = "UAFO";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAFT] = "UAFT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAGH] = "UAGH";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAMDM] = "UAMM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UASSP] = "UASS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UATMC] = "UAMy";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UATOBM] = "UAOBM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UATRR] = "UATRR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAWA] = "UAWA";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAVR] = "UAVR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UALDR] = "UALDU";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UARAR] = "UARAR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAATOSC] = "UAATOSC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UABPP] = "UABPP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UARSC] = "UARSC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAKOO] = "UAKoO";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UABBC] = "UABBC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UACDD] = "UACDD";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAD] = "UAD";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UARCO] = "UARCO";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAF] = "UAF";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAM] = "UAMk";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAP] = "UAP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAMC] = "UAMC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAS] = "UAS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAWAW] = "UAWAW";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UATF] = "UATF";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAWR] = "UAWR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAESR] = "UAESR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAMAC] = "UAMAC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UA3PE] = "UA3PE";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAGHI] = "UAGHI";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UATSC] = "UATSC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAOD] = "UAOD";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UACAM] = "UACAM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAGSS] = "UAGSS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UARoE] = "UARoE";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UARoR] = "UARoR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAWGE] = "WGE";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAOSS] = "UAOSS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UASIK] = "UASIK";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAAR] = "UAAR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UABAM] = "UABAM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UASAW] = "UASAW";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UABAP] = "UABAP";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UACDW] = "UACDW";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAFRR] = "UAFRR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UACFV] = "UACFV";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAFRW] = "UAFRW";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAPCRM] = "UAPCRM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UAR] = "UAR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UA2020SC1] = "UA20S1";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UA2020SC2] = "UA20S2";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UA2020SC3] = "UA20S3";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UA2020SC4] = "UA20S4";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UA2020SC5] = "UA20S5";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UA2020SMT] = "UA20SMT";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UA2020POR] = "UA20POR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UA2020SCR] = "UA20SCR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UA2020F] = "UA20F";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UA2021GL] = "UA21GL";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UA2021FF] = "UA21FF";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UA2021DO] = "UA21DO";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UA2021MoS] = "UA21MoS";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UA2021TotM] = "UA21TotM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UA2022HoK] = "UA22HoK";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UA2022HoKR] = "UA22HoKR";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UA2022GO] = "UA22GO";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_UA2022WotM] = "UA22WotM";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MCV1SC] = "MCV1SC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MCV2DC] = "MCV2DC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MCV3MC] = "MCV3MC";
Parser.SOURCE_JSON_TO_ABV[Parser.SRC_MisMV1] = "MisMV1";

Parser.SOURCE_JSON_TO_DATE = {};
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_CoS] = "2016-03-15";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_DMG] = "2014-12-09";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_EEPC] = "2015-03-10";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_EET] = "2015-03-10";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_HotDQ] = "2014-08-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_LMoP] = "2014-07-15";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MM] = "2014-09-30";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_OotA] = "2015-09-15";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_PHB] = "2014-08-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_PotA] = "2015-04-07";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_RoT] = "2014-11-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_RoTOS] = "2014-11-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SCAG] = "2015-11-03";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SKT] = "2016-09-06";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_ToA] = "2017-09-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TLK] = "2017-11-28";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_ToD] = "2019-10-22";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TTP] = "2017-09-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TYP] = "2017-04-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TYP_AtG] = "2017-04-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TYP_DiT] = "2017-04-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TYP_TFoF] = "2017-04-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TYP_THSoT] = "2017-04-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TYP_TSC] = "2017-04-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TYP_ToH] = "2017-04-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TYP_WPM] = "2017-04-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_VGM] = "2016-11-15";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_XGE] = "2017-11-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_OGA] = "2017-10-11";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MTF] = "2018-05-29";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_WDH] = "2018-09-18";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_WDMM] = "2018-11-20";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_GGR] = "2018-11-20";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_KKW] = "2018-11-20";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_LLK] = "2018-11-10";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AZfyT] = "2019-03-05";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_GoS] = "2019-05-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AI] = "2019-06-18";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_OoW] = "2019-06-18";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_ESK] = "2019-06-24";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_DIP] = "2019-06-24";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_HftT] = "2019-05-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_DC] = "2019-06-24";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SLW] = "2019-06-24";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SDW] = "2019-06-24";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_BGDIA] = "2019-09-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_LR] = "2019-09-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SAC] = "2019-01-31";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_ERLW] = "2019-11-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_EFR] = "2019-11-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_RMBRE] = "2019-11-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_RMR] = "2019-11-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MFF] = "2019-11-12";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AWM] = "2019-11-12";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_IMR] = "2019-11-12";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SADS] = "2019-12-12";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_EGW] = "2020-03-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_EGW_ToR] = "2020-03-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_EGW_DD] = "2020-03-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_EGW_FS] = "2020-03-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_EGW_US] = "2020-03-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MOT] = "2020-06-02";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_IDRotF] = "2020-09-15";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_TCE] = "2020-11-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_VRGR] = "2021-05-18";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_HoL] = "2021-05-18";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_RtG] = "2021-05-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AitFR] = "2021-06-30";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AitFR_ISF] = "2021-06-30";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AitFR_THP] = "2021-07-07";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AitFR_AVT] = "2021-07-14";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AitFR_DN] = "2021-07-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AitFR_FCD] = "2021-07-28";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_WBtW] = "2021-09-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_DoD] = "2021-09-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MaBJoV] = "2021-10-05";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_FTD] = "2021-11-26";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SCC] = "2021-12-07";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SCC_CK] = "2021-12-07";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SCC_HfMT] = "2021-12-07";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SCC_TMM] = "2021-12-07";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SCC_ARiR] = "2021-12-07";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MPMM] = "2022-01-25";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_CRCotN] = "2022-03-15";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_JttRC] = "2022-07-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SAiS] = "2022-08-16";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_AAG] = "2022-08-16";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_BAM] = "2022-08-16";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_LoX] = "2022-08-16";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_DoSI] = "2022-07-31";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_DSotDQ] = "2022-11-22";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_KftGV] = "2023-02-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SCREEN] = "2015-01-20";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SCREEN_WILDERNESS_KIT] = "2020-11-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SCREEN_DUNGEON_KIT] = "2020-09-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SCREEN_SPELLJAMMER] = "2022-08-16";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_HEROES_FEAST] = "2020-10-27";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_CM] = "2021-03-16";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_NRH] = "2021-09-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_NRH_TCMC] = "2021-09-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_NRH_AVitW] = "2021-09-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_NRH_ASS] = "2021-09-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_NRH_CoI] = "2021-09-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_NRH_TLT] = "2021-09-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_NRH_AWoL] = "2021-09-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_NRH_AT] = "2021-09-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MGELFT] = "2020-12-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_VD] = "2022-06-09";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_SjA] = "2022-07-11"; Parser.SOURCE_JSON_TO_DATE[Parser.SRC_HAT_TG] = "2023-03-06";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_HAT_LMI] = "2023-03-31";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_ALCoS] = "2016-03-15";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_ALEE] = "2015-04-07";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_ALRoD] = "2015-09-15";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_PSA] = "2017-07-06";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_PSI] = "2016-07-12";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_PSK] = "2017-02-16";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_PSZ] = "2016-04-27";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_PSX] = "2018-01-09";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_PSD] = "2018-07-31";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_XMtS] = "2017-12-11";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAEBB] = "2015-02-02";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAA] = "2017-01-09";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAEAG] = "2017-09-11";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAFFR] = "2017-04-24";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAFFS] = "2017-04-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAFO] = "2017-10-09";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAFT] = "2016-06-06";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAGH] = "2016-04-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAMDM] = "2015-08-03";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UASSP] = "2017-04-03";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UATMC] = "2017-03-13";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UATOBM] = "2015-12-07";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UATRR] = "2016-09-12";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAWA] = "2015-05-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAVR] = "2015-06-08";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UALDR] = "2015-11-02";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UARAR] = "2017-01-16";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAATOSC] = "2017-03-27";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UABPP] = "2016-11-07";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UARSC] = "2017-05-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAKOO] = "2016-01-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UABBC] = "2016-11-14";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UACDD] = "2016-11-12";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAD] = "2016-11-28";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UARCO] = "2017-06-05";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAF] = "2016-12-5";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAM] = "2016-12-12";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAP] = "2016-12-19";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAMC] = "2015-04-06";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAS] = "2017-02-06";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAWAW] = "2017-02-13";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UATF] = "2016-08-01";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAWR] = "2017-03-20";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAESR] = "2017-11-13";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAMAC] = "2017-02-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UA3PE] = "2017-08-07";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAGHI] = "2017-07-10";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UATSC] = "2018-01-08";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAOD] = "2018-04-09";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UACAM] = "2018-05-14";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAGSS] = "2018-06-11";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UARoE] = "2018-07-23";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UARoR] = "2018-08-13";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAWGE] = "2018-07-23";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAOSS] = "2018-11-12";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UASIK] = "2018-12-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAAR] = "2019-02-28";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UABAM] = "2019-08-15";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UASAW] = "2019-09-05";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UABAP] = "2019-09-18";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UACDW] = "2019-10-03";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAFRR] = "2019-10-17";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UACFV] = "2019-11-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAFRW] = "2019-11-25";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAPCRM] = "2015-10-05";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UAR] = "2015-09-09";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UA2020SC1] = "2020-01-14";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UA2020SC2] = "2020-02-04";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UA2020SC3] = "2020-02-24";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UA2020SC4] = "2020-08-05";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UA2020SC5] = "2020-10-26";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UA2020SMT] = "2020-03-26";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UA2020POR] = "2020-04-14";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UA2020SCR] = "2020-05-12";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UA2020F] = "2020-07-13";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UA2021GL] = "2020-01-26";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UA2021FF] = "2020-03-12";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UA2021DO] = "2021-04-14";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UA2021MoS] = "2021-06-08";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UA2021TotM] = "2021-10-08";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UA2022HoK] = "2022-03-08";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UA2022HoKR] = "2022-04-25";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UA2022GO] = "2022-05-26";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_UA2022WotM] = "2022-07-18";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MCV1SC] = "2022-04-21";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MCV2DC] = "2022-12-05";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MCV3MC] = "2023-03-28";
Parser.SOURCE_JSON_TO_DATE[Parser.SRC_MisMV1] = "2023-05-03";

Parser.SOURCES_ADVENTURES = new Set([
	Parser.SRC_LMoP,
	Parser.SRC_HotDQ,
	Parser.SRC_RoT,
	Parser.SRC_RoTOS,
	Parser.SRC_PotA,
	Parser.SRC_OotA,
	Parser.SRC_CoS,
	Parser.SRC_SKT,
	Parser.SRC_TYP,
	Parser.SRC_TYP_AtG,
	Parser.SRC_TYP_DiT,
	Parser.SRC_TYP_TFoF,
	Parser.SRC_TYP_THSoT,
	Parser.SRC_TYP_TSC,
	Parser.SRC_TYP_ToH,
	Parser.SRC_TYP_WPM,
	Parser.SRC_ToA,
	Parser.SRC_TLK,
	Parser.SRC_TTP,
	Parser.SRC_WDH,
	Parser.SRC_LLK,
	Parser.SRC_WDMM,
	Parser.SRC_KKW,
	Parser.SRC_AZfyT,
	Parser.SRC_GoS,
	Parser.SRC_HftT,
	Parser.SRC_OoW,
	Parser.SRC_DIP,
	Parser.SRC_SLW,
	Parser.SRC_SDW,
	Parser.SRC_DC,
	Parser.SRC_BGDIA,
	Parser.SRC_LR,
	Parser.SRC_EFR,
	Parser.SRC_RMBRE,
	Parser.SRC_IMR,
	Parser.SRC_EGW_ToR,
	Parser.SRC_EGW_DD,
	Parser.SRC_EGW_FS,
	Parser.SRC_EGW_US,
	Parser.SRC_IDRotF,
	Parser.SRC_CM,
	Parser.SRC_HoL,
	Parser.SRC_XMtS,
	Parser.SRC_RtG,
	Parser.SRC_AitFR,
	Parser.SRC_AitFR_ISF,
	Parser.SRC_AitFR_THP,
	Parser.SRC_AitFR_AVT,
	Parser.SRC_AitFR_DN,
	Parser.SRC_AitFR_FCD,
	Parser.SRC_WBtW,
	Parser.SRC_NRH,
	Parser.SRC_NRH_TCMC,
	Parser.SRC_NRH_AVitW,
	Parser.SRC_NRH_ASS,
	Parser.SRC_NRH_CoI,
	Parser.SRC_NRH_TLT,
	Parser.SRC_NRH_AWoL,
	Parser.SRC_NRH_AT,
	Parser.SRC_SCC,
	Parser.SRC_SCC_CK,
	Parser.SRC_SCC_HfMT,
	Parser.SRC_SCC_TMM,
	Parser.SRC_SCC_ARiR,
	Parser.SRC_CRCotN,
	Parser.SRC_JttRC,
	Parser.SRC_SjA,
	Parser.SRC_LoX,
	Parser.SRC_DoSI,
	Parser.SRC_DSotDQ,
	Parser.SRC_KftGV,

	Parser.SRC_AWM,
]);
Parser.SOURCES_CORE_SUPPLEMENTS = new Set(Object.keys(Parser.SOURCE_JSON_TO_FULL).filter(it => !Parser.SOURCES_ADVENTURES.has(it)));
Parser.SOURCES_NON_STANDARD_WOTC = new Set([
	Parser.SRC_OGA,
	Parser.SRC_LLK,
	Parser.SRC_AZfyT,
	Parser.SRC_LR,
	Parser.SRC_TLK,
	Parser.SRC_TTP,
	Parser.SRC_AWM,
	Parser.SRC_IMR,
	Parser.SRC_SADS,
	Parser.SRC_MFF,
	Parser.SRC_XMtS,
	Parser.SRC_RtG,
	Parser.SRC_AitFR,
	Parser.SRC_AitFR_ISF,
	Parser.SRC_AitFR_THP,
	Parser.SRC_AitFR_AVT,
	Parser.SRC_AitFR_DN,
	Parser.SRC_AitFR_FCD,
	Parser.SRC_DoD,
	Parser.SRC_MaBJoV,
	Parser.SRC_NRH,
	Parser.SRC_NRH_TCMC,
	Parser.SRC_NRH_AVitW,
	Parser.SRC_NRH_ASS,
	Parser.SRC_NRH_CoI,
	Parser.SRC_NRH_TLT,
	Parser.SRC_NRH_AWoL,
	Parser.SRC_NRH_AT,
	Parser.SRC_MGELFT,
	Parser.SRC_VD,
	Parser.SRC_SjA,
	Parser.SRC_HAT_TG,
	Parser.SRC_HAT_LMI,
	Parser.SRC_MCV3MC,
	Parser.SRC_MisMV1,
]);

Parser.SOURCES_VANILLA = new Set([
	Parser.SRC_DMG,
	Parser.SRC_MM,
	Parser.SRC_PHB,
	Parser.SRC_SCAG,
			Parser.SRC_XGE,
		Parser.SRC_SAC,
	Parser.SRC_MFF,
	Parser.SRC_SADS,
	Parser.SRC_TCE,
	Parser.SRC_FTD,
	Parser.SRC_MPMM,
	Parser.SRC_SCREEN,
	Parser.SRC_SCREEN_WILDERNESS_KIT,
	Parser.SRC_SCREEN_DUNGEON_KIT,
	Parser.SRC_VD,
]);

Parser.SOURCES_COMEDY = new Set([
	Parser.SRC_AI,
	Parser.SRC_OoW,
	Parser.SRC_RMR,
	Parser.SRC_RMBRE,
	Parser.SRC_HftT,
	Parser.SRC_AWM,
	Parser.SRC_MGELFT,
	Parser.SRC_HAT_TG,
	Parser.SRC_HAT_LMI,
	Parser.SRC_MCV3MC,
	Parser.SRC_MisMV1,
]);

Parser.SOURCES_NON_FR = new Set([
	Parser.SRC_GGR,
	Parser.SRC_KKW,
	Parser.SRC_ERLW,
	Parser.SRC_EFR,
	Parser.SRC_UAWGE,
	Parser.SRC_EGW,
	Parser.SRC_EGW_ToR,
	Parser.SRC_EGW_DD,
	Parser.SRC_EGW_FS,
	Parser.SRC_EGW_US,
	Parser.SRC_MOT,
	Parser.SRC_XMtS,
	Parser.SRC_AZfyT,
	Parser.SRC_SCC,
	Parser.SRC_SCC_CK,
	Parser.SRC_SCC_HfMT,
	Parser.SRC_SCC_TMM,
	Parser.SRC_SCC_ARiR,
	Parser.SRC_CRCotN,
	Parser.SRC_SjA,
	Parser.SRC_SAiS,
	Parser.SRC_AAG,
	Parser.SRC_BAM,
	Parser.SRC_LoX,
	Parser.SRC_DSotDQ,
]);

Parser.SOURCES_AVAILABLE_DOCS_BOOK = {};
[
	Parser.SRC_PHB,
	Parser.SRC_MM,
	Parser.SRC_DMG,
	Parser.SRC_SCAG,
	Parser.SRC_VGM,
	Parser.SRC_OGA,
	Parser.SRC_XGE,
	Parser.SRC_MTF,
	Parser.SRC_GGR,
	Parser.SRC_AI,
	Parser.SRC_ERLW,
	Parser.SRC_RMR,
	Parser.SRC_EGW,
	Parser.SRC_MOT,
	Parser.SRC_TCE,
	Parser.SRC_VRGR,
	Parser.SRC_DoD,
	Parser.SRC_MaBJoV,
	Parser.SRC_FTD,
	Parser.SRC_SCC,
	Parser.SRC_MPMM,
	Parser.SRC_AAG,
	Parser.SRC_BAM,
	Parser.SRC_HAT_TG,
	Parser.SRC_SCREEN,
	Parser.SRC_SCREEN_WILDERNESS_KIT,
	Parser.SRC_SCREEN_DUNGEON_KIT,
	Parser.SRC_SCREEN_SPELLJAMMER,
].forEach(src => {
	Parser.SOURCES_AVAILABLE_DOCS_BOOK[src] = src;
	Parser.SOURCES_AVAILABLE_DOCS_BOOK[src.toLowerCase()] = src;
});
[
	{src: Parser.SRC_PSA, id: "PS-A"},
	{src: Parser.SRC_PSI, id: "PS-I"},
	{src: Parser.SRC_PSK, id: "PS-K"},
	{src: Parser.SRC_PSZ, id: "PS-Z"},
	{src: Parser.SRC_PSX, id: "PS-X"},
	{src: Parser.SRC_PSD, id: "PS-D"},
].forEach(({src, id}) => {
	Parser.SOURCES_AVAILABLE_DOCS_BOOK[src] = id;
	Parser.SOURCES_AVAILABLE_DOCS_BOOK[src.toLowerCase()] = id;
});
Parser.SOURCES_AVAILABLE_DOCS_ADVENTURE = {};
[
	Parser.SRC_LMoP,
	Parser.SRC_HotDQ,
	Parser.SRC_RoT,
	Parser.SRC_PotA,
	Parser.SRC_OotA,
	Parser.SRC_CoS,
	Parser.SRC_SKT,
	Parser.SRC_TYP_AtG,
	Parser.SRC_TYP_DiT,
	Parser.SRC_TYP_TFoF,
	Parser.SRC_TYP_THSoT,
	Parser.SRC_TYP_TSC,
	Parser.SRC_TYP_ToH,
	Parser.SRC_TYP_WPM,
	Parser.SRC_ToA,
	Parser.SRC_TLK,
	Parser.SRC_TTP,
	Parser.SRC_WDH,
	Parser.SRC_LLK,
	Parser.SRC_WDMM,
	Parser.SRC_KKW,
	Parser.SRC_AZfyT,
	Parser.SRC_GoS,
	Parser.SRC_HftT,
	Parser.SRC_OoW,
	Parser.SRC_DIP,
	Parser.SRC_SLW,
	Parser.SRC_SDW,
	Parser.SRC_DC,
	Parser.SRC_BGDIA,
	Parser.SRC_LR,
	Parser.SRC_EFR,
	Parser.SRC_RMBRE,
	Parser.SRC_IMR,
	Parser.SRC_EGW_ToR,
	Parser.SRC_EGW_DD,
	Parser.SRC_EGW_FS,
	Parser.SRC_EGW_US,
	Parser.SRC_IDRotF,
	Parser.SRC_CM,
	Parser.SRC_HoL,
	Parser.SRC_XMtS,
	Parser.SRC_RtG,
	Parser.SRC_AitFR_ISF,
	Parser.SRC_AitFR_THP,
	Parser.SRC_AitFR_AVT,
	Parser.SRC_AitFR_DN,
	Parser.SRC_AitFR_FCD,
	Parser.SRC_WBtW,
	Parser.SRC_NRH,
	Parser.SRC_NRH_TCMC,
	Parser.SRC_NRH_AVitW,
	Parser.SRC_NRH_ASS,
	Parser.SRC_NRH_CoI,
	Parser.SRC_NRH_TLT,
	Parser.SRC_NRH_AWoL,
	Parser.SRC_NRH_AT,
	Parser.SRC_SCC_CK,
	Parser.SRC_SCC_HfMT,
	Parser.SRC_SCC_TMM,
	Parser.SRC_SCC_ARiR,
	Parser.SRC_CRCotN,
	Parser.SRC_JttRC,
	Parser.SRC_LoX,
	Parser.SRC_DoSI,
	Parser.SRC_DSotDQ,
	Parser.SRC_KftGV,
].forEach(src => {
	Parser.SOURCES_AVAILABLE_DOCS_ADVENTURE[src] = src;
	Parser.SOURCES_AVAILABLE_DOCS_ADVENTURE[src.toLowerCase()] = src;
});

Parser.getTagSource = function (tag, source) {
	if (source && source.trim()) return source;

	tag = tag.trim();

	const tagMeta = Renderer.tag.TAG_LOOKUP[tag];

	if (!tagMeta) throw new Error(`Unhandled tag "${tag}"`);
	return tagMeta.defaultSource;
};

Parser.PROP_TO_TAG = {
	"monster": "creature",
	"optionalfeature": "optfeature",
	"tableGroup": "table",
	"vehicleUpgrade": "vehupgrade",
	"baseitem": "item",
	"itemGroup": "item",
	"magicvariant": "item",
};
Parser.getPropTag = function (prop) {
	if (Parser.PROP_TO_TAG[prop]) return Parser.PROP_TO_TAG[prop];
	return prop;
};

Parser.PROP_TO_DISPLAY_NAME = {
	"variantrule": "Variant Rule",
	"optionalfeature": "Option/Feature",
	"magicvariant": "Magic Item Variant",
	"baseitem": "Item (Base)",
	"item": "Item",
	"adventure": "Adventure",
	"adventureData": "Adventure Text",
	"book": "Book",
	"bookData": "Book Text",
	"makebrewCreatureTrait": "Homebrew Builder Creature Trait",
	"charoption": "Other Character Creation Option",

	"bonus": "Bonus Action",
	"legendary": "Legendary Action",
	"mythic": "Mythic Action",
	"lairActions": "Lair Action",
	"regionalEffects": "Regional Effect",
};
Parser.getPropDisplayName = function (prop, {suffix = ""} = {}) {
	if (Parser.PROP_TO_DISPLAY_NAME[prop]) return `${Parser.PROP_TO_DISPLAY_NAME[prop]}${suffix}`;

	const mFluff = /Fluff$/.exec(prop);
	if (mFluff) return Parser.getPropDisplayName(prop.slice(0, -mFluff[0].length), {suffix: " Fluff"});

	const mFoundry = /^foundry(?<prop>[A-Z].*)$/.exec(prop);
	if (mFoundry) return Parser.getPropDisplayName(mFoundry.groups.prop.lowercaseFirst(), {suffix: " Foundry Data"});

	return `${prop.split(/([A-Z][a-z]+)/g).join(" ").uppercaseFirst()}${suffix}`;
};

Parser.ITEM_TYPE_JSON_TO_ABV = {
	"A": "ammunition",
	"AF": "ammunition",
	"AT": "artisan's tools",
	"EM": "eldritch machine",
	"EXP": "explosive",
	"FD": "food and drink",
	"G": "adventuring gear",
	"GS": "gaming set",
	"HA": "heavy armor",
	"INS": "instrument",
	"LA": "light armor",
	"M": "melee weapon",
	"MA": "medium armor",
	"MNT": "mount",
	"MR": "master rune",
	"GV": "generic variant",
	"P": "potion",
	"R": "ranged weapon",
	"RD": "rod",
	"RG": "ring",
	"S": "shield",
	"SC": "scroll",
	"SCF": "spellcasting focus",
	"OTH": "other",
	"T": "tools",
	"TAH": "tack and harness",
	"TG": "trade good",
	"$": "treasure",
	"VEH": "vehicle (land)",
	"SHP": "vehicle (water)",
	"AIR": "vehicle (air)",
	"SPC": "vehicle (space)",
	"WD": "wand",
};

Parser.DMGTYPE_JSON_TO_FULL = {
	"A": "acid",
	"B": "bludgeoning",
	"C": "cold",
	"F": "fire",
	"O": "force",
	"L": "lightning",
	"N": "necrotic",
	"P": "piercing",
	"I": "poison",
	"Y": "psychic",
	"R": "radiant",
	"S": "slashing",
	"T": "thunder",
};

Parser.DMG_TYPES = ["acid", "bludgeoning", "cold", "fire", "force", "lightning", "necrotic", "piercing", "poison", "psychic", "radiant", "slashing", "thunder"];
Parser.CONDITIONS = ["blinded", "charmed", "deafened", "exhaustion", "frightened", "grappled", "incapacitated", "invisible", "paralyzed", "petrified", "poisoned", "prone", "restrained", "stunned", "unconscious"];

Parser.SENSES = [
	{"name": "blindsight", "source": Parser.SRC_PHB},
	{"name": "darkvision", "source": Parser.SRC_PHB},
	{"name": "tremorsense", "source": Parser.SRC_MM},
	{"name": "truesight", "source": Parser.SRC_PHB},
];

Parser.NUMBERS_ONES = ["", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"];
Parser.NUMBERS_TENS = ["", "", "twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety"];
Parser.NUMBERS_TEENS = ["ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen"];

Parser.metric = {
		MILES_TO_KILOMETRES: 1.6,
	FEET_TO_METRES: 0.3, 	YARDS_TO_METRES: 0.9, 	POUNDS_TO_KILOGRAMS: 0.5, 
	getMetricNumber ({originalValue, originalUnit, toFixed = null}) {
		if (isNaN(originalValue)) return originalValue;
		originalValue = Number(originalValue);
		if (!originalValue) return originalValue;

		let out = null;
		switch (originalUnit) {
			case "ft.": case "ft": case Parser.UNT_FEET: out = originalValue * Parser.metric.FEET_TO_METRES; break;
			case "yd.": case "yd": case Parser.UNT_YARDS: out = originalValue * Parser.metric.YARDS_TO_METRES; break;
			case "mi.": case "mi": case Parser.UNT_MILES: out = originalValue * Parser.metric.MILES_TO_KILOMETRES; break;
			case "lb.": case "lb": case "lbs": out = originalValue * Parser.metric.POUNDS_TO_KILOGRAMS; break;
			default: return originalValue;
		}
		if (toFixed != null) return Number(out.toFixed(toFixed));
		return out;
	},

	getMetricUnit ({originalUnit, isShortForm = false, isPlural = true}) {
		switch (originalUnit) {
			case "ft.": case "ft": case Parser.UNT_FEET: return isShortForm ? "m" : `meter`[isPlural ? "toPlural" : "toString"]();
			case "yd.": case "yd": case Parser.UNT_YARDS: return isShortForm ? "m" : `meter`[isPlural ? "toPlural" : "toString"]();
			case "mi.": case "mi": case Parser.UNT_MILES: return isShortForm ? "km" : `kilometre`[isPlural ? "toPlural" : "toString"]();
			case "lb.": case "lb": case "lbs": return isShortForm ? "kg" : `kilogram`[isPlural ? "toPlural" : "toString"]();
			default: return originalUnit;
		}
	},
};

Parser.MAP_GRID_TYPE_TO_FULL = {};
Parser.MAP_GRID_TYPE_TO_FULL["none"] = "None";
Parser.MAP_GRID_TYPE_TO_FULL["square"] = "Square";
Parser.MAP_GRID_TYPE_TO_FULL["hexRowsOdd"] = "Hex Rows (Odd)";
Parser.MAP_GRID_TYPE_TO_FULL["hexRowsEven"] = "Hex Rows (Even)";
Parser.MAP_GRID_TYPE_TO_FULL["hexColsOdd"] = "Hex Columns (Odd)";
Parser.MAP_GRID_TYPE_TO_FULL["hexColsEven"] = "Hex Columns (Even)";

Parser.mapGridTypeToFull = function (gridType) {
	return Parser._parse_aToB(Parser.MAP_GRID_TYPE_TO_FULL, gridType);
};

"use strict";

globalThis.IS_DEPLOYED = undefined;
globalThis.VERSION_NUMBER = "1.181.2";
globalThis.DEPLOYED_STATIC_ROOT = ""; globalThis.DEPLOYED_IMG_ROOT = undefined;
globalThis.IS_VTT = false;

globalThis.IMGUR_CLIENT_ID = `abdea4de492d3b0`;

globalThis.HASH_PART_SEP = ",";
globalThis.HASH_LIST_SEP = "_";
globalThis.HASH_SUB_LIST_SEP = "~";
globalThis.HASH_SUB_KV_SEP = ":";
globalThis.HASH_BLANK = "blankhash";
globalThis.HASH_SUB_NONE = "null";

globalThis.VeCt = {
	STR_NONE: "None",
	STR_SEE_CONSOLE: "See the console (CTRL+SHIFT+J) for details.",

	HASH_SCALED: "scaled",
	HASH_SCALED_SPELL_SUMMON: "scaledspellsummon",
	HASH_SCALED_CLASS_SUMMON: "scaledclasssummon",

	FILTER_BOX_SUB_HASH_SEARCH_PREFIX: "fbsr",

	JSON_PRERELEASE_INDEX: `prerelease/index.json`,
	JSON_BREW_INDEX: `homebrew/index.json`,

	STORAGE_HOMEBREW: "HOMEBREW_STORAGE",
	STORAGE_HOMEBREW_META: "HOMEBREW_META_STORAGE",
	STORAGE_EXCLUDES: "EXCLUDES_STORAGE",
	STORAGE_DMSCREEN: "DMSCREEN_STORAGE",
	STORAGE_DMSCREEN_TEMP_SUBLIST: "DMSCREEN_TEMP_SUBLIST",
	STORAGE_ROLLER_MACRO: "ROLLER_MACRO_STORAGE",
	STORAGE_ENCOUNTER: "ENCOUNTER_STORAGE",
	STORAGE_POINTBUY: "POINTBUY_STORAGE",
	STORAGE_GLOBAL_COMPONENT_STATE: "GLOBAL_COMPONENT_STATE",

	DUR_INLINE_NOTIFY: 500,

	PG_NONE: "NO_PAGE",
	STR_GENERIC: "Generic",

	SYM_UI_SKIP: Symbol("uiSkip"),

	SYM_WALKER_BREAK: Symbol("walkerBreak"),

	SYM_UTIL_TIMEOUT: Symbol("timeout"),

	LOC_ORIGIN_CANCER: "https://5e.tools",

	URL_BREW: `https://github.com/TheGiddyLimit/homebrew`,
	URL_ROOT_BREW: `https://raw.githubusercontent.com/TheGiddyLimit/homebrew/master/`, 	URL_PRERELEASE: `https://github.com/TheGiddyLimit/unearthed-arcana`,
	URL_ROOT_PRERELEASE: `https://raw.githubusercontent.com/TheGiddyLimit/unearthed-arcana/master/`, 
	STR_NO_ATTUNEMENT: "No Attunement Required",

	CR_UNKNOWN: 100001,
	CR_CUSTOM: 100000,

	SPELL_LEVEL_MAX: 9,
	LEVEL_MAX: 20,

	ENTDATA_TABLE_INCLUDE: "tableInclude",
	ENTDATA_ITEM_MERGED_ENTRY_TAG: "item__mergedEntryTag",

	DRAG_TYPE_IMPORT: "ve-Import",
	DRAG_TYPE_LOOT: "ve-Loot",

	Z_INDEX_BENEATH_HOVER: 199,
};

String.prototype.uppercaseFirst = String.prototype.uppercaseFirst || function () {
	const str = this.toString();
	if (str.length === 0) return str;
	if (str.length === 1) return str.charAt(0).toUpperCase();
	return str.charAt(0).toUpperCase() + str.slice(1);
};

String.prototype.lowercaseFirst = String.prototype.lowercaseFirst || function () {
	const str = this.toString();
	if (str.length === 0) return str;
	if (str.length === 1) return str.charAt(0).toLowerCase();
	return str.charAt(0).toLowerCase() + str.slice(1);
};

String.prototype.toTitleCase = String.prototype.toTitleCase || function () {
	let str = this.replace(/([^\W_]+[^-\u2014\s/]*) */g, m0 => m0.charAt(0).toUpperCase() + m0.substring(1).toLowerCase());

		StrUtil._TITLE_LOWER_WORDS_RE = StrUtil._TITLE_LOWER_WORDS_RE || StrUtil.TITLE_LOWER_WORDS.map(it => new RegExp(`\\s${it}\\s`, "gi"));
	StrUtil._TITLE_UPPER_WORDS_RE = StrUtil._TITLE_UPPER_WORDS_RE || StrUtil.TITLE_UPPER_WORDS.map(it => new RegExp(`\\b${it}\\b`, "g"));
	StrUtil._TITLE_UPPER_WORDS_PLURAL_RE = StrUtil._TITLE_UPPER_WORDS_PLURAL_RE || StrUtil.TITLE_UPPER_WORDS_PLURAL.map(it => new RegExp(`\\b${it}\\b`, "g"));

	const len = StrUtil.TITLE_LOWER_WORDS.length;
	for (let i = 0; i < len; i++) {
		str = str.replace(
			StrUtil._TITLE_LOWER_WORDS_RE[i],
			txt => txt.toLowerCase(),
		);
	}

	const len1 = StrUtil.TITLE_UPPER_WORDS.length;
	for (let i = 0; i < len1; i++) {
		str = str.replace(
			StrUtil._TITLE_UPPER_WORDS_RE[i],
			StrUtil.TITLE_UPPER_WORDS[i].toUpperCase(),
		);
	}

	for (let i = 0; i < len1; i++) {
		str = str.replace(
			StrUtil._TITLE_UPPER_WORDS_PLURAL_RE[i],
			`${StrUtil.TITLE_UPPER_WORDS_PLURAL[i].toUpperCase()}`,
		);
	}

	str = str
		.split(/([;:?!.])/g)
		.map(pt => pt.replace(/^(\s*)([^\s])/, (...m) => `${m[1]}${m[2].toUpperCase()}`))
		.join("");

	return str;
};

String.prototype.toSentenceCase = String.prototype.toSentenceCase || function () {
	const out = [];
	const re = /([^.!?]+)([.!?]\s*|$)/gi;
	let m;
	do {
		m = re.exec(this);
		if (m) {
			out.push(m[0].toLowerCase().uppercaseFirst());
		}
	} while (m);
	return out.join("");
};

String.prototype.toSpellCase = String.prototype.toSpellCase || function () {
	return this.toLowerCase().replace(/(^|of )(bigby|otiluke|mordenkainen|evard|hadar|agathys|abi-dalzim|aganazzar|drawmij|leomund|maximilian|melf|nystul|otto|rary|snilloc|tasha|tenser|jim)('s|$| )/g, (...m) => `${m[1]}${m[2].toTitleCase()}${m[3]}`);
};

String.prototype.toCamelCase = String.prototype.toCamelCase || function () {
	return this.split(" ").map((word, index) => {
		if (index === 0) return word.toLowerCase();
		return `${word.charAt(0).toUpperCase()}${word.slice(1).toLowerCase()}`;
	}).join("");
};

String.prototype.toPlural = String.prototype.toPlural || function () {
	let plural;
	if (StrUtil.IRREGULAR_PLURAL_WORDS[this.toLowerCase()]) plural = StrUtil.IRREGULAR_PLURAL_WORDS[this.toLowerCase()];
	else if (/(s|x|z|ch|sh)$/i.test(this)) plural = `${this}es`;
	else if (/[bcdfghjklmnpqrstvwxyz]y$/i.test(this)) plural = this.replace(/y$/i, "ies");
	else plural = `${this}s`;

	if (this.toLowerCase() === this) return plural;
	if (this.toUpperCase() === this) return plural.toUpperCase();
	if (this.toTitleCase() === this) return plural.toTitleCase();
	return plural;
};

String.prototype.escapeQuotes = String.prototype.escapeQuotes || function () {
	return this.replace(/'/g, `&apos;`).replace(/"/g, `&quot;`).replace(/</g, `&lt;`).replace(/>/g, `&gt;`);
};

String.prototype.qq = String.prototype.qq || function () {
	return this.escapeQuotes();
};

String.prototype.unescapeQuotes = String.prototype.unescapeQuotes || function () {
	return this.replace(/&apos;/g, `'`).replace(/&quot;/g, `"`).replace(/&lt;/g, `<`).replace(/&gt;/g, `>`);
};

String.prototype.uq = String.prototype.uq || function () {
	return this.unescapeQuotes();
};

String.prototype.encodeApos = String.prototype.encodeApos || function () {
	return this.replace(/'/g, `%27`);
};

String.prototype.distance = String.prototype.distance || function (target) {
	let source = this; let i; let j;
	if (!source) return target ? target.length : 0;
	else if (!target) return source.length;

	const m = source.length; const n = target.length; const INF = m + n; const score = new Array(m + 2); const sd = {};
	for (i = 0; i < m + 2; i++) score[i] = new Array(n + 2);
	score[0][0] = INF;
	for (i = 0; i <= m; i++) {
		score[i + 1][1] = i;
		score[i + 1][0] = INF;
		sd[source[i]] = 0;
	}
	for (j = 0; j <= n; j++) {
		score[1][j + 1] = j;
		score[0][j + 1] = INF;
		sd[target[j]] = 0;
	}

	for (i = 1; i <= m; i++) {
		let DB = 0;
		for (j = 1; j <= n; j++) {
			const i1 = sd[target[j - 1]]; const j1 = DB;
			if (source[i - 1] === target[j - 1]) {
				score[i + 1][j + 1] = score[i][j];
				DB = j;
			} else {
				score[i + 1][j + 1] = Math.min(score[i][j], Math.min(score[i + 1][j], score[i][j + 1])) + 1;
			}
			score[i + 1][j + 1] = Math.min(score[i + 1][j + 1], score[i1] ? score[i1][j1] + (i - i1 - 1) + 1 + (j - j1 - 1) : Infinity);
		}
		sd[source[i - 1]] = i;
	}
	return score[m + 1][n + 1];
};

String.prototype.isNumeric = String.prototype.isNumeric || function () {
	return !isNaN(parseFloat(this)) && isFinite(this);
};

String.prototype.last = String.prototype.last || function () {
	return this[this.length - 1];
};

String.prototype.escapeRegexp = String.prototype.escapeRegexp || function () {
	return this.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
};

String.prototype.toUrlified = String.prototype.toUrlified || function () {
	return encodeURIComponent(this.toLowerCase()).toLowerCase();
};

String.prototype.toChunks = String.prototype.toChunks || function (size) {
		const numChunks = Math.ceil(this.length / size);
	const chunks = new Array(numChunks);
	for (let i = 0, o = 0; i < numChunks; ++i, o += size) chunks[i] = this.substr(o, size);
	return chunks;
};

String.prototype.toAscii = String.prototype.toAscii || function () {
	return this
		.normalize("NFD") 		.replace(/[\u0300-\u036f]/g, "") 		.replace(/Æ/g, "AE").replace(/æ/g, "ae");
};

String.prototype.trimChar = String.prototype.trimChar || function (ch) {
	let start = 0; let end = this.length;
	while (start < end && this[start] === ch) ++start;
	while (end > start && this[end - 1] === ch) --end;
	return (start > 0 || end < this.length) ? this.substring(start, end) : this;
};

String.prototype.trimAnyChar = String.prototype.trimAnyChar || function (chars) {
	let start = 0; let end = this.length;
	while (start < end && chars.indexOf(this[start]) >= 0) ++start;
	while (end > start && chars.indexOf(this[end - 1]) >= 0) --end;
	return (start > 0 || end < this.length) ? this.substring(start, end) : this;
};

Array.prototype.joinConjunct || Object.defineProperty(Array.prototype, "joinConjunct", {
	enumerable: false,
	writable: true,
	value: function (joiner, lastJoiner, nonOxford) {
		if (this.length === 0) return "";
		if (this.length === 1) return this[0];
		if (this.length === 2) return this.join(lastJoiner);
		else {
			let outStr = "";
			for (let i = 0; i < this.length; ++i) {
				outStr += this[i];
				if (i < this.length - 2) outStr += joiner;
				else if (i === this.length - 2) outStr += `${(!nonOxford && this.length > 2 ? joiner.trim() : "")}${lastJoiner}`;
			}
			return outStr;
		}
	},
});

globalThis.StrUtil = {
	COMMAS_NOT_IN_PARENTHESES_REGEX: /,\s?(?![^(]*\))/g,
	COMMA_SPACE_NOT_IN_PARENTHESES_REGEX: /, (?![^(]*\))/g,

	uppercaseFirst: function (string) {
		return string.uppercaseFirst();
	},
		TITLE_LOWER_WORDS: ["a", "an", "the", "and", "but", "or", "for", "nor", "as", "at", "by", "for", "from", "in", "into", "near", "of", "on", "onto", "to", "with", "over", "von"],
		TITLE_UPPER_WORDS: ["Id", "Tv", "Dm", "Ok", "Npc", "Pc", "Tpk", "Wip"],
	TITLE_UPPER_WORDS_PLURAL: ["Ids", "Tvs", "Dms", "Oks", "Npcs", "Pcs", "Tpks", "Wips"], 
	IRREGULAR_PLURAL_WORDS: {
		"cactus": "cacti",
		"child": "children",
		"die": "dice",
		"djinni": "djinn",
		"dwarf": "dwarves",
		"efreeti": "efreet",
		"elf": "elves",
		"fey": "fey",
		"foot": "feet",
		"goose": "geese",
		"ki": "ki",
		"man": "men",
		"mouse": "mice",
		"ox": "oxen",
		"person": "people",
		"sheep": "sheep",
		"tooth": "teeth",
		"undead": "undead",
		"woman": "women",
	},

	padNumber: (n, len, padder) => {
		return String(n).padStart(len, padder);
	},

	elipsisTruncate (str, atLeastPre = 5, atLeastSuff = 0, maxLen = 20) {
		if (maxLen >= str.length) return str;

		maxLen = Math.max(atLeastPre + atLeastSuff + 3, maxLen);
		let out = "";
		let remain = maxLen - (3 + atLeastPre + atLeastSuff);
		for (let i = 0; i < str.length - atLeastSuff; ++i) {
			const c = str[i];
			if (i < atLeastPre) out += c;
			else if ((remain--) > 0) out += c;
		}
		if (remain < 0) out += "...";
		out += str.substring(str.length - atLeastSuff, str.length);
		return out;
	},

	toTitleCase (str) { return str.toTitleCase(); },
	qq (str) { return (str = str || "").qq(); },
};

globalThis.CleanUtil = {
	getCleanJson (data, {isMinify = false, isFast = true} = {}) {
		data = MiscUtil.copy(data);
		data = MiscUtil.getWalker().walk(data, {string: (str) => CleanUtil.getCleanString(str, {isFast})});
		let str = isMinify ? JSON.stringify(data) : `${JSON.stringify(data, null, "\t")}\n`;
		return str.replace(CleanUtil.STR_REPLACEMENTS_REGEX, (match) => CleanUtil.STR_REPLACEMENTS[match]);
	},

	getCleanString (str, {isFast = true} = {}) {
		str = str
			.replace(CleanUtil.SHARED_REPLACEMENTS_REGEX, (match) => CleanUtil.SHARED_REPLACEMENTS[match])
			.replace(CleanUtil._SOFT_HYPHEN_REMOVE_REGEX, "")
		;

		if (isFast) return str;

		const ptrStack = {_: ""};
		CleanUtil._getCleanString_walkerStringHandler(ptrStack, 0, str);
		return ptrStack._;
	},

	_getCleanString_walkerStringHandler (ptrStack, tagCount, str) {
		const tagSplit = Renderer.splitByTags(str);
		const len = tagSplit.length;
		for (let i = 0; i < len; ++i) {
			const s = tagSplit[i];
			if (!s) continue;
			if (s.startsWith("{@")) {
				const [tag, text] = Renderer.splitFirstSpace(s.slice(1, -1));

				ptrStack._ += `{${tag}${text.length ? " " : ""}`;
				this._getCleanString_walkerStringHandler(ptrStack, tagCount + 1, text);
				ptrStack._ += `}`;
			} else {
								if (tagCount) {
					ptrStack._ += s;
				} else {
					ptrStack._ += s
						.replace(CleanUtil._DASH_COLLAPSE_REGEX, "$1")
						.replace(CleanUtil._ELLIPSIS_COLLAPSE_REGEX, "$1");
				}
			}
		}
	},
};
CleanUtil.SHARED_REPLACEMENTS = {
	"’": "'",
	"‘": "'",
	"": "'",
	"…": "...",
	"\u200B": ``, 	"ﬀ": "ff",
	"ﬃ": "ffi",
	"ﬄ": "ffl",
	"ﬁ": "fi",
	"ﬂ": "fl",
	"Ĳ": "IJ",
	"ĳ": "ij",
	"Ǉ": "LJ",
	"ǈ": "Lj",
	"ǉ": "lj",
	"Ǌ": "NJ",
	"ǋ": "Nj",
	"ǌ": "nj",
	"ﬅ": "ft",
	"“": `"`,
	"”": `"`,
};
CleanUtil.STR_REPLACEMENTS = {
	"—": "\\u2014",
	"–": "\\u2013",
	"‑": "\\u2011",
	"−": "\\u2212",
	" ": "\\u00A0",
};
CleanUtil.SHARED_REPLACEMENTS_REGEX = new RegExp(Object.keys(CleanUtil.SHARED_REPLACEMENTS).join("|"), "g");
CleanUtil.STR_REPLACEMENTS_REGEX = new RegExp(Object.keys(CleanUtil.STR_REPLACEMENTS).join("|"), "g");
CleanUtil._SOFT_HYPHEN_REMOVE_REGEX = /\u00AD *\r?\n?\r?/g;
CleanUtil._ELLIPSIS_COLLAPSE_REGEX = /\s*(\.\s*\.\s*\.)/g;
CleanUtil._DASH_COLLAPSE_REGEX = /[ ]*([\u2014\u2013])[ ]*/g;

globalThis.SourceUtil = {
	ADV_BOOK_GROUPS: [
		{group: "core", displayName: "Core"},
		{group: "supplement", displayName: "Supplements"},
		{group: "setting", displayName: "Settings"},
		{group: "supplement-alt", displayName: "Extras"},
		{group: "prerelease", displayName: "Prerelease"},
		{group: "homebrew", displayName: "Homebrew"},
		{group: "screen", displayName: "Screens"},
		{group: "other", displayName: "Miscellaneous"},
	],

	_subclassReprintLookup: {},
	async pInitSubclassReprintLookup () {
		SourceUtil._subclassReprintLookup = await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/generated/gendata-subclass-lookup.json`);
	},

	isSubclassReprinted (className, classSource, subclassShortName, subclassSource) {
		const fromLookup = MiscUtil.get(SourceUtil._subclassReprintLookup, classSource, className, subclassSource, subclassShortName);
		return fromLookup ? fromLookup.isReprinted : false;
	},

		isSiteSource (source) { return !!Parser.SOURCE_JSON_TO_FULL[source]; },

	isAdventure (source) {
		if (source instanceof FilterItem) source = source.item;
		return Parser.SOURCES_ADVENTURES.has(source);
	},

	isCoreOrSupplement (source) {
		if (source instanceof FilterItem) source = source.item;
		return Parser.SOURCES_CORE_SUPPLEMENTS.has(source);
	},

	isNonstandardSource (source) {
		if (source == null) return false;
		return (
			(typeof BrewUtil2 === "undefined" || !BrewUtil2.hasSourceJson(source))
				&& SourceUtil.isNonstandardSourceWotc(source)
		)
			|| SourceUtil.isPrereleaseSource(source);
	},

			isPrereleaseSource (source) {
		if (source == null) return false;
		if (typeof PrereleaseUtil !== "undefined" && PrereleaseUtil.hasSourceJson(source)) return true;
		return source.startsWith(Parser.SRC_UA_PREFIX)
			|| source.startsWith(Parser.SRC_UA_ONE_PREFIX);
	},

	isNonstandardSourceWotc (source) {
		return source.startsWith(Parser.SRC_UA_PREFIX) || source.startsWith(Parser.SRC_UA_ONE_PREFIX) || source.startsWith(Parser.SRC_PS_PREFIX) || source.startsWith(Parser.SRC_AL_PREFIX) || source.startsWith(Parser.SRC_MCVX_PREFIX) || Parser.SOURCES_NON_STANDARD_WOTC.has(source);
	},

	getFilterGroup (source) {
		if (source instanceof FilterItem) source = source.item;
		if (typeof PrereleaseUtil !== "undefined" && PrereleaseUtil.hasSourceJson(source)) return 1;
		if (typeof BrewUtil2 !== "undefined" && BrewUtil2.hasSourceJson(source)) return 2;
		return Number(SourceUtil.isNonstandardSource(source));
	},

	getAdventureBookSourceHref (source, page) {
		if (!source) return null;
		source = source.toLowerCase();

				let docPage, mappedSource;
		if (Parser.SOURCES_AVAILABLE_DOCS_BOOK[source]) {
			docPage = UrlUtil.PG_BOOK;
			mappedSource = Parser.SOURCES_AVAILABLE_DOCS_BOOK[source];
		} else if (Parser.SOURCES_AVAILABLE_DOCS_ADVENTURE[source]) {
			docPage = UrlUtil.PG_ADVENTURE;
			mappedSource = Parser.SOURCES_AVAILABLE_DOCS_ADVENTURE[source];
		}
		if (!docPage) return null;

		mappedSource = mappedSource.toLowerCase();

		return `${docPage}#${[mappedSource, page ? `page:${page}` : null].filter(Boolean).join(HASH_PART_SEP)}`;
	},

	getEntitySource (it) { return it.source || it.inherits?.source; },
};

globalThis.CurrencyUtil = {
		doSimplifyCoins (obj, opts) {
		opts = opts || {};

		const conversionTable = opts.currencyConversionTable || Parser.getCurrencyConversionTable(opts.currencyConversionId);
		if (!conversionTable.length) return obj;

		const normalized = conversionTable
			.map(it => {
				return {
					...it,
					normalizedMult: 1 / it.mult,
				};
			})
			.sort((a, b) => SortUtil.ascSort(a.normalizedMult, b.normalizedMult));

				for (let i = 0; i < normalized.length - 1; ++i) {
			const coinCur = normalized[i].coin;
			const coinNxt = normalized[i + 1].coin;
			const coinRatio = normalized[i + 1].normalizedMult / normalized[i].normalizedMult;

			if (obj[coinCur] && Math.abs(obj[coinCur]) >= coinRatio) {
				const nxtVal = obj[coinCur] >= 0 ? Math.floor(obj[coinCur] / coinRatio) : Math.ceil(obj[coinCur] / coinRatio);
				obj[coinCur] = obj[coinCur] % coinRatio;
				obj[coinNxt] = (obj[coinNxt] || 0) + nxtVal;
			}
		}

				if (opts.originalCurrency) {
			const normalizedHighToLow = MiscUtil.copyFast(normalized).reverse();

															normalizedHighToLow
				.forEach((coinMeta, i) => {
					const valOld = opts.originalCurrency[coinMeta.coin] || 0;
					const valNew = obj[coinMeta.coin] || 0;

					const prevCoinMeta = normalizedHighToLow[i - 1];
					const nxtCoinMeta = normalizedHighToLow[i + 1];

					if (!prevCoinMeta) { 						if (nxtCoinMeta) {
							const diff = valNew - valOld;
							if (diff > 0) {
								obj[coinMeta.coin] = valOld;
								const coinRatio = coinMeta.normalizedMult / nxtCoinMeta.normalizedMult;
								obj[nxtCoinMeta.coin] = (obj[nxtCoinMeta.coin] || 0) + (diff * coinRatio);
							}
						}
					} else {
						if (nxtCoinMeta) {
							const diffPrevCoin = (opts.originalCurrency[prevCoinMeta.coin] || 0) - (obj[prevCoinMeta.coin] || 0);
							const coinRatio = prevCoinMeta.normalizedMult / coinMeta.normalizedMult;
							const capFromOld = valOld + (diffPrevCoin > 0 ? diffPrevCoin * coinRatio : 0);
							const diff = valNew - capFromOld;
							if (diff > 0) {
								obj[coinMeta.coin] = capFromOld;
								const coinRatio = coinMeta.normalizedMult / nxtCoinMeta.normalizedMult;
								obj[nxtCoinMeta.coin] = (obj[nxtCoinMeta.coin] || 0) + (diff * coinRatio);
							}
						}
					}
				});
		}

		normalized
			.filter(coinMeta => obj[coinMeta.coin] === 0 || obj[coinMeta.coin] == null)
			.forEach(coinMeta => {
								obj[coinMeta.coin] = null;
				delete obj[coinMeta.coin];
			});

		if (opts.isPopulateAllValues) normalized.forEach(coinMeta => obj[coinMeta.coin] = obj[coinMeta.coin] || 0);

		return obj;
	},

		getAsCopper (obj) {
		return Parser.FULL_CURRENCY_CONVERSION_TABLE
			.map(currencyMeta => (obj[currencyMeta.coin] || 0) * (1 / currencyMeta.mult))
			.reduce((a, b) => a + b, 0);
	},

		getAsSingleCurrency (obj) {
		const simplified = CurrencyUtil.doSimplifyCoins({...obj});

		if (Object.keys(simplified).length === 1) return simplified;

		const out = {};

		const targetDemonination = Parser.FULL_CURRENCY_CONVERSION_TABLE.find(it => simplified[it.coin]);

		out[targetDemonination.coin] = simplified[targetDemonination.coin];
		delete simplified[targetDemonination.coin];

		Object.entries(simplified)
			.forEach(([coin, amt]) => {
				const denom = Parser.FULL_CURRENCY_CONVERSION_TABLE.find(it => it.coin === coin);
				out[targetDemonination.coin] = (out[targetDemonination.coin] || 0) + (amt / denom.mult) * targetDemonination.mult;
			});

		return out;
	},
};

Math.seed = Math.seed || function (s) {
	return function () {
		s = Math.sin(s) * 10000;
		return s - Math.floor(s);
	};
};

globalThis.JqueryUtil = {
	_isEnhancementsInit: false,
	initEnhancements () {
		if (JqueryUtil._isEnhancementsInit) return;
		JqueryUtil._isEnhancementsInit = true;

		JqueryUtil.addSelectors();

				window.$$ = function (parts, ...args) {
			if (parts instanceof jQuery || parts instanceof HTMLElement) {
				return (...passed) => {
					const parts2 = [...passed[0]];
					const args2 = passed.slice(1);
					parts2[0] = `<div>${parts2[0]}`;
					parts2.last(`${parts2.last()}</div>`);

					const $temp = $$(parts2, ...args2);
					$temp.children().each((i, e) => $(e).appendTo(parts));
					return parts;
				};
			} else {
				const $eles = [];
				let ixArg = 0;

				const handleArg = (arg) => {
					if (arg instanceof $) {
						$eles.push(arg);
						return `<${arg.tag()} data-r="true"></${arg.tag()}>`;
					} else if (arg instanceof HTMLElement) {
						return handleArg($(arg));
					} else return arg;
				};

				const raw = parts.reduce((html, p) => {
					const myIxArg = ixArg++;
					if (args[myIxArg] == null) return `${html}${p}`;
					if (args[myIxArg] instanceof Array) return `${html}${args[myIxArg].map(arg => handleArg(arg)).join("")}${p}`;
					else return `${html}${handleArg(args[myIxArg])}${p}`;
				});
				const $res = $(raw);

				if ($res.length === 1) {
					if ($res.attr("data-r") === "true") return $eles[0];
					else $res.find(`[data-r=true]`).replaceWith(i => $eles[i]);
				} else {
										const $tmp = $(`<div></div>`);
					$tmp.append($res);
					$tmp.find(`[data-r=true]`).replaceWith(i => $eles[i]);
					return $tmp.children();
				}

				return $res;
			}
		};

		$.fn.extend({
						disableSpellcheck: function () { return this.attr("autocomplete", "new-password").attr("autocapitalize", "off").attr("spellcheck", "false"); },
			tag: function () { return this.prop("tagName").toLowerCase(); },
			title: function (...args) { return this.attr("title", ...args); },
			placeholder: function (...args) { return this.attr("placeholder", ...args); },
			disable: function () { return this.attr("disabled", true); },

						fastSetHtml: function (html) {
				if (!this.length) return this;
				let tgt = this[0];
				while (tgt.children.length) {
					tgt = tgt.children[0];
				}
				tgt.innerHTML = html;
				return this;
			},

			blurOnEsc: function () {
				return this.keydown(evt => {
					if (evt.which === 27) this.blur(); 				});
			},

			hideVe: function () { return this.addClass("ve-hidden"); },
			showVe: function () { return this.removeClass("ve-hidden"); },
			toggleVe: function (val) {
				if (val === undefined) return this.toggleClass("ve-hidden", !this.hasClass("ve-hidden"));
				else return this.toggleClass("ve-hidden", !val);
			},
		});

		$.event.special.destroyed = {
			remove: function (o) {
				if (o.handler) o.handler();
			},
		};
	},

	addSelectors () {
						$.expr[":"].textEquals = (el, i, m) => $(el).text().toLowerCase().trim() === m[3].unescapeQuotes();

				$.expr[":"].containsInsensitive = (el, i, m) => {
			const searchText = m[3];
			const textNode = $(el).contents().filter((i, e) => e.nodeType === 3)[0];
			if (!textNode) return false;
			const match = textNode.nodeValue.toLowerCase().trim().match(`${searchText.toLowerCase().trim().escapeRegexp()}`);
			return match && match.length > 0;
		};
	},

	showCopiedEffect (eleOr$Ele, text = "Copied!", bubble) {
		const $ele = eleOr$Ele instanceof $ ? eleOr$Ele : $(eleOr$Ele);

		const top = $(window).scrollTop();
		const pos = $ele.offset();

		const animationOptions = {
			top: "-=8",
			opacity: 0,
		};
		if (bubble) {
			animationOptions.left = `${Math.random() > 0.5 ? "-" : "+"}=${~~(Math.random() * 17)}`;
		}
		const seed = Math.random();
		const duration = bubble ? 250 + seed * 200 : 250;
		const offsetY = bubble ? 16 : 0;

		const $dispCopied = $(`<div class="clp__disp-copied ve-flex-vh-center py-2 px-4"></div>`);
		$dispCopied
			.html(text)
			.css({
				top: (pos.top - 24) + offsetY - top,
				left: pos.left + ($ele.width() / 2),
			})
			.appendTo(document.body)
			.animate(
				animationOptions,
				{
					duration,
					complete: () => $dispCopied.remove(),
					progress: (_, progress) => { 						if (bubble) {
							const diffProgress = 0.5 - progress;
							animationOptions.top = `${diffProgress > 0 ? "-" : "+"}=40`;
							$dispCopied.css("transform", `rotate(${seed > 0.5 ? "-" : ""}${seed * 500 * progress}deg)`);
						}
					},
				},
			);
	},

	_dropdownInit: false,
	bindDropdownButton ($ele) {
		if (!JqueryUtil._dropdownInit) {
			JqueryUtil._dropdownInit = true;
			document.addEventListener("click", () => [...document.querySelectorAll(`.open`)].filter(ele => !(ele.className || "").split(" ").includes(`dropdown--navbar`)).forEach(ele => ele.classList.remove("open")));
		}
		$ele.click(() => setTimeout(() => $ele.parent().addClass("open"), 1)); 	},

	_WRP_TOAST: null,
	_ACTIVE_TOAST: [],
		doToast (options) {
		if (typeof window === "undefined") return;

		if (JqueryUtil._WRP_TOAST == null) {
			JqueryUtil._WRP_TOAST = e_({
				tag: "div",
				clazz: "toast__container no-events w-100 overflow-y-hidden ve-flex-col",
			});
			document.body.appendChild(JqueryUtil._WRP_TOAST);
		}

		if (typeof options === "string") {
			options = {
				content: options,
				type: "info",
			};
		}
		options.type = options.type || "info";

		options.isAutoHide = options.isAutoHide ?? true;
		options.autoHideTime = options.autoHideTime ?? 5000;

		const eleToast = e_({
			tag: "div",
			clazz: `toast toast--type-${options.type} events-initial relative my-2 mx-auto`,
			children: [
				e_({
					tag: "div",
					clazz: "toast__wrp-content",
					children: [
						options.content instanceof $ ? options.content[0] : options.content,
					],
				}),
				e_({
					tag: "div",
					clazz: "toast__wrp-control",
					children: [
						e_({
							tag: "button",
							clazz: "btn toast__btn-close",
							children: [
								e_({
									tag: "span",
									clazz: "glyphicon glyphicon-remove",
								}),
							],
						}),
					],
				}),
			],
			mousedown: evt => {
				evt.preventDefault();
			},
			click: evt => {
				evt.preventDefault();
				JqueryUtil._doToastCleanup(toastMeta);

								if (!evt.shiftKey) return;
				[...JqueryUtil._ACTIVE_TOAST].forEach(toastMeta => JqueryUtil._doToastCleanup(toastMeta));
			},
		});

										eleToast.prependTo(JqueryUtil._WRP_TOAST);

		const toastMeta = {isAutoHide: !!options.isAutoHide, eleToast};
		JqueryUtil._ACTIVE_TOAST.push(toastMeta);

		AnimationUtil.pRecomputeStyles()
			.then(() => {
				eleToast.addClass(`toast--animate`);

				if (options.isAutoHide) {
					setTimeout(() => {
						JqueryUtil._doToastCleanup(toastMeta);
					}, options.autoHideTime);
				}

				if (JqueryUtil._ACTIVE_TOAST.length >= 3) {
					JqueryUtil._ACTIVE_TOAST
						.filter(({isAutoHide}) => !isAutoHide)
						.forEach(toastMeta => {
							JqueryUtil._doToastCleanup(toastMeta);
						});
				}
			});
	},

	_doToastCleanup (toastMeta) {
		toastMeta.eleToast.removeClass("toast--animate");
		JqueryUtil._ACTIVE_TOAST.splice(JqueryUtil._ACTIVE_TOAST.indexOf(toastMeta), 1);
		setTimeout(() => toastMeta.eleToast.parentElement && toastMeta.eleToast.remove(), 85);
	},

	isMobile () {
		if (navigator?.userAgentData?.mobile) return true;
				return window.matchMedia("(max-width: 768px)").matches;
	},
};

if (typeof window !== "undefined") window.addEventListener("load", JqueryUtil.initEnhancements);

globalThis.ElementUtil = {
	_ATTRS_NO_FALSY: new Set([
		"checked",
		"disabled",
	]),

	getOrModify ({
		tag,
		clazz,
		style,
		click,
		contextmenu,
		change,
		mousedown,
		mouseup,
		mousemove,
		pointerdown,
		pointerup,
		keydown,
		html,
		text,
		txt,
		ele,
		children,
		outer,

		id,
		name,
		title,
		val,
		href,
		type,
		tabindex,
		value,
		attrs,
		data,
	}) {
		ele = ele || (outer ? (new DOMParser()).parseFromString(outer, "text/html").body.childNodes[0] : document.createElement(tag));

		if (clazz) ele.className = clazz;
		if (style) ele.setAttribute("style", style);
		if (click) ele.addEventListener("click", click);
		if (contextmenu) ele.addEventListener("contextmenu", contextmenu);
		if (change) ele.addEventListener("change", change);
		if (mousedown) ele.addEventListener("mousedown", mousedown);
		if (mouseup) ele.addEventListener("mouseup", mouseup);
		if (mousemove) ele.addEventListener("mousemove", mousemove);
		if (pointerdown) ele.addEventListener("pointerdown", pointerdown);
		if (pointerup) ele.addEventListener("pointerup", pointerup);
		if (keydown) ele.addEventListener("keydown", keydown);
		if (html != null) ele.innerHTML = html;
		if (text != null || txt != null) ele.textContent = text;
		if (id != null) ele.setAttribute("id", id);
		if (name != null) ele.setAttribute("name", name);
		if (title != null) ele.setAttribute("title", title);
		if (href != null) ele.setAttribute("href", href);
		if (val != null) ele.setAttribute("value", val);
		if (type != null) ele.setAttribute("type", type);
		if (tabindex != null) ele.setAttribute("tabindex", tabindex);
		if (value != null) ele.setAttribute("value", value);

		if (attrs != null) {
			for (const k in attrs) {
				if (attrs[k] === undefined) continue;
				if (!attrs[k] && ElementUtil._ATTRS_NO_FALSY.has(k)) continue;
				ele.setAttribute(k, attrs[k]);
			}
		}

		if (data != null) { for (const k in data) { if (data[k] === undefined) continue; ele.dataset[k] = data[k]; } }

		if (children) for (let i = 0, len = children.length; i < len; ++i) if (children[i] != null) ele.append(children[i]);

		ele.appends = ele.appends || ElementUtil._appends.bind(ele);
		ele.appendTo = ele.appendTo || ElementUtil._appendTo.bind(ele);
		ele.prependTo = ele.prependTo || ElementUtil._prependTo.bind(ele);
		ele.addClass = ele.addClass || ElementUtil._addClass.bind(ele);
		ele.removeClass = ele.removeClass || ElementUtil._removeClass.bind(ele);
		ele.toggleClass = ele.toggleClass || ElementUtil._toggleClass.bind(ele);
		ele.showVe = ele.showVe || ElementUtil._showVe.bind(ele);
		ele.hideVe = ele.hideVe || ElementUtil._hideVe.bind(ele);
		ele.toggleVe = ele.toggleVe || ElementUtil._toggleVe.bind(ele);
		ele.empty = ele.empty || ElementUtil._empty.bind(ele);
		ele.detach = ele.detach || ElementUtil._detach.bind(ele);
		ele.attr = ele.attr || ElementUtil._attr.bind(ele);
		ele.val = ele.val || ElementUtil._val.bind(ele);
		ele.html = ele.html || ElementUtil._html.bind(ele);
		ele.txt = ele.txt || ElementUtil._txt.bind(ele);
		ele.tooltip = ele.tooltip || ElementUtil._tooltip.bind(ele);
		ele.onClick = ele.onClick || ElementUtil._onClick.bind(ele);
		ele.onContextmenu = ele.onContextmenu || ElementUtil._onContextmenu.bind(ele);
		ele.onChange = ele.onChange || ElementUtil._onChange.bind(ele);

		return ele;
	},

	_appends (child) {
		this.appendChild(child);
		return this;
	},

	_appendTo (parent) {
		parent.appendChild(this);
		return this;
	},

	_prependTo (parent) {
		parent.prepend(this);
		return this;
	},

	_addClass (clazz) {
		this.classList.add(clazz);
		return this;
	},

	_removeClass (clazz) {
		this.classList.remove(clazz);
		return this;
	},

	_toggleClass (clazz, isActive) {
		if (isActive == null) this.classList.toggle(clazz);
		else if (isActive) this.classList.add(clazz);
		else this.classList.remove(clazz);
		return this;
	},

	_showVe () {
		this.classList.remove("ve-hidden");
		return this;
	},

	_hideVe () {
		this.classList.add("ve-hidden");
		return this;
	},

	_toggleVe (isActive) {
		this.toggleClass("ve-hidden", isActive == null ? isActive : !isActive);
		return this;
	},

	_empty () {
		this.innerHTML = "";
		return this;
	},

	_detach () {
		if (this.parentElement) this.parentElement.removeChild(this);
		return this;
	},

	_attr (name, value) {
		this.setAttribute(name, value);
		return this;
	},

	_html (html) {
		if (html === undefined) return this.innerHTML;
		this.innerHTML = html;
		return this;
	},

	_txt (txt) {
		if (txt === undefined) return this.innerText;
		this.innerText = txt;
		return this;
	},

	_tooltip (title) {
		return this.attr("title", title);
	},

	_onClick (fn) { return ElementUtil._onX(this, "click", fn); },
	_onContextmenu (fn) { return ElementUtil._onX(this, "contextmenu", fn); },
	_onChange (fn) { return ElementUtil._onX(this, "change", fn); },

	_onX (ele, evtName, fn) { ele.addEventListener(evtName, fn); return ele; },

	_val (val) {
		if (val !== undefined) {
			switch (this.tagName) {
				case "SELECT": {
					let selectedIndexNxt = -1;
					for (let i = 0, len = this.options.length; i < len; ++i) {
						if (this.options[i]?.value === val) { selectedIndexNxt = i; break; }
					}
					this.selectedIndex = selectedIndexNxt;
					return this;
				}

				default: {
					this.value = val;
					return this;
				}
			}
		}

		switch (this.tagName) {
			case "SELECT": return this.options[this.selectedIndex]?.value;

			default: return this.value;
		}
	},

		getIndexPathToParent (parent, child) {
		if (!parent.contains(child)) return null;

		const path = [];

		while (child !== parent) {
			if (!child.parentElement) return null;

			const ix = [...child.parentElement.children].indexOf(child);
			if (!~ix) return null;

			path.push(ix);

			child = child.parentElement;
		}

		return path.reverse();
	},

	getChildByIndexPath (parent, indexPath) {
		for (let i = 0; i < indexPath.length; ++i) {
			const ix = indexPath[i];
			parent = parent.children[ix];
			if (!parent) return null;
		}
		return parent;
	},
	};

if (typeof window !== "undefined") window.e_ = ElementUtil.getOrModify;

globalThis.ObjUtil = {
	async pForEachDeep (source, pCallback, options = {depth: Infinity, callEachLevel: false}) {
		const path = [];
		const pDiveDeep = async function (val, path, depth = 0) {
			if (options.callEachLevel || typeof val !== "object" || options.depth === depth) {
				await pCallback(val, path, depth);
			}
			if (options.depth !== depth && typeof val === "object") {
				for (const key of Object.keys(val)) {
					path.push(key);
					await pDiveDeep(val[key], path, depth + 1);
				}
			}
			path.pop();
		};
		await pDiveDeep(source, path);
	},
};

globalThis.MiscUtil = {
	COLOR_HEALTHY: "#00bb20",
	COLOR_HURT: "#c5ca00",
	COLOR_BLOODIED: "#f7a100",
	COLOR_DEFEATED: "#cc0000",

		copy (obj, {isSafe = false, isPreserveUndefinedValueKeys = false} = {}) {
		if (isSafe && obj === undefined) return undefined; 		return JSON.parse(JSON.stringify(obj));
	},

	copyFast (obj) {
		if ((typeof obj !== "object") || obj == null) return obj;

		if (obj instanceof Array) return obj.map(MiscUtil.copyFast);

		const cpy = {};
		for (const k of Object.keys(obj)) cpy[k] = MiscUtil.copyFast(obj[k]);
		return cpy;
	},

	async pCopyTextToClipboard (text) {
		function doCompatibilityCopy () {
			const $iptTemp = $(`<textarea class="clp__wrp-temp"></textarea>`)
				.appendTo(document.body)
				.val(text)
				.select();
			document.execCommand("Copy");
			$iptTemp.remove();
		}

		if (navigator && navigator.permissions) {
			try {
				const access = await navigator.permissions.query({name: "clipboard-write"});
				if (access.state === "granted" || access.state === "prompt") {
					await navigator.clipboard.writeText(text);
				} else doCompatibilityCopy();
			} catch (e) { doCompatibilityCopy(); }
		} else doCompatibilityCopy();
	},

	checkProperty (object, ...path) {
		for (let i = 0; i < path.length; ++i) {
			object = object[path[i]];
			if (object == null) return false;
		}
		return true;
	},

	get (object, ...path) {
		if (object == null) return null;
		for (let i = 0; i < path.length; ++i) {
			object = object[path[i]];
			if (object == null) return object;
		}
		return object;
	},

	set (object, ...pathAndVal) {
		if (object == null) return null;

		const val = pathAndVal.pop();
		if (!pathAndVal.length) return null;

		const len = pathAndVal.length;
		for (let i = 0; i < len; ++i) {
			const pathPart = pathAndVal[i];
			if (i === len - 1) object[pathPart] = val;
			else object = (object[pathPart] = object[pathPart] || {});
		}

		return val;
	},

	getOrSet (object, ...pathAndVal) {
		if (pathAndVal.length < 2) return null;
		const existing = MiscUtil.get(object, ...pathAndVal.slice(0, -1));
		return existing || MiscUtil.set(object, ...pathAndVal);
	},

	getThenSetCopy (object1, object2, ...path) {
		const val = MiscUtil.get(object1, ...path);
		return MiscUtil.set(object2, ...path, MiscUtil.copyFast(val, {isSafe: true}));
	},

	delete (object, ...path) {
		if (object == null) return object;
		for (let i = 0; i < path.length - 1; ++i) {
			object = object[path[i]];
			if (object == null) return object;
		}
		return delete object[path.last()];
	},

		deleteObjectPath (object, ...path) {
		const stack = [object];

		if (object == null) return object;
		for (let i = 0; i < path.length - 1; ++i) {
			object = object[path[i]];
			stack.push(object);
			if (object === undefined) return object;
		}
		const out = delete object[path.last()];

		for (let i = path.length - 1; i > 0; --i) {
			if (!Object.keys(stack[i]).length) delete stack[i - 1][path[i - 1]];
		}

		return out;
	},

	merge (obj1, obj2) {
		obj2 = MiscUtil.copyFast(obj2);

		Object.entries(obj2)
			.forEach(([k, v]) => {
				if (obj1[k] == null) {
					obj1[k] = v;
					return;
				}

				if (
					typeof obj1[k] === "object"
					&& typeof v === "object"
					&& !(obj1[k] instanceof Array)
					&& !(v instanceof Array)
				) {
					MiscUtil.merge(obj1[k], v);
					return;
				}

				obj1[k] = v;
			});

		return obj1;
	},

		mix: (superclass) => new MiscUtil._MixinBuilder(superclass),
	_MixinBuilder: function (superclass) {
		this.superclass = superclass;

		this.with = function (...mixins) {
			return mixins.reduce((c, mixin) => mixin(c), this.superclass);
		};
	},

	clearSelection () {
		if (document.getSelection) {
			document.getSelection().removeAllRanges();
			document.getSelection().addRange(document.createRange());
		} else if (window.getSelection) {
			if (window.getSelection().removeAllRanges) {
				window.getSelection().removeAllRanges();
				window.getSelection().addRange(document.createRange());
			} else if (window.getSelection().empty) {
				window.getSelection().empty();
			}
		} else if (document.selection) {
			document.selection.empty();
		}
	},

	randomColor () {
		let r; let g; let b;
		const h = RollerUtil.randomise(30, 0) / 30;
		const i = ~~(h * 6);
		const f = h * 6 - i;
		const q = 1 - f;
		switch (i % 6) {
			case 0: r = 1; g = f; b = 0; break;
			case 1: r = q; g = 1; b = 0; break;
			case 2: r = 0; g = 1; b = f; break;
			case 3: r = 0; g = q; b = 1; break;
			case 4: r = f; g = 0; b = 1; break;
			case 5: r = 1; g = 0; b = q; break;
		}
		return `#${`00${(~~(r * 255)).toString(16)}`.slice(-2)}${`00${(~~(g * 255)).toString(16)}`.slice(-2)}${`00${(~~(b * 255)).toString(16)}`.slice(-2)}`;
	},

		invertColor (hex, opts) {
		opts = opts || {};

		hex = hex.slice(1); 
		let r = parseInt(hex.slice(0, 2), 16);
		let g = parseInt(hex.slice(2, 4), 16);
		let b = parseInt(hex.slice(4, 6), 16);

				const isDark = (r * 0.299 + g * 0.587 + b * 0.114) > 186;
		if (opts.dark && opts.light) return isDark ? opts.dark : opts.light;
		else if (opts.bw) return isDark ? "#000000" : "#FFFFFF";

		r = (255 - r).toString(16); g = (255 - g).toString(16); b = (255 - b).toString(16);
		return `#${[r, g, b].map(it => it.padStart(2, "0")).join("")}`;
	},

	scrollPageTop () {
		document.body.scrollTop = document.documentElement.scrollTop = 0;
	},

	expEval (str) {
				return new Function(`return ${str.replace(/[^-()\d/*+.]/g, "")}`)();
	},

	parseNumberRange (input, min = Number.MIN_SAFE_INTEGER, max = Number.MAX_SAFE_INTEGER) {
		if (!input || !input.trim()) return null;

		const errInvalid = input => { throw new Error(`Could not parse range input "${input}"`); };

		const errOutOfRange = () => { throw new Error(`Number was out of range! Range was ${min}-${max} (inclusive).`); };

		const isOutOfRange = (num) => num < min || num > max;

		const addToRangeVal = (range, num) => range.add(num);

		const addToRangeLoHi = (range, lo, hi) => {
			for (let i = lo; i <= hi; ++i) range.add(i);
		};

		const clean = input.replace(/\s*/g, "");
		if (!/^((\d+-\d+|\d+),)*(\d+-\d+|\d+)$/.exec(clean)) errInvalid();

		const parts = clean.split(",");
		const out = new Set();

		for (const part of parts) {
			if (part.includes("-")) {
				const spl = part.split("-");
				const numLo = Number(spl[0]);
				const numHi = Number(spl[1]);

				if (isNaN(numLo) || isNaN(numHi) || numLo === 0 || numHi === 0 || numLo > numHi) errInvalid();

				if (isOutOfRange(numLo) || isOutOfRange(numHi)) errOutOfRange();

				if (numLo === numHi) addToRangeVal(out, numLo);
				else addToRangeLoHi(out, numLo, numHi);
				continue;
			}

			const num = Number(part);
			if (isNaN(num) || num === 0) errInvalid();

			if (isOutOfRange(num)) errOutOfRange();
			addToRangeVal(out, num);
		}

		return out;
	},

	findCommonPrefix (strArr, {isRespectWordBoundaries} = {}) {
		if (isRespectWordBoundaries) {
			return MiscUtil._findCommonPrefixSuffixWords({strArr});
		}

		let prefix = null;
		strArr.forEach(s => {
			if (prefix == null) {
				prefix = s;
				return;
			}

			const minLen = Math.min(s.length, prefix.length);
			for (let i = 0; i < minLen; ++i) {
				const cp = prefix[i];
				const cs = s[i];
				if (cp !== cs) {
					prefix = prefix.substring(0, i);
					break;
				}
			}
		});
		return prefix;
	},

	findCommonSuffix (strArr, {isRespectWordBoundaries} = {}) {
		if (!isRespectWordBoundaries) throw new Error(`Unimplemented!`);

		return MiscUtil._findCommonPrefixSuffixWords({strArr, isSuffix: true});
	},

	_findCommonPrefixSuffixWords ({strArr, isSuffix}) {
		let prefixTks = null;

		strArr
			.map(str => str.split(" "))
			.forEach(tks => {
				if (isSuffix) tks.reverse();

				if (prefixTks == null) return prefixTks = [...tks];

				const minLen = Math.min(tks.length, prefixTks.length);
				while (prefixTks.length > minLen) prefixTks.pop();

				for (let i = 0; i < minLen; ++i) {
					const cp = prefixTks[i];
					const cs = tks[i];
					if (cp !== cs) {
						prefixTks = prefixTks.slice(0, i);
						break;
					}
				}
			});

		if (isSuffix) prefixTks.reverse();

		if (!prefixTks.length) return "";

		return isSuffix
			? ` ${prefixTks.join(" ")}`
			: `${prefixTks.join(" ")} `;
	},

		calculateBlendedColor (fgHexTarget, fgOpacity, bgHex) {
		const fgDcTarget = CryptUtil.hex2Dec(fgHexTarget);
		const bgDc = CryptUtil.hex2Dec(bgHex);
		return ((fgDcTarget - ((1 - fgOpacity) * bgDc)) / fgOpacity).toString(16);
	},

		debounce (func, wait, options) {
		let lastArgs; let lastThis; let maxWait; let result; let timerId; let lastCallTime; let lastInvokeTime = 0; let leading = false; let maxing = false; let trailing = true;

		wait = Number(wait) || 0;
		if (typeof options === "object") {
			leading = !!options.leading;
			maxing = "maxWait" in options;
			maxWait = maxing ? Math.max(Number(options.maxWait) || 0, wait) : maxWait;
			trailing = "trailing" in options ? !!options.trailing : trailing;
		}

		function invokeFunc (time) {
			let args = lastArgs; let thisArg = lastThis;

			lastArgs = lastThis = undefined;
			lastInvokeTime = time;
			result = func.apply(thisArg, args);
			return result;
		}

		function leadingEdge (time) {
			lastInvokeTime = time;
			timerId = setTimeout(timerExpired, wait);
			return leading ? invokeFunc(time) : result;
		}

		function remainingWait (time) {
			let timeSinceLastCall = time - lastCallTime; let timeSinceLastInvoke = time - lastInvokeTime; let result = wait - timeSinceLastCall;
			return maxing ? Math.min(result, maxWait - timeSinceLastInvoke) : result;
		}

		function shouldInvoke (time) {
			let timeSinceLastCall = time - lastCallTime; let timeSinceLastInvoke = time - lastInvokeTime;

			return (lastCallTime === undefined || (timeSinceLastCall >= wait) || (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
		}

		function timerExpired () {
			const time = Date.now();
			if (shouldInvoke(time)) {
				return trailingEdge(time);
			}
						timerId = setTimeout(timerExpired, remainingWait(time));
		}

		function trailingEdge (time) {
			timerId = undefined;

			if (trailing && lastArgs) return invokeFunc(time);
			lastArgs = lastThis = undefined;
			return result;
		}

		function cancel () {
			if (timerId !== undefined) clearTimeout(timerId);
			lastInvokeTime = 0;
			lastArgs = lastCallTime = lastThis = timerId = undefined;
		}

		function flush () {
			return timerId === undefined ? result : trailingEdge(Date.now());
		}

		function debounced () {
			let time = Date.now(); let isInvoking = shouldInvoke(time);
			lastArgs = arguments;
			lastThis = this;
			lastCallTime = time;

			if (isInvoking) {
				if (timerId === undefined) return leadingEdge(lastCallTime);
				if (maxing) {
										timerId = setTimeout(timerExpired, wait);
					return invokeFunc(lastCallTime);
				}
			}
			if (timerId === undefined) timerId = setTimeout(timerExpired, wait);
			return result;
		}

		debounced.cancel = cancel;
		debounced.flush = flush;
		return debounced;
	},

		throttle (func, wait, options) {
		let leading = true; let trailing = true;

		if (typeof options === "object") {
			leading = "leading" in options ? !!options.leading : leading;
			trailing = "trailing" in options ? !!options.trailing : trailing;
		}

		return this.debounce(func, wait, {leading, maxWait: wait, trailing});
	},

	pDelay (msecs, resolveAs) {
		return new Promise(resolve => setTimeout(() => resolve(resolveAs), msecs));
	},

	GENERIC_WALKER_ENTRIES_KEY_BLOCKLIST: new Set(["caption", "type", "colLabels", "colLabelGroups", "name", "colStyles", "style", "shortName", "subclassShortName", "id", "path"]),

		getWalker (opts) {
		opts = opts || {};

		if (opts.isBreakOnReturn && !opts.isNoModification) throw new Error(`"isBreakOnReturn" may only be used in "isNoModification" mode!`);

		const keyBlocklist = opts.keyBlocklist || new Set();

		const getMappedPrimitive = (obj, primitiveHandlers, lastKey, stack, prop, propPre, propPost) => {
			if (primitiveHandlers[propPre]) MiscUtil._getWalker_runHandlers({handlers: primitiveHandlers[propPre], obj, lastKey, stack});
			if (primitiveHandlers[prop]) {
				const out = MiscUtil._getWalker_applyHandlers({opts, handlers: primitiveHandlers[prop], obj, lastKey, stack});
				if (out === VeCt.SYM_WALKER_BREAK) return out;
				if (!opts.isNoModification) obj = out;
			}
			if (primitiveHandlers[propPost]) MiscUtil._getWalker_runHandlers({handlers: primitiveHandlers[propPost], obj, lastKey, stack});
			return obj;
		};

		const doObjectRecurse = (obj, primitiveHandlers, stack) => {
			for (const k of Object.keys(obj)) {
				if (keyBlocklist.has(k)) continue;

				const out = fn(obj[k], primitiveHandlers, k, stack);
				if (out === VeCt.SYM_WALKER_BREAK) return VeCt.SYM_WALKER_BREAK;
				if (!opts.isNoModification) obj[k] = out;
			}
		};

		const fn = (obj, primitiveHandlers, lastKey, stack) => {
			if (obj === null) return getMappedPrimitive(obj, primitiveHandlers, lastKey, stack, "null", "preNull", "postNull");

			switch (typeof obj) {
				case "undefined": return getMappedPrimitive(obj, primitiveHandlers, lastKey, stack, "undefined", "preUndefined", "postUndefined");
				case "boolean": return getMappedPrimitive(obj, primitiveHandlers, lastKey, stack, "boolean", "preBoolean", "postBoolean");
				case "number": return getMappedPrimitive(obj, primitiveHandlers, lastKey, stack, "number", "preNumber", "postNumber");
				case "string": return getMappedPrimitive(obj, primitiveHandlers, lastKey, stack, "string", "preString", "postString");
				case "object": {
										if (obj instanceof Array) {
						if (primitiveHandlers.preArray) MiscUtil._getWalker_runHandlers({handlers: primitiveHandlers.preArray, obj, lastKey, stack});
						if (opts.isDepthFirst) {
							if (stack) stack.push(obj);
							const out = new Array(obj.length);
							for (let i = 0, len = out.length; i < len; ++i) {
								out[i] = fn(obj[i], primitiveHandlers, lastKey, stack);
								if (out[i] === VeCt.SYM_WALKER_BREAK) return out[i];
							}
							if (!opts.isNoModification) obj = out;
							if (stack) stack.pop();

							if (primitiveHandlers.array) {
								const out = MiscUtil._getWalker_applyHandlers({opts, handlers: primitiveHandlers.array, obj, lastKey, stack});
								if (out === VeCt.SYM_WALKER_BREAK) return out;
								if (!opts.isNoModification) obj = out;
							}
							if (obj == null) {
								if (!opts.isAllowDeleteArrays) throw new Error(`Array handler(s) returned null!`);
							}
						} else {
							if (primitiveHandlers.array) {
								const out = MiscUtil._getWalker_applyHandlers({opts, handlers: primitiveHandlers.array, obj, lastKey, stack});
								if (out === VeCt.SYM_WALKER_BREAK) return out;
								if (!opts.isNoModification) obj = out;
							}
							if (obj != null) {
								const out = new Array(obj.length);
								for (let i = 0, len = out.length; i < len; ++i) {
									if (stack) stack.push(obj);
									out[i] = fn(obj[i], primitiveHandlers, lastKey, stack);
									if (stack) stack.pop();
									if (out[i] === VeCt.SYM_WALKER_BREAK) return out[i];
								}
								if (!opts.isNoModification) obj = out;
							} else {
								if (!opts.isAllowDeleteArrays) throw new Error(`Array handler(s) returned null!`);
							}
						}
						if (primitiveHandlers.postArray) MiscUtil._getWalker_runHandlers({handlers: primitiveHandlers.postArray, obj, lastKey, stack});
						return obj;
					}
					
										if (primitiveHandlers.preObject) MiscUtil._getWalker_runHandlers({handlers: primitiveHandlers.preObject, obj, lastKey, stack});
					if (opts.isDepthFirst) {
						if (stack) stack.push(obj);
						const flag = doObjectRecurse(obj, primitiveHandlers, stack);
						if (stack) stack.pop();
						if (flag === VeCt.SYM_WALKER_BREAK) return flag;

						if (primitiveHandlers.object) {
							const out = MiscUtil._getWalker_applyHandlers({opts, handlers: primitiveHandlers.object, obj, lastKey, stack});
							if (out === VeCt.SYM_WALKER_BREAK) return out;
							if (!opts.isNoModification) obj = out;
						}
						if (obj == null) {
							if (!opts.isAllowDeleteObjects) throw new Error(`Object handler(s) returned null!`);
						}
					} else {
						if (primitiveHandlers.object) {
							const out = MiscUtil._getWalker_applyHandlers({opts, handlers: primitiveHandlers.object, obj, lastKey, stack});
							if (out === VeCt.SYM_WALKER_BREAK) return out;
							if (!opts.isNoModification) obj = out;
						}
						if (obj == null) {
							if (!opts.isAllowDeleteObjects) throw new Error(`Object handler(s) returned null!`);
						} else {
							if (stack) stack.push(obj);
							const flag = doObjectRecurse(obj, primitiveHandlers, stack);
							if (stack) stack.pop();
							if (flag === VeCt.SYM_WALKER_BREAK) return flag;
						}
					}
					if (primitiveHandlers.postObject) MiscUtil._getWalker_runHandlers({handlers: primitiveHandlers.postObject, obj, lastKey, stack});
					return obj;
									}
				default: throw new Error(`Unhandled type "${typeof obj}"`);
			}
		};

		return {walk: fn};
	},

	_getWalker_applyHandlers ({opts, handlers, obj, lastKey, stack}) {
		handlers = handlers instanceof Array ? handlers : [handlers];
		const didBreak = handlers.some(h => {
			const out = h(obj, lastKey, stack);
			if (opts.isBreakOnReturn && out) return true;
			if (!opts.isNoModification) obj = out;
		});
		if (didBreak) return VeCt.SYM_WALKER_BREAK;
		return obj;
	},

	_getWalker_runHandlers ({handlers, obj, lastKey, stack}) {
		handlers = handlers instanceof Array ? handlers : [handlers];
		handlers.forEach(h => h(obj, lastKey, stack));
	},

		getAsyncWalker (opts) {
		opts = opts || {};
		const keyBlocklist = opts.keyBlocklist || new Set();

		const pFn = async (obj, primitiveHandlers, lastKey, stack) => {
			if (obj == null) {
				if (primitiveHandlers.null) return MiscUtil._getAsyncWalker_pApplyHandlers({opts, handlers: primitiveHandlers.null, obj, lastKey, stack});
				return obj;
			}

			const pDoObjectRecurse = async () => {
				await Object.keys(obj).pSerialAwaitMap(async k => {
					const v = obj[k];
					if (keyBlocklist.has(k)) return;
					const out = await pFn(v, primitiveHandlers, k, stack);
					if (!opts.isNoModification) obj[k] = out;
				});
			};

			const to = typeof obj;
			switch (to) {
				case undefined:
					if (primitiveHandlers.preUndefined) await MiscUtil._getAsyncWalker_pRunHandlers({handlers: primitiveHandlers.preUndefined, obj, lastKey, stack});
					if (primitiveHandlers.undefined) {
						const out = await MiscUtil._getAsyncWalker_pApplyHandlers({opts, handlers: primitiveHandlers.undefined, obj, lastKey, stack});
						if (!opts.isNoModification) obj = out;
					}
					if (primitiveHandlers.postUndefined) await MiscUtil._getAsyncWalker_pRunHandlers({handlers: primitiveHandlers.postUndefined, obj, lastKey, stack});
					return obj;
				case "boolean":
					if (primitiveHandlers.preBoolean) await MiscUtil._getAsyncWalker_pRunHandlers({handlers: primitiveHandlers.preBoolean, obj, lastKey, stack});
					if (primitiveHandlers.boolean) {
						const out = await MiscUtil._getAsyncWalker_pApplyHandlers({opts, handlers: primitiveHandlers.boolean, obj, lastKey, stack});
						if (!opts.isNoModification) obj = out;
					}
					if (primitiveHandlers.postBoolean) await MiscUtil._getAsyncWalker_pRunHandlers({handlers: primitiveHandlers.postBoolean, obj, lastKey, stack});
					return obj;
				case "number":
					if (primitiveHandlers.preNumber) await MiscUtil._getAsyncWalker_pRunHandlers({handlers: primitiveHandlers.preNumber, obj, lastKey, stack});
					if (primitiveHandlers.number) {
						const out = await MiscUtil._getAsyncWalker_pApplyHandlers({opts, handlers: primitiveHandlers.number, obj, lastKey, stack});
						if (!opts.isNoModification) obj = out;
					}
					if (primitiveHandlers.postNumber) await MiscUtil._getAsyncWalker_pRunHandlers({handlers: primitiveHandlers.postNumber, obj, lastKey, stack});
					return obj;
				case "string":
					if (primitiveHandlers.preString) await MiscUtil._getAsyncWalker_pRunHandlers({handlers: primitiveHandlers.preString, obj, lastKey, stack});
					if (primitiveHandlers.string) {
						const out = await MiscUtil._getAsyncWalker_pApplyHandlers({opts, handlers: primitiveHandlers.string, obj, lastKey, stack});
						if (!opts.isNoModification) obj = out;
					}
					if (primitiveHandlers.postString) await MiscUtil._getAsyncWalker_pRunHandlers({handlers: primitiveHandlers.postString, obj, lastKey, stack});
					return obj;
				case "object": {
					if (obj instanceof Array) {
						if (primitiveHandlers.preArray) await MiscUtil._getAsyncWalker_pRunHandlers({handlers: primitiveHandlers.preArray, obj, lastKey, stack});
						if (opts.isDepthFirst) {
							if (stack) stack.push(obj);
							const out = await obj.pSerialAwaitMap(it => pFn(it, primitiveHandlers, lastKey, stack));
							if (!opts.isNoModification) obj = out;
							if (stack) stack.pop();

							if (primitiveHandlers.array) {
								const out = await MiscUtil._getAsyncWalker_pApplyHandlers({opts, handlers: primitiveHandlers.array, obj, lastKey, stack});
								if (!opts.isNoModification) obj = out;
							}
							if (obj == null) {
								if (!opts.isAllowDeleteArrays) throw new Error(`Array handler(s) returned null!`);
							}
						} else {
							if (primitiveHandlers.array) {
								const out = await MiscUtil._getAsyncWalker_pApplyHandlers({opts, handlers: primitiveHandlers.array, obj, lastKey, stack});
								if (!opts.isNoModification) obj = out;
							}
							if (obj != null) {
								const out = await obj.pSerialAwaitMap(it => pFn(it, primitiveHandlers, lastKey, stack));
								if (!opts.isNoModification) obj = out;
							} else {
								if (!opts.isAllowDeleteArrays) throw new Error(`Array handler(s) returned null!`);
							}
						}
						if (primitiveHandlers.postArray) await MiscUtil._getAsyncWalker_pRunHandlers({handlers: primitiveHandlers.postArray, obj, lastKey, stack});
						return obj;
					} else {
						if (primitiveHandlers.preObject) await MiscUtil._getAsyncWalker_pRunHandlers({handlers: primitiveHandlers.preObject, obj, lastKey, stack});
						if (opts.isDepthFirst) {
							if (stack) stack.push(obj);
							await pDoObjectRecurse();
							if (stack) stack.pop();

							if (primitiveHandlers.object) {
								const out = await MiscUtil._getAsyncWalker_pApplyHandlers({opts, handlers: primitiveHandlers.object, obj, lastKey, stack});
								if (!opts.isNoModification) obj = out;
							}
							if (obj == null) {
								if (!opts.isAllowDeleteObjects) throw new Error(`Object handler(s) returned null!`);
							}
						} else {
							if (primitiveHandlers.object) {
								const out = await MiscUtil._getAsyncWalker_pApplyHandlers({opts, handlers: primitiveHandlers.object, obj, lastKey, stack});
								if (!opts.isNoModification) obj = out;
							}
							if (obj == null) {
								if (!opts.isAllowDeleteObjects) throw new Error(`Object handler(s) returned null!`);
							} else {
								await pDoObjectRecurse();
							}
						}
						if (primitiveHandlers.postObject) await MiscUtil._getAsyncWalker_pRunHandlers({handlers: primitiveHandlers.postObject, obj, lastKey, stack});
						return obj;
					}
				}
				default: throw new Error(`Unhandled type "${to}"`);
			}
		};

		return {pWalk: pFn};
	},

	async _getAsyncWalker_pApplyHandlers ({opts, handlers, obj, lastKey, stack}) {
		handlers = handlers instanceof Array ? handlers : [handlers];
		await handlers.pSerialAwaitMap(async pH => {
			const out = await pH(obj, lastKey, stack);
			if (!opts.isNoModification) obj = out;
		});
		return obj;
	},

	async _getAsyncWalker_pRunHandlers ({handlers, obj, lastKey, stack}) {
		handlers = handlers instanceof Array ? handlers : [handlers];
		await handlers.pSerialAwaitMap(pH => pH(obj, lastKey, stack));
	},

	pDefer (fn) {
		return (async () => fn())();
	},
};

globalThis.EventUtil = {
	_mouseX: 0,
	_mouseY: 0,
	_isUsingTouch: false,
	_isSetCssVars: false,

	init () {
		document.addEventListener("mousemove", evt => {
			EventUtil._mouseX = evt.clientX;
			EventUtil._mouseY = evt.clientY;
			EventUtil._onMouseMove_setCssVars();
		});
		document.addEventListener("touchstart", () => {
			EventUtil._isUsingTouch = true;
		});
	},

	_eleDocRoot: null,
	_onMouseMove_setCssVars () {
		if (!EventUtil._isSetCssVars) return;

		EventUtil._eleDocRoot = EventUtil._eleDocRoot || document.querySelector(":root");

		EventUtil._eleDocRoot.style.setProperty("--mouse-position-x", EventUtil._mouseX);
		EventUtil._eleDocRoot.style.setProperty("--mouse-position-y", EventUtil._mouseY);
	},

	getClientX (evt) { return evt.touches && evt.touches.length ? evt.touches[0].clientX : evt.clientX; },
	getClientY (evt) { return evt.touches && evt.touches.length ? evt.touches[0].clientY : evt.clientY; },

	getOffsetY (evt) {
		if (!evt.touches?.length) return evt.offsetY;

		const bounds = evt.target.getBoundingClientRect();
		return evt.targetTouches[0].clientY - bounds.y;
	},

	getMousePos () {
		return {x: EventUtil._mouseX, y: EventUtil._mouseY};
	},

	isUsingTouch () { return !!EventUtil._isUsingTouch; },

	isInInput (evt) {
		return evt.target.nodeName === "INPUT" || evt.target.nodeName === "TEXTAREA"
			|| evt.target.getAttribute("contenteditable") === "true";
	},

	noModifierKeys (evt) { return !evt.ctrlKey && !evt.altKey && !evt.metaKey; },

	getKeyIgnoreCapsLock (evt) {
		if (!evt.key) return null;
		if (evt.key.length !== 1) return evt.key;
		const isCaps = (evt.originalEvent || evt).getModifierState("CapsLock");
		if (!isCaps) return evt.key;
		const asciiCode = evt.key.charCodeAt(0);
		const isUpperCase = asciiCode >= 65 && asciiCode <= 90;
		const isLowerCase = asciiCode >= 97 && asciiCode <= 122;
		if (!isUpperCase && !isLowerCase) return evt.key;
		return isUpperCase ? evt.key.toLowerCase() : evt.key.toUpperCase();
	},
};

if (typeof window !== "undefined") window.addEventListener("load", EventUtil.init);

globalThis.AnimationUtil = class {
		static async pRecomputeStyles () {
		return new Promise(resolve => {
			requestAnimationFrame(() => {
				requestAnimationFrame(() => {
					resolve();
				});
			});
		});
	}

	static pLoadImage (uri) {
		return new Promise((resolve, reject) => {
			const img = new Image();
			img.onerror = err => reject(err);
			img.onload = () => resolve(img);
			img.src = uri;
		});
	}
};

globalThis.ContextUtil = {
	_isInit: false,
	_menus: [],

	_init () {
		if (ContextUtil._isInit) return;
		ContextUtil._isInit = true;

		$(document.body).on("click", () => ContextUtil._menus.forEach(menu => menu.close()));
	},

	getMenu (actions) {
		ContextUtil._init();

		const menu = new ContextUtil.Menu(actions);
		ContextUtil._menus.push(menu);
		return menu;
	},

	deleteMenu (menu) {
		if (!menu) return;

		menu.remove();
		const ix = ContextUtil._menus.findIndex(it => it === menu);
		if (~ix) ContextUtil._menus.splice(ix, 1);
	},

	pOpenMenu (evt, menu, userData) {
		evt.preventDefault();
		evt.stopPropagation();

		ContextUtil._init();

				ContextUtil._menus.filter(it => it !== menu).forEach(it => it.close());

		return menu.pOpen(evt, userData);
	},

	Menu: function (actions) {
		this._actions = actions;
		this._pResult = null;
		this.resolveResult_ = null;

		this.userData = null;

		this._$ele = null;
		this._metasActions = [];

		this.remove = function () { if (this._$ele) this._$ele.remove(); };

		this.width = function () { return this._$ele ? this._$ele.width() : undefined; };
		this.height = function () { return this._$ele ? this._$ele.height() : undefined; };

		this.pOpen = function (evt, userData) {
			evt.stopPropagation();
			evt.preventDefault();

			this._initLazy();

			if (this.resolveResult_) this.resolveResult_(null);
			this._pResult = new Promise(resolve => {
				this.resolveResult_ = resolve;
			});
			this.userData = userData;

			this._$ele
								.css({
					left: 0,
					top: 0,
					opacity: 0,
					pointerEvents: "none",
				})
				.showVe()
								.css({
					left: this._getMenuPosition(evt, "x"),
					top: this._getMenuPosition(evt, "y"),
					opacity: "",
					pointerEvents: "",
				});

			this._metasActions[0].$eleRow.focus();

			return this._pResult;
		};
		this.close = function () { if (this._$ele) this._$ele.hideVe(); };

		this._initLazy = function () {
			if (this._$ele) {
				this._metasActions.forEach(meta => meta.action.update());
				return;
			}

			const $elesAction = this._actions.map(it => {
				if (it == null) return $(`<div class="my-1 w-100 ui-ctx__divider"></div>`);

				const rdMeta = it.render({menu: this});
				this._metasActions.push(rdMeta);
				return rdMeta.$eleRow;
			});

			this._$ele = $$`<div class="ve-flex-col ui-ctx__wrp py-2 absolute">${$elesAction}</div>`
				.hideVe()
				.appendTo(document.body);
		};

		this._getMenuPosition = function (evt, axis) {
			const {fnMenuSize, fnGetEventPos, fnWindowSize, fnScrollDir} = axis === "x"
				? {fnMenuSize: "width", fnGetEventPos: "getClientX", fnWindowSize: "width", fnScrollDir: "scrollLeft"}
				: {fnMenuSize: "height", fnGetEventPos: "getClientY", fnWindowSize: "height", fnScrollDir: "scrollTop"};

			const posMouse = EventUtil[fnGetEventPos](evt);
			const szWin = $(window)[fnWindowSize]();
			const posScroll = $(window)[fnScrollDir]();
			let position = posMouse + posScroll;
			const szMenu = this[fnMenuSize]();
						if (posMouse + szMenu > szWin && szMenu < posMouse) position -= szMenu;
			return position;
		};
	},

		Action: function (text, fnAction, opts) {
		opts = opts || {};

		this.text = text;
		this.fnAction = fnAction;

		this.isDisabled = opts.isDisabled;
		this.title = opts.title;
		this.style = opts.style;

		this.fnActionAlt = opts.fnActionAlt;
		this.textAlt = opts.textAlt;
		this.titleAlt = opts.titleAlt;

		this.render = function ({menu}) {
			const $btnAction = this._render_$btnAction({menu});
			const $btnActionAlt = this._render_$btnActionAlt({menu});

			return {
				action: this,
				$eleRow: $$`<div class="ui-ctx__row ve-flex-v-center ${this.style || ""}">${$btnAction}${$btnActionAlt}</div>`,
				$eleBtn: $btnAction,
			};
		};

		this._render_$btnAction = function ({menu}) {
			const $btnAction = $(`<div class="w-100 min-w-0 ui-ctx__btn py-1 pl-5 ${this.fnActionAlt ? "" : "pr-5"}" ${this.isDisabled ? "disabled" : ""} tabindex="0">${this.text}</div>`)
				.on("click", async evt => {
					if (this.isDisabled) return;

					evt.preventDefault();
					evt.stopPropagation();

					menu.close();

					const result = await this.fnAction(evt, menu.userData);
					if (menu.resolveResult_) menu.resolveResult_(result);
				})
				.keydown(evt => {
					if (evt.key !== "Enter") return;
					$btnAction.click();
				});
			if (this.title) $btnAction.title(this.title);

			return $btnAction;
		};

		this._render_$btnActionAlt = function ({menu}) {
			if (!this.fnActionAlt) return null;

			const $btnActionAlt = $(`<div class="ui-ctx__btn ml-1 bl-1 py-1 px-4" ${this.isDisabled ? "disabled" : ""}>${this.textAlt ?? `<span class="glyphicon glyphicon-cog"></span>`}</div>`)
				.on("click", async evt => {
					if (this.isDisabled) return;

					evt.preventDefault();
					evt.stopPropagation();

					menu.close();

					const result = await this.fnActionAlt(evt, menu.userData);
					if (menu.resolveResult_) menu.resolveResult_(result);
				});
			if (this.titleAlt) $btnActionAlt.title(this.titleAlt);

			return $btnActionAlt;
		};

		this.update = function () {  };
	},

	ActionLink: function (text, fnHref, opts) {
		ContextUtil.Action.call(this, text, null, opts);

		this.fnHref = fnHref;
		this._$btnAction = null;

		this._render_$btnAction = function () {
			this._$btnAction = $(`<a href="${this.fnHref()}" class="w-100 min-w-0 ui-ctx__btn py-1 pl-5 ${this.fnActionAlt ? "" : "pr-5"}" ${this.isDisabled ? "disabled" : ""} tabindex="0">${this.text}</a>`);
			if (this.title) this._$btnAction.title(this.title);

			return this._$btnAction;
		};

		this.update = function () {
			this._$btnAction.attr("href", this.fnHref());
		};
	},

	ActionSelect: function (
		{
			values,
			fnOnChange = null,
			fnGetDisplayValue = null,
		},
	) {
		this._values = values;
		this._fnOnChange = fnOnChange;
		this._fnGetDisplayValue = fnGetDisplayValue;

		this._sel = null;

		this._ixInitial = null;

		this.render = function ({menu}) {
			this._sel = this._render_sel({menu});

			if (this._ixInitial != null) {
				this._sel.val(`${this._ixInitial}`);
				this._ixInitial = null;
			}

			return {
				action: this,
				$eleRow: $$`<div class="ui-ctx__row ve-flex-v-center">${this._sel}</div>`,
			};
		};

		this._render_sel = function ({menu}) {
			const sel = e_({
				tag: "select",
				clazz: "w-100 min-w-0 mx-5 py-1",
				tabindex: 0,
				children: this._values
					.map((val, i) => {
						return e_({
							tag: "option",
							value: i,
							text: this._fnGetDisplayValue ? this._fnGetDisplayValue(val) : val,
						});
					}),
				click: async evt => {
					evt.preventDefault();
					evt.stopPropagation();
				},
				keydown: evt => {
					if (evt.key !== "Enter") return;
					sel.click();
				},
				change: () => {
					menu.close();

					const ix = Number(sel.val() || 0);
					const val = this._values[ix];

					if (this._fnOnChange) this._fnOnChange(val);
					if (menu.resolveResult_) menu.resolveResult_(val);
				},
			});

			return sel;
		};

		this.setValue = function (val) {
			const ix = this._values.indexOf(val);
			if (!this._sel) return this._ixInitial = ix;
			this._sel.val(`${ix}`);
		};

		this.update = function () {  };
	},
};

globalThis.SearchUtil = {
	removeStemmer (elasticSearch) {
		const stemmer = elasticlunr.Pipeline.getRegisteredFunction("stemmer");
		elasticSearch.pipeline.remove(stemmer);
	},
};

globalThis.UrlUtil = {
	encodeForHash (toEncode) {
		if (toEncode instanceof Array) return toEncode.map(it => `${it}`.toUrlified()).join(HASH_LIST_SEP);
		else return `${toEncode}`.toUrlified();
	},

	encodeArrayForHash (...toEncodes) {
		return toEncodes.map(UrlUtil.encodeForHash).join(HASH_LIST_SEP);
	},

	autoEncodeHash (obj) {
		const curPage = UrlUtil.getCurrentPage();
		const encoder = UrlUtil.URL_TO_HASH_BUILDER[curPage];
		if (!encoder) throw new Error(`No encoder found for page ${curPage}`);
		return encoder(obj);
	},

	decodeHash (hash) {
		return hash.split(HASH_LIST_SEP).map(it => decodeURIComponent(it));
	},

	getSluggedHash (hash) {
		return Parser.stringToSlug(decodeURIComponent(hash)).replace(/_/g, "-");
	},

	getCurrentPage () {
		if (typeof window === "undefined") return VeCt.PG_NONE;
		const pSplit = window.location.pathname.split("/");
		let out = pSplit[pSplit.length - 1];
		if (!out.toLowerCase().endsWith(".html")) out += ".html";
		return out;
	},

		link (href, {isBustCache = false} = {}) {
		if (isBustCache) return UrlUtil._link_getWithParam(href, {param: `t=${Date.now()}`});
		return href;
	},

	_link_getWithParam (href, {param = `v=${VERSION_NUMBER}`} = {}) {
		if (href.includes("?")) return `${href}&${param}`;
		return `${href}?${param}`;
	},

	unpackSubHash (subHash, unencode) {
				if (subHash.includes(HASH_SUB_KV_SEP)) {
			const keyValArr = subHash.split(HASH_SUB_KV_SEP).map(s => s.trim());
			const out = {};
			let k = keyValArr[0].toLowerCase();
			if (unencode) k = decodeURIComponent(k);
			let v = keyValArr[1].toLowerCase();
			if (unencode) v = decodeURIComponent(v);
			out[k] = v.split(HASH_SUB_LIST_SEP).map(s => s.trim());
			if (out[k].length === 1 && out[k] === HASH_SUB_NONE) out[k] = [];
			return out;
		} else {
			throw new Error(`Badly formatted subhash ${subHash}`);
		}
	},

		packSubHash (key, values, opts) {
		opts = opts || {};
		if (opts.isEncodeBoth || opts.isEncodeKey) key = key.toUrlified();
		if (opts.isEncodeBoth || opts.isEncodeValues) values = values.map(it => it.toUrlified());
		return `${key}${HASH_SUB_KV_SEP}${values.join(HASH_SUB_LIST_SEP)}`;
	},

	categoryToPage (category) { return UrlUtil.CAT_TO_PAGE[category]; },
	categoryToHoverPage (category) { return UrlUtil.CAT_TO_HOVER_PAGE[category] || UrlUtil.categoryToPage(category); },

	pageToDisplayPage (page) { return UrlUtil.PG_TO_NAME[page] || page; },

	getFilename (url) { return url.slice(url.lastIndexOf("/") + 1); },

	isFullUrl (url) { return url && /^.*?:\/\//.test(url); },

	mini: {
		compress (primitive) {
			const type = typeof primitive;
			if (primitive == null) return `x`;
			switch (type) {
				case "boolean": return `b${Number(primitive)}`;
				case "number": return `n${primitive}`;
				case "string": return `s${primitive.toUrlified()}`;
				default: throw new Error(`Unhandled type "${type}"`);
			}
		},

		decompress (raw) {
			const [type, data] = [raw.slice(0, 1), raw.slice(1)];
			switch (type) {
				case "x": return null;
				case "b": return !!Number(data);
				case "n": return Number(data);
				case "s": return decodeURIComponent(String(data));
				default: throw new Error(`Unhandled type "${type}"`);
			}
		},
	},

	class: {
		getIndexedClassEntries (cls) {
			const out = [];

			(cls.classFeatures || []).forEach((lvlFeatureList, ixLvl) => {
				lvlFeatureList
										.filter(feature => (!feature.gainSubclassFeature || feature.gainSubclassFeatureHasContent)
						&& feature.name !== "Ability Score Improvement"
						&& feature.name !== "Proficiency Versatility")
					.forEach((feature, ixFeature) => {
						const name = Renderer.findName(feature);
						if (!name) { 							if (BrewUtil2.hasSourceJson(cls.source)) return;
							else throw new Error("Class feature had no name!");
						}
						out.push({
							_type: "classFeature",
							source: cls.source.source || cls.source,
							name,
							hash: `${UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES](cls)}${HASH_PART_SEP}${UrlUtil.getClassesPageStatePart({feature: {ixLevel: ixLvl, ixFeature: ixFeature}})}`,
							entry: feature,
							level: ixLvl + 1,
						});
					});
			});

			return out;
		},

		getIndexedSubclassEntries (sc) {
			const out = [];

			const lvlFeatures = sc.subclassFeatures || [];
			sc.source = sc.source || sc.classSource; 
			lvlFeatures.forEach(lvlFeature => {
				lvlFeature.forEach((feature, ixFeature) => {
					const subclassFeatureHash = `${UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES]({name: sc.className, source: sc.classSource})}${HASH_PART_SEP}${UrlUtil.getClassesPageStatePart({subclass: sc, feature: {ixLevel: feature.level - 1, ixFeature: ixFeature}})}`;

					const name = Renderer.findName(feature);
					if (!name) { 						if (BrewUtil2.hasSourceJson(sc.source)) return;
						else throw new Error("Subclass feature had no name!");
					}
					out.push({
						_type: "subclassFeature",
						name,
						subclassName: sc.name,
						subclassShortName: sc.shortName,
						source: sc.source.source || sc.source,
						hash: subclassFeatureHash,
						entry: feature,
						level: feature.level,
					});

					if (feature.entries) {
						const namedFeatureParts = feature.entries.filter(it => it.name);
						namedFeatureParts.forEach(it => {
							if (out.find(existing => it.name === existing.name && feature.level === existing.level)) return;
							out.push({
								_type: "subclassFeaturePart",
								name: it.name,
								subclassName: sc.name,
								subclassShortName: sc.shortName,
								source: sc.source.source || sc.source,
								hash: subclassFeatureHash,
								entry: feature,
								level: feature.level,
							});
						});
					}
				});
			});

			return out;
		},
	},

	getStateKeySubclass (sc) { return Parser.stringToSlug(`sub ${sc.shortName || sc.name} ${sc.source}`); },

		getClassesPageStatePart (opts) {
		if (!opts.subclass && !opts.feature) return "";

		if (!opts.feature) return UrlUtil.packSubHash("state", [UrlUtil._getClassesPageStatePart_subclass(opts.subclass)]);
		if (!opts.subclass) return UrlUtil.packSubHash("state", [UrlUtil._getClassesPageStatePart_feature(opts.feature)]);

		return UrlUtil.packSubHash(
			"state",
			[
				UrlUtil._getClassesPageStatePart_subclass(opts.subclass),
				UrlUtil._getClassesPageStatePart_feature(opts.feature),
			],
		);
	},

	_getClassesPageStatePart_subclass (sc) { return `${UrlUtil.getStateKeySubclass(sc)}=${UrlUtil.mini.compress(true)}`; },
	_getClassesPageStatePart_feature (feature) { return `feature=${UrlUtil.mini.compress(`${feature.ixLevel}-${feature.ixFeature}`)}`; },
};

UrlUtil.PG_BESTIARY = "bestiary.html";
UrlUtil.PG_SPELLS = "spells.html";
UrlUtil.PG_BACKGROUNDS = "backgrounds.html";
UrlUtil.PG_ITEMS = "items.html";
UrlUtil.PG_CLASSES = "classes.html";
UrlUtil.PG_CONDITIONS_DISEASES = "conditionsdiseases.html";
UrlUtil.PG_FEATS = "feats.html";
UrlUtil.PG_OPT_FEATURES = "optionalfeatures.html";
UrlUtil.PG_PSIONICS = "psionics.html";
UrlUtil.PG_RACES = "races.html";
UrlUtil.PG_REWARDS = "rewards.html";
UrlUtil.PG_VARIANTRULES = "variantrules.html";
UrlUtil.PG_ADVENTURE = "adventure.html";
UrlUtil.PG_ADVENTURES = "adventures.html";
UrlUtil.PG_BOOK = "book.html";
UrlUtil.PG_BOOKS = "books.html";
UrlUtil.PG_DEITIES = "deities.html";
UrlUtil.PG_CULTS_BOONS = "cultsboons.html";
UrlUtil.PG_OBJECTS = "objects.html";
UrlUtil.PG_TRAPS_HAZARDS = "trapshazards.html";
UrlUtil.PG_QUICKREF = "quickreference.html";
UrlUtil.PG_MANAGE_BREW = "managebrew.html";
UrlUtil.PG_MANAGE_PRERELEASE = "manageprerelease.html";
UrlUtil.PG_MAKE_BREW = "makebrew.html";
UrlUtil.PG_DEMO_RENDER = "renderdemo.html";
UrlUtil.PG_TABLES = "tables.html";
UrlUtil.PG_VEHICLES = "vehicles.html";
UrlUtil.PG_CHARACTERS = "characters.html";
UrlUtil.PG_ACTIONS = "actions.html";
UrlUtil.PG_LANGUAGES = "languages.html";
UrlUtil.PG_STATGEN = "statgen.html";
UrlUtil.PG_LIFEGEN = "lifegen.html";
UrlUtil.PG_NAMES = "names.html";
UrlUtil.PG_DM_SCREEN = "dmscreen.html";
UrlUtil.PG_CR_CALCULATOR = "crcalculator.html";
UrlUtil.PG_ENCOUNTERGEN = "encountergen.html";
UrlUtil.PG_LOOTGEN = "lootgen.html";
UrlUtil.PG_TEXT_CONVERTER = "converter.html";
UrlUtil.PG_CHANGELOG = "changelog.html";
UrlUtil.PG_CHAR_CREATION_OPTIONS = "charcreationoptions.html";
UrlUtil.PG_RECIPES = "recipes.html";
UrlUtil.PG_CLASS_SUBCLASS_FEATURES = "classfeatures.html";
UrlUtil.PG_MAPS = "maps.html";
UrlUtil.PG_SEARCH = "search.html";
UrlUtil.PG_DECKS = "decks.html";

UrlUtil.URL_TO_HASH_GENERIC = (it) => UrlUtil.encodeArrayForHash(it.name, it.source);

UrlUtil.URL_TO_HASH_BUILDER = {};
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BESTIARY] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_SPELLS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BACKGROUNDS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CONDITIONS_DISEASES] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_FEATS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_OPT_FEATURES] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_PSIONICS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_RACES] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_REWARDS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_VARIANTRULES] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ADVENTURE] = (it) => UrlUtil.encodeForHash(it.id);
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ADVENTURES] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ADVENTURE];
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BOOK] = (it) => UrlUtil.encodeForHash(it.id);
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BOOKS] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BOOK];
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_DEITIES] = (it) => UrlUtil.encodeArrayForHash(it.name, it.pantheon, it.source);
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CULTS_BOONS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_OBJECTS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_TRAPS_HAZARDS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_TABLES] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_VEHICLES] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ACTIONS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_LANGUAGES] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CHAR_CREATION_OPTIONS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_RECIPES] = (it) => `${UrlUtil.encodeArrayForHash(it.name, it.source)}${it._scaleFactor ? `${HASH_PART_SEP}${VeCt.HASH_SCALED}${HASH_SUB_KV_SEP}${it._scaleFactor}` : ""}`;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_DECKS] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASS_SUBCLASS_FEATURES] = (it) => (it.__prop === "subclassFeature" || it.subclassSource) ? UrlUtil.URL_TO_HASH_BUILDER["subclassFeature"](it) : UrlUtil.URL_TO_HASH_BUILDER["classFeature"](it);
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_QUICKREF] = ({name, ixChapter, ixHeader}) => {
	const hashParts = ["bookref-quick", ixChapter, UrlUtil.encodeForHash(name.toLowerCase())];
	if (ixHeader) hashParts.push(ixHeader);
	return hashParts.join(HASH_PART_SEP);
};

UrlUtil.URL_TO_HASH_BUILDER["monster"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BESTIARY];
UrlUtil.URL_TO_HASH_BUILDER["spell"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_SPELLS];
UrlUtil.URL_TO_HASH_BUILDER["background"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BACKGROUNDS];
UrlUtil.URL_TO_HASH_BUILDER["item"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS];
UrlUtil.URL_TO_HASH_BUILDER["itemGroup"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS];
UrlUtil.URL_TO_HASH_BUILDER["baseitem"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS];
UrlUtil.URL_TO_HASH_BUILDER["magicvariant"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS];
UrlUtil.URL_TO_HASH_BUILDER["class"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES];
UrlUtil.URL_TO_HASH_BUILDER["condition"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CONDITIONS_DISEASES];
UrlUtil.URL_TO_HASH_BUILDER["disease"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CONDITIONS_DISEASES];
UrlUtil.URL_TO_HASH_BUILDER["status"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CONDITIONS_DISEASES];
UrlUtil.URL_TO_HASH_BUILDER["feat"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_FEATS];
UrlUtil.URL_TO_HASH_BUILDER["optionalfeature"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_OPT_FEATURES];
UrlUtil.URL_TO_HASH_BUILDER["psionic"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_PSIONICS];
UrlUtil.URL_TO_HASH_BUILDER["race"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_RACES];
UrlUtil.URL_TO_HASH_BUILDER["subrace"] = (it) => UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_RACES]({name: `${it.name} (${it.raceName})`, source: it.source});
UrlUtil.URL_TO_HASH_BUILDER["reward"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_REWARDS];
UrlUtil.URL_TO_HASH_BUILDER["variantrule"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_VARIANTRULES];
UrlUtil.URL_TO_HASH_BUILDER["adventure"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ADVENTURES];
UrlUtil.URL_TO_HASH_BUILDER["adventureData"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ADVENTURES];
UrlUtil.URL_TO_HASH_BUILDER["book"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BOOKS];
UrlUtil.URL_TO_HASH_BUILDER["bookData"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BOOKS];
UrlUtil.URL_TO_HASH_BUILDER["deity"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_DEITIES];
UrlUtil.URL_TO_HASH_BUILDER["cult"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CULTS_BOONS];
UrlUtil.URL_TO_HASH_BUILDER["boon"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CULTS_BOONS];
UrlUtil.URL_TO_HASH_BUILDER["object"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_OBJECTS];
UrlUtil.URL_TO_HASH_BUILDER["trap"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_TRAPS_HAZARDS];
UrlUtil.URL_TO_HASH_BUILDER["hazard"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_TRAPS_HAZARDS];
UrlUtil.URL_TO_HASH_BUILDER["table"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_TABLES];
UrlUtil.URL_TO_HASH_BUILDER["tableGroup"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_TABLES];
UrlUtil.URL_TO_HASH_BUILDER["vehicle"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_VEHICLES];
UrlUtil.URL_TO_HASH_BUILDER["vehicleUpgrade"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_VEHICLES];
UrlUtil.URL_TO_HASH_BUILDER["action"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ACTIONS];
UrlUtil.URL_TO_HASH_BUILDER["language"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_LANGUAGES];
UrlUtil.URL_TO_HASH_BUILDER["charoption"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CHAR_CREATION_OPTIONS];
UrlUtil.URL_TO_HASH_BUILDER["recipe"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_RECIPES];
UrlUtil.URL_TO_HASH_BUILDER["deck"] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_DECKS];

UrlUtil.URL_TO_HASH_BUILDER["subclass"] = it => {
	return Hist.util.getCleanHash(
		`${UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES]({name: it.className, source: it.classSource})}${HASH_PART_SEP}${UrlUtil.getClassesPageStatePart({subclass: it})}`,
	);
};
UrlUtil.URL_TO_HASH_BUILDER["classFeature"] = (it) => UrlUtil.encodeArrayForHash(it.name, it.className, it.classSource, it.level, it.source);
UrlUtil.URL_TO_HASH_BUILDER["subclassFeature"] = (it) => UrlUtil.encodeArrayForHash(it.name, it.className, it.classSource, it.subclassShortName, it.subclassSource, it.level, it.source);
UrlUtil.URL_TO_HASH_BUILDER["card"] = (it) => UrlUtil.encodeArrayForHash(it.name, it.set, it.source);
UrlUtil.URL_TO_HASH_BUILDER["legendaryGroup"] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER["itemEntry"] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER["itemProperty"] = (it) => UrlUtil.encodeArrayForHash(it.abbreviation, it.source);
UrlUtil.URL_TO_HASH_BUILDER["itemType"] = (it) => UrlUtil.encodeArrayForHash(it.abbreviation, it.source);
UrlUtil.URL_TO_HASH_BUILDER["itemTypeAdditionalEntries"] = (it) => UrlUtil.encodeArrayForHash(it.appliesTo, it.source);
UrlUtil.URL_TO_HASH_BUILDER["itemMastery"] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER["skill"] = UrlUtil.URL_TO_HASH_GENERIC;
UrlUtil.URL_TO_HASH_BUILDER["sense"] = UrlUtil.URL_TO_HASH_GENERIC;

Object.keys(UrlUtil.URL_TO_HASH_BUILDER)
	.filter(k => !k.endsWith(".html") && k.toLowerCase() !== k)
	.forEach(k => UrlUtil.URL_TO_HASH_BUILDER[k.toLowerCase()] = UrlUtil.URL_TO_HASH_BUILDER[k]);

Object.keys(UrlUtil.URL_TO_HASH_BUILDER)
	.filter(k => !k.endsWith(".html"))
	.forEach(k => UrlUtil.URL_TO_HASH_BUILDER[`raw_${k}`] = UrlUtil.URL_TO_HASH_BUILDER[k]);

Object.keys(UrlUtil.URL_TO_HASH_BUILDER)
	.filter(k => !k.endsWith(".html"))
	.forEach(k => UrlUtil.URL_TO_HASH_BUILDER[`${k}Fluff`] = UrlUtil.URL_TO_HASH_BUILDER[k]);

UrlUtil.PG_TO_NAME = {};
UrlUtil.PG_TO_NAME[UrlUtil.PG_BESTIARY] = "Bestiary";
UrlUtil.PG_TO_NAME[UrlUtil.PG_SPELLS] = "Spells";
UrlUtil.PG_TO_NAME[UrlUtil.PG_BACKGROUNDS] = "Backgrounds";
UrlUtil.PG_TO_NAME[UrlUtil.PG_ITEMS] = "Items";
UrlUtil.PG_TO_NAME[UrlUtil.PG_CLASSES] = "Classes";
UrlUtil.PG_TO_NAME[UrlUtil.PG_CONDITIONS_DISEASES] = "Conditions & Diseases";
UrlUtil.PG_TO_NAME[UrlUtil.PG_FEATS] = "Feats";
UrlUtil.PG_TO_NAME[UrlUtil.PG_OPT_FEATURES] = "Other Options and Features";
UrlUtil.PG_TO_NAME[UrlUtil.PG_PSIONICS] = "Psionics";
UrlUtil.PG_TO_NAME[UrlUtil.PG_RACES] = "Races";
UrlUtil.PG_TO_NAME[UrlUtil.PG_REWARDS] = "Supernatural Gifts & Rewards";
UrlUtil.PG_TO_NAME[UrlUtil.PG_VARIANTRULES] = "Optional, Variant, and Expanded Rules";
UrlUtil.PG_TO_NAME[UrlUtil.PG_ADVENTURES] = "Adventures";
UrlUtil.PG_TO_NAME[UrlUtil.PG_BOOKS] = "Books";
UrlUtil.PG_TO_NAME[UrlUtil.PG_DEITIES] = "Deities";
UrlUtil.PG_TO_NAME[UrlUtil.PG_CULTS_BOONS] = "Cults & Supernatural Boons";
UrlUtil.PG_TO_NAME[UrlUtil.PG_OBJECTS] = "Objects";
UrlUtil.PG_TO_NAME[UrlUtil.PG_TRAPS_HAZARDS] = "Traps & Hazards";
UrlUtil.PG_TO_NAME[UrlUtil.PG_QUICKREF] = "Quick Reference";
UrlUtil.PG_TO_NAME[UrlUtil.PG_MANAGE_BREW] = "Homebrew Manager";
UrlUtil.PG_TO_NAME[UrlUtil.PG_MANAGE_PRERELEASE] = "Prerelease Content Manager";
UrlUtil.PG_TO_NAME[UrlUtil.PG_MAKE_BREW] = "Homebrew Builder";
UrlUtil.PG_TO_NAME[UrlUtil.PG_DEMO_RENDER] = "Renderer Demo";
UrlUtil.PG_TO_NAME[UrlUtil.PG_TABLES] = "Tables";
UrlUtil.PG_TO_NAME[UrlUtil.PG_VEHICLES] = "Vehicles";
UrlUtil.PG_TO_NAME[UrlUtil.PG_ACTIONS] = "Actions";
UrlUtil.PG_TO_NAME[UrlUtil.PG_LANGUAGES] = "Languages";
UrlUtil.PG_TO_NAME[UrlUtil.PG_STATGEN] = "Stat Generator";
UrlUtil.PG_TO_NAME[UrlUtil.PG_LIFEGEN] = "This Is Your Life";
UrlUtil.PG_TO_NAME[UrlUtil.PG_NAMES] = "Names";
UrlUtil.PG_TO_NAME[UrlUtil.PG_DM_SCREEN] = "DM Screen";
UrlUtil.PG_TO_NAME[UrlUtil.PG_CR_CALCULATOR] = "CR Calculator";
UrlUtil.PG_TO_NAME[UrlUtil.PG_ENCOUNTERGEN] = "Encounter Generator";
UrlUtil.PG_TO_NAME[UrlUtil.PG_LOOTGEN] = "Loot Generator";
UrlUtil.PG_TO_NAME[UrlUtil.PG_TEXT_CONVERTER] = "Text Converter";
UrlUtil.PG_TO_NAME[UrlUtil.PG_CHANGELOG] = "Changelog";
UrlUtil.PG_TO_NAME[UrlUtil.PG_CHAR_CREATION_OPTIONS] = "Other Character Creation Options";
UrlUtil.PG_TO_NAME[UrlUtil.PG_RECIPES] = "Recipes";
UrlUtil.PG_TO_NAME[UrlUtil.PG_CLASS_SUBCLASS_FEATURES] = "Class & Subclass Features";
UrlUtil.PG_TO_NAME[UrlUtil.PG_MAPS] = "Maps";
UrlUtil.PG_TO_NAME[UrlUtil.PG_DECKS] = "Decks";

UrlUtil.CAT_TO_PAGE = {};
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_CREATURE] = UrlUtil.PG_BESTIARY;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_SPELL] = UrlUtil.PG_SPELLS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_BACKGROUND] = UrlUtil.PG_BACKGROUNDS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ITEM] = UrlUtil.PG_ITEMS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_CLASS] = UrlUtil.PG_CLASSES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_CLASS_FEATURE] = UrlUtil.PG_CLASSES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_SUBCLASS] = UrlUtil.PG_CLASSES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_SUBCLASS_FEATURE] = UrlUtil.PG_CLASSES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_CONDITION] = UrlUtil.PG_CONDITIONS_DISEASES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_FEAT] = UrlUtil.PG_FEATS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ELDRITCH_INVOCATION] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_METAMAGIC] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_MANEUVER_BATTLEMASTER] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_MANEUVER_CAVALIER] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ARCANE_SHOT] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_OPTIONAL_FEATURE_OTHER] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_FIGHTING_STYLE] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_PSIONIC] = UrlUtil.PG_PSIONICS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_RACE] = UrlUtil.PG_RACES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_OTHER_REWARD] = UrlUtil.PG_REWARDS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_VARIANT_OPTIONAL_RULE] = UrlUtil.PG_VARIANTRULES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ADVENTURE] = UrlUtil.PG_ADVENTURE;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_DEITY] = UrlUtil.PG_DEITIES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_OBJECT] = UrlUtil.PG_OBJECTS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_TRAP] = UrlUtil.PG_TRAPS_HAZARDS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_HAZARD] = UrlUtil.PG_TRAPS_HAZARDS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_QUICKREF] = UrlUtil.PG_QUICKREF;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_CULT] = UrlUtil.PG_CULTS_BOONS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_BOON] = UrlUtil.PG_CULTS_BOONS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_DISEASE] = UrlUtil.PG_CONDITIONS_DISEASES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_TABLE] = UrlUtil.PG_TABLES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_TABLE_GROUP] = UrlUtil.PG_TABLES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_VEHICLE] = UrlUtil.PG_VEHICLES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_PACT_BOON] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ELEMENTAL_DISCIPLINE] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ARTIFICER_INFUSION] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_SHIP_UPGRADE] = UrlUtil.PG_VEHICLES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_INFERNAL_WAR_MACHINE_UPGRADE] = UrlUtil.PG_VEHICLES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ONOMANCY_RESONANT] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_RUNE_KNIGHT_RUNE] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ALCHEMICAL_FORMULA] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_MANEUVER] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ACTION] = UrlUtil.PG_ACTIONS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_LANGUAGE] = UrlUtil.PG_LANGUAGES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_BOOK] = UrlUtil.PG_BOOK;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_PAGE] = null;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_LEGENDARY_GROUP] = null;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_CHAR_CREATION_OPTIONS] = UrlUtil.PG_CHAR_CREATION_OPTIONS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_RECIPES] = UrlUtil.PG_RECIPES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_STATUS] = UrlUtil.PG_CONDITIONS_DISEASES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_DECK] = UrlUtil.PG_DECKS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_CARD] = "card";
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_SKILLS] = "skill";
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_SENSES] = "sense";
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_LEGENDARY_GROUP] = "legendaryGroup";

UrlUtil.CAT_TO_HOVER_PAGE = {};
UrlUtil.CAT_TO_HOVER_PAGE[Parser.CAT_ID_CLASS_FEATURE] = "classfeature";
UrlUtil.CAT_TO_HOVER_PAGE[Parser.CAT_ID_SUBCLASS_FEATURE] = "subclassfeature";
UrlUtil.CAT_TO_HOVER_PAGE[Parser.CAT_ID_CARD] = "card";
UrlUtil.CAT_TO_HOVER_PAGE[Parser.CAT_ID_SKILLS] = "skill";
UrlUtil.CAT_TO_HOVER_PAGE[Parser.CAT_ID_SENSES] = "sense";
UrlUtil.CAT_TO_HOVER_PAGE[Parser.CAT_ID_LEGENDARY_GROUP] = "legendaryGroup";

UrlUtil.HASH_START_CREATURE_SCALED = `${VeCt.HASH_SCALED}${HASH_SUB_KV_SEP}`;
UrlUtil.HASH_START_CREATURE_SCALED_SPELL_SUMMON = `${VeCt.HASH_SCALED_SPELL_SUMMON}${HASH_SUB_KV_SEP}`;
UrlUtil.HASH_START_CREATURE_SCALED_CLASS_SUMMON = `${VeCt.HASH_SCALED_CLASS_SUMMON}${HASH_SUB_KV_SEP}`;

UrlUtil.SUBLIST_PAGES = {
	[UrlUtil.PG_BESTIARY]: true,
	[UrlUtil.PG_SPELLS]: true,
	[UrlUtil.PG_BACKGROUNDS]: true,
	[UrlUtil.PG_ITEMS]: true,
	[UrlUtil.PG_CONDITIONS_DISEASES]: true,
	[UrlUtil.PG_FEATS]: true,
	[UrlUtil.PG_OPT_FEATURES]: true,
	[UrlUtil.PG_PSIONICS]: true,
	[UrlUtil.PG_RACES]: true,
	[UrlUtil.PG_REWARDS]: true,
	[UrlUtil.PG_VARIANTRULES]: true,
	[UrlUtil.PG_DEITIES]: true,
	[UrlUtil.PG_CULTS_BOONS]: true,
	[UrlUtil.PG_OBJECTS]: true,
	[UrlUtil.PG_TRAPS_HAZARDS]: true,
	[UrlUtil.PG_TABLES]: true,
	[UrlUtil.PG_VEHICLES]: true,
	[UrlUtil.PG_ACTIONS]: true,
	[UrlUtil.PG_LANGUAGES]: true,
	[UrlUtil.PG_CHAR_CREATION_OPTIONS]: true,
	[UrlUtil.PG_RECIPES]: true,
	[UrlUtil.PG_DECKS]: true,
};

UrlUtil.PAGE_TO_PROPS = {};
UrlUtil.PAGE_TO_PROPS[UrlUtil.PG_SPELLS] = ["spell"];
UrlUtil.PAGE_TO_PROPS[UrlUtil.PG_ITEMS] = ["item", "itemGroup", "itemType", "itemEntry", "itemProperty", "itemTypeAdditionalEntries", "itemMastery", "baseitem", "magicvariant"];

if (!IS_DEPLOYED && !IS_VTT && typeof window !== "undefined") {
		window.addEventListener("keypress", (e) => {
		if (EventUtil.noModifierKeys(e) && typeof d20 === "undefined") {
			if (e.key === "#") {
				const spl = window.location.href.split("/");
				window.prompt("Copy to clipboard: Ctrl+C, Enter", `https://5etools-mirror-1.github.io/${spl[spl.length - 1]}`);
			}
		}
	});
}

globalThis.SortUtil = {
	ascSort: (a, b) => {
		if (typeof FilterItem !== "undefined") {
			if (a instanceof FilterItem) a = a.item;
			if (b instanceof FilterItem) b = b.item;
		}

		return SortUtil._ascSort(a, b);
	},

	ascSortProp: (prop, a, b) => { return SortUtil.ascSort(a[prop], b[prop]); },

	ascSortLower: (a, b) => {
		if (typeof FilterItem !== "undefined") {
			if (a instanceof FilterItem) a = a.item;
			if (b instanceof FilterItem) b = b.item;
		}

		a = a ? a.toLowerCase() : a;
		b = b ? b.toLowerCase() : b;

		return SortUtil._ascSort(a, b);
	},

	ascSortLowerProp: (prop, a, b) => { return SortUtil.ascSortLower(a[prop], b[prop]); },

		ascSortNumericalSuffix (a, b) {
		if (typeof FilterItem !== "undefined") {
			if (a instanceof FilterItem) a = a.item;
			if (b instanceof FilterItem) b = b.item;
		}

		function popEndNumber (str) {
			const spl = str.split(" ");
			return spl.last().isNumeric() ? [spl.slice(0, -1).join(" "), Number(spl.last().replace(Parser._numberCleanRegexp, ""))] : [spl.join(" "), 0];
		}

		const [aStr, aNum] = popEndNumber(a.item || a);
		const [bStr, bNum] = popEndNumber(b.item || b);
		const initialSort = SortUtil.ascSort(aStr, bStr);
		if (initialSort) return initialSort;
		return SortUtil.ascSort(aNum, bNum);
	},

	_ascSort: (a, b) => {
		if (b === a) return 0;
		return b < a ? 1 : -1;
	},

	ascSortDate (a, b) {
		return b.getTime() - a.getTime();
	},

	ascSortDateString (a, b) {
		return SortUtil.ascSortDate(new Date(a || "1970-01-0"), new Date(b || "1970-01-0"));
	},

	compareListNames (a, b) { return SortUtil._ascSort(a.name.toLowerCase(), b.name.toLowerCase()); },

	listSort (a, b, opts) {
		opts = opts || {sortBy: "name"};
		if (opts.sortBy === "name") return SortUtil.compareListNames(a, b);
		else return SortUtil._compareByOrDefault_compareByOrDefault(a, b, opts.sortBy);
	},

	_listSort_compareBy (a, b, sortBy) {
		const aValue = typeof a.values[sortBy] === "string" ? a.values[sortBy].toLowerCase() : a.values[sortBy];
		const bValue = typeof b.values[sortBy] === "string" ? b.values[sortBy].toLowerCase() : b.values[sortBy];

		return SortUtil._ascSort(aValue, bValue);
	},

	_compareByOrDefault_compareByOrDefault (a, b, sortBy) {
		return SortUtil._listSort_compareBy(a, b, sortBy) || SortUtil.compareListNames(a, b);
	},

		_MON_TRAIT_ORDER: [
		"special equipment",
		"shapechanger",
	],
	monTraitSort: (a, b) => {
		if (a.sort != null && b.sort != null) return a.sort - b.sort;
		if (a.sort != null && b.sort == null) return -1;
		if (a.sort == null && b.sort != null) return 1;

		if (!a.name && !b.name) return 0;
		const aClean = Renderer.stripTags(a.name).toLowerCase().trim();
		const bClean = Renderer.stripTags(b.name).toLowerCase().trim();

		const isOnlyA = a.name.endsWith(" Only)");
		const isOnlyB = b.name.endsWith(" Only)");
		if (!isOnlyA && isOnlyB) return -1;
		if (isOnlyA && !isOnlyB) return 1;

		const ixA = SortUtil._MON_TRAIT_ORDER.indexOf(aClean);
		const ixB = SortUtil._MON_TRAIT_ORDER.indexOf(bClean);
		if (~ixA && ~ixB) return ixA - ixB;
		else if (~ixA) return -1;
		else if (~ixB) return 1;
		else return SortUtil.ascSort(aClean, bClean);
	},

	_alignFirst: ["L", "C"],
	_alignSecond: ["G", "E"],
	alignmentSort: (a, b) => {
		if (a === b) return 0;
		if (SortUtil._alignFirst.includes(a)) return -1;
		if (SortUtil._alignSecond.includes(a)) return 1;
		if (SortUtil._alignFirst.includes(b)) return 1;
		if (SortUtil._alignSecond.includes(b)) return -1;
		return 0;
	},

	ascSortCr (a, b) {
		if (typeof FilterItem !== "undefined") {
			if (a instanceof FilterItem) a = a.item;
			if (b instanceof FilterItem) b = b.item;
		}
				if (a === "Unknown") a = "998";
		if (b === "Unknown") b = "998";
		if (a === "\u2014" || a == null) a = "999";
		if (b === "\u2014" || b == null) b = "999";
		return SortUtil.ascSort(Parser.crToNumber(a), Parser.crToNumber(b));
	},

	ascSortAtts (a, b) {
		const aSpecial = a === "special";
		const bSpecial = b === "special";
		return aSpecial && bSpecial ? 0 : aSpecial ? 1 : bSpecial ? -1 : Parser.ABIL_ABVS.indexOf(a) - Parser.ABIL_ABVS.indexOf(b);
	},

	ascSortSize (a, b) { return Parser.SIZE_ABVS.indexOf(a) - Parser.SIZE_ABVS.indexOf(b); },

	initBtnSortHandlers ($wrpBtnsSort, list) {
		let dispCaretInitial = null;

		const dispCarets = [...$wrpBtnsSort[0].querySelectorAll(`[data-sort]`)]
			.map(btnSort => {
				const dispCaret = e_({
					tag: "span",
					clazz: "lst__caret",
				})
					.appendTo(btnSort);

				const btnSortField = btnSort.dataset.sort;

				if (btnSortField === list.sortBy) dispCaretInitial = dispCaret;

				e_({
					ele: btnSort,
					click: evt => {
						evt.stopPropagation();
						const direction = list.sortDir === "asc" ? "desc" : "asc";
						SortUtil._initBtnSortHandlers_showCaret({dispCarets, dispCaret, direction});
						list.sort(btnSortField, direction);
					},
				});

				return dispCaret;
			});

		dispCaretInitial = dispCaretInitial || dispCarets[0]; 
		SortUtil._initBtnSortHandlers_showCaret({dispCaret: dispCaretInitial, dispCarets, direction: list.sortDir});
	},

	_initBtnSortHandlers_showCaret (
		{
			dispCaret,
			dispCarets,
			direction,
		},
	) {
		dispCarets.forEach($it => $it.removeClass("lst__caret--active"));
		dispCaret.addClass("lst__caret--active").toggleClass("lst__caret--reverse", direction === "asc");
	},

		initBtnSortHandlersAdditional ($wrpBtnsSort, list) {
		[...$wrpBtnsSort[0].querySelectorAll(".sort")]
			.map(btnSort => {
				const btnSortField = btnSort.dataset.sort;

				e_({
					ele: btnSort,
					click: evt => {
						evt.stopPropagation();
						const direction = list.sortDir === "asc" ? "desc" : "asc";
						list.sort(btnSortField, direction);
					},
				});
			});
	},

	ascSortSourceGroup (a, b) {
		const grpA = a.group || "other";
		const grpB = b.group || "other";
		const ixA = SourceUtil.ADV_BOOK_GROUPS.findIndex(it => it.group === grpA);
		const ixB = SourceUtil.ADV_BOOK_GROUPS.findIndex(it => it.group === grpB);
		return SortUtil.ascSort(ixA, ixB);
	},

	ascSortAdventure (a, b) {
		return SortUtil.ascSortDateString(b.published, a.published)
			|| SortUtil.ascSortLower(a.parentSource || "", b.parentSource || "")
			|| SortUtil.ascSort(a.publishedOrder ?? 0, b.publishedOrder ?? 0)
			|| SortUtil.ascSortLower(a.storyline, b.storyline)
			|| SortUtil.ascSort(a.level?.start ?? 20, b.level?.start ?? 20)
			|| SortUtil.ascSortLower(a.name, b.name);
	},

	ascSortBook (a, b) {
		return SortUtil.ascSortDateString(b.published, a.published)
			|| SortUtil.ascSortLower(a.parentSource || "", b.parentSource || "")
			|| SortUtil.ascSortLower(a.name, b.name);
	},

	ascSortGenericEntity (a, b) {
		return SortUtil.ascSortLower(a.name, b.name) || SortUtil.ascSortLower(a.source, b.source);
	},

	ascSortDeity (a, b) {
		return SortUtil.ascSortLower(a.name, b.name) || SortUtil.ascSortLower(a.source, b.source) || SortUtil.ascSortLower(a.pantheon, b.pantheon);
	},

	ascSortCard (a, b) {
		return SortUtil.ascSortLower(a.set, b.set) || SortUtil.ascSortLower(a.source, b.source) || SortUtil.ascSortLower(a.name, b.name);
	},

	_ITEM_RARITY_ORDER: ["none", "common", "uncommon", "rare", "very rare", "legendary", "artifact", "varies", "unknown (magic)", "unknown"],
	ascSortItemRarity (a, b) {
		const ixA = SortUtil._ITEM_RARITY_ORDER.indexOf(a);
		const ixB = SortUtil._ITEM_RARITY_ORDER.indexOf(b);
		return (~ixA ? ixA : Number.MAX_SAFE_INTEGER) - (~ixB ? ixB : Number.MAX_SAFE_INTEGER);
	},
};

class _DataUtilPropConfig {
	static _MERGE_REQUIRES_PRESERVE = {};
	static _PAGE = null;

	static get PAGE () { return this._PAGE; }

	static async pMergeCopy (lst, ent, options) {
		return DataUtil.generic._pMergeCopy(this, this._PAGE, lst, ent, options);
	}
}

class _DataUtilPropConfigSingleSource extends _DataUtilPropConfig {
	static _FILENAME = null;

	static getDataUrl () { return `${Renderer.get().baseUrl}data/${this._FILENAME}`; }

	static async loadJSON () { return this.loadRawJSON(); }
	static async loadRawJSON () { return DataUtil.loadJSON(this.getDataUrl()); }
	static async loadUnmergedJSON () { return DataUtil.loadRawJSON(this.getDataUrl()); }
}

class _DataUtilPropConfigMultiSource extends _DataUtilPropConfig {
	static _DIR = null;
	static _PROP = null;
	static _IS_MUT_ENTITIES = false;

	static get _isFluff () { return this._PROP.endsWith("Fluff"); }

	static _P_INDEX = null;

	static pLoadIndex () {
		this._P_INDEX = this._P_INDEX || DataUtil.loadJSON(`${Renderer.get().baseUrl}data/${this._DIR}/${this._isFluff ? `fluff-` : ""}index.json`);
		return this._P_INDEX;
	}

	static async pLoadAll () {
		const json = await this.loadJSON();
		return json[this._PROP];
	}

	static async loadJSON () { return this._loadJSON({isUnmerged: false}); }
	static async loadUnmergedJSON () { return this._loadJSON({isUnmerged: true}); }

	static async _loadJSON ({isUnmerged = false} = {}) {
		const index = await this.pLoadIndex();

		const allData = await Object.entries(index)
			.pMap(async ([source, file]) => this._pLoadSourceEntities({source, isUnmerged, file}));

		return {[this._PROP]: allData.flat()};
	}

	static async pLoadSingleSource (source) {
		const index = await this.pLoadIndex();

		const file = index[source];
		if (!file) return null;

		return {[this._PROP]: await this._pLoadSourceEntities({source, file})};
	}

	static async _pLoadSourceEntities ({source, isUnmerged = false, file}) {
		await this._pInitPreData();

		const fnLoad = isUnmerged ? DataUtil.loadRawJSON.bind(DataUtil) : DataUtil.loadJSON.bind(DataUtil);

		let data = await fnLoad(`${Renderer.get().baseUrl}data/${this._DIR}/${file}`);
		data = data[this._PROP].filter(it => it.source === source);

		if (!this._IS_MUT_ENTITIES) return data;

		return data.map(ent => this._mutEntity(ent));
	}

	static _P_INIT_PRE_DATA = null;

	static async _pInitPreData () {
		return (this._P_INIT_PRE_DATA = this._P_INIT_PRE_DATA || this._pInitPreData_());
	}

	static async _pInitPreData_ () {  }

	static _mutEntity (ent) { return ent; }
}

class _DataUtilPropConfigCustom extends _DataUtilPropConfig {
	static async loadJSON () { throw new Error("Unimplemented!"); }
	static async loadUnmergedJSON () { throw new Error("Unimplemented!"); }
}

class _DataUtilBrewHelper {
	constructor ({defaultUrlRoot}) {
		this._defaultUrlRoot = defaultUrlRoot;
	}

	_getCleanUrlRoot (urlRoot) {
		if (urlRoot && urlRoot.trim()) {
			urlRoot = urlRoot.trim();
			if (!urlRoot.endsWith("/")) urlRoot = `${urlRoot}/`;
			return urlRoot;
		}
		return this._defaultUrlRoot;
	}

	async pLoadTimestamps (urlRoot) {
		urlRoot = this._getCleanUrlRoot(urlRoot);
		return DataUtil.loadJSON(`${urlRoot}_generated/index-timestamps.json`);
	}

	async pLoadPropIndex (urlRoot) {
		urlRoot = this._getCleanUrlRoot(urlRoot);
		return DataUtil.loadJSON(`${urlRoot}_generated/index-props.json`);
	}

	async pLoadMetaIndex (urlRoot) {
		urlRoot = this._getCleanUrlRoot(urlRoot);
		return DataUtil.loadJSON(`${urlRoot}_generated/index-meta.json`);
	}

	async pLoadSourceIndex (urlRoot) {
		urlRoot = this._getCleanUrlRoot(urlRoot);
		return DataUtil.loadJSON(`${urlRoot}_generated/index-sources.json`);
	}

	getFileUrl (path, urlRoot) {
		urlRoot = this._getCleanUrlRoot(urlRoot);
		return `${urlRoot}${path}`;
	}
}

globalThis.DataUtil = {
	_loading: {},
	_loaded: {},
	_merging: {},
	_merged: {},

	async _pLoad ({url, id, isBustCache = false}) {
		if (DataUtil._loading[id] && !isBustCache) {
			await DataUtil._loading[id];
			return DataUtil._loaded[id];
		}

		DataUtil._loading[id] = new Promise((resolve, reject) => {
			const request = new XMLHttpRequest();

			request.open("GET", url, true);
						request.overrideMimeType("application/json");

			request.onload = function () {
				try {
					DataUtil._loaded[id] = JSON.parse(this.response);
					resolve();
				} catch (e) {
					reject(new Error(`Could not parse JSON from ${url}: ${e.message}`));
				}
			};
			request.onerror = (e) => reject(new Error(`Error during JSON request: ${e.target.status}`));

			request.send();
		});

		await DataUtil._loading[id];
		return DataUtil._loaded[id];
	},

	_mutAddProps (data) {
		if (data && typeof data === "object") {
			for (const k in data) {
				if (data[k] instanceof Array) {
					for (const it of data[k]) {
						if (typeof it !== "object") continue;
						it.__prop = k;
					}
				}
			}
		}
	},

	async loadJSON (url) {
		return DataUtil._loadJson(url, {isDoDataMerge: true});
	},

	async loadRawJSON (url, {isBustCache} = {}) {
		return DataUtil._loadJson(url, {isBustCache});
	},

	async _loadJson (url, {isDoDataMerge = false, isBustCache = false} = {}) {
		const procUrl = UrlUtil.link(url, {isBustCache});

		let data;
		try {
			data = await DataUtil._pLoad({url: procUrl, id: url, isBustCache});
		} catch (e) {
			setTimeout(() => { throw e; });
		}

				if (!data) data = await DataUtil._pLoad({url: url, id: url, isBustCache});

		if (isDoDataMerge) await DataUtil.pDoMetaMerge(url, data);

		return data;
	},

	async pDoMetaMerge (ident, data, options) {
		DataUtil._mutAddProps(data);
		DataUtil._merging[ident] = DataUtil._merging[ident] || DataUtil._pDoMetaMerge(ident, data, options);
		await DataUtil._merging[ident];
		const out = DataUtil._merged[ident];

						if (options?.isSkipMetaMergeCache) {
			delete DataUtil._merging[ident];
			delete DataUtil._merged[ident];
		}

		return out;
	},

	_pDoMetaMerge_handleCopyProp (prop, arr, entry, options) {
		if (!entry._copy) return;
		let fnMergeCopy = DataUtil[prop]?.pMergeCopy;
		if (!fnMergeCopy) throw new Error(`No dependency _copy merge strategy specified for property "${prop}"`);
		fnMergeCopy = fnMergeCopy.bind(DataUtil[prop]);
		return fnMergeCopy(arr, entry, options);
	},

	async _pDoMetaMerge (ident, data, options) {
		if (data._meta) {
			const loadedSourceIds = new Set();

			if (data._meta.dependencies) {
				await Promise.all(Object.entries(data._meta.dependencies).map(async ([dataProp, sourceIds]) => {
					sourceIds.forEach(sourceId => loadedSourceIds.add(sourceId));

					if (!data[dataProp]) return; 
					const isHasInternalCopies = (data._meta.internalCopies || []).includes(dataProp);

					const dependencyData = await Promise.all(sourceIds.map(sourceId => DataUtil.pLoadByMeta(dataProp, sourceId)));

					const flatDependencyData = dependencyData.map(dd => dd[dataProp]).flat().filter(Boolean);
					await Promise.all(data[dataProp].map(entry => DataUtil._pDoMetaMerge_handleCopyProp(dataProp, flatDependencyData, entry, {...options, isErrorOnMissing: !isHasInternalCopies})));
				}));
				delete data._meta.dependencies;
			}

			if (data._meta.internalCopies) {
				for (const prop of data._meta.internalCopies) {
					if (!data[prop]) continue;
					for (const entry of data[prop]) {
						await DataUtil._pDoMetaMerge_handleCopyProp(prop, data[prop], entry, {...options, isErrorOnMissing: true});
					}
				}
				delete data._meta.internalCopies;
			}

						if (data._meta.includes) {
				const includesData = await Promise.all(Object.entries(data._meta.includes).map(async ([dataProp, sourceIds]) => {
										sourceIds = sourceIds.filter(it => !loadedSourceIds.has(it));

					sourceIds.forEach(sourceId => loadedSourceIds.add(sourceId));

					const includesData = await Promise.all(sourceIds.map(sourceId => DataUtil.pLoadByMeta(dataProp, sourceId)));

					const flatIncludesData = includesData.map(dd => dd[dataProp]).flat().filter(Boolean);
					return {dataProp, flatIncludesData};
				}));
				delete data._meta.includes;

								includesData.forEach(({dataProp, flatIncludesData}) => {
					data[dataProp] = [...data[dataProp] || [], ...flatIncludesData];
				});
			}
		}

		if (data._meta && data._meta.otherSources) {
			await Promise.all(Object.entries(data._meta.otherSources).map(async ([dataProp, sourceIds]) => {
				const additionalData = await Promise.all(Object.entries(sourceIds).map(async ([sourceId, findWith]) => ({
					findWith,
					dataOther: await DataUtil.pLoadByMeta(dataProp, sourceId),
				})));

				additionalData.forEach(({findWith, dataOther}) => {
					const toAppend = dataOther[dataProp].filter(it => it.otherSources && it.otherSources.find(os => os.source === findWith));
					if (toAppend.length) data[dataProp] = (data[dataProp] || []).concat(toAppend);
				});
			}));
			delete data._meta.otherSources;
		}

		if (data._meta && !Object.keys(data._meta).length) delete data._meta;

		DataUtil._merged[ident] = data;
	},

	getCleanFilename (filename) {
		return filename.replace(/[^-_a-zA-Z0-9]/g, "_");
	},

	getCsv (headers, rows) {
		function escapeCsv (str) {
			return `"${str.replace(/"/g, `""`).replace(/ +/g, " ").replace(/\n\n+/gi, "\n\n")}"`;
		}

		function toCsv (row) {
			return row.map(str => escapeCsv(str)).join(",");
		}

		return `${toCsv(headers)}\n${rows.map(r => toCsv(r)).join("\n")}`;
	},

	userDownload (filename, data, {fileType = null, isSkipAdditionalMetadata = false, propVersion = "siteVersion", valVersion = VERSION_NUMBER} = {}) {
		filename = `${filename}.json`;
		if (isSkipAdditionalMetadata || data instanceof Array) return DataUtil._userDownload(filename, JSON.stringify(data, null, "\t"), "text/json");

		data = {[propVersion]: valVersion, ...data};
		if (fileType != null) data = {fileType, ...data};
		return DataUtil._userDownload(filename, JSON.stringify(data, null, "\t"), "text/json");
	},

	userDownloadText (filename, string) {
		return DataUtil._userDownload(filename, string, "text/plain");
	},

	_userDownload (filename, data, mimeType) {
		const a = document.createElement("a");
		const t = new Blob([data], {type: mimeType});
		a.href = window.URL.createObjectURL(t);
		a.download = filename;
		a.dispatchEvent(new MouseEvent("click", {bubbles: true, cancelable: true, view: window}));
		setTimeout(() => window.URL.revokeObjectURL(a.href), 100);
	},

		pUserUpload (
		{
			isMultiple = false,
			expectedFileTypes = null,
			propVersion = "siteVersion",
		} = {},
	) {
		return new Promise(resolve => {
			const $iptAdd = $(`<input type="file" ${isMultiple ? "multiple" : ""} class="ve-hidden" accept=".json">`)
				.on("change", (evt) => {
					const input = evt.target;

					const reader = new FileReader();
					let readIndex = 0;
					const out = [];
					const errs = [];

					reader.onload = async () => {
						const name = input.files[readIndex - 1].name;
						const text = reader.result;

						try {
							const json = JSON.parse(text);

							const isSkipFile = expectedFileTypes != null
								&& json.fileType
								&& !expectedFileTypes.includes(json.fileType)
								&& !(await InputUiUtil.pGetUserBoolean({
									textYes: "Yes",
									textNo: "Cancel",
									title: "File Type Mismatch",
									htmlDescription: `The file "${name}" has the type "${json.fileType}" when the expected file type was "${expectedFileTypes.join("/")}".<br>Are you sure you want to upload this file?`,
								}));

							if (!isSkipFile) {
								delete json.fileType;
								delete json[propVersion];

								out.push({name, json});
							}
						} catch (e) {
							errs.push({filename: name, message: e.message});
						}

						if (input.files[readIndex]) {
							reader.readAsText(input.files[readIndex++]);
							return;
						}

						resolve({
							files: out,
							errors: errs,
							jsons: out.map(({json}) => json),
						});
					};

					reader.readAsText(input.files[readIndex++]);
				})
				.appendTo(document.body);

			$iptAdd.click();
		});
	},

	doHandleFileLoadErrorsGeneric (errors) {
		if (!errors) return;
		errors.forEach(err => {
			JqueryUtil.doToast({
				content: `Could not load file "${err.filename}": <code>${err.message}</code>. ${VeCt.STR_SEE_CONSOLE}`,
				type: "danger",
			});
		});
	},

	cleanJson (cpy, {isDeleteUniqueId = true} = {}) {
		if (!cpy) return cpy;
		cpy.name = cpy._displayName || cpy.name;
		if (isDeleteUniqueId) delete cpy.uniqueId;
		DataUtil.__cleanJsonObject(cpy);
		return cpy;
	},

	_CLEAN_JSON_ALLOWED_UNDER_KEYS: [
		"_copy",
		"_versions",
		"_version",
	],
	__cleanJsonObject (obj) {
		if (obj == null) return obj;
		if (typeof obj !== "object") return obj;

		if (obj instanceof Array) {
			return obj.forEach(it => DataUtil.__cleanJsonObject(it));
		}

		Object.entries(obj).forEach(([k, v]) => {
			if (DataUtil._CLEAN_JSON_ALLOWED_UNDER_KEYS.includes(k)) return;
						if ((k.startsWith("_") && k !== "_") || k === "customHashId") delete obj[k];
			else DataUtil.__cleanJsonObject(v);
		});
	},

	_MULTI_SOURCE_PROP_TO_DIR: {
		"monster": "bestiary",
		"monsterFluff": "bestiary",
		"spell": "spells",
		"spellFluff": "spells",
		"class": "class",
		"subclass": "class",
		"classFeature": "class",
		"subclassFeature": "class",
	},
	_MULTI_SOURCE_PROP_TO_INDEX_NAME: {
		"class": "index.json",
		"subclass": "index.json",
		"classFeature": "index.json",
		"subclassFeature": "index.json",
	},
	async pLoadByMeta (prop, source) {
		
		switch (prop) {
						case "monster":
			case "spell":
			case "monsterFluff":
			case "spellFluff": {
				const data = await DataUtil[prop].pLoadSingleSource(source);
				if (data) return data;

				return DataUtil._pLoadByMeta_pGetPrereleaseBrewUrl(source);
			}
			
						case "class":
			case "subclass":
			case "classFeature":
			case "subclassFeature": {
				const baseUrlPart = `${Renderer.get().baseUrl}data/${DataUtil._MULTI_SOURCE_PROP_TO_DIR[prop]}`;
				const index = await DataUtil.loadJSON(`${baseUrlPart}/${DataUtil._MULTI_SOURCE_PROP_TO_INDEX_NAME[prop]}`);
				if (index[source]) return DataUtil.loadJSON(`${baseUrlPart}/${index[source]}`);

				return DataUtil._pLoadByMeta_pGetPrereleaseBrewUrl(source);
			}
			
						case "item":
			case "itemGroup": {
				const data = await DataUtil.item.loadRawJSON();
				if (data[prop] && data[prop].some(it => it.source === source)) return data;
				return DataUtil._pLoadByMeta_pGetPrereleaseBrewUrl(source);
			}
			case "race": {
				const data = await DataUtil.race.loadJSON({isAddBaseRaces: true});
				if (data[prop] && data[prop].some(it => it.source === source)) return data;
				return DataUtil._pLoadByMeta_pGetPrereleaseBrewUrl(source);
			}
			
						default: {
				const impl = DataUtil[prop];
				if (impl && (impl.getDataUrl || impl.loadJSON)) {
					const data = await (impl.loadJSON ? impl.loadJSON() : DataUtil.loadJSON(impl.getDataUrl()));
					if (data[prop] && data[prop].some(it => it.source === source)) return data;

					return DataUtil._pLoadByMeta_pGetPrereleaseBrewUrl(source);
				}

				throw new Error(`Could not get loadable URL for \`${JSON.stringify({key: prop, value: source})}\``);
			}
					}
	},

	async _pLoadByMeta_pGetPrereleaseBrewUrl (source) {
		const fromPrerelease = await DataUtil.pLoadPrereleaseBySource(source);
		if (fromPrerelease) return fromPrerelease;

		const fromBrew = await DataUtil.pLoadBrewBySource(source);
		if (fromBrew) return fromBrew;

		throw new Error(`Could not find prerelease/brew URL for source "${source}"`);
	},

	async pLoadPrereleaseBySource (source) {
		if (typeof PrereleaseUtil === "undefined") return null;
		const url = await PrereleaseUtil.pGetSourceUrl(source);
		if (!url) return null;
		return DataUtil.loadJSON(url);
	},

	async pLoadBrewBySource (source) {
		if (typeof BrewUtil2 === "undefined") return null;
		const url = await BrewUtil2.pGetSourceUrl(source);
		if (!url) return null;
		return DataUtil.loadJSON(url);
	},

		dbg: {
		isTrackCopied: false,
	},
	
	generic: {
		_MERGE_REQUIRES_PRESERVE_BASE: {
			page: true,
			otherSources: true,
			srd: true,
			basicRules: true,
			reprintedAs: true,
			hasFluff: true,
			hasFluffImages: true,
			hasToken: true,
			_versions: true,
		},

		_walker_replaceTxt: null,

				unpackUid (uid, tag, opts) {
			opts = opts || {};
			if (opts.isLower) uid = uid.toLowerCase();
			let [name, source, displayText, ...others] = uid.split("|").map(it => it.trim());

			source = source || Parser.getTagSource(tag, source);
			if (opts.isLower) source = source.toLowerCase();

			return {
				name,
				source,
				displayText,
				others,
			};
		},

		packUid (ent, tag) {
						const sourceDefault = Parser.getTagSource(tag);
			return [
				ent.name,
				(ent.source || "").toLowerCase() === sourceDefault.toLowerCase() ? "" : ent.source,
			].join("|").replace(/\|+$/, ""); 		},

		getNormalizedUid (uid, tag) {
			const {name, source} = DataUtil.generic.unpackUid(uid, tag, {isLower: true});
			return [name, source].join("|");
		},

		getUid (ent, {isMaintainCase = false} = {}) {
			const {name} = ent;
			const source = SourceUtil.getEntitySource(ent);
			if (!name || !source) throw new Error(`Entity did not have a name and source!`);
			const out = [name, source].join("|");
			if (isMaintainCase) return out;
			return out.toLowerCase();
		},

		async _pMergeCopy (impl, page, entryList, entry, options) {
			if (!entry._copy) return;

			const hashCurrent = UrlUtil.URL_TO_HASH_BUILDER[page](entry);
			const hash = UrlUtil.URL_TO_HASH_BUILDER[page](entry._copy);

			if (hashCurrent === hash) throw new Error(`${hashCurrent} _copy self-references! This is a bug!`);

			const it = (impl._mergeCache = impl._mergeCache || {})[hash] || DataUtil.generic._pMergeCopy_search(impl, page, entryList, entry, options);

			if (!it) {
				if (options.isErrorOnMissing) {
										if (!IS_DEPLOYED && !IS_VTT) throw new Error(`Could not find "${page}" entity "${entry._copy.name}" ("${entry._copy.source}") to copy in copier "${entry.name}" ("${entry.source}")`);
				}
				return;
			}

			if (DataUtil.dbg.isTrackCopied) it.dbg_isCopied = true;
						if (it._copy) await DataUtil.generic._pMergeCopy(impl, page, entryList, it, options);

						const traitData = entry._copy?._trait
				? (await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/bestiary/traits.json`))
				: null;
			return DataUtil.generic._applyCopy(impl, MiscUtil.copyFast(it), entry, traitData, options);
		},

		_pMergeCopy_search (impl, page, entryList, entry, options) {
			const entryHash = UrlUtil.URL_TO_HASH_BUILDER[page](entry._copy);
			return entryList.find(it => {
				const hash = UrlUtil.URL_TO_HASH_BUILDER[page](it);
				impl._mergeCache[hash] = it;
				return hash === entryHash;
			});
		},

		COPY_ENTRY_PROPS: [
			"action", "bonus", "reaction", "trait", "legendary", "mythic", "variant", "spellcasting",
			"actionHeader", "bonusHeader", "reactionHeader", "legendaryHeader", "mythicHeader",
		],
		_applyCopy (impl, copyFrom, copyTo, traitData, options = {}) {
			if (options.doKeepCopy) copyTo.__copy = MiscUtil.copyFast(copyFrom);

						function normaliseMods (obj) {
				Object.entries(obj._mod).forEach(([k, v]) => {
					if (!(v instanceof Array)) obj._mod[k] = [v];
				});
			}

			const msgPtFailed = `Failed to apply _copy to "${copyTo.name}" ("${copyTo.source}").`;

			const copyMeta = copyTo._copy || {};

			if (copyMeta._mod) normaliseMods(copyMeta);

						let racials = null;
			if (copyMeta._trait) {
				racials = traitData.trait.find(t => t.name.toLowerCase() === copyMeta._trait.name.toLowerCase() && t.source.toLowerCase() === copyMeta._trait.source.toLowerCase());
				if (!racials) throw new Error(`${msgPtFailed} Could not find traits to apply with name "${copyMeta._trait.name}" and source "${copyMeta._trait.source}"`);
				racials = MiscUtil.copyFast(racials);

				if (racials.apply._mod) {
					normaliseMods(racials.apply);

					if (copyMeta._mod) {
						Object.entries(racials.apply._mod).forEach(([k, v]) => {
							if (copyMeta._mod[k]) copyMeta._mod[k] = copyMeta._mod[k].concat(v);
							else copyMeta._mod[k] = v;
						});
					} else copyMeta._mod = racials.apply._mod;
				}

				delete copyMeta._trait;
			}

			const copyToRootProps = new Set(Object.keys(copyTo));

						Object.keys(copyFrom).forEach(k => {
				if (copyTo[k] === null) return delete copyTo[k];
				if (copyTo[k] == null) {
					if (DataUtil.generic._MERGE_REQUIRES_PRESERVE_BASE[k] || impl?._MERGE_REQUIRES_PRESERVE[k]) {
						if (copyTo._copy._preserve?.["*"] || copyTo._copy._preserve?.[k]) copyTo[k] = copyFrom[k];
					} else copyTo[k] = copyFrom[k];
				}
			});

						if (racials && racials.apply._root) {
				Object.entries(racials.apply._root)
					.filter(([k, v]) => !copyToRootProps.has(k)) 					.forEach(([k, v]) => copyTo[k] = v);
			}

						function doEnsureArray (obj, prop) {
				if (!(obj[prop] instanceof Array)) obj[prop] = [obj[prop]];
			}

			function getRegexFromReplaceModInfo (replace, flags) {
				return new RegExp(replace, `g${flags || ""}`);
			}

			function doReplaceStringHandler (re, withStr, str) {
								const split = Renderer.splitByTags(str);
				const len = split.length;
				for (let i = 0; i < len; ++i) {
					if (split[i].startsWith("{@")) continue;
					split[i] = split[i].replace(re, withStr);
				}
				return split.join("");
			}

			function doMod_appendStr (modInfo, prop) {
				if (copyTo[prop]) copyTo[prop] = `${copyTo[prop]}${modInfo.joiner || ""}${modInfo.str}`;
				else copyTo[prop] = modInfo.str;
			}

			function doMod_replaceName (modInfo, prop) {
				if (!copyTo[prop]) return;

				DataUtil.generic._walker_replaceTxt = DataUtil.generic._walker_replaceTxt || MiscUtil.getWalker();
				const re = getRegexFromReplaceModInfo(modInfo.replace, modInfo.flags);
				const handlers = {string: doReplaceStringHandler.bind(null, re, modInfo.with)};

				copyTo[prop].forEach(it => {
					if (it.name) it.name = DataUtil.generic._walker_replaceTxt.walk(it.name, handlers);
				});
			}

			function doMod_replaceTxt (modInfo, prop) {
				if (!copyTo[prop]) return;

				DataUtil.generic._walker_replaceTxt = DataUtil.generic._walker_replaceTxt || MiscUtil.getWalker();
				const re = getRegexFromReplaceModInfo(modInfo.replace, modInfo.flags);
				const handlers = {string: doReplaceStringHandler.bind(null, re, modInfo.with)};

				const props = modInfo.props || [null, "entries", "headerEntries", "footerEntries"];
				if (!props.length) return;

				if (props.includes(null)) {
										copyTo[prop] = copyTo[prop].map(it => {
						if (typeof it !== "string") return it;
						return DataUtil.generic._walker_replaceTxt.walk(it, handlers);
					});
				}

				copyTo[prop].forEach(it => {
					props.forEach(prop => {
						if (prop == null) return;
						if (it[prop]) it[prop] = DataUtil.generic._walker_replaceTxt.walk(it[prop], handlers);
					});
				});
			}

			function doMod_prependArr (modInfo, prop) {
				doEnsureArray(modInfo, "items");
				copyTo[prop] = copyTo[prop] ? modInfo.items.concat(copyTo[prop]) : modInfo.items;
			}

			function doMod_appendArr (modInfo, prop) {
				doEnsureArray(modInfo, "items");
				copyTo[prop] = copyTo[prop] ? copyTo[prop].concat(modInfo.items) : modInfo.items;
			}

			function doMod_appendIfNotExistsArr (modInfo, prop) {
				doEnsureArray(modInfo, "items");
				if (!copyTo[prop]) return copyTo[prop] = modInfo.items;
				copyTo[prop] = copyTo[prop].concat(modInfo.items.filter(it => !copyTo[prop].some(x => CollectionUtil.deepEquals(it, x))));
			}

			function doMod_replaceArr (modInfo, prop, isThrow = true) {
				doEnsureArray(modInfo, "items");

				if (!copyTo[prop]) {
					if (isThrow) throw new Error(`${msgPtFailed} Could not find "${prop}" array`);
					return false;
				}

				let ixOld;
				if (modInfo.replace.regex) {
					const re = new RegExp(modInfo.replace.regex, modInfo.replace.flags || "");
					ixOld = copyTo[prop].findIndex(it => it.name ? re.test(it.name) : typeof it === "string" ? re.test(it) : false);
				} else if (modInfo.replace.index != null) {
					ixOld = modInfo.replace.index;
				} else {
					ixOld = copyTo[prop].findIndex(it => it.name ? it.name === modInfo.replace : it === modInfo.replace);
				}

				if (~ixOld) {
					copyTo[prop].splice(ixOld, 1, ...modInfo.items);
					return true;
				} else if (isThrow) throw new Error(`${msgPtFailed} Could not find "${prop}" item with name "${modInfo.replace}" to replace`);
				return false;
			}

			function doMod_replaceOrAppendArr (modInfo, prop) {
				const didReplace = doMod_replaceArr(modInfo, prop, false);
				if (!didReplace) doMod_appendArr(modInfo, prop);
			}

			function doMod_insertArr (modInfo, prop) {
				doEnsureArray(modInfo, "items");
				if (!copyTo[prop]) throw new Error(`${msgPtFailed} Could not find "${prop}" array`);
				copyTo[prop].splice(~modInfo.index ? modInfo.index : copyTo[prop].length, 0, ...modInfo.items);
			}

			function doMod_removeArr (modInfo, prop) {
				if (modInfo.names) {
					doEnsureArray(modInfo, "names");
					modInfo.names.forEach(nameToRemove => {
						const ixOld = copyTo[prop].findIndex(it => it.name === nameToRemove);
						if (~ixOld) copyTo[prop].splice(ixOld, 1);
						else {
							if (!modInfo.force) throw new Error(`${msgPtFailed} Could not find "${prop}" item with name "${nameToRemove}" to remove`);
						}
					});
				} else if (modInfo.items) {
					doEnsureArray(modInfo, "items");
					modInfo.items.forEach(itemToRemove => {
						const ixOld = copyTo[prop].findIndex(it => it === itemToRemove);
						if (~ixOld) copyTo[prop].splice(ixOld, 1);
						else throw new Error(`${msgPtFailed} Could not find "${prop}" item "${itemToRemove}" to remove`);
					});
				} else throw new Error(`${msgPtFailed} One of "names" or "items" must be provided!`);
			}

			function doMod_calculateProp (modInfo, prop) {
				copyTo[prop] = copyTo[prop] || {};
				const toExec = modInfo.formula.replace(/<\$([^$]+)\$>/g, (...m) => {
					switch (m[1]) {
						case "prof_bonus": return Parser.crToPb(copyTo.cr);
						case "dex_mod": return Parser.getAbilityModNumber(copyTo.dex);
						default: throw new Error(`${msgPtFailed} Unknown variable "${m[1]}"`);
					}
				});
								copyTo[prop][modInfo.prop] = eval(toExec);
			}

			function doMod_scalarAddProp (modInfo, prop) {
				function applyTo (k) {
					const out = Number(copyTo[prop][k]) + modInfo.scalar;
					const isString = typeof copyTo[prop][k] === "string";
					copyTo[prop][k] = isString ? `${out >= 0 ? "+" : ""}${out}` : out;
				}

				if (!copyTo[prop]) return;
				if (modInfo.prop === "*") Object.keys(copyTo[prop]).forEach(k => applyTo(k));
				else applyTo(modInfo.prop);
			}

			function doMod_scalarMultProp (modInfo, prop) {
				function applyTo (k) {
					let out = Number(copyTo[prop][k]) * modInfo.scalar;
					if (modInfo.floor) out = Math.floor(out);
					const isString = typeof copyTo[prop][k] === "string";
					copyTo[prop][k] = isString ? `${out >= 0 ? "+" : ""}${out}` : out;
				}

				if (!copyTo[prop]) return;
				if (modInfo.prop === "*") Object.keys(copyTo[prop]).forEach(k => applyTo(k));
				else applyTo(modInfo.prop);
			}

			function doMod_addSenses (modInfo) {
				doEnsureArray(modInfo, "senses");
				copyTo.senses = copyTo.senses || [];
				modInfo.senses.forEach(sense => {
					let found = false;
					for (let i = 0; i < copyTo.senses.length; ++i) {
						const m = new RegExp(`${sense.type} (\\d+)`, "i").exec(copyTo.senses[i]);
						if (m) {
							found = true;
														if (Number(m[1]) < sense.range) {
								copyTo.senses[i] = `${sense.type} ${sense.range} ft.`;
							}
							break;
						}
					}

					if (!found) copyTo.senses.push(`${sense.type} ${sense.range} ft.`);
				});
			}

			function doMod_addSaves (modInfo) {
				copyTo.save = copyTo.save || {};
				Object.entries(modInfo.saves).forEach(([save, mode]) => {
										const total = mode * Parser.crToPb(copyTo.cr) + Parser.getAbilityModNumber(copyTo[save]);
					const asText = total >= 0 ? `+${total}` : total;
					if (copyTo.save && copyTo.save[save]) {
												if (Number(copyTo.save[save]) < total) copyTo.save[save] = asText;
					} else copyTo.save[save] = asText;
				});
			}

			function doMod_addSkills (modInfo) {
				copyTo.skill = copyTo.skill || {};
				Object.entries(modInfo.skills).forEach(([skill, mode]) => {
										const total = mode * Parser.crToPb(copyTo.cr) + Parser.getAbilityModNumber(copyTo[Parser.skillToAbilityAbv(skill)]);
					const asText = total >= 0 ? `+${total}` : total;
					if (copyTo.skill && copyTo.skill[skill]) {
												if (Number(copyTo.skill[skill]) < total) copyTo.skill[skill] = asText;
					} else copyTo.skill[skill] = asText;
				});
			}

			function doMod_addAllSaves (modInfo) {
				return doMod_addSaves({
					mode: "addSaves",
					saves: Object.keys(Parser.ATB_ABV_TO_FULL).mergeMap(it => ({[it]: modInfo.saves})),
				});
			}

			function doMod_addAllSkills (modInfo) {
				return doMod_addSkills({
					mode: "addSkills",
					skills: Object.keys(Parser.SKILL_TO_ATB_ABV).mergeMap(it => ({[it]: modInfo.skills})),
				});
			}

			function doMod_addSpells (modInfo) {
				if (!copyTo.spellcasting) throw new Error(`${msgPtFailed} Creature did not have a spellcasting property!`);

								const spellcasting = copyTo.spellcasting[0];

				if (modInfo.spells) {
					const spells = spellcasting.spells;

					Object.keys(modInfo.spells).forEach(k => {
						if (!spells[k]) spells[k] = modInfo.spells[k];
						else {
														const spellCategoryNu = modInfo.spells[k];
							const spellCategoryOld = spells[k];
							Object.keys(spellCategoryNu).forEach(kk => {
								if (!spellCategoryOld[kk]) spellCategoryOld[kk] = spellCategoryNu[kk];
								else {
									if (typeof spellCategoryOld[kk] === "object") {
										if (spellCategoryOld[kk] instanceof Array) spellCategoryOld[kk] = spellCategoryOld[kk].concat(spellCategoryNu[kk]).sort(SortUtil.ascSortLower);
										else throw new Error(`${msgPtFailed} Object at key ${kk} not an array!`);
									} else spellCategoryOld[kk] = spellCategoryNu[kk];
								}
							});
						}
					});
				}

				["constant", "will", "ritual"].forEach(prop => {
					if (!modInfo[prop]) return;
					modInfo[prop].forEach(sp => (spellcasting[prop] = spellcasting[prop] || []).push(sp));
				});

				["rest", "daily", "weekly", "yearly"].forEach(prop => {
					if (!modInfo[prop]) return;

					for (let i = 1; i <= 9; ++i) {
						const e = `${i}e`;

						spellcasting[prop] = spellcasting[prop] || {};

						if (modInfo[prop][i]) {
							modInfo[prop][i].forEach(sp => (spellcasting[prop][i] = spellcasting[prop][i] || []).push(sp));
						}

						if (modInfo[prop][e]) {
							modInfo[prop][e].forEach(sp => (spellcasting[prop][e] = spellcasting[prop][e] || []).push(sp));
						}
					}
				});
			}

			function doMod_replaceSpells (modInfo) {
				if (!copyTo.spellcasting) throw new Error(`${msgPtFailed} Creature did not have a spellcasting property!`);

								const spellcasting = copyTo.spellcasting[0];

				const handleReplace = (curSpells, replaceMeta, k) => {
					doEnsureArray(replaceMeta, "with");

					const ix = curSpells[k].indexOf(replaceMeta.replace);
					if (~ix) {
						curSpells[k].splice(ix, 1, ...replaceMeta.with);
						curSpells[k].sort(SortUtil.ascSortLower);
					} else throw new Error(`${msgPtFailed} Could not find spell "${replaceMeta.replace}" to replace`);
				};

				if (modInfo.spells) {
					const trait0 = spellcasting.spells;
					Object.keys(modInfo.spells).forEach(k => { 						if (trait0[k]) {
							const replaceMetas = modInfo.spells[k];
							const curSpells = trait0[k];
							replaceMetas.forEach(replaceMeta => handleReplace(curSpells, replaceMeta, "spells"));
						}
					});
				}

								if (modInfo.daily) {
					for (let i = 1; i <= 9; ++i) {
						const e = `${i}e`;

						if (modInfo.daily[i]) {
							modInfo.daily[i].forEach(replaceMeta => handleReplace(spellcasting.daily, replaceMeta, i));
						}

						if (modInfo.daily[e]) {
							modInfo.daily[e].forEach(replaceMeta => handleReplace(spellcasting.daily, replaceMeta, e));
						}
					}
				}
			}

			function doMod_removeSpells (modInfo) {
				if (!copyTo.spellcasting) throw new Error(`${msgPtFailed} Creature did not have a spellcasting property!`);

								const spellcasting = copyTo.spellcasting[0];

				if (modInfo.spells) {
					const spells = spellcasting.spells;

					Object.keys(modInfo.spells).forEach(k => {
						if (!spells[k]?.spells) return;

						spells[k].spells = spells[k].spells.filter(it => !modInfo.spells[k].includes(it));
					});
				}

				["constant", "will", "ritual"].forEach(prop => {
					if (!modInfo[prop]) return;
					spellcasting[prop].filter(it => !modInfo[prop].includes(it));
				});

				["rest", "daily", "weekly", "yearly"].forEach(prop => {
					if (!modInfo[prop]) return;

					for (let i = 1; i <= 9; ++i) {
						const e = `${i}e`;

						spellcasting[prop] = spellcasting[prop] || {};

						if (modInfo[prop][i]) {
							spellcasting[prop][i] = spellcasting[prop][i].filter(it => !modInfo[prop][i].includes(it));
						}

						if (modInfo[prop][e]) {
							spellcasting[prop][e] = spellcasting[prop][e].filter(it => !modInfo[prop][e].includes(it));
						}
					}
				});
			}

			function doMod_scalarAddHit (modInfo, prop) {
				if (!copyTo[prop]) return;
				copyTo[prop] = JSON.parse(JSON.stringify(copyTo[prop]).replace(/{@hit ([-+]?\d+)}/g, (m0, m1) => `{@hit ${Number(m1) + modInfo.scalar}}`));
			}

			function doMod_scalarAddDc (modInfo, prop) {
				if (!copyTo[prop]) return;
				copyTo[prop] = JSON.parse(JSON.stringify(copyTo[prop]).replace(/{@dc (\d+)(?:\|[^}]+)?}/g, (m0, m1) => `{@dc ${Number(m1) + modInfo.scalar}}`));
			}

			function doMod_maxSize (modInfo) {
				const sizes = [...copyTo.size].sort(SortUtil.ascSortSize);

				const ixsCur = sizes.map(it => Parser.SIZE_ABVS.indexOf(it));
				const ixMax = Parser.SIZE_ABVS.indexOf(modInfo.max);

				if (!~ixMax || ixsCur.some(ix => !~ix)) throw new Error(`${msgPtFailed} Unhandled size!`);

				const ixsNxt = ixsCur.filter(ix => ix <= ixMax);
				if (!ixsNxt.length) ixsNxt.push(ixMax);

				copyTo.size = ixsNxt.map(ix => Parser.SIZE_ABVS[ix]);
			}

			function doMod_scalarMultXp (modInfo) {
				function getOutput (input) {
					let out = input * modInfo.scalar;
					if (modInfo.floor) out = Math.floor(out);
					return out;
				}

				if (copyTo.cr.xp) copyTo.cr.xp = getOutput(copyTo.cr.xp);
				else {
					const curXp = Parser.crToXpNumber(copyTo.cr);
					if (!copyTo.cr.cr) copyTo.cr = {cr: copyTo.cr};
					copyTo.cr.xp = getOutput(curXp);
				}
			}

			function doMod (modInfos, ...properties) {
				function handleProp (prop) {
					modInfos.forEach(modInfo => {
						if (typeof modInfo === "string") {
							switch (modInfo) {
								case "remove": return delete copyTo[prop];
								default: throw new Error(`${msgPtFailed} Unhandled mode: ${modInfo}`);
							}
						} else {
							switch (modInfo.mode) {
								case "appendStr": return doMod_appendStr(modInfo, prop);
								case "replaceName": return doMod_replaceName(modInfo, prop);
								case "replaceTxt": return doMod_replaceTxt(modInfo, prop);
								case "prependArr": return doMod_prependArr(modInfo, prop);
								case "appendArr": return doMod_appendArr(modInfo, prop);
								case "replaceArr": return doMod_replaceArr(modInfo, prop);
								case "replaceOrAppendArr": return doMod_replaceOrAppendArr(modInfo, prop);
								case "appendIfNotExistsArr": return doMod_appendIfNotExistsArr(modInfo, prop);
								case "insertArr": return doMod_insertArr(modInfo, prop);
								case "removeArr": return doMod_removeArr(modInfo, prop);
								case "calculateProp": return doMod_calculateProp(modInfo, prop);
								case "scalarAddProp": return doMod_scalarAddProp(modInfo, prop);
								case "scalarMultProp": return doMod_scalarMultProp(modInfo, prop);
																case "addSenses": return doMod_addSenses(modInfo);
								case "addSaves": return doMod_addSaves(modInfo);
								case "addSkills": return doMod_addSkills(modInfo);
								case "addAllSaves": return doMod_addAllSaves(modInfo);
								case "addAllSkills": return doMod_addAllSkills(modInfo);
								case "addSpells": return doMod_addSpells(modInfo);
								case "replaceSpells": return doMod_replaceSpells(modInfo);
								case "removeSpells": return doMod_removeSpells(modInfo);
								case "scalarAddHit": return doMod_scalarAddHit(modInfo, prop);
								case "scalarAddDc": return doMod_scalarAddDc(modInfo, prop);
								case "maxSize": return doMod_maxSize(modInfo);
								case "scalarMultXp": return doMod_scalarMultXp(modInfo);
																default: throw new Error(`${msgPtFailed} Unhandled mode: ${modInfo.mode}`);
							}
						}
					});
				}

				properties.forEach(prop => handleProp(prop));
								if (!properties.length) handleProp();
			}

						if (copyMeta._mod) {
								Object.entries(copyMeta._mod).forEach(([k, v]) => {
					copyMeta._mod[k] = DataUtil.generic.variableResolver.resolve({obj: v, ent: copyTo});
				});

				Object.entries(copyMeta._mod).forEach(([prop, modInfos]) => {
					if (prop === "*") doMod(modInfos, ...DataUtil.generic.COPY_ENTRY_PROPS);
					else if (prop === "_") doMod(modInfos);
					else doMod(modInfos, prop);
				});
			}

						copyTo._isCopy = true;

						delete copyTo._copy;
		},

		variableResolver: class {
			static _getSize ({ent}) { return ent.size?.[0] || Parser.SZ_MEDIUM; }

			static _SIZE_TO_MULT = {
				[Parser.SZ_LARGE]: 2,
				[Parser.SZ_HUGE]: 3,
				[Parser.SZ_GARGANTUAN]: 4,
			};

			static _getSizeMult (size) { return this._SIZE_TO_MULT[size] ?? 1; }

			static _getCleanMathExpression (str) { return str.replace(/[^-+/*0-9.,]+/g, ""); }

			static resolve ({obj, ent, msgPtFailed = null}) {
				return JSON.parse(
					JSON.stringify(obj)
						.replace(/<\$(?<variable>[^$]+)\$>/g, (...m) => {
							const [mode, detail] = m.last().variable.split("__");

							switch (mode) {
								case "name": return ent.name;
								case "short_name":
								case "title_short_name": {
									return Renderer.monster.getShortName(ent, {isTitleCase: mode === "title_short_name"});
								}

								case "dc":
								case "spell_dc": {
									if (!Parser.ABIL_ABVS.includes(detail)) throw new Error(`${msgPtFailed ? `${msgPtFailed} ` : ""} Unknown ability score "${detail}"`);
									return 8 + Parser.getAbilityModNumber(Number(ent[detail])) + Parser.crToPb(ent.cr);
								}

								case "to_hit": {
									if (!Parser.ABIL_ABVS.includes(detail)) throw new Error(`${msgPtFailed ? `${msgPtFailed} ` : ""} Unknown ability score "${detail}"`);
									const total = Parser.crToPb(ent.cr) + Parser.getAbilityModNumber(Number(ent[detail]));
									return total >= 0 ? `+${total}` : total;
								}

								case "damage_mod": {
									if (!Parser.ABIL_ABVS.includes(detail)) throw new Error(`${msgPtFailed ? `${msgPtFailed} ` : ""} Unknown ability score "${detail}"`);
									const total = Parser.getAbilityModNumber(Number(ent[detail]));
									return total === 0 ? "" : total > 0 ? ` + ${total}` : ` - ${Math.abs(total)}`;
								}

								case "damage_avg": {
									const replaced = detail
										.replace(/\b(?<abil>str|dex|con|int|wis|cha)\b/gi, (...m) => Parser.getAbilityModNumber(Number(ent[m.last().abil])))
										.replace(/\bsize_mult\b/g, () => this._getSizeMult(this._getSize({ent})));

																		return Math.floor(eval(this._getCleanMathExpression(replaced)));
								}

								case "size_mult": {
									const mult = this._getSizeMult(this._getSize({ent}));

									if (!detail) return mult;

																		return Math.floor(eval(`${mult} * ${this._getCleanMathExpression(detail)}`));
								}

								default: return m[0];
							}
						}),
				);
			}
		},

		getVersions (parent) {
			if (!parent?._versions?.length) return [];

			return parent._versions
				.map(ver => {
					if (ver._template && ver._implementations?.length) return DataUtil.generic._getVersions_template({ver});
					return DataUtil.generic._getVersions_basic({ver});
				})
				.flat()
				.map(ver => DataUtil.generic._getVersion({parentEntity: parent, version: ver}));
		},

		_getVersions_template ({ver}) {
			return ver._implementations
				.map(impl => {
					let cpyTemplate = MiscUtil.copyFast(ver._template);
					const cpyImpl = MiscUtil.copyFast(impl);

					DataUtil.generic._getVersions_mutExpandCopy({ent: cpyTemplate});

					if (cpyImpl._variables) {
						cpyTemplate = MiscUtil.getWalker()
							.walk(
								cpyTemplate,
								{
									string: str => str.replace(/{{([^}]+)}}/g, (...m) => cpyImpl._variables[m[1]]),
								},
							);
						delete cpyImpl._variables;
					}

					Object.assign(cpyTemplate, cpyImpl);

					return cpyTemplate;
				});
		},

		_getVersions_basic ({ver}) {
			const cpyVer = MiscUtil.copyFast(ver);
			DataUtil.generic._getVersions_mutExpandCopy({ent: cpyVer});
			return cpyVer;
		},

		_getVersions_mutExpandCopy ({ent}) {
						ent._copy = {
				_mod: ent._mod,
				_preserve: {"*": true},
			};
			delete ent._mod;
		},

		_getVersion ({parentEntity, version}) {
			const additionalData = {
				_versionBase_isVersion: true,
				_versionBase_name: parentEntity.name,
				_versionBase_source: parentEntity.source,
				_versionBase_hasToken: parentEntity.hasToken,
				_versionBase_hasFluff: parentEntity.hasFluff,
				_versionBase_hasFluffImages: parentEntity.hasFluffImages,
			};
			const cpyParentEntity = MiscUtil.copyFast(parentEntity);

			delete cpyParentEntity._versions;
			delete cpyParentEntity.hasToken;
			delete cpyParentEntity.hasFluff;
			delete cpyParentEntity.hasFluffImages;

			DataUtil.generic._applyCopy(
				null,
				cpyParentEntity,
				version,
				null,
			);
			Object.assign(version, additionalData);
			return version;
		},
	},

	proxy: {
		getVersions (prop, ent) {
			if (DataUtil[prop]?.getVersions) return DataUtil[prop]?.getVersions(ent);
			return DataUtil.generic.getVersions(ent);
		},

		unpackUid (prop, uid, tag, opts) {
			if (DataUtil[prop]?.unpackUid) return DataUtil[prop]?.unpackUid(uid, tag, opts);
			return DataUtil.generic.unpackUid(uid, tag, opts);
		},

		getNormalizedUid (prop, uid, tag, opts) {
			if (DataUtil[prop]?.getNormalizedUid) return DataUtil[prop].getNormalizedUid(uid, tag, opts);
			return DataUtil.generic.getNormalizedUid(uid, tag, opts);
		},

		getUid (prop, ent, opts) {
			if (DataUtil[prop]?.getUid) return DataUtil[prop].getUid(ent, opts);
			return DataUtil.generic.getUid(ent, opts);
		},
	},

	monster: class extends _DataUtilPropConfigMultiSource {
		static _MERGE_REQUIRES_PRESERVE = {
			legendaryGroup: true,
			environment: true,
			soundClip: true,
			altArt: true,
			variant: true,
			dragonCastingColor: true,
			familiar: true,
		};

		static _PAGE = UrlUtil.PG_BESTIARY;

		static _DIR = "bestiary";
		static _PROP = "monster";

		static async loadJSON () {
			await DataUtil.monster.pPreloadMeta();
			return super.loadJSON();
		}

		static getVersions (mon) {
			const additionalVersionData = DataUtil.monster._getAdditionalVersionsData(mon);
			if (additionalVersionData.length) {
				mon = MiscUtil.copyFast(mon);
				(mon._versions = mon._versions || []).push(...additionalVersionData);
			}
			return DataUtil.generic.getVersions(mon);
		}

		static _getAdditionalVersionsData (mon) {
			if (!mon.variant?.length) return [];

			return mon.variant
				.filter(it => it._version)
				.map(it => {
					const toAdd = {
						name: it._version.name || it.name,
						source: it._version.source || it.source || mon.source,
						variant: null,
					};

					if (it._version.addAs) {
						const cpy = MiscUtil.copyFast(it);
						delete cpy._version;
						delete cpy.type;
						delete cpy.source;
						delete cpy.page;

						toAdd._mod = {
							[it._version.addAs]: {
								mode: "appendArr",
								items: cpy,
							},
						};

						return toAdd;
					}

					if (it._version.addHeadersAs) {
						const cpy = MiscUtil.copyFast(it);
						cpy.entries = cpy.entries.filter(it => it.name && it.entries);
						cpy.entries.forEach(cpyEnt => {
							delete cpyEnt.type;
							delete cpyEnt.source;
						});

						toAdd._mod = {
							[it._version.addHeadersAs]: {
								mode: "appendArr",
								items: cpy.entries,
							},
						};

						return toAdd;
					}
				})
				.filter(Boolean);
		}

		static async pPreloadMeta () {
			DataUtil.monster._pLoadMeta = DataUtil.monster._pLoadMeta || ((async () => {
				const legendaryGroups = await DataUtil.legendaryGroup.pLoadAll();
				DataUtil.monster.populateMetaReference({legendaryGroup: legendaryGroups});
			})());
			await DataUtil.monster._pLoadMeta;
		}

		static _pLoadMeta = null;
		static metaGroupMap = {};
		static getMetaGroup (mon) {
			if (!mon.legendaryGroup || !mon.legendaryGroup.source || !mon.legendaryGroup.name) return null;
			return (DataUtil.monster.metaGroupMap[mon.legendaryGroup.source] || {})[mon.legendaryGroup.name];
		}
		static populateMetaReference (data) {
			(data.legendaryGroup || []).forEach(it => {
				(DataUtil.monster.metaGroupMap[it.source] =
					DataUtil.monster.metaGroupMap[it.source] || {})[it.name] = it;
			});
		}
	},

	monsterFluff: class extends _DataUtilPropConfigMultiSource {
		static _PAGE = UrlUtil.PG_BESTIARY;
		static _DIR = "bestiary";
		static _PROP = "monsterFluff";
	},

	spell: class extends _DataUtilPropConfigMultiSource {
		static _PAGE = UrlUtil.PG_SPELLS;
		static _DIR = "spells";
		static _PROP = "spell";
		static _IS_MUT_ENTITIES = true;

		static _SPELL_SOURCE_LOOKUP = null;

				static setSpellSourceLookup (lookup, {isExternalApplication = false} = {}) {
			if (!isExternalApplication) throw new Error("Should not be calling this!");
			this._SPELL_SOURCE_LOOKUP = MiscUtil.copyFast(lookup);
		}

		static mutEntity (sp, {isExternalApplication = false} = {}) {
			if (!isExternalApplication) throw new Error("Should not be calling this!");
			return this._mutEntity(sp);
		}

		static unmutEntity (sp, {isExternalApplication = false} = {}) {
			if (!isExternalApplication) throw new Error("Should not be calling this!");
			delete sp.classes;
			delete sp.races;
			delete sp.optionalfeatures;
			delete sp.backgrounds;
			delete sp.feats;
			delete sp.charoptions;
			delete sp.rewards;
			delete sp._isMutEntity;
		}
		
		static async _pInitPreData_ () {
			this._SPELL_SOURCE_LOOKUP = await DataUtil.loadRawJSON(`${Renderer.get().baseUrl}data/generated/gendata-spell-source-lookup.json`);
		}

		static _mutEntity (sp) {
			if (sp._isMutEntity) return sp;

			const spSources = this._SPELL_SOURCE_LOOKUP[sp.source.toLowerCase()]?.[sp.name.toLowerCase()];
			if (!spSources) return;

			this._mutSpell_class({sp, spSources, propSources: "class", propClasses: "fromClassList"});
			this._mutSpell_class({sp, spSources, propSources: "classVariant", propClasses: "fromClassListVariant"});
			this._mutSpell_subclass({sp, spSources});
			this._mutSpell_race({sp, spSources});
			this._mutSpell_optionalfeature({sp, spSources});
			this._mutSpell_background({sp, spSources});
			this._mutSpell_feat({sp, spSources});
			this._mutSpell_charoption({sp, spSources});
			this._mutSpell_reward({sp, spSources});

			sp._isMutEntity = true;

			return sp;
		}

		static _mutSpell_class ({sp, spSources, propSources, propClasses}) {
			if (!spSources[propSources]) return;

			Object.entries(spSources[propSources])
				.forEach(([source, nameTo]) => {
					const tgt = MiscUtil.getOrSet(sp, "classes", propClasses, []);

					Object.entries(nameTo)
						.forEach(([name, val]) => {
							if (tgt.some(it => it.name === nameTo && it.source === source)) return;

							const toAdd = {name, source};
							if (val === true) return tgt.push(toAdd);

							if (val.definedInSource) {
								toAdd.definedInSource = val.definedInSource;
								tgt.push(toAdd);
								return;
							}

							if (val.definedInSources) {
								val.definedInSources
									.forEach(definedInSource => {
										const cpyToAdd = MiscUtil.copyFast(toAdd);

										if (definedInSource == null) {
											return tgt.push(cpyToAdd);
										}

										cpyToAdd.definedInSource = definedInSource;
										tgt.push(cpyToAdd);
									});

								return;
							}

							throw new Error("Unimplemented!");
						});
				});
		}

		static _mutSpell_subclass ({sp, spSources}) {
			if (!spSources.subclass) return;

			Object.entries(spSources.subclass)
				.forEach(([classSource, classNameTo]) => {
					Object.entries(classNameTo)
						.forEach(([className, sourceTo]) => {
							Object.entries(sourceTo)
								.forEach(([source, nameTo]) => {
									const tgt = MiscUtil.getOrSet(sp, "classes", "fromSubclass", []);

									Object.entries(nameTo)
										.forEach(([name, val]) => {
											if (val === true) throw new Error("Unimplemented!");

											if (tgt.some(it => it.class.name === className && it.class.source === classSource && it.subclass.name === name && it.subclass.source === source && ((it.subclass.subSubclass == null && val.subSubclasses == null) || val.subSubclasses.includes(it.subclass.subSubclass)))) return;

											const toAdd = {
												class: {
													name: className,
													source: classSource,
												},
												subclass: {
													name: val.name,
													shortName: name,
													source,
												},
											};

											if (!val.subSubclasses?.length) return tgt.push(toAdd);

											val.subSubclasses
												.forEach(subSubclass => {
													const cpyToAdd = MiscUtil.copyFast(toAdd);
													cpyToAdd.subclass.subSubclass = subSubclass;
													tgt.push(cpyToAdd);
												});
										});
								});
						});
				});
		}

		static _mutSpell_race ({sp, spSources}) {
			this._mutSpell_generic({sp, spSources, propSources: "race", propSpell: "races"});
		}

		static _mutSpell_optionalfeature ({sp, spSources}) {
			this._mutSpell_generic({sp, spSources, propSources: "optionalfeature", propSpell: "optionalfeatures"});
		}

		static _mutSpell_background ({sp, spSources}) {
			this._mutSpell_generic({sp, spSources, propSources: "background", propSpell: "backgrounds"});
		}

		static _mutSpell_feat ({sp, spSources}) {
			this._mutSpell_generic({sp, spSources, propSources: "feat", propSpell: "feats"});
		}

		static _mutSpell_charoption ({sp, spSources}) {
			this._mutSpell_generic({sp, spSources, propSources: "charoption", propSpell: "charoptions"});
		}

		static _mutSpell_reward ({sp, spSources}) {
			this._mutSpell_generic({sp, spSources, propSources: "reward", propSpell: "rewards"});
		}

		static _mutSpell_generic ({sp, spSources, propSources, propSpell}) {
			if (!spSources[propSources]) return;

			Object.entries(spSources[propSources])
				.forEach(([source, nameTo]) => {
					const tgt = MiscUtil.getOrSet(sp, propSpell, []);

					Object.entries(nameTo)
						.forEach(([name, val]) => {
							if (tgt.some(it => it.name === nameTo && it.source === source)) return;

							const toAdd = {name, source};
							if (val === true) return tgt.push(toAdd);

							Object.assign(toAdd, {...val});
							tgt.push(toAdd);
						});
				});
		}
	},

	spellFluff: class extends _DataUtilPropConfigMultiSource {
		static _PAGE = UrlUtil.PG_SPELLS;
		static _DIR = "spells";
		static _PROP = "spellFluff";
	},

	background: class extends _DataUtilPropConfigSingleSource {
		static _PAGE = UrlUtil.PG_BACKGROUNDS;
		static _FILENAME = "backgrounds.json";
	},

	backgroundFluff: class extends _DataUtilPropConfigSingleSource {
		static _PAGE = UrlUtil.PG_BACKGROUNDS;
		static _FILENAME = "fluff-backgrounds.json";
	},

	charoption: class extends _DataUtilPropConfigSingleSource {
		static _PAGE = UrlUtil.PG_CHAR_CREATION_OPTIONS;
		static _FILENAME = "charcreationoptions.json";
	},

	charoptionFluff: class extends _DataUtilPropConfigSingleSource {
		static _PAGE = UrlUtil.PG_CHAR_CREATION_OPTIONS;
		static _FILENAME = "fluff-charcreationoptions.json";
	},

	condition: class extends _DataUtilPropConfigSingleSource {
		static _PAGE = UrlUtil.PG_CONDITIONS_DISEASES;
		static _FILENAME = "conditionsdiseases.json";
	},

	conditionFluff: class extends _DataUtilPropConfigSingleSource {
		static _PAGE = UrlUtil.PG_CONDITIONS_DISEASES;
		static _FILENAME = "fluff-conditionsdiseases.json";
	},

	disease: class extends _DataUtilPropConfigSingleSource {
		static _PAGE = UrlUtil.PG_CONDITIONS_DISEASES;
		static _FILENAME = "conditionsdiseases.json";
	},

	feat: class extends _DataUtilPropConfigSingleSource {
		static _PAGE = UrlUtil.PG_FEATS;
		static _FILENAME = "feats.json";
	},

	featFluff: class extends _DataUtilPropConfigSingleSource {
		static _PAGE = UrlUtil.PG_FEATS;
		static _FILENAME = "fluff-feats.json";
	},

	item: class extends _DataUtilPropConfigCustom {
		static _MERGE_REQUIRES_PRESERVE = {
			lootTables: true,
			tier: true,
		};
		static _PAGE = UrlUtil.PG_ITEMS;

		static async loadRawJSON () {
			if (DataUtil.item._loadedRawJson) return DataUtil.item._loadedRawJson;

			DataUtil.item._pLoadingRawJson = (async () => {
				const urlItems = `${Renderer.get().baseUrl}data/items.json`;
				const urlItemsBase = `${Renderer.get().baseUrl}data/items-base.json`;
				const urlVariants = `${Renderer.get().baseUrl}data/magicvariants.json`;

				const [dataItems, dataItemsBase, dataVariants] = await Promise.all([
					DataUtil.loadJSON(urlItems),
					DataUtil.loadJSON(urlItemsBase),
					DataUtil.loadJSON(urlVariants),
				]);

				DataUtil.item._loadedRawJson = {
					item: MiscUtil.copyFast(dataItems.item),
					itemGroup: MiscUtil.copyFast(dataItems.itemGroup),
					magicvariant: MiscUtil.copyFast(dataVariants.magicvariant),
					baseitem: MiscUtil.copyFast(dataItemsBase.baseitem),
				};
			})();
			await DataUtil.item._pLoadingRawJson;

			return DataUtil.item._loadedRawJson;
		}

		static async loadJSON () {
			return {item: await Renderer.item.pBuildList()};
		}

		static async loadPrerelease () {
			return {item: await Renderer.item.pGetItemsFromPrerelease()};
		}

		static async loadBrew () {
			return {item: await Renderer.item.pGetItemsFromBrew()};
		}
	},

	itemGroup: class extends _DataUtilPropConfig {
		static _MERGE_REQUIRES_PRESERVE = {
			lootTables: true,
			tier: true,
		};
		static _PAGE = UrlUtil.PG_ITEMS;

		static async pMergeCopy (...args) { return DataUtil.item.pMergeCopy(...args); }
		static async loadRawJSON (...args) { return DataUtil.item.loadRawJSON(...args); }
	},

	itemFluff: class extends _DataUtilPropConfigSingleSource {
		static _PAGE = UrlUtil.PG_ITEMS;
		static _FILENAME = "fluff-items.json";
	},

	language: class extends _DataUtilPropConfigSingleSource {
		static _PAGE = UrlUtil.PG_LANGUAGES;
		static _FILENAME = "languages.json";

		static async loadJSON () {
			const rawData = await super.loadJSON();

						const scriptLookup = {};
			(rawData.languageScript || []).forEach(script => scriptLookup[script.name] = script);

			const out = {language: MiscUtil.copyFast(rawData.language)};
			out.language.forEach(lang => {
				if (!lang.script || lang.fonts === false) return;

				const script = scriptLookup[lang.script];
				if (!script) return;

				lang._fonts = [...script.fonts];
			});
			
			return out;
		}
	},

	languageFluff: class extends _DataUtilPropConfigSingleSource {
		static _PAGE = UrlUtil.PG_LANGUAGES;
		static _FILENAME = "fluff-languages.json";
	},

	object: class extends _DataUtilPropConfigSingleSource {
		static _PAGE = UrlUtil.PG_OBJECTS;
		static _FILENAME = "objects.json";
	},

	objectFluff: class extends _DataUtilPropConfigSingleSource {
		static _PAGE = UrlUtil.PG_OBJECTS;
		static _FILENAME = "fluff-objects.json";
	},

	race: class extends _DataUtilPropConfigSingleSource {
		static _PAGE = UrlUtil.PG_RACES;
		static _FILENAME = "races.json";

		static _loadCache = {};
		static _pIsLoadings = {};
		static async loadJSON ({isAddBaseRaces = false} = {}) {
			if (!DataUtil.race._pIsLoadings[isAddBaseRaces]) {
				DataUtil.race._pIsLoadings[isAddBaseRaces] = (async () => {
					DataUtil.race._loadCache[isAddBaseRaces] = DataUtil.race.getPostProcessedSiteJson(
						await this.loadRawJSON(),
						{isAddBaseRaces},
					);
				})();
			}
			await DataUtil.race._pIsLoadings[isAddBaseRaces];
			return DataUtil.race._loadCache[isAddBaseRaces];
		}

		static getPostProcessedSiteJson (rawRaceData, {isAddBaseRaces = false} = {}) {
			rawRaceData = MiscUtil.copyFast(rawRaceData);
			(rawRaceData.subrace || []).forEach(sr => {
				const r = rawRaceData.race.find(it => it.name === sr.raceName && it.source === sr.raceSource);
				if (!r) return JqueryUtil.doToast({content: `Failed to find race "${sr.raceName}" (${sr.raceSource})`, type: "danger"});
				const cpySr = MiscUtil.copyFast(sr);
				delete cpySr.raceName;
				delete cpySr.raceSource;
				(r.subraces = r.subraces || []).push(sr);
			});
			delete rawRaceData.subrace;
			const raceData = Renderer.race.mergeSubraces(rawRaceData.race, {isAddBaseRaces});
			raceData.forEach(it => it.__prop = "race");
			return {race: raceData};
		}

		static async loadPrerelease ({isAddBaseRaces = true} = {}) {
			return DataUtil.race._loadPrereleaseBrew({isAddBaseRaces, brewUtil: typeof PrereleaseUtil !== "undefined" ? PrereleaseUtil : null});
		}

		static async loadBrew ({isAddBaseRaces = true} = {}) {
			return DataUtil.race._loadPrereleaseBrew({isAddBaseRaces, brewUtil: typeof BrewUtil2 !== "undefined" ? BrewUtil2 : null});
		}

		static async _loadPrereleaseBrew ({isAddBaseRaces = true, brewUtil} = {}) {
			if (!brewUtil) return {};

			const rawSite = await DataUtil.race.loadRawJSON();
			const brew = await brewUtil.pGetBrewProcessed();
			return DataUtil.race.getPostProcessedPrereleaseBrewJson(rawSite, brew, {isAddBaseRaces});
		}

		static getPostProcessedPrereleaseBrewJson (rawSite, brew, {isAddBaseRaces = false} = {}) {
			rawSite = MiscUtil.copyFast(rawSite);
			brew = MiscUtil.copyFast(brew);

			const rawSiteUsed = [];
			(brew.subrace || []).forEach(sr => {
				const rSite = rawSite.race.find(it => it.name === sr.raceName && it.source === sr.raceSource);
				const rBrew = (brew.race || []).find(it => it.name === sr.raceName && it.source === sr.raceSource);
				if (!rSite && !rBrew) return JqueryUtil.doToast({content: `Failed to find race "${sr.raceName}" (${sr.raceSource})`, type: "danger"});
				const rTgt = rSite || rBrew;
				const cpySr = MiscUtil.copyFast(sr);
				delete cpySr.raceName;
				delete cpySr.raceSource;
				(rTgt.subraces = rTgt.subraces || []).push(sr);
				if (rSite && !rawSiteUsed.includes(rSite)) rawSiteUsed.push(rSite);
			});
			delete brew.subrace;

			const raceDataBrew = Renderer.race.mergeSubraces(brew.race || [], {isAddBaseRaces});
						const raceDataSite = Renderer.race.mergeSubraces(rawSiteUsed, {isAddBaseRaces: false});

			const out = [...raceDataBrew, ...raceDataSite];
			out.forEach(it => it.__prop = "race");
			return {race: out};
		}
	},

	raceFluff: class extends _DataUtilPropConfigSingleSource {
		static _PAGE = UrlUtil.PG_RACES;
		static _FILENAME = "fluff-races.json";

		static _getApplyUncommonMonstrous (data) {
			data = MiscUtil.copyFast(data);
			data.raceFluff
				.forEach(raceFluff => {
					if (raceFluff.uncommon) {
						raceFluff.entries = raceFluff.entries || [];
						raceFluff.entries.push(MiscUtil.copyFast(data.raceFluffMeta.uncommon));
						delete raceFluff.uncommon;
					}

					if (raceFluff.monstrous) {
						raceFluff.entries = raceFluff.entries || [];
						raceFluff.entries.push(MiscUtil.copyFast(data.raceFluffMeta.monstrous));
						delete raceFluff.monstrous;
					}
				});
			return data;
		}

		static async loadJSON () {
			const data = await super.loadJSON();
			return this._getApplyUncommonMonstrous(data);
		}

		static async loadUnmergedJSON () {
			const data = await super.loadUnmergedJSON();
			return this._getApplyUncommonMonstrous(data);
		}
	},

	recipe: class extends _DataUtilPropConfigSingleSource {
		static _PAGE = UrlUtil.PG_RECIPES;
		static _FILENAME = "recipes.json";

		static async loadJSON () {
			const out = [];

			const rawData = await super.loadJSON();

			DataUtil.recipe.postProcessData(rawData);

						for (const r of rawData.recipe) {
				const fluff = await Renderer.utils.pGetFluff({
					entity: r,
					fnGetFluffData: DataUtil.recipeFluff.loadJSON.bind(DataUtil.recipeFluff),
					fluffProp: "recipeFluff",
				});

				if (!fluff) {
					out.push(r);
					continue;
				}

				const cpyR = MiscUtil.copyFast(r);
				cpyR.fluff = MiscUtil.copyFast(fluff);
				delete cpyR.fluff.name;
				delete cpyR.fluff.source;
				out.push(cpyR);
			}
			
			return {recipe: out};
		}

		static postProcessData (data) {
			if (!data.recipe || !data.recipe.length) return;

						data.recipe.forEach(r => Renderer.recipe.populateFullIngredients(r));
		}

		static async loadPrerelease () {
			return this._loadPrereleaseBrew({brewUtil: typeof PrereleaseUtil !== "undefined" ? PrereleaseUtil : null});
		}

		static async loadBrew () {
			return this._loadPrereleaseBrew({brewUtil: typeof BrewUtil2 !== "undefined" ? BrewUtil2 : null});
		}

		static async _loadPrereleaseBrew ({brewUtil}) {
			if (!brewUtil) return {};

			const brew = await brewUtil.pGetBrewProcessed();
			DataUtil.recipe.postProcessData(brew);
			return brew;
		}
	},

	recipeFluff: class extends _DataUtilPropConfigSingleSource {
		static _PAGE = UrlUtil.PG_RECIPES;
		static _FILENAME = "fluff-recipes.json";
	},

	vehicle: class extends _DataUtilPropConfigSingleSource {
		static _PAGE = UrlUtil.PG_VEHICLES;
		static _FILENAME = "vehicles.json";
	},

	vehicleFluff: class extends _DataUtilPropConfigSingleSource {
		static _PAGE = UrlUtil.PG_VEHICLES;
		static _FILENAME = "fluff-vehicles.json";
	},

	optionalfeature: class extends _DataUtilPropConfigSingleSource {
		static _PAGE = UrlUtil.PG_OPT_FEATURES;
		static _FILENAME = "optionalfeatures.json";
	},

	class: class clazz extends _DataUtilPropConfigCustom {
		static _PAGE = UrlUtil.PG_CLASSES;

		static _pLoadJson = null;
		static _pLoadRawJson = null;

		static loadJSON () {
			return DataUtil.class._pLoadJson = DataUtil.class._pLoadJson || (async () => {
				return {
					class: await DataLoader.pCacheAndGetAllSite("class"),
					subclass: await DataLoader.pCacheAndGetAllSite("subclass"),
				};
			})();
		}

		static loadRawJSON () {
			return DataUtil.class._pLoadRawJson = DataUtil.class._pLoadRawJson || (async () => {
				const index = await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/class/index.json`);
				const allData = await Promise.all(Object.values(index).map(it => DataUtil.loadJSON(`${Renderer.get().baseUrl}data/class/${it}`)));

				return {
					class: MiscUtil.copyFast(allData.map(it => it.class || []).flat()),
					subclass: MiscUtil.copyFast(allData.map(it => it.subclass || []).flat()),
					classFeature: allData.map(it => it.classFeature || []).flat(),
					subclassFeature: allData.map(it => it.subclassFeature || []).flat(),
				};
			})();
		}

		static async loadPrerelease () {
			return {
				class: await DataLoader.pCacheAndGetAllPrerelease("class"),
				subclass: await DataLoader.pCacheAndGetAllPrerelease("subclass"),
			};
		}

		static async loadBrew () {
			return {
				class: await DataLoader.pCacheAndGetAllBrew("class"),
				subclass: await DataLoader.pCacheAndGetAllBrew("subclass"),
			};
		}

		static packUidSubclass (it) {
						const sourceDefault = Parser.getTagSource("subclass");
			return [
				it.name,
				it.className,
				(it.classSource || "").toLowerCase() === sourceDefault.toLowerCase() ? "" : it.classSource,
				(it.source || "").toLowerCase() === sourceDefault.toLowerCase() ? "" : it.source,
			].join("|").replace(/\|+$/, ""); 		}

				static unpackUidClassFeature (uid, opts) {
			opts = opts || {};
			if (opts.isLower) uid = uid.toLowerCase();
			let [name, className, classSource, level, source, displayText] = uid.split("|").map(it => it.trim());
			classSource = classSource || (opts.isLower ? Parser.SRC_PHB.toLowerCase() : Parser.SRC_PHB);
			source = source || classSource;
			level = Number(level);
			return {
				name,
				className,
				classSource,
				level,
				source,
				displayText,
			};
		}

		static isValidClassFeatureUid (uid) {
			const {name, className, level} = DataUtil.class.unpackUidClassFeature(uid);
			return !(!name || !className || isNaN(level));
		}

		static packUidClassFeature (f) {
						return [
				f.name,
				f.className,
				f.classSource === Parser.SRC_PHB ? "" : f.classSource, 				f.level,
				f.source === f.classSource ? "" : f.source, 			].join("|").replace(/\|+$/, ""); 		}

				static unpackUidSubclassFeature (uid, opts) {
			opts = opts || {};
			if (opts.isLower) uid = uid.toLowerCase();
			let [name, className, classSource, subclassShortName, subclassSource, level, source, displayText] = uid.split("|").map(it => it.trim());
			classSource = classSource || (opts.isLower ? Parser.SRC_PHB.toLowerCase() : Parser.SRC_PHB);
			subclassSource = subclassSource || (opts.isLower ? Parser.SRC_PHB.toLowerCase() : Parser.SRC_PHB);
			source = source || subclassSource;
			level = Number(level);
			return {
				name,
				className,
				classSource,
				subclassShortName,
				subclassSource,
				level,
				source,
				displayText,
			};
		}

		static isValidSubclassFeatureUid (uid) {
			const {name, className, subclassShortName, level} = DataUtil.class.unpackUidSubclassFeature(uid);
			return !(!name || !className || !subclassShortName || isNaN(level));
		}

		static packUidSubclassFeature (f) {
						return [
				f.name,
				f.className,
				f.classSource === Parser.SRC_PHB ? "" : f.classSource, 				f.subclassShortName,
				f.subclassSource === Parser.SRC_PHB ? "" : f.subclassSource, 				f.level,
				f.source === f.subclassSource ? "" : f.source, 			].join("|").replace(/\|+$/, ""); 		}

				static _CACHE_SUBCLASS_LOOKUP_PROMISE = null;
		static _CACHE_SUBCLASS_LOOKUP = null;
		static async pGetSubclassLookup () {
			DataUtil.class._CACHE_SUBCLASS_LOOKUP_PROMISE = DataUtil.class._CACHE_SUBCLASS_LOOKUP_PROMISE || (async () => {
				const subclassLookup = {};
				Object.assign(subclassLookup, await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/generated/gendata-subclass-lookup.json`));
				DataUtil.class._CACHE_SUBCLASS_LOOKUP = subclassLookup;
			})();
			await DataUtil.class._CACHE_SUBCLASS_LOOKUP_PROMISE;
			return DataUtil.class._CACHE_SUBCLASS_LOOKUP;
		}
			},

	subclass: class extends _DataUtilPropConfig {
		static _PAGE = "subclass";
	},

	deity: class extends _DataUtilPropConfigSingleSource {
		static _PAGE = UrlUtil.PG_DEITIES;
		static _FILENAME = "deities.json";

		static doPostLoad (data) {
			const PRINT_ORDER = [
				Parser.SRC_PHB,
				Parser.SRC_DMG,
				Parser.SRC_SCAG,
				Parser.SRC_VGM,
				Parser.SRC_MTF,
				Parser.SRC_ERLW,
			];

			const inSource = {};
			PRINT_ORDER.forEach(src => {
				inSource[src] = {};
				data.deity.filter(it => it.source === src).forEach(it => inSource[src][it.reprintAlias || it.name] = it); 			});

			const laterPrinting = [PRINT_ORDER.last()];
			[...PRINT_ORDER].reverse().slice(1).forEach(src => {
				laterPrinting.forEach(laterSrc => {
					Object.keys(inSource[src]).forEach(name => {
						const newer = inSource[laterSrc][name];
						if (newer) {
							const old = inSource[src][name];
							old.reprinted = true;
							if (!newer._isEnhanced) {
								newer.previousVersions = newer.previousVersions || [];
								newer.previousVersions.push(old);
							}
						}
					});
				});

				laterPrinting.push(src);
			});
			data.deity.forEach(g => g._isEnhanced = true);

			return data;
		}

		static async loadJSON () {
			const data = await super.loadJSON();
			DataUtil.deity.doPostLoad(data);
			return data;
		}

		static getUid (ent, opts) {
			return this.packUidDeity(ent, opts);
		}

		static getNormalizedUid (uid, tag) {
			const {name, pantheon, source} = this.unpackUidDeity(uid, tag, {isLower: true});
			return [name, pantheon, source].join("|");
		}

		static unpackUidDeity (uid, opts) {
			opts = opts || {};
			if (opts.isLower) uid = uid.toLowerCase();
			let [name, pantheon, source, displayText, ...others] = uid.split("|").map(it => it.trim());

			pantheon = pantheon || "forgotten realms";
			if (opts.isLower) pantheon = pantheon.toLowerCase();

			source = source || Parser.getTagSource("deity", source);
			if (opts.isLower) source = source.toLowerCase();

			return {
				name,
				pantheon,
				source,
				displayText,
				others,
			};
		}

		static packUidDeity (it) {
						const sourceDefault = Parser.getTagSource("deity");
			return [
				it.name,
				(it.pantheon || "").toLowerCase() === "forgotten realms" ? "" : it.pantheon,
				(it.source || "").toLowerCase() === sourceDefault.toLowerCase() ? "" : it.source,
			].join("|").replace(/\|+$/, ""); 		}
	},

	table: class extends _DataUtilPropConfigCustom {
		static async loadJSON () {
			const datas = await Promise.all([
				`${Renderer.get().baseUrl}data/generated/gendata-tables.json`,
				`${Renderer.get().baseUrl}data/tables.json`,
			].map(url => DataUtil.loadJSON(url)));
			const combined = {};
			datas.forEach(data => {
				Object.entries(data).forEach(([k, v]) => {
					if (combined[k] && combined[k] instanceof Array && v instanceof Array) combined[k] = combined[k].concat(v);
					else if (combined[k] == null) combined[k] = v;
					else throw new Error(`Could not merge keys for key "${k}"`);
				});
			});

			return combined;
		}
	},

	legendaryGroup: class extends _DataUtilPropConfigSingleSource {
		static _PAGE = UrlUtil.PG_BESTIARY;
		static _FILENAME = "bestiary/legendarygroups.json";

		static async pLoadAll () {
			return (await this.loadJSON()).legendaryGroup;
		}
	},

	variantrule: class extends _DataUtilPropConfigSingleSource {
		static _PAGE = UrlUtil.PG_VARIANTRULES;
		static _FILENAME = "variantrules.json";

		static async loadJSON () {
			const rawData = await super.loadJSON();
			const rawDataGenerated = await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/generated/gendata-variantrules.json`);

			return {variantrule: [...rawData.variantrule, ...rawDataGenerated.variantrule]};
		}
	},

	deck: class extends _DataUtilPropConfigCustom {
		static _PAGE = UrlUtil.PG_DECKS;

		static _pLoadJson = null;
		static _pLoadRawJson = null;

		static loadJSON () {
			return DataUtil.deck._pLoadJson = DataUtil.deck._pLoadJson || (async () => {
				return {
					deck: await DataLoader.pCacheAndGetAllSite("deck"),
					card: await DataLoader.pCacheAndGetAllSite("card"),
				};
			})();
		}

		static loadRawJSON () {
			return DataUtil.deck._pLoadRawJson = DataUtil.deck._pLoadRawJson || DataUtil.loadJSON(`${Renderer.get().baseUrl}data/decks.json`);
		}

		static async loadPrerelease () {
			return {
				deck: await DataLoader.pCacheAndGetAllPrerelease("deck"),
				card: await DataLoader.pCacheAndGetAllPrerelease("card"),
			};
		}

		static async loadBrew () {
			return {
				deck: await DataLoader.pCacheAndGetAllBrew("deck"),
				card: await DataLoader.pCacheAndGetAllBrew("card"),
			};
		}

				static unpackUidCard (uid, opts) {
			opts = opts || {};
			if (opts.isLower) uid = uid.toLowerCase();
			let [name, set, source, displayText] = uid.split("|").map(it => it.trim());
			set = set || "none";
			source = source || Parser.getTagSource("card", source)[opts.isLower ? "toLowerCase" : "toString"]();
			return {
				name,
				set,
				source,
				displayText,
			};
		}
	},

	quickreference: {
				unpackUid (uid, opts) {
			opts = opts || {};
			if (opts.isLower) uid = uid.toLowerCase();
			let [name, source, ixChapter, ixHeader, displayText] = uid.split("|").map(it => it.trim());
			source = source || (opts.isLower ? Parser.SRC_PHB.toLowerCase() : Parser.SRC_PHB);
			ixChapter = Number(ixChapter || 0);
			return {
				name,
				ixChapter,
				ixHeader,
				source,
				displayText,
			};
		},
	},

	brew: new _DataUtilBrewHelper({defaultUrlRoot: VeCt.URL_ROOT_BREW}),
	prerelease: new _DataUtilBrewHelper({defaultUrlRoot: VeCt.URL_ROOT_PRERELEASE}),
};

globalThis.RollerUtil = {
	isCrypto () {
		return typeof window !== "undefined" && typeof window.crypto !== "undefined";
	},

	randomise (max, min = 1) {
		if (min > max) return 0;
		if (max === min) return max;
		if (RollerUtil.isCrypto()) {
			return RollerUtil._randomise(min, max + 1);
		} else {
			return RollerUtil.roll(max) + min;
		}
	},

	rollOnArray (array) {
		return array[RollerUtil.randomise(array.length) - 1];
	},

		_randomise: (min, max) => {
		if (isNaN(min) || isNaN(max)) throw new Error(`Invalid min/max!`);

		const range = max - min;
		const bytesNeeded = Math.ceil(Math.log2(range) / 8);
		const randomBytes = new Uint8Array(bytesNeeded);
		const maximumRange = (2 ** 8) ** bytesNeeded;
		const extendedRange = Math.floor(maximumRange / range) * range;
		let i;
		let randomInteger;
		while (true) {
			window.crypto.getRandomValues(randomBytes);
			randomInteger = 0;
			for (i = 0; i < bytesNeeded; i++) {
				randomInteger <<= 8;
				randomInteger += randomBytes[i];
			}
			if (randomInteger < extendedRange) {
				randomInteger %= range;
				return min + randomInteger;
			}
		}
	},

		roll (max, fn = Math.random) {
		return Math.floor(fn() * max);
	},

	addListRollButton (isCompact) {

	},

	getColRollType (colLabel) {
		if (typeof colLabel !== "string") return false;
		colLabel = Renderer.stripTags(colLabel);

		if (Renderer.dice.lang.getTree3(colLabel)) return RollerUtil.ROLL_COL_STANDARD;

				colLabel = colLabel.replace(RollerUtil._REGEX_ROLLABLE_COL_LABEL, "$1");
		if (Renderer.dice.lang.getTree3(colLabel)) return RollerUtil.ROLL_COL_VARIABLE;

		return RollerUtil.ROLL_COL_NONE;
	},

	getFullRollCol (lbl) {
		if (lbl.includes("@dice")) return lbl;

		if (Renderer.dice.lang.getTree3(lbl)) return `{@dice ${lbl}}`;

				const m = RollerUtil._REGEX_ROLLABLE_COL_LABEL.exec(lbl);
		if (!m) return lbl;

		return `{@dice ${m[1]}${m[2]}#$prompt_number:title=Enter a ${m[3].trim()}$#|${lbl}}`;
	},

	_DICE_REGEX_STR: "((([1-9]\\d*)?d([1-9]\\d*)(\\s*?[-+×x*÷/]\\s*?(\\d,\\d|\\d)+(\\.\\d+)?)?))+?",
};
RollerUtil.DICE_REGEX = new RegExp(RollerUtil._DICE_REGEX_STR, "g");
RollerUtil.REGEX_DAMAGE_DICE = /(?<average>\d+)(?<prefix> \((?:{@dice |{@damage ))(?<diceExp>[-+0-9d ]*)(?<suffix>}\)(?:\s*\+\s*the spell's level)? [a-z]+( \([-a-zA-Z0-9 ]+\))?( or [a-z]+( \([-a-zA-Z0-9 ]+\))?)? damage)/gi;
RollerUtil.REGEX_DAMAGE_FLAT = /(?<prefix>Hit: |{@h})(?<flatVal>[0-9]+)(?<suffix> [a-z]+( \([-a-zA-Z0-9 ]+\))?( or [a-z]+( \([-a-zA-Z0-9 ]+\))?)? damage)/gi;
RollerUtil._REGEX_ROLLABLE_COL_LABEL = /^(.*?\d)(\s*[-+/*^×÷]\s*)([a-zA-Z0-9 ]+)$/;
RollerUtil.ROLL_COL_NONE = 0;
RollerUtil.ROLL_COL_STANDARD = 1;
RollerUtil.ROLL_COL_VARIABLE = 2;

function StorageUtilBase () {
	this._META_KEY = "_STORAGE_META_STORAGE";

	this._fakeStorageBacking = {};
	this._fakeStorageBackingAsync = {};

	this._getFakeStorageSync = function () {
		return {
			isSyncFake: true,
			getItem: k => this._fakeStorageBacking[k],
			removeItem: k => delete this._fakeStorageBacking[k],
			setItem: (k, v) => this._fakeStorageBacking[k] = v,
		};
	};

	this._getFakeStorageAsync = function () {
		return {
			pIsAsyncFake: true,
			setItem: async (k, v) => this._fakeStorageBackingAsync[k] = v,
			getItem: async (k) => this._fakeStorageBackingAsync[k],
			removeItem: async (k) => delete this._fakeStorageBackingAsync[k],
		};
	};

	this._getSyncStorage = function () { throw new Error(`Unimplemented!`); };
	this._getAsyncStorage = async function () { throw new Error(`Unimplemented!`); };

	this.getPageKey = function (key, page) { return `${key}_${page || UrlUtil.getCurrentPage()}`; };

		this.syncGet = function (key) {
		const rawOut = this._getSyncStorage().getItem(key);
		if (rawOut && rawOut !== "undefined" && rawOut !== "null") return JSON.parse(rawOut);
		return null;
	};

	this.syncSet = function (key, value) {
		this._getSyncStorage().setItem(key, JSON.stringify(value));
		this._syncTrackKey(key);
	};

	this.syncRemove = function (key) {
		this._getSyncStorage().removeItem(key);
		this._syncTrackKey(key, true);
	};

	this.syncGetForPage = function (key) { return this.syncGet(`${key}_${UrlUtil.getCurrentPage()}`); };
	this.syncSetForPage = function (key, value) { this.syncSet(`${key}_${UrlUtil.getCurrentPage()}`, value); };

	this.isSyncFake = function () {
		return !!this._getSyncStorage().isSyncFake;
	};

	this._syncTrackKey = function (key, isRemove) {
		const meta = this.syncGet(this._META_KEY) || {};
		if (isRemove) delete meta[key];
		else meta[key] = 1;
		this._getSyncStorage().setItem(this._META_KEY, JSON.stringify(meta));
	};

	this.syncGetDump = function () {
		const out = {};
		this._syncGetPresentKeys().forEach(key => out[key] = this.syncGet(key));
		return out;
	};

	this._syncGetPresentKeys = function () {
		const meta = this.syncGet(this._META_KEY) || {};
		return Object.entries(meta).filter(([, isPresent]) => isPresent).map(([key]) => key);
	};

	this.syncSetFromDump = function (dump) {
		const keysToRemove = new Set(this._syncGetPresentKeys());
		Object.entries(dump).map(([k, v]) => {
			keysToRemove.delete(k);
			return this.syncSet(k, v);
		});
		[...keysToRemove].map(k => this.syncRemove(k));
	};
	
		this.pIsAsyncFake = async function () {
		const storage = await this._getAsyncStorage();
		return !!storage.pIsAsyncFake;
	};

	this.pSet = async function (key, value) {
		this._pTrackKey(key).then(null);
		const storage = await this._getAsyncStorage();
		return storage.setItem(key, value);
	};

	this.pGet = async function (key) {
		const storage = await this._getAsyncStorage();
		return storage.getItem(key);
	};

	this.pRemove = async function (key) {
		this._pTrackKey(key, true).then(null);
		const storage = await this._getAsyncStorage();
		return storage.removeItem(key);
	};

	this.pGetForPage = async function (key, {page = null} = {}) { return this.pGet(this.getPageKey(key, page)); };
	this.pSetForPage = async function (key, value, {page = null} = {}) { return this.pSet(this.getPageKey(key, page), value); };
	this.pRemoveForPage = async function (key, {page = null} = {}) { return this.pRemove(this.getPageKey(key, page)); };

	this._pTrackKey = async function (key, isRemove) {
		const storage = await this._getAsyncStorage();
		const meta = (await this.pGet(this._META_KEY)) || {};
		if (isRemove) delete meta[key];
		else meta[key] = 1;
		return storage.setItem(this._META_KEY, meta);
	};

	this.pGetDump = async function () {
		const out = {};
		await Promise.all(
			(await this._pGetPresentKeys()).map(async (key) => out[key] = await this.pGet(key)),
		);
		return out;
	};

	this._pGetPresentKeys = async function () {
		const meta = (await this.pGet(this._META_KEY)) || {};
		return Object.entries(meta).filter(([, isPresent]) => isPresent).map(([key]) => key);
	};

	this.pSetFromDump = async function (dump) {
		const keysToRemove = new Set(await this._pGetPresentKeys());
		await Promise.all(
			Object.entries(dump).map(([k, v]) => {
				keysToRemove.delete(k);
				return this.pSet(k, v);
			}),
		);
		await Promise.all(
			[...keysToRemove].map(k => this.pRemove(k)),
		);
	};
	}

function StorageUtilMemory$1 () {
	StorageUtilBase.call(this);

	this._fakeStorage = null;
	this._fakeStorageAsync = null;

	this._getSyncStorage = function () {
		this._fakeStorage = this._fakeStorage || this._getFakeStorageSync();
		return this._fakeStorage;
	};

	this._getAsyncStorage = async function () {
		this._fakeStorageAsync = this._fakeStorageAsync || this._getFakeStorageAsync();
		return this._fakeStorageAsync;
	};
}

globalThis.StorageUtilMemory = StorageUtilMemory$1;

function StorageUtilBacked () {
	StorageUtilBase.call(this);

	this._isInit = false;
	this._isInitAsync = false;
	this._fakeStorage = null;
	this._fakeStorageAsync = null;

	this._initSyncStorage = function () {
		if (this._isInit) return;

		if (typeof window === "undefined") {
			this._fakeStorage = this._getFakeStorageSync();
			this._isInit = true;
			return;
		}

		try {
			window.localStorage.setItem("_test_storage", true);
		} catch (e) {
						this._fakeStorage = this._getFakeStorageSync();
		}

		this._isInit = true;
	};

	this._getSyncStorage = function () {
		this._initSyncStorage();
		if (this._fakeStorage) return this._fakeStorage;
		return window.localStorage;
	};

	this._initAsyncStorage = async function () {
		if (this._isInitAsync) return;

		if (typeof window === "undefined") {
			this._fakeStorageAsync = this._getFakeStorageAsync();
			this._isInitAsync = true;
			return;
		}

		try {
						await new Promise((resolve, reject) => {
				const request = window.indexedDB.open("_test_db", 1);
				request.onerror = reject;
				request.onsuccess = resolve;
			});
			await localforage.setItem("_storage_check", true);
		} catch (e) {
			this._fakeStorageAsync = this._getFakeStorageAsync();
		}

		this._isInitAsync = true;
	};

	this._getAsyncStorage = async function () {
		await this._initAsyncStorage();
		if (this._fakeStorageAsync) return this._fakeStorageAsync;
		else return localforage;
	};
}

globalThis.StorageUtil = new StorageUtilBacked();

globalThis.SessionStorageUtil = {
	_fakeStorage: {},
	__storage: null,
	getStorage: () => {
		try {
			return window.sessionStorage;
		} catch (e) {
						if (SessionStorageUtil.__storage) return SessionStorageUtil.__storage;
			else {
				return SessionStorageUtil.__storage = {
					isFake: true,
					getItem: (k) => {
						return SessionStorageUtil._fakeStorage[k];
					},
					removeItem: (k) => {
						delete SessionStorageUtil._fakeStorage[k];
					},
					setItem: (k, v) => {
						SessionStorageUtil._fakeStorage[k] = v;
					},
				};
			}
		}
	},

	isFake () {
		return SessionStorageUtil.getStorage().isSyncFake;
	},

	setForPage: (key, value) => {
		SessionStorageUtil.set(`${key}_${UrlUtil.getCurrentPage()}`, value);
	},

	set (key, value) {
		SessionStorageUtil.getStorage().setItem(key, JSON.stringify(value));
	},

	getForPage: (key) => {
		return SessionStorageUtil.get(`${key}_${UrlUtil.getCurrentPage()}`);
	},

	get (key) {
		const rawOut = SessionStorageUtil.getStorage().getItem(key);
		if (rawOut && rawOut !== "undefined" && rawOut !== "null") return JSON.parse(rawOut);
		return null;
	},

	removeForPage: (key) => {
		SessionStorageUtil.remove(`${key}_${UrlUtil.getCurrentPage()}`);
	},

	remove (key) {
		SessionStorageUtil.getStorage().removeItem(key);
	},
};

globalThis.CryptUtil = {
			_md5cycle: (x, k) => {
		let a = x[0];
		let b = x[1];
		let c = x[2];
		let d = x[3];

		a = CryptUtil._ff(a, b, c, d, k[0], 7, -680876936);
		d = CryptUtil._ff(d, a, b, c, k[1], 12, -389564586);
		c = CryptUtil._ff(c, d, a, b, k[2], 17, 606105819);
		b = CryptUtil._ff(b, c, d, a, k[3], 22, -1044525330);
		a = CryptUtil._ff(a, b, c, d, k[4], 7, -176418897);
		d = CryptUtil._ff(d, a, b, c, k[5], 12, 1200080426);
		c = CryptUtil._ff(c, d, a, b, k[6], 17, -1473231341);
		b = CryptUtil._ff(b, c, d, a, k[7], 22, -45705983);
		a = CryptUtil._ff(a, b, c, d, k[8], 7, 1770035416);
		d = CryptUtil._ff(d, a, b, c, k[9], 12, -1958414417);
		c = CryptUtil._ff(c, d, a, b, k[10], 17, -42063);
		b = CryptUtil._ff(b, c, d, a, k[11], 22, -1990404162);
		a = CryptUtil._ff(a, b, c, d, k[12], 7, 1804603682);
		d = CryptUtil._ff(d, a, b, c, k[13], 12, -40341101);
		c = CryptUtil._ff(c, d, a, b, k[14], 17, -1502002290);
		b = CryptUtil._ff(b, c, d, a, k[15], 22, 1236535329);

		a = CryptUtil._gg(a, b, c, d, k[1], 5, -165796510);
		d = CryptUtil._gg(d, a, b, c, k[6], 9, -1069501632);
		c = CryptUtil._gg(c, d, a, b, k[11], 14, 643717713);
		b = CryptUtil._gg(b, c, d, a, k[0], 20, -373897302);
		a = CryptUtil._gg(a, b, c, d, k[5], 5, -701558691);
		d = CryptUtil._gg(d, a, b, c, k[10], 9, 38016083);
		c = CryptUtil._gg(c, d, a, b, k[15], 14, -660478335);
		b = CryptUtil._gg(b, c, d, a, k[4], 20, -405537848);
		a = CryptUtil._gg(a, b, c, d, k[9], 5, 568446438);
		d = CryptUtil._gg(d, a, b, c, k[14], 9, -1019803690);
		c = CryptUtil._gg(c, d, a, b, k[3], 14, -187363961);
		b = CryptUtil._gg(b, c, d, a, k[8], 20, 1163531501);
		a = CryptUtil._gg(a, b, c, d, k[13], 5, -1444681467);
		d = CryptUtil._gg(d, a, b, c, k[2], 9, -51403784);
		c = CryptUtil._gg(c, d, a, b, k[7], 14, 1735328473);
		b = CryptUtil._gg(b, c, d, a, k[12], 20, -1926607734);

		a = CryptUtil._hh(a, b, c, d, k[5], 4, -378558);
		d = CryptUtil._hh(d, a, b, c, k[8], 11, -2022574463);
		c = CryptUtil._hh(c, d, a, b, k[11], 16, 1839030562);
		b = CryptUtil._hh(b, c, d, a, k[14], 23, -35309556);
		a = CryptUtil._hh(a, b, c, d, k[1], 4, -1530992060);
		d = CryptUtil._hh(d, a, b, c, k[4], 11, 1272893353);
		c = CryptUtil._hh(c, d, a, b, k[7], 16, -155497632);
		b = CryptUtil._hh(b, c, d, a, k[10], 23, -1094730640);
		a = CryptUtil._hh(a, b, c, d, k[13], 4, 681279174);
		d = CryptUtil._hh(d, a, b, c, k[0], 11, -358537222);
		c = CryptUtil._hh(c, d, a, b, k[3], 16, -722521979);
		b = CryptUtil._hh(b, c, d, a, k[6], 23, 76029189);
		a = CryptUtil._hh(a, b, c, d, k[9], 4, -640364487);
		d = CryptUtil._hh(d, a, b, c, k[12], 11, -421815835);
		c = CryptUtil._hh(c, d, a, b, k[15], 16, 530742520);
		b = CryptUtil._hh(b, c, d, a, k[2], 23, -995338651);

		a = CryptUtil._ii(a, b, c, d, k[0], 6, -198630844);
		d = CryptUtil._ii(d, a, b, c, k[7], 10, 1126891415);
		c = CryptUtil._ii(c, d, a, b, k[14], 15, -1416354905);
		b = CryptUtil._ii(b, c, d, a, k[5], 21, -57434055);
		a = CryptUtil._ii(a, b, c, d, k[12], 6, 1700485571);
		d = CryptUtil._ii(d, a, b, c, k[3], 10, -1894986606);
		c = CryptUtil._ii(c, d, a, b, k[10], 15, -1051523);
		b = CryptUtil._ii(b, c, d, a, k[1], 21, -2054922799);
		a = CryptUtil._ii(a, b, c, d, k[8], 6, 1873313359);
		d = CryptUtil._ii(d, a, b, c, k[15], 10, -30611744);
		c = CryptUtil._ii(c, d, a, b, k[6], 15, -1560198380);
		b = CryptUtil._ii(b, c, d, a, k[13], 21, 1309151649);
		a = CryptUtil._ii(a, b, c, d, k[4], 6, -145523070);
		d = CryptUtil._ii(d, a, b, c, k[11], 10, -1120210379);
		c = CryptUtil._ii(c, d, a, b, k[2], 15, 718787259);
		b = CryptUtil._ii(b, c, d, a, k[9], 21, -343485551);

		x[0] = CryptUtil._add32(a, x[0]);
		x[1] = CryptUtil._add32(b, x[1]);
		x[2] = CryptUtil._add32(c, x[2]);
		x[3] = CryptUtil._add32(d, x[3]);
	},

	_cmn: (q, a, b, x, s, t) => {
		a = CryptUtil._add32(CryptUtil._add32(a, q), CryptUtil._add32(x, t));
		return CryptUtil._add32((a << s) | (a >>> (32 - s)), b);
	},

	_ff: (a, b, c, d, x, s, t) => {
		return CryptUtil._cmn((b & c) | ((~b) & d), a, b, x, s, t);
	},

	_gg: (a, b, c, d, x, s, t) => {
		return CryptUtil._cmn((b & d) | (c & (~d)), a, b, x, s, t);
	},

	_hh: (a, b, c, d, x, s, t) => {
		return CryptUtil._cmn(b ^ c ^ d, a, b, x, s, t);
	},

	_ii: (a, b, c, d, x, s, t) => {
		return CryptUtil._cmn(c ^ (b | (~d)), a, b, x, s, t);
	},

	_md51: (s) => {
		let n = s.length;
		let state = [1732584193, -271733879, -1732584194, 271733878];
		let i;
		for (i = 64; i <= s.length; i += 64) {
			CryptUtil._md5cycle(state, CryptUtil._md5blk(s.substring(i - 64, i)));
		}
		s = s.substring(i - 64);
		let tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
		for (i = 0; i < s.length; i++) tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);
		tail[i >> 2] |= 0x80 << ((i % 4) << 3);
		if (i > 55) {
			CryptUtil._md5cycle(state, tail);
			for (i = 0; i < 16; i++) tail[i] = 0;
		}
		tail[14] = n * 8;
		CryptUtil._md5cycle(state, tail);
		return state;
	},

	_md5blk: (s) => {
		let md5blks = [];
		for (let i = 0; i < 64; i += 4) {
			md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
		}
		return md5blks;
	},

	_hex_chr: "0123456789abcdef".split(""),

	_rhex: (n) => {
		let s = "";
		for (let j = 0; j < 4; j++) {
			s += CryptUtil._hex_chr[(n >> (j * 8 + 4)) & 0x0F] + CryptUtil._hex_chr[(n >> (j * 8)) & 0x0F];
		}
		return s;
	},

	_add32: (a, b) => {
		return (a + b) & 0xFFFFFFFF;
	},
	
	hex: (x) => {
		for (let i = 0; i < x.length; i++) {
			x[i] = CryptUtil._rhex(x[i]);
		}
		return x.join("");
	},

	hex2Dec (hex) {
		return parseInt(`0x${hex}`);
	},

	md5: (s) => {
		return CryptUtil.hex(CryptUtil._md51(s));
	},

		hashCode (obj) {
		if (typeof obj === "string") {
			if (!obj) return 0;
			let h = 0;
			for (let i = 0; i < obj.length; ++i) h = 31 * h + obj.charCodeAt(i);
			return h;
		} else if (typeof obj === "number") return obj;
		else throw new Error(`No hashCode implementation for ${obj}`);
	},

	uid () { 		if (RollerUtil.isCrypto()) {
			return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c => (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16));
		} else {
			let d = Date.now();
			if (typeof performance !== "undefined" && typeof performance.now === "function") {
				d += performance.now();
			}
			return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
				const r = (d + Math.random() * 16) % 16 | 0;
				d = Math.floor(d / 16);
				return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
			});
		}
	},
};

globalThis.CollectionUtil = {
	ObjectSet: class ObjectSet {
		constructor () {
			this.map = new Map();
			this[Symbol.iterator] = this.values;
		}
						add (item) {
			this.map.set(item._toIdString(), item);
		}

		values () {
			return this.map.values();
		}
	},

	setEq (a, b) {
		if (a.size !== b.size) return false;
		for (const it of a) if (!b.has(it)) return false;
		return true;
	},

	setDiff (set1, set2) {
		return new Set([...set1].filter(it => !set2.has(it)));
	},

	objectDiff (obj1, obj2) {
		const out = {};

		[...new Set([...Object.keys(obj1), ...Object.keys(obj2)])]
			.forEach(k => {
				const diff = CollectionUtil._objectDiff_recurse(obj1[k], obj2[k]);
				if (diff !== undefined) out[k] = diff;
			});

		return out;
	},

	_objectDiff_recurse (a, b) {
		if (CollectionUtil.deepEquals(a, b)) return undefined;

		if (a && b && typeof a === "object" && typeof b === "object") {
			return CollectionUtil.objectDiff(a, b);
		}

		return b;
	},

	objectIntersect (obj1, obj2) {
		const out = {};

		[...new Set([...Object.keys(obj1), ...Object.keys(obj2)])]
			.forEach(k => {
				const diff = CollectionUtil._objectIntersect_recurse(obj1[k], obj2[k]);
				if (diff !== undefined) out[k] = diff;
			});

		return out;
	},

	_objectIntersect_recurse (a, b) {
		if (CollectionUtil.deepEquals(a, b)) return a;

		if (a && b && typeof a === "object" && typeof b === "object") {
			return CollectionUtil.objectIntersect(a, b);
		}

		return undefined;
	},

	deepEquals (a, b) {
		if (Object.is(a, b)) return true;
		if (a && b && typeof a === "object" && typeof b === "object") {
			if (CollectionUtil._eq_isPlainObject(a) && CollectionUtil._eq_isPlainObject(b)) return CollectionUtil._eq_areObjectsEqual(a, b);
			const isArrayA = Array.isArray(a);
			const isArrayB = Array.isArray(b);
			if (isArrayA || isArrayB) return isArrayA === isArrayB && CollectionUtil._eq_areArraysEqual(a, b);
			const isSetA = a instanceof Set;
			const isSetB = b instanceof Set;
			if (isSetA || isSetB) return isSetA === isSetB && CollectionUtil.setEq(a, b);
			return CollectionUtil._eq_areObjectsEqual(a, b);
		}
		return false;
	},

	_eq_isPlainObject: (value) => value.constructor === Object || value.constructor == null,
	_eq_areObjectsEqual (a, b) {
		const keysA = Object.keys(a);
		const {length} = keysA;
		if (Object.keys(b).length !== length) return false;
		for (let i = 0; i < length; i++) {
			if (!b.hasOwnProperty(keysA[i])) return false;
			if (!CollectionUtil.deepEquals(a[keysA[i]], b[keysA[i]])) return false;
		}
		return true;
	},
	_eq_areArraysEqual (a, b) {
		const {length} = a;
		if (b.length !== length) return false;
		for (let i = 0; i < length; i++) if (!CollectionUtil.deepEquals(a[i], b[i])) return false;
		return true;
	},

		dfs (obj, opts) {
		const {prop = null, fnMatch = null} = opts;
		if (!prop && !fnMatch) throw new Error(`One of "prop" or "fnMatch" must be specified!`);

		if (obj instanceof Array) {
			for (const child of obj) {
				const n = CollectionUtil.dfs(child, opts);
				if (n) return n;
			}
			return;
		}

		if (obj instanceof Object) {
			if (prop && obj[prop]) return obj[prop];
			if (fnMatch && fnMatch(obj)) return obj;

			for (const child of Object.values(obj)) {
				const n = CollectionUtil.dfs(child, opts);
				if (n) return n;
			}
		}
	},

	bfs (obj, opts) {
		const {prop = null, fnMatch = null} = opts;
		if (!prop && !fnMatch) throw new Error(`One of "prop" or "fnMatch" must be specified!`);

		if (obj instanceof Array) {
			for (const child of obj) {
				if (!(child instanceof Array) && child instanceof Object) {
					if (prop && child[prop]) return child[prop];
					if (fnMatch && fnMatch(child)) return child;
				}
			}

			for (const child of obj) {
				const n = CollectionUtil.bfs(child, opts);
				if (n) return n;
			}

			return;
		}

		if (obj instanceof Object) {
			if (prop && obj[prop]) return obj[prop];
			if (fnMatch && fnMatch(obj)) return obj;

			return CollectionUtil.bfs(Object.values(obj));
		}
	},
	};

Array.prototype.last || Object.defineProperty(Array.prototype, "last", {
	enumerable: false,
	writable: true,
	value: function (arg) {
		if (arg !== undefined) this[this.length - 1] = arg;
		else return this[this.length - 1];
	},
});

Array.prototype.filterIndex || Object.defineProperty(Array.prototype, "filterIndex", {
	enumerable: false,
	writable: true,
	value: function (fnCheck) {
		const out = [];
		this.forEach((it, i) => {
			if (fnCheck(it)) out.push(i);
		});
		return out;
	},
});

Array.prototype.equals || Object.defineProperty(Array.prototype, "equals", {
	enumerable: false,
	writable: true,
	value: function (array2) {
		const array1 = this;
		if (!array1 && !array2) return true;
		else if ((!array1 && array2) || (array1 && !array2)) return false;

		let temp = [];
		if ((!array1[0]) || (!array2[0])) return false;
		if (array1.length !== array2.length) return false;
		let key;
				for (let i = 0; i < array1.length; i++) {
			key = `${(typeof array1[i])}~${array1[i]}`; 			if (temp[key]) temp[key]++;
			else temp[key] = 1;
		}
				for (let i = 0; i < array2.length; i++) {
			key = `${(typeof array2[i])}~${array2[i]}`;
			if (temp[key]) {
				if (temp[key] === 0) return false;
				else temp[key]--;
			} else return false;
		}
		return true;
	},
});

Array.prototype.segregate || Object.defineProperty(Array.prototype, "segregate", {
	enumerable: false,
	writable: true,
	value: function (fnIsValid) {
		return this.reduce(([pass, fail], elem) => fnIsValid(elem) ? [[...pass, elem], fail] : [pass, [...fail, elem]], [[], []]);
	},
});

Array.prototype.partition || Object.defineProperty(Array.prototype, "partition", {
	enumerable: false,
	writable: true,
	value: Array.prototype.segregate,
});

Array.prototype.getNext || Object.defineProperty(Array.prototype, "getNext", {
	enumerable: false,
	writable: true,
	value: function (curVal) {
		let ix = this.indexOf(curVal);
		if (!~ix) throw new Error("Value was not in array!");
		if (++ix >= this.length) ix = 0;
		return this[ix];
	},
});

Array.prototype.shuffle || Object.defineProperty(Array.prototype, "shuffle", {
	enumerable: false,
	writable: true,
	value: function () {
		for (let i = 0; i < 10000; ++i) this.sort(() => Math.random() - 0.5);
		return this;
	},
});

Array.prototype.mergeMap || Object.defineProperty(Array.prototype, "mergeMap", {
	enumerable: false,
	writable: true,
	value: function (fnMap) {
		return this.map((...args) => fnMap(...args)).filter(it => it != null).reduce((a, b) => Object.assign(a, b), {});
	},
});

Array.prototype.first || Object.defineProperty(Array.prototype, "first", {
	enumerable: false,
	writable: true,
	value: function (fnMapFind) {
		for (let i = 0, len = this.length; i < len; ++i) {
			const result = fnMapFind(this[i], i, this);
			if (result) return result;
		}
	},
});

Array.prototype.pMap || Object.defineProperty(Array.prototype, "pMap", {
	enumerable: false,
	writable: true,
	value: async function (fnMap) {
		return Promise.all(this.map((it, i) => fnMap(it, i, this)));
	},
});

Array.prototype.pSerialAwaitMap || Object.defineProperty(Array.prototype, "pSerialAwaitMap", {
	enumerable: false,
	writable: true,
	value: async function (fnMap) {
		const out = [];
		for (let i = 0, len = this.length; i < len; ++i) out.push(await fnMap(this[i], i, this));
		return out;
	},
});

Array.prototype.pSerialAwaitFilter || Object.defineProperty(Array.prototype, "pSerialAwaitFilter", {
	enumerable: false,
	writable: true,
	value: async function (fnFilter) {
		const out = [];
		for (let i = 0, len = this.length; i < len; ++i) {
			if (await fnFilter(this[i], i, this)) out.push(this[i]);
		}
		return out;
	},
});

Array.prototype.pSerialAwaitFind || Object.defineProperty(Array.prototype, "pSerialAwaitFind", {
	enumerable: false,
	writable: true,
	value: async function (fnFind) {
		for (let i = 0, len = this.length; i < len; ++i) if (await fnFind(this[i], i, this)) return this[i];
	},
});

Array.prototype.pSerialAwaitSome || Object.defineProperty(Array.prototype, "pSerialAwaitSome", {
	enumerable: false,
	writable: true,
	value: async function (fnSome) {
		for (let i = 0, len = this.length; i < len; ++i) if (await fnSome(this[i], i, this)) return true;
		return false;
	},
});

Array.prototype.pSerialAwaitFirst || Object.defineProperty(Array.prototype, "pSerialAwaitFirst", {
	enumerable: false,
	writable: true,
	value: async function (fnMapFind) {
		for (let i = 0, len = this.length; i < len; ++i) {
			const result = await fnMapFind(this[i], i, this);
			if (result) return result;
		}
	},
});

Array.prototype.unique || Object.defineProperty(Array.prototype, "unique", {
	enumerable: false,
	writable: true,
	value: function (fnGetProp) {
		const seen = new Set();
		return this.filter((...args) => {
			const val = fnGetProp ? fnGetProp(...args) : args[0];
			if (seen.has(val)) return false;
			seen.add(val);
			return true;
		});
	},
});

Array.prototype.zip || Object.defineProperty(Array.prototype, "zip", {
	enumerable: false,
	writable: true,
	value: function (otherArray) {
		const out = [];
		const len = Math.max(this.length, otherArray.length);
		for (let i = 0; i < len; ++i) {
			out.push([this[i], otherArray[i]]);
		}
		return out;
	},
});

Array.prototype.nextWrap || Object.defineProperty(Array.prototype, "nextWrap", {
	enumerable: false,
	writable: true,
	value: function (item) {
		const ix = this.indexOf(item);
		if (~ix) {
			if (ix + 1 < this.length) return this[ix + 1];
			else return this[0];
		} else return this.last();
	},
});

Array.prototype.prevWrap || Object.defineProperty(Array.prototype, "prevWrap", {
	enumerable: false,
	writable: true,
	value: function (item) {
		const ix = this.indexOf(item);
		if (~ix) {
			if (ix - 1 >= 0) return this[ix - 1];
			else return this.last();
		} else return this[0];
	},
});

Array.prototype.findLast || Object.defineProperty(Array.prototype, "findLast", {
	enumerable: false,
	writable: true,
	value: function (fn) {
		for (let i = this.length - 1; i >= 0; --i) if (fn(this[i])) return this[i];
	},
});

Array.prototype.findLastIndex || Object.defineProperty(Array.prototype, "findLastIndex", {
	enumerable: false,
	writable: true,
	value: function (fn) {
		for (let i = this.length - 1; i >= 0; --i) if (fn(this[i])) return i;
		return -1;
	},
});

Array.prototype.sum || Object.defineProperty(Array.prototype, "sum", {
	enumerable: false,
	writable: true,
	value: function () {
		let tmp = 0;
		const len = this.length;
		for (let i = 0; i < len; ++i) tmp += this[i];
		return tmp;
	},
});

Array.prototype.mean || Object.defineProperty(Array.prototype, "mean", {
	enumerable: false,
	writable: true,
	value: function () {
		return this.sum() / this.length;
	},
});

Array.prototype.meanAbsoluteDeviation || Object.defineProperty(Array.prototype, "meanAbsoluteDeviation", {
	enumerable: false,
	writable: true,
	value: function () {
		const mean = this.mean();
		return (this.map(num => Math.abs(num - mean)) || []).mean();
	},
});

Map.prototype.getOrSet || Object.defineProperty(Map.prototype, "getOrSet", {
	enumerable: false,
	writable: true,
	value: function (k, orV) {
		if (this.has(k)) return this.get(k);
		this.set(k, orV);
		return orV;
	},
});

function BookModeView (opts) {
	opts = opts || {};
	const {hashKey, $openBtn, $eleNoneVisible, pageTitle, popTblGetNumShown, isFlex, state, stateKey, isHideContentOnNoneShown, isHideButtonCloseNone} = opts;

	if (hashKey && stateKey) throw new Error();

	this.hashKey = hashKey;
	this.stateKey = stateKey;
	this.state = state;
	this.$openBtn = $openBtn;
	this.$eleNoneVisible = $eleNoneVisible;
	this.popTblGetNumShown = popTblGetNumShown;
	this.isHideContentOnNoneShown = isHideContentOnNoneShown;
	this.isHideButtonCloseNone = isHideButtonCloseNone;

	this.active = false;
	this._$body = null;
	this._$wrpBook = null;

	this._$wrpRenderedContent = null;
	this._$wrpNoneShown = null;
	this._doRenderContent = null; 
	this.$openBtn.off("click").on("click", () => {
		if (this.stateKey) {
			this.state[this.stateKey] = true;
		} else {
			Hist.cleanSetHash(`${window.location.hash}${HASH_PART_SEP}${this.hashKey}${HASH_SUB_KV_SEP}true`);
		}
	});

	this.close = () => { return this._doHashTeardown(); };

	this._doHashTeardown = () => {
		if (this.stateKey) {
			this.state[this.stateKey] = false;
		} else {
			Hist.cleanSetHash(window.location.hash.replace(`${this.hashKey}${HASH_SUB_KV_SEP}true`, ""));
		}
	};

	this._renderContent = async ($wrpContent, $dispName, $wrpControlsToPass) => {
		this._$wrpRenderedContent = this._$wrpRenderedContent
			? this._$wrpRenderedContent.empty().append($wrpContent)
			: $$`<div class="bkmv__scroller smooth-scroll h-100 overflow-y-auto ${isFlex ? "ve-flex" : ""}">${this.isHideContentOnNoneShown ? null : $wrpContent}</div>`;
		this._$wrpRenderedContent.appendTo(this._$wrpBook);

		const numShown = await this.popTblGetNumShown({$wrpContent, $dispName, $wrpControls: $wrpControlsToPass});

		if (numShown) {
			if (this.isHideContentOnNoneShown) this._$wrpRenderedContent.append($wrpContent);
			if (this._$wrpNoneShown) {
				this._$wrpNoneShown.detach();
			}
		} else {
			if (this.isHideContentOnNoneShown) $wrpContent.detach();
			if (!this._$wrpNoneShown) {
				const $btnClose = $(`<button class="btn btn-default">Close</button>`)
					.click(() => this.close());

				this._$wrpNoneShown = $$`<div class="w-100 ve-flex-col ve-flex-h-center no-shrink bkmv__footer mb-3">
					<div class="mb-2 ve-flex-vh-center min-h-0">${this.$eleNoneVisible}</div>
					${this.isHideButtonCloseNone ? null : $$`<div class="ve-flex-vh-center">${$btnClose}</div>`}
				</div>`;
			}
			this._$wrpNoneShown.appendTo(this.isHideContentOnNoneShown ? this._$wrpRenderedContent : this._$wrpBook);
		}
	};

		this.pOpen = async () => {
		if (this.active) return;
		this.active = true;
		document.title = `${pageTitle} - 5etools`;

		this._$body = $(`body`);
		this._$wrpBook = $(`<div class="bkmv"></div>`);

		this._$body.css("overflow", "hidden");
		this._$body.addClass("bkmv-active");

		const $btnClose = $(`<button class="btn btn-xs btn-danger br-0 bt-0 bb-0 btl-0 bbl-0 h-20p" title="Close"><span class="glyphicon glyphicon-remove"></span></button>`)
			.click(() => this._doHashTeardown());
		const $dispName = $(`<div></div>`); 		$$`<div class="bkmv__spacer-name split-v-center no-shrink">${$dispName}${$btnClose}</div>`.appendTo(this._$wrpBook);

						const $wrpControls = $(`<div class="w-100 ve-flex-col bkmv__wrp-controls"></div>`)
			.appendTo(this._$wrpBook);

		let $wrpControlsToPass = $wrpControls;
		if (opts.hasPrintColumns) {
			$wrpControls.addClass("px-2 mt-2");

			const injectPrintCss = (cols) => {
				$(`#bkmv__print-style`).remove();
				$(`<style media="print" id="bkmv__print-style">.bkmv__wrp { column-count: ${cols}; }</style>`)
					.appendTo($(document.body));
			};

			const lastColumns = StorageUtil.syncGetForPage(BookModeView._BOOK_VIEW_COLUMNS_K);

			const $selColumns = $(`<select class="form-control input-sm">
				<option value="0">Two (book style)</option>
				<option value="1">One</option>
			</select>`)
				.change(() => {
					const val = Number($selColumns.val());
					if (val === 0) injectPrintCss(2);
					else injectPrintCss(1);

					StorageUtil.syncSetForPage(BookModeView._BOOK_VIEW_COLUMNS_K, val);
				});
			if (lastColumns != null) $selColumns.val(lastColumns);
			$selColumns.change();

			$wrpControlsToPass = $$`<div class="w-100 ve-flex">
				<div class="ve-flex-vh-center"><div class="mr-2 no-wrap help-subtle" title="Applied when printing the page.">Print columns:</div>${$selColumns}</div>
			</div>`.appendTo($wrpControls);
		}
		
		const $wrpContent = $(`<div class="bkmv__wrp p-2"></div>`);

		await this._renderContent($wrpContent, $dispName, $wrpControlsToPass);

		this._pRenderContent = () => this._renderContent($wrpContent, $dispName, $wrpControlsToPass);

		this._$body.append(this._$wrpBook);
	};

	this.teardown = () => {
		if (this.active) {
			if (this._$wrpRenderedContent) this._$wrpRenderedContent.detach();
			if (this._$wrpNoneShown) this._$wrpNoneShown.detach();

			this._$body.css("overflow", "");
			this._$body.removeClass("bkmv-active");
			this._$wrpBook.remove();
			this.active = false;

			this._pRenderContent = null;
		}
	};

	this.pHandleSub = (sub) => {
		if (this.stateKey) return; 
		const bookViewHash = sub.find(it => it.startsWith(this.hashKey));
		if (bookViewHash && UrlUtil.unpackSubHash(bookViewHash)[this.hashKey][0] === "true") return this.pOpen();
		else this.teardown();
	};
}
BookModeView._BOOK_VIEW_COLUMNS_K = "bookViewColumns";

globalThis.ExcludeUtil = {
	isInitialised: false,
	_excludes: null,
	_cache_excludesLookup: null,
	_lock: null,

	async pInitialise ({lockToken = null} = {}) {
		try {
			await ExcludeUtil._lock.pLock({token: lockToken});
			await ExcludeUtil._pInitialise();
		} finally {
			ExcludeUtil._lock.unlock();
		}
	},

	async _pInitialise () {
		if (ExcludeUtil.isInitialised) return;

		ExcludeUtil.pSave = MiscUtil.throttle(ExcludeUtil._pSave, 50);
		try {
			ExcludeUtil._excludes = await StorageUtil.pGet(VeCt.STORAGE_EXCLUDES) || [];
			ExcludeUtil._excludes = ExcludeUtil._excludes.filter(it => it.hash); 		} catch (e) {
			JqueryUtil.doToast({
				content: "Error when loading content blocklist! Purged blocklist data. (See the log for more information.)",
				type: "danger",
			});
			try {
				await StorageUtil.pRemove(VeCt.STORAGE_EXCLUDES);
			} catch (e) {
				setTimeout(() => { throw e; });
			}
			ExcludeUtil._excludes = null;
			window.location.hash = "";
			setTimeout(() => { throw e; });
		}
		ExcludeUtil.isInitialised = true;
	},

	getList () {
		return MiscUtil.copyFast(ExcludeUtil._excludes || []);
	},

	async pSetList (toSet) {
		ExcludeUtil._excludes = toSet;
		ExcludeUtil._cache_excludesLookup = null;
		await ExcludeUtil.pSave();
	},

	async pExtendList (toAdd) {
		try {
			const lockToken = await ExcludeUtil._lock.pLock();
			await ExcludeUtil._pExtendList({toAdd, lockToken});
		} finally {
			ExcludeUtil._lock.unlock();
		}
	},

	async _pExtendList ({toAdd, lockToken}) {
		await ExcludeUtil.pInitialise({lockToken});
		this._doBuildCache();

		const out = MiscUtil.copyFast(ExcludeUtil._excludes || []);
		MiscUtil.copyFast(toAdd || [])
			.filter(({hash, category, source}) => {
				if (!hash || !category || !source) return false;
				const cacheUid = ExcludeUtil._getCacheUids(hash, category, source, true);
				return !ExcludeUtil._cache_excludesLookup[cacheUid];
			})
			.forEach(it => out.push(it));

		await ExcludeUtil.pSetList(out);
	},

	_doBuildCache () {
		if (ExcludeUtil._cache_excludesLookup) return;
		if (!ExcludeUtil._excludes) return;

		ExcludeUtil._cache_excludesLookup = {};
		ExcludeUtil._excludes.forEach(({source, category, hash}) => {
			const cacheUid = ExcludeUtil._getCacheUids(hash, category, source, true);
			ExcludeUtil._cache_excludesLookup[cacheUid] = true;
		});
	},

	_getCacheUids (hash, category, source, isExact) {
		hash = (hash || "").toLowerCase();
		category = (category || "").toLowerCase();
		source = (source?.source || source || "").toLowerCase();

		const exact = `${hash}__${category}__${source}`;
		if (isExact) return [exact];

		return [
			`${hash}__${category}__${source}`,
			`*__${category}__${source}`,
			`${hash}__*__${source}`,
			`${hash}__${category}__*`,
			`*__*__${source}`,
			`*__${category}__*`,
			`${hash}__*__*`,
			`*__*__*`,
		];
	},

	_excludeCount: 0,
		isExcluded (hash, category, source, opts) {
		if (!ExcludeUtil._excludes || !ExcludeUtil._excludes.length) return false;
		if (!source) throw new Error(`Entity had no source!`);
		opts = opts || {};

		this._doBuildCache();

		hash = (hash || "").toLowerCase();
		category = (category || "").toLowerCase();
		source = (source.source || source || "").toLowerCase();

		const isExcluded = ExcludeUtil._isExcluded(hash, category, source);
		if (!isExcluded) return isExcluded;

		if (!opts.isNoCount) ++ExcludeUtil._excludeCount;

		return isExcluded;
	},

	_isExcluded (hash, category, source) {
		for (const cacheUid of ExcludeUtil._getCacheUids(hash, category, source)) {
			if (ExcludeUtil._cache_excludesLookup[cacheUid]) return true;
		}
		return false;
	},

	isAllContentExcluded (list) { return (!list.length && ExcludeUtil._excludeCount) || (list.length > 0 && list.length === ExcludeUtil._excludeCount); },
	getAllContentBlocklistedHtml () { return `<div class="initial-message">(All content <a href="blocklist.html">blocklisted</a>)</div>`; },

	async _pSave () {
		return StorageUtil.pSet(VeCt.STORAGE_EXCLUDES, ExcludeUtil._excludes);
	},

		async pSave () {  },
};

globalThis.ExtensionUtil = {
	ACTIVE: false,

	_doSend (type, data) {
		const detail = MiscUtil.copy({type, data}); 		window.dispatchEvent(new CustomEvent("rivet.send", {detail}));
	},

	async pDoSendStats (evt, ele) {
		const {page, source, hash, extensionData} = ExtensionUtil._getElementData({ele});

		if (page && source && hash) {
			let toSend = ExtensionUtil._getEmbeddedFromCache(page, source, hash)
				|| await DataLoader.pCacheAndGet(page, source, hash);

			if (extensionData) {
				switch (page) {
					case UrlUtil.PG_BESTIARY: {
						if (extensionData._scaledCr) toSend = await ScaleCreature.scale(toSend, extensionData._scaledCr);
						else if (extensionData._scaledSpellSummonLevel) toSend = await ScaleSpellSummonedCreature.scale(toSend, extensionData._scaledSpellSummonLevel);
						else if (extensionData._scaledClassSummonLevel) toSend = await ScaleClassSummonedCreature.scale(toSend, extensionData._scaledClassSummonLevel);
					}
				}
			}

			ExtensionUtil._doSend("entity", {page, entity: toSend, isTemp: !!evt.shiftKey});
		}
	},

	async doDragStart (evt, ele) {
		const {page, source, hash} = ExtensionUtil._getElementData({ele});
		const meta = {
			type: VeCt.DRAG_TYPE_IMPORT,
			page,
			source,
			hash,
		};
		evt.dataTransfer.setData("application/json", JSON.stringify(meta));
	},

	_getElementData ({ele}) {
		const $parent = $(ele).closest(`[data-page]`);
		const page = $parent.attr("data-page");
		const source = $parent.attr("data-source");
		const hash = $parent.attr("data-hash");
		const rawExtensionData = $parent.attr("data-extension");
		const extensionData = rawExtensionData ? JSON.parse(rawExtensionData) : null;

		return {page, source, hash, extensionData};
	},

	pDoSendStatsPreloaded ({page, entity, isTemp, options}) {
		ExtensionUtil._doSend("entity", {page, entity, isTemp, options});
	},

	pDoSendCurrency ({currency}) {
		ExtensionUtil._doSend("currency", {currency});
	},

	doSendRoll (data) { ExtensionUtil._doSend("roll", data); },

	pDoSend ({type, data}) { ExtensionUtil._doSend(type, data); },

	
	_CACHE_EMBEDDED_STATS: {},

	addEmbeddedToCache (page, source, hash, ent) {
		MiscUtil.set(ExtensionUtil._CACHE_EMBEDDED_STATS, page.toLowerCase(), source.toLowerCase(), hash.toLowerCase(), MiscUtil.copyFast(ent));
	},

	_getEmbeddedFromCache (page, source, hash) {
		return MiscUtil.get(ExtensionUtil._CACHE_EMBEDDED_STATS, page.toLowerCase(), source.toLowerCase(), hash.toLowerCase());
	},

	};
if (typeof window !== "undefined") window.addEventListener("rivet.active", () => ExtensionUtil.ACTIVE = true);

globalThis.TokenUtil = {
	handleStatblockScroll (event, ele) {
		$(`#token_image`)
			.toggle(ele.scrollTop < 32)
			.css({
				opacity: (32 - ele.scrollTop) / 32,
				top: -ele.scrollTop,
			});
	},
};

globalThis.VeLock = function ({name = null, isDbg = false} = {}) {
	this._name = name;
	this._isDbg = isDbg;
	this._lockMeta = null;

	this._getCaller = () => {
		return (new Error()).stack.split("\n")[3].trim();
	};

	this.pLock = async ({token = null} = {}) => {
		if (token != null && this._lockMeta?.token === token) {
			++this._lockMeta.depth;
						if (this._isDbg) console.warn(`Lock "${this._name || "(unnamed)"}" add (now ${this._lockMeta.depth}) at ${this._getCaller()}`);
			return token;
		}

		while (this._lockMeta) await this._lockMeta.lock;

				if (this._isDbg) console.warn(`Lock "${this._name || "(unnamed)"}" acquired at ${this._getCaller()}`);

		let unlock = null;
		const lock = new Promise(resolve => unlock = resolve);
		this._lockMeta = {
			lock,
			unlock,
			token: CryptUtil.uid(),
			depth: 0,
		};

		return this._lockMeta.token;
	};

	this.unlock = () => {
		if (!this._lockMeta) return;

		if (this._lockMeta.depth > 0) {
						if (this._isDbg) console.warn(`Lock "${this._name || "(unnamed)"}" sub (now ${this._lockMeta.depth - 1}) at ${this._getCaller()}`);
			return --this._lockMeta.depth;
		}

				if (this._isDbg) console.warn(`Lock "${this._name || "(unnamed)"}" released at ${this._getCaller()}`);

		const lockMeta = this._lockMeta;
		this._lockMeta = null;
		lockMeta.unlock();
	};
};
ExcludeUtil._lock = new VeLock();

globalThis.DatetimeUtil = {
	getDateStr ({date, isShort = false, isPad = false} = {}) {
		const month = DatetimeUtil._MONTHS[date.getMonth()];
		return `${isShort ? month.substring(0, 3) : month} ${isPad && date.getDate() < 10 ? "\u00A0" : ""}${Parser.getOrdinalForm(date.getDate())}, ${date.getFullYear()}`;
	},

	getDatetimeStr ({date, isPlainText = false} = {}) {
		date = date ?? new Date();
		const monthName = DatetimeUtil._MONTHS[date.getMonth()];
		return `${date.getDate()} ${!isPlainText ? `<span title="${monthName}">` : ""}${monthName.substring(0, 3)}.${!isPlainText ? `</span>` : ""} ${date.getFullYear()}, ${DatetimeUtil._getPad2(date.getHours())}:${DatetimeUtil._getPad2(date.getMinutes())}:${DatetimeUtil._getPad2(date.getSeconds())}`;
	},

	_getPad2 (num) { return `${num}`.padStart(2, "0"); },

	getIntervalStr (millis) {
		if (millis < 0 || isNaN(millis)) return "(Unknown interval)";

		const s = number => (number !== 1) ? "s" : "";

		const stack = [];

		let numSecs = Math.floor(millis / 1000);

		const numYears = Math.floor(numSecs / DatetimeUtil._SECS_PER_YEAR);
		if (numYears) {
			stack.push(`${numYears} year${s(numYears)}`);
			numSecs = numSecs - (numYears * DatetimeUtil._SECS_PER_YEAR);
		}

		const numDays = Math.floor(numSecs / DatetimeUtil._SECS_PER_DAY);
		if (numDays) {
			stack.push(`${numDays} day${s(numDays)}`);
			numSecs = numSecs - (numDays * DatetimeUtil._SECS_PER_DAY);
		}

		const numHours = Math.floor(numSecs / DatetimeUtil._SECS_PER_HOUR);
		if (numHours) {
			stack.push(`${numHours} hour${s(numHours)}`);
			numSecs = numSecs - (numHours * DatetimeUtil._SECS_PER_HOUR);
		}

		const numMinutes = Math.floor(numSecs / DatetimeUtil._SECS_PER_MINUTE);
		if (numMinutes) {
			stack.push(`${numMinutes} minute${s(numMinutes)}`);
			numSecs = numSecs - (numMinutes * DatetimeUtil._SECS_PER_MINUTE);
		}

		if (numSecs) stack.push(`${numSecs} second${s(numSecs)}`);
		else if (!stack.length) stack.push("less than a second"); 
		return stack.join(", ");
	},
};
DatetimeUtil._MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
DatetimeUtil._SECS_PER_YEAR = 31536000;
DatetimeUtil._SECS_PER_DAY = 86400;
DatetimeUtil._SECS_PER_HOUR = 3600;
DatetimeUtil._SECS_PER_MINUTE = 60;

globalThis.EditorUtil = {
	getTheme () {
		const {isNight} = styleSwitcher.getSummary();
		return isNight ? "ace/theme/tomorrow_night" : "ace/theme/textmate";
	},

	initEditor (id, additionalOpts = null) {
		additionalOpts = additionalOpts || {};

		const editor = ace.edit(id);
		editor.setOptions({
			theme: EditorUtil.getTheme(),
			wrap: true,
			showPrintMargin: false,
			tabSize: 2,
			useWorker: false,
			...additionalOpts,
		});

		styleSwitcher.addFnOnChange(() => editor.setOptions({theme: EditorUtil.getTheme()}));

		return editor;
	},
};

if (!IS_VTT && typeof window !== "undefined") {
	window.addEventListener("load", () => {
		const docRoot = document.querySelector(":root");

		if (CSS?.supports("top: constant(safe-area-inset-top)")) {
			docRoot.style.setProperty("--safe-area-inset-top", "constant(safe-area-inset-top, 0)");
			docRoot.style.setProperty("--safe-area-inset-right", "constant(safe-area-inset-right, 0)");
			docRoot.style.setProperty("--safe-area-inset-bottom", "constant(safe-area-inset-bottom, 0)");
			docRoot.style.setProperty("--safe-area-inset-left", "constant(safe-area-inset-left, 0)");
		} else if (CSS?.supports("top: env(safe-area-inset-top)")) {
			docRoot.style.setProperty("--safe-area-inset-top", "env(safe-area-inset-top, 0)");
			docRoot.style.setProperty("--safe-area-inset-right", "env(safe-area-inset-right, 0)");
			docRoot.style.setProperty("--safe-area-inset-bottom", "env(safe-area-inset-bottom, 0)");
			docRoot.style.setProperty("--safe-area-inset-left", "env(safe-area-inset-left, 0)");
		}
	});

	window.addEventListener("load", () => {
		$(document.body)
			.on("click", `[data-packed-dice]`, evt => {
				Renderer.dice.pRollerClickUseData(evt, evt.currentTarget);
			});
		Renderer.events.bindGeneric();
	});

	if (location.origin === VeCt.LOC_ORIGIN_CANCER) {
		const ivsCancer = [];

		window.addEventListener("load", () => {
			let isPadded = false;
			let anyFound = false;
			[
				"div-gpt-ad-5etools35927", 				"div-gpt-ad-5etools35930", 				"div-gpt-ad-5etools35928", 				"div-gpt-ad-5etools35929", 				"div-gpt-ad-5etools36159", 				"div-gpt-ad-5etools36834", 			].forEach(id => {
				const iv = setInterval(() => {
					const $wrp = $(`#${id}`);
					if (!$wrp.length) return;
					if (!$wrp.children().length) return;
					if ($wrp.children()[0].tagName === "SCRIPT") return;
					const $tgt = $wrp.closest(".cancer__anchor").find(".cancer__disp-cancer");
					if ($tgt.length) {
						anyFound = true;
						$tgt.css({display: "flex"}).text("Advertisements");
						clearInterval(iv);
					}
				}, 250);

				ivsCancer.push(iv);
			});

			const ivPad = setInterval(() => {
				if (!anyFound) return;
				if (isPadded) return;
				isPadded = true;
								$(`.view-col-group--cancer`).append(`<div class="w-100 no-shrink" style="height: 110px;"></div>`);
			}, 300);
			ivsCancer.push(ivPad);
		});

				setTimeout(() => {
			const $wrp = $(`.cancer__wrp-leaderboard-inner`);
			const h = $wrp.outerHeight();
			$wrp.css({height: h});
			ivsCancer.forEach(iv => clearInterval(iv));
		}, 5000);
	} else {
		window.addEventListener("load", () => $(`.cancer__anchor`).remove());
	}

				}

globalThis._Donate = {
		
		cycleLeader (ele) {
		const modes = [{width: 970, height: 90}, {width: 970, height: 250}, {width: 320, height: 50}, {width: 728, height: 90}];
		_Donate._cycleMode(ele, modes);
	},

	cycleSide (ele) {
		const modes = [{width: 300, height: 250}, {width: 300, height: 600}];
		_Donate._cycleMode(ele, modes);
	},

	_cycleMode (ele, modes) {
		const $e = $(ele);
		const pos = $e.data("pos") || 0;
		const mode = modes[pos];
		$e.css(mode);
		$e.text(`${mode.width}*${mode.height}`);
		$e.data("pos", (pos + 1) % modes.length);
	},
	};

"use strict";

class Prx {
	static addHook (prop, hook) {
		this.px._hooks[prop] = this.px._hooks[prop] || [];
		this.px._hooks[prop].push(hook);
	}

	static addHookAll (hook) {
		this.px._hooksAll.push(hook);
	}

	static toString () {
		return JSON.stringify(this, (k, v) => k === "px" ? undefined : v);
	}

	static copy () {
		return JSON.parse(Prx.toString.bind(this)());
	}

	static get (toProxy) {
		toProxy.px = {
			addHook: Prx.addHook.bind(toProxy),
			addHookAll: Prx.addHookAll.bind(toProxy),
			toString: Prx.toString.bind(toProxy),
			copy: Prx.copy.bind(toProxy),
			_hooksAll: [],
			_hooks: {},
		};

		return new Proxy(toProxy, {
			set: (object, prop, value) => {
				object[prop] = value;
				toProxy.px._hooksAll.forEach(hook => hook(prop, value));
				if (toProxy.px._hooks[prop]) toProxy.px._hooks[prop].forEach(hook => hook(prop, value));
				return true;
			},
			deleteProperty: (object, prop) => {
				delete object[prop];
				toProxy.px._hooksAll.forEach(hook => hook(prop, null));
				if (toProxy.px._hooks[prop]) toProxy.px._hooks[prop].forEach(hook => hook(prop, null));
				return true;
			},
		});
	}
}

function MixinProxyBase (Cls) {
	class MixedProxyBase extends Cls {
		constructor (...args) {
			super(...args);
			this.__hooks = {};
			this.__hooksAll = {};
			this.__hooksTmp = null;
			this.__hooksAllTmp = null;
		}

		_getProxy (hookProp, toProxy) {
			return new Proxy(toProxy, {
				set: (object, prop, value) => {
					return this._doProxySet(hookProp, object, prop, value);
				},
				deleteProperty: (object, prop) => {
					if (!(prop in object)) return true;
					const prevValue = object[prop];
					Reflect.deleteProperty(object, prop);
					this._doFireHooksAll(hookProp, prop, undefined, prevValue);
					if (this.__hooks[hookProp] && this.__hooks[hookProp][prop]) this.__hooks[hookProp][prop].forEach(hook => hook(prop, undefined, prevValue));
					return true;
				},
			});
		}

		_doProxySet (hookProp, object, prop, value) {
			if (object[prop] === value) return true;
			const prevValue = object[prop];
			Reflect.set(object, prop, value);
			this._doFireHooksAll(hookProp, prop, value, prevValue);
			this._doFireHooks(hookProp, prop, value, prevValue);
			return true;
		}

				async _pDoProxySet (hookProp, object, prop, value) {
			if (object[prop] === value) return true;
			const prevValue = object[prop];
			Reflect.set(object, prop, value);
			if (this.__hooksAll[hookProp]) for (const hook of this.__hooksAll[hookProp]) await hook(prop, value, prevValue);
			if (this.__hooks[hookProp] && this.__hooks[hookProp][prop]) for (const hook of this.__hooks[hookProp][prop]) await hook(prop, value, prevValue);
			return true;
		}

		_doFireHooks (hookProp, prop, value, prevValue) {
			if (this.__hooks[hookProp] && this.__hooks[hookProp][prop]) this.__hooks[hookProp][prop].forEach(hook => hook(prop, value, prevValue));
		}

		_doFireHooksAll (hookProp, prop, value, prevValue) {
			if (this.__hooksAll[hookProp]) this.__hooksAll[hookProp].forEach(hook => hook(prop, undefined, prevValue));
		}

		
		_doFireAllHooks (hookProp) {
			if (this.__hooks[hookProp]) Object.entries(this.__hooks[hookProp]).forEach(([prop, hk]) => hk(prop));
		}

				_addHook (hookProp, prop, hook) {
			ProxyBase$1._addHook_to(this.__hooks, hookProp, prop, hook);
			if (this.__hooksTmp) ProxyBase$1._addHook_to(this.__hooksTmp, hookProp, prop, hook);
			return hook;
		}

		static _addHook_to (obj, hookProp, prop, hook) {
			((obj[hookProp] = obj[hookProp] || {})[prop] = (obj[hookProp][prop] || [])).push(hook);
		}

		_addHookAll (hookProp, hook) {
			ProxyBase$1._addHookAll_to(this.__hooksAll, hookProp, hook);
			if (this.__hooksAllTmp) ProxyBase$1._addHookAll_to(this.__hooksAllTmp, hookProp, hook);
		}

		static _addHookAll_to (obj, hookProp, hook) {
			(obj[hookProp] = obj[hookProp] || []).push(hook);
		}

		_removeHook (hookProp, prop, hook) {
			ProxyBase$1._removeHook_from(this.__hooks, hookProp, prop, hook);
			if (this.__hooksTmp) ProxyBase$1._removeHook_from(this.__hooksTmp, hookProp, prop, hook);
		}

		static _removeHook_from (obj, hookProp, prop, hook) {
			if (obj[hookProp] && obj[hookProp][prop]) {
				const ix = obj[hookProp][prop].findIndex(hk => hk === hook);
				if (~ix) obj[hookProp][prop].splice(ix, 1);
			}
		}

		_removeHooks (hookProp, prop) {
			if (this.__hooks[hookProp]) delete this.__hooks[hookProp][prop];
			if (this.__hooksTmp && this.__hooksTmp[hookProp]) delete this.__hooksTmp[hookProp][prop];
		}

		_removeHookAll (hookProp, hook) {
			ProxyBase$1._removeHookAll_from(this.__hooksAll, hookProp, hook);
			if (this.__hooksAllTmp) ProxyBase$1._removeHook_from(this.__hooksAllTmp, hookProp, hook);
		}

		static _removeHookAll_from (obj, hookProp, hook) {
			if (obj[hookProp]) {
				const ix = obj[hookProp].findIndex(hk => hk === hook);
				if (~ix) obj[hookProp].splice(ix, 1);
			}
		}

		_resetHooks (hookProp) {
			if (hookProp !== undefined) delete this.__hooks[hookProp];
			else Object.keys(this.__hooks).forEach(prop => delete this.__hooks[prop]);
		}

		_resetHooksAll (hookProp) {
			if (hookProp !== undefined) delete this.__hooksAll[hookProp];
			else Object.keys(this.__hooksAll).forEach(prop => delete this.__hooksAll[prop]);
		}

		_saveHookCopiesTo (obj) { this.__hooksTmp = obj; }
		_saveHookAllCopiesTo (obj) { this.__hooksAllTmp = obj; }

				_proxyAssign (hookProp, proxyProp, underProp, toObj, isOverwrite) {
			const oldKeys = Object.keys(this[proxyProp]);
			const nuKeys = new Set(Object.keys(toObj));
			const dirtyKeyValues = {};

			if (isOverwrite) {
				oldKeys.forEach(k => {
					if (!nuKeys.has(k) && this[underProp] !== undefined) {
						const prevValue = this[proxyProp][k];
						delete this[underProp][k];
						dirtyKeyValues[k] = prevValue;
					}
				});
			}

			nuKeys.forEach(k => {
				if (!CollectionUtil.deepEquals(this[underProp][k], toObj[k])) {
					const prevValue = this[proxyProp][k];
					this[underProp][k] = toObj[k];
					dirtyKeyValues[k] = prevValue;
				}
			});

			Object.entries(dirtyKeyValues)
				.forEach(([k, prevValue]) => {
					this._doFireHooksAll(hookProp, k, this[underProp][k], prevValue);
					if (this.__hooks[hookProp] && this.__hooks[hookProp][k]) this.__hooks[hookProp][k].forEach(hk => hk(k, this[underProp][k], prevValue));
				});
		}

		_proxyAssignSimple (hookProp, toObj, isOverwrite) {
			return this._proxyAssign(hookProp, `_${hookProp}`, `__${hookProp}`, toObj, isOverwrite);
		}
	}

	return MixedProxyBase;
}

let ProxyBase$1 = class ProxyBase extends MixinProxyBase(class {}) {};

globalThis.ProxyBase = ProxyBase$1;

let UiUtil$1 = class UiUtil {
		static strToInt (string, fallbackEmpty = 0, opts) { return UiUtil$1._strToNumber(string, fallbackEmpty, opts, true); }

		static strToNumber (string, fallbackEmpty = 0, opts) { return UiUtil$1._strToNumber(string, fallbackEmpty, opts, false); }

	static _strToNumber (string, fallbackEmpty = 0, opts, isInt) {
		opts = opts || {};
		let out;
		string = string.trim();
		if (!string) out = fallbackEmpty;
		else {
			const num = UiUtil$1._parseStrAsNumber(string, isInt);
			out = isNaN(num) || !isFinite(num)
				? opts.fallbackOnNaN !== undefined ? opts.fallbackOnNaN : 0
				: num;
		}
		if (opts.max != null) out = Math.min(out, opts.max);
		if (opts.min != null) out = Math.max(out, opts.min);
		return out;
	}

		static strToBool (string, fallbackEmpty = null, opts) {
		opts = opts || {};
		if (!string) return fallbackEmpty;
		string = string.trim().toLowerCase();
		if (!string) return fallbackEmpty;
		return string === "true" ? true : string === "false" ? false : opts.fallbackOnNaB;
	}

	static intToBonus (int, {isPretty = false} = {}) { return `${int >= 0 ? "+" : int < 0 ? (isPretty ? "\u2012" : "-") : ""}${Math.abs(int)}`; }

	static getEntriesAsText (entryArray) {
		if (!entryArray || !entryArray.length) return "";
		if (!(entryArray instanceof Array)) return UiUtil$1.getEntriesAsText([entryArray]);

		return entryArray
			.map(it => {
				if (typeof it === "string" || typeof it === "number") return it;

				return JSON.stringify(it, null, 2)
					.split("\n")
					.map(it => `  ${it}`) 				;
			})
			.flat()
			.join("\n");
	}

	static getTextAsEntries (text) {
		try {
			const lines = text
				.split("\n")
				.filter(it => it.trim())
				.map(it => {
					if (/^\s/.exec(it)) return it; 					return `"${it.replace(/"/g, `\\"`)}",`; 				})
				.map(it => {
					if (/[}\]]$/.test(it.trim())) return `${it},`; 					return it;
				});
			const json = `[\n${lines.join("")}\n]`
								.replace(/(.*?)(,)(:?\s*]|\s*})/g, "$1$3");
			return JSON.parse(json);
		} catch (e) {
			const lines = text.split("\n").filter(it => it.trim());
			const slice = lines.join(" \\ ").substring(0, 30);
			JqueryUtil.doToast({
				content: `Could not parse entries! Error was: ${e.message}<br>Text was: ${slice}${slice.length === 30 ? "..." : ""}`,
				type: "danger",
			});
			return lines;
		}
	}

		static getShowModal (opts) {
		opts = opts || {};

		const doc = (opts.window || window).document;

		UiUtil$1._initModalEscapeHandler({doc});
		UiUtil$1._initModalMouseupHandlers({doc});
		if (doc.activeElement) doc.activeElement.blur(); 
		let resolveModal;
		const pResolveModal = new Promise(resolve => { resolveModal = resolve; });

				const pHandleCloseClick = async (isDataEntered, ...args) => {
			if (opts.cbClose) await opts.cbClose(isDataEntered, ...args);
			resolveModal([isDataEntered, ...args]);

			if (opts.isIndestructible) wrpOverlay.detach();
			else wrpOverlay.remove();

			doTeardown();
		};

		const doTeardown = () => {
			UiUtil$1._popFromModalStack(modalStackMeta);
			if (!UiUtil$1._MODAL_STACK.length) doc.body.classList.remove(`ui-modal__body-active`);
		};

		const doOpen = () => {
			wrpOverlay.appendTo(doc.body);
			doc.body.classList.add(`ui-modal__body-active`);
		};

		const wrpOverlay = e_({tag: "div", clazz: "ui-modal__overlay"});
		if (opts.zIndex != null) wrpOverlay.style.zIndex = `${opts.zIndex}`;
		if (opts.overlayColor != null) wrpOverlay.style.backgroundColor = `${opts.overlayColor}`;

				const overlayBlind = opts.isFullscreenModal
			? e_({
				tag: "div",
				clazz: `ui-modal__overlay-blind w-100 h-100 ve-flex-col`,
			}).appendTo(wrpOverlay)
			: null;

		const wrpScroller = e_({
			tag: "div",
			clazz: `ui-modal__scroller ve-flex-col`,
		});

		const modalWindowClasses = [
			opts.isWidth100 ? `w-100` : "",
			opts.isHeight100 ? "h-100" : "",
			opts.isUncappedHeight ? "ui-modal__inner--uncap-height" : "",
			opts.isUncappedWidth ? "ui-modal__inner--uncap-width" : "",
			opts.isMinHeight0 ? `ui-modal__inner--no-min-height` : "",
			opts.isMaxWidth640p ? `ui-modal__inner--max-width-640p` : "",
			opts.isFullscreenModal ? `ui-modal__inner--mode-fullscreen my-0 pt-0` : "",
			opts.hasFooter ? `pb-0` : "",
		].filter(Boolean);

		const btnCloseModal = opts.isFullscreenModal ? e_({
			tag: "button",
			clazz: `btn btn-danger btn-xs`,
			html: `<span class="glyphicon glyphicon-remove></span>`,
			click: pHandleCloseClick(false),
		}) : null;

		const modalFooter = opts.hasFooter
			? e_({
				tag: "div",
				clazz: `"no-shrink w-100 ve-flex-col ui-modal__footer ${opts.isFullscreenModal ? `ui-modal__footer--fullscreen mt-1` : ""}`,
			})
			: null;

		const modal = e_({
			tag: "div",
			clazz: `ui-modal__inner ve-flex-col ${modalWindowClasses.join(" ")}`,
			children: [
				!opts.isEmpty && opts.title
					? e_({
						tag: "div",
						clazz: `split-v-center no-shrink ${opts.isHeaderBorder ? `ui-modal__header--border` : ""} ${opts.isFullscreenModal ? `ui-modal__header--fullscreen mb-1` : ""}`,
						children: [
							opts.title
								? e_({
									tag: "h4",
									clazz: `my-2`,
									html: opts.title.qq(),
								})
								: null,

							opts.$titleSplit ? opts.$titleSplit[0] : null,

							btnCloseModal,
						].filter(Boolean),
					})
					: null,

				!opts.isEmpty ? wrpScroller : null,

				modalFooter,
			].filter(Boolean),
		}).appendTo(opts.isFullscreenModal ? overlayBlind : wrpOverlay);

		wrpOverlay
			.addEventListener("mouseup", evt => {
				if (evt.target !== wrpOverlay) return;
				if (evt.target !== UiUtil$1._MODAL_LAST_MOUSEDOWN) return;
				if (opts.isPermanent) return;
				evt.stopPropagation();
				evt.preventDefault();
				return pHandleCloseClick(false);
			});

		if (!opts.isClosed) doOpen();

		const modalStackMeta = {
			isPermanent: opts.isPermanent,
			pHandleCloseClick,
			doTeardown,
		};
		if (!opts.isClosed) UiUtil$1._pushToModalStack(modalStackMeta);

		const out = {
			$modal: $(modal),
			$modalInner: $(wrpScroller),
			$modalFooter: $(modalFooter),
			doClose: pHandleCloseClick,
			doTeardown,
			pGetResolved: () => pResolveModal,
		};

		if (opts.isIndestructible || opts.isClosed) {
			out.doOpen = () => {
				UiUtil$1._pushToModalStack(modalStackMeta);
				doOpen();
			};
		}

		return out;
	}

		static async pGetShowModal (opts) {
		return UiUtil$1.getShowModal(opts);
	}

	static _pushToModalStack (modalStackMeta) {
		if (!UiUtil$1._MODAL_STACK.includes(modalStackMeta)) {
			UiUtil$1._MODAL_STACK.push(modalStackMeta);
		}
	}

	static _popFromModalStack (modalStackMeta) {
		const ixStack = UiUtil$1._MODAL_STACK.indexOf(modalStackMeta);
		if (~ixStack) UiUtil$1._MODAL_STACK.splice(ixStack, 1);
	}

	static _initModalEscapeHandler ({doc}) {
		if (UiUtil$1._MODAL_STACK) return;
		UiUtil$1._MODAL_STACK = [];

		doc.addEventListener("keydown", evt => {
			if (evt.which !== 27) return;
			if (!UiUtil$1._MODAL_STACK.length) return;
			if (EventUtil.isInInput(evt)) return;

			const outerModalMeta = UiUtil$1._MODAL_STACK.last();
			if (!outerModalMeta) return;
			evt.stopPropagation();
			if (!outerModalMeta.isPermanent) return outerModalMeta.pHandleCloseClick(false);
		});
	}

	static _initModalMouseupHandlers ({doc}) {
		doc.addEventListener("mousedown", evt => {
			UiUtil$1._MODAL_LAST_MOUSEDOWN = evt.target;
		});
	}

	static isAnyModalOpen () {
		return !!UiUtil$1._MODAL_STACK?.length;
	}

	static addModalSep ($modalInner) {
		$modalInner.append(`<hr class="ui-modal__row-sep">`);
	}

	static $getAddModalRow ($modalInner, tag = "div") {
		return $(`<${tag} class="ui-modal__row"></${tag}>`).appendTo($modalInner);
	}

		static $getAddModalRowHeader ($modalInner, headerText, opts) {
		opts = opts || {};
		const $row = UiUtil$1.$getAddModalRow($modalInner, "h5").addClass("bold");
		if (opts.$eleRhs) $$`<div class="split ve-flex-v-center w-100 pr-1"><span>${headerText}</span>${opts.$eleRhs}</div>`.appendTo($row);
		else $row.text(headerText);
		if (opts.helpText) $row.title(opts.helpText);
		return $row;
	}

	static $getAddModalRowCb ($modalInner, labelText, objectWithProp, propName, helpText) {
		const $row = UiUtil$1.$getAddModalRow($modalInner, "label").addClass(`ui-modal__row--cb`);
		if (helpText) $row.title(helpText);
		$row.append(`<span>${labelText}</span>`);
		const $cb = $(`<input type="checkbox">`).appendTo($row)
			.keydown(evt => {
				if (evt.key === "Escape") $cb.blur();
			})
			.prop("checked", objectWithProp[propName])
			.on("change", () => objectWithProp[propName] = $cb.prop("checked"));
		return $cb;
	}

		static $getAddModalRowSel ($modalInner, labelText, objectWithProp, propName, values, opts) {
		opts = opts || {};
		const $row = UiUtil$1.$getAddModalRow($modalInner, "label").addClass(`ui-modal__row--sel`);
		if (opts.helpText) $row.title(opts.helpText);
		$row.append(`<span>${labelText}</span>`);
		const $sel = $(`<select class="form-control input-xs w-30">`).appendTo($row);
		values.forEach((val, i) => $(`<option value="${i}"></option>`).text(opts.fnDisplay ? opts.fnDisplay(val) : val).appendTo($sel));
				const ix = values.indexOf(objectWithProp[propName]);
		$sel.val(`${~ix ? ix : 0}`)
			.change(() => objectWithProp[propName] = values[$sel.val()]);
		return $sel;
	}

	static _parseStrAsNumber (str, isInt) {
		const wrpTree = Renderer.dice.lang.getTree3(str);
		if (!wrpTree) return NaN;
		const out = wrpTree.tree.evl({});
		if (!isNaN(out) && isInt) return Math.round(out);
		return out;
	}

	static bindTypingEnd ({$ipt, fnKeyup, fnKeypress, fnKeydown, fnClick} = {}) {
		let timerTyping;
		$ipt
			.on("keyup search paste", evt => {
				clearTimeout(timerTyping);
				timerTyping = setTimeout(() => { fnKeyup(evt); }, UiUtil$1.TYPE_TIMEOUT_MS);
			})
									.on("blur", evt => {
				clearTimeout(timerTyping);
				fnKeyup(evt);
			})
			.on("keypress", evt => {
				if (fnKeypress) fnKeypress(evt);
			})
			.on("keydown", evt => {
				if (fnKeydown) fnKeydown(evt);
				clearTimeout(timerTyping);
			})
			.on("click", () => {
				if (fnClick) fnClick();
			})
			.on("instantKeyup", () => {
				clearTimeout(timerTyping);
				fnKeyup();
			})
		;
	}

		static async pDoForceFocus (ele, {timeout = 250} = {}) {
		if (!ele) return;
		ele.focus();

		const forceFocusStart = Date.now();
		while ((Date.now() < forceFocusStart + timeout) && document.activeElement !== ele) {
			await MiscUtil.pDelay(33);
			ele.focus();
		}
	}
};
UiUtil$1.SEARCH_RESULTS_CAP = 75;
UiUtil$1.TYPE_TIMEOUT_MS = 100; UiUtil$1._MODAL_STACK = null;
UiUtil$1._MODAL_LAST_MOUSEDOWN = null;

let ListSelectClickHandlerBase$1 = class ListSelectClickHandlerBase {
	static _EVT_PASS_THOUGH_TAGS = new Set(["A", "BUTTON"]);

	constructor () {
		this._firstSelection = null;
		this._lastSelection = null;

		this._selectionInitialValue = null;
	}

		get _visibleItems () { throw new Error("Unimplemented!"); }

		get _allItems () { throw new Error("Unimplemented!"); }

		_getCb (item, opts) { throw new Error("Unimplemented!"); }

		_setCheckbox (item, opts) { throw new Error("Unimplemented!"); }

		_setHighlighted (item, opts) { throw new Error("Unimplemented!"); }

		handleSelectClick (item, evt, opts) {
		opts = opts || {};

		if (opts.isPassThroughEvents) {
			const evtPath = evt.composedPath();
			const subEles = evtPath.slice(0, evtPath.indexOf(evt.currentTarget));
			if (subEles.some(ele => this.constructor._EVT_PASS_THOUGH_TAGS.has(ele?.tagName))) return;
		}

		evt.preventDefault();
		evt.stopPropagation();

		const cb = this._getCb(item, opts);
		if (cb.disabled) return true;

		if (evt && evt.shiftKey && this._firstSelection) {
			if (this._lastSelection === item) {
				
				this._setCheckbox(item, {...opts, toVal: !cb.checked});
			} else if (this._firstSelection === item && this._lastSelection) {
				
				const ix1 = this._visibleItems.indexOf(this._firstSelection);
				const ix2 = this._visibleItems.indexOf(this._lastSelection);

				const [ixStart, ixEnd] = [ix1, ix2].sort(SortUtil.ascSort);
				for (let i = ixStart; i <= ixEnd; ++i) {
					const it = this._visibleItems[i];
					this._setCheckbox(it, {...opts, toVal: false});
				}

				this._setCheckbox(item, opts);
			} else {
								this._selectionInitialValue = this._getCb(this._firstSelection, opts).checked;

				const ix1 = this._visibleItems.indexOf(this._firstSelection);
				const ix2 = this._visibleItems.indexOf(item);
				const ix2Prev = this._lastSelection ? this._visibleItems.indexOf(this._lastSelection) : null;

				const [ixStart, ixEnd] = [ix1, ix2].sort(SortUtil.ascSort);
				const nxtOpts = {...opts, toVal: this._selectionInitialValue};
				for (let i = ixStart; i <= ixEnd; ++i) {
					const it = this._visibleItems[i];
					this._setCheckbox(it, nxtOpts);
				}

								if (this._selectionInitialValue && ix2Prev != null) {
					if (ix2Prev > ixEnd) {
						const nxtOpts = {...opts, toVal: !this._selectionInitialValue};
						for (let i = ixEnd + 1; i <= ix2Prev; ++i) {
							const it = this._visibleItems[i];
							this._setCheckbox(it, nxtOpts);
						}
					} else if (ix2Prev < ixStart) {
						const nxtOpts = {...opts, toVal: !this._selectionInitialValue};
						for (let i = ix2Prev; i < ixStart; ++i) {
							const it = this._visibleItems[i];
							this._setCheckbox(it, nxtOpts);
						}
					}
				}
			}

			this._lastSelection = item;
		} else {
			
			const cbMaster = this._getCb(item, opts);
			if (cbMaster) {
				cbMaster.checked = !cbMaster.checked;

				if (opts.fnOnSelectionChange) opts.fnOnSelectionChange(item, cbMaster.checked);

				if (!opts.isNoHighlightSelection) {
					this._setHighlighted(item, cbMaster.checked);
				}
			} else {
				if (!opts.isNoHighlightSelection) {
					this._setHighlighted(item, false);
				}
			}

			this._firstSelection = item;
			this._lastSelection = null;
			this._selectionInitialValue = null;
		}
	}

		handleSelectClickRadio (item, evt) {
		evt.preventDefault();
		evt.stopPropagation();

		this._allItems.forEach(itemOther => {
			const cb = this._getCb(itemOther);

			if (itemOther === item) {
																cb.checked = true;
				this._setHighlighted(itemOther, true);
			} else {
				cb.checked = false;
				this._setHighlighted(itemOther, false);
			}
		});
	}
};

globalThis.ListSelectClickHandlerBase = ListSelectClickHandlerBase$1;

let ListSelectClickHandler$1 = class ListSelectClickHandler extends ListSelectClickHandlerBase$1 {
	constructor ({list}) {
		super();
		this._list = list;
	}

	get _visibleItems () { return this._list.visibleItems; }

	get _allItems () { return this._list.items; }

	_getCb (item, opts = {}) { return opts.fnGetCb ? opts.fnGetCb(item) : item.data.cbSel; }

	_setCheckbox (item, opts = {}) { return this.setCheckbox(item, opts); }

	_setHighlighted (item, isHighlighted) {
		if (isHighlighted) item.ele instanceof $ ? item.ele.addClass("list-multi-selected") : item.ele.classList.add("list-multi-selected");
		else item.ele instanceof $ ? item.ele.removeClass("list-multi-selected") : item.ele.classList.remove("list-multi-selected");
	}

	
	setCheckbox (item, {fnGetCb, fnOnSelectionChange, isNoHighlightSelection, toVal = true} = {}) {
		const cbSlave = this._getCb(item, {fnGetCb, fnOnSelectionChange, isNoHighlightSelection});

		if (cbSlave?.disabled) return;

		if (cbSlave) {
			cbSlave.checked = toVal;
			if (fnOnSelectionChange) fnOnSelectionChange(item, toVal);
		}

		if (isNoHighlightSelection) return;

		this._setHighlighted(item, toVal);
	}

		bindSelectAllCheckbox ($cbAll) {
		$cbAll.change(() => {
			const isChecked = $cbAll.prop("checked");
			this.setCheckboxes({isChecked});
		});
	}

	setCheckboxes ({isChecked, isIncludeHidden}) {
		(isIncludeHidden ? this._list.items : this._list.visibleItems)
			.forEach(item => {
				if (item.data.cbSel?.disabled) return;

				if (item.data.cbSel) item.data.cbSel.checked = isChecked;

				this._setHighlighted(item, isChecked);
			});
	}
};

globalThis.ListSelectClickHandler = ListSelectClickHandler$1;

let ListUiUtil$1 = class ListUiUtil {
	static bindPreviewButton (page, allData, item, btnShowHidePreview, {$fnGetPreviewStats} = {}) {
		btnShowHidePreview.addEventListener("click", evt => {
			const entity = allData[item.ix];
			page = page || entity?.__prop;

			const elePreviewWrp = this.getOrAddListItemPreviewLazy(item);

			this.handleClickBtnShowHideListPreview(evt, page, entity, btnShowHidePreview, elePreviewWrp, {$fnGetPreviewStats});
		});
	}

	static handleClickBtnShowHideListPreview (evt, page, entity, btnShowHidePreview, elePreviewWrp, {nxtText = null, $fnGetPreviewStats} = {}) {
		evt.stopPropagation();
		evt.preventDefault();

		nxtText = nxtText ?? btnShowHidePreview.innerHTML.trim() === this.HTML_GLYPHICON_EXPAND ? this.HTML_GLYPHICON_CONTRACT : this.HTML_GLYPHICON_EXPAND;
		const isHidden = nxtText === this.HTML_GLYPHICON_EXPAND;
		const isFluff = !!evt.shiftKey;

		elePreviewWrp.classList.toggle("ve-hidden", isHidden);
		btnShowHidePreview.innerHTML = nxtText;

		const elePreviewWrpInner = elePreviewWrp.lastElementChild;

		const isForce = (elePreviewWrp.dataset.dataType === "stats" && isFluff) || (elePreviewWrp.dataset.dataType === "fluff" && !isFluff);
		if (!isForce && elePreviewWrpInner.innerHTML) return;

		$(elePreviewWrpInner).empty().off("click").on("click", evt => { evt.stopPropagation(); });

		if (isHidden) return;

		elePreviewWrp.dataset.dataType = isFluff ? "fluff" : "stats";

		const doAppendStatView = () => ($fnGetPreviewStats || Renderer.hover.$getHoverContent_stats)(page, entity, {isStatic: true}).appendTo(elePreviewWrpInner);

		if (!evt.shiftKey || !UrlUtil.URL_TO_HASH_BUILDER[page]) {
			doAppendStatView();
			return;
		}

		Renderer.hover.pGetHoverableFluff(page, entity.source, UrlUtil.URL_TO_HASH_BUILDER[page](entity))
			.then(fluffEntity => {
												if (elePreviewWrpInner.innerHTML) return;

				if (!fluffEntity) return doAppendStatView();
				Renderer.hover.$getHoverContent_fluff(page, fluffEntity).appendTo(elePreviewWrpInner);
			});
	}

	static getOrAddListItemPreviewLazy (item) {
				let elePreviewWrp;
		if (item.ele.children.length === 1) {
			elePreviewWrp = e_({
				ag: "div",
				clazz: "ve-hidden ve-flex",
				children: [
					e_({tag: "div", clazz: "col-0-5"}),
					e_({tag: "div", clazz: "col-11-5 ui-list__wrp-preview py-2 pr-2"}),
				],
			}).appendTo(item.ele);
		} else elePreviewWrp = item.ele.lastElementChild;
		return elePreviewWrp;
	}

	static bindPreviewAllButton ($btnAll, list) {
		$btnAll
			.click(async () => {
				const nxtHtml = $btnAll.html() === ListUiUtil$1.HTML_GLYPHICON_EXPAND
					? ListUiUtil$1.HTML_GLYPHICON_CONTRACT
					: ListUiUtil$1.HTML_GLYPHICON_EXPAND;

				if (nxtHtml === ListUiUtil$1.HTML_GLYPHICON_CONTRACT && list.visibleItems.length > 500) {
					const isSure = await InputUiUtil$1.pGetUserBoolean({
						title: "Are You Sure?",
						htmlDescription: `You are about to expand ${list.visibleItems.length} rows. This may seriously degrade performance.<br>Are you sure you want to continue?`,
					});
					if (!isSure) return;
				}

				$btnAll.html(nxtHtml);

				list.visibleItems.forEach(listItem => {
					if (listItem.data.btnShowHidePreview.innerHTML !== nxtHtml) listItem.data.btnShowHidePreview.click();
				});
			});
	}

	
	static ListSyntax = class {
		static _READONLY_WALKER = null;

		constructor (
			{
				fnGetDataList,
				pFnGetFluff,
			},
		) {
			this._fnGetDataList = fnGetDataList;
			this._pFnGetFluff = pFnGetFluff;
		}

		get _dataList () { return this._fnGetDataList(); }

		build () {
			return {
				stats: {
					help: `"stats:<text>" ("/text/" for regex) to search within stat blocks.`,
					fn: (listItem, searchTerm) => {
						if (listItem.data._textCacheStats == null) listItem.data._textCacheStats = this._getSearchCacheStats(this._dataList[listItem.ix]);
						return this._listSyntax_isTextMatch(listItem.data._textCacheStats, searchTerm);
					},
				},
				info: {
					help: `"info:<text>" ("/text/" for regex) to search within info.`,
					fn: async (listItem, searchTerm) => {
						if (listItem.data._textCacheFluff == null) listItem.data._textCacheFluff = await this._pGetSearchCacheFluff(this._dataList[listItem.ix]);
						return this._listSyntax_isTextMatch(listItem.data._textCacheFluff, searchTerm);
					},
					isAsync: true,
				},
				text: {
					help: `"text:<text>" ("/text/" for regex) to search within stat blocks plus info.`,
					fn: async (listItem, searchTerm) => {
						if (listItem.data._textCacheAll == null) {
							const {textCacheStats, textCacheFluff, textCacheAll} = await this._pGetSearchCacheAll(this._dataList[listItem.ix], {textCacheStats: listItem.data._textCacheStats, textCacheFluff: listItem.data._textCacheFluff});
							listItem.data._textCacheStats = listItem.data._textCacheStats || textCacheStats;
							listItem.data._textCacheFluff = listItem.data._textCacheFluff || textCacheFluff;
							listItem.data._textCacheAll = textCacheAll;
						}
						return this._listSyntax_isTextMatch(listItem.data._textCacheAll, searchTerm);
					},
					isAsync: true,
				},
			};
		}

		_listSyntax_isTextMatch (str, searchTerm) {
			if (!str) return false;
			if (searchTerm instanceof RegExp) return searchTerm.test(str);
			return str.includes(searchTerm);
		}

						_getSearchCacheStats (entity) {
			return this._getSearchCache_entries(entity);
		}

		static _INDEXABLE_PROPS_ENTRIES = [
			"entries",
		];

		_getSearchCache_entries (entity, {indexableProps = null} = {}) {
			if ((indexableProps || this.constructor._INDEXABLE_PROPS_ENTRIES).every(it => !entity[it])) return "";
			const ptrOut = {_: ""};
			(indexableProps || this.constructor._INDEXABLE_PROPS_ENTRIES).forEach(it => this._getSearchCache_handleEntryProp(entity, it, ptrOut));
			return ptrOut._;
		}

		_getSearchCache_handleEntryProp (entity, prop, ptrOut) {
			if (!entity[prop]) return;

			this.constructor._READONLY_WALKER = this.constructor._READONLY_WALKER || MiscUtil.getWalker({
				keyBlocklist: new Set(["type", "colStyles", "style"]),
				isNoModification: true,
			});

			this.constructor._READONLY_WALKER.walk(
				entity[prop],
				{
					string: (str) => this._getSearchCache_handleString(ptrOut, str),
				},
			);
		}

		_getSearchCache_handleString (ptrOut, str) {
			ptrOut._ += `${Renderer.stripTags(str).toLowerCase()} -- `;
		}

		async _pGetSearchCacheFluff (entity) {
			const fluff = this._pFnGetFluff ? await this._pFnGetFluff(entity) : null;
			return fluff ? this._getSearchCache_entries(fluff, {indexableProps: ["entries"]}) : "";
		}

		async _pGetSearchCacheAll (entity, {textCacheStats = null, textCacheFluff = null}) {
			textCacheStats = textCacheStats || this._getSearchCacheStats(entity);
			textCacheFluff = textCacheFluff || await this._pGetSearchCacheFluff(entity);
			return {
				textCacheStats,
				textCacheFluff,
				textCacheAll: [textCacheStats, textCacheFluff].filter(Boolean).join(" -- "),
			};
		}
	};

	};
ListUiUtil$1.HTML_GLYPHICON_EXPAND = `[+]`;
ListUiUtil$1.HTML_GLYPHICON_CONTRACT = `[\u2012]`;

globalThis.ListUiUtil = ListUiUtil$1;

class ProfUiUtil {
		static getProfCycler (state = 0, opts) {
		opts = opts || {};

		const STATES = opts.isSimple ? Object.keys(ProfUiUtil.PROF_TO_FULL).slice(0, 2) : Object.keys(ProfUiUtil.PROF_TO_FULL);

		const NUM_STATES = Object.keys(STATES).length;

				state = Number(state) || 0;
		if (state >= NUM_STATES) state = NUM_STATES - 1;
		else if (state < 0) state = 0;

		const $btnCycle = $(`<button class="ui-prof__btn-cycle"></button>`)
			.click(() => {
				$btnCycle
					.attr("data-state", ++state >= NUM_STATES ? state = 0 : state)
					.title(ProfUiUtil.PROF_TO_FULL[state].name)
					.trigger("change");
			})
			.contextmenu(evt => {
				evt.preventDefault();
				$btnCycle
					.attr("data-state", --state < 0 ? state = NUM_STATES - 1 : state)
					.title(ProfUiUtil.PROF_TO_FULL[state].name)
					.trigger("change");
			});
		const setState = (nuState) => {
			state = nuState;
			if (state > NUM_STATES) state = 0;
			else if (state < 0) state = NUM_STATES - 1;
			$btnCycle.attr("data-state", state).title(ProfUiUtil.PROF_TO_FULL[state].name);
		};
		return {
			$ele: $btnCycle,
			setState,
			getState: () => state,
		};
	}
}
ProfUiUtil.PROF_TO_FULL = {
	"0": {
		name: "No proficiency",
		mult: 0,
	},
	"1": {
		name: "Proficiency",
		mult: 1,
	},
	"2": {
		name: "Expertise",
		mult: 2,
	},
	"3": {
		name: "Half proficiency",
		mult: 0.5,
	},
};

class TabUiUtilBase {
	static decorate (obj, {isInitMeta = false} = {}) {
		if (isInitMeta) {
			obj.__meta = {};
			obj._meta = obj._getProxy("meta", obj.__meta);
		}

		obj.__tabState = {};

		obj._getTabProps = function ({propProxy = TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup = TabUiUtilBase._DEFAULT_TAB_GROUP} = {}) {
			return {
				propProxy,
				_propProxy: `_${propProxy}`,
				__propProxy: `__${propProxy}`,
				propActive: `ixActiveTab__${tabGroup}`,
			};
		};

				obj._renderTabs = function (tabMetas, {$parent, propProxy = TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup = TabUiUtilBase._DEFAULT_TAB_GROUP, cbTabChange, additionalClassesWrpHeads} = {}) {
			if (!tabMetas.length) throw new Error(`One or more tab meta must be specified!`);
			obj._resetTabs({tabGroup});

			const isSingleTab = tabMetas.length === 1;

			const {propActive, _propProxy, __propProxy} = obj._getTabProps({propProxy, tabGroup});

			this[__propProxy][propActive] = this[__propProxy][propActive] || 0;

			const $dispTabTitle = obj.__$getDispTabTitle({isSingleTab});

			const renderTabMetas_standard = (it, i) => {
				const $btnTab = obj.__$getBtnTab({
					isSingleTab,
					tabMeta: it,
					_propProxy,
					propActive,
					ixTab: i,
				});

				const $wrpTab = obj.__$getWrpTab({tabMeta: it, ixTab: i});

				return {
					...it,
					ix: i,
					$btnTab,
					$wrpTab,
				};
			};

			const tabMetasOut = tabMetas.map((it, i) => {
				if (it.type) return obj.__renderTypedTabMeta({tabMeta: it, ixTab: i});
				return renderTabMetas_standard(it, i);
			}).filter(Boolean);

			if ($parent) obj.__renderTabs_addToParent({$dispTabTitle, $parent, tabMetasOut, additionalClassesWrpHeads});

			const hkActiveTab = () => {
				tabMetasOut.forEach(it => {
					if (it.type) return; 
					const isActive = it.ix === this[_propProxy][propActive];
					if (isActive && $dispTabTitle) $dispTabTitle.text(isSingleTab ? "" : it.name);
					if (it.$btnTab) it.$btnTab.toggleClass("active", isActive);
					it.$wrpTab.toggleVe(isActive);
				});

				if (cbTabChange) cbTabChange();
			};
			this._addHook(propProxy, propActive, hkActiveTab);
			hkActiveTab();

			obj.__tabState[tabGroup] = {
				fnReset: () => {
					this._removeHook(propProxy, propActive, hkActiveTab);
				},
				tabMetasOut,
			};

			return tabMetasOut;
		};

		obj.__renderTabs_addToParent = function ({$dispTabTitle, $parent, tabMetasOut, additionalClassesWrpHeads}) {
			const hasBorder = tabMetasOut.some(it => it.hasBorder);
			$$`<div class="ve-flex-col w-100 h-100">
				${$dispTabTitle}
				<div class="ve-flex-col w-100 h-100 min-h-0">
					<div class="ve-flex ${hasBorder ? `ui-tab__wrp-tab-heads--border` : ""} ${additionalClassesWrpHeads || ""}">${tabMetasOut.map(it => it.$btnTab)}</div>
					<div class="ve-flex w-100 h-100 min-h-0">${tabMetasOut.map(it => it.$wrpTab).filter(Boolean)}</div>
				</div>
			</div>`.appendTo($parent);
		};

		obj._resetTabs = function ({tabGroup = TabUiUtilBase._DEFAULT_TAB_GROUP} = {}) {
			if (!obj.__tabState[tabGroup]) return;
			obj.__tabState[tabGroup].fnReset();
			delete obj.__tabState[tabGroup];
		};

		obj._hasPrevTab = function ({propProxy = TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup = TabUiUtilBase._DEFAULT_TAB_GROUP} = {}) {
			return obj.__hasTab({propProxy, tabGroup, offset: -1});
		};
		obj._hasNextTab = function ({propProxy = TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup = TabUiUtilBase._DEFAULT_TAB_GROUP} = {}) {
			return obj.__hasTab({propProxy, tabGroup, offset: 1});
		};

		obj.__hasTab = function ({propProxy = TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup = TabUiUtilBase._DEFAULT_TAB_GROUP, offset}) {
			const {propActive, _propProxy} = obj._getTabProps({propProxy, tabGroup});
			const ixActive = obj[_propProxy][propActive];
			return !!(obj.__tabState[tabGroup]?.tabMetasOut && obj.__tabState[tabGroup]?.tabMetasOut[ixActive + offset]);
		};

		obj._doSwitchToPrevTab = function ({propProxy = TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup = TabUiUtilBase._DEFAULT_TAB_GROUP} = {}) {
			return obj.__doSwitchToTab({propProxy, tabGroup, offset: -1});
		};
		obj._doSwitchToNextTab = function ({propProxy = TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup = TabUiUtilBase._DEFAULT_TAB_GROUP} = {}) {
			return obj.__doSwitchToTab({propProxy, tabGroup, offset: 1});
		};

		obj.__doSwitchToTab = function ({propProxy = TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup = TabUiUtilBase._DEFAULT_TAB_GROUP, offset}) {
			if (!obj.__hasTab({propProxy, tabGroup, offset})) return;
			const {propActive, _propProxy} = obj._getTabProps({propProxy, tabGroup});
			obj[_propProxy][propActive] = obj[_propProxy][propActive] + offset;
		};

		obj._addHookActiveTab = function (hook, {propProxy = TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup = TabUiUtilBase._DEFAULT_TAB_GROUP} = {}) {
			const {propActive} = obj._getTabProps({propProxy, tabGroup});
			this._addHook(propProxy, propActive, hook);
		};

		obj._getIxActiveTab = function ({propProxy = TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup = TabUiUtilBase._DEFAULT_TAB_GROUP} = {}) {
			const {propActive, _propProxy} = obj._getTabProps({propProxy, tabGroup});
			return obj[_propProxy][propActive];
		};

		obj._setIxActiveTab = function ({propProxy = TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup = TabUiUtilBase._DEFAULT_TAB_GROUP, ixActiveTab} = {}) {
			const {propActive, _propProxy} = obj._getTabProps({propProxy, tabGroup});
			obj[_propProxy][propActive] = ixActiveTab;
		};

		obj._getActiveTab = function ({propProxy = TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup = TabUiUtilBase._DEFAULT_TAB_GROUP} = {}) {
			const tabState = obj.__tabState[tabGroup];
			const ixActiveTab = obj._getIxActiveTab({propProxy, tabGroup});
			return tabState.tabMetasOut[ixActiveTab];
		};

		obj._setActiveTab = function ({propProxy = TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup = TabUiUtilBase._DEFAULT_TAB_GROUP, tab}) {
			const tabState = obj.__tabState[tabGroup];
			const ix = tabState.tabMetasOut.indexOf(tab);
			obj._setIxActiveTab({propProxy, tabGroup, ixActiveTab: ix});
		};

		obj.__$getBtnTab = function () { throw new Error("Unimplemented!"); };
		obj.__$getWrpTab = function () { throw new Error("Unimplemented!"); };
		obj.__renderTypedTabMeta = function () { throw new Error("Unimplemented!"); };
		obj.__$getDispTabTitle = function () { throw new Error("Unimplemented!"); };
	}
}
TabUiUtilBase._DEFAULT_TAB_GROUP = "_default";
TabUiUtilBase._DEFAULT_PROP_PROXY = "meta";

TabUiUtilBase.TabMeta = class {
	constructor ({name, icon = null, type = null, buttons = null} = {}) {
		this.name = name;
		this.icon = icon;
		this.type = type;
		this.buttons = buttons;
	}
};

let TabUiUtil$1 = class TabUiUtil extends TabUiUtilBase {
	static decorate (obj, {isInitMeta = false} = {}) {
		super.decorate(obj, {isInitMeta});

		obj.__$getBtnTab = function ({tabMeta, _propProxy, propActive, ixTab}) {
			return $(`<button class="btn btn-default ui-tab__btn-tab-head ${tabMeta.isHeadHidden ? "ve-hidden" : ""}">${tabMeta.name.qq()}</button>`)
				.click(() => obj[_propProxy][propActive] = ixTab);
		};

		obj.__$getWrpTab = function ({tabMeta}) {
			return $(`<div class="ui-tab__wrp-tab-body ve-flex-col ve-hidden ${tabMeta.hasBorder ? "ui-tab__wrp-tab-body--border" : ""} ${tabMeta.hasBackground ? "ui-tab__wrp-tab-body--background" : ""}"></div>`);
		};

		obj.__renderTypedTabMeta = function ({tabMeta, ixTab}) {
			switch (tabMeta.type) {
				case "buttons": return obj.__renderTypedTabMeta_buttons({tabMeta, ixTab});
				default: throw new Error(`Unhandled tab type "${tabMeta.type}"`);
			}
		};

		obj.__renderTypedTabMeta_buttons = function ({tabMeta, ixTab}) {
			const $btns = tabMeta.buttons.map((meta, j) => {
				const $btn = $(`<button class="btn ui-tab__btn-tab-head ${meta.type ? `btn-${meta.type}` : "btn-primary"}" ${meta.title ? `title="${meta.title.qq()}"` : ""}>${meta.html}</button>`)
					.click(evt => meta.pFnClick(evt, $btn));
				return $btn;
			});

			const $btnTab = $$`<div class="btn-group ve-flex-v-right ve-flex-h-right ml-2 w-100">${$btns}</div>`;

			return {
				...tabMeta,
				ix: ixTab,
				$btns,
				$btnTab,
			};
		};

		obj.__$getDispTabTitle = function () { return null; };
	}
};

globalThis.TabUiUtil = TabUiUtil$1;

TabUiUtil$1.TabMeta = class extends TabUiUtilBase.TabMeta {
	constructor (opts) {
		super(opts);
		this.hasBorder = !!opts.hasBorder;
		this.hasBackground = !!opts.hasBackground;
		this.isHeadHidden = !!opts.isHeadHidden;
		this.isNoPadding = !!opts.isNoPadding;
	}
};

let TabUiUtilSide$1 = class TabUiUtilSide extends TabUiUtilBase {
	static decorate (obj, {isInitMeta = false} = {}) {
		super.decorate(obj, {isInitMeta});

		obj.__$getBtnTab = function ({isSingleTab, tabMeta, _propProxy, propActive, ixTab}) {
			return isSingleTab ? null : $(`<button class="btn btn-default btn-sm ui-tab-side__btn-tab mb-2 br-0 btr-0 bbr-0 text-left ve-flex-v-center" title="${tabMeta.name.qq()}"><div class="${tabMeta.icon} ui-tab-side__icon-tab mr-2 mobile-ish__mr-0 text-center"></div><div class="mobile-ish__hidden">${tabMeta.name.qq()}</div></button>`)
				.click(() => this[_propProxy][propActive] = ixTab);
		};

		obj.__$getWrpTab = function ({tabMeta}) {
			return $(`<div class="ve-flex-col w-100 h-100 ui-tab-side__wrp-tab ${tabMeta.isNoPadding ? "" : "px-3 py-2"} overflow-y-auto"></div>`);
		};

		obj.__renderTabs_addToParent = function ({$dispTabTitle, $parent, tabMetasOut}) {
			$$`<div class="ve-flex-col w-100 h-100">
				${$dispTabTitle}
				<div class="ve-flex w-100 h-100 min-h-0">
					<div class="ve-flex-col h-100 pt-2">${tabMetasOut.map(it => it.$btnTab)}</div>
					<div class="ve-flex-col w-100 h-100 min-w-0">${tabMetasOut.map(it => it.$wrpTab).filter(Boolean)}</div>
				</div>
			</div>`.appendTo($parent);
		};

		obj.__renderTypedTabMeta = function ({tabMeta, ixTab}) {
			switch (tabMeta.type) {
				case "buttons": return obj.__renderTypedTabMeta_buttons({tabMeta, ixTab});
				default: throw new Error(`Unhandled tab type "${tabMeta.type}"`);
			}
		};

		obj.__renderTypedTabMeta_buttons = function ({tabMeta, ixTab}) {
			const $btns = tabMeta.buttons.map((meta, j) => {
				const $btn = $(`<button class="btn ${meta.type ? `btn-${meta.type}` : "btn-primary"} btn-sm" ${meta.title ? `title="${meta.title.qq()}"` : ""}>${meta.html}</button>`)
					.click(evt => meta.pFnClick(evt, $btn));

				if (j === tabMeta.buttons.length - 1) $btn.addClass(`br-0 btr-0 bbr-0`);

				return $btn;
			});

			const $btnTab = $$`<div class="btn-group ve-flex-v-center ve-flex-h-right mb-2">${$btns}</div>`;

			return {
				...tabMeta,
				ix: ixTab,
				$btnTab,
			};
		};

		obj.__$getDispTabTitle = function ({isSingleTab}) {
			return $(`<div class="ui-tab-side__disp-active-tab-name ${isSingleTab ? `ui-tab-side__disp-active-tab-name--single` : ""} bold"></div>`);
		};
	}
};

globalThis.TabUiUtilSide = TabUiUtilSide$1;

class SearchUiUtil {
	static async pDoGlobalInit () {
		elasticlunr.clearStopWords();
		await Renderer.item.pPopulatePropertyAndTypeReference();
	}

	static _isNoHoverCat (cat) {
		return SearchUiUtil.NO_HOVER_CATEGORIES.has(cat);
	}

	static async pGetContentIndices (options) {
		options = options || {};

		const availContent = {};

		const [searchIndexRaw] = await Promise.all([
			DataUtil.loadJSON(`${Renderer.get().baseUrl}search/index.json`),
			ExcludeUtil.pInitialise(),
		]);

		const data = Omnidexer.decompressIndex(searchIndexRaw);

		const additionalData = {};
		if (options.additionalIndices) {
			await Promise.all(options.additionalIndices.map(async add => {
				additionalData[add] = Omnidexer.decompressIndex(await DataUtil.loadJSON(`${Renderer.get().baseUrl}search/index-${add}.json`));
				const maxId = additionalData[add].last().id;

				const prereleaseIndex = await PrereleaseUtil.pGetAdditionalSearchIndices(maxId, add);
				if (prereleaseIndex.length) additionalData[add] = additionalData[add].concat(prereleaseIndex);

				const brewIndex = await BrewUtil2.pGetAdditionalSearchIndices(maxId, add);
				if (brewIndex.length) additionalData[add] = additionalData[add].concat(brewIndex);
			}));
		}

		const alternateData = {};
		if (options.alternateIndices) {
			await Promise.all(options.alternateIndices.map(async alt => {
				alternateData[alt] = Omnidexer.decompressIndex(await DataUtil.loadJSON(`${Renderer.get().baseUrl}search/index-alt-${alt}.json`));
				const maxId = alternateData[alt].last().id;

				const prereleaseIndex = await BrewUtil2.pGetAlternateSearchIndices(maxId, alt);
				if (prereleaseIndex.length) alternateData[alt] = alternateData[alt].concat(prereleaseIndex);

				const brewIndex = await BrewUtil2.pGetAlternateSearchIndices(maxId, alt);
				if (brewIndex.length) alternateData[alt] = alternateData[alt].concat(brewIndex);
			}));
		}

		const fromDeepIndex = (d) => d.d; 
		availContent.ALL = elasticlunr(function () {
			this.addField("n");
			this.addField("s");
			this.setRef("id");
		});
		SearchUtil.removeStemmer(availContent.ALL);

				let ixMax = 0;

		const initIndexForFullCat = (doc) => {
			if (!availContent[doc.cf]) {
				availContent[doc.cf] = elasticlunr(function () {
					this.addField("n");
					this.addField("s");
					this.setRef("id");
				});
				SearchUtil.removeStemmer(availContent[doc.cf]);
			}
		};

		const handleDataItem = (d, isAlternate) => {
			if (
				SearchUiUtil._isNoHoverCat(d.c)
				|| fromDeepIndex(d)
				|| ExcludeUtil.isExcluded(d.u, Parser.pageCategoryToProp(d.c), d.s, {isNoCount: true})
			) return;
			d.cf = d.c === Parser.CAT_ID_CREATURE ? "Creature" : Parser.pageCategoryToFull(d.c);
			if (isAlternate) d.cf = `alt_${d.cf}`;
			initIndexForFullCat(d);
			if (!isAlternate) availContent.ALL.addDoc(d);
			availContent[d.cf].addDoc(d);
			ixMax = Math.max(ixMax, d.id);
		};

		data.forEach(d => handleDataItem(d));
		Object.values(additionalData).forEach(arr => arr.forEach(d => handleDataItem(d)));
		Object.values(alternateData).forEach(arr => arr.forEach(d => handleDataItem(d, true)));

		const pAddPrereleaseBrewIndex = async ({brewUtil}) => {
			const brewIndex = await brewUtil.pGetSearchIndex({id: availContent.ALL.documentStore.length});

			brewIndex.forEach(d => {
				if (SearchUiUtil._isNoHoverCat(d.c) || fromDeepIndex(d)) return;
				d.cf = Parser.pageCategoryToFull(d.c);
				d.cf = d.c === Parser.CAT_ID_CREATURE ? "Creature" : Parser.pageCategoryToFull(d.c);
				initIndexForFullCat(d);
				availContent.ALL.addDoc(d);
				availContent[d.cf].addDoc(d);
			});
		};

		await pAddPrereleaseBrewIndex({brewUtil: PrereleaseUtil});
		await pAddPrereleaseBrewIndex({brewUtil: BrewUtil2});

		return availContent;
	}
}
SearchUiUtil.NO_HOVER_CATEGORIES = new Set([
	Parser.CAT_ID_ADVENTURE,
	Parser.CAT_ID_BOOK,
	Parser.CAT_ID_QUICKREF,
	Parser.CAT_ID_PAGE,
]);

class SearchWidget {
	static getSearchNoResults () {
		return `<div class="ui-search__message"><i>No results.</i></div>`;
	}

	static getSearchLoading () {
		return `<div class="ui-search__message"><i>\u2022\u2022\u2022</i></div>`;
	}

	static getSearchEnter () {
		return `<div class="ui-search__message"><i>Enter a search.</i></div>`;
	}

		static bindAutoSearch ($iptSearch, opts) {
		UiUtil$1.bindTypingEnd({
			$ipt: $iptSearch,
			fnKeyup: evt => {
				if (evt.type === "blur") return;

								switch (evt.key) {
					case "ArrowDown": {
						evt.preventDefault();
						return;
					}
					case "Enter": return;
				}

				opts.fnSearch && opts.fnSearch();
			},
			fnKeypress: evt => {
				switch (evt.key) {
					case "ArrowDown": {
						evt.preventDefault();
						return;
					}
					case "Enter": {
						opts.flags.doClickFirst = true;
						opts.fnSearch && opts.fnSearch();
					}
				}
			},
			fnKeydown: evt => {
				if (opts.flags.isWait) {
					opts.flags.isWait = false;
					opts.fnShowWait && opts.fnShowWait();
					return;
				}

				switch (evt.key) {
					case "ArrowDown": {
						if (opts.$ptrRows && opts.$ptrRows._[0]) {
							evt.stopPropagation();
							evt.preventDefault();
							opts.$ptrRows._[0][0].focus();
						}
						break;
					}
					case "Enter": {
						if (opts.$ptrRows && opts.$ptrRows._[0]) {
							evt.preventDefault();
							opts.$ptrRows._[0].click();
						}
						break;
					}
				}
			},
			fnClick: () => {
				if (opts.fnSearch && $iptSearch.val() && $iptSearch.val().trim().length) opts.fnSearch();
			},
		});
	}

	static bindRowHandlers ({result, $row, $ptrRows, fnHandleClick, $iptSearch}) {
		return $row
			.keydown(evt => {
				switch (evt.which) {
					case 13: { 						return fnHandleClick(result);
					}
					case 38: { 						evt.preventDefault();
						const ixRow = $ptrRows._.indexOf($row);
						const $prev = $ptrRows._[ixRow - 1];
						if ($prev) $prev.focus();
						else $iptSearch.focus();
						break;
					}
					case 40: { 						evt.preventDefault();
						const ixRow = $ptrRows._.indexOf($row);
						const $nxt = $ptrRows._[ixRow + 1];
						if ($nxt) $nxt.focus();
						break;
					}
				}
			})
			.click(() => fnHandleClick(result));
	}

	static docToPageSourceHash (doc) {
		const page = UrlUtil.categoryToHoverPage(doc.c);
		const source = doc.s;
		const hash = doc.u;

		return {page, source, hash};
	}

		constructor (indexes, cbSearch, options) {
		options = options || {};

		this._indexes = indexes;
		this._cat = options.defaultCategory || "ALL";
		this._cbSearch = cbSearch;
		this._fnFilterResults = options.fnFilterResults || null;
		this._searchOptions = options.searchOptions || null;
		this._fnTransform = options.fnTransform || null;

		this._flags = {
			doClickFirst: false,
			isWait: false,
		};
		this._$ptrRows = {_: []};

		this._$selCat = null;
		this._$iptSearch = null;
		this._$wrpResults = null;

		this._$rendered = null;
	}

	static pDoGlobalInit () {
		if (!SearchWidget.P_LOADING_CONTENT) {
			SearchWidget.P_LOADING_CONTENT = (async () => {
				Object.assign(SearchWidget.CONTENT_INDICES, await SearchUiUtil.pGetContentIndices({additionalIndices: ["item"], alternateIndices: ["spell"]}));
			})();
		}
		return SearchWidget.P_LOADING_CONTENT;
	}

	__getSearchOptions () {
		return this._searchOptions || {
			fields: {
				n: {boost: 5, expand: true},
				s: {expand: true},
			},
			bool: "AND",
			expand: true,
		};
	}

	__$getRow (r) {
		return $(`<div class="ui-search__row" tabindex="0">
			<span>${r.doc.n}</span>
			<span>${r.doc.s ? `<i title="${Parser.sourceJsonToFull(r.doc.s)}">${Parser.sourceJsonToAbv(r.doc.s)}${r.doc.p ? ` p${r.doc.p}` : ""}</i>` : ""}</span>
		</div>`);
	}

	static __getAllTitle () {
		return "All Categories";
	}

	static __getCatOptionText (it) {
		return it;
	}

	get $wrpSearch () {
		if (!this._$rendered) this._render();
		return this._$rendered;
	}

	__showMsgInputRequired () {
		this._flags.isWait = true;
		this._$wrpResults.empty().append(SearchWidget.getSearchEnter());
	}

	__showMsgWait () {
		this._$wrpResults.empty().append(SearchWidget.getSearchLoading());
	}

	__showMsgNoResults () {
		this._flags.isWait = true;
		this._$wrpResults.empty().append(SearchWidget.getSearchNoResults());
	}

	__doSearch () {
		const searchInput = this._$iptSearch.val().trim();

		const index = this._indexes[this._cat];
		const results = index.search(searchInput, this.__getSearchOptions());

		const {toProcess, resultCount} = (() => {
			if (results.length) {
				if (this._fnFilterResults) {
					const filtered = results.filter(it => this._fnFilterResults(it.doc));
					return {
						toProcess: filtered.slice(0, UiUtil$1.SEARCH_RESULTS_CAP),
						resultCount: filtered.length,
					};
				} else {
					return {
						toProcess: results.slice(0, UiUtil$1.SEARCH_RESULTS_CAP),
						resultCount: results.length,
					};
				}
			} else {
								if (searchInput.trim()) {
					return {
						toProcess: [],
						resultCount: 0,
					};
				}

								if (this._fnFilterResults) {
					const filtered = Object.values(index.documentStore.docs).filter(it => this._fnFilterResults(it)).map(it => ({doc: it}));
					return {
						toProcess: filtered.slice(0, UiUtil$1.SEARCH_RESULTS_CAP),
						resultCount: filtered.length,
					};
				} else {
					return {
						toProcess: Object.values(index.documentStore.docs).slice(0, UiUtil$1.SEARCH_RESULTS_CAP).map(it => ({doc: it})),
						resultCount: Object.values(index.documentStore.docs).length,
					};
				}
			}
		})();

		this._$wrpResults.empty();
		this._$ptrRows._ = [];

		if (resultCount) {
			const handleClick = (r) => {
				if (this._fnTransform) this._cbSearch(this._fnTransform(r.doc));
				else this._cbSearch(r.doc);
			};

			if (this._flags.doClickFirst) {
				handleClick(toProcess[0]);
				this._flags.doClickFirst = false;
				return;
			}

			const res = toProcess.slice(0, UiUtil$1.SEARCH_RESULTS_CAP);

			res.forEach(r => {
				const $row = this.__$getRow(r).appendTo(this._$wrpResults);
				SearchWidget.bindRowHandlers({result: r, $row, $ptrRows: this._$ptrRows, fnHandleClick: handleClick, $iptSearch: this._$iptSearch});
				this._$ptrRows._.push($row);
			});

			if (resultCount > UiUtil$1.SEARCH_RESULTS_CAP) {
				const diff = resultCount - UiUtil$1.SEARCH_RESULTS_CAP;
				this._$wrpResults.append(`<div class="ui-search__row ui-search__row--readonly">...${diff} more result${diff === 1 ? " was" : "s were"} hidden. Refine your search!</div>`);
			}
		} else {
			if (!searchInput.trim()) this.__showMsgInputRequired();
			else this.__showMsgNoResults();
		}
	}

	_render () {
		if (!this._$rendered) {
			this._$rendered = $(`<div class="ui-search__wrp-output"></div>`);
			const $wrpControls = $(`<div class="ui-search__wrp-controls"></div>`).appendTo(this._$rendered);

			this._$selCat = $(`<select class="form-control ui-search__sel-category">
				<option value="ALL">${SearchWidget.__getAllTitle()}</option>
				${Object.keys(this._indexes).sort().filter(it => it !== "ALL").map(it => `<option value="${it}">${SearchWidget.__getCatOptionText(it)}</option>`).join("")}
			</select>`)
				.appendTo($wrpControls).toggle(Object.keys(this._indexes).length !== 1)
				.on("change", () => {
					this._cat = this._$selCat.val();
					this.__doSearch();
				});

			this._$iptSearch = $(`<input class="ui-search__ipt-search search form-control" autocomplete="off" placeholder="Search...">`).appendTo($wrpControls);
			this._$wrpResults = $(`<div class="ui-search__wrp-results"></div>`).appendTo(this._$rendered);

			let lastSearchTerm = "";
			SearchWidget.bindAutoSearch(this._$iptSearch, {
				flags: this._flags,
				fnSearch: this.__doSearch.bind(this),
				fnShowWait: this.__showMsgWait.bind(this),
				$ptrRows: this._$ptrRows,
			});

						this._$iptSearch.keydown(evt => {
				if (evt.key === "Escape") this._$iptSearch.blur();
				if (!this._$iptSearch.val().trim().length) return;
				if (evt.which !== 13) {
					if (lastSearchTerm === "") this.__showMsgWait();
					lastSearchTerm = this._$iptSearch.val();
				}
			});

			this.__doSearch();
		}
	}

	doFocus () {
		this._$iptSearch.focus();
	}

	static async pAddToIndexes (prop, entry) {
		const nextId = Object.values(SearchWidget.CONTENT_INDICES.ALL.documentStore.docs).length;

		const indexer = new Omnidexer(nextId);

		const toIndex = {[prop]: [entry]};

		const toIndexMultiPart = Omnidexer.TO_INDEX__FROM_INDEX_JSON.filter(it => it.listProp === prop);
		for (const it of toIndexMultiPart) await indexer.pAddToIndex(it, toIndex);

		const toIndexSinglePart = Omnidexer.TO_INDEX.filter(it => it.listProp === prop);
		for (const it of toIndexSinglePart) await indexer.pAddToIndex(it, toIndex);

		const toAdd = Omnidexer.decompressIndex(indexer.getIndex());
		toAdd.forEach(d => {
			d.cf = d.c === Parser.CAT_ID_CREATURE ? "Creature" : Parser.pageCategoryToFull(d.c);
			SearchWidget.CONTENT_INDICES.ALL.addDoc(d);
			SearchWidget.CONTENT_INDICES[d.cf].addDoc(d);
		});
	}

		static async pGetUserSpellSearch (opts) {
		opts = opts || {};
		await SearchWidget.P_LOADING_CONTENT;

		const nxtOpts = {
			fnTransform: doc => {
				const cpy = MiscUtil.copyFast(doc);
				Object.assign(cpy, SearchWidget.docToPageSourceHash(cpy));
				cpy.tag = `{@spell ${doc.n.toSpellCase()}${doc.s !== Parser.SRC_PHB ? `|${doc.s}` : ""}}`;
				return cpy;
			},
		};
		if (opts.level != null) nxtOpts.fnFilterResults = result => result.lvl === opts.level;

		const title = opts.level === 0 ? "Select Cantrip" : "Select Spell";
		return SearchWidget.pGetUserEntitySearch(
			title,
			"alt_Spell",
			nxtOpts,
		);
	}

	static async pGetUserLegendaryGroupSearch () {
		await SearchWidget.pLoadCustomIndex({
			contentIndexName: "entity_LegendaryGroups",
			errorName: "legendary groups",
			customIndexSubSpecs: [
				new SearchWidget.CustomIndexSubSpec({
					dataSource: `${Renderer.get().baseUrl}data/bestiary/legendarygroups.json`,
					prop: "legendaryGroup",
					catId: Parser.CAT_ID_LEGENDARY_GROUP,
					page: "legendaryGroup",
				}),
			],
		});

		return SearchWidget.pGetUserEntitySearch(
			"Select Legendary Group",
			"entity_LegendaryGroups",
			{
				fnTransform: doc => {
					const cpy = MiscUtil.copyFast(doc);
					Object.assign(cpy, SearchWidget.docToPageSourceHash(cpy));
					cpy.page = "legendaryGroup";
					return cpy;
				},
			},
		);
	}

	static async pGetUserFeatSearch () {
				await SearchWidget.pLoadCustomIndex({
			contentIndexName: "entity_Feats",
			errorName: "feats",
			customIndexSubSpecs: [
				new SearchWidget.CustomIndexSubSpec({
					dataSource: `${Renderer.get().baseUrl}data/feats.json`,
					prop: "feat",
					catId: Parser.CAT_ID_FEAT,
					page: UrlUtil.PG_FEATS,
				}),
			],
		});

		return SearchWidget.pGetUserEntitySearch(
			"Select Feat",
			"entity_Feats",
			{
				fnTransform: doc => {
					const cpy = MiscUtil.copyFast(doc);
					Object.assign(cpy, SearchWidget.docToPageSourceHash(cpy));
					cpy.tag = `{@feat ${doc.n}${doc.s !== Parser.SRC_PHB ? `|${doc.s}` : ""}}`;
					return cpy;
				},
			},
		);
	}

	static async pGetUserBackgroundSearch () {
				await SearchWidget.pLoadCustomIndex({
			contentIndexName: "entity_Backgrounds",
			errorName: "backgrounds",
			customIndexSubSpecs: [
				new SearchWidget.CustomIndexSubSpec({
					dataSource: `${Renderer.get().baseUrl}data/backgrounds.json`,
					prop: "background",
					catId: Parser.CAT_ID_BACKGROUND,
					page: UrlUtil.PG_BACKGROUNDS,
				}),
			],
		});

		return SearchWidget.pGetUserEntitySearch(
			"Select Background",
			"entity_Backgrounds",
			{
				fnTransform: doc => {
					const cpy = MiscUtil.copyFast(doc);
					Object.assign(cpy, SearchWidget.docToPageSourceHash(cpy));
					cpy.tag = `{@background ${doc.n}${doc.s !== Parser.SRC_PHB ? `|${doc.s}` : ""}}`;
					return cpy;
				},
			},
		);
	}

	static async pGetUserRaceSearch () {
				const dataSource = () => {
			return DataUtil.race.loadJSON();
		};
		await SearchWidget.pLoadCustomIndex({
			contentIndexName: "entity_Races",
			errorName: "races",
			customIndexSubSpecs: [
				new SearchWidget.CustomIndexSubSpec({
					dataSource,
					prop: "race",
					catId: Parser.CAT_ID_RACE,
					page: UrlUtil.PG_RACES,
				}),
			],
		});

		return SearchWidget.pGetUserEntitySearch(
			"Select Race",
			"entity_Races",
			{
				fnTransform: doc => {
					const cpy = MiscUtil.copyFast(doc);
					Object.assign(cpy, SearchWidget.docToPageSourceHash(cpy));
					cpy.tag = `{@race ${doc.n}${doc.s !== Parser.SRC_PHB ? `|${doc.s}` : ""}}`;
					return cpy;
				},
			},
		);
	}

	static async pGetUserOptionalFeatureSearch () {
				await SearchWidget.pLoadCustomIndex({
			contentIndexName: "entity_OptionalFeatures",
			errorName: "optional features",
			customIndexSubSpecs: [
				new SearchWidget.CustomIndexSubSpec({
					dataSource: `${Renderer.get().baseUrl}data/optionalfeatures.json`,
					prop: "optionalfeature",
					catId: Parser.CAT_ID_OPTIONAL_FEATURE_OTHER,
					page: UrlUtil.PG_OPT_FEATURES,
				}),
			],
		});

		return SearchWidget.pGetUserEntitySearch(
			"Select Optional Feature",
			"entity_OptionalFeatures",
			{
				fnTransform: doc => {
					const cpy = MiscUtil.copyFast(doc);
					Object.assign(cpy, SearchWidget.docToPageSourceHash(cpy));
					cpy.tag = `{@optfeature ${doc.n}${doc.s !== Parser.SRC_PHB ? `|${doc.s}` : ""}}`;
					return cpy;
				},
			},
		);
	}

	static async pGetUserAdventureSearch (opts) {
		await SearchWidget.pLoadCustomIndex({
			contentIndexName: "entity_Adventures",
			errorName: "adventures",
			customIndexSubSpecs: [
				new SearchWidget.CustomIndexSubSpec({
					dataSource: `${Renderer.get().baseUrl}data/adventures.json`,
					prop: "adventure",
					catId: Parser.CAT_ID_ADVENTURE,
					page: UrlUtil.PG_ADVENTURE,
				}),
			],
		});
		return SearchWidget.pGetUserEntitySearch("Select Adventure", "entity_Adventures", opts);
	}

	static async pGetUserBookSearch (opts) {
		await SearchWidget.pLoadCustomIndex({
			contentIndexName: "entity_Books",
			errorName: "books",
			customIndexSubSpecs: [
				new SearchWidget.CustomIndexSubSpec({
					dataSource: `${Renderer.get().baseUrl}data/books.json`,
					prop: "book",
					catId: Parser.CAT_ID_BOOK,
					page: UrlUtil.PG_BOOK,
				}),
			],
		});
		return SearchWidget.pGetUserEntitySearch("Select Book", "entity_Books", opts);
	}

	static async pGetUserAdventureBookSearch (opts) {
		const contentIndexName = opts.contentIndexName || "entity_AdventuresBooks";
		await SearchWidget.pLoadCustomIndex({
			contentIndexName,
			errorName: "adventures/books",
			customIndexSubSpecs: [
				new SearchWidget.CustomIndexSubSpec({
					dataSource: `${Renderer.get().baseUrl}data/adventures.json`,
					prop: "adventure",
					catId: Parser.CAT_ID_ADVENTURE,
					page: UrlUtil.PG_ADVENTURE,
					pFnGetDocExtras: opts.pFnGetDocExtras,
				}),
				new SearchWidget.CustomIndexSubSpec({
					dataSource: `${Renderer.get().baseUrl}data/books.json`,
					prop: "book",
					catId: Parser.CAT_ID_BOOK,
					page: UrlUtil.PG_BOOK,
					pFnGetDocExtras: opts.pFnGetDocExtras,
				}),
			],
		});
		return SearchWidget.pGetUserEntitySearch("Select Adventure or Book", contentIndexName, opts);
	}

	static async pGetUserCreatureSearch () {
		await SearchWidget.P_LOADING_CONTENT;

		const nxtOpts = {
			fnTransform: doc => {
				const cpy = MiscUtil.copyFast(doc);
				Object.assign(cpy, SearchWidget.docToPageSourceHash(cpy));
				cpy.tag = `{@creature ${doc.n}${doc.s !== Parser.SRC_MM ? `|${doc.s}` : ""}}`;
				return cpy;
			},
		};

		return SearchWidget.pGetUserEntitySearch(
			"Select Creature",
			"Creature",
			nxtOpts,
		);
	}

	static async __pLoadItemIndex (isBasicIndex) {
		const dataSource = async () => {
			const allItems = (await Renderer.item.pBuildList()).filter(it => !it._isItemGroup);
			return {
				item: allItems.filter(it => {
					if (it.type === "GV") return false;
					if (isBasicIndex == null) return true;
					const isBasic = it.rarity === "none" || it.rarity === "unknown" || it._category === "basic";
					return isBasicIndex ? isBasic : !isBasic;
				}),
			};
		};
		const indexName = isBasicIndex == null ? "entity_Items" : isBasicIndex ? "entity_ItemsBasic" : "entity_ItemsMagic";

		return SearchWidget.pLoadCustomIndex({
			contentIndexName: indexName,
			errorName: "items",
			customIndexSubSpecs: [
				new SearchWidget.CustomIndexSubSpec({
					dataSource,
					prop: "item",
					catId: Parser.CAT_ID_ITEM,
					page: UrlUtil.PG_ITEMS,
				}),
			],
		});
	}

	static async __pGetUserItemSearch (isBasicIndex) {
		const indexName = isBasicIndex == null ? "entity_Items" : isBasicIndex ? "entity_ItemsBasic" : "entity_ItemsMagic";
		return SearchWidget.pGetUserEntitySearch(
			"Select Item",
			indexName,
			{
				fnTransform: doc => {
					const cpy = MiscUtil.copyFast(doc);
					Object.assign(cpy, SearchWidget.docToPageSourceHash(cpy));
					cpy.tag = `{@item ${doc.n}${doc.s !== Parser.SRC_DMG ? `|${doc.s}` : ""}}`;
					return cpy;
				},
			},
		);
	}

	static async pGetUserBasicItemSearch () {
		await SearchWidget.__pLoadItemIndex(true);
		return SearchWidget.__pGetUserItemSearch(true);
	}

	static async pGetUserMagicItemSearch () {
		await SearchWidget.__pLoadItemIndex(false);
		return SearchWidget.__pGetUserItemSearch(false);
	}

	static async pGetUserItemSearch () {
		await SearchWidget.__pLoadItemIndex();
		return SearchWidget.__pGetUserItemSearch();
	}
	
		static async pGetUserEntitySearch (title, indexName, opts) {
		opts = opts || {};

		return new Promise(resolve => {
			const searchOpts = {defaultCategory: indexName};
			if (opts.fnFilterResults) searchOpts.fnFilterResults = opts.fnFilterResults;
			if (opts.fnTransform) searchOpts.fnTransform = opts.fnTransform;

			const searchWidget = new SearchWidget(
				{[indexName]: SearchWidget.CONTENT_INDICES[indexName]},
				(docOrTransformed) => {
					doClose(false); 					resolve(docOrTransformed);
				},
				searchOpts,
			);
			const {$modalInner, doClose} = UiUtil$1.getShowModal({
				title,
				cbClose: (doResolve) => {
					searchWidget.$wrpSearch.detach();
					if (doResolve) resolve(null); 				},
			});
			$modalInner.append(searchWidget.$wrpSearch);
			searchWidget.doFocus();
		});
	}

		static CustomIndexSubSpec = class {
		constructor ({dataSource, prop, catId, page, pFnGetDocExtras}) {
			this.dataSource = dataSource;
			this.prop = prop;
			this.catId = catId;
			this.page = page;
			this.pFnGetDocExtras = pFnGetDocExtras;
		}
	};

	static async pLoadCustomIndex ({contentIndexName, customIndexSubSpecs, errorName}) {
		if (SearchWidget.P_LOADING_INDICES[contentIndexName]) await SearchWidget.P_LOADING_INDICES[contentIndexName];
		else {
			const doClose = SearchWidget._showLoadingModal();

			try {
				SearchWidget.P_LOADING_INDICES[contentIndexName] = (SearchWidget.CONTENT_INDICES[contentIndexName] = await SearchWidget._pGetIndex(customIndexSubSpecs));
				SearchWidget.P_LOADING_INDICES[contentIndexName] = null;
			} catch (e) {
				JqueryUtil.doToast({type: "danger", content: `Could not load ${errorName}! ${VeCt.STR_SEE_CONSOLE}`});
				throw e;
			} finally {
				doClose();
			}
		}
	}

	static async _pGetIndex (customIndexSubSpecs) {
		const index = elasticlunr(function () {
			this.addField("n");
			this.addField("s");
			this.setRef("id");
		});

		let id = 0;
		for (const subSpec of customIndexSubSpecs) {
			const [json, prerelease, brew] = await Promise.all([
				typeof subSpec.dataSource === "string"
					? DataUtil.loadJSON(subSpec.dataSource)
					: subSpec.dataSource(),
				PrereleaseUtil.pGetBrewProcessed(),
				BrewUtil2.pGetBrewProcessed(),
			]);

			await [
				...json[subSpec.prop],
				...(prerelease[subSpec.prop] || []),
				...(brew[subSpec.prop] || []),
			]
				.pSerialAwaitMap(async ent => {
					const doc = {
						id: id++,
						c: subSpec.catId,
						cf: Parser.pageCategoryToFull(subSpec.catId),
						h: 1,
						n: ent.name,
						q: subSpec.page,
						s: ent.source,
						u: UrlUtil.URL_TO_HASH_BUILDER[subSpec.page](ent),
					};
					if (subSpec.pFnGetDocExtras) Object.assign(doc, await subSpec.pFnGetDocExtras({ent, doc, subSpec}));
					index.addDoc(doc);
				});
		}

		return index;
	}

	static _showLoadingModal () {
		const {$modalInner, doClose} = UiUtil$1.getShowModal({isPermanent: true});
		$(`<div class="ve-flex-vh-center w-100 h-100"><span class="dnd-font italic ve-muted">Loading...</span></div>`).appendTo($modalInner);
		return doClose;
	}
	}
SearchWidget.P_LOADING_CONTENT = null;
SearchWidget.CONTENT_INDICES = {};
SearchWidget.P_LOADING_INDICES = {};

let InputUiUtil$1 = class InputUiUtil {
	static async _pGetShowModal (getShowModalOpts) {
		return UiUtil$1.getShowModal(getShowModalOpts);
	}

	static _$getBtnOk ({comp = null, opts, doClose}) {
		return $(`<button class="btn btn-primary mr-2">${opts.buttonText || "OK"}</button>`)
			.click(evt => {
				evt.stopPropagation();
				if (comp && !comp._state.isValid) return JqueryUtil.doToast({content: `Please enter valid input!`, type: "warning"});
				doClose(true);
			});
	}

	static _$getBtnCancel ({comp = null, opts, doClose}) {
		return $(`<button class="btn btn-default">Cancel</button>`)
			.click(evt => {
				evt.stopPropagation();
				doClose(false);
			});
	}

	static _$getBtnSkip ({comp = null, opts, doClose}) {
		return !opts.isSkippable ? null : $(`<button class="btn btn-default ml-3">Skip</button>`)
			.click(evt => {
				evt.stopPropagation();
				doClose(VeCt.SYM_UI_SKIP);
			});
	}

		static async pGetUserNumber (opts) {
		opts = opts || {};

		let defaultVal = opts.default !== undefined ? opts.default : null;
		if (opts.storageKey_default) {
			const prev = await (opts.isGlobal_default ? StorageUtil.pGet(opts.storageKey_default) : StorageUtil.pGetForPage(opts.storageKey_default));
			if (prev != null) defaultVal = prev;
		}

		const $iptNumber = $(`<input class="form-control mb-2 text-right" ${opts.min ? `min="${opts.min}"` : ""} ${opts.max ? `max="${opts.max}"` : ""}>`)
			.keydown(evt => {
				if (evt.key === "Escape") { $iptNumber.blur(); return; }

				evt.stopPropagation();
				if (evt.key === "Enter") {
					evt.preventDefault();
					doClose(true);
				}
			});
		if (defaultVal !== undefined) $iptNumber.val(defaultVal);

		const {$modalInner, doClose, pGetResolved, doAutoResize: doAutoResizeModal} = await InputUiUtil$1._pGetShowModal({
			title: opts.title || "Enter a Number",
			isMinHeight0: true,
		});

		const $btnOk = this._$getBtnOk({opts, doClose});
		const $btnCancel = this._$getBtnCancel({opts, doClose});
		const $btnSkip = this._$getBtnSkip({opts, doClose});

		if (opts.$elePre) opts.$elePre.appendTo($modalInner);
		$iptNumber.appendTo($modalInner);
		if (opts.$elePost) opts.$elePost.appendTo($modalInner);
		$$`<div class="ve-flex-v-center ve-flex-h-right pb-1 px-1">${$btnOk}${$btnCancel}${$btnSkip}</div>`.appendTo($modalInner);

		if (doAutoResizeModal) doAutoResizeModal();

		$iptNumber.focus();
		$iptNumber.select();

				const [isDataEntered] = await pGetResolved();

		if (typeof isDataEntered === "symbol") return isDataEntered;

		if (!isDataEntered) return null;
		const outRaw = $iptNumber.val();
		if (!outRaw.trim()) return null;
		let out = UiUtil$1.strToInt(outRaw);
		if (opts.min) out = Math.max(opts.min, out);
		if (opts.max) out = Math.min(opts.max, out);
		if (opts.int) out = Math.round(out);

		if (opts.storageKey_default) {
			opts.isGlobal_default
				? StorageUtil.pSet(opts.storageKey_default, out).then(null)
				: StorageUtil.pSetForPage(opts.storageKey_default, out).then(null);
		}

		return out;
			}

		static async pGetUserBoolean (opts) {
		opts = opts || {};

		if (opts.storageKey) {
			const prev = await (opts.isGlobal ? StorageUtil.pGet(opts.storageKey) : StorageUtil.pGetForPage(opts.storageKey));
			if (prev != null) return prev;
		}

		const $btnTrueRemember = opts.textYesRemember ? $(`<button class="btn btn-primary ve-flex-v-center mr-2"><span class="glyphicon glyphicon-ok mr-2"></span><span>${opts.textYesRemember}</span></button>`)
			.click(() => {
				doClose(true, true);
				if (opts.fnRemember) {
					opts.fnRemember(true);
				} else {
					opts.isGlobal
						? StorageUtil.pSet(opts.storageKey, true)
						: StorageUtil.pSetForPage(opts.storageKey, true);
				}
			}) : null;

		const $btnTrue = $(`<button class="btn btn-primary ve-flex-v-center mr-3"><span class="glyphicon glyphicon-ok mr-2"></span><span>${opts.textYes || "OK"}</span></button>`)
			.click(evt => {
				evt.stopPropagation();
				doClose(true, true);
			});

		const $btnFalse = opts.isAlert ? null : $(`<button class="btn btn-default btn-sm ve-flex-v-center"><span class="glyphicon glyphicon-remove mr-2"></span><span>${opts.textNo || "Cancel"}</span></button>`)
			.click(evt => {
				evt.stopPropagation();
				doClose(true, false);
			});

		const $btnSkip = !opts.isSkippable ? null : $(`<button class="btn btn-default btn-sm ml-3"><span class="glyphicon glyphicon-forward"></span><span>${opts.textSkip || "Skip"}</span></button>`)
			.click(evt => {
				evt.stopPropagation();
				doClose(VeCt.SYM_UI_SKIP);
			});

		const {$modalInner, doClose, pGetResolved, doAutoResize: doAutoResizeModal} = await InputUiUtil$1._pGetShowModal({
			title: opts.title || "Choose",
			isMinHeight0: true,
		});

		if (opts.htmlDescription && opts.htmlDescription.trim()) $$`<div class="ve-flex w-100 mb-1">${opts.htmlDescription}</div>`.appendTo($modalInner);
		$$`<div class="ve-flex-v-center ve-flex-h-right py-1 px-1">${$btnTrueRemember}${$btnTrue}${$btnFalse}${$btnSkip}</div>`.appendTo($modalInner);

		if (doAutoResizeModal) doAutoResizeModal();

		$btnTrue.focus();
		$btnTrue.select();

				const [isDataEntered, out] = await pGetResolved();

		if (typeof isDataEntered === "symbol") return isDataEntered;

		if (!isDataEntered) return null;
		if (out == null) throw new Error(`Callback must receive a value!`); 		return out;
			}

		static async pGetUserEnum (opts) {
		opts = opts || {};

		const $selEnum = $(`<select class="form-control mb-2"><option value="-1" disabled>${opts.placeholder || "Select..."}</option></select>`)
			.keydown(async evt => {
				evt.stopPropagation();
				if (evt.key === "Enter") {
					evt.preventDefault();
					doClose(true);
				}
			});

		if (opts.isAllowNull) $(`<option value="-1"></option>`).text(opts.fnDisplay ? opts.fnDisplay(null, -1) : "(None)").appendTo($selEnum);

		opts.values.forEach((v, i) => $(`<option value="${i}"></option>`).text(opts.fnDisplay ? opts.fnDisplay(v, i) : v).appendTo($selEnum));
		if (opts.default != null) $selEnum.val(opts.default);
		else $selEnum[0].selectedIndex = 0;

		const {$modalInner, doClose, pGetResolved, doAutoResize: doAutoResizeModal} = await InputUiUtil$1._pGetShowModal({
			title: opts.title || "Select an Option",
			isMinHeight0: true,
		});

		const $btnOk = this._$getBtnOk({opts, doClose});
		const $btnCancel = this._$getBtnCancel({opts, doClose});
		const $btnSkip = this._$getBtnSkip({opts, doClose});

		$selEnum.appendTo($modalInner);
		if (opts.$elePost) opts.$elePost.appendTo($modalInner);
		$$`<div class="ve-flex-v-center ve-flex-h-right pb-1 px-1">${$btnOk}${$btnCancel}${$btnSkip}</div>`.appendTo($modalInner);

		if (doAutoResizeModal) doAutoResizeModal();

		$selEnum.focus();

				const [isDataEntered] = await pGetResolved();
		if (typeof isDataEntered === "symbol") return isDataEntered;

		if (!isDataEntered) return null;
		const ix = Number($selEnum.val());
		if (!~ix) return null;
		if (opts.fnGetExtraState) {
			const out = {extraState: opts.fnGetExtraState()};
			if (opts.isResolveItem) out.item = opts.values[ix];
			else out.ix = ix;
			return out;
		}

		return opts.isResolveItem ? opts.values[ix] : ix;
			}

		static async pGetUserMultipleChoice (opts) {
		const prop = "formData";

		const initialState = {};
		if (opts.defaults) opts.defaults.forEach(ix => initialState[ComponentUiUtil$1.getMetaWrpMultipleChoice_getPropIsActive(prop, ix)] = true);
		if (opts.required) {
			opts.required.forEach(ix => {
				initialState[ComponentUiUtil$1.getMetaWrpMultipleChoice_getPropIsActive(prop, ix)] = true; 				initialState[ComponentUiUtil$1.getMetaWrpMultipleChoice_getPropIsRequired(prop, ix)] = true;
			});
		}

		const comp = BaseComponent$1.fromObject(initialState);

		let title = opts.title;
		if (!title) {
			if (opts.count != null) title = `Choose ${Parser.numberToText(opts.count).uppercaseFirst()}`;
			else if (opts.min != null && opts.max != null) title = `Choose Between ${Parser.numberToText(opts.min).uppercaseFirst()} and ${Parser.numberToText(opts.max).uppercaseFirst()} Options`;
			else if (opts.min != null) title = `Choose At Least ${Parser.numberToText(opts.min).uppercaseFirst()}`;
			else title = `Choose At Most ${Parser.numberToText(opts.max).uppercaseFirst()}`;
		}

		const {$ele: $wrpList, $iptSearch, propIsAcceptable} = ComponentUiUtil$1.getMetaWrpMultipleChoice(comp, prop, opts);
		$wrpList.addClass(`mb-1`);

		const {$modalInner, doClose, pGetResolved, doAutoResize: doAutoResizeModal} = await InputUiUtil$1._pGetShowModal({
			...(opts.modalOpts || {}),
			title,
			isMinHeight0: true,
			isUncappedHeight: true,
		});

		const $btnOk = this._$getBtnOk({opts, doClose});
		const $btnCancel = this._$getBtnCancel({opts, doClose});
		const $btnSkip = this._$getBtnSkip({opts, doClose});

		const hkIsAcceptable = () => $btnOk.attr("disabled", !comp._state[propIsAcceptable]);
		comp._addHookBase(propIsAcceptable, hkIsAcceptable);
		hkIsAcceptable();

		if (opts.htmlDescription) $modalInner.append(opts.htmlDescription);
		if ($iptSearch) {
			$$`<label class="mb-1">
				${$iptSearch}
			</label>`.appendTo($modalInner);
		}
		$wrpList.appendTo($modalInner);
		$$`<div class="ve-flex-v-center ve-flex-h-right no-shrink pb-1 px-1">${$btnOk}${$btnCancel}${$btnSkip}</div>`.appendTo($modalInner);

		if (doAutoResizeModal) doAutoResizeModal();

		$wrpList.focus();

				const [isDataEntered] = await pGetResolved();

		if (typeof isDataEntered === "symbol") return isDataEntered;

		if (!isDataEntered) return null;

		const ixs = ComponentUiUtil$1.getMetaWrpMultipleChoice_getSelectedIxs(comp, prop);

		if (!opts.isResolveItems) return ixs;

		if (opts.values) return ixs.map(ix => opts.values[ix]);

		if (opts.valueGroups) {
			const allValues = opts.valueGroups.map(it => it.values).flat();
			return ixs.map(ix => allValues[ix]);
		}

		throw new Error(`Should never occur!`);
			}

		static async pGetUserIcon (opts) {
		opts = opts || {};

		let lastIx = opts.default != null ? opts.default : -1;
		const onclicks = [];

		const {$modalInner, doClose, pGetResolved, doAutoResize: doAutoResizeModal} = await InputUiUtil$1._pGetShowModal({
			title: opts.title || "Select an Option",
			isMinHeight0: true,
		});

		$$`<div class="ve-flex ve-flex-wrap ve-flex-h-center mb-2">${opts.values.map((v, i) => {
			const $btn = $$`<div class="m-2 btn ${v.buttonClass || "btn-default"} ui__btn-xxl-square ve-flex-col ve-flex-h-center">
					${v.iconClass ? `<div class="ui-icn__wrp-icon ${v.iconClass} mb-1"></div>` : ""}
					${v.iconContent ? v.iconContent : ""}
					<div class="whitespace-normal w-100">${v.name}</div>
				</div>`
				.click(() => {
					lastIx = i;
					onclicks.forEach(it => it());
				})
				.toggleClass(v.buttonClassActive || "active", opts.default === i);
			if (v.buttonClassActive && opts.default === i) {
				$btn.removeClass("btn-default").addClass(v.buttonClassActive);
			}

			onclicks.push(() => {
				$btn.toggleClass(v.buttonClassActive || "active", lastIx === i);
				if (v.buttonClassActive) $btn.toggleClass("btn-default", lastIx !== i);
			});
			return $btn;
		})}</div>`.appendTo($modalInner);

		const $btnOk = this._$getBtnOk({opts, doClose});
		const $btnCancel = this._$getBtnCancel({opts, doClose});
		const $btnSkip = this._$getBtnSkip({opts, doClose});

		$$`<div class="ve-flex-v-center ve-flex-h-right pb-1 px-1">${$btnOk}${$btnCancel}${$btnSkip}</div>`.appendTo($modalInner);

				const [isDataEntered] = await pGetResolved();

		if (typeof isDataEntered === "symbol") return isDataEntered;
		if (!isDataEntered) return null;
		return ~lastIx ? lastIx : null;
			}

		static async pGetUserString (opts) {
		opts = opts || {};

		const propValue = "text";
		const comp = BaseComponent$1.fromObject({
			[propValue]: opts.default || "",
			isValid: true,
		});

		const $iptStr = ComponentUiUtil$1.$getIptStr(
			comp,
			propValue,
			{
				html: `<input class="form-control mb-2" type="text">`,
				autocomplete: opts.autocomplete,
			},
		)
			.keydown(async evt => {
				if (evt.key === "Escape") return; 
				if (opts.autocomplete) {
										await MiscUtil.pDelay(17); 					if ($modalInner.find(`.typeahead.dropdown-menu`).is(":visible")) return;
				}

				evt.stopPropagation();
				if (evt.key === "Enter") {
					evt.preventDefault();
					doClose(true);
				}
			});
		if (opts.isCode) $iptStr.addClass("code");

		if (opts.fnIsValid) {
			const hkText = () => comp._state.isValid = !comp._state.text.trim() || !!opts.fnIsValid(comp._state.text);
			comp._addHookBase(propValue, hkText);
			hkText();

			const hkIsValid = () => $iptStr.toggleClass("form-control--error", !comp._state.isValid);
			comp._addHookBase("isValid", hkIsValid);
			hkIsValid();
		}

		const {$modalInner, doClose, pGetResolved, doAutoResize: doAutoResizeModal} = await InputUiUtil$1._pGetShowModal({
			title: opts.title || "Enter Text",
			isMinHeight0: true,
		});

		const $btnOk = this._$getBtnOk({comp, opts, doClose});
		const $btnCancel = this._$getBtnCancel({comp, opts, doClose});
		const $btnSkip = this._$getBtnSkip({comp, opts, doClose});

		if (opts.$elePre) opts.$elePre.appendTo($modalInner);
		$iptStr.appendTo($modalInner);
		if (opts.$elePost) opts.$elePost.appendTo($modalInner);
		$$`<div class="ve-flex-v-center ve-flex-h-right pb-1 px-1">${$btnOk}${$btnCancel}${$btnSkip}</div>`.appendTo($modalInner);

		if (doAutoResizeModal) doAutoResizeModal();

		$iptStr.focus();
		$iptStr.select();

		if (opts.cbPostRender) {
			opts.cbPostRender({
				comp,
				$iptStr,
				propValue,
			});
		}

				const [isDataEntered] = await pGetResolved();

		if (typeof isDataEntered === "symbol") return isDataEntered;
		if (!isDataEntered) return null;
		const raw = $iptStr.val();
		return raw;
			}

		static async pGetUserText (opts) {
		opts = opts || {};

		const $iptStr = $(`<textarea class="form-control mb-2 resize-vertical w-100" ${opts.disabled ? "disabled" : ""}></textarea>`)
			.val(opts.default);
		if (opts.isCode) $iptStr.addClass("code");

		const {$modalInner, doClose, pGetResolved, doAutoResize: doAutoResizeModal} = await InputUiUtil$1._pGetShowModal({
			title: opts.title || "Enter Text",
			isMinHeight0: true,
		});

		const $btnOk = this._$getBtnOk({opts, doClose});
		const $btnCancel = this._$getBtnCancel({opts, doClose});
		const $btnSkip = this._$getBtnSkip({opts, doClose});

		$iptStr.appendTo($modalInner);
		$$`<div class="ve-flex-v-center ve-flex-h-right pb-1 px-1">${$btnOk}${$btnCancel}${$btnSkip}</div>`.appendTo($modalInner);

		if (doAutoResizeModal) doAutoResizeModal();

		$iptStr.focus();
		$iptStr.select();

				const [isDataEntered] = await pGetResolved();

		if (typeof isDataEntered === "symbol") return isDataEntered;
		if (!isDataEntered) return null;
		const raw = $iptStr.val();
		if (!raw.trim()) return null;
		else return raw;
			}

		static async pGetUserColor (opts) {
		opts = opts || {};

		const $iptRgb = $(`<input class="form-control mb-2" ${opts.default != null ? `value="${opts.default}"` : ""} type="color">`);

		const {$modalInner, doClose, pGetResolved, doAutoResize: doAutoResizeModal} = await InputUiUtil$1._pGetShowModal({
			title: opts.title || "Choose Color",
			isMinHeight0: true,
		});

		const $btnOk = this._$getBtnOk({opts, doClose});
		const $btnCancel = this._$getBtnCancel({opts, doClose});
		const $btnSkip = this._$getBtnSkip({opts, doClose});

		$iptRgb.appendTo($modalInner);
		$$`<div class="ve-flex-v-center ve-flex-h-right pb-1 px-1">${$btnOk}${$btnCancel}${$btnSkip}</div>`.appendTo($modalInner);

		if (doAutoResizeModal) doAutoResizeModal();

		$iptRgb.focus();
		$iptRgb.select();

				const [isDataEntered] = await pGetResolved();

		if (typeof isDataEntered === "symbol") return isDataEntered;
		if (!isDataEntered) return null;
		const raw = $iptRgb.val();
		if (!raw.trim()) return null;
		else return raw;
			}

		static async pGetUserDirection (opts) {
		const X = 0;
		const Y = 1;
		const DEG_CIRCLE = 360;

		opts = opts || {};
		const step = Math.max(2, Math.min(DEG_CIRCLE, opts.step || DEG_CIRCLE));
		const stepDeg = DEG_CIRCLE / step;

		function getAngle (p1, p2) {
			return Math.atan2(p2[Y] - p1[Y], p2[X] - p1[X]) * 180 / Math.PI;
		}

		let active = false;
		let curAngle = Math.min(DEG_CIRCLE, opts.default) || 0;

		const $arm = $(`<div class="ui-dir__arm"></div>`);
		const handleAngle = () => $arm.css({transform: `rotate(${curAngle + 180}deg)`});
		handleAngle();

		const $pad = $$`<div class="ui-dir__face">${$arm}</div>`.on("mousedown touchstart", evt => {
			active = true;
			handleEvent(evt);
		});

		const $document = $(document);
		const evtId = `ui_user_dir_${CryptUtil.uid()}`;
		$document.on(`mousemove.${evtId} touchmove${evtId}`, evt => {
			handleEvent(evt);
		}).on(`mouseup.${evtId} touchend${evtId} touchcancel${evtId}`, evt => {
			evt.preventDefault();
			evt.stopPropagation();
			active = false;
		});
		const handleEvent = (evt) => {
			if (!active) return;

			const coords = [EventUtil.getClientX(evt), EventUtil.getClientY(evt)];

			const {top, left} = $pad.offset();
			const center = [left + ($pad.width() / 2), top + ($pad.height() / 2)];
			curAngle = getAngle(center, coords) + 90;
			if (step !== DEG_CIRCLE) curAngle = Math.round(curAngle / stepDeg) * stepDeg;
			else curAngle = Math.round(curAngle);
			handleAngle();
		};

		const BTN_STEP_SIZE = 26;
		const BORDER_PAD = 16;
		const CONTROLS_RADIUS = (92 + BTN_STEP_SIZE + BORDER_PAD) / 2;
		const $padOuter = opts.stepButtons ? (() => {
			const steps = opts.stepButtons;
			const SEG_ANGLE = 360 / steps.length;

			const $btns = [];

			for (let i = 0; i < steps.length; ++i) {
				const theta = (SEG_ANGLE * i * (Math.PI / 180)) - (1.5708); 				const x = CONTROLS_RADIUS * Math.cos(theta);
				const y = CONTROLS_RADIUS * Math.sin(theta);
				$btns.push(
					$(`<button class="btn btn-default btn-xxs absolute">${steps[i]}</button>`)
						.css({
							top: y + CONTROLS_RADIUS - (BTN_STEP_SIZE / 2),
							left: x + CONTROLS_RADIUS - (BTN_STEP_SIZE / 2),
							width: BTN_STEP_SIZE,
							height: BTN_STEP_SIZE,
							zIndex: 1002,
						})
						.click(() => {
							curAngle = SEG_ANGLE * i;
							handleAngle();
						}),
				);
			}

			const $wrpInner = $$`<div class="ve-flex-vh-center relative">${$btns}${$pad}</div>`
				.css({
					width: CONTROLS_RADIUS * 2,
					height: CONTROLS_RADIUS * 2,
				});

			return $$`<div class="ve-flex-vh-center">${$wrpInner}</div>`
				.css({
					width: (CONTROLS_RADIUS * 2) + BTN_STEP_SIZE + BORDER_PAD,
					height: (CONTROLS_RADIUS * 2) + BTN_STEP_SIZE + BORDER_PAD,
				});
		})() : null;

		const {$modalInner, doClose, pGetResolved, doAutoResize: doAutoResizeModal} = await InputUiUtil$1._pGetShowModal({
			title: opts.title || "Select Direction",
			isMinHeight0: true,
		});

		const $btnOk = this._$getBtnOk({opts, doClose});
		const $btnCancel = this._$getBtnCancel({opts, doClose});
		const $btnSkip = this._$getBtnSkip({opts, doClose});

		$$`<div class="ve-flex-vh-center mb-3">
				${$padOuter || $pad}
			</div>`.appendTo($modalInner);
		$$`<div class="ve-flex-v-center ve-flex-h-right pb-1 px-1">${$btnOk}${$btnCancel}${$btnSkip}</div>`.appendTo($modalInner);

		if (doAutoResizeModal) doAutoResizeModal();

				const [isDataEntered] = await pGetResolved();

		if (typeof isDataEntered === "symbol") return isDataEntered;
		$document.off(`mousemove.${evtId} touchmove${evtId} mouseup.${evtId} touchend${evtId} touchcancel${evtId}`);
		if (!isDataEntered) return null;
		if (curAngle < 0) curAngle += 360;
		return curAngle; 			}

		static async pGetUserDice (opts) {
		opts = opts || {};

		const comp = BaseComponent$1.fromObject({
			num: (opts.default && opts.default.num) || 1,
			faces: (opts.default && opts.default.faces) || 6,
			bonus: (opts.default && opts.default.bonus) || null,
		});

		comp.render = function ($parent) {
			$parent.empty();

			const $iptNum = ComponentUiUtil$1.$getIptInt(this, "num", 0, {$ele: $(`<input class="form-control input-xs form-control--minimal text-center mr-1">`)})
				.appendTo($parent)
				.keydown(evt => {
					if (evt.key === "Escape") { $iptNum.blur(); return; }
										if (evt.which === 13) doClose(true);
					evt.stopPropagation();
				});
			const $selFaces = ComponentUiUtil$1.$getSelEnum(this, "faces", {values: Renderer.dice.DICE})
				.addClass("mr-2").addClass("text-center").css("textAlignLast", "center");

			const $iptBonus = $(`<input class="form-control input-xs form-control--minimal text-center">`)
				.change(() => this._state.bonus = UiUtil$1.strToInt($iptBonus.val(), null, {fallbackOnNaN: null}))
				.keydown(evt => {
					if (evt.key === "Escape") { $iptBonus.blur(); return; }
										if (evt.which === 13) doClose(true);
					evt.stopPropagation();
				});
			const hook = () => $iptBonus.val(this._state.bonus != null ? UiUtil$1.intToBonus(this._state.bonus) : this._state.bonus);
			comp._addHookBase("bonus", hook);
			hook();

			$$`<div class="ve-flex-vh-center">${$iptNum}<div class="mr-1">d</div>${$selFaces}${$iptBonus}</div>`.appendTo($parent);
		};

		comp.getAsString = function () {
			return `${this._state.num}d${this._state.faces}${this._state.bonus ? UiUtil$1.intToBonus(this._state.bonus) : ""}`;
		};

		const {$modalInner, doClose, pGetResolved, doAutoResize: doAutoResizeModal} = await InputUiUtil$1._pGetShowModal({
			title: opts.title || "Enter Dice",
			isMinHeight0: true,
		});

		const $btnOk = this._$getBtnOk({opts, doClose});
		const $btnCancel = this._$getBtnCancel({opts, doClose});
		const $btnSkip = this._$getBtnSkip({opts, doClose});

		comp.render($modalInner);

		$$`<div class="ve-flex-v-center ve-flex-h-right pb-1 px-1 mt-2">${$btnOk}${$btnCancel}${$btnSkip}</div>`.appendTo($modalInner);

		if (doAutoResizeModal) doAutoResizeModal();

				const [isDataEntered] = await pGetResolved();

		if (typeof isDataEntered === "symbol") return isDataEntered;
		if (!isDataEntered) return null;
		return comp.getAsString();
			}
};

let DragReorderUiUtil$1 = class DragReorderUiUtil {
		static $getDragPad (opts) {
		opts = opts || {};

		const getComponentById = (id) => opts.componentsParent[opts.componentsProp].find(it => it.id === id);

		const dragMeta = {};
		const doDragCleanup = () => {
			dragMeta.on = false;
			dragMeta.$wrap.remove();
			dragMeta.$dummies.forEach($d => $d.remove());
			$(document.body).off(`mouseup.drag__stop`);
		};

		const doDragRender = () => {
			if (dragMeta.on) doDragCleanup();

			$(document.body).on(`mouseup.drag__stop`, () => {
				if (dragMeta.on) doDragCleanup();
			});

			dragMeta.on = true;
			dragMeta.$wrap = $(`<div class="ve-flex-col ui-drag__wrp-drag-block"></div>`).appendTo(opts.$parent);
			dragMeta.$dummies = [];

			const ids = opts.componentsParent[opts.componentsProp].map(it => it.id);

			ids.forEach(id => {
				const $dummy = $(`<div class="w-100 ${id === opts.componentId ? "ui-drag__wrp-drag-dummy--highlight" : "ui-drag__wrp-drag-dummy--lowlight"}"></div>`)
					.height(getComponentById(id).height)
					.mouseup(() => {
						if (dragMeta.on) doDragCleanup();
					})
					.appendTo(dragMeta.$wrap);
				dragMeta.$dummies.push($dummy);

				if (id !== opts.componentId) { 					$dummy.mouseenter(() => {
						const cachedPos = getComponentById(id).pos;

						getComponentById(id).pos = getComponentById(opts.componentId).pos;
						getComponentById(opts.componentId).pos = cachedPos;

						doDragRender();
					});
				}
			});
		};

		return $(`<div class="m${opts.marginSide || "l"}-2 ui-drag__patch" title="Drag to Reorder">
		<div class="ui-drag__patch-col"><div>&#8729</div><div>&#8729</div><div>&#8729</div></div>
		<div class="ui-drag__patch-col"><div>&#8729</div><div>&#8729</div><div>&#8729</div></div>
		</div>`).mousedown(() => doDragRender());
	}

		static $getDragPadOpts ($fnGetRow, opts) {
		if (!opts.$parent || !opts.swapRowPositions || (!opts.$children && !opts.$getChildren)) throw new Error("Missing required option(s)!");

		const dragMeta = {};
		const doDragCleanup = () => {
			dragMeta.on = false;
			dragMeta.$wrap.remove();
			dragMeta.$dummies.forEach($d => $d.remove());
			$(document.body).off(`mouseup.drag__stop`);
			if (opts.fnOnDragComplete) opts.fnOnDragComplete();
		};

		const doDragRender = () => {
			if (dragMeta.on) doDragCleanup();

			$(document.body).on(`mouseup.drag__stop`, () => {
				if (dragMeta.on) doDragCleanup();
			});

			dragMeta.on = true;
			dragMeta.$wrap = $(`<div class="ve-flex-col ui-drag__wrp-drag-block"></div>`).appendTo(opts.$parent);
			dragMeta.$dummies = [];

			const $children = opts.$getChildren ? opts.$getChildren() : opts.$children;
			const ixRow = $children.indexOf($fnGetRow());

			$children.forEach(($child, i) => {
				const dimensions = {w: $child.outerWidth(true), h: $child.outerHeight(true)};
				const $dummy = $(`<div class="no-shrink ${i === ixRow ? "ui-drag__wrp-drag-dummy--highlight" : "ui-drag__wrp-drag-dummy--lowlight"}"></div>`)
					.width(dimensions.w).height(dimensions.h)
					.mouseup(() => {
						if (dragMeta.on) doDragCleanup();
					})
					.appendTo(dragMeta.$wrap);
				dragMeta.$dummies.push($dummy);

				if (i !== ixRow) { 					$dummy.mouseenter(() => {
						opts.swapRowPositions(i, ixRow);
						doDragRender();
					});
				}
			});
		};

		return $(`<div class="mr-2 ui-drag__patch" title="Drag to Reorder">
		<div class="ui-drag__patch-col"><div>&#8729</div><div>&#8729</div><div>&#8729</div></div>
		<div class="ui-drag__patch-col"><div>&#8729</div><div>&#8729</div><div>&#8729</div></div>
		</div>`).mousedown(() => doDragRender());
	}

		static $getDragPad2 ($fnGetRow, $parent, parent) {
		const {swapRowPositions, $children, $getChildren} = parent;
		const nxtOpts = {$parent, swapRowPositions, $children, $getChildren};
		return this.$getDragPadOpts($fnGetRow, nxtOpts);
	}
};

class SourceUiUtil {
	static _getValidOptions (options) {
		if (!options) throw new Error(`No options were specified!`);
		if (!options.$parent || !options.cbConfirm || !options.cbConfirmExisting || !options.cbCancel) throw new Error(`Missing options!`);
		options.mode = options.mode || "add";
		return options;
	}

		static render (options) {
		options = SourceUiUtil._getValidOptions(options);
		options.$parent.empty();
		options.mode = options.mode || "select";

		const isEditMode = options.mode === "edit";

		let jsonDirty = false;
		const $iptName = $(`<input class="form-control ui-source__ipt-named">`)
			.keydown(evt => { if (evt.key === "Escape") $iptName.blur(); })
			.change(() => {
				if (!jsonDirty && !isEditMode) $iptJson.val($iptName.val().replace(/[^-_a-zA-Z]/g, ""));
				$iptName.removeClass("form-control--error");
			});
		if (options.source) $iptName.val(options.source.full);
		const $iptAbv = $(`<input class="form-control ui-source__ipt-named">`)
			.keydown(evt => { if (evt.key === "Escape") $iptAbv.blur(); })
			.change(() => {
				$iptAbv.removeClass("form-control--error");
			});
		if (options.source) $iptAbv.val(options.source.abbreviation);
		const $iptJson = $(`<input class="form-control ui-source__ipt-named" ${isEditMode ? "disabled" : ""}>`)
			.keydown(evt => { if (evt.key === "Escape") $iptJson.blur(); })
			.change(() => {
				jsonDirty = true;
				$iptJson.removeClass("form-control--error");
			});
		if (options.source) $iptJson.val(options.source.json);
		let hasColor = false;
		const $iptColor = $(`<input type="color" class="w-100 b-0">`)
			.keydown(evt => { if (evt.key === "Escape") $iptColor.blur(); })
			.change(() => hasColor = true);
		if (options.source?.color != null) (hasColor = true) && $iptColor.val(options.source.color);
		const $iptUrl = $(`<input class="form-control ui-source__ipt-named">`)
			.keydown(evt => { if (evt.key === "Escape") $iptUrl.blur(); });
		if (options.source) $iptUrl.val(options.source.url);
		const $iptAuthors = $(`<input class="form-control ui-source__ipt-named">`)
			.keydown(evt => { if (evt.key === "Escape") $iptAuthors.blur(); });
		if (options.source) $iptAuthors.val((options.source.authors || []).join(", "));
		const $iptConverters = $(`<input class="form-control ui-source__ipt-named">`)
			.keydown(evt => { if (evt.key === "Escape") $iptConverters.blur(); });
		if (options.source) $iptConverters.val((options.source.convertedBy || []).join(", "));

		const $btnOk = $(`<button class="btn btn-primary">OK</button>`)
			.click(async () => {
				let incomplete = false;
				[$iptName, $iptAbv, $iptJson].forEach($ipt => {
					const val = $ipt.val();
					if (!val || !val.trim()) (incomplete = true) && $ipt.addClass("form-control--error");
				});
				if (incomplete) return;

				const jsonVal = $iptJson.val().trim();
				if (!isEditMode && BrewUtil2.hasSourceJson(jsonVal)) {
					$iptJson.addClass("form-control--error");
					JqueryUtil.doToast({content: `The JSON identifier "${jsonVal}" already exists!`, type: "danger"});
					return;
				}

				const source = {
					json: jsonVal,
					abbreviation: $iptAbv.val().trim(),
					full: $iptName.val().trim(),
					url: $iptUrl.val().trim(),
					authors: $iptAuthors.val().trim().split(",").map(it => it.trim()).filter(Boolean),
					convertedBy: $iptConverters.val().trim().split(",").map(it => it.trim()).filter(Boolean),
				};
				if (hasColor) source.color = $iptColor.val().trim();

				await options.cbConfirm(source, options.mode !== "edit");
			});

		const $btnCancel = options.isRequired && !isEditMode
			? null
			: $(`<button class="btn btn-default ml-2">Cancel</button>`).click(() => options.cbCancel());

		const $btnUseExisting = $(`<button class="btn btn-default">Use an Existing Source</button>`)
			.click(() => {
				$stageInitial.hideVe();
				$stageExisting.showVe();

								[$iptName, $iptAbv, $iptJson].forEach($ipt => $ipt.removeClass("form-control--error"));
			});

		const $stageInitial = $$`<div class="h-100 w-100 ve-flex-vh-center"><div class="ve-flex-col">
			<h3 class="text-center">${isEditMode ? "Edit Homebrew Source" : "Add a Homebrew Source"}</h3>
			<div class="ui-source__row mb-2"><div class="col-12 ve-flex-v-center">
				<span class="mr-2 ui-source__name help" title="The name or title for the homebrew you wish to create. This could be the name of a book or PDF; for example, 'Monster Manual'">Title</span>
				${$iptName}
			</div></div>
			<div class="ui-source__row mb-2"><div class="col-12 ve-flex-v-center">
				<span class="mr-2 ui-source__name help" title="An abbreviated form of the title. This will be shown in lists on the site, and in the top-right corner of stat blocks or data entries; for example, 'MM'">Abbreviation</span>
				${$iptAbv}
			</div></div>
			<div class="ui-source__row mb-2"><div class="col-12 ve-flex-v-center">
				<span class="mr-2 ui-source__name help" title="This will be used to identify your homebrew universally, so should be unique to you and you alone">JSON Identifier</span>
				${$iptJson}
			</div></div>
			<div class="ui-source__row mb-2"><div class="col-12 ve-flex-v-center">
				<span class="mr-2 ui-source__name help" title="A color which should be used when displaying the source abbreviation">Color</span>
				${$iptColor}
			</div></div>
			<div class="ui-source__row mb-2"><div class="col-12 ve-flex-v-center">
				<span class="mr-2 ui-source__name help" title="A link to the original homebrew, e.g. a GM Binder page">Source URL</span>
				${$iptUrl}
			</div></div>
			<div class="ui-source__row mb-2"><div class="col-12 ve-flex-v-center">
				<span class="mr-2 ui-source__name help" title="A comma-separated list of authors, e.g. 'John Doe, Joe Bloggs'">Author(s)</span>
				${$iptAuthors}
			</div></div>
			<div class="ui-source__row mb-2"><div class="col-12 ve-flex-v-center">
				<span class="mr-2 ui-source__name help" title="A comma-separated list of people who converted the homebrew to 5etools' format, e.g. 'John Doe, Joe Bloggs'">Converted By</span>
				${$iptConverters}
			</div></div>
			<div class="text-center mb-2">${$btnOk}${$btnCancel}</div>

			${!isEditMode && BrewUtil2.getMetaLookup("sources")?.length ? $$`<div class="ve-flex-vh-center mb-3 mt-3"><span class="ui-source__divider"></span>or<span class="ui-source__divider"></span></div>
			<div class="ve-flex-vh-center">${$btnUseExisting}</div>` : ""}
		</div></div>`.appendTo(options.$parent);

		const $selExisting = $$`<select class="form-control input-sm">
			<option disabled>Select</option>
			${(BrewUtil2.getMetaLookup("sources") || []).sort((a, b) => SortUtil.ascSortLower(a.full, b.full)).map(s => `<option value="${s.json.escapeQuotes()}">${s.full.escapeQuotes()}</option>`)}
		</select>`.change(() => $selExisting.removeClass("form-control--error"));
		$selExisting[0].selectedIndex = 0;

		const $btnConfirmExisting = $(`<button class="btn btn-default btn-sm">Confirm</button>`)
			.click(async () => {
				if ($selExisting[0].selectedIndex === 0) {
					$selExisting.addClass("form-control--error");
					return;
				}

				const sourceJson = $selExisting.val();
				const source = BrewUtil2.sourceJsonToSource(sourceJson);
				await options.cbConfirmExisting(source);

								$selExisting[0].selectedIndex = 0;
				$stageExisting.hideVe();
				$stageInitial.showVe();
			});

		const $btnBackExisting = $(`<button class="btn btn-default btn-sm mr-2">Back</button>`)
			.click(() => {
				$selExisting[0].selectedIndex = 0;
				$stageExisting.hideVe();
				$stageInitial.showVe();
			});

		const $stageExisting = $$`<div class="h-100 w-100 ve-flex-vh-center ve-hidden"><div>
			<h3 class="text-center">Select a Homebrew Source</h3>
			<div class="mb-2"><div class="col-12 ve-flex-vh-center">${$selExisting}</div></div>
			<div class="col-12 ve-flex-vh-center">${$btnBackExisting}${$btnConfirmExisting}</div>
		</div></div>`.appendTo(options.$parent);
	}
}

function MixinBaseComponent (Cls) {
	class MixedBaseComponent extends Cls {
		constructor (...args) {
			super(...args);

			this.__locks = {};
			this.__rendered = {};

						this.__state = {...this._getDefaultState()};
			this._state = this._getProxy("state", this.__state);
		}

		_addHookBase (prop, hook) {
			return this._addHook("state", prop, hook);
		}

		_removeHookBase (prop, hook) {
			return this._removeHook("state", prop, hook);
		}

		_removeHooksBase (prop) {
			return this._removeHooks("state", prop);
		}

		_addHookAllBase (hook) {
			return this._addHookAll("state", hook);
		}

		_removeHookAllBase (hook) {
			return this._removeHookAll("state", hook);
		}

		_setState (toState) {
			this._proxyAssign("state", "_state", "__state", toState, true);
		}

		_setStateValue (prop, value, {isForceTriggerHooks = true} = {}) {
			if (this._state[prop] === value && !isForceTriggerHooks) return value;
						if (this._state[prop] !== value) return this._state[prop] = value;

			this._doFireHooksAll("state", prop, value, value);
			this._doFireHooks("state", prop, value, value);
			return value;
		}

		_getState () { return MiscUtil.copyFast(this.__state); }

		getPod () {
			this.__pod = this.__pod || {
				get: (prop) => this._state[prop],
				set: (prop, val) => this._state[prop] = val,
				delete: (prop) => delete this._state[prop],
				addHook: (prop, hook) => this._addHookBase(prop, hook),
				addHookAll: (hook) => this._addHookAllBase(hook),
				removeHook: (prop, hook) => this._removeHookBase(prop, hook),
				removeHookAll: (hook) => this._removeHookAllBase(hook),
				triggerCollectionUpdate: (prop) => this._triggerCollectionUpdate(prop),
				setState: (state) => this._setState(state),
				getState: () => this._getState(),
				assign: (toObj, isOverwrite) => this._proxyAssign("state", "_state", "__state", toObj, isOverwrite),
				pLock: lockName => this._pLock(lockName),
				unlock: lockName => this._unlock(lockName),
				component: this,
			};
			return this.__pod;
		}

				_getDefaultState () { return {}; }

		getBaseSaveableState () {
			return {
				state: MiscUtil.copyFast(this.__state),
			};
		}

		setBaseSaveableStateFrom (toLoad, isOverwrite = false) {
			toLoad?.state && this._proxyAssignSimple("state", toLoad.state, isOverwrite);
		}

				_getRenderedCollection (opts) {
			opts = opts || {};
			const renderedLookupProp = opts.namespace ? `${opts.namespace}.${opts.prop}` : opts.prop;
			return (this.__rendered[renderedLookupProp] = this.__rendered[renderedLookupProp] || {});
		}

				_renderCollection (opts) {
			opts = opts || {};

			const rendered = this._getRenderedCollection(opts);
			const toDelete = new Set(Object.keys(rendered));

			(this._state[opts.prop] || []).forEach((it, i) => {
				if (it.id == null) throw new Error(`Collection item did not have an ID!`);
				const meta = rendered[it.id];

				toDelete.delete(it.id);
				if (meta) {
					if (opts.isDiffMode) {
												const nxtHash = CryptUtil.md5(JSON.stringify(it));
						if (nxtHash !== meta.__hash) {
							meta.__hash = nxtHash;
						} else return;
					}

					meta.data = it; 					opts.fnUpdateExisting(meta, it, i);
				} else {
					const meta = opts.fnGetNew(it, i);

										if (meta == null) return;

					meta.data = it;
					if (!meta.$wrpRow && !meta.fmRemoveEles) throw new Error(`A "$wrpRow" or a "fmRemoveEles" property is required for deletes!`);

					if (opts.isDiffMode) meta.hash = CryptUtil.md5(JSON.stringify(it));

					rendered[it.id] = meta;
				}
			});

			toDelete.forEach(id => {
				const meta = rendered[id];
				if (meta.$wrpRow) meta.$wrpRow.remove();
				if (meta.fmRemoveEles) meta.fmRemoveEles();
				delete rendered[id];
				if (opts.fnDeleteExisting) opts.fnDeleteExisting(meta);
			});

			if (opts.fnReorderExisting) {
				(this._state[opts.prop] || []).forEach((it, i) => {
					const meta = rendered[it.id];
					opts.fnReorderExisting(meta, it, i);
				});
			}
		}

				async _pRenderCollection (opts) {
			opts = opts || {};

			const rendered = this._getRenderedCollection(opts);
			const entities = this._state[opts.prop];
			return this._pRenderCollection_doRender(rendered, entities, opts);
		}

		async _pRenderCollection_doRender (rendered, entities, opts) {
			opts = opts || {};

			const toDelete = new Set(Object.keys(rendered));

						for (let i = 0; i < entities.length; ++i) {
				const it = entities[i];

				if (!it.id) throw new Error(`Collection item did not have an ID!`);
								const meta = rendered[it.id];

				toDelete.delete(it.id);
				if (meta) {
					if (opts.isDiffMode) {
												const nxtHash = CryptUtil.md5(JSON.stringify(it));
						if (nxtHash !== meta.__hash) meta.__hash = nxtHash;
						else continue;
					}

					const nxtMeta = await opts.pFnUpdateExisting(meta, it);
															if (opts.isMultiRender) rendered[it.id] = nxtMeta;
				} else {
					const meta = await opts.pFnGetNew(it);
										if (meta == null) continue;

					if (opts.isMultiRender && meta.some(it => !it.$wrpRow && !it.fmRemoveEles)) throw new Error(`A "$wrpRow" or a "fmRemoveEles" property is required for deletes!`);
					if (!opts.isMultiRender && !meta.$wrpRow && !meta.fmRemoveEles) throw new Error(`A "$wrpRow" or a "fmRemoveEles" property is required for deletes!`);

					if (opts.isDiffMode) meta.__hash = CryptUtil.md5(JSON.stringify(it));

					rendered[it.id] = meta;
				}
			}

			const doRemoveELements = meta => {
				if (meta.$wrpRow) meta.$wrpRow.remove();
				if (meta.fmRemoveEles) meta.fmRemoveEles();
			};

			for (const id of toDelete) {
				const meta = rendered[id];
				if (opts.isMultiRender) meta.forEach(it => doRemoveELements(it));
				else doRemoveELements(meta);
				if (opts.additionalCaches) opts.additionalCaches.forEach(it => delete it[id]);
				delete rendered[id];
				if (opts.pFnDeleteExisting) await opts.pFnDeleteExisting(meta);
			}
		}

				_detachCollection (prop, namespace = null) {
			const renderedLookupProp = namespace ? `${namespace}.${prop}` : prop;
			const rendered = (this.__rendered[renderedLookupProp] = this.__rendered[renderedLookupProp] || {});
			Object.values(rendered).forEach(it => it.$wrpRow.detach());
		}

				_resetCollectionRenders (prop, namespace = null) {
			const renderedLookupProp = namespace ? `${namespace}.${prop}` : prop;
			const rendered = (this.__rendered[renderedLookupProp] = this.__rendered[renderedLookupProp] || {});
			Object.values(rendered).forEach(it => it.$wrpRow.remove());
			delete this.__rendered[renderedLookupProp];
		}

		render () { throw new Error("Unimplemented!"); }

				getSaveableState () { return {...this.getBaseSaveableState()}; }
		setStateFrom (toLoad, isOverwrite = false) { this.setBaseSaveableStateFrom(toLoad, isOverwrite); }

		async _pLock (lockName) {
			while (this.__locks[lockName]) await this.__locks[lockName].lock;
			let unlock = null;
			const lock = new Promise(resolve => unlock = resolve);
			this.__locks[lockName] = {
				lock,
				unlock,
			};
		}

		async _pGate (lockName) {
			while (this.__locks[lockName]) await this.__locks[lockName].lock;
		}

		_unlock (lockName) {
			const lockMeta = this.__locks[lockName];
			if (lockMeta) {
				delete this.__locks[lockName];
				lockMeta.unlock();
			}
		}

		async _pDoProxySetBase (prop, value) { return this._pDoProxySet("state", this.__state, prop, value); }

		_triggerCollectionUpdate (prop) {
			if (!this._state[prop]) return;
			this._state[prop] = [...this._state[prop]];
		}

		static _toCollection (array) {
			if (array) return array.map(it => ({id: CryptUtil.uid(), entity: it}));
		}

		static _fromCollection (array) {
			if (array) return array.map(it => it.entity);
		}

		static fromObject (obj, ...noModCollections) {
			const comp = new this();
			Object.entries(MiscUtil.copyFast(obj)).forEach(([k, v]) => {
				if (v == null) comp.__state[k] = v;
				else if (noModCollections.includes(k) || noModCollections.includes("*")) comp.__state[k] = v;
				else if (typeof v === "object" && v instanceof Array) comp.__state[k] = BaseComponent$1._toCollection(v);
				else comp.__state[k] = v;
			});
			return comp;
		}

		static fromObjectNoMod (obj) { return this.fromObject(obj, "*"); }

		toObject (...noModCollections) {
			const cpy = MiscUtil.copyFast(this.__state);
			Object.entries(cpy).forEach(([k, v]) => {
				if (v == null) return;

				if (noModCollections.includes(k) || noModCollections.includes("*")) cpy[k] = v;
				else if (v instanceof Array && v.every(it => it && it.id)) cpy[k] = BaseComponent$1._fromCollection(v);
			});
			return cpy;
		}

		toObjectNoMod () { return this.toObject("*"); }
	}

	return MixedBaseComponent;
}

let BaseComponent$1 = class BaseComponent extends MixinBaseComponent(ProxyBase$1) {};

globalThis.BaseComponent = BaseComponent$1;

let RenderableCollectionBase$1 = class RenderableCollectionBase {
		constructor (comp, prop, opts) {
		opts = opts || {};
		this._comp = comp;
		this._prop = prop;
		this._namespace = opts.namespace;
		this._isDiffMode = opts.isDiffMode;
	}

	getNewRender (entity, i) {
		throw new Error(`Unimplemented!`);
	}

	doUpdateExistingRender (renderedMeta, entity, i) {
		throw new Error(`Unimplemented!`);
	}

	doDeleteExistingRender (renderedMeta) {
			}

	doReorderExistingComponent (renderedMeta, entity, i) {
			}

	_getCollectionItem (id) {
		return this._comp._state[this._prop].find(it => it.id === id);
	}

		render (opts) {
		opts = opts || {};
		this._comp._renderCollection({
			prop: this._prop,
			fnUpdateExisting: (rendered, ent, i) => this.doUpdateExistingRender(rendered, ent, i),
			fnGetNew: (entity, i) => this.getNewRender(entity, i),
			fnDeleteExisting: (rendered) => this.doDeleteExistingRender(rendered),
			fnReorderExisting: (rendered, ent, i) => this.doReorderExistingComponent(rendered, ent, i),
			namespace: this._namespace,
			isDiffMode: opts.isDiffMode != null ? opts.isDiffMode : this._isDiffMode,
		});
	}
};

class RenderableCollectionAsyncBase {
		constructor (comp, prop, opts) {
		opts = opts || {};
		this._comp = comp;
		this._prop = prop;
		this._namespace = opts.namespace;
		this._isDiffMode = opts.isDiffMode;
		this._isMultiRender = opts.isMultiRender;
		this._additionalCaches = opts.additionalCaches;
	}

	pGetNewRender (entity, i) {
		throw new Error(`Unimplemented!`);
	}

	pDoUpdateExistingRender (renderedMeta, entity, i) {
		throw new Error(`Unimplemented!`);
	}

		render (opts) {
		opts = opts || {};
		this._comp._pRenderCollection({
			prop: this._prop,
			fnUpdateExisting: (rendered, source, i) => this.pDoUpdateExistingRender(rendered, source, i),
			fnGetNew: (entity, i) => this.pGetNewRender(entity, i),
			namespace: this._namespace,
			isDiffMode: opts.isDiffMode != null ? opts.isDiffMode : this._isDiffMode,
			isMultiRender: this._isMultiRender,
			additionalCaches: this._additionalCaches,
		});
	}
}

class BaseLayeredComponent extends BaseComponent$1 {
	constructor () {
		super();

				this._layers = [];
		this.__layerMeta = {};
		this._layerMeta = this._getProxy("layerMeta", this.__layerMeta);
	}

	_addHookDeep (prop, hook) {
		this._addHookBase(prop, hook);
		this._addHook("layerMeta", prop, hook);
	}

	_removeHookDeep (prop, hook) {
		this._removeHookBase(prop, hook);
		this._removeHook("layerMeta", prop, hook);
	}

	_getBase (prop) {
		return this._state[prop];
	}

	_get (prop) {
		if (this._layerMeta[prop]) {
			for (let i = this._layers.length - 1; i >= 0; --i) {
				const val = this._layers[i].data[prop];
				if (val != null) return val;
			}
					}
		return this._state[prop];
	}

	_addLayer (layer) {
		this._layers.push(layer);
		this._addLayer_addLayerMeta(layer);
	}

	_addLayer_addLayerMeta (layer) {
		Object.entries(layer.data).forEach(([k, v]) => this._layerMeta[k] = v != null);
	}

	_removeLayer (layer) {
		const ix = this._layers.indexOf(layer);
		if (~ix) {
			this._layers.splice(ix, 1);

						Object.keys(this._layerMeta).forEach(k => delete this._layerMeta[k]);
			this._layers.forEach(l => this._addLayer_addLayerMeta(l));
		}
	}

	updateLayersActive (prop) {
						this._layerMeta[prop] = this._layers.some(l => l.data[prop] != null);
	}

	getBaseSaveableState () {
		return {
			state: MiscUtil.copyFast(this.__state),
			layers: MiscUtil.copyFast(this._layers.map(l => l.getSaveableState())),
		};
	}

	setBaseSaveableStateFrom (toLoad) {
		toLoad.state && Object.assign(this._state, toLoad.state);
		if (toLoad.layers) toLoad.layers.forEach(l => this._addLayer(CompLayer.fromSavedState(this, l)));
	}

	getPod () {
		this.__pod = this.__pod || {
			...super.getPod(),

			addHookDeep: (prop, hook) => this._addHookDeep(prop, hook),
			removeHookDeep: (prop, hook) => this._removeHookDeep(prop, hook),
			addHookAll: (hook) => this._addHookAll("state", hook),
			getBase: (prop) => this._getBase(prop),
			get: (prop) => this._get(prop),
			addLayer: (name, data) => {
								const l = new CompLayer(this, name, data);
				this._addLayer(l);
				return l;
			},
			removeLayer: (layer) => this._removeLayer(layer),
			layers: this._layers, 		};
		return this.__pod;
	}
}

class CompLayer extends ProxyBase$1 {
	constructor (component, layerName, data) {
		super();

		this._name = layerName;
		this.__data = data;

		this.data = this._getProxy("data", this.__data);

		this._addHookAll("data", prop => component.updateLayersActive(prop));
	}

	getSaveableState () {
		return {
			name: this._name,
			data: MiscUtil.copyFast(this.__data),
		};
	}

	static fromSavedState (component, savedState) { return new CompLayer(component, savedState.name, savedState.data); }
}

function MixinComponentHistory (Cls) {
	class MixedComponentHistory extends Cls {
		constructor () {
			super(...arguments);
			this._histStackUndo = [];
			this._histStackRedo = [];
			this._isHistDisabled = true;
			this._histPropBlocklist = new Set();
			this._histPropAllowlist = null;

			this._histInitialState = null;
		}

		set isHistDisabled (val) { this._isHistDisabled = val; }
		addBlocklistProps (...props) { props.forEach(p => this._histPropBlocklist.add(p)); }
		addAllowlistProps (...props) {
			this._histPropAllowlist = this._histPropAllowlist || new Set();
			props.forEach(p => this._histPropAllowlist.add(p));
		}

				initHistory () {
						this._histInitialState = MiscUtil.copyFast(this._state);
			this._isHistDisabled = false;

			this._addHookAll("state", prop => {
				if (this._isHistDisabled) return;
				if (this._histPropBlocklist.has(prop)) return;
				if (this._histPropAllowlist && !this._histPropAllowlist.has(prop)) return;

				this.recordHistory();
			});
		}

		recordHistory () {
			const stateCopy = MiscUtil.copyFast(this._state);

						this._histPropBlocklist.forEach(prop => delete stateCopy[prop]);
			if (this._histPropAllowlist) Object.keys(stateCopy).filter(k => !this._histPropAllowlist.has(k)).forEach(k => delete stateCopy[k]);

			this._histStackUndo.push(stateCopy);
			this._histStackRedo = [];
		}

		_histAddExcludedProperties (stateCopy) {
			Object.entries(this._state).forEach(([k, v]) => {
				if (this._histPropBlocklist.has(k)) return stateCopy[k] = v;
				if (this._histPropAllowlist && !this._histPropAllowlist.has(k)) stateCopy[k] = v;
			});
		}

		undo () {
			if (this._histStackUndo.length) {
				const lastHistDisabled = this._isHistDisabled;
				this._isHistDisabled = true;

				const curState = this._histStackUndo.pop();
				this._histStackRedo.push(curState);
				const toApply = MiscUtil.copyFast(this._histStackUndo.last() || this._histInitialState);
				this._histAddExcludedProperties(toApply);
				this._setState(toApply);

				this._isHistDisabled = lastHistDisabled;
			} else {
				const lastHistDisabled = this._isHistDisabled;
				this._isHistDisabled = true;

				const toApply = MiscUtil.copyFast(this._histInitialState);
				this._histAddExcludedProperties(toApply);
				this._setState(toApply);

				this._isHistDisabled = lastHistDisabled;
			}
		}

		redo () {
			if (!this._histStackRedo.length) return;

			const lastHistDisabled = this._isHistDisabled;
			this._isHistDisabled = true;

			const toApplyRaw = this._histStackRedo.pop();
			this._histStackUndo.push(toApplyRaw);
			const toApply = MiscUtil.copyFast(toApplyRaw);
			this._histAddExcludedProperties(toApply);
			this._setState(toApply);

			this._isHistDisabled = lastHistDisabled;
		}
	}
	return MixedComponentHistory;
}

function MixinComponentGlobalState (Cls) {
	class MixedComponentGlobalState extends Cls {
		constructor (...args) {
			super(...args);

						this._stateGlobal = this._getProxy("stateGlobal", MixinComponentGlobalState._Singleton.__stateGlobal);

						MixinComponentGlobalState._Singleton._pLoadState()
				.then(() => {
					this._doFireHooksAll("stateGlobal");
					this._doFireAllHooks("stateGlobal");
					this._addHookAll("stateGlobal", MixinComponentGlobalState._Singleton._pSaveStateDebounced);
				});
		}

		get __stateGlobal () { return MixinComponentGlobalState._Singleton.__stateGlobal; }

		_addHookGlobal (prop, hook) {
			return this._addHook("stateGlobal", prop, hook);
		}
	}
	return MixedComponentGlobalState;
}

MixinComponentGlobalState._Singleton = class {
	static async _pSaveState () {
		return StorageUtil.pSet(VeCt.STORAGE_GLOBAL_COMPONENT_STATE, MiscUtil.copyFast(MixinComponentGlobalState._Singleton.__stateGlobal));
	}

	static async _pLoadState () {
		if (MixinComponentGlobalState._Singleton._pLoadingState) return MixinComponentGlobalState._Singleton._pLoadingState;
		return MixinComponentGlobalState._Singleton._pLoadingState = MixinComponentGlobalState._Singleton._pLoadState_();
	}

	static async _pLoadState_ () {
		Object.assign(MixinComponentGlobalState._Singleton.__stateGlobal, (await StorageUtil.pGet(VeCt.STORAGE_GLOBAL_COMPONENT_STATE)) || {});
	}

	static _getDefaultStateGlobal () {
		return {
			isUseSpellPoints: false,
		};
	}
};
MixinComponentGlobalState._Singleton.__stateGlobal = {...MixinComponentGlobalState._Singleton._getDefaultStateGlobal()};
MixinComponentGlobalState._Singleton._pSaveStateDebounced = MiscUtil.debounce(MixinComponentGlobalState._Singleton._pSaveState.bind(MixinComponentGlobalState._Singleton), 100);
MixinComponentGlobalState._Singleton._pLoadingState = null;


let ComponentUiUtil$1 = class ComponentUiUtil {
	static trackHook (hooks, prop, hook) {
		hooks[prop] = hooks[prop] || [];
		hooks[prop].push(hook);
	}

	static $getDisp (comp, prop, {html, $ele, fnGetText} = {}) {
		$ele = ($ele || $(html || `<div></div>`));

		const hk = () => $ele.text(fnGetText ? fnGetText(comp._state[prop]) : comp._state[prop]);
		comp._addHookBase(prop, hk);
		hk();

		return $ele;
	}

		static $getIptInt (component, prop, fallbackEmpty = 0, opts) {
		return ComponentUiUtil$1._$getIptNumeric(component, prop, UiUtil$1.strToInt, fallbackEmpty, opts);
	}

		static $getIptNumber (component, prop, fallbackEmpty = 0, opts) {
		return ComponentUiUtil$1._$getIptNumeric(component, prop, UiUtil$1.strToNumber, fallbackEmpty, opts);
	}

	static _$getIptNumeric (component, prop, fnConvert, fallbackEmpty = 0, opts) {
		opts = opts || {};
		opts.offset = opts.offset || 0;

		const setIptVal = () => {
			if (opts.isAllowNull && component._state[prop] == null) {
				return $ipt.val(null);
			}

			const num = (component._state[prop] || 0) + opts.offset;
			const val = opts.padLength ? `${num}`.padStart(opts.padLength, "0") : num;
			$ipt.val(val);
		};

		const $ipt = (opts.$ele || $(opts.html || `<input class="form-control input-xs form-control--minimal text-right">`)).disableSpellcheck()
			.keydown(evt => { if (evt.key === "Escape") $ipt.blur(); })
			.change(() => {
				const raw = $ipt.val().trim();
				const cur = component._state[prop];

				if (opts.isAllowNull && !raw) return component._state[prop] = null;

				if (raw.startsWith("=")) {
										component._state[prop] = fnConvert(raw.slice(1), fallbackEmpty, opts) - opts.offset;
				} else {
										const mUnary = prevValue != null && prevValue < 0
						? /^[+/*^]/.exec(raw) 						: /^[-+/*^]/.exec(raw);
					if (mUnary) {
						let proc = raw;
						proc = proc.slice(1).trim();
						const mod = fnConvert(proc, fallbackEmpty, opts);
						const full = `${cur}${mUnary[0]}${mod}`;
						component._state[prop] = fnConvert(full, fallbackEmpty, opts) - opts.offset;
					} else {
						component._state[prop] = fnConvert(raw, fallbackEmpty, opts) - opts.offset;
					}
				}

								if (cur === component._state[prop]) setIptVal();
			});

		let prevValue;
		const hook = () => {
			prevValue = component._state[prop];
			setIptVal();
		};
		if (opts.hookTracker) ComponentUiUtil$1.trackHook(opts.hookTracker, prop, hook);
		component._addHookBase(prop, hook);
		hook();

		if (opts.asMeta) return this._getIptDecoratedMeta(component, prop, $ipt, hook, opts);
		else return $ipt;
	}

		static $getIptStr (component, prop, opts) {
		opts = opts || {};

				if ((opts.decorationLeft || opts.decorationRight) && !opts.asMeta) throw new Error(`Input must be created with "asMeta" option`);

		const $ipt = (opts.$ele || $(opts.html || `<input class="form-control input-xs form-control--minimal">`))
			.keydown(evt => { if (evt.key === "Escape") $ipt.blur(); })
			.disableSpellcheck();
		UiUtil$1.bindTypingEnd({
			$ipt,
			fnKeyup: () => {
				const nxtVal = opts.isNoTrim ? $ipt.val() : $ipt.val().trim();
				component._state[prop] = opts.isAllowNull && !nxtVal ? null : nxtVal;
			},
		});

		if (opts.placeholder) $ipt.attr("placeholder", opts.placeholder);

		if (opts.autocomplete && opts.autocomplete.length) $ipt.typeahead({source: opts.autocomplete});
		const hook = () => {
			if (component._state[prop] == null) $ipt.val(null);
			else {
								if ($ipt.val().trim() !== component._state[prop]) $ipt.val(component._state[prop]);
			}
		};
		component._addHookBase(prop, hook);
		hook();

		if (opts.asMeta) return this._getIptDecoratedMeta(component, prop, $ipt, hook, opts);
		else return $ipt;
	}

	static _getIptDecoratedMeta (component, prop, $ipt, hook, opts) {
		const out = {$ipt, unhook: () => component._removeHookBase(prop, hook)};

		if (opts.decorationLeft || opts.decorationRight) {
			let $decorLeft;
			let $decorRight;

			if (opts.decorationLeft) {
				$ipt.addClass(`ui-ideco__ipt ui-ideco__ipt--left`);
				$decorLeft = ComponentUiUtil$1._$getDecor(component, prop, $ipt, opts.decorationLeft, "left", opts);
			}

			if (opts.decorationRight) {
				$ipt.addClass(`ui-ideco__ipt ui-ideco__ipt--right`);
				$decorRight = ComponentUiUtil$1._$getDecor(component, prop, $ipt, opts.decorationRight, "right", opts);
			}

			out.$wrp = $$`<div class="relative w-100">${$ipt}${$decorLeft}${$decorRight}</div>`;
		}

		return out;
	}

	static _$getDecor (component, prop, $ipt, decorType, side, opts) {
		switch (decorType) {
			case "search": {
				return $(`<div class="ui-ideco__wrp ui-ideco__wrp--${side} no-events ve-flex-vh-center"><span class="glyphicon glyphicon-search"></span></div>`);
			}
			case "clear": {
				return $(`<div class="ui-ideco__wrp ui-ideco__wrp--${side} ve-flex-vh-center clickable" title="Clear"><span class="glyphicon glyphicon-remove"></span></div>`)
					.click(() => $ipt.val("").change().keydown().keyup());
			}
			case "ticker": {
				const isValidValue = val => {
					if (opts.max != null && val > opts.max) return false;
					if (opts.min != null && val < opts.min) return false;
					return true;
				};

				const handleClick = (delta) => {
																									const nxt = component._state[prop] + delta;
					if (!isValidValue(nxt)) return;
					component._state[prop] = nxt;
					$ipt.focus();
				};

				const $btnUp = $(`<button class="btn btn-default ui-ideco__btn-ticker bold no-select">+</button>`)
					.click(() => handleClick(1));

				const $btnDown = $(`<button class="btn btn-default ui-ideco__btn-ticker bold no-select">\u2012</button>`)
					.click(() => handleClick(-1));

				return $$`<div class="ui-ideco__wrp ui-ideco__wrp--${side} ve-flex-vh-center ve-flex-col">
					${$btnUp}
					${$btnDown}
				</div>`;
			}
			case "spacer": {
				return "";
			}
			default: throw new Error(`Unimplemented!`);
		}
	}

		static $getIptEntries (component, prop, opts) {
		opts = opts || {};

		const $ipt = (opts.$ele || $(`<textarea class="form-control input-xs form-control--minimal resize-vertical"></textarea>`))
			.keydown(evt => { if (evt.key === "Escape") $ipt.blur(); })
			.change(() => component._state[prop] = UiUtil$1.getTextAsEntries($ipt.val().trim()));
		const hook = () => $ipt.val(UiUtil$1.getEntriesAsText(component._state[prop]));
		component._addHookBase(prop, hook);
		hook();
		return $ipt;
	}

		static $getIptColor (component, prop, opts) {
		opts = opts || {};

		const $ipt = (opts.$ele || $(`<input class="form-control input-xs form-control--minimal ui__ipt-color" type="color">`))
			.change(() => component._state[prop] = $ipt.val());
		const hook = () => $ipt.val(component._state[prop]);
		component._addHookBase(prop, hook);
		hook();
		return $ipt;
	}

		static getBtnBool (component, prop, opts) {
		opts = opts || {};

		let ele = opts.ele;
		if (opts.html) ele = e_({outer: opts.html});

		const activeClass = opts.activeClass || "active";
		const stateName = opts.stateName || "state";
		const stateProp = opts.stateProp || `_${stateName}`;

		const btn = (ele ? e_({ele}) : e_({
			ele: ele,
			tag: "button",
			clazz: "btn btn-xs btn-default",
			text: opts.text || "Toggle",
		}))
			.onClick(() => component[stateProp][prop] = !component[stateProp][prop])
			.onContextmenu(evt => {
				evt.preventDefault();
				component[stateProp][prop] = !component[stateProp][prop];
			});

		const hk = () => {
			btn.toggleClass(activeClass, opts.isInverted ? !component[stateProp][prop] : !!component[stateProp][prop]);
			if (opts.activeTitle || opts.inactiveTitle) btn.title(component[stateProp][prop] ? (opts.activeTitle || opts.title || "") : (opts.inactiveTitle || opts.title || ""));
			if (opts.fnHookPost) opts.fnHookPost(component[stateProp][prop]);
		};
		component._addHook(stateName, prop, hk);
		hk();

		return btn;
	}

		static $getBtnBool (component, prop, opts) {
		const nxtOpts = {...opts};
		if (nxtOpts.$ele) {
			nxtOpts.ele = nxtOpts.$ele[0];
			delete nxtOpts.$ele;
		}
		return $(this.getBtnBool(component, prop, nxtOpts));
	}

		static $getCbBool (component, prop, opts) {
		opts = opts || {};

		const stateName = opts.stateName || "state";
		const stateProp = opts.stateProp || `_${stateName}`;

		const cb = e_({
			tag: "input",
			type: "checkbox",
			keydown: evt => {
				if (evt.key === "Escape") cb.blur();
			},
			change: () => {
				component[stateProp][prop] = cb.checked;
			},
		});

		const hook = () => {
			cb.checked = !!component[stateProp][prop];
			if (opts.displayNullAsIndeterminate) cb.indeterminate = component[stateProp][prop] == null;
		};
		component._addHook(stateName, prop, hook);
		hook();

		const $cb = $(cb);

		return opts.asMeta ? ({$cb, unhook: () => component._removeHook(stateName, prop, hook)}) : $cb;
	}

		static $getSelSearchable (comp, prop, opts) {
		opts = opts || {};

		const $iptDisplay = (opts.$ele || $(opts.html || `<input class="form-control input-xs form-control--minimal">`))
			.addClass("ui-sel2__ipt-display")
			.attr("tabindex", "-1")
			.click(() => {
				if (opts.isDisabled) return;
				$iptSearch.focus().select();
			})
			.prop("disabled", !!opts.isDisabled)
			.disableSpellcheck();

		const handleSearchChange = () => {
			const cleanTerm = this._$getSelSearchable_getSearchString($iptSearch.val());
			metaOptions.forEach(it => {
				it.isVisible = it.searchTerm.includes(cleanTerm);
				it.$ele.toggleVe(it.isVisible && !it.isForceHidden);
			});
		};
		const handleSearchChangeDebounced = MiscUtil.debounce(handleSearchChange, 30);

		const $iptSearch = (opts.$ele || $(opts.html || `<input class="form-control input-xs form-control--minimal">`))
			.addClass("absolute ui-sel2__ipt-search")
			.keydown(evt => {
				if (opts.isDisabled) return;

				switch (evt.key) {
					case "Escape": evt.stopPropagation(); return $iptSearch.blur();

					case "ArrowDown": {
						evt.preventDefault();
						const visibleMetaOptions = metaOptions.filter(it => it.isVisible && !it.isForceHidden);
						if (!visibleMetaOptions.length) return;
						visibleMetaOptions[0].$ele.focus();
						break;
					}

					case "Enter":
					case "Tab": {
						const visibleMetaOptions = metaOptions.filter(it => it.isVisible && !it.isForceHidden);
						if (!visibleMetaOptions.length) return;
						comp._state[prop] = visibleMetaOptions[0].value;
						$iptSearch.blur();
						break;
					}

					default: handleSearchChangeDebounced();
				}
			})
			.change(() => handleSearchChangeDebounced())
			.click(() => {
				if (opts.isDisabled) return;
				$iptSearch.focus().select();
			})
			.prop("disabled", !!opts.isDisabled)
			.disableSpellcheck();

		const $wrpChoices = $(`<div class="absolute ui-sel2__wrp-options overflow-y-scroll"></div>`);

		const $wrp = $$`<div class="ve-flex relative ui-sel2__wrp w-100">
			${$iptDisplay}
			${$iptSearch}
			${$wrpChoices}
			<div class="ui-sel2__disp-arrow absolute no-events bold"><span class="glyphicon glyphicon-menu-down"></span></div>
		</div>`;

		const procValues = opts.isAllowNull ? [null, ...opts.values] : opts.values;
		const metaOptions = procValues.map((v, i) => {
			const display = v == null ? (opts.displayNullAs || "\u2014") : opts.fnDisplay ? opts.fnDisplay(v) : v;
			const additionalStyleClasses = opts.fnGetAdditionalStyleClasses ? opts.fnGetAdditionalStyleClasses(v) : null;

			const $ele = $(`<div class="ve-flex-v-center py-1 px-1 clickable ui-sel2__disp-option ${v == null ? `italic` : ""} ${additionalStyleClasses ? additionalStyleClasses.join(" ") : ""}" tabindex="0">${display}</div>`)
				.click(() => {
					if (opts.isDisabled) return;

					comp._state[prop] = v;
					$(document.activeElement).blur();
										$wrp.addClass("no-events");
					setTimeout(() => $wrp.removeClass("no-events"), 50);
				})
				.keydown(evt => {
					if (opts.isDisabled) return;

					switch (evt.key) {
						case "Escape": evt.stopPropagation(); return $ele.blur();

						case "ArrowDown": {
							evt.preventDefault();
							const visibleMetaOptions = metaOptions.filter(it => it.isVisible && !it.isForceHidden);
							if (!visibleMetaOptions.length) return;
							const ixCur = visibleMetaOptions.indexOf(out);
							const nxt = visibleMetaOptions[ixCur + 1];
							if (nxt) nxt.$ele.focus();
							break;
						}

						case "ArrowUp": {
							evt.preventDefault();
							const visibleMetaOptions = metaOptions.filter(it => it.isVisible && !it.isForceHidden);
							if (!visibleMetaOptions.length) return;
							const ixCur = visibleMetaOptions.indexOf(out);
							const prev = visibleMetaOptions[ixCur - 1];
							if (prev) return prev.$ele.focus();
							$iptSearch.focus();
							break;
						}

						case "Enter": {
							comp._state[prop] = v;
							$ele.blur();
							break;
						}
					}
				})
				.appendTo($wrpChoices);

			const isForceHidden = opts.isHiddenPerValue && !!(opts.isAllowNull ? opts.isHiddenPerValue[i - 1] : opts.isHiddenPerValue[i]);
			if (isForceHidden) $ele.hideVe();

			const out = {
				value: v,
				isVisible: true,
				isForceHidden,
				searchTerm: this._$getSelSearchable_getSearchString(display),
				$ele,
			};
			return out;
		});

		const fnUpdateHidden = (isHiddenPerValue, isHideNull = false) => {
			let metaOptions_ = metaOptions;

			if (opts.isAllowNull) {
				metaOptions_[0].isForceHidden = isHideNull;
				metaOptions_ = metaOptions_.slice(1);
			}

			metaOptions_.forEach((it, i) => it.isForceHidden = !!isHiddenPerValue[i]);
			handleSearchChange();
		};

		const hk = () => {
			if (comp._state[prop] == null) $iptDisplay.addClass("italic").addClass("ve-muted").val(opts.displayNullAs || "\u2014");
			else $iptDisplay.removeClass("italic").removeClass("ve-muted").val(opts.fnDisplay ? opts.fnDisplay(comp._state[prop]) : comp._state[prop]);

			metaOptions.forEach(it => it.$ele.removeClass("active"));
			const metaActive = metaOptions.find(it => it.value == null ? comp._state[prop] == null : it.value === comp._state[prop]);
			if (metaActive) metaActive.$ele.addClass("active");
		};
		comp._addHookBase(prop, hk);
		hk();

		return opts.asMeta
			? ({
				$wrp,
				unhook: () => comp._removeHookBase(prop, hk),
				$iptDisplay,
				$iptSearch,
				fnUpdateHidden,
			})
			: $wrp;
	}

	static _$getSelSearchable_getSearchString (str) {
		if (str == null) return "";
		return str.trim().toLowerCase().replace(/\s+/g, " ");
	}

		static $getSelEnum (component, prop, {values, $ele, html, isAllowNull, fnDisplay, displayNullAs, asMeta, propProxy = "state", isSetIndexes = false} = {}) {
		const _propProxy = `_${propProxy}`;

		let values_;

		let $sel = $ele || (html ? $(html) : null);
				if (!$sel) { const sel = document.createElement("select"); sel.className = "form-control input-xs"; $sel = $(sel); }

		$sel.change(() => {
			const ix = Number($sel.val());
			if (~ix) return void (component[_propProxy][prop] = isSetIndexes ? ix : values_[ix]);

			if (isAllowNull) return void (component[_propProxy][prop] = null);
			component[_propProxy][prop] = isSetIndexes ? 0 : values_[0];
		});

				const setValues_handleResetOnMissing = ({isResetOnMissing, nxtValues}) => {
			if (!isResetOnMissing) return;

			if (component[_propProxy][prop] == null) return;

			if (isSetIndexes) {
				if (component[_propProxy][prop] >= 0 && component[_propProxy][prop] < nxtValues.length) {
					if (isAllowNull) return component[_propProxy][prop] = null;
					return component[_propProxy][prop] = 0;
				}

				return;
			}

			if (!nxtValues.includes(component[_propProxy][prop])) {
				if (isAllowNull) return component[_propProxy][prop] = null;
				return component[_propProxy][prop] = nxtValues[0];
			}
		};

		const setValues = (nxtValues, {isResetOnMissing = false, isForce = false} = {}) => {
			if (!isForce && CollectionUtil.deepEquals(values_, nxtValues)) return;
			values_ = nxtValues;
			$sel.empty();
						if (isAllowNull) { const opt = document.createElement("option"); opt.value = "-1"; opt.text = displayNullAs || "\u2014"; $sel.append(opt); }
			values_.forEach((it, i) => { const opt = document.createElement("option"); opt.value = `${i}`; opt.text = fnDisplay ? fnDisplay(it) : it; $sel.append(opt); });

			setValues_handleResetOnMissing({isResetOnMissing, nxtValues});

			hook();
		};

		const hook = () => {
			if (isSetIndexes) {
				const ix = component[_propProxy][prop] == null ? -1 : component[_propProxy][prop];
				$sel.val(`${ix}`);
				return;
			}

			const searchFor = component[_propProxy][prop] === undefined ? null : component[_propProxy][prop];
						const ix = values_.indexOf(searchFor);
			$sel.val(`${ix}`);
		};
		component._addHookBase(prop, hook);

		setValues(values);

		if (!asMeta) return $sel;

		return {
			$sel,
			unhook: () => component._removeHookBase(prop, hook),
			setValues,
		};
	}

		static $getPickEnum (component, prop, opts) {
		return this._$getPickEnumOrString(component, prop, opts);
	}

		static $getPickString (component, prop, opts) {
		return this._$getPickEnumOrString(component, prop, {...opts, isFreeText: true});
	}

		static _$getPickEnumOrString (component, prop, opts) {
		opts = opts || {};

		const getSubcompValues = () => {
			const initialValuesArray = (opts.values || []).concat(opts.isFreeText ? MiscUtil.copyFast((component._state[prop] || [])) : []);
			const initialValsCompWith = opts.isCaseInsensitive ? component._state[prop].map(it => it.toLowerCase()) : component._state[prop];
			return initialValuesArray
				.map(v => opts.isCaseInsensitive ? v.toLowerCase() : v)
				.mergeMap(v => ({[v]: component._state[prop] && initialValsCompWith.includes(v)}));
		};

		const initialVals = getSubcompValues();

		let $btnAdd;
		if (opts.isFreeText) {
			$btnAdd = $(`<button class="btn btn-xxs btn-default ui-pick__btn-add ml-auto">+</button>`)
				.click(async () => {
					const input = await InputUiUtil$1.pGetUserString();
					if (input == null || input === VeCt.SYM_UI_SKIP) return;
					const inputClean = opts.isCaseInsensitive ? input.trim().toLowerCase() : input.trim();
					pickComp.getPod().set(inputClean, true);
				});
		} else {
			const menu = ContextUtil.getMenu(opts.values.map(it => new ContextUtil.Action(
				opts.fnDisplay ? opts.fnDisplay(it) : it,
				() => pickComp.getPod().set(it, true),
			)));

			$btnAdd = $(`<button class="btn btn-xxs btn-default ui-pick__btn-add">+</button>`)
				.click(evt => ContextUtil.pOpenMenu(evt, menu));
		}

		const pickComp = BaseComponent$1.fromObject(initialVals);
		pickComp.render = function ($parent) {
			$parent.empty();

			Object.entries(this._state).forEach(([k, v]) => {
				if (v === false) return;

				const $btnRemove = $(`<button class="btn btn-danger ui-pick__btn-remove text-center">×</button>`)
					.click(() => this._state[k] = false);
				const txt = `${opts.fnDisplay ? opts.fnDisplay(k) : k}`;
				$$`<div class="ve-flex mx-1 mb-1 ui-pick__disp-pill max-w-100 min-w-0"><div class="px-1 ui-pick__disp-text ve-flex-v-center text-clip-ellipsis" title="${txt.qq()}">${txt}</div>${$btnRemove}</div>`.appendTo($parent);
			});
		};

		const $wrpPills = $(`<div class="ve-flex ve-flex-wrap max-w-100 min-w-0"></div>`);
		const $wrp = $$`<div class="ve-flex-v-center w-100">${$btnAdd}${$wrpPills}</div>`;
		pickComp._addHookAll("state", () => {
			component._state[prop] = Object.keys(pickComp._state).filter(k => pickComp._state[k]);
			pickComp.render($wrpPills);
		});
		pickComp.render($wrpPills);

		const hkParent = () => pickComp._proxyAssignSimple("state", getSubcompValues(), true);
		component._addHookBase(prop, hkParent);

		return $wrp;
	}

		static $getCbsEnum (component, prop, opts) {
		opts = opts || {};

		const $wrp = $(`<div class="ve-flex-col w-100"></div>`);
		const metas = opts.values.map(it => {
			const $cb = $(`<input type="checkbox">`)
				.keydown(evt => {
					if (evt.key === "Escape") $cb.blur();
				})
				.change(() => {
					let didUpdate = false;
					const ix = (component._state[prop] || []).indexOf(it);
					if (~ix) component._state[prop].splice(ix, 1);
					else {
						if (component._state[prop]) component._state[prop].push(it);
						else {
							didUpdate = true;
							component._state[prop] = [it];
						}
					}
					if (!didUpdate) component._state[prop] = [...component._state[prop]];
				});

			$$`<label class="split-v-center my-1 stripe-odd ${opts.isIndent ? "ml-4" : ""}"><div class="no-wrap ve-flex-v-center">${opts.fnDisplay ? opts.fnDisplay(it) : it}</div>${$cb}</label>`.appendTo($wrp);

			return {$cb, value: it};
		});

		const hook = () => metas.forEach(meta => meta.$cb.prop("checked", component._state[prop] && component._state[prop].includes(meta.value)));
		component._addHookBase(prop, hook);
		hook();

		return opts.asMeta ? {$wrp, unhook: () => component._removeHookBase(prop, hook)} : $wrp;
	}

			static getMetaWrpMultipleChoice (comp, prop, opts) {
		opts = opts || {};
		this._getMetaWrpMultipleChoice_doValidateOptions(opts);

		const rowMetas = [];
		const $eles = [];
		const ixsSelectionOrder = [];
		const $elesSearchable = {};

		const propIsAcceptable = this.getMetaWrpMultipleChoice_getPropIsAcceptable(prop);
		const propPulse = this.getMetaWrpMultipleChoice_getPropPulse(prop);
		const propIxMax = this._getMetaWrpMultipleChoice_getPropValuesLength(prop);

		const cntRequired = ((opts.required || []).length) + ((opts.ixsRequired || []).length);
		const count = opts.count != null ? opts.count - cntRequired : null;
		const countIncludingRequired = opts.count != null ? count + cntRequired : null;
		const min = opts.min != null ? opts.min - cntRequired : null;
		const max = opts.max != null ? opts.max - cntRequired : null;

		const valueGroups = opts.valueGroups || [{values: opts.values}];

		let ixValue = 0;
		valueGroups.forEach((group, i) => {
			if (i !== 0) $eles.push($(`<hr class="w-100 hr-2 hr--dotted">`));

			if (group.name) {
				const $wrpName = $$`<div class="split-v-center py-1">
					<div class="ve-flex-v-center"><span class="mr-2">‒</span><span>${group.name}</span></div>
					${opts.valueGroupSplitControlsLookup?.[group.name]}
				</div>`;
				$eles.push($wrpName);
			}

			if (group.text) $eles.push($(`<div class="ve-flex-v-center py-1"><div class="ml-1 mr-3"></div><i>${group.text}</i></div>`));

			group.values.forEach(v => {
				const ixValueFrozen = ixValue;

				const propIsActive = this.getMetaWrpMultipleChoice_getPropIsActive(prop, ixValueFrozen);
				const propIsRequired = this.getMetaWrpMultipleChoice_getPropIsRequired(prop, ixValueFrozen);

				const isHardRequired = (opts.required && opts.required.includes(v))
					|| (opts.ixsRequired && opts.ixsRequired.includes(ixValueFrozen));
				const isRequired = isHardRequired || comp._state[propIsRequired];

								if (comp._state[propIsActive] && !comp._state[propIsRequired]) ixsSelectionOrder.push(ixValueFrozen);

				let hk;
				const $cb = isRequired
					? $(`<input type="checkbox" disabled checked title="This option is required.">`)
					: ComponentUiUtil$1.$getCbBool(comp, propIsActive);

				if (isRequired) comp._state[propIsActive] = true;

				if (!isRequired) {
					hk = () => {
												const ixIx = ixsSelectionOrder.findIndex(it => it === ixValueFrozen);
						if (~ixIx) ixsSelectionOrder.splice(ixIx, 1);
						if (comp._state[propIsActive]) ixsSelectionOrder.push(ixValueFrozen);
						
												const activeRows = rowMetas.filter(it => comp._state[it.propIsActive]);

						if (count != null) {
														if (activeRows.length > countIncludingRequired) {
																const ixFirstSelected = ixsSelectionOrder.splice(ixsSelectionOrder.length - 2, 1)[0];
								if (ixFirstSelected != null) {
									const propIsActiveOther = this.getMetaWrpMultipleChoice_getPropIsActive(prop, ixFirstSelected);
									comp._state[propIsActiveOther] = false;

									comp._state[propPulse] = !comp._state[propPulse];
								}
								return;
							}
						}

						let isAcceptable = false;
						if (count != null) {
							if (activeRows.length === countIncludingRequired) isAcceptable = true;
						} else {
							if (activeRows.length >= (min || 0) && activeRows.length <= (max || Number.MAX_SAFE_INTEGER)) isAcceptable = true;
						}

												comp._state[propIsAcceptable] = isAcceptable;
						
						comp._state[propPulse] = !comp._state[propPulse];
					};
					comp._addHookBase(propIsActive, hk);
					hk();
				}

				const displayValue = opts.fnDisplay ? opts.fnDisplay(v, ixValueFrozen) : v;

				rowMetas.push({
					$cb,
					displayValue,
					value: v,
					propIsActive,
					unhook: () => {
						if (hk) comp._removeHookBase(propIsActive, hk);
					},
				});

				const $ele = $$`<label class="ve-flex-v-center py-1 stripe-even">
					<div class="col-1 ve-flex-vh-center">${$cb}</div>
					<div class="col-11 ve-flex-v-center">${displayValue}</div>
				</label>`;
				$eles.push($ele);

				if (opts.isSearchable) {
					const searchText = `${opts.fnGetSearchText ? opts.fnGetSearchText(v, ixValueFrozen) : v}`.toLowerCase().trim();
					($elesSearchable[searchText] = $elesSearchable[searchText] || []).push($ele);
				}

				ixValue++;
			});
		});

						ixsSelectionOrder.sort((a, b) => SortUtil.ascSort(a, b));

		comp.__state[propIxMax] = ixValue;

		let $iptSearch;
		if (opts.isSearchable) {
			const compSub = BaseComponent$1.fromObject({search: ""});
			$iptSearch = ComponentUiUtil$1.$getIptStr(compSub, "search");
			const hkSearch = () => {
				const cleanSearch = compSub._state.search.trim().toLowerCase();
				if (!cleanSearch) {
					Object.values($elesSearchable).forEach($eles => $eles.forEach($ele => $ele.removeClass("ve-hidden")));
					return;
				}

				Object.entries($elesSearchable)
					.forEach(([searchText, $eles]) => $eles.forEach($ele => $ele.toggleVe(searchText.includes(cleanSearch))));
			};
			compSub._addHookBase("search", hkSearch);
			hkSearch();
		}

				const unhook = () => rowMetas.forEach(it => it.unhook());
		return {
			$ele: $$`<div class="ve-flex-col w-100 overflow-y-auto">${$eles}</div>`,
			$iptSearch,
			rowMetas, 			propIsAcceptable,
			propPulse,
			unhook,
			cleanup: () => {
				unhook();
								Object.keys(comp._state)
					.filter(it => it.startsWith(`${prop}__`))
					.forEach(it => delete comp._state[it]);
			},
		};
	}

	static getMetaWrpMultipleChoice_getPropIsAcceptable (prop) { return `${prop}__isAcceptable`; }
	static getMetaWrpMultipleChoice_getPropPulse (prop) { return `${prop}__pulse`; }
	static _getMetaWrpMultipleChoice_getPropValuesLength (prop) { return `${prop}__length`; }
	static getMetaWrpMultipleChoice_getPropIsActive (prop, ixValue) { return `${prop}__isActive_${ixValue}`; }
	static getMetaWrpMultipleChoice_getPropIsRequired (prop, ixValue) { return `${prop}__isRequired_${ixValue}`; }

	static getMetaWrpMultipleChoice_getSelectedIxs (comp, prop) {
		const out = [];
		const len = comp._state[this._getMetaWrpMultipleChoice_getPropValuesLength(prop)] || 0;
		for (let i = 0; i < len; ++i) {
			if (comp._state[this.getMetaWrpMultipleChoice_getPropIsActive(prop, i)]) out.push(i);
		}
		return out;
	}

	static getMetaWrpMultipleChoice_getSelectedValues (comp, prop, {values, valueGroups}) {
		const selectedIxs = this.getMetaWrpMultipleChoice_getSelectedIxs(comp, prop);
		if (values) return selectedIxs.map(ix => values[ix]);

		const selectedIxsSet = new Set(selectedIxs);
		const out = [];
		let ixValue = 0;
		valueGroups.forEach(group => {
			group.values.forEach(v => {
				if (selectedIxsSet.has(ixValue)) out.push(v);
				ixValue++;
			});
		});
		return out;
	}

	static _getMetaWrpMultipleChoice_doValidateOptions (opts) {
		if ((Number(!!opts.values) + Number(!!opts.valueGroups)) !== 1) throw new Error(`Exactly one of "values" and "valueGroups" must be specified!`);

		if (opts.count != null && (opts.min != null || opts.max != null)) throw new Error(`Chooser must be either in "count" mode or "min/max" mode!`);
				if (opts.count == null && opts.min == null && opts.max == null) opts.count = 1;
	}
	
		static $getSliderRange (comp, opts) {
		opts = opts || {};
		const slider = new ComponentUiUtil$1.RangeSlider({comp, ...opts});
		return slider.$get();
	}

	static $getSliderNumber (
		comp,
		prop,
		{
			min,
			max,
			step,
			$ele,
			asMeta,
		} = {},
	) {
		const $slider = ($ele || $(`<input type="range">`))
			.change(() => comp._state[prop] = Number($slider.val()));

		if (min != null) $slider.attr("min", min);
		if (max != null) $slider.attr("max", max);
		if (step != null) $slider.attr("step", step);

		const hk = () => $slider.val(comp._state[prop]);
		comp._addHookBase(prop, hk);
		hk();

		return asMeta ? ({$slider, unhook: () => comp._removeHookBase(prop, hk)}) : $slider;
	}
};
ComponentUiUtil$1.RangeSlider = class {
	constructor (
		{
			comp,
			propMin,
			propMax,
			propCurMin,
			propCurMax,
			fnDisplay,
			fnDisplayTooltip,
			sparseValues,
		},
	) {
		this._comp = comp;
		this._propMin = propMin;
		this._propMax = propMax;
		this._propCurMin = propCurMin;
		this._propCurMax = propCurMax;
		this._fnDisplay = fnDisplay;
		this._fnDisplayTooltip = fnDisplayTooltip;
		this._sparseValues = sparseValues;

		this._isSingle = !this._propCurMax;

						const compCpyState = {
			[this._propMin]: this._comp._state[this._propMin],
			[this._propCurMin]: this._comp._state[this._propCurMin],
			[this._propMax]: this._comp._state[this._propMax],
		};
		if (!this._isSingle) compCpyState[this._propCurMax] = this._comp._state[this._propCurMax];
		this._compCpy = BaseComponent$1.fromObject(compCpyState);

				this._comp._addHook("state", this._propMin, () => this._compCpy._state[this._propMin] = this._comp._state[this._propMin]);
		this._comp._addHook("state", this._propCurMin, () => this._compCpy._state[this._propCurMin] = this._comp._state[this._propCurMin]);
		this._comp._addHook("state", this._propMax, () => this._compCpy._state[this._propMax] = this._comp._state[this._propMax]);

		if (!this._isSingle) this._comp._addHook("state", this._propCurMax, () => this._compCpy._state[this._propCurMax] = this._comp._state[this._propCurMax]);
		
		this._cacheRendered = null;
		this._dispTrackOuter = null;
		this._dispTrackInner = null;
		this._thumbLow = null;
		this._thumbHigh = null;
		this._dragMeta = null;
	}

	$get () {
		const out = this.get();
		return $(out);
	}

	get () {
		this.constructor._init();
		this.constructor._ALL_SLIDERS.add(this);

		if (this._cacheRendered) return this._cacheRendered;

				const dispValueLeft = this._isSingle ? this._getSpcSingleValue() : this._getDispValue({isVisible: true, side: "left"});
		const dispValueRight = this._getDispValue({isVisible: true, side: "right"});

		this._dispTrackInner = this._isSingle ? null : e_({
			tag: "div",
			clazz: "ui-slidr__track-inner h-100 absolute",
		});

		this._thumbLow = this._getThumb();
		this._thumbHigh = this._isSingle ? null : this._getThumb();

		this._dispTrackOuter = e_({
			tag: "div",
			clazz: `relative w-100 ui-slidr__track-outer`,
			children: [
				this._dispTrackInner,
				this._thumbLow,
				this._thumbHigh,
			].filter(Boolean),
		});

		const wrpTrack = e_({
			tag: "div",
			clazz: `ve-flex-v-center w-100 h-100 ui-slidr__wrp-track clickable`,
			mousedown: evt => {
				const thumb = this._getClosestThumb(evt);
				this._handleMouseDown(evt, thumb);
			},
			children: [
				this._dispTrackOuter,
			],
		});

		const wrpTop = e_({
			tag: "div",
			clazz: "ve-flex-v-center w-100 ui-slidr__wrp-top",
			children: [
				dispValueLeft,
				wrpTrack,
				dispValueRight,
			].filter(Boolean),
		});
		
				const wrpPips = e_({
			tag: "div",
			clazz: `w-100 ve-flex relative clickable h-100 ui-slidr__wrp-pips`,
			mousedown: evt => {
				const thumb = this._getClosestThumb(evt);
				this._handleMouseDown(evt, thumb);
			},
		});

		const wrpBottom = e_({
			tag: "div",
			clazz: "w-100 ve-flex-vh-center ui-slidr__wrp-bottom",
			children: [
				this._isSingle ? this._getSpcSingleValue() : this._getDispValue({side: "left"}), 				wrpPips,
				this._getDispValue({side: "right"}), 			].filter(Boolean),
		});
		
				const hkChangeValue = () => {
			const curMin = this._compCpy._state[this._propCurMin];
			const pctMin = this._getLeftPositionPercentage({value: curMin});
			this._thumbLow.style.left = `calc(${pctMin}% - ${this.constructor._W_THUMB_PX / 2}px)`;
			const toDisplayLeft = this._fnDisplay ? `${this._fnDisplay(curMin)}`.qq() : curMin;
			const toDisplayLeftTooltip = this._fnDisplayTooltip ? `${this._fnDisplayTooltip(curMin)}`.qq() : null;
			if (!this._isSingle) {
				dispValueLeft
					.html(toDisplayLeft)
					.tooltip(toDisplayLeftTooltip);
			}

			if (!this._isSingle) {
				this._dispTrackInner.style.left = `${pctMin}%`;

				const curMax = this._compCpy._state[this._propCurMax];
				const pctMax = this._getLeftPositionPercentage({value: curMax});
				this._dispTrackInner.style.right = `${100 - pctMax}%`;
				this._thumbHigh.style.left = `calc(${pctMax}% - ${this.constructor._W_THUMB_PX / 2}px)`;
				dispValueRight
					.html(this._fnDisplay ? `${this._fnDisplay(curMax)}`.qq() : curMax)
					.tooltip(this._fnDisplayTooltip ? `${this._fnDisplayTooltip(curMax)}`.qq() : null);
			} else {
				dispValueRight
					.html(toDisplayLeft)
					.tooltip(toDisplayLeftTooltip);
			}
		};

		const hkChangeLimit = () => {
			const pips = [];

			if (!this._sparseValues) {
				const numPips = this._compCpy._state[this._propMax] - this._compCpy._state[this._propMin];
				let pipIncrement = 1;
								if (numPips > ComponentUiUtil$1.RangeSlider._MAX_PIPS) pipIncrement = Math.ceil(numPips / ComponentUiUtil$1.RangeSlider._MAX_PIPS);

				let i, len;
				for (
					i = this._compCpy._state[this._propMin], len = this._compCpy._state[this._propMax] + 1;
					i < len;
					i += pipIncrement
				) {
					pips.push(this._getWrpPip({
						isMajor: i === this._compCpy._state[this._propMin] || i === (len - 1),
						value: i,
					}));
				}

								if (i !== this._compCpy._state[this._propMax]) pips.push(this._getWrpPip({isMajor: true, value: this._compCpy._state[this._propMax]}));
			} else {
				const len = this._sparseValues.length;
				this._sparseValues.forEach((val, i) => {
					pips.push(this._getWrpPip({
						isMajor: i === 0 || i === (len - 1),
						value: val,
					}));
				});
			}

			wrpPips.empty();
			e_({
				ele: wrpPips,
				children: pips,
			});

			hkChangeValue();
		};

		this._compCpy._addHook("state", this._propMin, hkChangeLimit);
		this._compCpy._addHook("state", this._propMax, hkChangeLimit);
		this._compCpy._addHook("state", this._propCurMin, hkChangeValue);
		if (!this._isSingle) this._compCpy._addHook("state", this._propCurMax, hkChangeValue);

		hkChangeLimit();
		
		const wrp = e_({
			tag: "div",
			clazz: "ve-flex-col w-100 ui-slidr__wrp",
			children: [
				wrpTop,
				wrpBottom,
			],
		});

		return this._cacheRendered = wrp;
	}

	destroy () {
		this.constructor._ALL_SLIDERS.delete(this);
		if (this._cacheRendered) this._cacheRendered.remove();
	}

	_getDispValue ({isVisible, side}) {
		return e_({
			tag: "div",
			clazz: `overflow-hidden ui-slidr__disp-value no-shrink no-grow ve-flex-vh-center bold no-select ${isVisible ? `ui-slidr__disp-value--visible` : ""} ui-slidr__disp-value--${side}`,
		});
	}

	_getSpcSingleValue () {
		return e_({
			tag: "div",
			clazz: `px-2`,
		});
	}

	_getThumb () {
		const thumb = e_({
			tag: "div",
			clazz: "ui-slidr__thumb absolute clickable",
			mousedown: evt => this._handleMouseDown(evt, thumb),
		}).attr("draggable", true);

		return thumb;
	}

	_getWrpPip ({isMajor, value} = {}) {
		const style = this._getWrpPip_getStyle({value});

		const pip = e_({
			tag: "div",
			clazz: `ui-slidr__pip ${isMajor ? `ui-slidr__pip--major` : `absolute`}`,
		});

		const dispLabel = e_({
			tag: "div",
			clazz: "absolute ui-slidr__pip-label ve-flex-vh-center ve-small no-wrap",
			html: isMajor ? this._fnDisplay ? `${this._fnDisplay(value)}`.qq() : value : "",
			title: isMajor && this._fnDisplayTooltip ? `${this._fnDisplayTooltip(value)}`.qq() : null,
		});

		return e_({
			tag: "div",
			clazz: "ve-flex-col ve-flex-vh-center absolute no-select",
			children: [
				pip,
				dispLabel,
			],
			style,
		});
	}

	_getWrpPip_getStyle ({value}) {
		return `left: ${this._getLeftPositionPercentage({value})}%`;
	}

	_getLeftPositionPercentage ({value}) {
		if (this._sparseValues) {
			const ix = this._sparseValues.sort(SortUtil.ascSort).indexOf(value);
			if (!~ix) throw new Error(`Value "${value}" was not in the list of sparse values!`);
			return (ix / (this._sparseValues.length - 1)) * 100;
		}

		const min = this._compCpy._state[this._propMin]; const max = this._compCpy._state[this._propMax];
		return ((value - min) / (max - min)) * 100;
	}

		_getRelativeValue (evt, {trackOriginX, trackWidth}) {
		const xEvt = EventUtil.getClientX(evt) - trackOriginX;

		if (this._sparseValues) {
			const ixMax = this._sparseValues.length - 1;
			const rawVal = Math.round((xEvt / trackWidth) * ixMax);
			return this._sparseValues[Math.min(ixMax, Math.max(0, rawVal))];
		}

		const min = this._compCpy._state[this._propMin]; const max = this._compCpy._state[this._propMax];

		const rawVal = min
			+ Math.round(
				(xEvt / trackWidth) * (max - min),
			);

		return Math.min(max, Math.max(min, rawVal)); 	}

	_getClosestThumb (evt) {
		if (this._isSingle) return this._thumbLow;

		const {x: trackOriginX, width: trackWidth} = this._dispTrackOuter.getBoundingClientRect();
		const value = this._getRelativeValue(evt, {trackOriginX, trackWidth});

		if (value < this._compCpy._state[this._propCurMin]) return this._thumbLow;
		if (value > this._compCpy._state[this._propCurMax]) return this._thumbHigh;

		const {distToMin, distToMax} = this._getDistsToCurrentMinAndMax(value);
		if (distToMax < distToMin) return this._thumbHigh;
		return this._thumbLow;
	}

	_getDistsToCurrentMinAndMax (value) {
		if (this._isSingle) throw new Error(`Can not get distance to max value for singleton slider!`);

				const distToMin = Math.abs(this._compCpy._state[this._propCurMin] - value);
		const distToMax = Math.abs(this._compCpy._state[this._propCurMax] - value);
		return {distToMin, distToMax};
	}

	_handleClick (evt, value) {
		evt.stopPropagation();
		evt.preventDefault();

				if (value < this._compCpy._state[this._propCurMin]) this._compCpy._state[this._propCurMin] = value;

				if (value > this._compCpy._state[this._propCurMax]) this._compCpy._state[this._propCurMax] = value;

				const {distToMin, distToMax} = this._getDistsToCurrentMinAndMax(value);

		if (distToMax < distToMin) this._compCpy._state[this._propCurMax] = value;
		else this._compCpy._state[this._propCurMin] = value;
	}

	_handleMouseDown (evt, thumb) {
		evt.preventDefault();
		evt.stopPropagation();

				const {x: trackOriginX, width: trackWidth} = this._dispTrackOuter.getBoundingClientRect();

		thumb.addClass(`ui-slidr__thumb--hover`);

		this._dragMeta = {
			trackOriginX,
			trackWidth,
			thumb,
		};
		
		this._handleMouseMove(evt);
	}

	_handleMouseUp () {
		const wasActive = this._doDragCleanup();

				if (wasActive) {
			const nxtState = {
				[this._propMin]: this._compCpy._state[this._propMin],
				[this._propMax]: this._compCpy._state[this._propMax],
				[this._propCurMin]: this._compCpy._state[this._propCurMin],
			};
			if (!this._isSingle) nxtState[this._propCurMax] = this._compCpy._state[this._propCurMax];

			this._comp._proxyAssignSimple("state", nxtState);
		}
	}

	_handleMouseMove (evt) {
		if (!this._dragMeta) return;

		const val = this._getRelativeValue(evt, this._dragMeta);

		if (this._dragMeta.thumb === this._thumbLow) {
			if (val > this._compCpy._state[this._propCurMax]) return;
			this._compCpy._state[this._propCurMin] = val;
		} else if (this._dragMeta.thumb === this._thumbHigh) {
			if (val < this._compCpy._state[this._propCurMin]) return;
			this._compCpy._state[this._propCurMax] = val;
		}
	}

	_doDragCleanup () {
		const isActive = this._dragMeta != null;

		if (this._dragMeta?.thumb) this._dragMeta.thumb.removeClass(`ui-slidr__thumb--hover`);

		this._dragMeta = null;

		return isActive;
	}

	static _init () {
		if (this._isInit) return;
		document.addEventListener("mousemove", evt => {
			for (const slider of this._ALL_SLIDERS) {
				slider._handleMouseMove(evt);
			}
		});

		document.addEventListener("mouseup", evt => {
			for (const slider of this._ALL_SLIDERS) {
				slider._handleMouseUp(evt);
			}
		});
	}
};
ComponentUiUtil$1.RangeSlider._isInit = false;
ComponentUiUtil$1.RangeSlider._ALL_SLIDERS = new Set();
ComponentUiUtil$1.RangeSlider._W_THUMB_PX = 16;
ComponentUiUtil$1.RangeSlider._W_LABEL_PX = 24;
ComponentUiUtil$1.RangeSlider._MAX_PIPS = 40;

class SettingsUtil {
	static Setting = class {
		constructor (
			{
				type,
				name,
				help,
				defaultVal,
			},
		) {
			this.type = type;
			this.name = name;
			this.help = help;
			this.defaultVal = defaultVal;
		}
	};

	static EnumSetting = class extends SettingsUtil.Setting {
		constructor (
			{
				enumVals,
				...rest
			},
		) {
			super(rest);
			this.enumVals = enumVals;
		}
	};

	static getDefaultSettings (settings) {
		return Object.entries(settings)
			.mergeMap(([prop, {defaultVal}]) => ({[prop]: defaultVal}));
	}
}

globalThis.ProxyBase = ProxyBase$1;
globalThis.UiUtil = UiUtil$1;
globalThis.ListUiUtil = ListUiUtil$1;
globalThis.ProfUiUtil = ProfUiUtil;
globalThis.TabUiUtil = TabUiUtil$1;
globalThis.SearchUiUtil = SearchUiUtil;
globalThis.SearchWidget = SearchWidget;
globalThis.InputUiUtil = InputUiUtil$1;
globalThis.DragReorderUiUtil = DragReorderUiUtil$1;
globalThis.SourceUiUtil = SourceUiUtil;
globalThis.BaseComponent = BaseComponent$1;
globalThis.ComponentUiUtil = ComponentUiUtil$1;
globalThis.RenderableCollectionBase = RenderableCollectionBase$1;

"use strict";

let UtilsChangelog$1 = class UtilsChangelog {
	static _RELEASE_URL = "https://github.com/5etools-mirror-1/5etools-mirror-1.github.io/releases";

	static renderChangelog (changelog, $wrp) {
		let lastMajorVersion = 0;
		let lastMinorVersion = 0;
		changelog.forEach((it, i) => {
			if (!it.txt) return;

			let [vMajor, vMinor, vPatch] = it.ver.split(".");
			vMajor = Number(vMajor);
			vMinor = Number(vMinor);

			const hLevel = vMajor !== lastMajorVersion ? "2" : vMinor !== lastMinorVersion ? "3" : "4";
			const blocks = it.txt.trim().split(/\n\n+/g);

			let htmlStack = "";

			const cleanListLine = l => l.trim().replace(/^-\s*/, "");

			blocks.forEach(block => {
				htmlStack += `<div class="small mb-2">`;

				const lines = block.split("\n");

				let ulStack = [];
				let depth = -1;
				lines.forEach(l => {
					if (l.trim().startsWith("-")) {
						const nxtDepth = l.length - l.trimLeft().length;

						if (nxtDepth > depth) {
							depth = nxtDepth;
							htmlStack += `<ul><li>${cleanListLine(l).qq()}</li>`;
						} else if (nxtDepth < depth) {
							depth = nxtDepth;
							htmlStack += `</ul><li>${cleanListLine(l).qq()}</li>`;
						} else {
							htmlStack += `<li>${cleanListLine(l).qq()}</li>`;
						}
					} else {
						while (ulStack.length) {
							ulStack.pop();
							htmlStack += "</ul>";
						}
						depth = -1;
						htmlStack += `<div class="mb-1">${l.qq()}</div>`;
					}
				});

				while (ulStack.length) {
					ulStack.pop();
					htmlStack += "</ul>";
				}

				htmlStack += `</div>`;
			});

			htmlStack += `</div>`;

			const isLast = i === changelog.length - 1;

			const titlePart = it.title ? `, &quot;<span ${it.titleAlt ? `class="help" title="AKA &quot;${it.titleAlt.escapeQuotes()}&quot; Edition"` : ""}>${it.title.escapeQuotes()}</span>&quot; Edition` : "";
			$wrp.prepend(`<div class="ve-flex-col" id="v${it.ver}">
				<div class="split-v-center">
					<h${hLevel} class="bold">v${isLast ? `<a href="${UtilsChangelog$1._RELEASE_URL}" rel="noopener noreferrer">` : ""}${it.ver}${isLast ? `</a>` : ""}${titlePart}</h${hLevel}>
					<span class="text-muted">${it.date}</span>
				</div>

				${htmlStack}
			</div>`);

			lastMajorVersion = vMajor;
			lastMinorVersion = vMinor;
		});
	}
};

globalThis.UtilsChangelog = UtilsChangelog$1;

"use strict";

globalThis.Renderer = function () {
	this.wrapperTag = "div";
	this.baseUrl = "";
	this.baseMediaUrls = {};

	if (globalThis.DEPLOYED_IMG_ROOT) {
		this.baseMediaUrls["img"] = globalThis.DEPLOYED_IMG_ROOT;
	}

	this._lazyImages = false;
	this._subVariant = false;
	this._firstSection = true;
	this._isAddHandlers = true;
	this._headerIndex = 1;
	this._tagExportDict = null;
	this._roll20Ids = null;
	this._trackTitles = {enabled: false, titles: {}};
	this._enumerateTitlesRel = {enabled: false, titles: {}};
	this._isHeaderIndexIncludeTableCaptions = false;
	this._isHeaderIndexIncludeImageTitles = false;
	this._plugins = {};
	this._fnPostProcess = null;
	this._extraSourceClasses = null;
	this._depthTracker = null;
	this._depthTrackerAdditionalProps = [];
	this._depthTrackerAdditionalPropsInherited = [];
	this._lastDepthTrackerInheritedProps = {};
	this._isInternalLinksDisabled = false;
	this._isPartPageExpandCollapseDisabled = false;
	this._fnsGetStyleClasses = {};

		this.setLazyImages = function (bool) {
				if (typeof IntersectionObserver === "undefined") this._lazyImages = false;
		else this._lazyImages = !!bool;
		return this;
	};

		this.setWrapperTag = function (tag) { this.wrapperTag = tag; return this; };

		this.setBaseUrl = function (url) { this.baseUrl = url; return this; };

	this.setBaseMediaUrl = function (mediaDir, url) { this.baseMediaUrls[mediaDir] = url; return this; };

		this.setFirstSection = function (bool) { this._firstSection = bool; return this; };

		this.setAddHandlers = function (bool) { this._isAddHandlers = bool; return this; };

		this.setFnPostProcess = function (fn) { this._fnPostProcess = fn; return this; };

		this.setExtraSourceClasses = function (arr) { this._extraSourceClasses = arr; return this; };

			this.resetHeaderIndex = function () {
		this._headerIndex = 1;
		this._trackTitles.titles = {};
		this._enumerateTitlesRel.titles = {};
		return this;
	};

	this.getHeaderIndex = function () { return this._headerIndex; };

	this.setHeaderIndexTableCaptions = function (bool) { this._isHeaderIndexIncludeTableCaptions = bool; return this; };
	this.setHeaderIndexImageTitles = function (bool) { this._isHeaderIndexIncludeImageTitles = bool; return this; };
	
		this.doExportTags = function (toObj) {
		this._tagExportDict = toObj;
		return this;
	};

		this.resetExportTags = function () {
		this._tagExportDict = null;
		return this;
	};

	this.setRoll20Ids = function (roll20Ids) {
		this._roll20Ids = roll20Ids;
		return this;
	};

	this.resetRoll20Ids = function () {
		this._roll20Ids = null;
		return this;
	};

		this.setInternalLinksDisabled = function (val) { this._isInternalLinksDisabled = !!val; return this; };
	this.isInternalLinksDisabled = function () { return !!this._isInternalLinksDisabled; };

	this.setPartPageExpandCollapseDisabled = function (val) { this._isPartPageExpandCollapseDisabled = !!val; return this; };

		this.setFnGetStyleClasses = function (identifier, fn) {
		if (fn == null) {
			delete this._fnsGetStyleClasses[identifier];
			return this;
		}

		this._fnsGetStyleClasses[identifier] = fn;
		return this;
	};

		this.setEnumerateTitlesRel = function (bool) {
		this._enumerateTitlesRel.enabled = bool;
		return this;
	};

	this._getEnumeratedTitleRel = function (name) {
		if (this._enumerateTitlesRel.enabled && name) {
			const clean = name.toLowerCase();
			this._enumerateTitlesRel.titles[clean] = this._enumerateTitlesRel.titles[clean] || 0;
			return `data-title-relative-index="${this._enumerateTitlesRel.titles[clean]++}"`;
		} else return "";
	};

	this.setTrackTitles = function (bool) {
		this._trackTitles.enabled = bool;
		return this;
	};

	this.getTrackedTitles = function () {
		return MiscUtil.copyFast(this._trackTitles.titles);
	};

	this.getTrackedTitlesInverted = function ({isStripTags = false} = {}) {
						const trackedTitlesInverse = {};
		Object.entries(this._trackTitles.titles || {}).forEach(([titleIx, titleName]) => {
			if (isStripTags) titleName = Renderer.stripTags(titleName);
			titleName = titleName.toLowerCase().trim();
			(trackedTitlesInverse[titleName] = trackedTitlesInverse[titleName] || []).push(titleIx);
		});
		return trackedTitlesInverse;
	};

	this._handleTrackTitles = function (name, {isTable = false, isImage = false} = {}) {
		if (!this._trackTitles.enabled) return;
		if (isTable && !this._isHeaderIndexIncludeTableCaptions) return;
		if (isImage && !this._isHeaderIndexIncludeImageTitles) return;
		this._trackTitles.titles[this._headerIndex] = name;
	};

	this._handleTrackDepth = function (entry, depth) {
		if (!entry.name || !this._depthTracker) return;

		this._lastDepthTrackerInheritedProps = MiscUtil.copyFast(this._lastDepthTrackerInheritedProps);
		if (entry.source) this._lastDepthTrackerInheritedProps.source = entry.source;
		if (this._depthTrackerAdditionalPropsInherited?.length) {
			this._depthTrackerAdditionalPropsInherited.forEach(prop => this._lastDepthTrackerInheritedProps[prop] = entry[prop] || this._lastDepthTrackerInheritedProps[prop]);
		}

		const additionalData = this._depthTrackerAdditionalProps.length
			? this._depthTrackerAdditionalProps.mergeMap(it => ({[it]: entry[it]}))
			: {};

		this._depthTracker.push({
			...this._lastDepthTrackerInheritedProps,
			...additionalData,
			depth,
			name: entry.name,
			type: entry.type,
			ixHeader: this._headerIndex,
			source: this._lastDepthTrackerInheritedProps.source,
			data: entry.data,
			page: entry.page,
			alias: entry.alias,
			entry,
		});
	};

		this.addPlugin = function (pluginType, fnPlugin) {
		MiscUtil.getOrSet(this._plugins, pluginType, []).push(fnPlugin);
	};

	this.removePlugin = function (pluginType, fnPlugin) {
		if (!fnPlugin) return;
		const ix = (MiscUtil.get(this._plugins, pluginType) || []).indexOf(fnPlugin);
		if (~ix) this._plugins[pluginType].splice(ix, 1);
	};

	this.removePlugins = function (pluginType) {
		MiscUtil.delete(this._plugins, pluginType);
	};

	this._getPlugins = function (pluginType) { return this._plugins[pluginType] || []; };

		this.withPlugin = function ({pluginTypes, fnPlugin, fn}) {
		for (const pt of pluginTypes) this.addPlugin(pt, fnPlugin);
		try {
			return fn(this);
		} finally {
			for (const pt of pluginTypes) this.removePlugin(pt, fnPlugin);
		}
	};

		this.pWithPlugin = async function ({pluginTypes, fnPlugin, pFn}) {
		for (const pt of pluginTypes) this.addPlugin(pt, fnPlugin);
		try {
			const out = await pFn(this);
			return out;
		} finally {
			for (const pt of pluginTypes) this.removePlugin(pt, fnPlugin);
		}
	};
	
		this.setDepthTracker = function (arr, {additionalProps, additionalPropsInherited} = {}) {
		this._depthTracker = arr;
		this._depthTrackerAdditionalProps = additionalProps || [];
		this._depthTrackerAdditionalPropsInherited = additionalPropsInherited || [];
		return this;
	};

	this.getLineBreak = function () { return "<br>"; };

		this.recursiveRender = function (entry, textStack, meta, options) {
		if (entry instanceof Array) {
			entry.forEach(nxt => this.recursiveRender(nxt, textStack, meta, options));
			setTimeout(() => { throw new Error(`Array passed to renderer! The renderer only guarantees support for primitives and basic objects.`); });
			return this;
		}

				if (textStack.length === 0) textStack[0] = "";
		else textStack.reverse();

				meta = meta || {};
		meta._typeStack = [];
		meta.depth = meta.depth == null ? 0 : meta.depth;

		this._recursiveRender(entry, textStack, meta, options);
		if (this._fnPostProcess) textStack[0] = this._fnPostProcess(textStack[0]);
		textStack.reverse();

		return this;
	};

		this._recursiveRender = function (entry, textStack, meta, options) {
		if (entry == null) return; 		if (!textStack) throw new Error("Missing stack!");
		if (!meta) throw new Error("Missing metadata!");
		if (entry.type === "section") meta.depth = -1;

		options = options || {};

		meta._didRenderPrefix = false;
		meta._didRenderSuffix = false;

		if (typeof entry === "object") {
						const type = entry.type == null || entry.type === "section" ? "entries" : entry.type;

						if (type === "wrapper") return this._recursiveRender(entry.wrapped, textStack, meta, options);

			meta._typeStack.push(type);

			switch (type) {
								case "entries": this._renderEntries(entry, textStack, meta, options); break;
				case "options": this._renderOptions(entry, textStack, meta, options); break;
				case "list": this._renderList(entry, textStack, meta, options); break;
				case "table": this._renderTable(entry, textStack, meta, options); break;
				case "tableGroup": this._renderTableGroup(entry, textStack, meta, options); break;
				case "inset": this._renderInset(entry, textStack, meta, options); break;
				case "insetReadaloud": this._renderInsetReadaloud(entry, textStack, meta, options); break;
				case "variant": this._renderVariant(entry, textStack, meta, options); break;
				case "variantInner": this._renderVariantInner(entry, textStack, meta, options); break;
				case "variantSub": this._renderVariantSub(entry, textStack, meta, options); break;
				case "spellcasting": this._renderSpellcasting(entry, textStack, meta, options); break;
				case "quote": this._renderQuote(entry, textStack, meta, options); break;
				case "optfeature": this._renderOptfeature(entry, textStack, meta, options); break;
				case "patron": this._renderPatron(entry, textStack, meta, options); break;

								case "abilityDc": this._renderAbilityDc(entry, textStack, meta, options); break;
				case "abilityAttackMod": this._renderAbilityAttackMod(entry, textStack, meta, options); break;
				case "abilityGeneric": this._renderAbilityGeneric(entry, textStack, meta, options); break;

								case "inline": this._renderInline(entry, textStack, meta, options); break;
				case "inlineBlock": this._renderInlineBlock(entry, textStack, meta, options); break;
				case "bonus": this._renderBonus(entry, textStack, meta, options); break;
				case "bonusSpeed": this._renderBonusSpeed(entry, textStack, meta, options); break;
				case "dice": this._renderDice(entry, textStack, meta, options); break;
				case "link": this._renderLink(entry, textStack, meta, options); break;
				case "actions": this._renderActions(entry, textStack, meta, options); break;
				case "attack": this._renderAttack(entry, textStack, meta, options); break;
				case "ingredient": this._renderIngredient(entry, textStack, meta, options); break;

								case "item": this._renderItem(entry, textStack, meta, options); break;
				case "itemSub": this._renderItemSub(entry, textStack, meta, options); break;
				case "itemSpell": this._renderItemSpell(entry, textStack, meta, options); break;

								case "statblockInline": this._renderStatblockInline(entry, textStack, meta, options); break;
				case "statblock": this._renderStatblock(entry, textStack, meta, options); break;

								case "image": this._renderImage(entry, textStack, meta, options); break;
				case "gallery": this._renderGallery(entry, textStack, meta, options); break;

								case "flowchart": this._renderFlowchart(entry, textStack, meta, options); break;
				case "flowBlock": this._renderFlowBlock(entry, textStack, meta, options); break;

								case "homebrew": this._renderHomebrew(entry, textStack, meta, options); break;

								case "code": this._renderCode(entry, textStack, meta, options); break;
				case "hr": this._renderHr(entry, textStack, meta, options); break;
			}

			meta._typeStack.pop();
		} else if (typeof entry === "string") { 			this._renderPrefix(entry, textStack, meta, options);
			this._renderString(entry, textStack, meta, options);
			this._renderSuffix(entry, textStack, meta, options);
		} else { 						this._renderPrefix(entry, textStack, meta, options);
			this._renderPrimitive(entry, textStack, meta, options);
			this._renderSuffix(entry, textStack, meta, options);
		}
	};

	this._adjustDepth = function (meta, dDepth) {
		const cachedDepth = meta.depth;
		meta.depth += dDepth;
		meta.depth = Math.min(Math.max(-1, meta.depth), 2); 		return cachedDepth;
	};

	this._renderPrefix = function (entry, textStack, meta, options) {
		if (meta._didRenderPrefix) return;
		if (options.prefix != null) {
			textStack[0] += options.prefix;
			meta._didRenderPrefix = true;
		}
	};

	this._renderSuffix = function (entry, textStack, meta, options) {
		if (meta._didRenderSuffix) return;
		if (options.suffix != null) {
			textStack[0] += options.suffix;
			meta._didRenderSuffix = true;
		}
	};

	this._renderImage = function (entry, textStack, meta, options) {
		if (entry.title) this._handleTrackTitles(entry.title, {isImage: true});

		if (entry.imageType === "map" || entry.imageType === "mapPlayer") textStack[0] += `<div class="rd__wrp-map">`;
		textStack[0] += `<div class="float-clear"></div>`;
		textStack[0] += `<div class="${meta._typeStack.includes("gallery") ? "rd__wrp-gallery-image" : ""}">`;

		const href = this._renderImage_getUrl(entry);
		const svg = this._lazyImages && entry.width != null && entry.height != null
			? `data:image/svg+xml,${encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" width="${entry.width}" height="${entry.height}"><rect width="100%" height="100%" fill="#ccc3"></rect></svg>`)}`
			: null;
		const ptTitleCreditTooltip = this._renderImage_getTitleCreditTooltipText(entry);
		textStack[0] += `<div class="${this._renderImage_getWrapperClasses(entry, meta)}" ${entry.title && this._isHeaderIndexIncludeImageTitles ? `data-title-index="${this._headerIndex++}"` : ""}>
			<a href="${href}" target="_blank" rel="noopener noreferrer" ${ptTitleCreditTooltip ? `title="${ptTitleCreditTooltip}"` : ""}>
				<img class="${this._renderImage_getImageClasses(entry, meta)}" src="${svg || href}" ${entry.altText || entry.title ? `alt="${Renderer.stripTags((entry.altText || entry.title)).qq()}"` : ""} ${svg ? `data-src="${href}"` : `loading="lazy"`} ${this._renderImage_getStylePart(entry)}>
			</a>
		</div>`;

		if (entry.title || entry.credit || entry.mapRegions) {
			const ptAdventureBookMeta = entry.mapRegions && meta.adventureBookPage && meta.adventureBookSource && meta.adventureBookHash
				? `data-rd-adventure-book-map-page="${meta.adventureBookPage.qq()}" data-rd-adventure-book-map-source="${meta.adventureBookSource.qq()}" data-rd-adventure-book-map-hash="${meta.adventureBookHash.qq()}"`
				: "";

			textStack[0] += `<div class="rd__image-title">`;

			if (entry.title && !entry.mapRegions) textStack[0] += `<div class="rd__image-title-inner">${this.render(entry.title)}</div>`;

			if (entry.mapRegions && !IS_VTT) {
				textStack[0] += `<button class="btn btn-xs btn-default rd__image-btn-viewer" onclick="RenderMap.pShowViewer(event, this)" data-rd-packed-map="${this._renderImage_getMapRegionData(entry)}" ${ptAdventureBookMeta} title="Open Dynamic Viewer (SHIFT to Open in New Window)"><span class="glyphicon glyphicon-picture"></span> ${Renderer.stripTags(entry.title) || "Dynamic Viewer"}</button>`;
			}

			if (entry.credit) textStack[0] += `<div class="rd__image-credit ve-muted"><span class="glyphicon glyphicon-pencil" title="Art Credit"></span> ${this.render(entry.credit)}</div>`;

			textStack[0] += `</div>`;
		}

		if (entry._galleryTitlePad) textStack[0] += `<div class="rd__image-title">&nbsp;</div>`;
		if (entry._galleryCreditPad) textStack[0] += `<div class="rd__image-credit">&nbsp;</div>`;

		textStack[0] += `</div>`;
		if (entry.imageType === "map" || entry.imageType === "mapPlayer") textStack[0] += `</div>`;
	};

	this._renderImage_getTitleCreditTooltipText = function (entry) {
		if (!entry.title && !entry.credit) return null;
		return Renderer.stripTags(
			[entry.title, entry.credit ? `Art credit: ${entry.credit}` : null]
				.filter(Boolean)
				.join(". "),
		).qq();
	};

	this._renderImage_getStylePart = function (entry) {
		const styles = [
									entry.maxWidth ? `max-width: min(100%, ${entry.maxWidth}${entry.maxWidthUnits || "px"})` : "",
						entry.maxHeight ? `max-height: min(60vh, ${entry.maxHeight}${entry.maxHeightUnits || "px"})` : "",
		].filter(Boolean).join("; ");
		return styles ? `style="${styles}"` : "";
	};

	this._renderImage_getMapRegionData = function (entry) {
		return JSON.stringify(this.getMapRegionData(entry)).escapeQuotes();
	};

	this.getMapRegionData = function (entry) {
		return {
			regions: entry.mapRegions,
			width: entry.width,
			height: entry.height,
			href: this._renderImage_getUrl(entry),
			hrefThumbnail: this._renderImage_getUrlThumbnail(entry),
			page: entry.page,
			source: entry.source,
			hash: entry.hash,
		};
	};

	this._renderImage_getWrapperClasses = function (entry) {
		const out = ["rd__wrp-image", "relative"];
		if (entry.style) {
			switch (entry.style) {
				case "comic-speaker-left": out.push("rd__comic-img-speaker", "rd__comic-img-speaker--left"); break;
				case "comic-speaker-right": out.push("rd__comic-img-speaker", "rd__comic-img-speaker--right"); break;
			}
		}
		return out.join(" ");
	};

	this._renderImage_getImageClasses = function (entry) {
		const out = ["rd__image"];
		if (entry.style) {
			switch (entry.style) {
				case "deity-symbol": out.push("rd__img-small"); break;
			}
		}
		return out.join(" ");
	};

	this._renderImage_getUrl = function (entry) {
		let url = Renderer.utils.getMediaUrl(entry, "href", "img");
		for (const plugin of this._getPlugins(`image_urlPostProcess`)) {
			url = plugin(entry, url) || plugin(entry, url);
		}
		return url;
	};

	this._renderImage_getUrlThumbnail = function (entry) {
		let url = Renderer.utils.getMediaUrl(entry, "hrefThumbnail", "img");
		for (const plugin of this._getPlugins(`image_urlThumbnailPostProcess`)) {
			url = plugin(entry, url) || plugin(entry, url);
		}
		return url;
	};

	this._renderList_getListCssClasses = function (entry, textStack, meta, options) {
		const out = [`rd__list`];
		if (entry.style || entry.columns) {
			if (entry.style) out.push(...entry.style.split(" ").map(it => `rd__${it}`));
			if (entry.columns) out.push(`columns-${entry.columns}`);
		}
		return out.join(" ");
	};

	this._renderTableGroup = function (entry, textStack, meta, options) {
		const len = entry.tables.length;
		for (let i = 0; i < len; ++i) this._recursiveRender(entry.tables[i], textStack, meta);
	};

	this._renderTable = function (entry, textStack, meta, options) {
				if (entry.intro) {
			const len = entry.intro.length;
			for (let i = 0; i < len; ++i) {
				this._recursiveRender(entry.intro[i], textStack, meta, {prefix: "<p>", suffix: "</p>"});
			}
		}

		textStack[0] += `<table class="w-100 rd__table ${entry.style || ""} ${entry.isStriped === false ? "" : "stripe-odd-table"}">`;

		const headerRowMetas = Renderer.table.getHeaderRowMetas(entry);
		const autoRollMode = Renderer.table.getAutoConvertedRollMode(entry, {headerRowMetas});
		const toRenderLabel = autoRollMode ? RollerUtil.getFullRollCol(entry.colLabels[0]) : null;
		const isInfiniteResults = autoRollMode === RollerUtil.ROLL_COL_VARIABLE;

				if (entry.caption != null) {
			this._handleTrackTitles(entry.caption, {isTable: true});
			textStack[0] += `<caption ${this._isHeaderIndexIncludeTableCaptions ? `data-title-index="${this._headerIndex++}"` : ""}>${entry.caption}</caption>`;
		}

				const rollCols = [];
		let bodyStack = [""];
		bodyStack[0] += "<tbody>";
		const lenRows = entry.rows.length;
		for (let ixRow = 0; ixRow < lenRows; ++ixRow) {
			bodyStack[0] += "<tr>";
			const r = entry.rows[ixRow];
			let roRender = r.type === "row" ? r.row : r;

			const len = roRender.length;
			for (let ixCell = 0; ixCell < len; ++ixCell) {
				rollCols[ixCell] = rollCols[ixCell] || false;

								if (autoRollMode && ixCell === 0) {
					roRender = Renderer.getRollableRow(
						roRender,
						{
							isForceInfiniteResults: isInfiniteResults,
							isFirstRow: ixRow === 0,
							isLastRow: ixRow === lenRows - 1,
						},
					);
					rollCols[ixCell] = true;
				}

				let toRenderCell;
				if (roRender[ixCell].type === "cell") {
					if (roRender[ixCell].roll) {
						rollCols[ixCell] = true;
						if (roRender[ixCell].entry) {
							toRenderCell = roRender[ixCell].entry;
						} else if (roRender[ixCell].roll.exact != null) {
							toRenderCell = roRender[ixCell].roll.pad ? StrUtil.padNumber(roRender[ixCell].roll.exact, 2, "0") : roRender[ixCell].roll.exact;
						} else {
														
							const dispMin = roRender[ixCell].roll.displayMin != null ? roRender[ixCell].roll.displayMin : roRender[ixCell].roll.min;
							const dispMax = roRender[ixCell].roll.displayMax != null ? roRender[ixCell].roll.displayMax : roRender[ixCell].roll.max;

							if (dispMax === Renderer.dice.POS_INFINITE) {
								toRenderCell = roRender[ixCell].roll.pad
									? `${StrUtil.padNumber(dispMin, 2, "0")}+`
									: `${dispMin}+`;
							} else {
								toRenderCell = roRender[ixCell].roll.pad
									? `${StrUtil.padNumber(dispMin, 2, "0")}-${StrUtil.padNumber(dispMax, 2, "0")}`
									: `${dispMin}-${dispMax}`;
							}
						}
					} else if (roRender[ixCell].entry) {
						toRenderCell = roRender[ixCell].entry;
					}
				} else {
					toRenderCell = roRender[ixCell];
				}
				bodyStack[0] += `<td ${this._renderTable_makeTableTdClassText(entry, ixCell)} ${this._renderTable_getCellDataStr(roRender[ixCell])} ${roRender[ixCell].type === "cell" && roRender[ixCell].width ? `colspan="${roRender[ixCell].width}"` : ""}>`;
				if (r.style === "row-indent-first" && ixCell === 0) bodyStack[0] += `<div class="rd__tab-indent"></div>`;
				const cacheDepth = this._adjustDepth(meta, 1);
				this._recursiveRender(toRenderCell, bodyStack, meta);
				meta.depth = cacheDepth;
				bodyStack[0] += "</td>";
			}
			bodyStack[0] += "</tr>";
		}
		bodyStack[0] += "</tbody>";

				if (headerRowMetas) {
			textStack[0] += "<thead>";

			for (let ixRow = 0, lenRows = headerRowMetas.length; ixRow < lenRows; ++ixRow) {
				textStack[0] += "<tr>";

				const headerRowMeta = headerRowMetas[ixRow];
				for (let ixCell = 0, lenCells = headerRowMeta.length; ixCell < lenCells; ++ixCell) {
					const lbl = headerRowMeta[ixCell];
					textStack[0] += `<th ${this._renderTable_getTableThClassText(entry, ixCell)} data-rd-isroller="${rollCols[ixCell]}" ${entry.isNameGenerator ? `data-rd-namegeneratorrolls="${headerRowMeta.length - 1}"` : ""}>`;
					this._recursiveRender(autoRollMode && ixCell === 0 ? RollerUtil.getFullRollCol(lbl) : lbl, textStack, meta);
					textStack[0] += `</th>`;
				}

				textStack[0] += "</tr>";
			}

			textStack[0] += "</thead>";
		}

		textStack[0] += bodyStack[0];

				if (entry.footnotes != null) {
			textStack[0] += "<tfoot>";
			const len = entry.footnotes.length;
			for (let i = 0; i < len; ++i) {
				textStack[0] += `<tr><td colspan="99">`;
				const cacheDepth = this._adjustDepth(meta, 1);
				this._recursiveRender(entry.footnotes[i], textStack, meta);
				meta.depth = cacheDepth;
				textStack[0] += "</td></tr>";
			}
			textStack[0] += "</tfoot>";
		}
		textStack[0] += "</table>";

		if (entry.outro) {
			const len = entry.outro.length;
			for (let i = 0; i < len; ++i) {
				this._recursiveRender(entry.outro[i], textStack, meta, {prefix: "<p>", suffix: "</p>"});
			}
		}
	};

	this._renderTable_getCellDataStr = function (ent) {
		function convertZeros (num) {
			if (num === 0) return 100;
			return num;
		}

		if (ent.roll) {
			return `data-roll-min="${convertZeros(ent.roll.exact != null ? ent.roll.exact : ent.roll.min)}" data-roll-max="${convertZeros(ent.roll.exact != null ? ent.roll.exact : ent.roll.max)}"`;
		}

		return "";
	};

	this._renderTable_getTableThClassText = function (entry, i) {
		return entry.colStyles == null || i >= entry.colStyles.length ? "" : `class="${entry.colStyles[i]}"`;
	};

	this._renderTable_makeTableTdClassText = function (entry, i) {
		if (entry.rowStyles != null) return i >= entry.rowStyles.length ? "" : `class="${entry.rowStyles[i]}"`;
		else return this._renderTable_getTableThClassText(entry, i);
	};

	this._renderEntries = function (entry, textStack, meta, options) {
		this._renderEntriesSubtypes(entry, textStack, meta, options, true);
	};

	this._getPagePart = function (entry, isInset) {
		if (!Renderer.utils.isDisplayPage(entry.page)) return "";
		return ` <span class="rd__title-link ${isInset ? `rd__title-link--inset` : ""}">${entry.source ? `<span class="help-subtle" title="${Parser.sourceJsonToFull(entry.source)}">${Parser.sourceJsonToAbv(entry.source)}</span> ` : ""}p${entry.page}</span>`;
	};

	this._renderEntriesSubtypes = function (entry, textStack, meta, options, incDepth) {
		const type = entry.type || "entries";
		const isInlineTitle = meta.depth >= 2;
		const isAddPeriod = isInlineTitle && entry.name && !Renderer._INLINE_HEADER_TERMINATORS.has(entry.name[entry.name.length - 1]);
		const pagePart = !this._isPartPageExpandCollapseDisabled && !isInlineTitle
			? this._getPagePart(entry)
			: "";
		const partExpandCollapse = !this._isPartPageExpandCollapseDisabled && !isInlineTitle
			? `<span class="rd__h-toggle ml-2 clickable" data-rd-h-toggle-button="true">[\u2013]</span>`
			: "";
		const partPageExpandCollapse = !this._isPartPageExpandCollapseDisabled && (pagePart || partExpandCollapse)
			? `<span class="ve-flex-vh-center">${[pagePart, partExpandCollapse].filter(Boolean).join("")}</span>`
			: "";
		const nextDepth = incDepth && meta.depth < 2 ? meta.depth + 1 : meta.depth;
		const styleString = this._renderEntriesSubtypes_getStyleString(entry, meta, isInlineTitle);
		const dataString = this._renderEntriesSubtypes_getDataString(entry);
		if (entry.name != null && Renderer.ENTRIES_WITH_ENUMERATED_TITLES_LOOKUP[entry.type]) this._handleTrackTitles(entry.name);

		const headerTag = isInlineTitle ? "span" : `h${Math.min(Math.max(meta.depth + 2, 1), 6)}`;
		const headerClass = `rd__h--${meta.depth + 1}`; 
		const cachedLastDepthTrackerProps = MiscUtil.copyFast(this._lastDepthTrackerInheritedProps);
		this._handleTrackDepth(entry, meta.depth);

		const pluginDataNamePrefix = this._getPlugins(`${type}_namePrefix`).map(plugin => plugin(entry, textStack, meta, options)).filter(Boolean);

		const headerSpan = entry.name ? `<${headerTag} class="rd__h ${headerClass}" data-title-index="${this._headerIndex++}" ${this._getEnumeratedTitleRel(entry.name)}> <span class="entry-title-inner${!pagePart && entry.source ? ` help-subtle` : ""}"${!pagePart && entry.source ? ` title="Source: ${Parser.sourceJsonToFull(entry.source)}${entry.page ? `, p${entry.page}` : ""}"` : ""}>${pluginDataNamePrefix.join("")}${this.render({type: "inline", entries: [entry.name]})}${isAddPeriod ? "." : ""}</span>${partPageExpandCollapse}</${headerTag}> ` : "";

		if (meta.depth === -1) {
			if (!this._firstSection) textStack[0] += `<hr class="rd__hr rd__hr--section">`;
			this._firstSection = false;
		}

		if (entry.entries || entry.name) {
			textStack[0] += `<${this.wrapperTag} ${dataString} ${styleString}>${headerSpan}`;
			this._renderEntriesSubtypes_renderPreReqText(entry, textStack, meta);
			if (entry.entries) {
				const cacheDepth = meta.depth;
				const len = entry.entries.length;
				for (let i = 0; i < len; ++i) {
					meta.depth = nextDepth;
					this._recursiveRender(entry.entries[i], textStack, meta, {prefix: "<p>", suffix: "</p>"});
										if (i === 0 && cacheDepth >= 2) textStack[0] += `<div class="rd__spc-inline-post"></div>`;
				}
				meta.depth = cacheDepth;
			}
			textStack[0] += `</${this.wrapperTag}>`;
		}

		this._lastDepthTrackerInheritedProps = cachedLastDepthTrackerProps;
	};

	this._renderEntriesSubtypes_getDataString = function (entry) {
		let dataString = "";
		if (entry.source) dataString += `data-source="${entry.source}"`;
		if (entry.data) {
			for (const k in entry.data) {
				if (!k.startsWith("rd-")) continue;
				dataString += ` data-${k}="${`${entry.data[k]}`.escapeQuotes()}"`;
			}
		}
		return dataString;
	};

	this._renderEntriesSubtypes_renderPreReqText = function (entry, textStack, meta) {
		if (entry.prerequisite) {
			textStack[0] += `<span class="rd__prerequisite">Prerequisite: `;
			this._recursiveRender({type: "inline", entries: [entry.prerequisite]}, textStack, meta);
			textStack[0] += `</span>`;
		}
	};

	this._renderEntriesSubtypes_getStyleString = function (entry, meta, isInlineTitle) {
		const styleClasses = ["rd__b"];
		styleClasses.push(this._getStyleClass(entry.type || "entries", entry));
		if (isInlineTitle) {
			if (this._subVariant) styleClasses.push(Renderer.HEAD_2_SUB_VARIANT);
			else styleClasses.push(Renderer.HEAD_2);
		} else styleClasses.push(meta.depth === -1 ? Renderer.HEAD_NEG_1 : meta.depth === 0 ? Renderer.HEAD_0 : Renderer.HEAD_1);
		return styleClasses.length > 0 ? `class="${styleClasses.join(" ")}"` : "";
	};

	this._renderOptions = function (entry, textStack, meta, options) {
		if (!entry.entries) return;
		entry.entries = entry.entries.sort((a, b) => a.name && b.name ? SortUtil.ascSort(a.name, b.name) : a.name ? -1 : b.name ? 1 : 0);

		if (entry.style && entry.style === "list-hang-notitle") {
			const fauxEntry = {
				type: "list",
				style: "list-hang-notitle",
				items: entry.entries.map(ent => {
					if (typeof ent === "string") return ent;
					if (ent.type === "item") return ent;

					const out = {...ent, type: "item"};
					if (ent.name) out.name = Renderer._INLINE_HEADER_TERMINATORS.has(ent.name[ent.name.length - 1]) ? out.name : `${out.name}.`;
					return out;
				}),
			};
			this._renderList(fauxEntry, textStack, meta, options);
		} else this._renderEntriesSubtypes(entry, textStack, meta, options, false);
	};

	this._renderList = function (entry, textStack, meta, options) {
		if (entry.items) {
			const tag = entry.start ? "ol" : "ul";
			const cssClasses = this._renderList_getListCssClasses(entry, textStack, meta, options);
			textStack[0] += `<${tag} ${cssClasses ? `class="${cssClasses}"` : ""} ${entry.start ? `start="${entry.start}"` : ""}>`;
			if (entry.name) textStack[0] += `<li class="rd__list-name">${entry.name}</li>`;
			const isListHang = entry.style && entry.style.split(" ").includes("list-hang");
			const len = entry.items.length;
			for (let i = 0; i < len; ++i) {
				const item = entry.items[i];
								if (item.type !== "list") {
					const className = `${this._getStyleClass(entry.type, item)}${item.type === "itemSpell" ? " rd__li-spell" : ""}`;
					textStack[0] += `<li class="rd__li ${className}">`;
				}
								if (isListHang && typeof item === "string") textStack[0] += "<div>";
				this._recursiveRender(item, textStack, meta);
				if (isListHang && typeof item === "string") textStack[0] += "</div>";
				if (item.type !== "list") textStack[0] += "</li>";
			}
			textStack[0] += `</${tag}>`;
		}
	};

	this._renderInset = function (entry, textStack, meta, options) {
		const dataString = this._renderEntriesSubtypes_getDataString(entry);
		textStack[0] += `<${this.wrapperTag} class="rd__b-special rd__b-inset ${entry.style || ""}" ${dataString}>`;

		const cachedLastDepthTrackerProps = MiscUtil.copyFast(this._lastDepthTrackerInheritedProps);
		this._handleTrackDepth(entry, 1);

		const pagePart = this._getPagePart(entry, true);
		const partExpandCollapse = `<span class="rd__h-toggle ml-2 clickable" data-rd-h-special-toggle-button="true">[\u2013]</span>`;
		const partPageExpandCollapse = `<span class="ve-flex-vh-center">${[pagePart, partExpandCollapse].filter(Boolean).join("")}</span>`;

		if (entry.name != null) {
			if (Renderer.ENTRIES_WITH_ENUMERATED_TITLES_LOOKUP[entry.type]) this._handleTrackTitles(entry.name);
			textStack[0] += `<span class="rd__h rd__h--2-inset" data-title-index="${this._headerIndex++}" ${this._getEnumeratedTitleRel(entry.name)}><h4 class="entry-title-inner">${entry.name}</h4>${partPageExpandCollapse}</span>`;
		} else {
			textStack[0] += `<span class="rd__h rd__h--2-inset rd__h--2-inset-no-name">${partPageExpandCollapse}</span>`;
		}

		if (entry.entries) {
			const len = entry.entries.length;
			for (let i = 0; i < len; ++i) {
				const cacheDepth = meta.depth;
				meta.depth = 2;
				this._recursiveRender(entry.entries[i], textStack, meta, {prefix: "<p>", suffix: "</p>"});
				meta.depth = cacheDepth;
			}
		}
		textStack[0] += `<div class="float-clear"></div>`;
		textStack[0] += `</${this.wrapperTag}>`;

		this._lastDepthTrackerInheritedProps = cachedLastDepthTrackerProps;
	};

	this._renderInsetReadaloud = function (entry, textStack, meta, options) {
		const dataString = this._renderEntriesSubtypes_getDataString(entry);
		textStack[0] += `<${this.wrapperTag} class="rd__b-special rd__b-inset rd__b-inset--readaloud ${entry.style || ""}" ${dataString}>`;

		const cachedLastDepthTrackerProps = MiscUtil.copyFast(this._lastDepthTrackerInheritedProps);
		this._handleTrackDepth(entry, 1);

		const pagePart = this._getPagePart(entry, true);
		const partExpandCollapse = `<span class="rd__h-toggle ml-2 clickable" data-rd-h-special-toggle-button="true">[\u2013]</span>`;
		const partPageExpandCollapse = `<span class="ve-flex-vh-center">${[pagePart, partExpandCollapse].filter(Boolean).join("")}</span>`;

		if (entry.name != null) {
			if (Renderer.ENTRIES_WITH_ENUMERATED_TITLES_LOOKUP[entry.type]) this._handleTrackTitles(entry.name);
			textStack[0] += `<span class="rd__h rd__h--2-inset" data-title-index="${this._headerIndex++}" ${this._getEnumeratedTitleRel(entry.name)}><h4 class="entry-title-inner">${entry.name}</h4>${this._getPagePart(entry, true)}</span>`;
		} else {
			textStack[0] += `<span class="rd__h rd__h--2-inset rd__h--2-inset-no-name">${partPageExpandCollapse}</span>`;
		}

		const len = entry.entries.length;
		for (let i = 0; i < len; ++i) {
			const cacheDepth = meta.depth;
			meta.depth = 2;
			this._recursiveRender(entry.entries[i], textStack, meta, {prefix: "<p>", suffix: "</p>"});
			meta.depth = cacheDepth;
		}
		textStack[0] += `<div class="float-clear"></div>`;
		textStack[0] += `</${this.wrapperTag}>`;

		this._lastDepthTrackerInheritedProps = cachedLastDepthTrackerProps;
	};

	this._renderVariant = function (entry, textStack, meta, options) {
		const dataString = this._renderEntriesSubtypes_getDataString(entry);

		if (entry.name != null && Renderer.ENTRIES_WITH_ENUMERATED_TITLES_LOOKUP[entry.type]) this._handleTrackTitles(entry.name);
		const cachedLastDepthTrackerProps = MiscUtil.copyFast(this._lastDepthTrackerInheritedProps);
		this._handleTrackDepth(entry, 1);

		const pagePart = this._getPagePart(entry, true);
		const partExpandCollapse = `<span class="rd__h-toggle ml-2 clickable" data-rd-h-special-toggle-button="true">[\u2013]</span>`;
		const partPageExpandCollapse = `<span class="ve-flex-vh-center">${[pagePart, partExpandCollapse].filter(Boolean).join("")}</span>`;

		textStack[0] += `<${this.wrapperTag} class="rd__b-special rd__b-inset" ${dataString}>`;
		textStack[0] += `<span class="rd__h rd__h--2-inset" data-title-index="${this._headerIndex++}" ${this._getEnumeratedTitleRel(entry.name)}><h4 class="entry-title-inner">Variant: ${entry.name}</h4>${partPageExpandCollapse}</span>`;
		const len = entry.entries.length;
		for (let i = 0; i < len; ++i) {
			const cacheDepth = meta.depth;
			meta.depth = 2;
			this._recursiveRender(entry.entries[i], textStack, meta, {prefix: "<p>", suffix: "</p>"});
			meta.depth = cacheDepth;
		}
		if (entry.source) textStack[0] += Renderer.utils.getSourceAndPageTrHtml({source: entry.source, page: entry.page});
		textStack[0] += `</${this.wrapperTag}>`;

		this._lastDepthTrackerInheritedProps = cachedLastDepthTrackerProps;
	};

	this._renderVariantInner = function (entry, textStack, meta, options) {
		const dataString = this._renderEntriesSubtypes_getDataString(entry);

		if (entry.name != null && Renderer.ENTRIES_WITH_ENUMERATED_TITLES_LOOKUP[entry.type]) this._handleTrackTitles(entry.name);
		const cachedLastDepthTrackerProps = MiscUtil.copyFast(this._lastDepthTrackerInheritedProps);
		this._handleTrackDepth(entry, 1);

		textStack[0] += `<${this.wrapperTag} class="rd__b-inset-inner" ${dataString}>`;
		textStack[0] += `<span class="rd__h rd__h--2-inset" data-title-index="${this._headerIndex++}" ${this._getEnumeratedTitleRel(entry.name)}><h4 class="entry-title-inner">${entry.name}</h4></span>`;
		const len = entry.entries.length;
		for (let i = 0; i < len; ++i) {
			const cacheDepth = meta.depth;
			meta.depth = 2;
			this._recursiveRender(entry.entries[i], textStack, meta, {prefix: "<p>", suffix: "</p>"});
			meta.depth = cacheDepth;
		}
		if (entry.source) textStack[0] += Renderer.utils.getSourceAndPageTrHtml({source: entry.source, page: entry.page});
		textStack[0] += `</${this.wrapperTag}>`;

		this._lastDepthTrackerInheritedProps = cachedLastDepthTrackerProps;
	};

	this._renderVariantSub = function (entry, textStack, meta, options) {
				this._subVariant = true;
		const fauxEntry = entry;
		fauxEntry.type = "entries";
		const cacheDepth = meta.depth;
		meta.depth = 3;
		this._recursiveRender(fauxEntry, textStack, meta, {prefix: "<p>", suffix: "</p>"});
		meta.depth = cacheDepth;
		this._subVariant = false;
	};

	this._renderSpellcasting_getEntries = function (entry) {
		const hidden = new Set(entry.hidden || []);
		const toRender = [{type: "entries", name: entry.name, entries: entry.headerEntries ? MiscUtil.copyFast(entry.headerEntries) : []}];

		if (entry.constant || entry.will || entry.rest || entry.daily || entry.weekly || entry.yearly || entry.ritual) {
			const tempList = {type: "list", style: "list-hang-notitle", items: [], data: {isSpellList: true}};
			if (entry.constant && !hidden.has("constant")) tempList.items.push({type: "itemSpell", name: `Constant:`, entry: this._renderSpellcasting_getRenderableList(entry.constant).join(", ")});
			if (entry.will && !hidden.has("will")) tempList.items.push({type: "itemSpell", name: `At will:`, entry: this._renderSpellcasting_getRenderableList(entry.will).join(", ")});

			this._renderSpellcasting_getEntries_procPerDuration({entry, tempList, hidden, prop: "charges", fnGetDurationText: num => ` charge${num === 1 ? "" : "s"}`});
			this._renderSpellcasting_getEntries_procPerDuration({entry, tempList, hidden, prop: "rest", durationText: "/rest"});
			this._renderSpellcasting_getEntries_procPerDuration({entry, tempList, hidden, prop: "daily", durationText: "/day"});
			this._renderSpellcasting_getEntries_procPerDuration({entry, tempList, hidden, prop: "weekly", durationText: "/week"});
			this._renderSpellcasting_getEntries_procPerDuration({entry, tempList, hidden, prop: "yearly", durationText: "/year"});

			if (entry.ritual && !hidden.has("ritual")) tempList.items.push({type: "itemSpell", name: `Rituals:`, entry: this._renderSpellcasting_getRenderableList(entry.ritual).join(", ")});
			tempList.items = tempList.items.filter(it => it.entry !== "");
			if (tempList.items.length) toRender[0].entries.push(tempList);
		}

		if (entry.spells && !hidden.has("spells")) {
			const tempList = {type: "list", style: "list-hang-notitle", items: [], data: {isSpellList: true}};
			for (let lvl = 0; lvl < 10; ++lvl) {
				const spells = entry.spells[lvl];
				if (spells) {
					let levelCantrip = `${Parser.spLevelToFull(lvl)}${(lvl === 0 ? "s" : " level")}`;
					let slotsAtWill = ` (at will)`;
					const slots = spells.slots;
					if (slots >= 0) slotsAtWill = slots > 0 ? ` (${slots} slot${slots > 1 ? "s" : ""})` : ``;
					if (spells.lower && spells.lower !== lvl) {
						levelCantrip = `${Parser.spLevelToFull(spells.lower)}-${levelCantrip}`;
						if (slots >= 0) slotsAtWill = slots > 0 ? ` (${slots} ${Parser.spLevelToFull(lvl)}-level slot${slots > 1 ? "s" : ""})` : ``;
					}
					tempList.items.push({type: "itemSpell", name: `${levelCantrip}${slotsAtWill}:`, entry: this._renderSpellcasting_getRenderableList(spells.spells).join(", ") || "\u2014"});
				}
			}
			toRender[0].entries.push(tempList);
		}

		if (entry.footerEntries) toRender.push({type: "entries", entries: entry.footerEntries});
		return toRender;
	};

	this._renderSpellcasting_getEntries_procPerDuration = function ({entry, hidden, tempList, prop, durationText, fnGetDurationText}) {
		if (!entry[prop] || hidden.has(prop)) return;

		for (let lvl = 9; lvl > 0; lvl--) {
			const perDur = entry[prop];
			if (perDur[lvl]) tempList.items.push({type: "itemSpell", name: `${lvl}${fnGetDurationText ? fnGetDurationText(lvl) : durationText}:`, entry: this._renderSpellcasting_getRenderableList(perDur[lvl]).join(", ")});
			const lvlEach = `${lvl}e`;
			if (perDur[lvlEach]) {
				const isHideEach = !perDur[lvl] && perDur[lvlEach].length === 1;
				tempList.items.push({type: "itemSpell", name: `${lvl}${fnGetDurationText ? fnGetDurationText(lvl) : durationText}${isHideEach ? "" : ` each`}:`, entry: this._renderSpellcasting_getRenderableList(perDur[lvlEach]).join(", ")});
			}
		}
	};

	this._renderSpellcasting_getRenderableList = function (spellList) {
		return spellList.filter(it => !it.hidden).map(it => it.entry || it);
	};

	this._renderSpellcasting = function (entry, textStack, meta, options) {
		const toRender = this._renderSpellcasting_getEntries(entry);
		this._recursiveRender({type: "entries", entries: toRender}, textStack, meta);
	};

	this._renderQuote = function (entry, textStack, meta, options) {
		const len = entry.entries.length;
		for (let i = 0; i < len; ++i) {
			textStack[0] += `<p class="rd__quote-line ${i === len - 1 && entry.by ? `rd__quote-line--last` : ""}">${i === 0 && !entry.skipMarks ? "&ldquo;" : ""}`;
			this._recursiveRender(entry.entries[i], textStack, meta, {prefix: entry.skipItalics ? "" : "<i>", suffix: entry.skipItalics ? "" : "</i>"});
			textStack[0] += `${i === len - 1 && !entry.skipMarks ? "&rdquo;" : ""}</p>`;
		}

		if (entry.by || entry.from) {
			textStack[0] += `<p>`;
			const tempStack = [""];
			const byArr = this._renderQuote_getBy(entry);
			if (byArr) {
				for (let i = 0, len = byArr.length; i < len; ++i) {
					const by = byArr[i];
					this._recursiveRender(by, tempStack, meta);
					if (i < len - 1) tempStack[0] += "<br>";
				}
			}
			textStack[0] += `<span class="rd__quote-by">\u2014 ${byArr ? tempStack.join("") : ""}${byArr && entry.from ? `, ` : ""}${entry.from ? `<i>${entry.from}</i>` : ""}</span>`;
			textStack[0] += `</p>`;
		}
	};

	this._renderQuote_getBy = function (entry) {
		if (!entry.by?.length) return null;
		return entry.by instanceof Array ? entry.by : [entry.by];
	};

	this._renderOptfeature = function (entry, textStack, meta, options) {
		this._renderEntriesSubtypes(entry, textStack, meta, options, true);
	};

	this._renderPatron = function (entry, textStack, meta, options) {
		this._renderEntriesSubtypes(entry, textStack, meta, options, false);
	};

	this._renderAbilityDc = function (entry, textStack, meta, options) {
		this._renderPrefix(entry, textStack, meta, options);
		textStack[0] += `<div class="text-center"><b>`;
		this._recursiveRender(entry.name, textStack, meta);
		textStack[0] += ` save DC</b> = 8 + your proficiency bonus + your ${Parser.attrChooseToFull(entry.attributes)}</div>`;
		this._renderSuffix(entry, textStack, meta, options);
	};

	this._renderAbilityAttackMod = function (entry, textStack, meta, options) {
		this._renderPrefix(entry, textStack, meta, options);
		textStack[0] += `<div class="text-center"><b>`;
		this._recursiveRender(entry.name, textStack, meta);
		textStack[0] += ` attack modifier</b> = your proficiency bonus + your ${Parser.attrChooseToFull(entry.attributes)}</div>`;
		this._renderSuffix(entry, textStack, meta, options);
	};

	this._renderAbilityGeneric = function (entry, textStack, meta, options) {
		this._renderPrefix(entry, textStack, meta, options);
		textStack[0] += `<div class="text-center">`;
		if (entry.name) this._recursiveRender(entry.name, textStack, meta, {prefix: "<b>", suffix: "</b> = "});
		textStack[0] += `${entry.text}${entry.attributes ? ` ${Parser.attrChooseToFull(entry.attributes)}` : ""}</div>`;
		this._renderSuffix(entry, textStack, meta, options);
	};

	this._renderInline = function (entry, textStack, meta, options) {
		if (entry.entries) {
			const len = entry.entries.length;
			for (let i = 0; i < len; ++i) this._recursiveRender(entry.entries[i], textStack, meta);
		}
	};

	this._renderInlineBlock = function (entry, textStack, meta, options) {
		this._renderPrefix(entry, textStack, meta, options);
		if (entry.entries) {
			const len = entry.entries.length;
			for (let i = 0; i < len; ++i) this._recursiveRender(entry.entries[i], textStack, meta);
		}
		this._renderSuffix(entry, textStack, meta, options);
	};

	this._renderBonus = function (entry, textStack, meta, options) {
		textStack[0] += (entry.value < 0 ? "" : "+") + entry.value;
	};

	this._renderBonusSpeed = function (entry, textStack, meta, options) {
		textStack[0] += entry.value === 0 ? "\u2014" : `${entry.value < 0 ? "" : "+"}${entry.value} ft.`;
	};

	this._renderDice = function (entry, textStack, meta, options) {
		const pluginResults = this._getPlugins("dice").map(plugin => plugin(entry, textStack, meta, options)).filter(Boolean);

		textStack[0] += Renderer.getEntryDice(entry, entry.name, {isAddHandlers: this._isAddHandlers, pluginResults});
	};

	this._renderActions = function (entry, textStack, meta, options) {
		const dataString = this._renderEntriesSubtypes_getDataString(entry);

		if (entry.name != null && Renderer.ENTRIES_WITH_ENUMERATED_TITLES_LOOKUP[entry.type]) this._handleTrackTitles(entry.name);
		const cachedLastDepthTrackerProps = MiscUtil.copyFast(this._lastDepthTrackerInheritedProps);
		this._handleTrackDepth(entry, 2);

		textStack[0] += `<${this.wrapperTag} class="${Renderer.HEAD_2}" ${dataString}><span class="rd__h rd__h--3" data-title-index="${this._headerIndex++}" ${this._getEnumeratedTitleRel(entry.name)}><span class="entry-title-inner">${entry.name}.</span></span> `;
		const len = entry.entries.length;
		for (let i = 0; i < len; ++i) this._recursiveRender(entry.entries[i], textStack, meta, {prefix: "<p>", suffix: "</p>"});
		textStack[0] += `</${this.wrapperTag}>`;

		this._lastDepthTrackerInheritedProps = cachedLastDepthTrackerProps;
	};

	this._renderAttack = function (entry, textStack, meta, options) {
		this._renderPrefix(entry, textStack, meta, options);
		textStack[0] += `<i>${Parser.attackTypeToFull(entry.attackType)}:</i> `;
		const len = entry.attackEntries.length;
		for (let i = 0; i < len; ++i) this._recursiveRender(entry.attackEntries[i], textStack, meta);
		textStack[0] += ` <i>Hit:</i> `;
		const len2 = entry.hitEntries.length;
		for (let i = 0; i < len2; ++i) this._recursiveRender(entry.hitEntries[i], textStack, meta);
		this._renderSuffix(entry, textStack, meta, options);
	};

	this._renderIngredient = function (entry, textStack, meta, options) {
		this._renderPrefix(entry, textStack, meta, options);
		this._recursiveRender(entry.entry, textStack, meta);
		this._renderSuffix(entry, textStack, meta, options);
	};

	this._renderItem = function (entry, textStack, meta, options) {
		this._renderPrefix(entry, textStack, meta, options);
		const isAddPeriod = entry.name && entry.nameDot !== false && !Renderer._INLINE_HEADER_TERMINATORS.has(entry.name[entry.name.length - 1]);
		textStack[0] += `<p class="rd__p-list-item"><span class="${entry.style || "bold"} rd__list-item-name">${this.render(entry.name)}${isAddPeriod ? "." : ""}</span> `;
		if (entry.entry) this._recursiveRender(entry.entry, textStack, meta);
		else if (entry.entries) {
			const len = entry.entries.length;
			for (let i = 0; i < len; ++i) this._recursiveRender(entry.entries[i], textStack, meta, {prefix: i > 0 ? `<span class="rd__p-cont-indent">` : "", suffix: i > 0 ? "</span>" : ""});
		}
		textStack[0] += "</p>";
		this._renderSuffix(entry, textStack, meta, options);
	};

	this._renderItemSub = function (entry, textStack, meta, options) {
		this._renderPrefix(entry, textStack, meta, options);
		const isAddPeriod = entry.name && entry.nameDot !== false && !Renderer._INLINE_HEADER_TERMINATORS.has(entry.name[entry.name.length - 1]);
		this._recursiveRender(entry.entry, textStack, meta, {prefix: `<p class="rd__p-list-item"><span class="italic rd__list-item-name">${entry.name}${isAddPeriod ? "." : ""}</span> `, suffix: "</p>"});
		this._renderSuffix(entry, textStack, meta, options);
	};

	this._renderItemSpell = function (entry, textStack, meta, options) {
		this._renderPrefix(entry, textStack, meta, options);
		this._recursiveRender(entry.entry, textStack, meta, {prefix: `<p>${entry.name} `, suffix: "</p>"});
		this._renderSuffix(entry, textStack, meta, options);
	};

	this._InlineStatblockStrategy = function (
		{
			pFnPreProcess,
		},
	) {
		this.pFnPreProcess = pFnPreProcess;
	};

	this._INLINE_STATBLOCK_STRATEGIES = {
		"item": new this._InlineStatblockStrategy({
			pFnPreProcess: async (ent) => {
				await Renderer.item.pPopulatePropertyAndTypeReference();
				Renderer.item.enhanceItem(ent);
				return ent;
			},
		}),
	};

	this._renderStatblockInline = function (entry, textStack, meta, options) {
		const fnGetRenderCompact = Renderer.hover.getFnRenderCompact(entry.dataType);

		const headerName = entry.data?.name;
		const headerStyle = entry.style;

		if (!fnGetRenderCompact) {
			this._renderPrefix(entry, textStack, meta, options);
			this._renderDataHeader(textStack, headerName, headerStyle);
			textStack[0] += `<tr>
				<td colspan="6">
					<i class="text-danger">Cannot render &quot;${entry.type}&quot;&mdash;unknown data type &quot;${entry.dataType}&quot;!</i>
				</td>
			</tr>`;
			this._renderDataFooter(textStack);
			this._renderSuffix(entry, textStack, meta, options);
			return;
		}

		const strategy = this._INLINE_STATBLOCK_STRATEGIES[entry.dataType];

		if (!strategy?.pFnPreProcess) {
			this._renderPrefix(entry, textStack, meta, options);
			this._renderDataHeader(textStack, headerName, headerStyle, {isCollapsed: entry.collapsed});
			textStack[0] += fnGetRenderCompact(entry.data, {isEmbeddedEntity: true});
			this._renderDataFooter(textStack);
			this._renderSuffix(entry, textStack, meta, options);
			return;
		}

		this._renderPrefix(entry, textStack, meta, options);
		this._renderDataHeader(textStack, headerName, headerStyle, {isCollapsed: entry.collapsed});

		const id = CryptUtil.uid();
		Renderer._cache.inlineStatblock[id] = {
			pFn: async (ele) => {
				const ent = await strategy.pFnPreProcess(entry.data);

				const tbl = ele.closest("table");
				const nxt = e_({
					outer: Renderer.utils.getEmbeddedDataHeader(headerName, headerStyle, {isCollapsed: entry.collapsed})
						+ fnGetRenderCompact(ent, {isEmbeddedEntity: true})
						+ Renderer.utils.getEmbeddedDataFooter(),
				});
				tbl.parentNode.replaceChild(
					nxt,
					tbl,
				);
			},
		};

		textStack[0] += `<tr><td colspan="6"><style data-rd-cache-id="${id}" data-rd-cache="inlineStatblock" onload="Renderer._cache.pRunFromEle(this)"></style></td></tr>`;
		this._renderDataFooter(textStack);
		this._renderSuffix(entry, textStack, meta, options);
	};

	this._renderDataHeader = function (textStack, name, style, {isCollapsed = false} = {}) {
		textStack[0] += Renderer.utils.getEmbeddedDataHeader(name, style, {isCollapsed});
	};

	this._renderDataFooter = function (textStack) {
		textStack[0] += Renderer.utils.getEmbeddedDataFooter();
	};

	this._renderStatblock = function (entry, textStack, meta, options) {
		this._renderPrefix(entry, textStack, meta, options);

		const page = entry.prop || Renderer.tag.getPage(entry.tag);
		const source = Parser.getTagSource(entry.tag, entry.source);
		const hash = entry.hash || (UrlUtil.URL_TO_HASH_BUILDER[page] ? UrlUtil.URL_TO_HASH_BUILDER[page]({...entry, name: entry.name, source}) : null);

		const asTag = `{@${entry.tag} ${entry.name}|${source}${entry.displayName ? `|${entry.displayName}` : ""}}`;

		if (!page || !source || !hash) {
			this._renderDataHeader(textStack, entry.name, entry.style);
			textStack[0] += `<tr>
				<td colspan="6">
					<i class="text-danger">Cannot load ${entry.tag ? `&quot;${asTag}&quot;` : entry.displayName || entry.name}! An unknown tag/prop, source, or hash was provided.</i>
				</td>
			</tr>`;
			this._renderDataFooter(textStack);
			this._renderSuffix(entry, textStack, meta, options);

			return;
		}

		this._renderDataHeader(textStack, entry.name, entry.style, {isCollapsed: entry.collapsed});
		textStack[0] += `<tr>
			<td colspan="6" data-rd-tag="${(entry.tag || "").qq()}" data-rd-page="${(page || "").qq()}" data-rd-source="${(source || "").qq()}" data-rd-hash="${(hash || "").qq()}" data-rd-name="${(entry.name || "").qq()}" data-rd-display-name="${(entry.displayName || "").qq()}" data-rd-style="${(entry.style || "").qq()}">
				<i>Loading ${entry.tag ? `${Renderer.get().render(asTag)}` : entry.displayName || entry.name}...</i>
				<style onload="Renderer.events.handleLoad_inlineStatblock(this)"></style>
			</td>
		</tr>`;
		this._renderDataFooter(textStack);
		this._renderSuffix(entry, textStack, meta, options);
	};

	this._renderGallery = function (entry, textStack, meta, options) {
		textStack[0] += `<div class="rd__wrp-gallery">`;
		const len = entry.images.length;
		const anyNamed = entry.images.some(it => it.title);
		const isAnyCredited = entry.images.some(it => it.credit);
		for (let i = 0; i < len; ++i) {
			const img = MiscUtil.copyFast(entry.images[i]);

						if (anyNamed && !img.title) img._galleryTitlePad = true;
			if (isAnyCredited && !img.credit) img._galleryCreditPad = true;

			delete img.imageType;
			this._recursiveRender(img, textStack, meta, options);
		}
		textStack[0] += `</div>`;
	};

	this._renderFlowchart = function (entry, textStack, meta, options) {
		textStack[0] += `<div class="rd__wrp-flowchart">`;
		const len = entry.blocks.length;
		for (let i = 0; i < len; ++i) {
			this._recursiveRender(entry.blocks[i], textStack, meta, options);
			if (i !== len - 1) {
				textStack[0] += `<div class="rd__s-v-flow"></div>`;
			}
		}
		textStack[0] += `</div>`;
	};

	this._renderFlowBlock = function (entry, textStack, meta, options) {
		const dataString = this._renderEntriesSubtypes_getDataString(entry);
		textStack[0] += `<${this.wrapperTag} class="rd__b-special rd__b-flow text-center" ${dataString}>`;

		const cachedLastDepthTrackerProps = MiscUtil.copyFast(this._lastDepthTrackerInheritedProps);
		this._handleTrackDepth(entry, 1);

		if (entry.name != null) {
			if (Renderer.ENTRIES_WITH_ENUMERATED_TITLES_LOOKUP[entry.type]) this._handleTrackTitles(entry.name);
			textStack[0] += `<span class="rd__h rd__h--2-flow-block" data-title-index="${this._headerIndex++}" ${this._getEnumeratedTitleRel(entry.name)}><h4 class="entry-title-inner">${this.render({type: "inline", entries: [entry.name]})}</h4></span>`;
		}
		if (entry.entries) {
			const len = entry.entries.length;
			for (let i = 0; i < len; ++i) {
				const cacheDepth = meta.depth;
				meta.depth = 2;
				this._recursiveRender(entry.entries[i], textStack, meta, {prefix: "<p>", suffix: "</p>"});
				meta.depth = cacheDepth;
			}
		}
		textStack[0] += `<div class="float-clear"></div>`;
		textStack[0] += `</${this.wrapperTag}>`;

		this._lastDepthTrackerInheritedProps = cachedLastDepthTrackerProps;
	};

	this._renderHomebrew = function (entry, textStack, meta, options) {
		this._renderPrefix(entry, textStack, meta, options);
		textStack[0] += `<div class="homebrew-section"><div class="homebrew-float"><span class="homebrew-notice"></span>`;

		if (entry.oldEntries) {
			const hoverMeta = Renderer.hover.getMakePredefinedHover({type: "entries", name: "Homebrew", entries: entry.oldEntries});
			let markerText;
			if (entry.movedTo) {
				markerText = "(See moved content)";
			} else if (entry.entries) {
				markerText = "(See replaced content)";
			} else {
				markerText = "(See removed content)";
			}
			textStack[0] += `<span class="homebrew-old-content" href="#${window.location.hash}" ${hoverMeta.html}>${markerText}</span>`;
		}

		textStack[0] += `</div>`;

		if (entry.entries) {
			const len = entry.entries.length;
			for (let i = 0; i < len; ++i) this._recursiveRender(entry.entries[i], textStack, meta, {prefix: "<p>", suffix: "</p>"});
		} else if (entry.movedTo) {
			textStack[0] += `<i>This content has been moved to ${entry.movedTo}.</i>`;
		} else {
			textStack[0] += "<i>This content has been deleted.</i>";
		}

		textStack[0] += `</div>`;
		this._renderSuffix(entry, textStack, meta, options);
	};

	this._renderCode = function (entry, textStack, meta, options) {
		const isWrapped = !!StorageUtil.syncGet("rendererCodeWrap");
		textStack[0] += `
			<div class="ve-flex-col h-100">
				<div class="ve-flex no-shrink pt-1">
					<button class="btn btn-default btn-xs mb-1 mr-2" onclick="Renderer.events.handleClick_copyCode(event, this)">Copy Code</button>
					<button class="btn btn-default btn-xs mb-1 ${isWrapped ? "active" : ""}" onclick="Renderer.events.handleClick_toggleCodeWrap(event, this)">Word Wrap</button>
				</div>
				<pre class="h-100 w-100 mb-1 ${isWrapped ? "rd__pre-wrap" : ""}">${entry.preformatted}</pre>
			</div>
		`;
	};

	this._renderHr = function (entry, textStack, meta, options) {
		textStack[0] += `<hr class="rd__hr">`;
	};

	this._getStyleClass = function (entryType, entry) {
		const outList = [];

		const pluginResults = this._getPlugins(`${entryType}_styleClass_fromSource`)
			.map(plugin => plugin(entryType, entry)).filter(Boolean);

		if (!pluginResults.some(it => it.isSkip)) {
			if (
				SourceUtil.isNonstandardSource(entry.source)
				|| (typeof PrereleaseUtil !== "undefined" && PrereleaseUtil.hasSourceJson(entry.source))
			) outList.push("spicy-sauce");
			if (typeof BrewUtil2 !== "undefined" && BrewUtil2.hasSourceJson(entry.source)) outList.push("refreshing-brew");
		}

		if (this._extraSourceClasses) outList.push(...this._extraSourceClasses);
		for (const k in this._fnsGetStyleClasses) {
			const fromFn = this._fnsGetStyleClasses[k](entry);
			if (fromFn) outList.push(...fromFn);
		}
		if (entry.style) outList.push(entry.style);
		return outList.join(" ");
	};

	this._renderString = function (entry, textStack, meta, options) {
		const tagSplit = Renderer.splitByTags(entry);
		const len = tagSplit.length;
		for (let i = 0; i < len; ++i) {
			const s = tagSplit[i];
			if (!s) continue;
			if (s.startsWith("{@")) {
				const [tag, text] = Renderer.splitFirstSpace(s.slice(1, -1));
				this._renderString_renderTag(textStack, meta, options, tag, text);
			} else textStack[0] += s;
		}
	};

	this._renderString_renderTag = function (textStack, meta, options, tag, text) {
						for (const plugin of this._getPlugins("string_tag")) {
			const out = plugin(tag, text, textStack, meta, options);
			if (out) return void (textStack[0] += out);
		}

				for (const plugin of this._getPlugins(`string_${tag}`)) {
			const out = plugin(tag, text, textStack, meta, options);
			if (out) return void (textStack[0] += out);
		}
		
		switch (tag) {
						case "@b":
			case "@bold":
				textStack[0] += `<b>`;
				this._recursiveRender(text, textStack, meta);
				textStack[0] += `</b>`;
				break;
			case "@i":
			case "@italic":
				textStack[0] += `<i>`;
				this._recursiveRender(text, textStack, meta);
				textStack[0] += `</i>`;
				break;
			case "@s":
			case "@strike":
				textStack[0] += `<s>`;
				this._recursiveRender(text, textStack, meta);
				textStack[0] += `</s>`;
				break;
			case "@u":
			case "@underline":
				textStack[0] += `<u>`;
				this._recursiveRender(text, textStack, meta);
				textStack[0] += `</u>`;
				break;
			case "@sup":
				textStack[0] += `<sup>`;
				this._recursiveRender(text, textStack, meta);
				textStack[0] += `</sup>`;
				break;
			case "@sub":
				textStack[0] += `<sub>`;
				this._recursiveRender(text, textStack, meta);
				textStack[0] += `</sub>`;
				break;
			case "@kbd":
				textStack[0] += `<kbd>`;
				this._recursiveRender(text, textStack, meta);
				textStack[0] += `</kbd>`;
				break;
			case "@code":
				textStack[0] += `<span class="code">`;
				this._recursiveRender(text, textStack, meta);
				textStack[0] += `</span>`;
				break;
			case "@style": {
				const [displayText, styles] = Renderer.splitTagByPipe(text);
				const classNames = (styles || "").split(";").map(it => Renderer._STYLE_TAG_ID_TO_STYLE[it.trim()]).filter(Boolean).join(" ");
				textStack[0] += `<span class="${classNames}">`;
				this._recursiveRender(displayText, textStack, meta);
				textStack[0] += `</span>`;
				break;
			}
			case "@font": {
				const [displayText, fontFamily] = Renderer.splitTagByPipe(text);
				textStack[0] += `<span style="font-family: '${fontFamily}'">`;
				this._recursiveRender(displayText, textStack, meta);
				textStack[0] += `</span>`;
				break;
			}
			case "@note":
				textStack[0] += `<i class="ve-muted">`;
				this._recursiveRender(text, textStack, meta);
				textStack[0] += `</i>`;
				break;
			case "@atk":
				textStack[0] += `<i>${Renderer.attackTagToFull(text)}</i>`;
				break;
			case "@h": textStack[0] += `<i>Hit:</i> `; break;
			case "@m": textStack[0] += `<i>Miss:</i> `; break;
			case "@color": {
				const [toDisplay, color] = Renderer.splitTagByPipe(text);
				const ptColor = this._renderString_renderTag_getBrewColorPart(color);

				textStack[0] += `<span class="rd__color" style="color: ${ptColor}">`;
				this._recursiveRender(toDisplay, textStack, meta);
				textStack[0] += `</span>`;
				break;
			}
			case "@highlight": {
				const [toDisplay, color] = Renderer.splitTagByPipe(text);
				const ptColor = this._renderString_renderTag_getBrewColorPart(color);

				textStack[0] += ptColor ? `<span style="background-color: ${ptColor}">` : `<span class="rd__highlight">`;
				textStack[0] += toDisplay;
				textStack[0] += `</span>`;
				break;
			}
			case "@help": {
				const [toDisplay, title = ""] = Renderer.splitTagByPipe(text);
				textStack[0] += `<span class="help" title="${title.qq()}">`;
				this._recursiveRender(toDisplay, textStack, meta);
				textStack[0] += `</span>`;
				break;
			}

						case "@unit": {
				const [amount, unitSingle, unitPlural] = Renderer.splitTagByPipe(text);
				textStack[0] += isNaN(amount) ? unitSingle : Number(amount) > 1 ? (unitPlural || unitSingle.toPlural()) : unitSingle;
				break;
			}

						case "@comic":
				textStack[0] += `<span class="rd__comic">`;
				this._recursiveRender(text, textStack, meta);
				textStack[0] += `</span>`;
				break;
			case "@comicH1":
				textStack[0] += `<span class="rd__comic rd__comic--h1">`;
				this._recursiveRender(text, textStack, meta);
				textStack[0] += `</span>`;
				break;
			case "@comicH2":
				textStack[0] += `<span class="rd__comic rd__comic--h2">`;
				this._recursiveRender(text, textStack, meta);
				textStack[0] += `</span>`;
				break;
			case "@comicH3":
				textStack[0] += `<span class="rd__comic rd__comic--h3">`;
				this._recursiveRender(text, textStack, meta);
				textStack[0] += `</span>`;
				break;
			case "@comicH4":
				textStack[0] += `<span class="rd__comic rd__comic--h4">`;
				this._recursiveRender(text, textStack, meta);
				textStack[0] += `</span>`;
				break;
			case "@comicNote":
				textStack[0] += `<span class="rd__comic rd__comic--note">`;
				this._recursiveRender(text, textStack, meta);
				textStack[0] += `</span>`;
				break;

						case "@dc": {
				const [dcText, displayText] = Renderer.splitTagByPipe(text);
				textStack[0] += `DC <span class="rd__dc">${displayText || dcText}</span>`;
				break;
			}

						case "@dice":
			case "@autodice":
			case "@damage":
			case "@hit":
			case "@d20":
			case "@chance":
			case "@coinflip":
			case "@recharge":
			case "@ability":
			case "@savingThrow":
			case "@skillCheck": {
				const fauxEntry = Renderer.utils.getTagEntry(tag, text);

				if (tag === "@recharge") {
					const [, flagsRaw] = Renderer.splitTagByPipe(text);
					const flags = flagsRaw ? flagsRaw.split("") : null;
					textStack[0] += `${flags && flags.includes("m") ? "" : "("}Recharge `;
					this._recursiveRender(fauxEntry, textStack, meta);
					textStack[0] += `${flags && flags.includes("m") ? "" : ")"}`;
				} else {
					this._recursiveRender(fauxEntry, textStack, meta);
				}

				break;
			}

			case "@hitYourSpellAttack": this._renderString_renderTag_hitYourSpellAttack(textStack, meta, options, tag, text); break;

						case "@scaledice":
			case "@scaledamage": {
				const fauxEntry = Renderer.parseScaleDice(tag, text);
				this._recursiveRender(fauxEntry, textStack, meta);
				break;
			}

						case "@filter": {
								const [displayText, page, ...filters] = Renderer.splitTagByPipe(text);

				const filterSubhashMeta = Renderer.getFilterSubhashes(filters);

				const fauxEntry = {
					type: "link",
					text: displayText,
					href: {
						type: "internal",
						path: `${page}.html`,
						hash: HASH_BLANK,
						hashPreEncoded: true,
						subhashes: filterSubhashMeta.subhashes,
					},
				};

				if (filterSubhashMeta.customHash) fauxEntry.href.hash = filterSubhashMeta.customHash;

				this._recursiveRender(fauxEntry, textStack, meta);

				break;
			}
			case "@link": {
				const [displayText, url] = Renderer.splitTagByPipe(text);
				let outUrl = url == null ? displayText : url;
				if (!outUrl.startsWith("http")) outUrl = `http://${outUrl}`; 				const fauxEntry = {
					type: "link",
					href: {
						type: "external",
						url: outUrl,
					},
					text: displayText,
				};
				this._recursiveRender(fauxEntry, textStack, meta);

				break;
			}
			case "@5etools": {
				const [displayText, page, hash] = Renderer.splitTagByPipe(text);
				const fauxEntry = {
					type: "link",
					href: {
						type: "internal",
						path: page,
					},
					text: displayText,
				};
				if (hash) {
					fauxEntry.hash = hash;
					fauxEntry.hashPreEncoded = true;
				}
				this._recursiveRender(fauxEntry, textStack, meta);

				break;
			}

						case "@footnote": {
				const [displayText, footnoteText, optTitle] = Renderer.splitTagByPipe(text);
				const hoverMeta = Renderer.hover.getMakePredefinedHover({
					type: "entries",
					name: optTitle ? optTitle.toTitleCase() : "Footnote",
					entries: [footnoteText, optTitle ? `{@note ${optTitle}}` : ""].filter(Boolean),
				});
				textStack[0] += `<span class="help" ${hoverMeta.html}>`;
				this._recursiveRender(displayText, textStack, meta);
				textStack[0] += `</span>`;

				break;
			}
			case "@homebrew": {
				const [newText, oldText] = Renderer.splitTagByPipe(text);
				const tooltipEntries = [];
				if (newText && oldText) {
					tooltipEntries.push("{@b This is a homebrew addition, replacing the following:}");
				} else if (newText) {
					tooltipEntries.push("{@b This is a homebrew addition.}");
				} else if (oldText) {
					tooltipEntries.push("{@b The following text has been removed with this homebrew:}");
				}
				if (oldText) {
					tooltipEntries.push(oldText);
				}
				const hoverMeta = Renderer.hover.getMakePredefinedHover({
					type: "entries",
					name: "Homebrew Modifications",
					entries: tooltipEntries,
				});
				textStack[0] += `<span class="homebrew-inline" ${hoverMeta.html}>`;
				this._recursiveRender(newText || "[...]", textStack, meta);
				textStack[0] += `</span>`;

				break;
			}
			case "@area": {
				const [compactText, areaId, flags, ...others] = Renderer.splitTagByPipe(text);

				const renderText = flags && flags.includes("x")
					? compactText
					: `${flags && flags.includes("u") ? "A" : "a"}rea ${compactText}`;

				if (typeof BookUtil === "undefined") { 					textStack[0] += renderText;
				} else {
					const area = BookUtil.curRender.headerMap[areaId] || {entry: {name: ""}}; 					const hoverMeta = Renderer.hover.getMakePredefinedHover(area.entry, {isLargeBookContent: true, depth: area.depth});
					textStack[0] += `<a href="#${BookUtil.curRender.curBookId},${area.chapter},${UrlUtil.encodeForHash(area.entry.name)},0" ${hoverMeta.html}>${renderText}</a>`;
				}

				break;
			}

						case "@loader": {
				const {name, path, mode} = this._renderString_getLoaderTagMeta(text);

				const brewUtilName = mode === "homebrew" ? "BrewUtil2" : mode === "prerelease" ? "PrereleaseUtil" : null;
				const brewUtil = globalThis[brewUtilName];

				if (!brewUtil) {
					textStack[0] += `<span class="text-danger" title="Unknown loader mode &quot;${mode.qq()}&quot;!">${name}<span class="glyphicon glyphicon-alert rd__loadbrew-icon rd__loadbrew-icon"></span></span>`;

					break;
				}

				textStack[0] += `<span onclick="${brewUtilName}.pAddBrewFromLoaderTag(this)" data-rd-loader-path="${path.escapeQuotes()}" data-rd-loader-name="${name.escapeQuotes()}" class="rd__wrp-loadbrew--ready" title="Click to install ${brewUtil.DISPLAY_NAME}">${name}<span class="glyphicon glyphicon-download-alt rd__loadbrew-icon rd__loadbrew-icon"></span></span>`;
				break;
			}

						case "@book":
			case "@adventure": {
								const page = tag === "@book" ? "book.html" : "adventure.html";
				const [displayText, book, chapter, section, rawNumber] = Renderer.splitTagByPipe(text);
				const number = rawNumber || 0;
				const hash = `${book}${chapter ? `${HASH_PART_SEP}${chapter}${section ? `${HASH_PART_SEP}${UrlUtil.encodeForHash(section)}${number != null ? `${HASH_PART_SEP}${UrlUtil.encodeForHash(number)}` : ""}` : ""}` : ""}`;
				const fauxEntry = {
					type: "link",
					href: {
						type: "internal",
						path: page,
						hash,
						hashPreEncoded: true,
					},
					text: displayText,
				};
				this._recursiveRender(fauxEntry, textStack, meta);

				break;
			}

			default: {
				const {name, source, displayText, others, page, hash, hashPreEncoded, pageHover, hashHover, hashPreEncodedHover, preloadId, linkText, subhashes, subhashesHover, isFauxPage} = Renderer.utils.getTagMeta(tag, text);

				const fauxEntry = {
					type: "link",
					href: {
						type: "internal",
						path: page,
						hash,
						hover: {
							page,
							isFauxPage,
							source,
						},
					},
					text: (displayText || name),
				};

				if (hashPreEncoded != null) fauxEntry.href.hashPreEncoded = hashPreEncoded;
				if (pageHover != null) fauxEntry.href.hover.page = pageHover;
				if (hashHover != null) fauxEntry.href.hover.hash = hashHover;
				if (hashPreEncodedHover != null) fauxEntry.href.hover.hashPreEncoded = hashPreEncodedHover;
				if (preloadId != null) fauxEntry.href.hover.preloadId = preloadId;
				if (linkText) fauxEntry.text = linkText;
				if (subhashes) fauxEntry.href.subhashes = subhashes;
				if (subhashesHover) fauxEntry.href.hover.subhashes = subhashesHover;

				this._recursiveRender(fauxEntry, textStack, meta);

				break;
			}
		}
	};

	this._renderString_renderTag_getBrewColorPart = function (color) {
		if (!color) return "";
		const scrubbedColor = BrewUtilShared.getValidColor(color, {isExtended: true});
		return scrubbedColor.startsWith("--") ? `var(${scrubbedColor})` : `#${scrubbedColor}`;
	};

	this._renderString_renderTag_hitYourSpellAttack = function (textStack, meta, options, tag, text) {
		const fauxEntry = {
			type: "dice",
			rollable: true,
			subType: "d20",
			displayText: "your spell attack modifier",
			toRoll: `1d20 + #$prompt_number:title=Enter your Spell Attack Modifier$#`,
		};
		return this._recursiveRender(fauxEntry, textStack, meta);
	};

	this._renderString_getLoaderTagMeta = function (text, {isDefaultUrl = false} = {}) {
		const [name, file, mode = "homebrew"] = Renderer.splitTagByPipe(text);

		if (!isDefaultUrl) return {name, path: file, mode};

		const path = /^.*?:\/\//.test(file) ? file : `${VeCt.URL_ROOT_BREW}${file}`;
		return {name, path, mode};
	};

	this._renderPrimitive = function (entry, textStack, meta, options) { textStack[0] += entry; };

	this._renderLink = function (entry, textStack, meta, options) {
		let href = this._renderLink_getHref(entry);

				if (entry.href.hover && this._roll20Ids) {
			const procHash = UrlUtil.encodeForHash(entry.href.hash);
			const id = this._roll20Ids[procHash];
			if (id) {
				href = `http://journal.roll20.net/${id.type}/${id.roll20Id}`;
			}
		}

		const pluginData = this._getPlugins("link").map(plugin => plugin(entry, textStack, meta, options)).filter(Boolean);
		const isDisableEvents = pluginData.some(it => it.isDisableEvents);
		const additionalAttributes = pluginData.map(it => it.attributes).filter(Boolean);

		if (this._isInternalLinksDisabled && entry.href.type === "internal") {
			textStack[0] += `<span class="bold" ${isDisableEvents ? "" : this._renderLink_getHoverString(entry)} ${additionalAttributes.join(" ")}>${this.render(entry.text)}</span>`;
		} else if (entry.href.hover?.isFauxPage) {
			textStack[0] += `<span class="help help--hover" ${isDisableEvents ? "" : this._renderLink_getHoverString(entry)} ${additionalAttributes.join(" ")}>${this.render(entry.text)}</span>`;
		} else {
			textStack[0] += `<a href="${href.qq()}" ${entry.href.type === "internal" ? "" : `target="_blank" rel="noopener noreferrer"`} ${isDisableEvents ? "" : this._renderLink_getHoverString(entry)} ${additionalAttributes.join(" ")}>${this.render(entry.text)}</a>`;
		}
	};

	this._renderLink_getHref = function (entry) {
		let href;
		if (entry.href.type === "internal") {
						href = `${this.baseUrl}${entry.href.path}#`;
			if (entry.href.hash != null) {
				href += entry.href.hashPreEncoded ? entry.href.hash : UrlUtil.encodeForHash(entry.href.hash);
			}
			if (entry.href.subhashes != null) {
				href += Renderer.utils.getLinkSubhashString(entry.href.subhashes);
			}
		} else if (entry.href.type === "external") {
			href = entry.href.url;
		}
		return href;
	};

	this._renderLink_getHoverString = function (entry) {
		if (!entry.href.hover || !this._isAddHandlers) return "";

		let procHash = entry.href.hover.hash
			? entry.href.hover.hashPreEncoded ? entry.href.hover.hash : UrlUtil.encodeForHash(entry.href.hover.hash)
			: entry.href.hashPreEncoded ? entry.href.hash : UrlUtil.encodeForHash(entry.href.hash);

		if (this._tagExportDict) {
			this._tagExportDict[procHash] = {
				page: entry.href.hover.page,
				source: entry.href.hover.source,
				hash: procHash,
			};
		}

		if (entry.href.hover.subhashes) {
			procHash += Renderer.utils.getLinkSubhashString(entry.href.hover.subhashes);
		}

		const pluginData = this._getPlugins("link_attributesHover")
			.map(plugin => plugin(entry, procHash))
			.filter(Boolean);
		const replacementAttributes = pluginData.map(it => it.attributesHoverReplace).filter(Boolean);
		if (replacementAttributes.length) return replacementAttributes.join(" ");

		return `onmouseover="Renderer.hover.pHandleLinkMouseOver(event, this)" onmouseleave="Renderer.hover.handleLinkMouseLeave(event, this)" onmousemove="Renderer.hover.handleLinkMouseMove(event, this)" data-vet-page="${entry.href.hover.page.qq()}" data-vet-source="${entry.href.hover.source.qq()}" data-vet-hash="${procHash.qq()}" ${entry.href.hover.preloadId != null ? `data-vet-preload-id="${`${entry.href.hover.preloadId}`.qq()}"` : ""} ${entry.href.hover.isFauxPage ? `data-vet-is-faux-page="true"` : ""} ${Renderer.hover.getPreventTouchString()}`;
	};

		this.render = function (entry, depth = 0) {
		const tempStack = [];
		this.recursiveRender(entry, tempStack, {depth});
		return tempStack.join("");
	};
};

Renderer.ENTRIES_WITH_ENUMERATED_TITLES = [
	{type: "section", key: "entries", depth: -1},
	{type: "entries", key: "entries", depthIncrement: 1},
	{type: "options", key: "entries"},
	{type: "inset", key: "entries", depth: 2},
	{type: "insetReadaloud", key: "entries", depth: 2},
	{type: "variant", key: "entries", depth: 2},
	{type: "variantInner", key: "entries", depth: 2},
	{type: "actions", key: "entries", depth: 2},
	{type: "flowBlock", key: "entries", depth: 2},
	{type: "optfeature", key: "entries", depthIncrement: 1},
	{type: "patron", key: "entries"},
];

Renderer.ENTRIES_WITH_ENUMERATED_TITLES_LOOKUP = Renderer.ENTRIES_WITH_ENUMERATED_TITLES.mergeMap(it => ({[it.type]: it}));

Renderer.ENTRIES_WITH_CHILDREN = [
	...Renderer.ENTRIES_WITH_ENUMERATED_TITLES,
	{type: "list", key: "items"},
	{type: "table", key: "rows"},
];

Renderer._INLINE_HEADER_TERMINATORS = new Set([".", ",", "!", "?", ";", ":", `"`]);

Renderer._STYLE_TAG_ID_TO_STYLE = {
	"small-caps": "small-caps",
	"small": "ve-small",
	"capitalize": "capitalize",
	"dnd-font": "dnd-font",
};

Renderer.get = () => {
	if (!Renderer.defaultRenderer) Renderer.defaultRenderer = new Renderer();
	return Renderer.defaultRenderer;
};

Renderer.applyProperties = function (entry, object) {
	const propSplit = Renderer.splitByPropertyInjectors(entry);
	const len = propSplit.length;
	if (len === 1) return entry;

	let textStack = "";

	for (let i = 0; i < len; ++i) {
		const s = propSplit[i];
		if (!s) continue;
		if (s.startsWith("{=")) {
			const [path, modifiers] = s.slice(2, -1).split("/");
			let fromProp = object[path];

			if (modifiers) {
				for (const modifier of modifiers) {
					switch (modifier) {
						case "a": 							fromProp = Renderer.applyProperties._leadingAn.has(fromProp[0].toLowerCase()) ? "an" : "a";
							break;

						case "l": fromProp = fromProp.toLowerCase(); break; 						case "t": fromProp = fromProp.toTitleCase(); break; 						case "u": fromProp = fromProp.toUpperCase(); break; 						case "v": fromProp = Parser.numberToVulgar(fromProp); break; 						case "r": fromProp = Math.round(fromProp); break; 						case "f": fromProp = Math.floor(fromProp); break; 						case "c": fromProp = Math.ceil(fromProp); break; 					}
				}
			}
			textStack += fromProp;
		} else textStack += s;
	}

	return textStack;
};
Renderer.applyProperties._leadingAn = new Set(["a", "e", "i", "o", "u"]);

Renderer.applyAllProperties = function (entries, object = null) {
	let lastObj = null;
	const handlers = {
		object: (obj) => {
			lastObj = obj;
			return obj;
		},
		string: (str) => Renderer.applyProperties(str, object || lastObj),
	};
	return MiscUtil.getWalker().walk(entries, handlers);
};

Renderer.attackTagToFull = function (tagStr) {
	function renderTag (tags) {
		return `${tags.includes("m") ? "Melee " : tags.includes("r") ? "Ranged " : tags.includes("g") ? "Magical " : tags.includes("a") ? "Area " : ""}${tags.includes("w") ? "Weapon " : tags.includes("s") ? "Spell " : ""}`;
	}

	const tagGroups = tagStr.toLowerCase().split(",").map(it => it.trim()).filter(it => it).map(it => it.split(""));
	if (tagGroups.length > 1) {
		const seen = new Set(tagGroups.last());
		for (let i = tagGroups.length - 2; i >= 0; --i) {
			tagGroups[i] = tagGroups[i].filter(it => {
				const out = !seen.has(it);
				seen.add(it);
				return out;
			});
		}
	}
	return `${tagGroups.map(it => renderTag(it)).join(" or ")}Attack:`;
};

Renderer.splitFirstSpace = function (string) {
	const firstIndex = string.indexOf(" ");
	return firstIndex === -1 ? [string, ""] : [string.substr(0, firstIndex), string.substr(firstIndex + 1)];
};

Renderer._splitByTagsBase = function (leadingCharacter) {
	return function (string) {
		let tagDepth = 0;
		let char, char2;
		const out = [];
		let curStr = "";
		let isLastOpen = false;

		const len = string.length;
		for (let i = 0; i < len; ++i) {
			char = string[i];
			char2 = string[i + 1];

			switch (char) {
				case "{":
					isLastOpen = true;
					if (char2 === leadingCharacter) {
						if (tagDepth++ > 0) {
							curStr += "{";
						} else {
							out.push(curStr.replace(/<VE_LEAD>/g, leadingCharacter));
							curStr = `{${leadingCharacter}`;
							++i;
						}
					} else curStr += "{";
					break;

				case "}":
					isLastOpen = false;
					curStr += "}";
					if (tagDepth !== 0 && --tagDepth === 0) {
						out.push(curStr.replace(/<VE_LEAD>/g, leadingCharacter));
						curStr = "";
					}
					break;

				case leadingCharacter: {
					if (!isLastOpen) curStr += "<VE_LEAD>";
					else curStr += leadingCharacter;
					break;
				}

				default: isLastOpen = false; curStr += char; break;
			}
		}

		if (curStr) out.push(curStr.replace(/<VE_LEAD>/g, leadingCharacter));

		return out;
	};
};

Renderer.splitByTags = Renderer._splitByTagsBase("@");
Renderer.splitByPropertyInjectors = Renderer._splitByTagsBase("=");

Renderer._splitByPipeBase = function (leadingCharacter) {
	return function (string) {
		let tagDepth = 0;
		let char, char2;
		const out = [];
		let curStr = "";

		const len = string.length;
		for (let i = 0; i < len; ++i) {
			char = string[i];
			char2 = string[i + 1];

			switch (char) {
				case "{":
					if (char2 === leadingCharacter) tagDepth++;
					curStr += "{";

					break;

				case "}":
					if (tagDepth) tagDepth--;
					curStr += "}";

					break;

				case "|": {
					if (tagDepth) curStr += "|";
					else {
						out.push(curStr);
						curStr = "";
					}
					break;
				}

				default: {
					curStr += char;
					break;
				}
			}
		}

		if (curStr) out.push(curStr);
		return out;
	};
};

Renderer.splitTagByPipe = Renderer._splitByPipeBase("@");

Renderer.getEntryDice = function (entry, name, opts = {}) {
	const toDisplay = Renderer.getEntryDiceDisplayText(entry);

	if (entry.rollable === true) return Renderer.getRollableEntryDice(entry, name, toDisplay, opts);
	else return toDisplay;
};

Renderer.getRollableEntryDice = function (
	entry,
	name,
	toDisplay,
	{
		isAddHandlers = true,
		pluginResults = null,
	} = {},
) {
	const toPack = MiscUtil.copyFast(entry);
	if (typeof toPack.toRoll !== "string") {
				toPack.toRoll = Renderer.legacyDiceToString(toPack.toRoll);
	}

	const handlerPart = isAddHandlers ? `onmousedown="event.preventDefault()" data-packed-dice='${JSON.stringify(toPack).qq()}'` : "";

	const rollableTitlePart = isAddHandlers ? Renderer.getEntryDiceTitle(toPack.subType) : null;
	const titlePart = isAddHandlers
		? `title="${[name, rollableTitlePart].filter(Boolean).join(". ").qq()}" ${name ? `data-roll-name="${name}"` : ""}`
		: name ? `title="${name.qq()}" data-roll-name="${name.qq()}"` : "";

	const additionalDataPart = (pluginResults || [])
		.filter(it => it.additionalData)
		.map(it => {
			return Object.entries(it.additionalData)
				.map(([dataKey, val]) => `${dataKey}='${typeof val === "object" ? JSON.stringify(val).qq() : `${val}`.qq()}'`)
				.join(" ");
		})
		.join(" ");

	toDisplay = (pluginResults || []).filter(it => it.toDisplay)[0]?.toDisplay ?? toDisplay;

	const ptRoll = Renderer.getRollableEntryDice._getPtRoll(toPack);

	return `<span class="roller render-roller" ${titlePart} ${handlerPart} ${additionalDataPart}>${toDisplay}</span>${ptRoll}`;
};

Renderer.getRollableEntryDice._getPtRoll = (toPack) => {
	if (!toPack.autoRoll) return "";

	const r = Renderer.dice.parseRandomise2(toPack.toRoll);
	return ` (<span data-rd-is-autodice-result="true">${r}</span>)`;
};

Renderer.getEntryDiceTitle = function (subType) {
	return `Click to roll. ${subType === "damage" ? "SHIFT to roll a critical hit, CTRL to half damage (rounding down)." : subType === "d20" ? "SHIFT to roll with advantage, CTRL to roll with disadvantage." : "SHIFT/CTRL to roll twice."}`;
};

Renderer.legacyDiceToString = function (array) {
	let stack = "";
	array.forEach(r => {
		stack += `${r.neg ? "-" : stack === "" ? "" : "+"}${r.number || 1}d${r.faces}${r.mod ? r.mod > 0 ? `+${r.mod}` : r.mod : ""}`;
	});
	return stack;
};

Renderer.getEntryDiceDisplayText = function (entry) {
	if (entry.displayText) return entry.displayText;
	return Renderer._getEntryDiceDisplayText_getDiceAsStr(entry);
};

Renderer._getEntryDiceDisplayText_getDiceAsStr = function (entry) {
	if (entry.successThresh != null) return `${entry.successThresh} percent`;
	if (typeof entry.toRoll === "string") return entry.toRoll;
		return Renderer.legacyDiceToString(entry.toRoll);
};

Renderer.parseScaleDice = function (tag, text) {
		const [baseRoll, progression, addPerProgress, renderMode] = Renderer.splitTagByPipe(text);
	const progressionParse = MiscUtil.parseNumberRange(progression, 1, 9);
	const baseLevel = Math.min(...progressionParse);
	const options = {};
	const isMultableDice = /^(\d+)d(\d+)$/i.exec(addPerProgress);

	const getSpacing = () => {
		let diff = null;
		const sorted = [...progressionParse].sort(SortUtil.ascSort);
		for (let i = 1; i < sorted.length; ++i) {
			const prev = sorted[i - 1];
			const curr = sorted[i];
			if (diff == null) diff = curr - prev;
			else if (curr - prev !== diff) return null;
		}
		return diff;
	};

	const spacing = getSpacing();
	progressionParse.forEach(k => {
		const offset = k - baseLevel;
		if (isMultableDice && spacing != null) {
			options[k] = offset ? `${Number(isMultableDice[1]) * (offset / spacing)}d${isMultableDice[2]}` : "";
		} else {
			options[k] = offset ? [...new Array(Math.floor(offset / spacing))].map(_ => addPerProgress).join("+") : "";
		}
	});

	const out = {
		type: "dice",
		rollable: true,
		toRoll: baseRoll,
		displayText: addPerProgress,
		prompt: {
			entry: renderMode === "psi" ? "Spend Psi Points..." : "Cast at...",
			mode: renderMode,
			options,
		},
	};
	if (tag === "@scaledamage") out.subType = "damage";

	return out;
};

Renderer.getAbilityData = function (abArr, {isOnlyShort, isCurrentLineage} = {}) {
	if (isOnlyShort && isCurrentLineage) return new Renderer._AbilityData({asTextShort: "Lineage (choose)"});

	const outerStack = (abArr || [null]).map(it => Renderer.getAbilityData._doRenderOuter(it));
	if (outerStack.length <= 1) return outerStack[0];
	return new Renderer._AbilityData({
		asText: `Choose one of: ${outerStack.map((it, i) => `(${Parser.ALPHABET[i].toLowerCase()}) ${it.asText}`).join(" ")}`,
		asTextShort: `${outerStack.map((it, i) => `(${Parser.ALPHABET[i].toLowerCase()}) ${it.asTextShort}`).join(" ")}`,
		asCollection: [...new Set(outerStack.map(it => it.asCollection).flat())],
		areNegative: [...new Set(outerStack.map(it => it.areNegative).flat())],
	});
};

Renderer.getAbilityData._doRenderOuter = function (abObj) {
	const mainAbs = [];
	const asCollection = [];
	const areNegative = [];
	const toConvertToText = [];
	const toConvertToShortText = [];

	if (abObj != null) {
		handleAllAbilities(abObj);
		handleAbilitiesChoose();
		return new Renderer._AbilityData({
			asText: toConvertToText.join("; "),
			asTextShort: toConvertToShortText.join("; "),
			asCollection: asCollection,
			areNegative: areNegative,
		});
	}

	return new Renderer._AbilityData();

	function handleAllAbilities (abObj, targetList) {
		MiscUtil.copyFast(Parser.ABIL_ABVS)
			.sort((a, b) => SortUtil.ascSort(abObj[b] || 0, abObj[a] || 0))
			.forEach(shortLabel => handleAbility(abObj, shortLabel, targetList));
	}

	function handleAbility (abObj, shortLabel, optToConvertToTextStorage) {
		if (abObj[shortLabel] != null) {
			const isNegMod = abObj[shortLabel] < 0;
			const toAdd = `${shortLabel.uppercaseFirst()} ${(isNegMod ? "" : "+")}${abObj[shortLabel]}`;

			if (optToConvertToTextStorage) {
				optToConvertToTextStorage.push(toAdd);
			} else {
				toConvertToText.push(toAdd);
				toConvertToShortText.push(toAdd);
			}

			mainAbs.push(shortLabel.uppercaseFirst());
			asCollection.push(shortLabel);
			if (isNegMod) areNegative.push(shortLabel);
		}
	}

	function handleAbilitiesChoose () {
		if (abObj.choose != null) {
			const ch = abObj.choose;
			let outStack = "";
			if (ch.weighted) {
				const w = ch.weighted;
				const froms = w.from.map(it => it.uppercaseFirst());
				const isAny = froms.length === 6;
				const isAllEqual = w.weights.unique().length === 1;
				let cntProcessed = 0;

				const weightsIncrease = w.weights.filter(it => it >= 0).sort(SortUtil.ascSort).reverse();
				const weightsReduce = w.weights.filter(it => it < 0).map(it => -it).sort(SortUtil.ascSort);

				const areIncreaseShort = [];
				const areIncrease = isAny && isAllEqual && w.weights.length > 1 && w.weights[0] >= 0
					? (() => {
						weightsIncrease.forEach(it => areIncreaseShort.push(`+${it}`));
						return [`${cntProcessed ? "choose " : ""}${Parser.numberToText(w.weights.length)} different +${weightsIncrease[0]}`];
					})()
					: weightsIncrease.map(it => {
						areIncreaseShort.push(`+${it}`);
						if (isAny) return `${cntProcessed ? "choose " : ""}any ${cntProcessed++ ? `other ` : ""}+${it}`;
						return `one ${cntProcessed++ ? `other ` : ""}ability to increase by ${it}`;
					});

				const areReduceShort = [];
				const areReduce = isAny && isAllEqual && w.weights.length > 1 && w.weights[0] < 0
					? (() => {
						weightsReduce.forEach(it => areReduceShort.push(`-${it}`));
						return [`${cntProcessed ? "choose " : ""}${Parser.numberToText(w.weights.length)} different -${weightsReduce[0]}`];
					})()
					: weightsReduce.map(it => {
						areReduceShort.push(`-${it}`);
						if (isAny) return `${cntProcessed ? "choose " : ""}any ${cntProcessed++ ? `other ` : ""}-${it}`;
						return `one ${cntProcessed++ ? `other ` : ""}ability to decrease by ${it}`;
					});

				const startText = isAny
					? `Choose `
					: `From ${froms.joinConjunct(", ", " and ")} choose `;

				const ptAreaIncrease = isAny
					? areIncrease.concat(areReduce).join("; ")
					: areIncrease.concat(areReduce).joinConjunct(", ", isAny ? "; " : " and ");
				toConvertToText.push(`${startText}${ptAreaIncrease}`);
				toConvertToShortText.push(`${isAny ? "Any combination " : ""}${areIncreaseShort.concat(areReduceShort).join("/")}${isAny ? "" : ` from ${froms.join("/")}`}`);
			} else {
				const allAbilities = ch.from.length === 6;
				const allAbilitiesWithParent = isAllAbilitiesWithParent(ch);
				let amount = ch.amount === undefined ? 1 : ch.amount;
				amount = (amount < 0 ? "" : "+") + amount;
				if (allAbilities) {
					outStack += "any ";
				} else if (allAbilitiesWithParent) {
					outStack += "any other ";
				}
				if (ch.count != null && ch.count > 1) {
					outStack += `${Parser.numberToText(ch.count)} `;
				}
				if (allAbilities || allAbilitiesWithParent) {
					outStack += `${ch.count > 1 ? "unique " : ""}${amount}`;
				} else {
					for (let j = 0; j < ch.from.length; ++j) {
						let suffix = "";
						if (ch.from.length > 1) {
							if (j === ch.from.length - 2) {
								suffix = " or ";
							} else if (j < ch.from.length - 2) {
								suffix = ", ";
							}
						}
						let thsAmount = ` ${amount}`;
						if (ch.from.length > 1) {
							if (j !== ch.from.length - 1) {
								thsAmount = "";
							}
						}
						outStack += ch.from[j].uppercaseFirst() + thsAmount + suffix;
					}
				}
			}

			if (outStack.trim()) {
				toConvertToText.push(`Choose ${outStack}`);
				toConvertToShortText.push(outStack.uppercaseFirst());
			}
		}
	}

	function isAllAbilitiesWithParent (chooseAbs) {
		const tempAbilities = [];
		for (let i = 0; i < mainAbs.length; ++i) {
			tempAbilities.push(mainAbs[i].toLowerCase());
		}
		for (let i = 0; i < chooseAbs.from.length; ++i) {
			const ab = chooseAbs.from[i].toLowerCase();
			if (!tempAbilities.includes(ab)) tempAbilities.push(ab);
			if (!asCollection.includes(ab.toLowerCase)) asCollection.push(ab.toLowerCase());
		}
		return tempAbilities.length === 6;
	}
};

Renderer._AbilityData = function ({asText, asTextShort, asCollection, areNegative} = {}) {
	this.asText = asText || "";
	this.asTextShort = asTextShort || "";
	this.asCollection = asCollection || [];
	this.areNegative = areNegative || [];
};

Renderer.getFilterSubhashes = function (filters, namespace = null) {
	let customHash = null;

	const subhashes = filters.map(f => {
		const [fName, fVals, fMeta, fOpts] = f.split("=").map(s => s.trim());
		const isBoxData = fName.startsWith("fb");
		const key = isBoxData ? `${fName}${namespace ? `.${namespace}` : ""}` : `flst${namespace ? `.${namespace}` : ""}${UrlUtil.encodeForHash(fName)}`;

		let value;
				if (isBoxData) {
			return {
				key,
				value: fVals,
				preEncoded: true,
			};
		} else if (fName === "search") {
						return {
				key: VeCt.FILTER_BOX_SUB_HASH_SEARCH_PREFIX,
				value: UrlUtil.encodeForHash(fVals),
				preEncoded: true,
			};
		} else if (fName === "hash") {
			customHash = fVals;
			return null;
		} else if (fVals.startsWith("[") && fVals.endsWith("]")) { 			const [min, max] = fVals.substring(1, fVals.length - 1).split(";").map(it => it.trim());
			if (max == null) { 				value = [
					`min=${min}`,
					`max=${min}`,
				].join(HASH_SUB_LIST_SEP);
			} else {
				value = [
					min ? `min=${min}` : "",
					max ? `max=${max}` : "",
				].filter(Boolean).join(HASH_SUB_LIST_SEP);
			}
		} else if (fVals.startsWith("::") && fVals.endsWith("::")) { 			value = fVals.substring(2, fVals.length - 2).split(";")
				.map(it => it.trim())
				.map(it => {
					if (it.startsWith("!")) return `${UrlUtil.encodeForHash(it.slice(1))}=${UrlUtil.mini.compress(false)}`;
					return `${UrlUtil.encodeForHash(it)}=${UrlUtil.mini.compress(true)}`;
				})
				.join(HASH_SUB_LIST_SEP);
		} else {
			value = fVals.split(";")
				.map(s => s.trim())
				.filter(Boolean)
				.map(s => {
					if (s.startsWith("!")) return `${UrlUtil.encodeForHash(s.slice(1))}=2`;
					return `${UrlUtil.encodeForHash(s)}=1`;
				})
				.join(HASH_SUB_LIST_SEP);
		}

		const out = [{
			key,
			value,
			preEncoded: true,
		}];

		if (fMeta) {
			out.push({
				key: `flmt${UrlUtil.encodeForHash(fName)}`,
				value: fMeta,
				preEncoded: true,
			});
		}

		if (fOpts) {
			out.push({
				key: `flop${UrlUtil.encodeForHash(fName)}`,
				value: fOpts,
				preEncoded: true,
			});
		}

		return out;
	}).flat().filter(Boolean);

	return {
		customHash,
		subhashes,
	};
};

Renderer._cache = {
	inlineStatblock: {},

	async pRunFromEle (ele) {
		const cached = Renderer._cache[ele.dataset.rdCache][ele.dataset.rdCacheId];
		await cached.pFn(ele);
	},
};

Renderer.utils = {
	getBorderTr: (optText = null) => {
		return `<tr><th class="border" colspan="6">${optText || ""}</th></tr>`;
	},

	getDividerTr: () => {
		return `<tr><td class="divider" colspan="6"><div></div></td></tr>`;
	},

	getSourceSubText (it) {
		return it.sourceSub ? ` \u2014 ${it.sourceSub}` : "";
	},

		getNameTr: (it, opts) => {
		opts = opts || {};

		let dataPart = "";
		let pageLinkPart;
		if (opts.page) {
			const hash = UrlUtil.URL_TO_HASH_BUILDER[opts.page](it);
			dataPart = `data-page="${opts.page}" data-source="${it.source.escapeQuotes()}" data-hash="${hash.escapeQuotes()}" ${opts.extensionData != null ? `data-extension='${JSON.stringify(opts.extensionData).escapeQuotes()}` : ""}'`;
			pageLinkPart = SourceUtil.getAdventureBookSourceHref(it.source, it.page);

						if (opts.isEmbeddedEntity) ExtensionUtil.addEmbeddedToCache(opts.page, it.source, hash, it);
		}

		const tagPartSourceStart = `<${pageLinkPart ? `a href="${Renderer.get().baseUrl}${pageLinkPart}"` : "span"}`;
		const tagPartSourceEnd = `</${pageLinkPart ? "a" : "span"}>`;

		const ptBrewSourceLink = Renderer.utils._getNameTr_getPtPrereleaseBrewSourceLink({ent: it, brewUtil: PrereleaseUtil})
			|| Renderer.utils._getNameTr_getPtPrereleaseBrewSourceLink({ent: it, brewUtil: BrewUtil2});

				const $ele = $$`<tr>
			<th class="rnd-name ${opts.extraThClasses ? opts.extraThClasses.join(" ") : ""}" colspan="6" ${dataPart}>
				<div class="name-inner">
					<div class="ve-flex-v-center">
						<h1 class="stats-name copyable m-0" onmousedown="event.preventDefault()" onclick="Renderer.utils._pHandleNameClick(this)">${opts.prefix || ""}${it._displayName || it.name}${opts.suffix || ""}</h1>
						${opts.controlRhs || ""}
						${!IS_VTT && ExtensionUtil.ACTIVE && opts.page ? Renderer.utils.getBtnSendToFoundryHtml() : ""}
					</div>
					<div class="stats-source ve-flex-v-baseline">
						${tagPartSourceStart} class="help-subtle stats-source-abbreviation ${it.source ? `${Parser.sourceJsonToColor(it.source)}" title="${Parser.sourceJsonToFull(it.source)}${Renderer.utils.getSourceSubText(it)}` : ""}" ${Parser.sourceJsonToStyle(it.source)}>${it.source ? Parser.sourceJsonToAbv(it.source) : ""}${tagPartSourceEnd}

						${Renderer.utils.isDisplayPage(it.page) ? ` ${tagPartSourceStart} class="rd__stats-name-page ml-1" title="Page ${it.page}">p${it.page}${tagPartSourceEnd}` : ""}

						${ptBrewSourceLink}
					</div>
				</div>
			</th>
		</tr>`;

		if (opts.asJquery) return $ele;
		else return $ele[0].outerHTML;
	},

	_getNameTr_getPtPrereleaseBrewSourceLink ({ent, brewUtil}) {
		if (!brewUtil.hasSourceJson(ent.source) || !brewUtil.sourceJsonToSource(ent.source)?.url) return "";

		return `<a href="${brewUtil.sourceJsonToSource(ent.source).url}" title="View ${brewUtil.DISPLAY_NAME.toTitleCase()} Source" class="ve-self-flex-center ml-2 ve-muted rd__stats-name-brew-link" target="_blank" rel="noopener noreferrer"><span class="	glyphicon glyphicon-share"></span></a>`;
	},

	getBtnSendToFoundryHtml ({isMb = true} = {}) {
		return `<button title="Send to Foundry (SHIFT for Temporary Import)" class="btn btn-xs btn-default btn-stats-name mx-2 ${isMb ? "mb-2" : ""} ve-self-flex-end" onclick="ExtensionUtil.pDoSendStats(event, this)" draggable="true" ondragstart="ExtensionUtil.doDragStart(event, this)"><span class="glyphicon glyphicon-send"></span></button>`;
	},

	isDisplayPage (page) { return page != null && ((!isNaN(page) && page > 0) || isNaN(page)); },

	getExcludedTr ({entity, dataProp, page, isExcluded}) {
		const excludedHtml = Renderer.utils.getExcludedHtml({entity, dataProp, page, isExcluded});
		if (!excludedHtml) return "";
		return `<tr><td colspan="6" class="pt-3">${excludedHtml}</td></tr>`;
	},

	getExcludedHtml ({entity, dataProp, page, isExcluded}) {
		if (isExcluded != null && !isExcluded) return "";
		if (isExcluded == null) {
			if (!ExcludeUtil.isInitialised) return "";
			if (page && !UrlUtil.URL_TO_HASH_BUILDER[page]) return "";
			const hash = page ? UrlUtil.URL_TO_HASH_BUILDER[page](entity) : UrlUtil.autoEncodeHash(entity);
			isExcluded = isExcluded
				|| dataProp === "item" ? Renderer.item.isExcluded(entity, {hash}) : ExcludeUtil.isExcluded(hash, dataProp, entity.source);
		}
		return isExcluded ? `<div class="text-center text-danger"><b><i>Warning: This content has been <a href="blocklist.html">blocklisted</a>.</i></b></div>` : "";
	},

	getSourceAndPageTrHtml (it, {tag, fnUnpackUid} = {}) {
		const html = Renderer.utils.getSourceAndPageHtml(it, {tag, fnUnpackUid});
		return html ? `<b>Source:</b> ${html}` : "";
	},

	_getAltSourceHtmlOrText (it, prop, introText, isText) {
		if (!it[prop] || !it[prop].length) return "";

		return `${introText} ${it[prop].map(as => {
			if (as.entry) return (isText ? Renderer.stripTags : Renderer.get().render)(as.entry);
			return `${isText ? "" : `<i class="help-subtle" title="${Parser.sourceJsonToFull(as.source).qq()}">`}${Parser.sourceJsonToAbv(as.source)}${isText ? "" : `</i>`}${Renderer.utils.isDisplayPage(as.page) ? `, page ${as.page}` : ""}`;
		}).join("; ")}`;
	},

	_getReprintedAsHtmlOrText (ent, {isText, tag, fnUnpackUid} = {}) {
		if (!ent.reprintedAs) return "";
		if (!tag || !fnUnpackUid) return "";

		const ptReprinted = ent.reprintedAs
			.map(it => {
				const uid = it.uid ?? it;
				const tag_ = it.tag ?? tag;

				const {name, source, displayText} = fnUnpackUid(uid);

				if (isText) {
					return `${Renderer.stripTags(displayText || name)} in ${Parser.sourceJsonToAbv(source)}`;
				}

				const asTag = `{@${tag_} ${name}|${source}${displayText ? `|${displayText}` : ""}}`;

				return `${Renderer.get().render(asTag)} in <i class="help-subtle" title="${Parser.sourceJsonToFull(source).qq()}">${Parser.sourceJsonToAbv(source)}</i>`;
			})
			.join("; ");

		return `Reprinted as ${ptReprinted}`;
	},

	getSourceAndPageHtml (it, {tag, fnUnpackUid} = {}) { return this._getSourceAndPageHtmlOrText(it, {tag, fnUnpackUid}); },
	getSourceAndPageText (it, {tag, fnUnpackUid} = {}) { return this._getSourceAndPageHtmlOrText(it, {isText: true, tag, fnUnpackUid}); },

	_getSourceAndPageHtmlOrText (it, {isText, tag, fnUnpackUid} = {}) {
		const sourceSub = Renderer.utils.getSourceSubText(it);
		const baseText = `${isText ? `` : `<i title="${Parser.sourceJsonToFull(it.source)}${sourceSub}">`}${Parser.sourceJsonToAbv(it.source)}${sourceSub}${isText ? "" : `</i>`}${Renderer.utils.isDisplayPage(it.page) ? `, page ${it.page}` : ""}`;
		const reprintedAsText = Renderer.utils._getReprintedAsHtmlOrText(it, {isText, tag, fnUnpackUid});
		const addSourceText = Renderer.utils._getAltSourceHtmlOrText(it, "additionalSources", "Additional information from", isText);
		const otherSourceText = Renderer.utils._getAltSourceHtmlOrText(it, "otherSources", "Also found in", isText);
		const externalSourceText = Renderer.utils._getAltSourceHtmlOrText(it, "externalSources", "External sources:", isText);

		const srdText = it.srd ? `${isText ? "" : `the <span title="Systems Reference Document">`}SRD${isText ? "" : `</span>`}${typeof it.srd === "string" ? ` (as &quot;${it.srd}&quot;)` : ""}` : "";
		const basicRulesText = it.basicRules ? `the Basic Rules${typeof it.basicRules === "string" ? ` (as &quot;${it.basicRules}&quot;)` : ""}` : "";
		const srdAndBasicRulesText = (srdText || basicRulesText) ? `Available in ${[srdText, basicRulesText].filter(it => it).join(" and ")}` : "";

		return `${[baseText, addSourceText, reprintedAsText, otherSourceText, srdAndBasicRulesText, externalSourceText].filter(it => it).join(". ")}${baseText && (addSourceText || otherSourceText || srdAndBasicRulesText || externalSourceText) ? "." : ""}`;
	},

	async _pHandleNameClick (ele) {
		await MiscUtil.pCopyTextToClipboard($(ele).text());
		JqueryUtil.showCopiedEffect($(ele));
	},

	getPageTr (it, {tag, fnUnpackUid} = {}) {
		return `<tr><td colspan=6>${Renderer.utils.getSourceAndPageTrHtml(it, {tag, fnUnpackUid})}</td></tr>`;
	},

	getAbilityRoller (statblock, ability) {
		if (statblock[ability] == null) return "\u2014";
		return Renderer.get().render(`{@ability ${ability} ${statblock[ability]}}`);
	},

	getEmbeddedDataHeader (name, style, {isCollapsed = false} = {}) {
		return `<table class="rd__b-special rd__b-data ${style ? `rd__b-data--${style}` : ""}">
		<thead><tr><th class="rd__data-embed-header" colspan="6" data-rd-data-embed-header="true"><span class="rd__data-embed-name ${isCollapsed ? "" : `ve-hidden`}">${name}</span><span class="rd__data-embed-toggle">[${isCollapsed ? "+" : "\u2013"}]</span></th></tr></thead><tbody class="${isCollapsed ? `ve-hidden` : ""}" data-rd-embedded-data-render-target="true">`;
	},

	getEmbeddedDataFooter () {
		return `</tbody></table>`;
	},

	TabButton: function ({label, fnChange, fnPopulate, isVisible}) {
		this.label = label;
		this.fnChange = fnChange;
		this.fnPopulate = fnPopulate;
		this.isVisible = isVisible;
	},

	_tabs: {},
	_curTab: null,
	_tabsPreferredLabel: null,
	bindTabButtons ({tabButtons, tabLabelReference, $wrpTabs, $pgContent}) {
		Renderer.utils._tabs = {};
		Renderer.utils._curTab = null;

		$wrpTabs.find(`.stat-tab-gen`).remove();

		tabButtons.forEach((tb, i) => {
			tb.ix = i;

			tb.$t = $(`<button class="ui-tab__btn-tab-head btn btn-default stat-tab-gen">${tb.label}</button>`)
				.click(() => tb.fnActivateTab({isUserInput: true}));

			tb.fnActivateTab = ({isUserInput = false} = {}) => {
				const curTab = Renderer.utils._curTab;
				const tabs = Renderer.utils._tabs;

				if (!curTab || curTab.label !== tb.label) {
					if (curTab) curTab.$t.removeClass(`ui-tab__btn-tab-head--active`);
					Renderer.utils._curTab = tb;
					tb.$t.addClass(`ui-tab__btn-tab-head--active`);
					if (curTab) tabs[curTab.label].$content = $pgContent.children().detach();

					tabs[tb.label] = tb;
					if (!tabs[tb.label].$content && tb.fnPopulate) tb.fnPopulate();
					else $pgContent.append(tabs[tb.label].$content);
					if (tb.fnChange) tb.fnChange();
				}

								if (isUserInput) Renderer.utils._tabsPreferredLabel = tb.label;
			};
		});

				if (tabButtons.length !== 1) tabButtons.slice().reverse().forEach(tb => $wrpTabs.prepend(tb.$t));

				if (!Renderer.utils._tabsPreferredLabel) return tabButtons[0].fnActivateTab();

				const tabButton = tabButtons.find(tb => tb.label === Renderer.utils._tabsPreferredLabel);
		if (tabButton) return tabButton.fnActivateTab();

						const ixDesired = tabLabelReference.indexOf(Renderer.utils._tabsPreferredLabel);
		if (!~ixDesired) return tabButtons[0].fnActivateTab(); 
		const ixsAvailableMetas = tabButtons
			.map(tb => {
				const ixMapped = tabLabelReference.indexOf(tb.label);
				if (!~ixMapped) return null;
				return {
					ixMapped,
					label: tb.label,
				};
			})
			.filter(Boolean);
		if (!ixsAvailableMetas.length) return tabButtons[0].fnActivateTab(); 
				const ixMetaHigher = ixsAvailableMetas.find(({ixMapped}) => ixMapped > ixDesired);
		if (ixMetaHigher != null) return (tabButtons.find(it => it.label === ixMetaHigher.label) || tabButtons[0]).fnActivateTab();

				const ixMetaMax = ixsAvailableMetas.last();
		(tabButtons.find(it => it.label === ixMetaMax.label) || tabButtons[0]).fnActivateTab();
	},

	_pronounceButtonsBound: false,
	bindPronounceButtons () {
		if (Renderer.utils._pronounceButtonsBound) return;
		Renderer.utils._pronounceButtonsBound = true;
		$(`body`).on("click", ".btn-name-pronounce", function () {
			const audio = $(this).find(`.name-pronounce`)[0];
			audio.currentTime = 0;
			audio.play();
		});
	},

	async pHasFluffText (entity, prop) {
		return entity.hasFluff || ((await Renderer.utils.pGetPredefinedFluff(entity, prop))?.entries?.length || 0) > 0;
	},

	async pHasFluffImages (entity, prop) {
		return entity.hasFluffImages || (((await Renderer.utils.pGetPredefinedFluff(entity, prop))?.images?.length || 0) > 0);
	},

		async pGetPredefinedFluff (entry, prop) {
		if (!entry.fluff) return null;

		const mappedProp = `_${prop}`;
		const mappedPropAppend = `_append${prop.uppercaseFirst()}`;
		const fluff = {};

		const assignPropsIfExist = (fromObj, ...props) => {
			props.forEach(prop => {
				if (fromObj[prop]) fluff[prop] = fromObj[prop];
			});
		};

		assignPropsIfExist(entry.fluff, "name", "type", "entries", "images");

		if (entry.fluff[mappedProp]) {
			const fromList = [
				...((await PrereleaseUtil.pGetBrewProcessed())[prop] || []),
				...((await BrewUtil2.pGetBrewProcessed())[prop] || []),
			]
				.find(it =>
					it.name === entry.fluff[mappedProp].name
					&& it.source === entry.fluff[mappedProp].source,
				);
			if (fromList) {
				assignPropsIfExist(fromList, "name", "type", "entries", "images");
			}
		}

		if (entry.fluff[mappedPropAppend]) {
			const fromList = [
				...((await PrereleaseUtil.pGetBrewProcessed())[prop] || []),
				...((await BrewUtil2.pGetBrewProcessed())[prop] || []),
			]
				.find(it =>
					it.name === entry.fluff[mappedPropAppend].name
					&& it.source === entry.fluff[mappedPropAppend].source,
				);
			if (fromList) {
				if (fromList.entries) {
					fluff.entries = MiscUtil.copyFast(fluff.entries || []);
					fluff.entries.push(...MiscUtil.copyFast(fromList.entries));
				}
				if (fromList.images) {
					fluff.images = MiscUtil.copyFast(fluff.images || []);
					fluff.images.push(...MiscUtil.copyFast(fromList.images));
				}
			}
		}

		return fluff;
	},

	async pGetFluff ({entity, pFnPostProcess, fnGetFluffData, fluffUrl, fluffBaseUrl, fluffProp} = {}) {
		let predefinedFluff = await Renderer.utils.pGetPredefinedFluff(entity, fluffProp);
		if (predefinedFluff) {
			if (pFnPostProcess) predefinedFluff = await pFnPostProcess(predefinedFluff);
			return predefinedFluff;
		}
		if (!fnGetFluffData && !fluffBaseUrl && !fluffUrl) return null;

		const fluffIndex = fluffBaseUrl ? await DataUtil.loadJSON(`${Renderer.get().baseUrl}${fluffBaseUrl}fluff-index.json`) : null;
		if (fluffIndex && !fluffIndex[entity.source]) return null;

		const data = fnGetFluffData ? await fnGetFluffData() : fluffIndex && fluffIndex[entity.source]
			? await DataUtil.loadJSON(`${Renderer.get().baseUrl}${fluffBaseUrl}${fluffIndex[entity.source]}`)
			: await DataUtil.loadJSON(`${Renderer.get().baseUrl}${fluffUrl}`);
		if (!data) return null;

		let fluff = (data[fluffProp] || []).find(it => it.name === entity.name && it.source === entity.source);
		if (!fluff && entity._versionBase_name && entity._versionBase_source) fluff = (data[fluffProp] || []).find(it => it.name === entity._versionBase_name && it.source === entity._versionBase_source);
		if (!fluff) return null;

				if (pFnPostProcess) fluff = await pFnPostProcess(fluff);
		return fluff;
	},

	_TITLE_SKIP_TYPES: new Set(["entries", "section"]),
		async pBuildFluffTab ({isImageTab, $content, entity, $headerControls, pFnGetFluff} = {}) {
		$content.append(Renderer.utils.getBorderTr());
		$content.append(Renderer.utils.getNameTr(entity, {controlRhs: $headerControls, asJquery: true}));
		const $td = $(`<td colspan="6" class="text"></td>`);
		$$`<tr class="text">${$td}</tr>`.appendTo($content);
		$content.append(Renderer.utils.getBorderTr());

		const fluff = MiscUtil.copyFast((await pFnGetFluff(entity)) || {});
		fluff.entries = fluff.entries || [Renderer.utils.HTML_NO_INFO];
		fluff.images = fluff.images || [Renderer.utils.HTML_NO_IMAGES];

		$td.fastSetHtml(Renderer.utils.getFluffTabContent({entity, fluff, isImageTab}));
	},

	getFluffTabContent ({entity, fluff, isImageTab = false}) {
		Renderer.get().setFirstSection(true);
		return (fluff[isImageTab ? "images" : "entries"] || []).map((ent, i) => {
			if (isImageTab) return Renderer.get().render(ent);

									if (i === 0 && ent.name && entity.name && (Renderer.utils._TITLE_SKIP_TYPES).has(ent.type)) {
				const entryLowName = ent.name.toLowerCase().trim();
				const entityLowName = entity.name.toLowerCase().trim();

				if (entryLowName.includes(entityLowName) || entityLowName.includes(entryLowName)) {
					const cpy = MiscUtil.copyFast(ent);
					delete cpy.name;
					return Renderer.get().render(cpy);
				} else return Renderer.get().render(ent);
			} else {
				if (typeof ent === "string") return `<p>${Renderer.get().render(ent)}</p>`;
				else return Renderer.get().render(ent);
			}
		}).join("");
	},

	HTML_NO_INFO: "<i>No information available.</i>",
	HTML_NO_IMAGES: "<i>No images available.</i>",

	prerequisite: class {
		static _WEIGHTS = [
			"level",
			"pact",
			"patron",
			"spell",
			"race",
			"alignment",
			"ability",
			"proficiency",
			"spellcasting",
			"spellcasting2020",
			"psionics",
			"feature",
			"feat",
			"background",
			"item",
			"itemType",
			"itemProperty",
			"campaign",
			"group",
			"other",
			"otherSummary",
			undefined,
		]
			.mergeMap((k, i) => ({[k]: i}));

		static _getShortClassName (className) {
						const ixFirstVowel = /[aeiou]/.exec(className).index;
			const start = className.slice(0, ixFirstVowel + 1);
			let end = className.slice(ixFirstVowel + 1);
			end = end.replace(/[aeiou]/g, "");
			return `${start}${end}`.toTitleCase();
		}

		static getHtml (prerequisites, {isListMode = false, blocklistKeys = new Set(), isTextOnly = false, isSkipPrefix = false} = {}) {
			if (!prerequisites?.length) return isListMode ? "\u2014" : "";

			const prereqsShared = prerequisites.length === 1
				? {}
				: Object.entries(
					prerequisites
						.slice(1)
						.reduce((a, b) => CollectionUtil.objectIntersect(a, b), prerequisites[0]),
				)
					.filter(([k, v]) => prerequisites.every(pre => CollectionUtil.deepEquals(pre[k], v)))
					.mergeMap(([k, v]) => ({[k]: v}));

			const shared = Object.keys(prereqsShared).length
				? this.getHtml([prereqsShared], {isListMode, blocklistKeys, isTextOnly, isSkipPrefix: true})
				: null;

			let cntPrerequisites = 0;
			let hasNote = false;
			const listOfChoices = prerequisites
				.map(pr => {
										const ptNote = !isListMode && pr.note ? Renderer.get().render(pr.note) : null;
					if (ptNote) {
						hasNote = true;
					}

					const prereqsToJoin = Object.entries(pr)
						.filter(([k]) => !prereqsShared[k])
						.sort(([kA], [kB]) => this._WEIGHTS[kA] - this._WEIGHTS[kB])
						.map(([k, v]) => {
							if (k === "note" || blocklistKeys.has(k)) return false;

							cntPrerequisites += 1;

							switch (k) {
								case "level": return this._getHtml_level({v, isListMode, isTextOnly});
								case "pact": return this._getHtml_pact({v, isListMode, isTextOnly});
								case "patron": return this._getHtml_patron({v, isListMode, isTextOnly});
								case "spell": return this._getHtml_spell({v, isListMode, isTextOnly});
								case "feat": return this._getHtml_feat({v, isListMode, isTextOnly});
								case "feature": return this._getHtml_feature({v, isListMode, isTextOnly});
								case "item": return this._getHtml_item({v, isListMode, isTextOnly});
								case "itemType": return this._getHtml_itemType({v, isListMode, isTextOnly});
								case "itemProperty": return this._getHtml_itemProperty({v, isListMode, isTextOnly});
								case "otherSummary": return this._getHtml_otherSummary({v, isListMode, isTextOnly});
								case "other": return this._getHtml_other({v, isListMode, isTextOnly});
								case "race": return this._getHtml_race({v, isListMode, isTextOnly});
								case "background": return this._getHtml_background({v, isListMode, isTextOnly});
								case "ability": return this._getHtml_ability({v, isListMode, isTextOnly});
								case "proficiency": return this._getHtml_proficiency({v, isListMode, isTextOnly});
								case "spellcasting": return this._getHtml_spellcasting({v, isListMode, isTextOnly});
								case "spellcasting2020": return this._getHtml_spellcasting2020({v, isListMode, isTextOnly});
								case "psionics": return this._getHtml_psionics({v, isListMode, isTextOnly});
								case "alignment": return this._getHtml_alignment({v, isListMode, isTextOnly});
								case "campaign": return this._getHtml_campaign({v, isListMode, isTextOnly});
								case "group": return this._getHtml_group({v, isListMode, isTextOnly});
								default: throw new Error(`Unhandled key: ${k}`);
							}
						})
						.filter(Boolean);

					const ptPrereqs = prereqsToJoin
						.join(prereqsToJoin.some(it => / or /.test(it)) ? "; " : ", ");

					return [ptPrereqs, ptNote]
						.filter(Boolean)
						.join(". ");
				})
				.filter(Boolean);

			if (!listOfChoices.length && !shared) return isListMode ? "\u2014" : "";
			if (isListMode) return [shared, listOfChoices.join("/")].filter(Boolean).join(" + ");

			const sharedSuffix = MiscUtil.findCommonSuffix(listOfChoices, {isRespectWordBoundaries: true});
			const listOfChoicesTrimmed = sharedSuffix
				? listOfChoices.map(it => it.slice(0, -sharedSuffix.length))
				: listOfChoices;

			const joinedChoices = (
				hasNote
					? listOfChoicesTrimmed.join(" Or, ")
					: listOfChoicesTrimmed.joinConjunct(listOfChoicesTrimmed.some(it => / or /.test(it)) ? "; " : ", ", " or ")
			) + sharedSuffix;
			return `${isSkipPrefix ? "" : `<b>Prerequisite${cntPrerequisites === 1 ? "" : "s"}:</b> `}${[shared, joinedChoices].filter(Boolean).join(", plus ")}`;
		}

		static _getHtml_level ({v, isListMode}) {
						if (typeof v === "number") {
				if (isListMode) return `Lvl ${v}`;
				else return `${Parser.getOrdinalForm(v)} level`;
			} else if (!v.class && !v.subclass) {
				if (isListMode) return `Lvl ${v.level}`;
				else return `${Parser.getOrdinalForm(v.level)} level`;
			}

			const isLevelVisible = v.level !== 1; 			const isSubclassVisible = v.subclass && v.subclass.visible;
			const isClassVisible = v.class && (v.class.visible || isSubclassVisible); 			if (isListMode) {
				const shortNameRaw = isClassVisible ? this._getShortClassName(v.class.name) : null;
				return `${isClassVisible ? `${shortNameRaw.slice(0, 4)}${isSubclassVisible ? "*" : "."}` : ""}${isLevelVisible ? ` Lvl ${v.level}` : ""}`;
			} else {
				let classPart = "";
				if (isClassVisible && isSubclassVisible) classPart = ` ${v.class.name} (${v.subclass.name})`;
				else if (isClassVisible) classPart = ` ${v.class.name}`;
				else if (isSubclassVisible) classPart = ` &lt;remember to insert class name here&gt; (${v.subclass.name})`; 				return `${isLevelVisible ? `${Parser.getOrdinalForm(v.level)} level` : ""}${isClassVisible ? ` ${classPart}` : ""}`;
			}
		}

		static _getHtml_pact ({v, isListMode}) {
			return Parser.prereqPactToFull(v);
		}

		static _getHtml_patron ({v, isListMode}) {
			return isListMode ? `${Parser.prereqPatronToShort(v)} patron` : `${v} patron`;
		}

		static _getHtml_spell ({v, isListMode, isTextOnly}) {
			return isListMode
				? v.map(x => x.split("#")[0].split("|")[0].toTitleCase()).join("/")
				: v.map(sp => Parser.prereqSpellToFull(sp, {isTextOnly})).joinConjunct(", ", " or ");
		}

		static _getHtml_feat ({v, isListMode, isTextOnly}) {
			return isListMode
				? v.map(x => x.split("|")[0].toTitleCase()).join("/")
				: v.map(it => (isTextOnly ? Renderer.stripTags.bind(Renderer) : Renderer.get().render.bind(Renderer.get()))(`{@feat ${it}} feat`)).joinConjunct(", ", " or ");
		}

		static _getHtml_feature ({v, isListMode, isTextOnly}) {
			return isListMode
				? v.map(x => Renderer.stripTags(x).toTitleCase()).join("/")
				: v.map(it => isTextOnly ? Renderer.stripTags(it) : Renderer.get().render(it)).joinConjunct(", ", " or ");
		}

		static _getHtml_item ({v, isListMode}) {
			return isListMode ? v.map(x => x.toTitleCase()).join("/") : v.joinConjunct(", ", " or ");
		}

		static _getHtml_itemType ({v, isListMode}) {
			return isListMode
				? v
					.map(it => Renderer.item.getType(it))
					.map(it => it?.abbreviation)
					.join("+")
				: v
					.map(it => Renderer.item.getType(it))
					.map(it => it?.name?.toTitleCase())
					.joinConjunct(", ", " and ");
		}

		static _getHtml_itemProperty ({v, isListMode}) {
			if (v == null) return isListMode ? "No Prop." : "No Other Properties";

			return isListMode
				? v
					.map(it => Renderer.item.getProperty(it))
					.map(it => it?.abbreviation)
					.join("+")
				: (
					`${v
						.map(it => Renderer.item.getProperty(it))
						.map(it => it?.name?.toTitleCase())
						.joinConjunct(", ", " and ")
					} Property`
				);
		}

		static _getHtml_otherSummary ({v, isListMode, isTextOnly}) {
			return isListMode
				? (v.entrySummary || Renderer.stripTags(v.entry))
				: (isTextOnly ? Renderer.stripTags(v.entry) : Renderer.get().render(v.entry));
		}

		static _getHtml_other ({v, isListMode, isTextOnly}) {
			return isListMode ? "Special" : (isTextOnly ? Renderer.stripTags(v) : Renderer.get().render(v));
		}

		static _getHtml_race ({v, isListMode, isTextOnly}) {
			const parts = v.map((it, i) => {
				if (isListMode) {
					return `${it.name.toTitleCase()}${it.subrace != null ? ` (${it.subrace})` : ""}`;
				} else {
					const raceName = it.displayEntry ? (isTextOnly ? Renderer.stripTags(it.displayEntry) : Renderer.get().render(it.displayEntry)) : i === 0 ? it.name.toTitleCase() : it.name;
					return `${raceName}${it.subrace != null ? ` (${it.subrace})` : ""}`;
				}
			});
			return isListMode ? parts.join("/") : parts.joinConjunct(", ", " or ");
		}

		static _getHtml_background ({v, isListMode, isTextOnly}) {
			const parts = v.map((it, i) => {
				if (isListMode) {
					return `${it.name.toTitleCase()}`;
				} else {
					return it.displayEntry ? (isTextOnly ? Renderer.stripTags(it.displayEntry) : Renderer.get().render(it.displayEntry)) : i === 0 ? it.name.toTitleCase() : it.name;
				}
			});
			return isListMode ? parts.join("/") : parts.joinConjunct(", ", " or ");
		}

		static _getHtml_ability ({v, isListMode, isTextOnly}) {
			
			let hadMultipleInner = false;
			let hadMultiMultipleInner = false;
			let allValuesEqual = null;

			outer: for (const abMeta of v) {
				for (const req of Object.values(abMeta)) {
					if (allValuesEqual == null) allValuesEqual = req;
					else {
						if (req !== allValuesEqual) {
							allValuesEqual = null;
							break outer;
						}
					}
				}
			}

			const abilityOptions = v.map(abMeta => {
				if (allValuesEqual) {
					const abList = Object.keys(abMeta);
					hadMultipleInner = hadMultipleInner || abList.length > 1;
					return isListMode ? abList.map(ab => ab.uppercaseFirst()).join(", ") : abList.map(ab => Parser.attAbvToFull(ab)).joinConjunct(", ", " and ");
				} else {
					const groups = {};

					Object.entries(abMeta).forEach(([ab, req]) => {
						(groups[req] = groups[req] || []).push(ab);
					});

					let isMulti = false;
					const byScore = Object.entries(groups)
						.sort(([reqA], [reqB]) => SortUtil.ascSort(Number(reqB), Number(reqA)))
						.map(([req, abs]) => {
							hadMultipleInner = hadMultipleInner || abs.length > 1;
							if (abs.length > 1) hadMultiMultipleInner = isMulti = true;

							abs = abs.sort(SortUtil.ascSortAtts);
							return isListMode
								? `${abs.map(ab => ab.uppercaseFirst()).join(", ")} ${req}+`
								: `${abs.map(ab => Parser.attAbvToFull(ab)).joinConjunct(", ", " and ")} ${req} or higher`;
						});

					return isListMode
						? `${isMulti || byScore.length > 1 ? "(" : ""}${byScore.join(" & ")}${isMulti || byScore.length > 1 ? ")" : ""}`
						: isMulti ? byScore.joinConjunct("; ", " and ") : byScore.joinConjunct(", ", " and ");
				}
			});

						if (isListMode) {
				return `${abilityOptions.join("/")}${allValuesEqual != null ? ` ${allValuesEqual}+` : ""}`;
			} else {
				const isComplex = hadMultiMultipleInner || hadMultipleInner || allValuesEqual == null;
				const joined = abilityOptions.joinConjunct(
					hadMultiMultipleInner ? " - " : hadMultipleInner ? "; " : ", ",
					isComplex ? (isTextOnly ? ` /or/ ` : ` <i>or</i> `) : " or ",
				);
				return `${joined}${allValuesEqual != null ? ` ${allValuesEqual} or higher` : ""}`;
			}
		}

		static _getHtml_proficiency ({v, isListMode}) {
			const parts = v.map(obj => {
				return Object.entries(obj).map(([profType, prof]) => {
					switch (profType) {
						case "armor": {
							return isListMode ? `Prof ${Parser.armorFullToAbv(prof)} armor` : `Proficiency with ${prof} armor`;
						}
						case "weapon": {
							return isListMode ? `Prof ${Parser.weaponFullToAbv(prof)} weapon` : `Proficiency with a ${prof} weapon`;
						}
						default: throw new Error(`Unhandled proficiency type: "${profType}"`);
					}
				});
			});
			return isListMode ? parts.join("/") : parts.joinConjunct(", ", " or ");
		}

		static _getHtml_spellcasting ({v, isListMode}) {
			return isListMode ? "Spellcasting" : "The ability to cast at least one spell";
		}

		static _getHtml_spellcasting2020 ({v, isListMode}) {
			return isListMode ? "Spellcasting" : "Spellcasting or Pact Magic feature";
		}

		static _getHtml_psionics ({v, isListMode, isTextOnly}) {
			return isListMode
				? "Psionics"
				: (isTextOnly ? Renderer.stripTags : Renderer.get().render.bind(Renderer.get()))("Psionic Talent feature or {@feat Wild Talent|UA2020PsionicOptionsRevisited} feat");
		}

		static _getHtml_alignment ({v, isListMode}) {
			return isListMode
				? Parser.alignmentListToFull(v)
					.replace(/\bany\b/gi, "").trim()
					.replace(/\balignment\b/gi, "align").trim()
					.toTitleCase()
				: Parser.alignmentListToFull(v);
		}

		static _getHtml_campaign ({v, isListMode}) {
			return isListMode
				? v.join("/")
				: `${v.joinConjunct(", ", " or ")} Campaign`;
		}

		static _getHtml_group ({v, isListMode}) {
			return isListMode
				? v.map(it => it.toTitleCase()).join("/")
				: `${v.map(it => it.toTitleCase()).joinConjunct(", ", " or ")} Group`;
		}
	},

	getRepeatableHtml (ent, {isListMode = false} = {}) {
		if (ent.repeatable == null) return isListMode ? "\u2014" : "";
		return `${isListMode ? "" : "<b>"}Repeatable:${isListMode ? "" : "</b>"} ${ent.repeatableNote || (ent.repeatable ? "Yes" : "No")}`;
	},

	getRenderedSize (size) {
		return [...(size ? [size].flat() : [])]
			.sort(SortUtil.ascSortSize)
			.map(sz => Parser.sizeAbvToFull(sz))
			.joinConjunct(", ", " or ");
	},

	getMediaUrl (entry, prop, mediaDir) {
		if (!entry[prop]) return "";

		let href = "";
		if (entry[prop].type === "internal") {
			const baseUrl = Renderer.get().baseMediaUrls[mediaDir] || Renderer.get().baseUrl;
			const mediaPart = `${mediaDir}/${entry[prop].path}`;
			href = baseUrl !== "" ? `${baseUrl}${mediaPart}` : UrlUtil.link(mediaPart);
		} else if (entry[prop].type === "external") {
			href = entry[prop].url;
		}
		return href;
	},

	getTagEntry (tag, text) {
		switch (tag) {
			case "@dice":
			case "@autodice":
			case "@damage":
			case "@hit":
			case "@d20":
			case "@chance":
			case "@recharge": {
				const fauxEntry = {
					type: "dice",
					rollable: true,
				};
				const [rollText, displayText, name, ...others] = Renderer.splitTagByPipe(text);
				if (displayText) fauxEntry.displayText = displayText;

				if ((!fauxEntry.displayText && (rollText || "").includes("summonSpellLevel")) || (fauxEntry.displayText && fauxEntry.displayText.includes("summonSpellLevel"))) fauxEntry.displayText = (fauxEntry.displayText || rollText || "").replace(/summonSpellLevel/g, "the spell's level");

				if ((!fauxEntry.displayText && (rollText || "").includes("summonClassLevel")) || (fauxEntry.displayText && fauxEntry.displayText.includes("summonClassLevel"))) fauxEntry.displayText = (fauxEntry.displayText || rollText || "").replace(/summonClassLevel/g, "your class level");

				if (name) fauxEntry.name = name;

				switch (tag) {
					case "@dice":
					case "@autodice":
					case "@damage": {
												fauxEntry.toRoll = rollText;

						if (!fauxEntry.displayText && (rollText || "").includes(";")) fauxEntry.displayText = rollText.replace(/;/g, "/");
						if ((!fauxEntry.displayText && (rollText || "").includes("#$")) || (fauxEntry.displayText && fauxEntry.displayText.includes("#$"))) fauxEntry.displayText = (fauxEntry.displayText || rollText).replace(/#\$prompt_number[^$]*\$#/g, "(n)");
						fauxEntry.displayText = fauxEntry.displayText || fauxEntry.toRoll;

						if (tag === "@damage") fauxEntry.subType = "damage";
						if (tag === "@autodice") fauxEntry.autoRoll = true;

						return fauxEntry;
					}
					case "@d20":
					case "@hit": {
												let mod;
						if (!isNaN(rollText)) {
							const n = Number(rollText);
							mod = `${n >= 0 ? "+" : ""}${n}`;
						} else mod = /^\s+[-+]/.test(rollText) ? rollText : `+${rollText}`;
						fauxEntry.displayText = fauxEntry.displayText || mod;
						fauxEntry.toRoll = `1d20${mod}`;
						fauxEntry.subType = "d20";
						fauxEntry.d20mod = mod;
						if (tag === "@hit") fauxEntry.context = {type: "hit"};
						return fauxEntry;
					}
					case "@chance": {
												const [textSuccess, textFailure] = others;
						fauxEntry.toRoll = `1d100`;
						fauxEntry.successThresh = Number(rollText);
						fauxEntry.chanceSuccessText = textSuccess;
						fauxEntry.chanceFailureText = textFailure;
						return fauxEntry;
					}
					case "@recharge": {
												const flags = displayText ? displayText.split("") : null; 						fauxEntry.toRoll = "1d6";
						const asNum = Number(rollText || 6);
						fauxEntry.successThresh = 7 - asNum;
						fauxEntry.successMax = 6;
						fauxEntry.displayText = `${asNum}${asNum < 6 ? `\u20136` : ""}`;
						fauxEntry.chanceSuccessText = "Recharged!";
						fauxEntry.chanceFailureText = "Did not recharge";
						fauxEntry.isColorSuccessFail = true;
						return fauxEntry;
					}
				}

				return fauxEntry;
			}

			case "@ability": 			case "@savingThrow": { 				const fauxEntry = {
					type: "dice",
					rollable: true,
					subType: "d20",
					context: {type: tag === "@ability" ? "abilityCheck" : "savingThrow"},
				};

				const [abilAndScoreOrScore, displayText, name, ...others] = Renderer.splitTagByPipe(text);

				let [abil, ...rawScoreOrModParts] = abilAndScoreOrScore.split(" ").map(it => it.trim()).filter(Boolean);
				abil = abil.toLowerCase();

				fauxEntry.context.ability = abil;

				if (name) fauxEntry.name = name;
				else {
					if (tag === "@ability") fauxEntry.name = Parser.attAbvToFull(abil);
					else if (tag === "@savingThrow") fauxEntry.name = `${Parser.attAbvToFull(abil)} save`;
				}

				const rawScoreOrMod = rawScoreOrModParts.join(" ");
								if (isNaN(rawScoreOrMod) && tag === "@savingThrow") {
					if (displayText) fauxEntry.displayText = displayText;
					else fauxEntry.displayText = rawScoreOrMod;

					fauxEntry.toRoll = `1d20${rawScoreOrMod}`;
					fauxEntry.d20mod = rawScoreOrMod;
				} else {
					const scoreOrMod = Number(rawScoreOrMod) || 0;
					const mod = (tag === "@ability" ? Parser.getAbilityModifier : UiUtil.intToBonus)(scoreOrMod);

					if (displayText) fauxEntry.displayText = displayText;
					else {
						if (tag === "@ability") fauxEntry.displayText = `${scoreOrMod} (${mod})`;
						else fauxEntry.displayText = mod;
					}

					fauxEntry.toRoll = `1d20${mod}`;
					fauxEntry.d20mod = mod;
				}

				return fauxEntry;
			}

									case "@skillCheck": {
				const fauxEntry = {
					type: "dice",
					rollable: true,
					subType: "d20",
					context: {type: "skillCheck"},
				};

				const [skillAndMod, displayText, name, ...others] = Renderer.splitTagByPipe(text);

				const parts = skillAndMod.split(" ").map(it => it.trim()).filter(Boolean);
				const namePart = parts.shift();
				const bonusPart = parts.join(" ");
				const skill = namePart.replace(/_/g, " ");

				let mod = bonusPart;
				if (!isNaN(bonusPart)) mod = UiUtil.intToBonus(Number(bonusPart) || 0);
				else if (bonusPart.startsWith("#$")) mod = `+${bonusPart}`;

				fauxEntry.context.skill = skill;
				fauxEntry.displayText = displayText || mod;

				if (name) fauxEntry.name = name;
				else fauxEntry.name = skill.toTitleCase();

				fauxEntry.toRoll = `1d20${mod}`;
				fauxEntry.d20mod = mod;

				return fauxEntry;
			}

						case "@coinflip": {
				const [displayText, name, textSuccess, textFailure] = Renderer.splitTagByPipe(text);

				const fauxEntry = {
					type: "dice",
					toRoll: "1d2",
					successThresh: 1,
					successMax: 2,
					displayText: displayText || "flip a coin",
					chanceSuccessText: textSuccess || `Heads`,
					chanceFailureText: textFailure || `Tails`,
					isColorSuccessFail: !textSuccess && !textFailure,
					rollable: true,
				};

				return fauxEntry;
			}

			default: throw new Error(`Unhandled tag "${tag}"`);
		}
	},

	getTagMeta (tag, text) {
		switch (tag) {
			case "@deity": {
				let [name, pantheon, source, displayText, ...others] = Renderer.splitTagByPipe(text);
				pantheon = pantheon || "forgotten realms";
				source = source || Parser.getTagSource(tag, source);
				const hash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_DEITIES]({name, pantheon, source});

				return {
					name,
					displayText,
					others,

					page: UrlUtil.PG_DEITIES,
					source,
					hash,

					hashPreEncoded: true,
				};
			}

			case "@card": {
				const unpacked = DataUtil.deck.unpackUidCard(text);
				const {name, set, source, displayText} = unpacked;
				const hash = UrlUtil.URL_TO_HASH_BUILDER["card"]({name, set, source});

				return {
					name,
					displayText,

					isFauxPage: true,
					page: "card",
					source,
					hash,
					hashPreEncoded: true,
				};
			}

			case "@classFeature": {
				const unpacked = DataUtil.class.unpackUidClassFeature(text);

				const classPageHash = `${UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES]({name: unpacked.className, source: unpacked.classSource})}${HASH_PART_SEP}${UrlUtil.getClassesPageStatePart({feature: {ixLevel: unpacked.level - 1, ixFeature: 0}})}`;

				return {
					name: unpacked.name,
					displayText: unpacked.displayText,

					page: UrlUtil.PG_CLASSES,
					source: unpacked.source,
					hash: classPageHash,
					hashPreEncoded: true,

					pageHover: "classfeature",
					hashHover: UrlUtil.URL_TO_HASH_BUILDER["classFeature"](unpacked),
					hashPreEncodedHover: true,
				};
			}

			case "@subclassFeature": {
				const unpacked = DataUtil.class.unpackUidSubclassFeature(text);

				const classPageHash = `${UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES]({name: unpacked.className, source: unpacked.classSource})}${HASH_PART_SEP}${UrlUtil.getClassesPageStatePart({feature: {ixLevel: unpacked.level - 1, ixFeature: 0}})}`;

				return {
					name: unpacked.name,
					displayText: unpacked.displayText,

					page: UrlUtil.PG_CLASSES,
					source: unpacked.source,
					hash: classPageHash,
					hashPreEncoded: true,

					pageHover: "subclassfeature",
					hashHover: UrlUtil.URL_TO_HASH_BUILDER["subclassFeature"](unpacked),
					hashPreEncodedHover: true,
				};
			}

			case "@quickref": {
				const unpacked = DataUtil.quickreference.unpackUid(text);

				const hash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_QUICKREF](unpacked);

				return {
					name: unpacked.name,
					displayText: unpacked.displayText,

					page: UrlUtil.PG_QUICKREF,
					source: unpacked.source,
					hash,
					hashPreEncoded: true,
				};
			}

			default: return Renderer.utils._getTagMeta_generic(tag, text);
		}
	},

	_getTagMeta_generic (tag, text) {
		const {name, source, displayText, others} = DataUtil.generic.unpackUid(text, tag);
		const hash = UrlUtil.encodeForHash([name, source]);

		const out = {
			name,
			displayText,
			others,

			page: null,
			source,
			hash,

			preloadId: null,
			subhashes: null,
			linkText: null,

			hashPreEncoded: true,
		};

		switch (tag) {
			case "@spell": out.page = UrlUtil.PG_SPELLS; break;
			case "@item": out.page = UrlUtil.PG_ITEMS; break;
			case "@condition":
			case "@disease":
			case "@status": out.page = UrlUtil.PG_CONDITIONS_DISEASES; break;
			case "@background": out.page = UrlUtil.PG_BACKGROUNDS; break;
			case "@race": out.page = UrlUtil.PG_RACES; break;
			case "@optfeature": out.page = UrlUtil.PG_OPT_FEATURES; break;
			case "@reward": out.page = UrlUtil.PG_REWARDS; break;
			case "@feat": out.page = UrlUtil.PG_FEATS; break;
			case "@psionic": out.page = UrlUtil.PG_PSIONICS; break;
			case "@object": out.page = UrlUtil.PG_OBJECTS; break;
			case "@boon":
			case "@cult": out.page = UrlUtil.PG_CULTS_BOONS; break;
			case "@trap":
			case "@hazard": out.page = UrlUtil.PG_TRAPS_HAZARDS; break;
			case "@variantrule": out.page = UrlUtil.PG_VARIANTRULES; break;
			case "@table": out.page = UrlUtil.PG_TABLES; break;
			case "@vehicle":
			case "@vehupgrade": out.page = UrlUtil.PG_VEHICLES; break;
			case "@action": out.page = UrlUtil.PG_ACTIONS; break;
			case "@language": out.page = UrlUtil.PG_LANGUAGES; break;
			case "@charoption": out.page = UrlUtil.PG_CHAR_CREATION_OPTIONS; break;
			case "@recipe": out.page = UrlUtil.PG_RECIPES; break;
			case "@deck": out.page = UrlUtil.PG_DECKS; break;

			case "@legroup": {
				out.page = "legendaryGroup";
				out.isFauxPage = true;
				break;
			}

			case "@creature": {
				out.page = UrlUtil.PG_BESTIARY;

								if (others.length) {
					const [type, value] = others[0].split("=").map(it => it.trim().toLowerCase()).filter(Boolean);
					if (type && value) {
						switch (type) {
							case VeCt.HASH_SCALED: {
								const targetCrNum = Parser.crToNumber(value);
								out.preloadId = Renderer.monster.getCustomHashId({name, source, _isScaledCr: true, _scaledCr: targetCrNum});
								out.subhashes = [
									{key: VeCt.HASH_SCALED, value: targetCrNum},
								];
								out.linkText = displayText || `${name} (CR ${value})`;
								break;
							}

							case VeCt.HASH_SCALED_SPELL_SUMMON: {
								const scaledSpellNum = Number(value);
								out.preloadId = Renderer.monster.getCustomHashId({name, source, _isScaledSpellSummon: true, _scaledSpellSummonLevel: scaledSpellNum});
								out.subhashes = [
									{key: VeCt.HASH_SCALED_SPELL_SUMMON, value: scaledSpellNum},
								];
								out.linkText = displayText || `${name} (Spell Level ${value})`;
								break;
							}

							case VeCt.HASH_SCALED_CLASS_SUMMON: {
								const scaledClassNum = Number(value);
								out.preloadId = Renderer.monster.getCustomHashId({name, source, _isScaledClassSummon: true, _scaledClassSummonLevel: scaledClassNum});
								out.subhashes = [
									{key: VeCt.HASH_SCALED_CLASS_SUMMON, value: scaledClassNum},
								];
								out.linkText = displayText || `${name} (Class Level ${value})`;
								break;
							}
						}
					}
				}

				break;
			}

			case "@class": {
				out.page = UrlUtil.PG_CLASSES;

				if (others.length) {
					const [subclassShortName, subclassSource, featurePart] = others;

					if (subclassSource) out.source = subclassSource;

					const classStateOpts = {
						subclass: {
							shortName: subclassShortName.trim(),
							source: subclassSource
								? subclassSource.trim()
								: Parser.SRC_PHB,
						},
					};

										const hoverSubhashObj = UrlUtil.unpackSubHash(UrlUtil.getClassesPageStatePart(classStateOpts));
					out.subhashesHover = [{key: "state", value: hoverSubhashObj.state, preEncoded: true}];

					if (featurePart) {
						const featureParts = featurePart.trim().split("-");
						classStateOpts.feature = {
							ixLevel: featureParts[0] || "0",
							ixFeature: featureParts[1] || "0",
						};
					}

					const subhashObj = UrlUtil.unpackSubHash(UrlUtil.getClassesPageStatePart(classStateOpts));

					out.subhashes = [
						{key: "state", value: subhashObj.state.join(HASH_SUB_LIST_SEP), preEncoded: true},
						{key: "fltsource", value: "clear"},
						{key: "flstmiscellaneous", value: "clear"},
					];
				}

				break;
			}

			case "@skill": { out.isFauxPage = true; out.page = "skill"; break; }
			case "@sense": { out.isFauxPage = true; out.page = "sense"; break; }
			case "@itemMastery": { out.isFauxPage = true; out.page = "itemMastery"; break; }

			default: throw new Error(`Unhandled tag "${tag}"`);
		}

		return out;
	},

		applyTemplate (ent, templateString, {fnPreApply, mapCustom} = {}) {
		return templateString.replace(/{{([^}]+)}}/g, (fullMatch, strArgs) => {
			if (fnPreApply) fnPreApply(fullMatch, strArgs);

						if (strArgs === "item.dmg1") {
				return Renderer.item._getTaggedDamage(ent.dmg1);
			} else if (strArgs === "item.dmg2") {
				return Renderer.item._getTaggedDamage(ent.dmg2);
			}

			if (mapCustom && mapCustom[strArgs]) return mapCustom[strArgs];

			const args = strArgs.split(" ").map(arg => arg.trim()).filter(Boolean);

			
			if (args.length === 1) {
				return Renderer.utils._applyTemplate_getValue(ent, args[0]);
			} else if (args.length === 2) {
				const val = Renderer.utils._applyTemplate_getValue(ent, args[1]);
				switch (args[0]) {
					case "getFullImmRes": return Parser.getFullImmRes(val);
					default: throw new Error(`Unknown template function "${args[0]}"`);
				}
			} else throw new Error(`Unhandled number of arguments ${args.length}`);
		});
	},

	_applyTemplate_getValue (ent, prop) {
		const spl = prop.split(".");
		switch (spl[0]) {
			case "item": {
				const path = spl.slice(1);
				if (!path.length) return `{@i missing key path}`;
				return MiscUtil.get(ent, ...path);
			}
			default: return `{@i unknown template root: "${spl[0]}"}`;
		}
	},
	
		getFlatEntries (entry) {
		const out = [];
		const depthStack = [];

		const recurse = ({obj}) => {
			let isPopDepth = false;

			Renderer.ENTRIES_WITH_ENUMERATED_TITLES
				.forEach(meta => {
					if (obj.type !== meta.type) return;

					const kName = "name"; 					if (obj[kName] == null) return;

					isPopDepth = true;

					const curDepth = depthStack.length ? depthStack.last() : 0;
					const nxtDepth = meta.depth ? meta.depth : meta.depthIncrement ? curDepth + meta.depthIncrement : curDepth;

					depthStack.push(
						Math.min(
							nxtDepth,
							2,
						),
					);

					const cpyObj = MiscUtil.copyFast(obj);

					out.push({
						depth: curDepth,
						entry: cpyObj,
						key: meta.key,
						ix: out.length,
						name: cpyObj.name,
					});

					cpyObj[meta.key] = cpyObj[meta.key].map(child => {
						if (!child.type) return child;
						const childMeta = Renderer.ENTRIES_WITH_ENUMERATED_TITLES_LOOKUP[child.type];
						if (!childMeta) return child;

						const kNameChild = "name"; 						if (child[kName] == null) return child;

												const ixNextRef = out.length;

												recurse({obj: child});

												return {IX_FLAT_REF: ixNextRef};
					});
				});

			if (isPopDepth) depthStack.pop();
		};

		recurse({obj: entry});

		return out;
	},

	getLinkSubhashString (subhashes) {
		let out = "";
		const len = subhashes.length;
		for (let i = 0; i < len; ++i) {
			const subHash = subhashes[i];
			if (subHash.preEncoded) out += `${HASH_PART_SEP}${subHash.key}${HASH_SUB_KV_SEP}`;
			else out += `${HASH_PART_SEP}${UrlUtil.encodeForHash(subHash.key)}${HASH_SUB_KV_SEP}`;
			if (subHash.value != null) {
				if (subHash.preEncoded) out += subHash.value;
				else out += UrlUtil.encodeForHash(subHash.value);
			} else {
								out += subHash.values.map(v => UrlUtil.encodeForHash(v)).join(HASH_SUB_LIST_SEP);
			}
		}
		return out;
	},

	initFullEntries_ (ent, {propEntries = "entries", propFullEntries = "_fullEntries"} = {}) {
		ent[propFullEntries] = ent[propFullEntries] || (ent[propEntries] ? MiscUtil.copyFast(ent[propEntries]) : []);
	},

	lazy: {
		_getIntersectionConfig () {
			return {
				rootMargin: "150px 0px", 				threshold: 0.01,
			};
		},

		_OBSERVERS: {},
		getCreateObserver ({observerId, fnOnObserve}) {
			if (!Renderer.utils.lazy._OBSERVERS[observerId]) {
				const observer = Renderer.utils.lazy._OBSERVERS[observerId] = new IntersectionObserver(
					Renderer.utils.lazy.getFnOnIntersect({
						observerId,
						fnOnObserve,
					}),
					Renderer.utils.lazy._getIntersectionConfig(),
				);

				observer._TRACKED = new Set();

				observer.track = it => {
					observer._TRACKED.add(it);
					return observer.observe(it);
				};

				observer.untrack = it => {
					observer._TRACKED.delete(it);
					return observer.unobserve(it);
				};

								observer._printListener = evt => {
					if (!observer._TRACKED.size) return;

										[...observer._TRACKED].forEach(it => {
						observer.untrack(it);
						fnOnObserve({
							observer,
							entry: {
								target: it,
							},
						});
					});

					alert(`All content must be loaded prior to printing. Please cancel the print and wait a few moments for loading to complete!`);
									};
				window.addEventListener("beforeprint", observer._printListener);
			}
			return Renderer.utils.lazy._OBSERVERS[observerId];
		},

		destroyObserver ({observerId}) {
			const observer = Renderer.utils.lazy._OBSERVERS[observerId];
			if (!observer) return;

			observer.disconnect();
			window.removeEventListener("beforeprint", observer._printListener);
		},

		getFnOnIntersect ({observerId, fnOnObserve}) {
			return obsEntries => {
				const observer = Renderer.utils.lazy._OBSERVERS[observerId];

				obsEntries.forEach(entry => {
										if (entry.intersectionRatio <= 0) return;

					observer.untrack(entry.target);
					fnOnObserve({
						observer,
						entry,
					});
				});
			};
		},
	},
};

Renderer.tag = class {
	static _TagBase = class {
		tagName;
		defaultSource = null;
		page = null;

		get tag () { return `@${this.tagName}`; }

		getStripped (tag, text) {
			text = text.replace(/<\$([^$]+)\$>/gi, ""); 			return this._getStripped(tag, text);
		}

				_getStripped (tag, text) { throw new Error("Unimplemented!"); }
	};

	static _TagBaseAt = class extends this._TagBase {
		get tag () { return `@${this.tagName}`; }
	};

	static _TagBaseHash = class extends this._TagBase {
		get tag () { return `#${this.tagName}`; }
	};

	static _TagTextStyle = class extends this._TagBaseAt {
		_getStripped (tag, text) { return text; }
	};

	static TagBoldShort = class extends this._TagTextStyle {
		tagName = "b";
	};

	static TagBoldLong = class extends this._TagTextStyle {
		tagName = "bold";
	};

	static TagItalicShort = class extends this._TagTextStyle {
		tagName = "i";
	};

	static TagItalicLong = class extends this._TagTextStyle {
		tagName = "italic";
	};

	static TagStrikethroughShort = class extends this._TagTextStyle {
		tagName = "s";
	};

	static TagStrikethroughLong = class extends this._TagTextStyle {
		tagName = "strike";
	};

	static TagUnderlineShort = class extends this._TagTextStyle {
		tagName = "u";
	};

	static TagUnderlineLong = class extends this._TagTextStyle {
		tagName = "underline";
	};

	static TagSup = class extends this._TagTextStyle {
		tagName = "sup";
	};

	static TagSub = class extends this._TagTextStyle {
		tagName = "sub";
	};

	static TagKbd = class extends this._TagTextStyle {
		tagName = "kbd";
	};

	static TagCode = class extends this._TagTextStyle {
		tagName = "code";
	};

	static TagStyle = class extends this._TagTextStyle {
		tagName = "style";
	};

	static TagFont = class extends this._TagTextStyle {
		tagName = "font";
	};

	static TagComic = class extends this._TagTextStyle {
		tagName = "comic";
	};

	static TagComicH1 = class extends this._TagTextStyle {
		tagName = "comicH1";
	};

	static TagComicH2 = class extends this._TagTextStyle {
		tagName = "comicH2";
	};

	static TagComicH3 = class extends this._TagTextStyle {
		tagName = "comicH3";
	};

	static TagComicH4 = class extends this._TagTextStyle {
		tagName = "comicH4";
	};

	static TagComicNote = class extends this._TagTextStyle {
		tagName = "comicNote";
	};

	static TagNote = class extends this._TagTextStyle {
		tagName = "note";
	};

	static TagUnit = class extends this._TagBaseAt {
		tagName = "unit";

		_getStripped (tag, text) {
			const [amount, unitSingle, unitPlural] = Renderer.splitTagByPipe(text);
			return isNaN(amount) ? unitSingle : Number(amount) > 1 ? (unitPlural || unitSingle.toPlural()) : unitSingle;
		}
	};

	static TagHit = class extends this._TagBaseAt {
		tagName = "h";

		_getStripped (tag, text) { return "Hit: "; }
	};

	static TagMiss = class extends this._TagBaseAt {
		tagName = "m";

		_getStripped (tag, text) { return "Miss: "; }
	};

	static TagAtk = class extends this._TagBaseAt {
		tagName = "atk";

		_getStripped (tag, text) { return Renderer.attackTagToFull(text); }
	};

	static TagHitYourSpellAttack = class extends this._TagBaseAt {
		tagName = "hitYourSpellAttack";

		_getStripped (tag, text) { return "your spell attack modifier"; }
	};

	static TagDc = class extends this._TagBaseAt {
		tagName = "dc";

		_getStripped (tag, text) {
			const [dcText, displayText] = Renderer.splitTagByPipe(text);
			return `DC ${displayText || dcText}`;
		}
	};

	static _TagDiceFlavor = class extends this._TagBaseAt {
		_getStripped (tag, text) {
			const [rollText, displayText] = Renderer.splitTagByPipe(text);
			switch (tag) {
				case "@damage":
				case "@dice":
				case "@autodice": {
					return displayText || rollText.replace(/;/g, "/");
				}
				case "@d20":
				case "@hit": {
					return displayText || (() => {
						const n = Number(rollText);
						if (!isNaN(n)) return `${n >= 0 ? "+" : ""}${n}`;
						return rollText;
					})();
				}
				case "@recharge": {
					const asNum = Number(rollText || 6);
					if (isNaN(asNum)) {
						throw new Error(`Could not parse "${rollText}" as a number!`);
					}
					return `(Recharge ${asNum}${asNum < 6 ? `\u20136` : ""})`;
				}
				case "@chance": {
					return displayText || `${rollText} percent`;
				}
				case "@ability": {
					const [, rawScore] = rollText.split(" ").map(it => it.trim().toLowerCase()).filter(Boolean);
					const score = Number(rawScore) || 0;
					return displayText || `${score} (${Parser.getAbilityModifier(score)})`;
				}
				case "@savingThrow":
				case "@skillCheck": {
					return displayText || rollText;
				}
			}
			throw new Error(`Unhandled tag: ${tag}`);
		}
	};

	static TaChance = class extends this._TagDiceFlavor {
		tagName = "chance";
	};

	static TaD20 = class extends this._TagDiceFlavor {
		tagName = "d20";
	};

	static TaDamage = class extends this._TagDiceFlavor {
		tagName = "damage";
	};

	static TaDice = class extends this._TagDiceFlavor {
		tagName = "dice";
	};

	static TaAutodice = class extends this._TagDiceFlavor {
		tagName = "autodice";
	};

	static TaHit = class extends this._TagDiceFlavor {
		tagName = "hit";
	};

	static TaRecharge = class extends this._TagDiceFlavor {
		tagName = "recharge";
	};

	static TaAbility = class extends this._TagDiceFlavor {
		tagName = "ability";
	};

	static TaSavingThrow = class extends this._TagDiceFlavor {
		tagName = "savingThrow";
	};

	static TaSkillCheck = class extends this._TagDiceFlavor {
		tagName = "skillCheck";
	};

	static _TagDiceFlavorScaling = class extends this._TagBaseAt {
		_getStripped (tag, text) {
			const [, , addPerProgress ] = Renderer.splitTagByPipe(text);
			return addPerProgress;
		}
	};

	static TagScaledice = class extends this._TagDiceFlavorScaling {
		tagName = "scaledice";
	};

	static TagScaledamage = class extends this._TagDiceFlavorScaling {
		tagName = "scaledamage";
	};

	static TagCoinflip = class extends this._TagBaseAt {
		tagName = "coinflip";

		_getStripped (tag, text) {
			const [displayText] = Renderer.splitTagByPipe(text);
			return displayText || "flip a coin";
		}
	};

	static _TagPipedNoDisplayText = class extends this._TagBaseAt {
		_getStripped (tag, text) {
			const parts = Renderer.splitTagByPipe(text);
			return parts[0];
		}
	};

	static Tag5etools = class extends this._TagPipedNoDisplayText {
		tagName = "5etools";
	};

	static TagAdventure = class extends this._TagPipedNoDisplayText {
		tagName = "adventure";
	};

	static TagBook = class extends this._TagPipedNoDisplayText {
		tagName = "book";
	};

	static TagFilter = class extends this._TagPipedNoDisplayText {
		tagName = "filter";
	};

	static TagFootnote = class extends this._TagPipedNoDisplayText {
		tagName = "footnote";
	};

	static TagLink = class extends this._TagPipedNoDisplayText {
		tagName = "link";
	};

	static TagLoader = class extends this._TagPipedNoDisplayText {
		tagName = "loader";
	};

	static TagColor = class extends this._TagPipedNoDisplayText {
		tagName = "color";
	};

	static TagHighlight = class extends this._TagPipedNoDisplayText {
		tagName = "highlight";
	};

	static TagHelp = class extends this._TagPipedNoDisplayText {
		tagName = "help";
	};

	static _TagPipedDisplayTextThird = class extends this._TagBaseAt {
		_getStripped (tag, text) {
			const parts = Renderer.splitTagByPipe(text);
			return parts.length >= 3 ? parts[2] : parts[0];
		}
	};

	static TagAction = class extends this._TagPipedDisplayTextThird {
		tagName = "action";
		defaultSource = Parser.SRC_PHB;
		page = UrlUtil.PG_ACTIONS;
	};

	static TagBackground = class extends this._TagPipedDisplayTextThird {
		tagName = "background";
		defaultSource = Parser.SRC_PHB;
		page = UrlUtil.PG_BACKGROUNDS;
	};

	static TagBoon = class extends this._TagPipedDisplayTextThird {
		tagName = "boon";
		defaultSource = Parser.SRC_MTF;
		page = UrlUtil.PG_CULTS_BOONS;
	};

	static TagCharoption = class extends this._TagPipedDisplayTextThird {
		tagName = "charoption";
		defaultSource = Parser.SRC_MOT;
		page = UrlUtil.PG_CHAR_CREATION_OPTIONS;
	};

	static TagClass = class extends this._TagPipedDisplayTextThird {
		tagName = "class";
		defaultSource = Parser.SRC_PHB;
		page = UrlUtil.PG_CLASSES;
	};

	static TagCondition = class extends this._TagPipedDisplayTextThird {
		tagName = "condition";
		defaultSource = Parser.SRC_PHB;
		page = UrlUtil.PG_CONDITIONS_DISEASES;
	};

	static TagCreature = class extends this._TagPipedDisplayTextThird {
		tagName = "creature";
		defaultSource = Parser.SRC_MM;
		page = UrlUtil.PG_BESTIARY;
	};

	static TagCult = class extends this._TagPipedDisplayTextThird {
		tagName = "cult";
		defaultSource = Parser.SRC_MTF;
		page = UrlUtil.PG_CULTS_BOONS;
	};

	static TagDeck = class extends this._TagPipedDisplayTextThird {
		tagName = "deck";
		defaultSource = Parser.SRC_DMG;
		page = UrlUtil.PG_DECKS;
	};

	static TagDisease = class extends this._TagPipedDisplayTextThird {
		tagName = "disease";
		defaultSource = Parser.SRC_DMG;
		page = UrlUtil.PG_CONDITIONS_DISEASES;
	};

	static TagFeat = class extends this._TagPipedDisplayTextThird {
		tagName = "feat";
		defaultSource = Parser.SRC_PHB;
		page = UrlUtil.PG_FEATS;
	};

	static TagHazard = class extends this._TagPipedDisplayTextThird {
		tagName = "hazard";
		defaultSource = Parser.SRC_DMG;
		page = UrlUtil.PG_TRAPS_HAZARDS;
	};

	static TagItem = class extends this._TagPipedDisplayTextThird {
		tagName = "item";
		defaultSource = Parser.SRC_DMG;
		page = UrlUtil.PG_ITEMS;
	};

	static TagItemMastery = class extends this._TagPipedDisplayTextThird {
		tagName = "itemMastery";
		defaultSource = VeCt.STR_GENERIC; 		page = "itemMastery";
	};

	static TagLanguage = class extends this._TagPipedDisplayTextThird {
		tagName = "language";
		defaultSource = Parser.SRC_PHB;
		page = UrlUtil.PG_LANGUAGES;
	};

	static TagLegroup = class extends this._TagPipedDisplayTextThird {
		tagName = "legroup";
		defaultSource = Parser.SRC_MM;
		page = "legendaryGroup";
	};

	static TagObject = class extends this._TagPipedDisplayTextThird {
		tagName = "object";
		defaultSource = Parser.SRC_DMG;
		page = UrlUtil.PG_OBJECTS;
	};

	static TagOptfeature = class extends this._TagPipedDisplayTextThird {
		tagName = "optfeature";
		defaultSource = Parser.SRC_PHB;
		page = UrlUtil.PG_OPT_FEATURES;
	};

	static TagPsionic = class extends this._TagPipedDisplayTextThird {
		tagName = "psionic";
		defaultSource = Parser.SRC_UATMC;
		page = UrlUtil.PG_PSIONICS;
	};

	static TagRace = class extends this._TagPipedDisplayTextThird {
		tagName = "race";
		defaultSource = Parser.SRC_PHB;
		page = UrlUtil.PG_RACES;
	};

	static TagRecipe = class extends this._TagPipedDisplayTextThird {
		tagName = "recipe";
		defaultSource = Parser.SRC_HEROES_FEAST;
		page = UrlUtil.PG_RECIPES;
	};

	static TagReward = class extends this._TagPipedDisplayTextThird {
		tagName = "reward";
		defaultSource = Parser.SRC_DMG;
		page = UrlUtil.PG_REWARDS;
	};

	static TagVehicle = class extends this._TagPipedDisplayTextThird {
		tagName = "vehicle";
		defaultSource = Parser.SRC_GoS;
		page = UrlUtil.PG_VEHICLES;
	};

	static TagVehupgrade = class extends this._TagPipedDisplayTextThird {
		tagName = "vehupgrade";
		defaultSource = Parser.SRC_GoS;
		page = UrlUtil.PG_VEHICLES;
	};

	static TagSense = class extends this._TagPipedDisplayTextThird {
		tagName = "sense";
		defaultSource = Parser.SRC_PHB;
		page = "sense";
	};

	static TagSkill = class extends this._TagPipedDisplayTextThird {
		tagName = "skill";
		defaultSource = Parser.SRC_PHB;
		page = "skill";
	};

	static TagSpell = class extends this._TagPipedDisplayTextThird {
		tagName = "spell";
		defaultSource = Parser.SRC_PHB;
		page = UrlUtil.PG_SPELLS;
	};

	static TagStatus = class extends this._TagPipedDisplayTextThird {
		tagName = "status";
		defaultSource = Parser.SRC_PHB;
		page = UrlUtil.PG_CONDITIONS_DISEASES;
	};

	static TagTable = class extends this._TagPipedDisplayTextThird {
		tagName = "table";
		defaultSource = Parser.SRC_DMG;
		page = UrlUtil.PG_TABLES;
	};

	static TagTrap = class extends this._TagPipedDisplayTextThird {
		tagName = "trap";
		defaultSource = Parser.SRC_DMG;
		page = UrlUtil.PG_TRAPS_HAZARDS;
	};

	static TagVariantrule = class extends this._TagPipedDisplayTextThird {
		tagName = "variantrule";
		defaultSource = Parser.SRC_DMG;
		page = UrlUtil.PG_VARIANTRULES;
	};

	static _TagPipedDisplayTextFourth = class extends this._TagBaseAt {
		_getStripped (tag, text) {
			const parts = Renderer.splitTagByPipe(text);
			return parts.length >= 4 ? parts[3] : parts[0];
		}
	};

	static TagCard = class extends this._TagPipedDisplayTextFourth {
		tagName = "card";
		defaultSource = Parser.SRC_DMG;
		page = "card";
	};

	static TagDeity = class extends this._TagPipedDisplayTextFourth {
		tagName = "deity";
		defaultSource = Parser.SRC_PHB;
		page = UrlUtil.PG_DEITIES;
	};

	static _TagPipedDisplayTextSixth = class extends this._TagBaseAt {
		_getStripped (tag, text) {
			const parts = Renderer.splitTagByPipe(text);
			return parts.length >= 6 ? parts[5] : parts[0];
		}
	};

	static TagClassFeature = class extends this._TagPipedDisplayTextSixth {
		tagName = "classFeature";
		defaultSource = Parser.SRC_PHB;
		page = UrlUtil.PG_CLASSES;
	};

	static _TagPipedDisplayTextEight = class extends this._TagBaseAt {
		_getStripped (tag, text) {
			const parts = Renderer.splitTagByPipe(text);
			return parts.length >= 8 ? parts[7] : parts[0];
		}
	};

	static TagSubclassFeature = class extends this._TagPipedDisplayTextEight {
		tagName = "subclassFeature";
		defaultSource = Parser.SRC_PHB;
		page = UrlUtil.PG_CLASSES;
	};

	static TagQuickref = class extends this._TagBaseAt {
		tagName = "quickref";
		defaultSource = Parser.SRC_PHB;
		page = UrlUtil.PG_QUICKREF;

		_getStripped (tag, text) {
			const {name, displayText} = DataUtil.quickreference.unpackUid(text);
			return displayText || name;
		}
	};

	static TagArea = class extends this._TagBaseAt {
		tagName = "area";

		_getStripped (tag, text) {
			const [compactText, , flags] = Renderer.splitTagByPipe(text);

			return flags && flags.includes("x")
				? compactText
				: `${flags && flags.includes("u") ? "A" : "a"}rea ${compactText}`;
		}
	};

	static TagHomebrew = class extends this._TagBaseAt {
		tagName = "homebrew";

		_getStripped (tag, text) {
			const [newText, oldText] = Renderer.splitTagByPipe(text);
			if (newText && oldText) {
				return `${newText} [this is a homebrew addition, replacing the following: "${oldText}"]`;
			} else if (newText) {
				return `${newText} [this is a homebrew addition]`;
			} else if (oldText) {
				return `[the following text has been removed due to homebrew: ${oldText}]`;
			} else throw new Error(`Homebrew tag had neither old nor new text!`);
		}
	};

	static TagItemEntry = class extends this._TagBaseHash {
		tagName = "itemEntry";
		defaultSource = Parser.SRC_DMG;
	};

	
	static TAGS = [
		new this.TagBoldShort(),
		new this.TagBoldLong(),
		new this.TagItalicShort(),
		new this.TagItalicLong(),
		new this.TagStrikethroughShort(),
		new this.TagStrikethroughLong(),
		new this.TagUnderlineShort(),
		new this.TagUnderlineLong(),
		new this.TagSup(),
		new this.TagSub(),
		new this.TagKbd(),
		new this.TagCode(),
		new this.TagStyle(),
		new this.TagFont(),

		new this.TagComic(),
		new this.TagComicH1(),
		new this.TagComicH2(),
		new this.TagComicH3(),
		new this.TagComicH4(),
		new this.TagComicNote(),

		new this.TagNote(),

		new this.TagUnit(),

		new this.TagHit(),
		new this.TagMiss(),

		new this.TagAtk(),

		new this.TagHitYourSpellAttack(),

		new this.TagDc(),

		new this.TaChance(),
		new this.TaD20(),
		new this.TaDamage(),
		new this.TaDice(),
		new this.TaAutodice(),
		new this.TaHit(),
		new this.TaRecharge(),
		new this.TaAbility(),
		new this.TaSavingThrow(),
		new this.TaSkillCheck(),

		new this.TagScaledice(),
		new this.TagScaledamage(),

		new this.TagCoinflip(),

		new this.Tag5etools(),
		new this.TagAdventure(),
		new this.TagBook(),
		new this.TagFilter(),
		new this.TagFootnote(),
		new this.TagLink(),
		new this.TagLoader(),
		new this.TagColor(),
		new this.TagHighlight(),
		new this.TagHelp(),

		new this.TagQuickref(),

		new this.TagArea(),

		new this.TagAction(),
		new this.TagBackground(),
		new this.TagBoon(),
		new this.TagCharoption(),
		new this.TagClass(),
		new this.TagCondition(),
		new this.TagCreature(),
		new this.TagCult(),
		new this.TagDeck(),
		new this.TagDisease(),
		new this.TagFeat(),
		new this.TagHazard(),
		new this.TagItem(),
		new this.TagItemMastery(),
		new this.TagLanguage(),
		new this.TagLegroup(),
		new this.TagObject(),
		new this.TagOptfeature(),
		new this.TagPsionic(),
		new this.TagRace(),
		new this.TagRecipe(),
		new this.TagReward(),
		new this.TagVehicle(),
		new this.TagVehupgrade(),
		new this.TagSense(),
		new this.TagSkill(),
		new this.TagSpell(),
		new this.TagStatus(),
		new this.TagTable(),
		new this.TagTrap(),
		new this.TagVariantrule(),

		new this.TagCard(),
		new this.TagDeity(),

		new this.TagClassFeature({tagName: "classFeature"}),

		new this.TagSubclassFeature({tagName: "subclassFeature"}),

		new this.TagHomebrew(),

		
		new this.TagItemEntry(),
	];

	static TAG_LOOKUP = {};

	static _init () {
		this.TAGS.forEach(tag => {
			this.TAG_LOOKUP[tag.tag] = tag;
			this.TAG_LOOKUP[tag.tagName] = tag;
		});

		return null;
	}

	static _ = this._init();

	
	static getPage (tag) {
		const tagInfo = this.TAG_LOOKUP[tag];
		return tagInfo?.page;
	}
};

Renderer.events = {
	handleClick_copyCode (evt, ele) {
		const $e = $(ele).parent().next("pre");
		MiscUtil.pCopyTextToClipboard($e.text());
		JqueryUtil.showCopiedEffect($e);
	},

	handleClick_toggleCodeWrap (evt, ele) {
		const nxt = !StorageUtil.syncGet("rendererCodeWrap");
		StorageUtil.syncSet("rendererCodeWrap", nxt);
		const $btn = $(ele).toggleClass("active", nxt);
		const $e = $btn.parent().next("pre");
		$e.toggleClass("rd__pre-wrap", nxt);
	},

	bindGeneric ({element = document.body} = {}) {
		$(element)
			.on("click", `[data-rd-data-embed-header]`, evt => {
				Renderer.events.handleClick_dataEmbedHeader(evt, evt.currentTarget);
			})
			.on("click", `[data-rd-h-toggle-button]`, evt => {
				Renderer.events.handleClick_headerToggleButton(evt, evt.currentTarget);
			})
			.on("click", `[data-rd-h-special-toggle-button]`, evt => {
				Renderer.events.handleClick_headerToggleButton(evt, evt.currentTarget, {isSpecial: true});
			})
		;
	},

	handleClick_dataEmbedHeader (evt, ele) {
		evt.stopPropagation();
		evt.preventDefault();

		const $ele = $(ele);
		$ele.find(".rd__data-embed-name").toggleVe();
		$ele.find(".rd__data-embed-toggle").text($ele.text().includes("+") ? "[\u2013]" : "[+]");
		$ele.closest("table").find("tbody").toggleVe();
	},

	handleClick_headerToggleButton (evt, ele, {isSpecial = false} = {}) {
		evt.stopPropagation();
		evt.preventDefault();

		const isShow = ele.innerHTML.includes("+");

		let eleNxt = ele.closest(".rd__h").nextElementSibling;

		while (eleNxt) {
						if (eleNxt.classList.contains("float-clear")) {
				eleNxt = eleNxt.nextElementSibling;
				continue;
			}

						if (!isSpecial) {
				const eleToCheck = Renderer.events._handleClick_headerToggleButton_getEleToCheck(eleNxt);
				if (
					eleToCheck.classList.contains("rd__b-special")
					|| (eleToCheck.classList.contains("rd__h") && !eleToCheck.classList.contains("rd__h--3"))
					|| (eleToCheck.classList.contains("rd__b") && !eleToCheck.classList.contains("rd__b--3"))
				) break;
			}

			eleNxt.classList.toggle("rd__ele-toggled-hidden");
			eleNxt = eleNxt.nextElementSibling;
		}

		ele.innerHTML = isShow ? "[\u2013]" : "[+]";
	},

	_handleClick_headerToggleButton_getEleToCheck (eleNxt) {
		if (eleNxt.type === 3) return eleNxt; 
				if (!eleNxt.classList.contains("rd__b") || eleNxt.classList.contains("rd__b--3")) return eleNxt;
		const childNodes = [...eleNxt.childNodes].filter(it => (it.type === 3 && (it.textContent || "").trim()) || it.type !== 3);
		if (childNodes.length !== 1) return eleNxt;
		if (childNodes[0].classList.contains("rd__b")) return Renderer.events._handleClick_headerToggleButton_getEleToCheck(childNodes[0]);
		return eleNxt;
	},

	handleLoad_inlineStatblock (ele) {
		const observer = Renderer.utils.lazy.getCreateObserver({
			observerId: "inlineStatblock",
			fnOnObserve: Renderer.events._handleLoad_inlineStatblock_fnOnObserve.bind(Renderer.events),
		});

		observer.track(ele.parentNode);
	},

	_handleLoad_inlineStatblock_fnOnObserve ({entry}) {
		const ele = entry.target;

		const tag = ele.dataset.rdTag.uq();
		const page = ele.dataset.rdPage.uq();
		const source = ele.dataset.rdSource.uq();
		const name = ele.dataset.rdName.uq();
		const displayName = ele.dataset.rdDisplayName.uq();
		const hash = ele.dataset.rdHash.uq();
		const style = ele.dataset.rdStyle.uq();

		DataLoader.pCacheAndGet(page, Parser.getTagSource(tag, source), hash)
			.then(toRender => {
				const tr = ele.closest("tr");

				if (!toRender) {
					tr.innerHTML = `<td colspan="6"><i class="text-danger">Failed to load ${tag ? Renderer.get().render(`{@${tag} ${name}|${source}${displayName ? `|${displayName}` : ""}}`) : displayName || name}!</i></td>`;
					throw new Error(`Could not find tag: "${tag}" (page/prop: "${page}") hash: "${hash}"`);
				}

				const headerName = displayName
					|| (name ?? toRender.name ?? (toRender.entries?.length ? toRender.entries?.[0]?.name : "(Unknown)"));

				const fnRender = Renderer.hover.getFnRenderCompact(page);
				const tbl = tr.closest("table");
				const nxt = e_({
					outer: Renderer.utils.getEmbeddedDataHeader(headerName, style)
						+ fnRender(toRender, {isEmbeddedEntity: true})
						+ Renderer.utils.getEmbeddedDataFooter(),
				});
				tbl.parentNode.replaceChild(
					nxt,
					tbl,
				);

				const nxtTgt = nxt.querySelector(`[data-rd-embedded-data-render-target="true"]`);

				const fnBind = Renderer.hover.getFnBindListenersCompact(page);
				if (fnBind) fnBind(toRender, nxtTgt);
			});
	},
};

Renderer.feat = {
	_mergeAbilityIncrease_getListItemText (abilityObj) {
		return Renderer.feat._mergeAbilityIncrease_getText(abilityObj);
	},

	_mergeAbilityIncrease_getListItemItem (abilityObj) {
		return {
			type: "item",
			name: "Ability Score Increase.",
			entry: Renderer.feat._mergeAbilityIncrease_getText(abilityObj),
		};
	},

	_mergeAbilityIncrease_getText (abilityObj) {
		const maxScore = abilityObj.max ?? 20;

		if (!abilityObj.choose) {
			return Object.keys(abilityObj)
				.filter(k => k !== "max")
				.map(ab => `Increase your ${Parser.attAbvToFull(ab)} score by ${abilityObj[ab]}, to a maximum of ${maxScore}.`)
				.join(" ");
		}

		if (abilityObj.choose.from.length === 6) {
			return abilityObj.choose.entry
				? Renderer.get().render(abilityObj.choose.entry) 				: `Increase one ability score of your choice by ${abilityObj.choose.amount ?? 1}, to a maximum of ${maxScore}.`;
		}

		const abbChoicesText = abilityObj.choose.from.map(it => Parser.attAbvToFull(it)).joinConjunct(", ", " or ");
		return `Increase your ${abbChoicesText} by ${abilityObj.choose.amount ?? 1}, to a maximum of ${maxScore}.`;
	},

	initFullEntries (feat) {
		if (!feat.ability || feat._fullEntries || !feat.ability.length) return;

		const abilsToDisplay = feat.ability.filter(it => !it.hidden);
		if (!abilsToDisplay.length) return;

		Renderer.utils.initFullEntries_(feat);

		const targetList = feat._fullEntries.find(e => e.type === "list");

				if (targetList && targetList.items.every(it => it.type === "item")) {
			abilsToDisplay.forEach(abilObj => targetList.items.unshift(Renderer.feat._mergeAbilityIncrease_getListItemItem(abilObj)));
			return;
		}

		if (targetList) {
			abilsToDisplay.forEach(abilObj => targetList.items.unshift(Renderer.feat._mergeAbilityIncrease_getListItemText(abilObj)));
			return;
		}

				abilsToDisplay.forEach(abilObj => feat._fullEntries.unshift(Renderer.feat._mergeAbilityIncrease_getListItemText(abilObj)));

		setTimeout(() => {
			throw new Error(`Could not find object of type "list" in "entries" for feat "${feat.name}" from source "${feat.source}" when merging ability scores! Reformat the feat to include a "list"-type entry.`);
		}, 1);
	},

		getCompactRenderedString (feat, opts) {
		opts = opts || {};

		const renderer = Renderer.get().setFirstSection(true);
		const renderStack = [];

		const prerequisite = Renderer.utils.prerequisite.getHtml(feat.prerequisite);
		const ptRepeatable = Renderer.utils.getRepeatableHtml(feat);
		Renderer.feat.initFullEntries(feat);
		renderStack.push(`
			${Renderer.utils.getExcludedTr({entity: feat, dataProp: "feat", page: UrlUtil.PG_FEATS})}
			${opts.isSkipNameRow ? "" : Renderer.utils.getNameTr(feat, {page: UrlUtil.PG_FEATS})}
			<tr class="text"><td colspan="6" class="text">
			${prerequisite ? `<p>${prerequisite}</p>` : ""}
			${ptRepeatable ? `<p>${prerequisite}</p>` : ""}
		`);
		renderer.recursiveRender({entries: feat._fullEntries || feat.entries}, renderStack, {depth: 2});
		renderStack.push(`</td></tr>`);

		return renderStack.join("");
	},

	pGetFluff (feat) {
		return Renderer.utils.pGetFluff({
			entity: feat,
			fnGetFluffData: DataUtil.featFluff.loadJSON.bind(DataUtil.featFluff),
			fluffProp: "featFluff",
		});
	},
};

Renderer.class = {
	getCompactRenderedString (cls) {
		if (cls.__prop === "subclass") return Renderer.subclass.getCompactRenderedString(cls);

		const clsEntry = {
			type: "section",
			name: cls.name,
			source: cls.source,
			page: cls.page,
			entries: MiscUtil.copyFast((cls.classFeatures || []).flat()),
		};

		return Renderer.hover.getGenericCompactRenderedString(clsEntry);
	},

	getHitDiceEntry (clsHd) { return clsHd ? {toRoll: `${clsHd.number}d${clsHd.faces}`, rollable: true} : null; },
	getHitPointsAtFirstLevel (clsHd) { return clsHd ? `${clsHd.number * clsHd.faces} + your Constitution modifier` : null; },
	getHitPointsAtHigherLevels (className, clsHd, hdEntry) { return className && clsHd && hdEntry ? `${Renderer.getEntryDice(hdEntry, "Hit die")} (or ${((clsHd.number * clsHd.faces) / 2 + 1)}) + your Constitution modifier per ${className} level after 1st` : null; },

	getRenderedArmorProfs (armorProfs) { return armorProfs.map(a => Renderer.get().render(a.full ? a.full : a === "light" || a === "medium" || a === "heavy" ? `{@filter ${a} armor|items|type=${a} armor}` : a)).join(", "); },
	getRenderedWeaponProfs (weaponProfs) { return weaponProfs.map(w => Renderer.get().render(w === "simple" || w === "martial" ? `{@filter ${w} weapons|items|type=${w} weapon}` : w.optional ? `<span class="help help--hover" title="Optional Proficiency">${w.proficiency}</span>` : w)).join(", "); },
	getRenderedToolProfs (toolProfs) { return toolProfs.map(it => Renderer.get().render(it)).join(", "); },
	getRenderedSkillProfs (skills) { return `${Parser.skillProficienciesToFull(skills).uppercaseFirst()}.`; },

	getWalkerFilterDereferencedFeatures () {
		return MiscUtil.getWalker({
			keyBlocklist: MiscUtil.GENERIC_WALKER_ENTRIES_KEY_BLOCKLIST,
			isAllowDeleteObjects: true,
			isDepthFirst: true,
		});
	},

	mutFilterDereferencedClassFeatures (
		{
			walker,
			cpyCls,
			pageFilter,
			filterValues,
			isUseSubclassSources = false,
		},
	) {
		walker = walker || Renderer.class.getWalkerFilterDereferencedFeatures();

		cpyCls.classFeatures = cpyCls.classFeatures.map((lvlFeatures, ixLvl) => {
			return walker.walk(
				lvlFeatures,
				{
					object: (obj) => {
						if (!obj.source) return obj;
						const fText = obj.isClassFeatureVariant ? {isClassFeatureVariant: true} : null;

						const isDisplay = [obj.source, ...(obj.otherSources || [])
							.map(it => it.source)]
							.some(src => pageFilter.filterBox.toDisplayByFilters(
								filterValues,
								...[
									{
										filter: pageFilter.sourceFilter,
										value: isUseSubclassSources && src === cpyCls.source
											? pageFilter.getActiveSource(filterValues)
											: src,
									},
									pageFilter.levelFilter
										? {
											filter: pageFilter.levelFilter,
											value: ixLvl + 1,
										}
										: null,
									{
										filter: pageFilter.optionsFilter,
										value: fText,
									},
								].filter(Boolean),
							));

						return isDisplay ? obj : null;
					},
					array: (arr) => {
						return arr.filter(it => it != null);
					},
				},
			);
		});
	},

	mutFilterDereferencedSubclassFeatures (
		{
			walker,
			cpySc,
			pageFilter,
			filterValues,
		},
	) {
		walker = walker || Renderer.class.getWalkerFilterDereferencedFeatures();

		cpySc.subclassFeatures = cpySc.subclassFeatures.map(lvlFeatures => {
			const level = CollectionUtil.bfs(lvlFeatures, {prop: "level"});

			return walker.walk(
				lvlFeatures,
				{
					object: (obj) => {
						if (obj.entries && !obj.entries.length) return null;
						if (!obj.source) return obj;
						const fText = obj.isClassFeatureVariant ? {isClassFeatureVariant: true} : null;

						const isDisplay = [obj.source, ...(obj.otherSources || [])
							.map(it => it.source)]
							.some(src => pageFilter.filterBox.toDisplayByFilters(
								filterValues,
								...[
									{
										filter: pageFilter.sourceFilter,
										value: src,
									},
									pageFilter.levelFilter
										? {
											filter: pageFilter.levelFilter,
											value: level,
										}
										: null,
									{
										filter: pageFilter.optionsFilter,
										value: fText,
									},
								].filter(Boolean),
							));

						return isDisplay ? obj : null;
					},
					array: (arr) => {
						return arr.filter(it => it != null);
					},
				},
			);
		});
	},
};

Renderer.subclass = {
	getCompactRenderedString (sc) {
		const scEntry = {
			type: "section",
			name: sc.name,
			source: sc.source,
			page: sc.page,
			entries: MiscUtil.copyFast((sc.subclassFeatures || []).flat()),
		};

		return Renderer.hover.getGenericCompactRenderedString(scEntry);
	},
};

Renderer.spell = {
	getCompactRenderedString (spell, opts) {
		opts = opts || {};

		const renderer = Renderer.get();
		const renderStack = [];

		renderStack.push(`
			${Renderer.utils.getExcludedTr({entity: spell, dataProp: "spell", page: UrlUtil.PG_SPELLS})}
			${Renderer.utils.getNameTr(spell, {page: UrlUtil.PG_SPELLS, isEmbeddedEntity: opts.isEmbeddedEntity})}
			<tr><td colspan="6">
				<table class="w-100 summary stripe-even-table">
					<tr>
						<th colspan="1">Level</th>
						<th colspan="1">School</th>
						<th colspan="2">Casting Time</th>
						<th colspan="2">Range</th>
					</tr>
					<tr>
						<td colspan="1">${Parser.spLevelToFull(spell.level)}${Parser.spMetaToFull(spell.meta)}</td>
						<td colspan="1">${Parser.spSchoolAndSubschoolsAbvsToFull(spell.school, spell.subschools)}</td>
						<td colspan="2">${Parser.spTimeListToFull(spell.time)}</td>
						<td colspan="2">${Parser.spRangeToFull(spell.range)}</td>
					</tr>
					<tr>
						<th colspan="4">Components</th>
						<th colspan="2">Duration</th>
					</tr>
					<tr>
						<td colspan="4">${Parser.spComponentsToFull(spell.components, spell.level)}</td>
						<td colspan="2">${Parser.spDurationToFull(spell.duration)}</td>
					</tr>
				</table>
			</td></tr>
		`);

		renderStack.push(`<tr class="text"><td colspan="6" class="text">`);
		const entryList = {type: "entries", entries: spell.entries};
		renderer.recursiveRender(entryList, renderStack, {depth: 1});
		if (spell.entriesHigherLevel) {
			const higherLevelsEntryList = {type: "entries", entries: spell.entriesHigherLevel};
			renderer.recursiveRender(higherLevelsEntryList, renderStack, {depth: 2});
		}
		const fromClassList = Renderer.spell.getCombinedClasses(spell, "fromClassList");
		if (fromClassList.length) {
			const [current] = Parser.spClassesToCurrentAndLegacy(fromClassList);
			renderStack.push(`<div><span class="bold">Classes: </span>${Parser.spMainClassesToFull(current)}</div>`);
		}
		renderStack.push(`</td></tr>`);

		return renderStack.join("");
	},

	_prereleaseSourcesCache: null,
	_brewSourcesCache: null,

	populatePrereleaseLookup (brew, {isForce = false} = {}) {
		Renderer.spell._populatePrereleaseBrewLookup({brew, isForce, propCache: "_prereleaseSourcesCache"});
	},

	populateBrewLookup (brew, {isForce = false} = {}) {
		Renderer.spell._populatePrereleaseBrewLookup({brew, isForce, propCache: "_brewSourcesCache"});
	},

	_populatePrereleaseBrewLookup ({brew, propCache, isForce}) {
		if (Renderer.spell[propCache] && !isForce) return;

		const cache = Renderer.spell[propCache] = {
			classes: {},

			groups: {},

						races: {},
			backgrounds: {},
			feats: {},
			optionalfeatures: {},
					};

						if (brew.class) {
			brew.class.forEach(c => {
				c.source = c.source || Parser.SRC_PHB;

				(c.classSpells || [])
					.forEach(itm => Renderer.spell._populatePrereleaseBrewLookup_item_classSubclass({
						cache,
						itm,
						className: c.name,
						classSource: c.source,
					}));
			});
		}

		if (brew.subclass) {
			brew.subclass.forEach(sc => {
				sc.classSource = sc.classSource || Parser.SRC_PHB;
				sc.shortName = sc.shortName || sc.name;
				sc.source = sc.source || sc.classSource;

				(sc.subclassSpells || [])
					.forEach(itm => Renderer.spell._populatePrereleaseBrewLookup_item_classSubclass({
						cache,
						itm,
						className: sc.className,
						classSource: sc.classSource,
						subclassShortName: sc.shortName,
						subclassName: sc.name,
						subclassSource: sc.source,
					}));

				Object.entries(sc.subSubclassSpells || {})
					.forEach(([subSubclassName, arr]) => {
						arr
							.forEach(itm => Renderer.spell._populatePrereleaseBrewLookup_item_classSubclass({
								cache,
								itm,
								className: sc.className,
								classSource: sc.classSource,
								subclassShortName: sc.shortName,
								subclassName: sc.name,
								subclassSource: sc.source,
								subSubclassName,
							}));
					});
			});
		}
		
		(brew.spellList || []).forEach(spellList => Renderer.spell._populatePrereleaseBrewLookup_item_group({cache, spellList}));
	},

	_populatePrereleaseBrewLookup_item_classSubclass (
		{
			cache,
			itm,
			className,
			classSource,
			subclassShortName,
			subclassName,
			subclassSource,
			subSubclassName,
		},
	) {
		const doAdd = (target) => {
			if (subclassShortName) {
				const toAdd = {
					class: {name: className, source: classSource},
					subclass: {name: subclassName || subclassShortName, shortName: subclassShortName, source: subclassSource},
				};
				if (subSubclassName) toAdd.subclass.subSubclass = subSubclassName;

				target.fromSubclass = target.fromSubclass || [];
				target.fromSubclass.push(toAdd);
				return;
			}

			const toAdd = {name: className, source: classSource};

			target.fromClassList = target.fromClassList || [];
			target.fromClassList.push(toAdd);
		};

				if (itm.className) {
			cache.classes.class = cache.classes.class || {};

			const cls = itm.className.toLowerCase();
			const source = (itm.classSource || Parser.SRC_PHB).toLowerCase();

			cache.classes.class[source] = cache.classes.class[source] || {};
			cache.classes.class[source][cls] = cache.classes.class[source][cls] || {};

			return doAdd(cache.classes.class[source][cls]);
		}
		
				cache.classes.spell = cache.classes.spell || {};

		let [name, source] = `${itm}`.toLowerCase().split("|");
		source = source || Parser.SRC_PHB.toLowerCase();

		cache.classes.spell[source] = cache.classes.spell[source] || {};
		cache.classes.spell[source][name] = cache.classes.spell[source][name] || {fromClassList: [], fromSubclass: []};

		doAdd(cache.classes.spell[source][name]);
			},

	_populatePrereleaseBrewLookup_item_group (
		{
			cache,
			spellList,
		},
	) {
		const spellListSourceLower = (spellList.source || "").toLowerCase();
		const spellListNameLower = (spellList.name || "").toLowerCase();

		spellList.spells
			.forEach(spell => {
				if (typeof spell === "string") {
					const {name, source} = DataUtil.proxy.unpackUid("spell", spell, "spell", {isLower: true});
					return MiscUtil.set(cache.groups, "spell", source, name, spellListSourceLower, spellListNameLower, {name: spellList.name, source: spellList.source});
				}

								throw new Error(`Grouping spells based on other spell lists is not yet supported!`);
			});
	},

	prePopulateHover (data) {
		(data.spell || []).forEach(sp => Renderer.spell.initBrewSources(sp));
	},

	prePopulateHoverPrerelease (data) {
		Renderer.spell.populatePrereleaseLookup(data);
	},

	prePopulateHoverBrew (data) {
		Renderer.spell.populateBrewLookup(data);
	},

	getCombinedClasses (sp, prop) {
		return [
			...((sp.classes || {})[prop] || []),
			...((sp._tmpClasses || {})[prop] || []),
		]
			.filter(it => {
				if (!ExcludeUtil.isInitialised) return true;

				switch (prop) {
					case "fromClassList":
					case "fromClassListVariant": {
						const hash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES](it);
						if (ExcludeUtil.isExcluded(hash, "class", it.source, {isNoCount: true})) return false;

						if (prop !== "fromClassListVariant") return true;
						if (it.definedInSource) return !ExcludeUtil.isExcluded("*", "classFeature", it.definedInSource, {isNoCount: true});

						return true;
					}
					case "fromSubclass":
					case "fromSubclassVariant": {
						const hash = UrlUtil.URL_TO_HASH_BUILDER["subclass"]({
							name: it.subclass.name,
							shortName: it.subclass.shortName,
							source: it.subclass.source,
							className: it.class.name,
							classSource: it.class.source,
						});

						if (prop !== "fromSubclassVariant") return !ExcludeUtil.isExcluded(hash, "subclass", it.subclass.source, {isNoCount: true});
						if (it.class.definedInSource) return !Renderer.spell.isExcludedSubclassVariantSource({classDefinedInSource: it.class.definedInSource});

						return true;
					}
					default: throw new Error(`Unhandled prop "${prop}"`);
				}
			});
	},

	isExcludedSubclassVariantSource ({classDefinedInSource, subclassDefinedInSource}) {
		return (classDefinedInSource != null && ExcludeUtil.isExcluded("*", "classFeature", classDefinedInSource, {isNoCount: true}))
			|| (subclassDefinedInSource != null && ExcludeUtil.isExcluded("*", "subclassFeature", subclassDefinedInSource, {isNoCount: true}));
	},

	getCombinedGeneric (sp, {propSpell, prop}) {
		const propSpellTmp = `_tmp${propSpell.uppercaseFirst()}`;
		return [
			...(sp[propSpell] || []),
			...(sp[propSpellTmp] || []),
		]
			.filter(it => {
				if (!ExcludeUtil.isInitialised || !prop) return true;
				const hash = UrlUtil.URL_TO_HASH_BUILDER[prop](it);
				return !ExcludeUtil.isExcluded(hash, prop, it.source, {isNoCount: true});
			})
			.sort(SortUtil.ascSortGenericEntity.bind(SortUtil));
	},

	_BREW_SOURCES_TMP_PROPS: [
		"_tmpSourcesInit",
		"_tmpClasses",
		"_tmpRaces",
		"_tmpBackgrounds",
		"_tmpFeats",
		"_tmpOptionalfeatures",
		"_tmpGroups",
	],
	uninitBrewSources (sp) {
		Renderer.spell._BREW_SOURCES_TMP_PROPS.forEach(prop => delete sp[prop]);
	},

	initBrewSources (sp) {
		if (sp._tmpSourcesInit) return;
		sp._tmpSourcesInit = true;

		sp._tmpClasses = {};
		sp._tmpRaces = [];
		sp._tmpBackgrounds = [];
		sp._tmpFeats = [];
		sp._tmpOptionalfeatures = [];
		sp._tmpGroups = [];

		const lowName = sp.name.toLowerCase();
		const lowSource = sp.source.toLowerCase();

		for (const cache of [Renderer.spell._prereleaseSourcesCache, Renderer.spell._brewSourcesCache]) {
			Renderer.spell._initBrewSources_brewClassesSubclasses({cache, sp, lowName, lowSource});
			Renderer.spell._initBrewSources_brewGeneric({cache, sp, lowName, lowSource, propSpell: "races", prop: "race"});
			Renderer.spell._initBrewSources_brewGeneric({cache, sp, lowName, lowSource, propSpell: "backgrounds", prop: "background"});
			Renderer.spell._initBrewSources_brewGeneric({cache, sp, lowName, lowSource, propSpell: "feats", prop: "feat"});
			Renderer.spell._initBrewSources_brewGeneric({cache, sp, lowName, lowSource, propSpell: "optionalfeatures", prop: "optionalfeature"});
			Renderer.spell._initBrewSources_brewGroup({cache, sp, lowName, lowSource});
		}
	},

	_initBrewSources_brewClassesSubclasses ({cache, sp, lowName, lowSource}) {
		if (!cache?.classes) return;

		if (cache.classes.spell?.[lowSource]?.[lowName]) {
			if (cache.classes.spell[lowSource][lowName].fromClassList.length) {
				sp._tmpClasses.fromClassList = sp._tmpClasses.fromClassList || [];
				sp._tmpClasses.fromClassList.push(...cache.classes.spell[lowSource][lowName].fromClassList);
			}

			if (cache.classes.spell[lowSource][lowName].fromSubclass.length) {
				sp._tmpClasses.fromSubclass = sp._tmpClasses.fromSubclass || [];
				sp._tmpClasses.fromSubclass.push(...cache.classes.spell[lowSource][lowName].fromSubclass);
			}
		}

		if (cache.classes.class && sp.classes?.fromClassList) {
			(sp._tmpClasses = sp._tmpClasses || {}).fromClassList = sp._tmpClasses.fromClassList || [];

						outer: for (const srcLower in cache.classes.class) {
				const searchForClasses = cache.classes.class[srcLower];

				for (const clsLowName in searchForClasses) {
					const spellHasClass = sp.classes?.fromClassList?.some(cls => (cls.source || "").toLowerCase() === srcLower && cls.name.toLowerCase() === clsLowName);
					if (!spellHasClass) continue;

					const fromDetails = searchForClasses[clsLowName];

					if (fromDetails.fromClassList) {
						sp._tmpClasses.fromClassList.push(...fromDetails.fromClassList);
					}

					if (fromDetails.fromSubclass) {
						sp._tmpClasses.fromSubclass = sp._tmpClasses.fromSubclass || [];
						sp._tmpClasses.fromSubclass.push(...fromDetails.fromSubclass);
					}

										break outer;
				}
			}
		}
	},

	_initBrewSources_brewGeneric ({cache, sp, lowName, lowSource, propSpell, prop}) {
		if (!cache?.[propSpell]) return;

		const propTmp = `_tmp${propSpell.uppercaseFirst()}`;

				if (cache[propSpell]?.spell?.[lowSource]?.[lowName]?.length) {
			(sp[propTmp] = sp[propTmp] || [])
				.push(...cache[propSpell].spell[lowSource][lowName]);
		}

				if (cache?.[propSpell]?.[prop] && sp[propSpell]) {
			sp[propTmp] = sp[propTmp] || [];

						outer: for (const srcLower in cache[propSpell][prop]) {
				const searchForExisting = cache[propSpell][prop][srcLower];

				for (const lowName in searchForExisting) {
					const spellHasEnt = sp[propSpell].some(it => (it.source || "").toLowerCase() === srcLower && it.name.toLowerCase() === lowName);
					if (!spellHasEnt) continue;

					const fromDetails = searchForExisting[lowName];

					sp[propTmp].push(...fromDetails);

										break outer;
				}
			}
		}
	},

	_initBrewSources_brewGroup ({cache, sp, lowName, lowSource}) {
		if (!cache?.groups) return;

		if (cache.groups.spell?.[lowSource]?.[lowName]) {
			Object.values(cache.groups.spell[lowSource][lowName])
				.forEach(bySource => {
					Object.values(bySource)
						.forEach(byName => {
							sp._tmpGroups.push(byName);
						});
				});
		}

			},

	pGetFluff (sp) {
		return Renderer.utils.pGetFluff({
			entity: sp,
			fluffBaseUrl: `data/spells/`,
			fluffProp: "spellFluff",
		});
	},
};

Renderer.condition = {
	getCompactRenderedString (cond) {
		const renderer = Renderer.get();
		const renderStack = [];

		renderStack.push(`
			${Renderer.utils.getExcludedTr({entity: cond, dataProp: cond.__prop || cond._type, page: UrlUtil.PG_CONDITIONS_DISEASES})}
			${Renderer.utils.getNameTr(cond, {page: UrlUtil.PG_CONDITIONS_DISEASES})}
			<tr class="text"><td colspan="6">
		`);
		renderer.recursiveRender({entries: cond.entries}, renderStack);
		renderStack.push(`</td></tr>`);

		return renderStack.join("");
	},

	pGetFluff (it) {
		return Renderer.utils.pGetFluff({
			entity: it,
			fnGetFluffData: it.__prop === "condition" ? DataUtil.conditionFluff.loadJSON.bind(DataUtil.conditionFluff) : null,
			fluffProp: it.__prop === "condition" ? "conditionFluff" : "diseaseFluff",
		});
	},
};

Renderer.background = {
	getCompactRenderedString (bg) {
		return Renderer.generic.getCompactRenderedString(
			bg,
			{
				dataProp: "background",
				page: UrlUtil.PG_BACKGROUNDS,
			},
		);
	},

	getSkillSummary (skillProfsArr, short, collectIn) {
		return Renderer.background._summariseProfs(skillProfsArr, short, collectIn, `skill`);
	},

	getToolSummary (toolProfsArray, short, collectIn) {
		return Renderer.background._summariseProfs(toolProfsArray, short, collectIn);
	},

	getLanguageSummary (languageProfsArray, short, collectIn) {
		return Renderer.background._summariseProfs(languageProfsArray, short, collectIn);
	},

	_summariseProfs (profGroupArr, short, collectIn, hoverTag) {
		if (!profGroupArr) return "";

		function getEntry (s) {
			return short ? s.toTitleCase() : hoverTag ? `{@${hoverTag} ${s.toTitleCase()}}` : s.toTitleCase();
		}

		function sortKeys (a, b) {
			if (a === b) return 0;
			if (a === "choose") return 1;
			if (b === "choose") return -1;
			return SortUtil.ascSort(a, b);
		}

		return profGroupArr.map(profGroup => {
			let sep = ", ";
			const toJoin = Object.keys(profGroup).sort(sortKeys).filter(k => profGroup[k]).map((k, i) => {
				if (k === "choose") {
					sep = "; ";
					const choose = profGroup[k];
					const chooseProfs = choose.from.map(s => {
						collectIn && !collectIn.includes(s) && collectIn.push(s);
						return getEntry(s);
					});
					return `${short ? `${i === 0 ? "C" : "c"}hoose ` : ""}${choose.count || 1} ${short ? `of` : `from`} ${chooseProfs.joinConjunct(", ", " or ")}`;
				} else {
					collectIn && !collectIn.includes(k) && collectIn.push(k);
					return getEntry(k);
				}
			});
			return toJoin.join(sep);
		}).join(" <i>or</i> ");
	},

	pGetFluff (bg) {
		return Renderer.utils.pGetFluff({
			entity: bg,
			fnGetFluffData: DataUtil.backgroundFluff.loadJSON.bind(DataUtil.backgroundFluff),
			fluffProp: "backgroundFluff",
		});
	},
};

Renderer.backgroundFeature = {
	getCompactRenderedString (ent) {
		return Renderer.generic.getCompactRenderedString(ent);
	},
};

Renderer.optionalfeature = {
	getListPrerequisiteLevelText (prerequisites) {
		if (!prerequisites || !prerequisites.some(it => it.level)) return "\u2014";
		const levelPart = prerequisites.find(it => it.level).level;
		return levelPart.level || levelPart;
	},

	getPreviouslyPrintedText (it) {
		return it.previousVersion ? `<tr><td colspan="6"><p class="mt-2">${Renderer.get().render(`{@i An earlier version of this ${it.featureType.map(t => Parser.optFeatureTypeToFull(t)).join("/")} is available in }${Parser.sourceJsonToFull(it.previousVersion.source)} {@i as {@optfeature ${it.previousVersion.name}|${it.previousVersion.source}}.}`)}</p></td></tr>` : "";
	},

	getTypeText (it) {
		const commonPrefix = it.featureType.length > 1 ? MiscUtil.findCommonPrefix(it.featureType.map(fs => Parser.optFeatureTypeToFull(fs)), {isRespectWordBoundaries: true}) : "";

		return [
			commonPrefix.trim() || null,
			it.featureType.map(ft => Parser.optFeatureTypeToFull(ft).substring(commonPrefix.length)).join("/"),
		].filter(Boolean).join(" ");
	},

	getCostHtml (ent) {
		if (!ent.consumes?.name) return "";

		const ptPrefix = "Cost: ";
		const ptUnit = ` ${ent.consumes.name[ent.consumes.amount !== 1 ? "toPlural" : "toString"]()}`;

		if (ent.consumes?.amountMin != null && ent.consumes?.amountMax != null) return `<i>${ptPrefix}${ent.consumes.amountMin}\u2013${ent.consumes.amountMax}${ptUnit}</i>`;
		return `<i>${ptPrefix}${ent.consumes.amount ?? 1}${ptUnit}</i>`;
	},

	getCompactRenderedString (it) {
		const ptCost = Renderer.optionalfeature.getCostHtml(it);
		return `
			${Renderer.utils.getExcludedTr({entity: it, dataProp: "optionalfeature", page: UrlUtil.PG_OPT_FEATURES})}
			${Renderer.utils.getNameTr(it, {page: UrlUtil.PG_OPT_FEATURES})}
			<tr class="text"><td colspan="6">
			${it.prerequisite ? `<p>${Renderer.utils.prerequisite.getHtml(it.prerequisite)}</p>` : ""}
			${ptCost ? `<p>${ptCost}</p>` : ""}
			${Renderer.get().render({entries: it.entries}, 1)}
			</td></tr>
			${Renderer.optionalfeature.getPreviouslyPrintedText(it)}
			<tr><td colspan="6"><p>${Renderer.get().render(`{@note Type: ${Renderer.optionalfeature.getTypeText(it)}}`)}</p></td></tr>
		`;
	},
};

Renderer.reward = {
	getRenderedString: (reward) => {
		const ptSubtitle = [
			(reward.type || "").toTitleCase(),
			reward.rarity ? reward.rarity.toTitleCase() : "",
		].filter(Boolean).join(", ");
		const entries = [
			ptSubtitle ? `{@i ${ptSubtitle}}` : "",
			...reward.entries,
		].filter(Boolean);
		return `<tr class="text"><td colspan="6">${Renderer.get().setFirstSection(true).render({entries}, 1)}</td></tr>`;
	},

	getCompactRenderedString (reward) {
		return `
			${Renderer.utils.getExcludedTr({entity: reward, dataProp: "reward", page: UrlUtil.PG_REWARDS})}
			${Renderer.utils.getNameTr(reward, {page: UrlUtil.PG_REWARDS})}
			${Renderer.reward.getRenderedString(reward)}
		`;
	},
};

Renderer.race = {
	getCompactRenderedString (race, {isStatic = false} = {}) {
		const renderer = Renderer.get();
		const renderStack = [];

		const ability = Renderer.getAbilityData(race.ability);
		renderStack.push(`
			${Renderer.utils.getExcludedTr({entity: race, dataProp: "race", page: UrlUtil.PG_RACES})}
			${Renderer.utils.getNameTr(race, {page: UrlUtil.PG_RACES})}
			<tr><td colspan="6">
				<table class="w-100 summary stripe-even-table">
					<tr>
						<th class="col-4 text-center">Ability Scores</th>
						<th class="col-4 text-center">Size</th>
						<th class="col-4 text-center">Speed</th>
					</tr>
					<tr>
						<td class="text-center">${ability.asText}</td>
						<td class="text-center">${(race.size || [Parser.SZ_VARIES]).map(sz => Parser.sizeAbvToFull(sz)).join("/")}</td>
						<td class="text-center">${Parser.getSpeedString(race)}</td>
					</tr>
				</table>
			</td></tr>
			<tr class="text"><td colspan="6">
		`);
		race._isBaseRace
			? renderer.recursiveRender({type: "entries", entries: race._baseRaceEntries}, renderStack, {depth: 1})
			: renderer.recursiveRender({type: "entries", entries: race.entries}, renderStack, {depth: 1});
		renderStack.push("</td></tr>");

		const ptHeightWeight = Renderer.race.getHeightAndWeightPart(race, {isStatic});
		if (ptHeightWeight) renderStack.push(`<tr class="text"><td colspan="6"><hr class="rd__hr">${ptHeightWeight}</td></tr>`);

		return renderStack.join("");
	},

	getHeightAndWeightPart (race, {isStatic = false} = {}) {
		if (!race.heightAndWeight) return null;
		if (race._isBaseRace) return null;

		const colLabels = ["Base Height", "Base Weight", "Height Modifier", "Weight Modifier"];
		const colStyles = ["col-2-3 text-center", "col-2-3 text-center", "col-2-3 text-center", "col-2 text-center"];
		const row = [
			Renderer.race.getRenderedHeight(race.heightAndWeight.baseHeight),
			`${race.heightAndWeight.baseWeight} lb.`,
			`+<span data-race-heightmod="true">${race.heightAndWeight.heightMod}</span>`,
			`× <span data-race-weightmod="true">${race.heightAndWeight.weightMod || "1"}</span> lb.`,
		];

		if (!isStatic) {
			colLabels.push("");
			colStyles.push("col-3-1 text-center");
			row.push(`<div class="ve-flex-vh-center">
				<div class="ve-hidden race__disp-result-height-weight ve-flex-v-baseline">
					<div class="mr-1">=</div>
					<div class="race__disp-result-height"></div>
					<div class="mr-2">; </div>
					<div class="race__disp-result-weight mr-1"></div>
					<div class="small">lb.</div>
				</div>
				<button class="btn btn-default btn-xs my-1 race__btn-roll-height-weight">Roll</button>
			</div>`);
		}

		const entries = [
			"You may roll for your character's height and weight on the Random Height and Weight table. The roll in the Height Modifier column adds a number (in inches) to the character's base height. To get a weight, multiply the number you rolled for height by the roll in the Weight Modifier column and add the result (in pounds) to the base weight.",
			{
				type: "table",
				caption: "Random Height and Weight",
				colLabels,
				colStyles,
				rows: [row],
			},
		];

		return Renderer.get().render({entries});
	},

	getRenderedHeight (height) {
		const heightFeet = Number(Math.floor(height / 12).toFixed(3));
		const heightInches = Number((height % 12).toFixed(3));
		return `${heightFeet ? `${heightFeet}'` : ""}${heightInches ? `${heightInches}"` : ""}`;
	},

		mergeSubraces (races, opts) {
		opts = opts || {};

		const out = [];
		races.forEach(r => {
						if (r.size && typeof r.size === "string") r.size = [r.size];

						if (r.lineage && r.lineage !== true) {
				r = MiscUtil.copyFast(r);

				if (r.lineage === "VRGR") {
					r.ability = r.ability || [
						{
							choose: {
								weighted: {
									from: [...Parser.ABIL_ABVS],
									weights: [2, 1],
								},
							},
						},
						{
							choose: {
								weighted: {
									from: [...Parser.ABIL_ABVS],
									weights: [1, 1, 1],
								},
							},
						},
					];
				} else if (r.lineage === "UA1") {
					r.ability = r.ability || [
						{
							choose: {
								weighted: {
									from: [...Parser.ABIL_ABVS],
									weights: [2, 1],
								},
							},
						},
					];
				}

				r.entries = r.entries || [];
				r.entries.push({
					type: "entries",
					name: "Languages",
					entries: ["You can speak, read, and write Common and one other language that you and your DM agree is appropriate for your character."],
				});

				r.languageProficiencies = r.languageProficiencies || [{"common": true, "anyStandard": 1}];
			}

			if (r.subraces && !r.subraces.length) delete r.subraces;

			if (r.subraces) {
				r.subraces.forEach(sr => {
					sr.source = sr.source || r.source;
					sr._isSubRace = true;
				});

				r.subraces.sort((a, b) => SortUtil.ascSortLower(a.name || "_", b.name || "_") || SortUtil.ascSortLower(Parser.sourceJsonToAbv(a.source), Parser.sourceJsonToAbv(b.source)));
			}

			if (opts.isAddBaseRaces && r.subraces) {
				const baseRace = MiscUtil.copyFast(r);

				baseRace._isBaseRace = true;

				const isAnyNoName = r.subraces.some(it => !it.name);
				if (isAnyNoName) {
					baseRace._rawName = baseRace.name;
					baseRace.name = `${baseRace.name} (Base)`;
				}

				const nameCounts = {};
				r.subraces.filter(sr => sr.name).forEach(sr => nameCounts[sr.name.toLowerCase()] = (nameCounts[sr.name.toLowerCase()] || 0) + 1);
				nameCounts._ = r.subraces.filter(sr => !sr.name).length;

				const lst = {
					type: "list",
					items: r.subraces.map(sr => {
						const count = nameCounts[(sr.name || "_").toLowerCase()];
						const idName = Renderer.race.getSubraceName(r.name, sr.name);
						return `{@race ${idName}|${sr.source}${count > 1 ? `|${idName} (<span title="${Parser.sourceJsonToFull(sr.source).escapeQuotes()}">${Parser.sourceJsonToAbv(sr.source)}</span>)` : ""}}`;
					}),
				};

				Renderer.race._mutBaseRaceEntries(baseRace, lst);
				baseRace._subraces = r.subraces.map(sr => ({name: Renderer.race.getSubraceName(r.name, sr.name), source: sr.source}));

				delete baseRace.subraces;

				out.push(baseRace);
			}

			out.push(...Renderer.race._mergeSubraces(r));
		});

		return out;
	},

	_mutMakeBaseRace (baseRace) {
		if (baseRace._isBaseRace) return;

		baseRace._isBaseRace = true;

		Renderer.race._mutBaseRaceEntries(baseRace, {type: "list", items: []});
	},

	_mutBaseRaceEntries (baseRace, lst) {
		baseRace._baseRaceEntries = [
			{
				type: "section",
				entries: [
					"This race has multiple subraces, as listed below:",
					lst,
				],
			},
			{
				type: "section",
				entries: [
					{
						type: "entries",
						entries: [
							{
								type: "entries",
								name: "Traits",
								entries: [
									...MiscUtil.copyFast(baseRace.entries),
								],
							},
						],
					},
				],
			},
		];
	},

	getSubraceName (raceName, subraceName) {
		if (!subraceName) return raceName;

		const mBrackets = /^(.*?)(\(.*?\))$/i.exec(raceName || "");
		if (!mBrackets) return `${raceName} (${subraceName})`;

		const bracketPart = mBrackets[2].substring(1, mBrackets[2].length - 1);
		return `${mBrackets[1]}(${[bracketPart, subraceName].join("; ")})`;
	},

	_mergeSubraces (race) {
		if (!race.subraces) return [race];
		return MiscUtil.copyFast(race.subraces).map(s => Renderer.race._getMergedSubrace(race, s));
	},

	_getMergedSubrace (race, s) {
		const cpy = MiscUtil.copyFast(race);
		cpy._baseName = cpy.name;
		cpy._baseSource = cpy.source;
		cpy._baseSrd = cpy.srd;
		cpy._baseBasicRules = cpy.basicRules;
		delete cpy.subraces;
		delete cpy.srd;
		delete cpy.basicRules;
		delete cpy._versions;
		delete cpy.hasFluff;
		delete cpy.hasFluffImages;

				if (s.name) {
			cpy._subraceName = s.name;

			if (s.alias) {
				cpy.alias = s.alias.map(it => Renderer.race.getSubraceName(cpy.name, it));
				delete s.alias;
			}

			cpy.name = Renderer.race.getSubraceName(cpy.name, s.name);
			delete s.name;
		}
		if (s.ability) {
						if ((s.overwrite && s.overwrite.ability) || !cpy.ability) cpy.ability = s.ability.map(() => ({}));

			if (cpy.ability.length !== s.ability.length) throw new Error(`Race and subrace ability array lengths did not match!`);
			s.ability.forEach((obj, i) => Object.assign(cpy.ability[i], obj));
			delete s.ability;
		}
		if (s.entries) {
			s.entries.forEach(e => {
				if (e.data && e.data.overwrite) {
					const toOverwrite = cpy.entries.findIndex(it => it.name.toLowerCase().trim() === e.data.overwrite.toLowerCase().trim());
					if (~toOverwrite) cpy.entries[toOverwrite] = e;
					else cpy.entries.push(e);
				} else {
					cpy.entries.push(e);
				}
			});
			delete s.entries;
		}

		if (s.traitTags) {
			if (s.overwrite && s.overwrite.traitTags) cpy.traitTags = s.traitTags;
			else cpy.traitTags = (cpy.traitTags || []).concat(s.traitTags);
			delete s.traitTags;
		}

		if (s.languageProficiencies) {
			if (s.overwrite && s.overwrite.languageProficiencies) cpy.languageProficiencies = s.languageProficiencies;
			else cpy.languageProficiencies = cpy.languageProficiencies = (cpy.languageProficiencies || []).concat(s.languageProficiencies);
			delete s.languageProficiencies;
		}

				if (s.skillProficiencies) {
						if (!cpy.skillProficiencies || (s.overwrite && s.overwrite["skillProficiencies"])) cpy.skillProficiencies = s.skillProficiencies;
			else {
				if (!s.skillProficiencies.length || !cpy.skillProficiencies.length) throw new Error(`No items!`);
				if (s.skillProficiencies.length > 1 || cpy.skillProficiencies.length > 1) throw new Error(`Subrace merging does not handle choices!`); 
								if (s.skillProficiencies.choose) {
					if (cpy.skillProficiencies.choose) throw new Error(`Subrace choose merging is not supported!!`); 					cpy.skillProficiencies.choose = s.skillProficiencies.choose;
					delete s.skillProficiencies.choose;
				}
				Object.assign(cpy.skillProficiencies[0], s.skillProficiencies[0]);
			}

			delete s.skillProficiencies;
		}

				Object.assign(cpy, s);

				Object.entries(cpy)
			.forEach(([k, v]) => {
				if (v != null) return;
				delete cpy[k];
			});

		return cpy;
	},

	adoptSubraces (allRaces, subraces) {
		const nxtData = [];

		subraces.forEach(sr => {
			if (!sr.raceName || !sr.raceSource) throw new Error(`Subrace was missing parent "raceName" and/or "raceSource"!`);

			const _baseRace = allRaces.find(r => r.name === sr.raceName && r.source === sr.raceSource);
			if (!_baseRace) throw new Error(`Could not find parent race for subrace "${sr.name}" (${sr.source})!`);

						if ((_baseRace._seenSubraces || []).some(it => it.name === sr.name && it.source === sr.source)) return;
			(_baseRace._seenSubraces = _baseRace._seenSubraces || []).push({name: sr.name, source: sr.source});

						if (
				!_baseRace._isBaseRace
				&& (PrereleaseUtil.hasSourceJson(_baseRace.source) || BrewUtil2.hasSourceJson(_baseRace.source))
			) {
				Renderer.race._mutMakeBaseRace(_baseRace);
			}

						if (_baseRace._isBaseRace) {
				const subraceListEntry = ((_baseRace._baseRaceEntries[0] || {}).entries || []).find(it => it.type === "list");
				subraceListEntry.items.push(`{@race ${_baseRace._rawName || _baseRace.name} (${sr.name})|${sr.source || _baseRace.source}}`);
			}

						let baseRace = nxtData.find(r => r.name === sr.raceName && r.source === sr.raceSource);
			if (!baseRace) {
								baseRace = MiscUtil.copyFast(_baseRace);
				if (baseRace._rawName) {
					baseRace.name = baseRace._rawName;
					delete baseRace._rawName;
				}
				delete baseRace._isBaseRace;
				delete baseRace._baseRaceEntries;

				nxtData.push(baseRace);
			}

			baseRace.subraces = baseRace.subraces || [];
			baseRace.subraces.push(sr);
		});

		return nxtData;
	},

	bindListenersHeightAndWeight (race, ele) {
		if (!race.heightAndWeight) return;
		if (race._isBaseRace) return;

		const $render = $(ele);

		const $dispResult = $render.find(`.race__disp-result-height-weight`);
		const $dispHeight = $render.find(`.race__disp-result-height`);
		const $dispWeight = $render.find(`.race__disp-result-weight`);

		const lock = new VeLock();
		let hasRolled = false;
		let resultHeight;
		let resultWeightMod;

		const $btnRollHeight = $render
			.find(`[data-race-heightmod="true"]`)
			.html(race.heightAndWeight.heightMod)
			.addClass("roller")
			.mousedown(evt => evt.preventDefault())
			.click(async () => {
				try {
					await lock.pLock();

					if (!hasRolled) return pDoFullRoll(true);
					await pRollHeight();
					updateDisplay();
				} finally {
					lock.unlock();
				}
			});

		const isWeightRoller = race.heightAndWeight.weightMod && isNaN(race.heightAndWeight.weightMod);
		const $btnRollWeight = $render
			.find(`[data-race-weightmod="true"]`)
			.html(isWeightRoller ? `(<span class="roller">${race.heightAndWeight.weightMod}</span>)` : race.heightAndWeight.weightMod || "1")
			.click(async () => {
				try {
					await lock.pLock();

					if (!hasRolled) return pDoFullRoll(true);
					await pRollWeight();
					updateDisplay();
				} finally {
					lock.unlock();
				}
			});
		if (isWeightRoller) $btnRollWeight.mousedown(evt => evt.preventDefault());

		const $btnRoll = $render
			.find(`button.race__btn-roll-height-weight`)
			.click(async () => pDoFullRoll());

		const pRollHeight = async () => {
			const mResultHeight = await Renderer.dice.pRoll2(race.heightAndWeight.heightMod, {
				isUser: false,
				label: "Height Modifier",
				name: race.name,
			});
			if (mResultHeight == null) return;
			resultHeight = mResultHeight;
		};

		const pRollWeight = async () => {
			const weightModRaw = race.heightAndWeight.weightMod || "1";
			const mResultWeightMod = isNaN(weightModRaw) ? await Renderer.dice.pRoll2(weightModRaw, {
				isUser: false,
				label: "Weight Modifier",
				name: race.name,
			}) : Number(weightModRaw);
			if (mResultWeightMod == null) return;
			resultWeightMod = mResultWeightMod;
		};

		const updateDisplay = () => {
			const renderedHeight = Renderer.race.getRenderedHeight(race.heightAndWeight.baseHeight + resultHeight);
			const totalWeight = race.heightAndWeight.baseWeight + (resultWeightMod * resultHeight);
			$dispHeight.text(renderedHeight);
			$dispWeight.text(Number(totalWeight.toFixed(3)));
		};

		const pDoFullRoll = async isPreLocked => {
			try {
				if (!isPreLocked) await lock.pLock();

				$btnRoll.parent().removeClass(`ve-flex-vh-center`).addClass(`split-v-center`);
				await pRollHeight();
				await pRollWeight();
				$dispResult.removeClass(`ve-hidden`);
				updateDisplay();

				hasRolled = true;
			} finally {
				if (!isPreLocked) lock.unlock();
			}
		};
	},

	bindListenersCompact (race, ele) {
		Renderer.race.bindListenersHeightAndWeight(race, ele);
	},

	pGetFluff (race) {
		return Renderer.utils.pGetFluff({
			entity: race,
			fnGetFluffData: DataUtil.raceFluff.loadJSON.bind(DataUtil.raceFluff),
			fluffProp: "raceFluff",
		});
	},
};

Renderer.raceFeature = {
	getCompactRenderedString (ent) {
		return Renderer.generic.getCompactRenderedString(ent);
	},
};

Renderer.deity = {
	_basePartTranslators: {
		"Alignment": {
			prop: "alignment",
			displayFn: (it) => it.map(a => Parser.alignmentAbvToFull(a)).join(" ").toTitleCase(),
		},
		"Pantheon": {
			prop: "pantheon",
		},
		"Category": {
			prop: "category",
			displayFn: it => typeof it === "string" ? it : it.join(", "),
		},
		"Domains": {
			prop: "domains",
			displayFn: (it) => it.join(", "),
		},
		"Province": {
			prop: "province",
		},
		"Alternate Names": {
			prop: "altNames",
			displayFn: (it) => it.join(", "),
		},
		"Symbol": {
			prop: "symbol",
		},
	},
	getOrderedParts (deity, prefix, suffix) {
		const parts = {};
		Object.entries(Renderer.deity._basePartTranslators).forEach(([k, v]) => {
			const val = deity[v.prop];
			if (val != null) {
				const outVal = v.displayFn ? v.displayFn(val) : val;
				parts[k] = outVal;
			}
		});
		if (deity.customProperties) Object.entries(deity.customProperties).forEach(([k, v]) => parts[k] = v);
		const allKeys = Object.keys(parts).sort(SortUtil.ascSortLower);
		return allKeys.map(k => `${prefix}<b>${k}: </b>${Renderer.get().render(parts[k])}${suffix}`).join("");
	},

	getCompactRenderedString (deity) {
		const renderer = Renderer.get();
		return `
			${Renderer.utils.getExcludedTr({entity: deity, dataProp: "deity", page: UrlUtil.PG_DEITIES})}
			${Renderer.utils.getNameTr(deity, {suffix: deity.title ? `, ${deity.title.toTitleCase()}` : "", page: UrlUtil.PG_DEITIES})}
			<tr><td colspan="6">
				<div class="rd__compact-stat">${Renderer.deity.getOrderedParts(deity, `<p>`, `</p>`)}</div>
			</td>
			${deity.entries ? `<tr><td colspan="6"><div class="border"></div></td></tr><tr><td colspan="6">${renderer.render({entries: deity.entries}, 1)}</td></tr>` : ""}
		`;
	},
};

Renderer.object = {
	CHILD_PROPS: ["actionEntries"],

	getCompactRenderedString (obj, opts) {
		return Renderer.object.getRenderedString(obj, {...opts, isCompact: true});
	},

	getRenderedString (obj, opts) {
		opts = opts || {};

		const renderer = Renderer.get().setFirstSection(true);

		const hasToken = obj.tokenUrl || obj.hasToken;
		const extraThClasses = !opts.isCompact && hasToken ? ["objs__name--token"] : null;

		return `
			${Renderer.utils.getExcludedTr({entity: obj, dataProp: "object", page: opts.page || UrlUtil.PG_OBJECTS})}
			${Renderer.utils.getNameTr(obj, {page: opts.page || UrlUtil.PG_OBJECTS, extraThClasses, isEmbeddedEntity: opts.isEmbeddedEntity})}
			<tr class="text"><td colspan="6"><i>${obj.objectType !== "GEN" ? `${Parser.sizeAbvToFull(obj.size)} ${obj.creatureType ? Parser.monTypeToFullObj(obj.creatureType).asText : "object"}` : `Variable size object`}</i><br></td></tr>
			<tr class="text"><td colspan="6">
				${obj.capCrew != null || obj.capPassenger != null ? `<b>Creature Capacity:</b> ${Renderer.vehicle.getShipCreatureCapacity(obj)}<br>` : ""}
				${obj.capCargo != null ? `<b>Cargo Capacity:</b> ${Renderer.vehicle.getShipCargoCapacity(obj)}</br>` : ""}
				${obj.ac != null ? `<b>Armor Class:</b> ${obj.ac.special ?? obj.ac}<br>` : ""}
				${obj.hp != null ? `<b>Hit Points:</b> ${obj.hp.special ?? obj.hp}<br>` : ""}
				${obj.speed != null ? `<b>Speed:</b> ${Parser.getSpeedString(obj)}<br>` : ""}
				${obj.immune != null ? `<b>Damage Immunities:</b> ${Parser.getFullImmRes(obj.immune)}<br>` : ""}
				${Parser.ABIL_ABVS.some(ab => obj[ab] != null) ? `<b>Ability Scores:</b> ${Parser.ABIL_ABVS.filter(ab => obj[ab] != null).map(ab => renderer.render(`${ab.toUpperCase()} ${Renderer.utils.getAbilityRoller(obj, ab)}`)).join(", ")}` : ""}
				${obj.resist ? `<b>Damage Resistances:</b> ${Parser.getFullImmRes(obj.resist)}<br>` : ""}
				${obj.vulnerable ? `<b>Damage Vulnerabilities:</b> ${Parser.getFullImmRes(obj.vulnerable)}<br>` : ""}
				${obj.conditionImmune ? `<b>Condition Immunities:</b> ${Parser.getFullCondImm(obj.conditionImmune)}<br>` : ""}
			</td></tr>
			<tr class="text"><td colspan="6">
			${obj.entries ? renderer.render({entries: obj.entries}, 2) : ""}
			${obj.actionEntries ? renderer.render({entries: obj.actionEntries}, 2) : ""}
			</td></tr>
		`;
	},

	getTokenUrl (obj) {
		return obj.tokenUrl || UrlUtil.link(`${Renderer.get().baseMediaUrls["img"] || Renderer.get().baseUrl}img/objects/tokens/${Parser.sourceJsonToAbv(obj.source)}/${Parser.nameToTokenName(obj.name)}.png`);
	},

	pGetFluff (obj) {
		return Renderer.utils.pGetFluff({
			entity: obj,
			fnGetFluffData: DataUtil.objectFluff.loadJSON.bind(DataUtil.objectFluff),
			fluffProp: "objectFluff",
		});
	},
};

Renderer.trap = {
	CHILD_PROPS: ["trigger", "effect", "eActive", "eDynamic", "eConstant", "countermeasures"],

	_getTrapEntries (it) {
		return [
						it.trigger ? {
				type: "entries",
				name: "Trigger",
				entries: it.trigger,
			} : null,
			
						it.effect ? {
				type: "entries",
				name: "Effect",
				entries: it.effect,
			} : null,
			
						it.initiative ? {
				type: "entries",
				name: "Initiative",
				entries: Renderer.trap.getTrapInitiativeEntries(it),
			} : null,
			it.eActive ? {
				type: "entries",
				name: "Active Elements",
				entries: it.eActive,
			} : null,
			it.eDynamic ? {
				type: "entries",
				name: "Dynamic Elements",
				entries: it.eDynamic,
			} : null,
			it.eConstant ? {
				type: "entries",
				name: "Constant Elements",
				entries: it.eConstant,
			} : null,
			
						it.countermeasures ? {
				type: "entries",
				name: "Countermeasures",
				entries: it.countermeasures,
			} : null,
					].filter(Boolean);
	},

	getTrapInitiativeEntries (it) { return [`The trap acts on ${Parser.trapInitToFull(it.initiative)}${it.initiativeNote ? ` (${it.initiativeNote})` : ""}.`]; },

	getRenderedTrapPart (renderer, it) {
		const trapEntries = Renderer.trap._getTrapEntries(it);

		if (!trapEntries.length) return "";

		return renderer.render({
			entries: trapEntries,
		}, 1);
	},

	getCompactRenderedString (it, opts) {
		return Renderer.traphazard.getCompactRenderedString(it, opts);
	},
};

Renderer.hazard = {
	getCompactRenderedString (it, opts) {
		return Renderer.traphazard.getCompactRenderedString(it, opts);
	},
};

Renderer.traphazard = {
	getSubtitle (it) {
		const type = it.trapHazType || "HAZ";
		if (type === "GEN") return null;

		const parenPart = [
			it.tier ? Parser.tierToFullLevel(it.tier) : null,
			Renderer.traphazard.getTrapLevelPart(it),
			it.threat ? `${it.threat} threat` : null,
		].filter(Boolean).join(", ");

		return parenPart ? `${Parser.trapHazTypeToFull(type)} (${parenPart})` : Parser.trapHazTypeToFull(type);
	},

	getTrapLevelPart (it) {
		return it.level?.min != null && it.level?.max != null
			? `level ${it.level.min}${it.level.min !== it.level.max ? `\u2013${it.level.max}` : ""}`
			: null;
	},

	getCompactRenderedString (it, opts) {
		opts = opts || {};

		const renderer = Renderer.get();
		const subtitle = Renderer.traphazard.getSubtitle(it);
		return `
			${Renderer.utils.getExcludedTr({entity: it, dataProp: it.__prop, page: UrlUtil.PG_TRAPS_HAZARDS})}
			${Renderer.utils.getNameTr(it, {page: UrlUtil.PG_TRAPS_HAZARDS, isEmbeddedEntity: opts.isEmbeddedEntity})}
			${subtitle ? `<tr class="text"><td colspan="6"><i>${subtitle}</i></td></tr>` : ""}
			<tr class="text"><td colspan="6">
			${renderer.render({entries: it.entries}, 2)}
			${Renderer.trap.getRenderedTrapPart(renderer, it)}
			</td></tr>
		`;
	},
};

Renderer.cultboon = {
	doRenderCultParts (it, renderer, renderStack) {
		if (it.goal || it.cultists || it.signaturespells) {
			const fauxList = {
				type: "list",
				style: "list-hang-notitle",
				items: [],
			};
			if (it.goal) {
				fauxList.items.push({
					type: "item",
					name: "Goals:",
					entry: it.goal.entry,
				});
			}

			if (it.cultists) {
				fauxList.items.push({
					type: "item",
					name: "Typical Cultists:",
					entry: it.cultists.entry,
				});
			}
			if (it.signaturespells) {
				fauxList.items.push({
					type: "item",
					name: "Signature Spells:",
					entry: it.signaturespells.entry,
				});
			}
			renderer.recursiveRender(fauxList, renderStack, {depth: 2});
		}
	},

	doRenderBoonParts (it, renderer, renderStack) {
		const benefits = {type: "list", style: "list-hang-notitle", items: []};
		if (it.ability) {
			benefits.items.push({
				type: "item",
				name: "Ability Score Adjustment:",
				entry: it.ability ? it.ability.entry : "None",
			});
		}
		if (it.signaturespells) {
			benefits.items.push({
				type: "item",
				name: "Signature Spells:",
				entry: it.signaturespells ? it.signaturespells.entry : "None",
			});
		}
		if (benefits.items.length) renderer.recursiveRender(benefits, renderStack, {depth: 1});
	},

	getCompactRenderedString (it) {
		const renderer = Renderer.get();

		const renderStack = [];
		if (it.__prop === "cult") {
			Renderer.cultboon.doRenderCultParts(it, renderer, renderStack);
			renderer.recursiveRender({entries: it.entries}, renderStack, {depth: 2});
			return `
			${Renderer.utils.getExcludedTr({entity: it, dataProp: "cult", page: UrlUtil.PG_CULTS_BOONS})}
			${Renderer.utils.getNameTr(it, {page: UrlUtil.PG_CULTS_BOONS})}
			<tr id="text"><td class="divider" colspan="6"><div></div></td></tr>
			<tr class="text"><td colspan="6" class="text">${renderStack.join("")}</td></tr>`;
		} else if (it.__prop === "boon") {
			Renderer.cultboon.doRenderBoonParts(it, renderer, renderStack);
			renderer.recursiveRender({entries: it.entries}, renderStack, {depth: 1});
			it._displayName = it._displayName || it.name;
			return `
			${Renderer.utils.getExcludedTr({entity: it, dataProp: "boon", page: UrlUtil.PG_CULTS_BOONS})}
			${Renderer.utils.getNameTr(it, {page: UrlUtil.PG_CULTS_BOONS})}
			<tr class="text"><td colspan="6">${renderStack.join("")}</td></tr>`;
		}
	},
};

Renderer.monster = {
	CHILD_PROPS: ["action", "bonus", "reaction", "trait", "legendary", "mythic", "variant", "spellcasting"],

	getShortName (mon, {isTitleCase = false, isSentenceCase = false, isUseDisplayName = false} = {}) {
		const name = isUseDisplayName ? (mon._displayName ?? mon.name) : mon.name;
		const shortName = isUseDisplayName ? (mon._displayShortName ?? mon.shortName) : mon.shortName;

		const prefix = mon.isNamedCreature ? "" : isTitleCase || isSentenceCase ? "The " : "the ";
		if (shortName === true) return `${prefix}${name}`;
		else if (shortName) return `${prefix}${!prefix && isTitleCase ? shortName.toTitleCase() : shortName.toLowerCase()}`;

		const out = Renderer.monster.getShortNameFromName(name, {isNamedCreature: mon.isNamedCreature});
		return `${prefix}${out}`;
	},

	getShortNameFromName (name, {isNamedCreature = false} = {}) {
		const base = name.split(",")[0];
		let out = base
			.replace(/(?:adult|ancient|young) \w+ (dragon|dracolich)/gi, "$1");
		out = isNamedCreature ? out.split(" ")[0] : out.toLowerCase();
		return out;
	},

	getLegendaryActionIntro (mon, {renderer = Renderer.get(), isUseDisplayName = false} = {}) {
		if (mon.legendaryHeader) {
			return renderer.render({entries: mon.legendaryHeader});
		} else {
			const legendaryActions = mon.legendaryActions || 3;
			const legendaryNameTitle = Renderer.monster.getShortName(mon, {isTitleCase: true, isUseDisplayName});
			return `${legendaryNameTitle} can take ${legendaryActions} legendary action${legendaryActions > 1 ? "s" : ""}, choosing from the options below. Only one legendary action can be used at a time and only at the end of another creature's turn. ${legendaryNameTitle} regains spent legendary actions at the start of its turn.`;
		}
	},

	getSectionIntro (mon, {renderer = Renderer.get(), prop}) {
		const headerProp = `${prop}Header`;
		if (mon[headerProp]) return renderer.render({entries: mon[headerProp]});
		return "";
	},

	getSave (renderer, attr, mod) {
		if (attr === "special") return renderer.render(mod);
		return renderer.render(`<span>${attr.uppercaseFirst()} {@savingThrow ${attr} ${mod}}</span>`);
	},

	dragonCasterVariant: {
				_LVL_TO_COLOR_TO_SPELLS__UNOFFICIAL: {
			2: {
				black: ["darkness", "Melf's acid arrow", "fog cloud", "scorching ray"],
				green: ["ray of sickness", "charm person", "detect thoughts", "invisibility", "suggestion"],
				white: ["ice knife|XGE", "Snilloc's snowball swarm|XGE"],
				brass: ["see invisibility", "magic mouth", "blindness/deafness", "sleep", "detect thoughts"],
				bronze: ["gust of wind", "misty step", "locate object", "blur", "witch bolt", "thunderwave", "shield"],
				copper: ["knock", "sleep", "detect thoughts", "blindness/deafness", "tasha's hideous laughter"],
			},
			3: {
				blue: ["wall of sand|XGE", "thunder step|XGE", "lightning bolt", "blink", "magic missile", "slow"],
				red: ["fireball", "scorching ray", "haste", "erupting earth|XGE", "Aganazzar's scorcher|XGE"],
				gold: ["slow", "fireball", "dispel magic", "counterspell", "Aganazzar's scorcher|XGE", "shield"],
				silver: ["sleet storm", "protection from energy", "catnap|XGE", "locate object", "identify", "Leomund's tiny hut"],
			},
			4: {
				black: ["vitriolic sphere|XGE", "sickening radiance|XGE", "Evard's black tentacles", "blight", "hunger of Hadar"],
				white: ["fire shield", "ice storm", "sleet storm"],
				brass: ["charm monster|XGE", "sending", "wall of sand|XGE", "hypnotic pattern", "tongues"],
				copper: ["polymorph", "greater invisibility", "confusion", "stinking cloud", "major image", "charm monster|XGE"],
			},
			5: {
				blue: ["telekinesis", "hold monster", "dimension door", "wall of stone", "wall of force"],
				green: ["cloudkill", "charm monster|XGE", "modify memory", "mislead", "hallucinatory terrain", "dimension door"],
				bronze: ["steel wind strike|XGE", "control winds|XGE", "watery sphere|XGE", "storm sphere|XGE", "tidal wave|XGE"],
				gold: ["hold monster", "immolation|XGE", "wall of fire", "greater invisibility", "dimension door"],
				silver: ["cone of cold", "ice storm", "teleportation circle", "skill empowerment|XGE", "creation", "Mordenkainen's private sanctum"],
			},
			6: {
				white: ["cone of cold", "wall of ice"],
				brass: ["scrying", "Rary's telepathic bond", "Otto's irresistible dance", "legend lore", "hold monster", "dream"],
			},
			7: {
				black: ["power word pain|XGE", "finger of death", "disintegrate", "hold monster"],
				blue: ["chain lightning", "forcecage", "teleport", "etherealness"],
				green: ["project image", "mirage arcane", "prismatic spray", "teleport"],
				bronze: ["whirlwind|XGE", "chain lightning", "scatter|XGE", "teleport", "disintegrate", "lightning bolt"],
				copper: ["symbol", "simulacrum", "reverse gravity", "project image", "Bigby's hand", "mental prison|XGE", "seeming"],
				silver: ["Otiluke's freezing sphere", "prismatic spray", "wall of ice", "contingency", "arcane gate"],
			},
			8: {
				gold: ["sunburst", "delayed blast fireball", "antimagic field", "teleport", "globe of invulnerability", "maze"],
			},
		},
				_LVL_TO_COLOR_TO_SPELLS__FTD: {
			1: {
				deep: ["command", "dissonant whispers", "faerie fire"],
			},
			2: {
				black: ["blindness/deafness", "create or destroy water"],
				green: ["invisibility", "speak with animals"],
				white: ["gust of wind"],
				brass: ["create or destroy water", "speak with animals"],
				bronze: ["beast sense", "detect thoughts", "speak with animals"],
				copper: ["lesser restoration", "phantasmal force"],
			},
			3: {
				blue: ["create or destroy water", "major image"],
				red: ["bane", "heat metal", "hypnotic pattern", "suggestion"],
				gold: ["bless", "cure wounds", "slow", "suggestion", "zone of truth"],
				silver: ["beacon of hope", "calm emotions", "hold person", "zone of truth"],
				deep: ["command", "dissonant whispers", "faerie fire", "water breathing"],
			},
			4: {
				black: ["blindness/deafness", "create or destroy water", "plant growth"],
				white: ["gust of wind"],
				brass: ["create or destroy water", "speak with animals", "suggestion"],
				copper: ["lesser restoration", "phantasmal force", "stone shape"],
			},
			5: {
				blue: ["arcane eye", "create or destroy water", "major image"],
				red: ["bane", "dominate person", "heat metal", "hypnotic pattern", "suggestion"],
				green: ["invisibility", "plant growth", "speak with animals"],
				bronze: ["beast sense", "control water", "detect thoughts", "speak with animals"],
				gold: ["bless", "commune", "cure wounds", "geas", "slow", "suggestion", "zone of truth"],
				silver: ["beacon of hope", "calm emotions", "hold person", "polymorph", "zone of truth"],
			},
			6: {
				white: ["gust of wind", "ice storm"],
				brass: ["create or destroy water", "locate creature", "speak with animals", "suggestion"],
				deep: ["command", "dissonant whispers", "faerie fire", "passwall", "water breathing"],
			},
			7: {
				black: ["blindness/deafness", "create or destroy water", "insect plague", "plant growth"],
				blue: ["arcane eye", "create or destroy water", "major image", "project image"],
				red: ["bane", "dominate person", "heat metal", "hypnotic pattern", "power word stun", "suggestion"],
				green: ["invisibility", "mass suggestion", "plant growth", "speak with animals"],
				bronze: ["beast sense", "control water", "detect thoughts", "heroes' feast", "speak with animals"],
				copper: ["lesser restoration", "move earth", "phantasmal force", "stone shape"],
				silver: ["beacon of hope", "calm emotions", "hold person", "polymorph", "teleport", "zone of truth"],
			},
			8: {
				gold: ["bless", "commune", "cure wounds", "geas", "plane shift", "slow", "suggestion", "word of recall", "zone of truth"],
			},
		},

		getAvailableColors () {
			const out = new Set();

			const add = (lookup) => Object.values(lookup).forEach(obj => Object.keys(obj).forEach(k => out.add(k)));
			add(Renderer.monster.dragonCasterVariant._LVL_TO_COLOR_TO_SPELLS__UNOFFICIAL);
			add(Renderer.monster.dragonCasterVariant._LVL_TO_COLOR_TO_SPELLS__FTD);

			return [...out].sort(SortUtil.ascSortLower);
		},

		hasCastingColorVariant (dragon) {
						return dragon.dragonCastingColor && !dragon.spellcasting;
		},

		getMeta (dragon) {
			const chaMod = Parser.getAbilityModNumber(dragon.cha);
			const pb = Parser.crToPb(dragon.cr);
			const maxSpellLevel = Math.floor(Parser.crToNumber(dragon.cr) / 3);

			return {
				chaMod,
				pb,
				maxSpellLevel,
				spellSaveDc: pb + chaMod + 8,
				spellToHit: pb + chaMod,
				exampleSpellsUnofficial: Renderer.monster.dragonCasterVariant._getMeta_getExampleSpells({
					dragon,
					maxSpellLevel,
					spellLookup: Renderer.monster.dragonCasterVariant._LVL_TO_COLOR_TO_SPELLS__UNOFFICIAL,
				}),
				exampleSpellsFtd: Renderer.monster.dragonCasterVariant._getMeta_getExampleSpells({
					dragon,
					maxSpellLevel,
					spellLookup: Renderer.monster.dragonCasterVariant._LVL_TO_COLOR_TO_SPELLS__FTD,
				}),
			};
		},

		_getMeta_getExampleSpells ({dragon, maxSpellLevel, spellLookup}) {
			if (spellLookup[maxSpellLevel]?.[dragon.dragonCastingColor]) return spellLookup[maxSpellLevel][dragon.dragonCastingColor];

						const flatKeys = Object.entries(spellLookup)
				.map(([lvl, group]) => {
					return Object.keys(group)
						.map(color => `${lvl}${color}`);
				})
				.flat()
				.mergeMap(it => ({[it]: true}));

			while (--maxSpellLevel > -1) {
				const lookupKey = `${maxSpellLevel}${dragon.dragonCastingColor}`;
				if (flatKeys[lookupKey]) return spellLookup[maxSpellLevel][dragon.dragonCastingColor];
			}
			return [];
		},

		getSpellcasterDetailsPart ({chaMod, maxSpellLevel, spellSaveDc, spellToHit, isSeeSpellsPageNote = false}) {
			const levelString = maxSpellLevel === 0 ? `${chaMod === 1 ? "This" : "These"} spells are Cantrips.` : `${chaMod === 1 ? "The" : "Each"} spell's level can be no higher than ${Parser.spLevelToFull(maxSpellLevel)}.`;

			return `This dragon can innately cast ${Parser.numberToText(chaMod)} spell${chaMod === 1 ? "" : "s"}, once per day${chaMod === 1 ? "" : " each"}, requiring no material components. ${levelString} The dragon's spell save DC is {@dc ${spellSaveDc}}, and it has {@hit ${spellToHit}} to hit with spell attacks.${isSeeSpellsPageNote ? ` See the {@filter spell page|spells|level=${[...new Array(maxSpellLevel + 1)].map((it, i) => i).join(";")}} for a list of spells the dragon is capable of casting.` : ""}`;
		},

		getVariantEntries (dragon) {
			if (!Renderer.monster.dragonCasterVariant.hasCastingColorVariant(dragon)) return [];

			const meta = Renderer.monster.dragonCasterVariant.getMeta(dragon);
			const {exampleSpellsUnofficial, exampleSpellsFtd} = meta;

			const vFtd = exampleSpellsFtd?.length ? {
				type: "variant",
				name: "Dragons as Innate Spellcasters",
				source: Parser.SRC_FTD,
				entries: [
					`${Renderer.monster.dragonCasterVariant.getSpellcasterDetailsPart(meta)}`,
					`A suggested spell list is shown below, but you can also choose spells to reflect the dragon's character. A dragon who innately casts {@filter druid|spells|class=druid} spells feels different from one who casts {@filter warlock|spells|class=warlock} spells. You can also give a dragon spells of a higher level than this rule allows, but such a tweak might increase the dragon's challenge rating\u2014especially if those spells deal damage or impose conditions on targets.`,
					{
						type: "list",
						items: exampleSpellsFtd.map(it => `{@spell ${it}}`),
					},
				],
			} : null;

			const vBasic = {
				type: "variant",
				name: "Dragons as Innate Spellcasters",
				entries: [
					"Dragons are innately magical creatures that can master a few spells as they age, using this variant.",
					`A young or older dragon can innately cast a number of spells equal to its Charisma modifier. Each spell can be cast once per day, requiring no material components, and the spell's level can be no higher than one-third the dragon's challenge rating (rounded down). The dragon's bonus to hit with spell attacks is equal to its proficiency bonus + its Charisma bonus. The dragon's spell save DC equals 8 + its proficiency bonus + its Charisma modifier.`,
					`{@note ${Renderer.monster.dragonCasterVariant.getSpellcasterDetailsPart({...meta, isSeeSpellsPageNote: true})}${exampleSpellsUnofficial?.length ? ` A selection of examples are shown below:` : ""}}`,
				],
			};
			if (dragon.source !== Parser.SRC_MM) {
				vBasic.source = Parser.SRC_MM;
				vBasic.page = 86;
			}
			if (exampleSpellsUnofficial) {
				const ls = {
					type: "list",
					style: "list-italic",
					items: exampleSpellsUnofficial.map(it => `{@spell ${it}}`),
				};
				vBasic.entries.push(ls);
			}

			return [vFtd, vBasic].filter(Boolean);
		},

		getHtml (dragon, {renderer = null} = {}) {
			const variantEntrues = Renderer.monster.dragonCasterVariant.getVariantEntries(dragon);
			if (!variantEntrues.length) return null;
			return variantEntrues.map(it => renderer.render(it)).join("");
		},
	},

	getCrScaleTarget (
		{
			win,
			$btnScale,
			initialCr,
			cbRender,
			isCompact,
		},
	) {
		const evtName = "click.cr-scaler";

		let slider;

		const $body = $(win.document.body);
		function cleanSliders () {
			$body.find(`.mon__cr_slider_wrp`).remove();
			$btnScale.off(evtName);
			if (slider) slider.destroy();
		}

		cleanSliders();

		const $wrp = $(`<div class="mon__cr_slider_wrp ${isCompact ? "mon__cr_slider_wrp--compact" : ""}"></div>`);

		const cur = Parser.CRS.indexOf(initialCr);
		if (cur === -1) throw new Error(`Initial CR ${initialCr} was not valid!`);

		const comp = BaseComponent.fromObject({
			min: 0,
			max: Parser.CRS.length - 1,
			cur,
		});
		slider = new ComponentUiUtil.RangeSlider({
			comp,
			propMin: "min",
			propMax: "max",
			propCurMin: "cur",
			fnDisplay: ix => Parser.CRS[ix],
		});
		slider.$get().appendTo($wrp);

		$btnScale.off(evtName).on(evtName, (evt) => evt.stopPropagation());
		$wrp.on(evtName, (evt) => evt.stopPropagation());
		$body.off(evtName).on(evtName, cleanSliders);

		comp._addHookBase("cur", () => {
			cbRender(Parser.crToNumber(Parser.CRS[comp._state.cur]));
			$body.off(evtName);
			cleanSliders();
		});

		$btnScale.after($wrp);
	},

	getSelSummonSpellLevel (mon) {
		if (mon.summonedBySpellLevel == null) return;

		return e_({
			tag: "select",
			clazz: "input-xs form-control form-control--minimal w-initial inline-block ve-popwindow__hidden",
			name: "mon__sel-summon-spell-level",
			children: [
				e_({tag: "option", val: "-1", text: "\u2014"}),
				...[...new Array(VeCt.SPELL_LEVEL_MAX + 1 - mon.summonedBySpellLevel)].map((_, i) => e_({
					tag: "option",
					val: i + mon.summonedBySpellLevel,
					text: i + mon.summonedBySpellLevel,
				})),
			],
		});
	},

	getSelSummonClassLevel (mon) {
		if (mon.summonedByClass == null) return;

		return e_({
			tag: "select",
			clazz: "input-xs form-control form-control--minimal w-initial inline-block ve-popwindow__hidden",
			name: "mon__sel-summon-class-level",
			children: [
				e_({tag: "option", val: "-1", text: "\u2014"}),
				...[...new Array(VeCt.LEVEL_MAX)].map((_, i) => e_({
					tag: "option",
					val: i + 1,
					text: i + 1,
				})),
			],
		});
	},

	getCompactRenderedStringSection (mon, renderer, title, key, depth) {
		if (!mon[key]) return "";

		const noteKey = `${key}Note`;

		const toRender = key === "lairActions" || key === "regionalEffects"
			? [{type: "entries", entries: mon[key]}]
			: mon[key];

		const ptHeader = mon[key] ? Renderer.monster.getSectionIntro(mon, {prop: key}) : "";

		return `<tr class="mon__stat-header-underline"><td colspan="6"><h3 class="mon__sect-header-inner">${title}${mon[noteKey] ? ` (<span class="ve-small">${mon[noteKey]}</span>)` : ""}</h3></td></tr>
		<tr class="text"><td colspan="6">
		${key === "legendary" && mon.legendary ? `<p>${Renderer.monster.getLegendaryActionIntro(mon)}</p>` : ""}
		${ptHeader ? `<p>${ptHeader}</p>` : ""}
		${toRender.map(it => it.rendered || renderer.render(it, depth)).join("")}
		</td></tr>`;
	},

	getTypeAlignmentPart (mon) {
		const typeObj = Parser.monTypeToFullObj(mon.type);

		return `${mon.level ? `${Parser.getOrdinalForm(mon.level)}-level ` : ""}${typeObj.asTextSidekick ? `${typeObj.asTextSidekick}; ` : ""}${Renderer.utils.getRenderedSize(mon.size)}${mon.sizeNote ? ` ${mon.sizeNote}` : ""} ${typeObj.asText}${mon.alignment ? `, ${mon.alignmentPrefix ? Renderer.get().render(mon.alignmentPrefix) : ""}${Parser.alignmentListToFull(mon.alignment).toTitleCase()}` : ""}`;
	},
	getSavesPart (mon) { return `${Object.keys(mon.save || {}).sort(SortUtil.ascSortAtts).map(s => Renderer.monster.getSave(Renderer.get(), s, mon.save[s])).join(", ")}`; },
	getSensesPart (mon) { return `${mon.senses ? `${Renderer.monster.getRenderedSenses(mon.senses)}, ` : ""}passive Perception ${mon.passive || "\u2014"}`; },

	getRenderWithPlugins ({renderer, mon, fn}) {
		return renderer.withPlugin({
			pluginTypes: [
				"dice",
			],
			fnPlugin: () => {
				if (mon.summonedBySpellLevel == null && mon._summonedByClass_level == null) return null;
				if (mon._summonedByClass_level) {
					return {
						additionalData: {
							"data-summoned-by-class-level": mon._summonedByClass_level,
						},
					};
				}
				return {
					additionalData: {
						"data-summoned-by-spell-level": mon._summonedBySpell_level ?? mon.summonedBySpellLevel,
					},
				};
			},
			fn,
		});
	},

		getCompactRenderedString (mon, opts) {
		const renderer = Renderer.get();
		return Renderer.monster.getRenderWithPlugins({
			renderer,
			mon,
			fn: () => Renderer.monster._getCompactRenderedString(mon, renderer, opts),
		});
	},

	_getCompactRenderedString (mon, renderer, opts) {
		opts = opts || {};
		if (opts.isCompact === undefined) opts.isCompact = true;

		const renderStack = [];
		const legGroup = DataUtil.monster.getMetaGroup(mon);
		const hasToken = mon.tokenUrl || mon.hasToken;
		const extraThClasses = !opts.isCompact && hasToken ? ["mon__name--token"] : null;

		const isCr = Parser.crToNumber(mon.cr) !== VeCt.CR_UNKNOWN;
		const isShowSpellLevelScaler = opts.isShowScalers && !isCr && mon.summonedBySpellLevel != null;
		const isShowClassLevelScaler = opts.isShowScalers && !isShowSpellLevelScaler && mon.summonedByClass != null;

		const fnGetSpellTraits = Renderer.monster.getSpellcastingRenderedTraits.bind(Renderer.monster, renderer);
		const allTraits = Renderer.monster.getOrderedTraits(mon, {fnGetSpellTraits});
		const allActions = Renderer.monster.getOrderedActions(mon, {fnGetSpellTraits});
		const allBonusActions = Renderer.monster.getOrderedBonusActions(mon, {fnGetSpellTraits});
		const allReactions = Renderer.monster.getOrderedReactions(mon, {fnGetSpellTraits});

		let ptCrSpellLevel = `<td colspan="2">\u2014</td>`;
		if (isShowSpellLevelScaler || isShowClassLevelScaler) {
									const selHtml = isShowSpellLevelScaler ? Renderer.monster.getSelSummonSpellLevel(mon)?.outerHTML : Renderer.monster.getSelSummonClassLevel(mon)?.outerHTML;
			ptCrSpellLevel = `<td colspan="2">${selHtml || ""}</td>`;
		} else if (isCr && ScaleCreature.isCrInScaleRange(mon)) {
			ptCrSpellLevel = `<td colspan="2">
				${Parser.monCrToFull(mon.cr, {isMythic: !!mon.mythic})}
				${opts.isShowScalers && !opts.isScaledCr && Parser.isValidCr(mon.cr ? (mon.cr.cr || mon.cr) : null) ? `
				<button title="Scale Creature By CR (Highly Experimental)" class="mon__btn-scale-cr btn btn-xs btn-default">
					<span class="glyphicon glyphicon-signal"></span>
				</button>
				` : ""}
				${opts.isScaledCr ? `
				<button title="Reset CR Scaling" class="mon__btn-reset-cr btn btn-xs btn-default">
					<span class="glyphicon glyphicon-refresh"></span>
				</button>
				` : ""}
			</td>`;
		}

		renderStack.push(`
			${Renderer.utils.getExcludedTr({entity: mon, dataProp: "monster", page: opts.page || UrlUtil.PG_BESTIARY})}
			${Renderer.utils.getNameTr(mon, {page: opts.page || UrlUtil.PG_BESTIARY, extensionData: {_scaledCr: mon._scaledCr, _scaledSpellSummonLevel: mon._scaledSpellSummonLevel, _scaledClassSummonLevel: mon._scaledClassSummonLevel}, extraThClasses, isEmbeddedEntity: opts.isEmbeddedEntity})}
			<tr><td colspan="6"><i>${Renderer.monster.getTypeAlignmentPart(mon)}</i></td></tr>
			<tr><td colspan="6"><div class="border"></div></td></tr>
			<tr><td colspan="6">
				<table class="w-100 summary-noback relative table-layout-fixed my-1">
					<tr>
						<th colspan="2">Armor Class</th>
						<th colspan="2">Hit Points</th>
						<th colspan="2">Speed</th>
						<th colspan="2">${isShowSpellLevelScaler ? "Spell Level" : isShowClassLevelScaler ? "Class Level" : "Challenge"}</th>
						${mon.pbNote || Parser.crToNumber(mon.cr) < VeCt.CR_CUSTOM ? `<th colspan="1" title="Proficiency Bonus">PB</th>` : ""}
						${hasToken && !opts.isCompact ? `<th colspan="1"></th>` : ""}
					</tr>
					<tr>
						<td colspan="2">${Parser.acToFull(mon.ac)}</td>
						<td colspan="2">${Renderer.monster.getRenderedHp(mon.hp)}</td>
						<td colspan="2">${Parser.getSpeedString(mon)}</td>
						${ptCrSpellLevel}
						${mon.pbNote || Parser.crToNumber(mon.cr) < VeCt.CR_CUSTOM ? `<td colspan="1">${mon.pbNote ?? UiUtil.intToBonus(Parser.crToPb(mon.cr), {isPretty: true})}</td>` : ""}
						${hasToken && !opts.isCompact ? `<td colspan="1"></td>` : ""}
					</tr>
				</table>
			</td></tr>
			<tr><td colspan="6"><div class="border mb-1"></div></td></tr>
			${Renderer.monster.getRenderedAbilityScores(mon)}
			<tr><td colspan="6"><div class="border mt-1"></div></td></tr>
			<tr><td colspan="6">
				<div class="rd__compact-stat mt-2">
					${mon.resource ? mon.resource.map(res => `<p><b>${res.name}</b> ${Renderer.monster.getRenderedResource(res)}</p>`).join("") : ""}
					${mon.save ? `<p><b>Saving Throws</b> ${Renderer.monster.getSavesPart(mon)}</p>` : ""}
					${mon.skill ? `<p><b>Skills</b> ${Renderer.monster.getSkillsString(renderer, mon)}</p>` : ""}
					${mon.vulnerable ? `<p><b>Damage Vuln.</b> ${Parser.getFullImmRes(mon.vulnerable)}</p>` : ""}
					${mon.resist ? `<p><b>Damage Res.</b> ${Parser.getFullImmRes(mon.resist)}</p>` : ""}
					${mon.immune ? `<p><b>Damage Imm.</b> ${Parser.getFullImmRes(mon.immune)}</p>` : ""}
					${mon.conditionImmune ? `<p><b>Condition Imm.</b> ${Parser.getFullCondImm(mon.conditionImmune)}</p>` : ""}
					${opts.isHideSenses ? "" : `<p><b>Senses</b> ${Renderer.monster.getSensesPart(mon)}</p>`}
					${opts.isHideLanguages ? "" : `<p><b>Languages</b> ${Renderer.monster.getRenderedLanguages(mon.languages)}</p>`}
				</div>
			</td></tr>
			${allTraits ? `<tr><td colspan="6"><div class="border"></div></td></tr>
			<tr class="text"><td colspan="6">
			${allTraits.map(it => it.rendered || renderer.render(it, 2)).join("")}
			</td></tr>` : ""}
			${Renderer.monster.getCompactRenderedStringSection({...mon, action: allActions}, renderer, "Actions", "action", 2)}
			${Renderer.monster.getCompactRenderedStringSection({...mon, bonus: allBonusActions}, renderer, "Bonus Actions", "bonus", 2)}
			${Renderer.monster.getCompactRenderedStringSection({...mon, reaction: allReactions}, renderer, "Reactions", "reaction", 2)}
			${Renderer.monster.getCompactRenderedStringSection(mon, renderer, "Legendary Actions", "legendary", 2)}
			${Renderer.monster.getCompactRenderedStringSection(mon, renderer, "Mythic Actions", "mythic", 2)}
			${legGroup && legGroup.lairActions ? Renderer.monster.getCompactRenderedStringSection(legGroup, renderer, "Lair Actions", "lairActions", 1) : ""}
			${legGroup && legGroup.regionalEffects ? Renderer.monster.getCompactRenderedStringSection(legGroup, renderer, "Regional Effects", "regionalEffects", 1) : ""}
			${mon.variant || (mon.dragonCastingColor && !mon.spellcasting) || mon.summonedBySpell ? `
			<tr class="text"><td colspan="6">
			${mon.variant ? mon.variant.map(it => it.rendered || renderer.render(it)).join("") : ""}
			${mon.dragonCastingColor ? Renderer.monster.dragonCasterVariant.getHtml(mon, {renderer}) : ""}
			${mon.footer ? renderer.render({entries: mon.footer}) : ""}
			${mon.summonedBySpell ? `<div><b>Summoned By:</b> ${renderer.render(`{@spell ${mon.summonedBySpell}}`)}<div>` : ""}
			</td></tr>
			` : ""}
		`);

		return renderStack.join("");
	},

	_getFormulaMax (formula) {
		return Renderer.dice.parseRandomise2(`dmax(${formula})`);
	},

	getRenderedHp: (hp, isPlainText) => {
		if (hp.special != null) return isPlainText ? Renderer.stripTags(hp.special) : Renderer.get().render(hp.special);

		if (/^\d+d1$/.exec(hp.formula)) {
			return hp.average;
		}

		if (isPlainText) return `${hp.average} (${hp.formula})`;

		const maxVal = Renderer.monster._getFormulaMax(hp.formula);
		const maxStr = maxVal ? `Maximum: ${maxVal}` : "";
		return `${maxStr ? `<span title="${maxStr}" class="help-subtle">` : ""}${hp.average}${maxStr ? "</span>" : ""} ${Renderer.get().render(`({@dice ${hp.formula}|${hp.formula}|Hit Points})`)}`;
	},

	getRenderedResource (res, isPlainText) {
		if (!res.formula) return `${res.value}`;

		if (isPlainText) return `${res.value} (${res.formula})`;

		const maxVal = Renderer.monster._getFormulaMax(res.formula);
		const maxStr = maxVal ? `Maximum: ${maxVal}` : "";
		return `${maxStr ? `<span title="${maxStr}" class="help-subtle">` : ""}${res.value}${maxStr ? "</span>" : ""} ${Renderer.get().render(`({@dice ${res.formula}|${res.formula}|${res.name}})`)}`;
	},

	getSafeAbilityScore (mon, abil, {isDefaultTen = false} = {}) {
		if (!mon) return isDefaultTen ? 10 : 0;
		if (mon[abil] == null) return isDefaultTen ? 10 : 0;
		return typeof mon[abil] === "number" ? mon[abil] : (isDefaultTen ? 10 : 0);
	},

	getRenderedAbilityScores (mon) {
		const byAbil = {};
		const byValue = {};

		Parser.ABIL_ABVS
			.forEach(ab => {
				if (mon[ab] == null || typeof mon[ab] === "number") return;

				const meta = {abil: ab, value: mon[ab].special};
				byAbil[meta.abil] = meta;
				meta.family = (byValue[meta.value] = byValue[meta.value] || []);
				meta.family.push(meta);
			});

		const seenAbs = new Set();
		const ptSpecial = Parser.ABIL_ABVS
			.map(ab => {
				const meta = byAbil[ab];
				if (!meta) return null;
				if (seenAbs.has(meta.abil)) return null;
				meta.family.forEach(meta => seenAbs.add(meta.abil));
				return `<b>${meta.family.map(meta => meta.abil.toUpperCase()).join(", ")}</b> ${meta.value}`;
			})
			.filter(Boolean)
			.map(r => `<tr><td colspan="6">${r}</td></tr>`).join("");

		if (Parser.ABIL_ABVS.every(ab => mon[ab] != null && typeof mon[ab] !== "number")) return ptSpecial;

		const absRemaining = Parser.ABIL_ABVS.filter(ab => !seenAbs.has(ab));

		return `<tr>
			${absRemaining.map(ab => `<th class="col-2 text-center bold">${ab.toUpperCase()}</th>`).join("")}
		</tr>
		<tr>
			${absRemaining.map(ab => `<td class="text-center">${Renderer.utils.getAbilityRoller(mon, ab)}</td>`).join("")}
		</tr>`;
	},

	getSpellcastingRenderedTraits: (renderer, mon, displayAsProp = "trait") => {
		const out = [];
		(mon.spellcasting || []).filter(it => (it.displayAs || "trait") === displayAsProp).forEach(entry => {
			entry.type = entry.type || "spellcasting";
			const renderStack = [];
			renderer.recursiveRender(entry, renderStack, {depth: 2});
			out.push({name: entry.name, rendered: renderStack.join("")});
		});
		return out;
	},

	getOrderedTraits (mon, {fnGetSpellTraits} = {}) {
		let traits = mon.trait ? MiscUtil.copyFast(mon.trait) : null;

		if (fnGetSpellTraits) {
			const spellTraits = fnGetSpellTraits(mon, "trait");
			if (spellTraits.length) traits = traits ? traits.concat(spellTraits) : spellTraits;
		}

		if (traits?.length) return traits.sort((a, b) => SortUtil.monTraitSort(a, b));
	},

	getOrderedActions (mon, {fnGetSpellTraits} = {}) { return Renderer.monster._getOrderedActionsBonusActions({mon, fnGetSpellTraits, prop: "action"}); },
	getOrderedBonusActions (mon, {fnGetSpellTraits} = {}) { return Renderer.monster._getOrderedActionsBonusActions({mon, fnGetSpellTraits, prop: "bonus"}); },
	getOrderedReactions (mon, {fnGetSpellTraits} = {}) { return Renderer.monster._getOrderedActionsBonusActions({mon, fnGetSpellTraits, prop: "reaction"}); },

	_getOrderedActionsBonusActions ({mon, fnGetSpellTraits, prop} = {}) {
		let actions = mon[prop] ? MiscUtil.copyFast(mon[prop]) : null;

		let spellActions;
		if (fnGetSpellTraits) {
			spellActions = fnGetSpellTraits(mon, prop);
		}

		if (!spellActions?.length && !actions?.length) return null;
		if (!actions?.length) return spellActions;
		if (!spellActions?.length) return actions;

										
		const ixLastAttack = actions.findLastIndex(it => it.entries && it.entries.length && typeof it.entries[0] === "string" && it.entries[0].includes(`{@atk `));
		const ixNext = actions.findIndex((act, ix) => ix > ixLastAttack && act.name && SortUtil.ascSortLower(act.name, "Spellcasting") >= 0);
		if (~ixNext) actions.splice(ixNext, 0, ...spellActions);
		else actions.push(...spellActions);
		return actions;
	},

	getSkillsString (renderer, mon) {
		if (!mon.skill) return "";

		function doSortMapJoinSkillKeys (obj, keys, joinWithOr) {
			const toJoin = keys.sort(SortUtil.ascSort).map(s => `<span data-mon-skill="${s.toTitleCase()}|${obj[s]}">${renderer.render(`{@skill ${s.toTitleCase()}}`)} ${Renderer.get().render(`{@skillCheck ${s.replace(/ /g, "_")} ${obj[s]}}`)}</span>`);
			return joinWithOr ? toJoin.joinConjunct(", ", " or ") : toJoin.join(", ");
		}

		const skills = doSortMapJoinSkillKeys(mon.skill, Object.keys(mon.skill).filter(k => k !== "other" && k !== "special"));
		if (mon.skill.other || mon.skill.special) {
			const others = mon.skill.other && mon.skill.other.map(it => {
				if (it.oneOf) {
					return `plus one of the following: ${doSortMapJoinSkillKeys(it.oneOf, Object.keys(it.oneOf), true)}`;
				}
				throw new Error(`Unhandled monster "other" skill properties!`);
			});
			const special = mon.skill.special && Renderer.get().render(mon.skill.special);
			return [skills, others, special].filter(Boolean).join(", ");
		}
		return skills;
	},

	getTokenUrl (mon) {
		return mon.tokenUrl || UrlUtil.link(`${Renderer.get().baseMediaUrls["img"] || Renderer.get().baseUrl}img/${Parser.sourceJsonToAbv(mon.source)}/${Parser.nameToTokenName(mon.name)}.png`);
	},

	postProcessFluff (mon, fluff) {
		const cpy = MiscUtil.copyFast(fluff);

						const thisGroup = DataUtil.monster.getMetaGroup(mon);
		const handleGroupProp = (prop, name) => {
			if (thisGroup && thisGroup[prop]) {
				cpy.entries = cpy.entries || [];
				cpy.entries.push({
					type: "entries",
					entries: [
						{
							type: "entries",
							name,
							entries: MiscUtil.copyFast(thisGroup[prop]),
						},
					],
				});
			}
		};

		handleGroupProp("lairActions", "Lair Actions");
		handleGroupProp("regionalEffects", "Regional Effects");
		handleGroupProp("mythicEncounter", `${mon.name} as a Mythic Encounter`);

		return cpy;
	},

	_FN_TAG_SENSES: null,
	_SENSE_TAG_METAS: null,
	getRenderedSenses (senses, isPlainText) {
		if (typeof senses === "string") senses = [senses]; 		if (isPlainText) return senses.join(", ");

		if (!Renderer.monster._FN_TAG_SENSES) {
			Renderer.monster._SENSE_TAG_METAS = [
				...MiscUtil.copyFast(Parser.SENSES),
				...(PrereleaseUtil.getBrewProcessedFromCache("sense") || []),
				...(BrewUtil2.getBrewProcessedFromCache("sense") || []),
			];
			Renderer.monster._SENSE_TAG_METAS.forEach(it => it._re = new RegExp(`\\b(?<sense>${it.name.escapeRegexp()})\\b`, "gi"));
			Renderer.monster._FN_TAG_SENSES = str => {
				Renderer.monster._SENSE_TAG_METAS
					.forEach(({name, source, _re}) => str = str.replace(_re, (...m) => `{@sense ${m.last().sense}|${source}}`));
				return str;
			};
		}

		const senseStr = senses
			.map(str => {
				const tagSplit = Renderer.splitByTags(str);
				str = "";
				const len = tagSplit.length;
				for (let i = 0; i < len; ++i) {
					const s = tagSplit[i];

					if (!s) continue;

					if (s.startsWith("{@")) {
						str += s;
						continue;
					}

					str += Renderer.monster._FN_TAG_SENSES(s);
				}
				return str;
			})
			.join(", ")
			.replace(/(^| |\()(blind|blinded)(\)| |$)/gi, (...m) => `${m[1]}{@condition blinded||${m[2]}}${m[3]}`);

		return Renderer.get().render(senseStr);
	},

	getRenderedLanguages (languages) {
		if (typeof languages === "string") languages = [languages]; 		return languages ? languages.map(it => Renderer.get().render(it)).join(", ") : "\u2014";
	},

	initParsed (mon) {
		mon._pTypes = mon._pTypes || Parser.monTypeToFullObj(mon.type); 		if (!mon._pCr) {
			if (Parser.crToNumber(mon.cr) === VeCt.CR_CUSTOM) mon._pCr = "Special";
			else if (Parser.crToNumber(mon.cr) === VeCt.CR_UNKNOWN) mon._pCr = "Unknown";
			else mon._pCr = mon.cr == null ? "\u2014" : (mon.cr.cr || mon.cr);
		}
		if (!mon._fCr) {
			mon._fCr = [mon._pCr];
			if (mon.cr) {
				if (mon.cr.lair) mon._fCr.push(mon.cr.lair);
				if (mon.cr.coven) mon._fCr.push(mon.cr.coven);
			}
		}
	},

	updateParsed (mon) {
		delete mon._pTypes;
		delete mon._pCr;
		delete mon._fCr;
		Renderer.monster.initParsed(mon);
	},

	getRenderedVariants (mon, {renderer = null} = {}) {
		renderer = renderer || Renderer.get();
		const dragonVariant = Renderer.monster.dragonCasterVariant.getHtml(mon, {renderer});
		const variants = mon.variant;
		if (!variants && !dragonVariant) return null;

		const rStack = [];
		(variants || []).forEach(v => renderer.recursiveRender(v, rStack));
		if (dragonVariant) rStack.push(dragonVariant);
		return rStack.join("");
	},

	getRenderedEnvironment (envs) { return (envs || []).sort(SortUtil.ascSortLower).map(it => it.toTitleCase()).join(", "); },

	getRenderedAltArtEntry (meta, {isPlainText = false} = {}) {
		return `${isPlainText ? "" : `<div>`}${meta.displayName || meta.name}; ${isPlainText ? "" : `<span title="${Parser.sourceJsonToFull(meta.source)}">`}${Parser.sourceJsonToAbv(meta.source)}${Renderer.utils.isDisplayPage(meta.page) ? ` p${meta.page}` : ""}${isPlainText ? "" : `</span></div>`}`;
	},

	pGetFluff (mon) {
		return Renderer.utils.pGetFluff({
			entity: mon,
			pFnPostProcess: Renderer.monster.postProcessFluff.bind(null, mon),
			fluffBaseUrl: `data/bestiary/`,
			fluffProp: "monsterFluff",
		});
	},

		getCustomHashId (mon) {
		if (!mon._isScaledCr && !mon._isScaledSpellSummon && !mon._scaledClassSummonLevel) return null;

		const {
			name,
			source,
			_scaledCr: scaledCr,
			_scaledSpellSummonLevel: scaledSpellSummonLevel,
			_scaledClassSummonLevel: scaledClassSummonLevel,
		} = mon;

		return [
			name,
			source,
			scaledCr ?? "",
			scaledSpellSummonLevel ?? "",
			scaledClassSummonLevel ?? "",
		].join("__").toLowerCase();
	},

	getUnpackedCustomHashId (customHashId) {
		if (!customHashId) return null;

		const [, , scaledCr, scaledSpellSummonLevel, scaledClassSummonLevel] = customHashId.split("__").map(it => it.trim());

		if (!scaledCr && !scaledSpellSummonLevel && !scaledClassSummonLevel) return null;

		return {
			_scaledCr: scaledCr ? Number(scaledCr) : null,
			_scaledSpellSummonLevel: scaledSpellSummonLevel ? Number(scaledSpellSummonLevel) : null,
			_scaledClassSummonLevel: scaledClassSummonLevel ? Number(scaledClassSummonLevel) : null,
			customHashId,
		};
	},
	
	async pGetModifiedCreature (monRaw, customHashId) {
		if (!customHashId) return monRaw;
		const {_scaledCr, _scaledSpellSummonLevel, _scaledClassSummonLevel} = Renderer.monster.getUnpackedCustomHashId(customHashId);
		if (_scaledCr) return ScaleCreature.scale(monRaw, _scaledCr);
		if (_scaledSpellSummonLevel) return ScaleSpellSummonedCreature.scale(monRaw, _scaledSpellSummonLevel);
		if (_scaledClassSummonLevel) return ScaleClassSummonedCreature.scale(monRaw, _scaledClassSummonLevel);
		throw new Error(`Unhandled custom hash ID "${customHashId}"`);
	},

	_bindListenersScale (mon, ele) {
		const page = UrlUtil.PG_BESTIARY;
		const source = mon.source;
		const hash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BESTIARY](mon);

		const fnRender = Renderer.hover.getFnRenderCompact(page);

		const $content = $(ele);

		$content
			.find(".mon__btn-scale-cr")
			.click(evt => {
				evt.stopPropagation();
				const win = (evt.view || {}).window;

				const $btn = $(evt.target).closest("button");
				const initialCr = mon._originalCr != null ? mon._originalCr : mon.cr.cr || mon.cr;
				const lastCr = mon.cr.cr || mon.cr;

				Renderer.monster.getCrScaleTarget({
					win,
					$btnScale: $btn,
					initialCr: lastCr,
					isCompact: true,
					cbRender: async (targetCr) => {
						const original = await DataLoader.pCacheAndGet(page, source, hash);
						const toRender = Parser.numberToCr(targetCr) === initialCr
							? original
							: await ScaleCreature.scale(original, targetCr);

						$content.empty().append(fnRender(toRender));

						Renderer.monster._bindListenersScale(toRender, ele);
					},
				});
			});

		$content
			.find(".mon__btn-reset-cr")
			.click(async () => {
				const toRender = await DataLoader.pCacheAndGet(page, source, hash);
				$content.empty().append(fnRender(toRender));

				Renderer.monster._bindListenersScale(toRender, ele);
			});

		const $selSummonSpellLevel = $content
			.find(`[name="mon__sel-summon-spell-level"]`)
			.change(async () => {
				const original = await DataLoader.pCacheAndGet(page, source, hash);
				const spellLevel = Number($selSummonSpellLevel.val());

				const toRender = ~spellLevel
					? await ScaleSpellSummonedCreature.scale(original, spellLevel)
					: original;

				$content.empty().append(fnRender(toRender));

				Renderer.monster._bindListenersScale(toRender, ele);
			})
			.val(mon._summonedBySpell_level != null ? `${mon._summonedBySpell_level}` : "-1");

		const $selSummonClassLevel = $content
			.find(`[name="mon__sel-summon-class-level"]`)
			.change(async () => {
				const original = await DataLoader.pCacheAndGet(page, source, hash);
				const classLevel = Number($selSummonClassLevel.val());

				const toRender = ~classLevel
					? await ScaleClassSummonedCreature.scale(original, classLevel)
					: original;

				$content.empty().append(fnRender(toRender));

				Renderer.monster._bindListenersScale(toRender, ele);
			})
			.val(mon._summonedByClass_level != null ? `${mon._summonedByClass_level}` : "-1");
	},

	bindListenersCompact (mon, ele) {
		Renderer.monster._bindListenersScale(mon, ele);
	},
};
Renderer.monster.CHILD_PROPS_EXTENDED = [...Renderer.monster.CHILD_PROPS, "lairActions", "regionalEffects"];

Renderer.monster.CHILD_PROPS_EXTENDED.forEach(prop => {
	const propFull = `monster${prop.uppercaseFirst()}`;
	Renderer[propFull] = {
		getCompactRenderedString (ent) {
			return Renderer.generic.getCompactRenderedString(ent);
		},
	};
});

Renderer.legendaryGroup = {
	getCompactRenderedString (legGroup, opts) {
		opts = opts || {};

		const ent = Renderer.legendaryGroup.getSummaryEntry(legGroup);
		if (!ent) return "";

		return `
		${Renderer.utils.getNameTr(legGroup, {isEmbeddedEntity: opts.isEmbeddedEntity})}
		<tr class="text"><td colspan="6">
		${Renderer.get().setFirstSection(true).render(ent)}
		</td></tr>
		${Renderer.utils.getPageTr(legGroup)}`;
	},

	getSummaryEntry (legGroup) {
		if (!legGroup || (!legGroup.lairActions && !legGroup.regionalEffects && !legGroup.mythicEncounter)) return null;

		return {
			type: "section",
			entries: [
				legGroup.lairActions ? {name: "Lair Actions", type: "entries", entries: legGroup.lairActions} : null,
				legGroup.regionalEffects ? {name: "Regional Effects", type: "entries", entries: legGroup.regionalEffects} : null,
				legGroup.mythicEncounter ? {name: "As a Mythic Encounter", type: "entries", entries: legGroup.mythicEncounter} : null,
			].filter(Boolean),
		};
	},
};

Renderer.item = {
	_sortProperties (a, b) {
		return SortUtil.ascSort(Renderer.item.propertyMap[a]?.name || "", Renderer.item.propertyMap[b]?.name || "");
	},

	_getPropertiesText (item, {renderer = null} = {}) {
		renderer = renderer || Renderer.get();

		if (!item.property) {
			const parts = [];
			if (item.dmg2) parts.push(`alt. ${Renderer.item._renderDamage(item.dmg2, {renderer})}`);
			if (item.range) parts.push(`range ${item.range} ft.`);
			return `${item.dmg1 && parts.length ? " - " : ""}${parts.join(", ")}`;
		}

		let renderedDmg2 = false;

		const renderedProperties = item.property
			.sort(Renderer.item._sortProperties)
			.map(prop => {
				const fullProp = Renderer.item.propertyMap[prop];

				if (fullProp.template) {
					const toRender = Renderer.utils.applyTemplate(
						item,
						fullProp.template,
						{
							fnPreApply: (fullMatch, variablePath) => {
								if (variablePath === "item.dmg2") renderedDmg2 = true;
							},
							mapCustom: {"prop_name": fullProp.name},
						},
					);

					return renderer.render(toRender);
				} else return fullProp.name;
			});

		if (!renderedDmg2 && item.dmg2) renderedProperties.unshift(`alt. ${Renderer.item._renderDamage(item.dmg2, {renderer})}`);

		return `${item.dmg1 && renderedProperties.length ? " - " : ""}${renderedProperties.join(", ")}`;
	},

	_getTaggedDamage (dmg, {renderer = null} = {}) {
		if (!dmg) return "";

		renderer = renderer || Renderer.get();

		Renderer.stripTags(dmg.trim());

		return renderer.render(`{@damage ${dmg}}`);
	},

	_renderDamage (dmg, {renderer = null} = {}) {
		renderer = renderer || Renderer.get();
		return renderer.render(Renderer.item._getTaggedDamage(dmg, {renderer}));
	},

	getDamageAndPropertiesText (item, {renderer = null} = {}) {
		renderer = renderer || Renderer.get();

		const damagePartsPre = [];
		const damageParts = [];

		if (item.mastery) damagePartsPre.push(`Mastery: ${item.mastery.map(it => renderer.render(`{@itemMastery ${it}}`)).join(", ")}`);

		if (item.dmg1) damageParts.push(Renderer.item._renderDamage(item.dmg1, {renderer}));

				if (item.ac != null) {
			const prefix = item.type === "S" ? "+" : "";
			const suffix = item.type === "LA" || (item.type === "MA" && item.dexterityMax === null) ? " + Dex" : item.type === "MA" ? " + Dex (max 2)" : "";
			damageParts.push(`AC ${prefix}${item.ac}${suffix}`);
		}
		if (item.acSpecial != null) damageParts.push(item.ac != null ? item.acSpecial : `AC ${item.acSpecial}`);

				if (item.speed != null) damageParts.push(`Speed: ${item.speed}`);
		if (item.carryingCapacity) damageParts.push(`Carrying Capacity: ${item.carryingCapacity} lb.`);

				if (item.vehSpeed || item.capCargo || item.capPassenger || item.crew || item.crewMin || item.crewMax || item.vehAc || item.vehHp || item.vehDmgThresh || item.travelCost || item.shippingCost) {
			const vehPartUpper = item.vehSpeed ? `Speed: ${Parser.numberToVulgar(item.vehSpeed)} mph` : null;

			const vehPartMiddle = item.capCargo || item.capPassenger ? `Carrying Capacity: ${[item.capCargo ? `${Parser.numberToFractional(item.capCargo)} ton${item.capCargo === 0 || item.capCargo > 1 ? "s" : ""} cargo` : null, item.capPassenger ? `${item.capPassenger} passenger${item.capPassenger === 1 ? "" : "s"}` : null].filter(Boolean).join(", ")}` : null;

			const {travelCostFull, shippingCostFull} = Parser.itemVehicleCostsToFull(item);

						const vehPartLower = [
				item.crew ? `Crew ${item.crew}` : null,
				item.crewMin && item.crewMax ? `Crew ${item.crewMin}-${item.crewMax}` : null,
				item.vehAc ? `AC ${item.vehAc}` : null,
				item.vehHp ? `HP ${item.vehHp}${item.vehDmgThresh ? `, Damage Threshold ${item.vehDmgThresh}` : ""}` : null,
			].filter(Boolean).join(", ");

			damageParts.push([
				vehPartUpper,
				vehPartMiddle,

								travelCostFull ? `Personal Travel Cost: ${travelCostFull} per mile per passenger` : null,
				shippingCostFull ? `Shipping Cost: ${shippingCostFull} per 100 pounds per mile` : null,
				
				vehPartLower,
			].filter(Boolean).join(renderer.getLineBreak()));
		}

		const damage = [
			damagePartsPre.join(", "),
			damageParts.join(", "),
		]
			.filter(Boolean)
			.join(renderer.getLineBreak());
		const damageType = item.dmgType ? Parser.dmgTypeToFull(item.dmgType) : "";
		const propertiesTxt = Renderer.item._getPropertiesText(item, {renderer});

		return [damage, damageType, propertiesTxt];
	},

	getTypeRarityAndAttunementText (item) {
		const typeRarity = [
			item._typeHtml === "other" ? "" : item._typeHtml,
			(item.rarity && Renderer.item.doRenderRarity(item.rarity) ? item.rarity : ""),
		].filter(Boolean).join(", ");

		return [
			item.reqAttune ? `${typeRarity} ${item._attunement}` : typeRarity,
			item._subTypeHtml || "",
			item.tier ? `${item.tier} tier` : "",
		];
	},

	getAttunementAndAttunementCatText (item, prop = "reqAttune") {
		let attunement = null;
		let attunementCat = VeCt.STR_NO_ATTUNEMENT;
		if (item[prop] != null && item[prop] !== false) {
			if (item[prop] === true) {
				attunementCat = "Requires Attunement";
				attunement = "(requires attunement)";
			} else if (item[prop] === "optional") {
				attunementCat = "Attunement Optional";
				attunement = "(attunement optional)";
			} else if (item[prop].toLowerCase().startsWith("by")) {
				attunementCat = "Requires Attunement By...";
				attunement = `(requires attunement ${Renderer.get().render(item[prop])})`;
			} else {
				attunementCat = "Requires Attunement"; 				attunement = `(requires attunement ${Renderer.get().render(item[prop])})`;
			}
		}
		return [attunement, attunementCat];
	},

	getHtmlAndTextTypes (item) {
		const typeHtml = [];
		const typeListText = [];
		const subTypeHtml = [];

		let showingBase = false;
		if (item.wondrous) {
			typeHtml.push(`wondrous item${item.tattoo ? ` (tattoo)` : ""}`);
			typeListText.push("wondrous item");
		}
		if (item.tattoo) {
			typeListText.push("tattoo");
		}
		if (item.staff) {
			typeHtml.push("staff");
			typeListText.push("staff");
		}
		if (item.ammo) {
			typeHtml.push(`ammunition`);
			typeListText.push("ammunition");
		}
		if (item.firearm) {
			subTypeHtml.push("firearm");
			typeListText.push("firearm");
		}
		if (item.age) {
			subTypeHtml.push(item.age);
			typeListText.push(item.age);
		}
		if (item.weaponCategory) {
			typeHtml.push(`weapon${item.baseItem ? ` (${Renderer.get().render(`{@item ${item.baseItem}}`)})` : ""}`);
			subTypeHtml.push(`${item.weaponCategory} weapon`);
			typeListText.push(`${item.weaponCategory} weapon`);
			showingBase = true;
		}
		if (item.staff && (item.type !== "M" && item.typeAlt !== "M")) { 			subTypeHtml.push("melee weapon");
			typeListText.push("melee weapon");
		}
		if (item.type) Renderer.item._getHtmlAndTextTypes_type({type: item.type, typeHtml, typeListText, subTypeHtml, showingBase, item});
		if (item.typeAlt) Renderer.item._getHtmlAndTextTypes_type({type: item.typeAlt, typeHtml, typeListText, subTypeHtml, showingBase, item});
		if (item.poison) {
			typeHtml.push(`poison${item.poisonTypes ? ` (${item.poisonTypes.joinConjunct(", ", " or ")})` : ""}`);
			typeListText.push("poison");
		}
		return [typeListText, typeHtml.join(", "), subTypeHtml.join(", ")];
	},

	_getHtmlAndTextTypes_type ({type, typeHtml, typeListText, subTypeHtml, showingBase, item}) {
		const fullType = Renderer.item.getItemTypeName(type);

		const isSub = (typeListText.some(it => it.includes("weapon")) && fullType.includes("weapon"))
			|| (typeListText.some(it => it.includes("armor")) && fullType.includes("armor"));

		if (!showingBase && !!item.baseItem) (isSub ? subTypeHtml : typeHtml).push(`${fullType} (${Renderer.get().render(`{@item ${item.baseItem}}`)})`);
		else if (type === "S") (isSub ? subTypeHtml : typeHtml).push(Renderer.get().render(`armor ({@item shield|phb})`));
		else (isSub ? subTypeHtml : typeHtml).push(fullType);

		typeListText.push(fullType);
	},

	_GET_RENDERED_ENTRIES_WALKER: null,

		getRenderedEntries (item, {isCompact = false, wrappedTypeAllowlist = null} = {}) {
		const renderer = Renderer.get();

		Renderer.item._GET_RENDERED_ENTRIES_WALKER = Renderer.item._GET_RENDERED_ENTRIES_WALKER || MiscUtil.getWalker({
			keyBlocklist: new Set([
				...MiscUtil.GENERIC_WALKER_ENTRIES_KEY_BLOCKLIST,
				"data",
			]),
		});

		const handlersName = {
			string: (str) => Renderer.item._getRenderedEntries_handlerConvertNamesToItalics.bind(Renderer.item, item, item.name)(str),
		};

		const handlersVariantName = item._variantName == null ? null : {
			string: (str) => Renderer.item._getRenderedEntries_handlerConvertNamesToItalics.bind(Renderer.item, item, item._variantName)(str),
		};

		const renderStack = [];
		if (item._fullEntries || item.entries?.length) {
			const entry = MiscUtil.copyFast({type: "entries", entries: item._fullEntries || item.entries});
			let procEntry = Renderer.item._GET_RENDERED_ENTRIES_WALKER.walk(entry, handlersName);
			if (handlersVariantName) procEntry = Renderer.item._GET_RENDERED_ENTRIES_WALKER.walk(entry, handlersVariantName);
			if (wrappedTypeAllowlist) procEntry.entries = procEntry.entries.filter(it => !it?.data?.[VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG] || wrappedTypeAllowlist.has(it?.data?.[VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]));
			renderer.recursiveRender(procEntry, renderStack, {depth: 1});
		}

		if (item._fullAdditionalEntries || item.additionalEntries) {
			const additionEntries = MiscUtil.copyFast({type: "entries", entries: item._fullAdditionalEntries || item.additionalEntries});
			let procAdditionEntries = Renderer.item._GET_RENDERED_ENTRIES_WALKER.walk(additionEntries, handlersName);
			if (handlersVariantName) procAdditionEntries = Renderer.item._GET_RENDERED_ENTRIES_WALKER.walk(additionEntries, handlersVariantName);
			if (wrappedTypeAllowlist) procAdditionEntries.entries = procAdditionEntries.entries.filter(it => !it?.data?.[VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG] || wrappedTypeAllowlist.has(it?.data?.[VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]));
			renderer.recursiveRender(procAdditionEntries, renderStack, {depth: 1});
		}

		if (!isCompact && item.lootTables) {
			renderStack.push(`<div><span class="bold">Found On: </span>${item.lootTables.sort(SortUtil.ascSortLower).map(tbl => renderer.render(`{@table ${tbl}}`)).join(", ")}</div>`);
		}

		return renderStack.join("").trim();
	},

	_getRenderedEntries_handlerConvertNamesToItalics (item, baseName, str) {
		if (item._fIsMundane) return str;

		const stack = [];
		let depth = 0;

		const tgtLen = baseName.length;
				const tgtName = item.sentient ? baseName : baseName.toLowerCase();

		const tgtNamePlural = tgtName.toPlural();
		const tgtLenPlural = tgtNamePlural.length;

				const tgtNameNoBraces = tgtName.replace(/ \(.*$/, "");
		const tgtLenNoBraces = tgtNameNoBraces.length;

		const len = str.length;
		for (let i = 0; i < len; ++i) {
			const c = str[i];

			switch (c) {
				case "{": {
					if (str[i + 1] === "@") depth++;
					stack.push(c);
					break;
				}
				case "}": {
					if (depth) depth--;
					stack.push(c);
					break;
				}
				default: stack.push(c); break;
			}

			if (depth) continue;

			if (stack.slice(-tgtLen).join("")[item.sentient ? "toString" : "toLowerCase"]() === tgtName) {
				stack.splice(stack.length - tgtLen, tgtLen, `{@i ${stack.slice(-tgtLen).join("")}}`);
			} else if (stack.slice(-tgtLenPlural).join("")[item.sentient ? "toString" : "toLowerCase"]() === tgtNamePlural) {
				stack.splice(stack.length - tgtLenPlural, tgtLenPlural, `{@i ${stack.slice(-tgtLenPlural).join("")}}`);
			} else if (stack.slice(-tgtLenNoBraces).join("")[item.sentient ? "toString" : "toLowerCase"]() === tgtNameNoBraces) {
				stack.splice(stack.length - tgtLenNoBraces, tgtLenNoBraces, `{@i ${stack.slice(-tgtLenNoBraces).join("")}}`);
			}
		}

		return stack.join("");
	},

	getCompactRenderedString (item, opts) {
		opts = opts || {};

		const [damage, damageType, propertiesTxt] = Renderer.item.getDamageAndPropertiesText(item);
		const [typeRarityText, subTypeText, tierText] = Renderer.item.getTypeRarityAndAttunementText(item);

		return `
		${Renderer.utils.getExcludedTr({entity: item, dataProp: "item", page: UrlUtil.PG_ITEMS})}
		${Renderer.utils.getNameTr(item, {page: UrlUtil.PG_ITEMS, isEmbeddedEntity: opts.isEmbeddedEntity})}
		<tr><td class="rd-item__type-rarity-attunement" colspan="6">${Renderer.item.getTypeRarityAndAttunementHtml(typeRarityText, subTypeText, tierText)}</td></tr>
		<tr>
			<td colspan="2">${[Parser.itemValueToFullMultiCurrency(item), Parser.itemWeightToFull(item)].filter(Boolean).join(", ").uppercaseFirst()}</td>
			<td class="text-right" colspan="4">${damage} ${damageType} ${propertiesTxt}</td>
		</tr>
		${Renderer.item.hasEntries(item) ? `${Renderer.utils.getDividerTr()}<tr class="text"><td colspan="6" class="text">${Renderer.item.getRenderedEntries(item, {isCompact: true})}</td></tr>` : ""}`;
	},

	hasEntries (item) {
		return item._fullAdditionalEntries?.length || item._fullEntries?.length || item.entries?.length;
	},

	getTypeRarityAndAttunementHtml (typeRarityText, subTypeText, tierText) {
		return `<div class="ve-flex-col">
			${typeRarityText || tierText ? `<div class="split ${subTypeText ? "mb-1" : ""}">
				<div class="italic">${(typeRarityText || "").uppercaseFirst()}</div>
				<div class="no-wrap ${tierText ? `ml-2` : ""}">${(tierText || "").uppercaseFirst()}</div>
			</div>` : ""}
			${subTypeText ? `<div class="italic">${subTypeText.uppercaseFirst()}</div>` : ""}
		</div>`;
	},

	_hiddenRarity: new Set(["none", "unknown", "unknown (magic)", "varies"]),
	doRenderRarity (rarity) {
		return !Renderer.item._hiddenRarity.has(rarity);
	},

	
	propertyMap: {},
	_addProperty (prt) {
		if (Renderer.item.propertyMap[prt.abbreviation]) return;
		const cpy = MiscUtil.copyFast(prt);
		Renderer.item.propertyMap[prt.abbreviation] = prt.name ? cpy : {
			...cpy,
			name: (prt.entries || prt.entriesTemplate)[0].name.toLowerCase(),
		};
	},

	getProperty (abbv) { return Renderer.item.propertyMap[abbv]; },

	
	typeMap: {},
	_addType (typ) {
		if (Renderer.item.typeMap[typ.abbreviation]?.entries || Renderer.item.typeMap[typ.abbreviation]?.entriesTemplate) return;
		const cpy = MiscUtil.copyFast(typ);

				Object.entries(Renderer.item.typeMap[typ.abbreviation] || {})
			.forEach(([k, v]) => {
				if (cpy[k]) return;
				cpy[k] = v;
			});

		cpy.name = cpy.name || (cpy.entries || cpy.entriesTemplate)[0].name.toLowerCase();

		Renderer.item.typeMap[typ.abbreviation] = cpy;
	},

	getType (abbv) { return Renderer.item.typeMap[abbv]; },

	
	entryMap: {},
	_addEntry (ent) {
		if (Renderer.item.entryMap[ent.source]?.[ent.name]) return;
		MiscUtil.set(Renderer.item.entryMap, ent.source, ent.name, ent);
	},

	
	_additionalEntriesMap: {},
	_addAdditionalEntries (ent) {
		if (Renderer.item._additionalEntriesMap[ent.appliesTo]) return;
		Renderer.item._additionalEntriesMap[ent.appliesTo] = MiscUtil.copyFast(ent.entries);
	},

	
	_masteryMap: {},
	_addMastery (ent) {
		const lookupSource = ent.source.toLowerCase();
		const lookupName = ent.name.toLowerCase();
		if (Renderer.item._masteryMap[lookupSource]?.[lookupName]) return;
		MiscUtil.set(Renderer.item._masteryMap, lookupSource, lookupName, ent);
	},

	_getMastery (uid) {
		const {name, source} = DataUtil.proxy.unpackUid("itemMastery", uid, "itemMastery", {isLower: true});
		return MiscUtil.get(Renderer.item._masteryMap, source, name);
	},

	
	async _pAddPrereleaseBrewPropertiesAndTypes () {
		if (typeof PrereleaseUtil !== "undefined") Renderer.item.addPrereleaseBrewPropertiesAndTypesFrom({data: await PrereleaseUtil.pGetBrewProcessed()});
		if (typeof BrewUtil2 !== "undefined") Renderer.item.addPrereleaseBrewPropertiesAndTypesFrom({data: await BrewUtil2.pGetBrewProcessed()});
	},

	addPrereleaseBrewPropertiesAndTypesFrom ({data}) {
		(data.itemProperty || [])
			.forEach(it => Renderer.item._addProperty(it));
		(data.itemType || [])
			.forEach(it => Renderer.item._addType(it));
		(data.itemEntry || [])
			.forEach(it => Renderer.item._addEntry(it));
		(data.itemTypeAdditionalEntries || [])
			.forEach(it => Renderer.item._addAdditionalEntries(it));
		(data.itemMastery || [])
			.forEach(it => Renderer.item._addMastery(it));
	},

	_addBasePropertiesAndTypes (baseItemData) {
		Object.entries(Parser.ITEM_TYPE_JSON_TO_ABV).forEach(([abv, name]) => Renderer.item._addType({abbreviation: abv, name}));

				(baseItemData.itemProperty || []).forEach(it => Renderer.item._addProperty(it));
		(baseItemData.itemType || []).forEach(it => {
						if (it.abbreviation === "SHP") Renderer.item._addType({...MiscUtil.copyFast(it), abbreviation: "AIR"});
			Renderer.item._addType(it);
		});
		(baseItemData.itemEntry || []).forEach(it => Renderer.item._addEntry(it));
		(baseItemData.itemTypeAdditionalEntries || []).forEach(it => Renderer.item._addAdditionalEntries(it));
		(baseItemData.itemMastery || []).forEach(it => Renderer.item._addMastery(it));

		baseItemData.baseitem.forEach(it => it._isBaseItem = true);
	},

	async _pGetSiteUnresolvedRefItems_pLoadItems () {
		const itemData = await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/items.json`);
		const items = itemData.item;
		itemData.itemGroup.forEach(it => it._isItemGroup = true);
		return [...items, ...itemData.itemGroup];
	},

	async pGetSiteUnresolvedRefItems () {
		const itemList = await Renderer.item._pGetSiteUnresolvedRefItems_pLoadItems();
		const baseItemsJson = await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/items-base.json`);
		const baseItems = await Renderer.item._pGetAndProcBaseItems(baseItemsJson);
		const {genericVariants, linkedLootTables} = await Renderer.item._pGetCacheSiteGenericVariants();
		const specificVariants = Renderer.item._createSpecificVariants(baseItems, genericVariants, {linkedLootTables});
		const allItems = [...itemList, ...baseItems, ...genericVariants, ...specificVariants];
		Renderer.item._enhanceItems(allItems);

		return {
			item: allItems,
			itemEntry: baseItemsJson.itemEntry,
		};
	},

	_pGettingSiteGenericVariants: null,
	async _pGetCacheSiteGenericVariants () {
		Renderer.item._pGettingSiteGenericVariants = Renderer.item._pGettingSiteGenericVariants || (async () => {
			const [genericVariants, linkedLootTables] = Renderer.item._getAndProcGenericVariants(await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/magicvariants.json`));
			return {genericVariants, linkedLootTables};
		})();
		return Renderer.item._pGettingSiteGenericVariants;
	},

	async pBuildList () {
		return DataLoader.pCacheAndGetAllSite(UrlUtil.PG_ITEMS);
	},

	async _pGetAndProcBaseItems (baseItemData) {
		Renderer.item._addBasePropertiesAndTypes(baseItemData);
		await Renderer.item._pAddPrereleaseBrewPropertiesAndTypes();
		return baseItemData.baseitem;
	},

	_getAndProcGenericVariants (variantData) {
		variantData.magicvariant.forEach(Renderer.item._genericVariants_addInheritedPropertiesToSelf);
		return [variantData.magicvariant, variantData.linkedLootTables];
	},

	_initFullEntries (item) {
		Renderer.utils.initFullEntries_(item);
	},

	_initFullAdditionalEntries (item) {
		Renderer.utils.initFullEntries_(item, {propEntries: "additionalEntries", propFullEntries: "_fullAdditionalEntries"});
	},

		_createSpecificVariants (baseItems, genericVariants, opts) {
		opts = opts || {};

		const genericAndSpecificVariants = [];
		baseItems.forEach((curBaseItem) => {
			curBaseItem._category = "Basic";
			if (curBaseItem.entries == null) curBaseItem.entries = [];

			if (curBaseItem.packContents) return; 
			genericVariants.forEach((curGenericVariant) => {
				if (!Renderer.item._createSpecificVariants_hasRequiredProperty(curBaseItem, curGenericVariant)) return;
				if (Renderer.item._createSpecificVariants_hasExcludedProperty(curBaseItem, curGenericVariant)) return;

				genericAndSpecificVariants.push(Renderer.item._createSpecificVariants_createSpecificVariant(curBaseItem, curGenericVariant, opts));
			});
		});
		return genericAndSpecificVariants;
	},

	_createSpecificVariants_hasRequiredProperty (baseItem, genericVariant) {
		return genericVariant.requires.some(req => Renderer.item._createSpecificVariants_isRequiresExcludesMatch(baseItem, req, "every"));
	},

	_createSpecificVariants_hasExcludedProperty (baseItem, genericVariant) {
		const curExcludes = genericVariant.excludes || {};
		return Renderer.item._createSpecificVariants_isRequiresExcludesMatch(baseItem, genericVariant.excludes, "some");
	},

	_createSpecificVariants_isRequiresExcludesMatch (baseItem, toMatch, method) {
		if (!toMatch) return false;

		return Object.entries(toMatch)[method](([k, v]) => {
			if (v instanceof Array) {
				return baseItem[k] instanceof Array
					? baseItem[k].some(it => v.includes(it))
					: v.includes(baseItem[k]);
			}

			return baseItem[k] instanceof Array
				? baseItem[k].some(it => v === it)
				: v === baseItem[k];
		});
	},

		_createSpecificVariants_createSpecificVariant (baseItem, genericVariant, opts) {
		const inherits = genericVariant.inherits;
		const specificVariant = MiscUtil.copyFast(baseItem);

				specificVariant.__prop = "item";

				delete specificVariant._isBaseItem;

				specificVariant._isEnhanced = false;
		delete specificVariant._fullEntries;

		specificVariant._baseName = baseItem.name;
		specificVariant._baseSrd = baseItem.srd;
		specificVariant._baseBasicRules = baseItem.basicRules;
		if (baseItem.source !== inherits.source) specificVariant._baseSource = baseItem.source;

		specificVariant._variantName = genericVariant.name;

				delete specificVariant.value;

				delete specificVariant.srd;
		delete specificVariant.basicRules;
		delete specificVariant.page;

				delete specificVariant.hasFluff;
		delete specificVariant.hasFluffImages;

		specificVariant._category = "Specific Variant";
		Object.entries(inherits)
			.forEach(([inheritedProperty, val]) => {
				switch (inheritedProperty) {
					case "namePrefix": specificVariant.name = `${val}${specificVariant.name}`; break;
					case "nameSuffix": specificVariant.name = `${specificVariant.name}${val}`; break;
					case "entries": {
						Renderer.item._initFullEntries(specificVariant);

						const appliedPropertyEntries = Renderer.applyAllProperties(val, Renderer.item._getInjectableProps(baseItem, inherits));
						appliedPropertyEntries.forEach((ent, i) => specificVariant._fullEntries.splice(i, 0, ent));
						break;
					}
					case "vulnerable":
					case "resist":
					case "immune": {
												break;
					}
					case "conditionImmune": {
						specificVariant[inheritedProperty] = [...specificVariant[inheritedProperty] || [], ...val].unique();
						break;
					}
					case "nameRemove": {
						specificVariant.name = specificVariant.name.replace(new RegExp(val.escapeRegexp(), "g"), "");

						break;
					}
					case "weightExpression":
					case "valueExpression": {
						const exp = Renderer.item._createSpecificVariants_evaluateExpression(baseItem, specificVariant, inherits, inheritedProperty);

						const result = Renderer.dice.parseRandomise2(exp);
						if (result != null) {
							switch (inheritedProperty) {
								case "weightExpression": specificVariant.weight = result; break;
								case "valueExpression": specificVariant.value = result; break;
							}
						}

						break;
					}
					case "barding": {
						specificVariant.bardingType = baseItem.type;
						break;
					}
					case "propertyAdd": {
						specificVariant.property = [
							...(specificVariant.property || []),
							...val.filter(it => !specificVariant.property || !specificVariant.property.includes(it)),
						];
						break;
					}
					case "propertyRemove": {
						if (specificVariant.property) {
							specificVariant.property = specificVariant.property.filter(it => !val.includes(it));
							if (!specificVariant.property.length) delete specificVariant.property;
						}
						break;
					}
					default: specificVariant[inheritedProperty] = val;
				}
			});

		Renderer.item._createSpecificVariants_mergeVulnerableResistImmune({specificVariant, inherits});

				genericVariant.variants = genericVariant.variants || [];
		if (!genericVariant.variants.some(it => it.base?.name === baseItem.name && it.base?.source === baseItem.source)) genericVariant.variants.push({base: baseItem, specificVariant});

				specificVariant.genericVariant = {
			name: genericVariant.name,
			source: genericVariant.source,
		};

				if (opts.linkedLootTables && opts.linkedLootTables[specificVariant.source] && opts.linkedLootTables[specificVariant.source][specificVariant.name]) {
			(specificVariant.lootTables = specificVariant.lootTables || []).push(...opts.linkedLootTables[specificVariant.source][specificVariant.name]);
		}

		if (baseItem.source !== Parser.SRC_PHB && baseItem.source !== Parser.SRC_DMG) {
			Renderer.item._initFullEntries(specificVariant);
			specificVariant._fullEntries.unshift({
				type: "wrapper",
				wrapped: `{@note The {@item ${baseItem.name}|${baseItem.source}|base item} can be found in ${Parser.sourceJsonToFull(baseItem.source)}${baseItem.page ? `, page ${baseItem.page}` : ""}.}`,
				data: {
					[VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "note",
				},
			});
		}

		return specificVariant;
	},

	_createSpecificVariants_evaluateExpression (baseItem, specificVariant, inherits, inheritedProperty) {
		return inherits[inheritedProperty].replace(/\[\[([^\]]+)]]/g, (...m) => {
			const propPath = m[1].split(".");
			return propPath[0] === "item"
				? MiscUtil.get(specificVariant, ...propPath.slice(1))
				: propPath[0] === "baseItem"
					? MiscUtil.get(baseItem, ...propPath.slice(1))
					: MiscUtil.get(specificVariant, ...propPath);
		});
	},

	_PROPS_VULN_RES_IMMUNE: [
		"vulnerable",
		"resist",
		"immune",
	],
	_createSpecificVariants_mergeVulnerableResistImmune ({specificVariant, inherits}) {
		const fromBase = {};
		Renderer.item._PROPS_VULN_RES_IMMUNE
			.filter(prop => specificVariant[prop])
			.forEach(prop => fromBase[prop] = [...specificVariant[prop]]);

						Renderer.item._PROPS_VULN_RES_IMMUNE
			.forEach(prop => {
				const val = inherits[prop];

								if (val === undefined) return;

								if (val == null) return delete fromBase[prop];

				const valSet = new Set();
				val.forEach(it => {
					if (typeof it === "string") valSet.add(it);
					if (!it?.[prop]?.length) return;
					it?.[prop].forEach(itSub => {
						if (typeof itSub === "string") valSet.add(itSub);
					});
				});

				Renderer.item._PROPS_VULN_RES_IMMUNE
					.filter(it => it !== prop)
					.forEach(propOther => {
						if (!fromBase[propOther]) return;

						fromBase[propOther] = fromBase[propOther]
							.filter(it => {
								if (typeof it === "string") return !valSet.has(it);

								if (it?.[propOther]?.length) {
									it[propOther] = it[propOther].filter(itSub => {
										if (typeof itSub === "string") return !valSet.has(itSub);
										return true;
									});
								}

								return true;
							});

						if (!fromBase[propOther].length) delete fromBase[propOther];
					});
			});

		Renderer.item._PROPS_VULN_RES_IMMUNE
			.forEach(prop => {
				if (fromBase[prop] || inherits[prop]) specificVariant[prop] = [...(fromBase[prop] || []), ...(inherits[prop] || [])].unique();
				else delete specificVariant[prop];
			});
	},

	_enhanceItems (allItems) {
		allItems.forEach((item) => Renderer.item.enhanceItem(item));
		return allItems;
	},

		async pGetGenericAndSpecificVariants (genericVariants, opts) {
		opts = opts || {};

		let baseItems;
		if (opts.baseItems) {
			baseItems = opts.baseItems;
		} else {
			const baseItemData = await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/items-base.json`);
			Renderer.item._addBasePropertiesAndTypes(baseItemData);
			baseItems = [...baseItemData.baseitem, ...(opts.additionalBaseItems || [])];
		}

		await Renderer.item._pAddPrereleaseBrewPropertiesAndTypes();
		genericVariants.forEach(Renderer.item._genericVariants_addInheritedPropertiesToSelf);
		const specificVariants = Renderer.item._createSpecificVariants(baseItems, genericVariants);
		const outSpecificVariants = Renderer.item._enhanceItems(specificVariants);

		if (opts.isSpecificVariantsOnly) return outSpecificVariants;

		const outGenericVariants = Renderer.item._enhanceItems(genericVariants);
		return [...outGenericVariants, ...outSpecificVariants];
	},

	_getInjectableProps (baseItem, inherits) {
		return {
			baseName: baseItem.name,
			dmgType: baseItem.dmgType ? Parser.dmgTypeToFull(baseItem.dmgType) : null,
			bonusAc: inherits.bonusAc,
			bonusWeapon: inherits.bonusWeapon,
			bonusWeaponAttack: inherits.bonusWeaponAttack,
			bonusWeaponDamage: inherits.bonusWeaponDamage,
			bonusWeaponCritDamage: inherits.bonusWeaponCritDamage,
			bonusSpellAttack: inherits.bonusSpellAttack,
			bonusSpellSaveDc: inherits.bonusSpellSaveDc,
			bonusSavingThrow: inherits.bonusSavingThrow,
		};
	},

	_INHERITED_PROPS_BLOCKLIST: new Set([
				"entries",
		"rarity",
		
				"namePrefix",
		"nameSuffix",
			]),
	_genericVariants_addInheritedPropertiesToSelf (genericVariant) {
		if (genericVariant._isInherited) return;
		genericVariant._isInherited = true;

		for (const prop in genericVariant.inherits) {
			if (Renderer.item._INHERITED_PROPS_BLOCKLIST.has(prop)) continue;

			const val = genericVariant.inherits[prop];

			if (val == null) delete genericVariant[prop];
			else if (genericVariant[prop]) {
				if (genericVariant[prop] instanceof Array && val instanceof Array) genericVariant[prop] = MiscUtil.copyFast(genericVariant[prop]).concat(val);
				else genericVariant[prop] = val;
			} else genericVariant[prop] = genericVariant.inherits[prop];
		}

		if (!genericVariant.entries && genericVariant.inherits.entries) {
			genericVariant.entries = MiscUtil.copyFast(Renderer.applyAllProperties(genericVariant.inherits.entries, genericVariant.inherits));
		}

		if (genericVariant.inherits.rarity == null) delete genericVariant.rarity;
		else if (genericVariant.inherits.rarity === "varies") {
					} else genericVariant.rarity = genericVariant.inherits.rarity;

		if (genericVariant.requires.armor) genericVariant.armor = genericVariant.requires.armor;
	},

	getItemTypeName (t) {
		const fullType = Renderer.item.typeMap[t];
		if (!fullType) throw new Error(`Item type ${t} not found. You probably meant to load the property/type reference first; see \`Renderer.item.pPopulatePropertyAndTypeReference()\`.`);
		return fullType.name || t;
	},

	enhanceItem (item) {
		if (item._isEnhanced) return;
		item._isEnhanced = true;
		if (item.noDisplay) return;
		if (item.type === "GV") item._category = "Generic Variant";
		if (item._category == null) item._category = "Other";
		if (item.entries == null) item.entries = [];
		if (item.type && (Renderer.item.typeMap[item.type]?.entries || Renderer.item.typeMap[item.type]?.entriesTemplate)) {
			Renderer.item._initFullEntries(item);

			const propetyEntries = Renderer.item._enhanceItem_getItemPropertyTypeEntries({item, ent: Renderer.item.typeMap[item.type]});
			propetyEntries.forEach(e => item._fullEntries.push({type: "wrapper", wrapped: e, data: {[VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "type"}}));
		}
		if (item.property) {
			item.property.forEach(p => {
				const entProperty = Renderer.item.propertyMap[p];

				if (!entProperty) throw new Error(`Item property ${p} not found. You probably meant to load the property/type reference first; see \`Renderer.item.pPopulatePropertyAndTypeReference()\`.`);

				if (!entProperty.entries && !entProperty.entriesTemplate) return;

				Renderer.item._initFullEntries(item);

				const propetyEntries = Renderer.item._enhanceItem_getItemPropertyTypeEntries({item, ent: entProperty});
				propetyEntries.forEach(e => item._fullEntries.push({type: "wrapper", wrapped: e, data: {[VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "property"}}));
			});
		}
				if (item.type === "LA" || item.type === "MA" || item.type === "HA") {
			if (item.stealth) {
				Renderer.item._initFullEntries(item);
				item._fullEntries.push({type: "wrapper", wrapped: "The wearer has disadvantage on Dexterity ({@skill Stealth}) checks.", data: {[VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "type"}});
			}
			if (item.type === "HA" && item.strength) {
				Renderer.item._initFullEntries(item);
				item._fullEntries.push({type: "wrapper", wrapped: `If the wearer has a Strength score lower than ${item.strength}, their speed is reduced by 10 feet.`, data: {[VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "type"}});
			}
		}
		if (item.type === "SCF") {
			if (item._isItemGroup) {
				if (item.scfType === "arcane" && item.source !== Parser.SRC_ERLW) {
					Renderer.item._initFullEntries(item);
					item._fullEntries.push({type: "wrapper", wrapped: "An arcane focus is a special item\u2014an orb, a crystal, a rod, a specially constructed staff, a wand-like length of wood, or some similar item\u2014designed to channel the power of arcane spells. A sorcerer, warlock, or wizard can use such an item as a spellcasting focus.", data: {[VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "type"}});
				}
				if (item.scfType === "druid") {
					Renderer.item._initFullEntries(item);
					item._fullEntries.push({type: "wrapper", wrapped: "A druidic focus might be a sprig of mistletoe or holly, a wand or scepter made of yew or another special wood, a staff drawn whole out of a living tree, or a totem object incorporating feathers, fur, bones, and teeth from sacred animals. A druid can use such an object as a spellcasting focus.", data: {[VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "type"}});
				}
				if (item.scfType === "holy") {
					Renderer.item._initFullEntries(item);
					item._fullEntries.push({type: "wrapper", wrapped: "A holy symbol is a representation of a god or pantheon. It might be an amulet depicting a symbol representing a deity, the same symbol carefully engraved or inlaid as an emblem on a shield, or a tiny box holding a fragment of a sacred relic. A cleric or paladin can use a holy symbol as a spellcasting focus. To use the symbol in this way, the caster must hold it in hand, wear it visibly, or bear it on a shield.", data: {[VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "type"}});
				}
			} else {
				if (item.scfType === "arcane") {
					Renderer.item._initFullEntries(item);
					item._fullEntries.push({type: "wrapper", wrapped: "An arcane focus is a special item designed to channel the power of arcane spells. A sorcerer, warlock, or wizard can use such an item as a spellcasting focus.", data: {[VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "type"}});
				}
				if (item.scfType === "druid") {
					Renderer.item._initFullEntries(item);
					item._fullEntries.push({type: "wrapper", wrapped: "A druid can use this object as a spellcasting focus.", data: {[VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "type"}});
				}
				if (item.scfType === "holy") {
					Renderer.item._initFullEntries(item);

					item._fullEntries.push({type: "wrapper", wrapped: "A holy symbol is a representation of a god or pantheon.", data: {[VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "type"}});
					item._fullEntries.push({type: "wrapper", wrapped: "A cleric or paladin can use a holy symbol as a spellcasting focus. To use the symbol in this way, the caster must hold it in hand, wear it visibly, or bear it on a shield.", data: {[VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "type"}});
				}
			}
		}

		(item.mastery || [])
			.forEach(uid => {
				const mastery = Renderer.item._getMastery(uid);

				if (!mastery) throw new Error(`Item mastery ${uid} not found. You probably meant to load the property/type reference first; see \`Renderer.item.pPopulatePropertyAndTypeReference()\`.`);
				if (!mastery.entries && !mastery.entriesTemplate) return;

				Renderer.item._initFullEntries(item);

				item._fullEntries.push({
					type: "wrapper",
					wrapped: {
						type: "entries",
						name: `Mastery: ${mastery.name}`,
						source: mastery.source,
						page: mastery.page,
						entries: Renderer.item._enhanceItem_getItemPropertyTypeEntries({item, ent: mastery}),
					},
					data: {
						[VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "mastery",
					},
				});
			});

				if (item.type === "T" || item.type === "AT" || item.type === "INS" || item.type === "GS") { 			Renderer.item._initFullAdditionalEntries(item);
			item._fullAdditionalEntries.push({type: "wrapper", wrapped: {type: "hr"}, data: {[VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "type"}});
			item._fullAdditionalEntries.push({type: "wrapper", wrapped: `{@note See the {@variantrule Tool Proficiencies|XGE} entry for more information.}`, data: {[VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "type"}});
		}

				if (item.type === "INS" || item.type === "GS") item.additionalSources = item.additionalSources || [];
		if (item.type === "INS") {
			if (!item.additionalSources.find(it => it.source === "XGE" && it.page === 83)) item.additionalSources.push({"source": "XGE", "page": 83});
		} else if (item.type === "GS") {
			if (!item.additionalSources.find(it => it.source === "XGE" && it.page === 81)) item.additionalSources.push({"source": "XGE", "page": 81});
		}

		if (item.type && Renderer.item._additionalEntriesMap[item.type]) {
			Renderer.item._initFullAdditionalEntries(item);
			const additional = Renderer.item._additionalEntriesMap[item.type];
			item._fullAdditionalEntries.push({type: "wrapper", wrapped: {type: "entries", entries: additional}, data: {[VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "type"}});
		}

				const [typeListText, typeHtml, subTypeHtml] = Renderer.item.getHtmlAndTextTypes(item);
		item._typeListText = typeListText;
		item._typeHtml = typeHtml;
		item._subTypeHtml = subTypeHtml;

				const [attune, attuneCat] = Renderer.item.getAttunementAndAttunementCatText(item);
		item._attunement = attune;
		item._attunementCategory = attuneCat;

		if (item.reqAttuneAlt) {
			const [attuneAlt, attuneCatAlt] = Renderer.item.getAttunementAndAttunementCatText(item, "reqAttuneAlt");
			item._attunementCategory = [attuneCat, attuneCatAlt];
		}

				if (item._isItemGroup) {
			Renderer.item._initFullEntries(item);
			item._fullEntries.push({type: "wrapper", wrapped: "Multiple variations of this item exist, as listed below:", data: {[VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "magicvariant"}});
			item._fullEntries.push({
				type: "wrapper",
				wrapped: {
					type: "list",
					items: item.items.map(it => typeof it === "string" ? `{@item ${it}}` : `{@item ${it.name}|${it.source}}`),
				},
				data: {[VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "magicvariant"},
			});
		}

						if (item.variants && item.variants.length) {
			Renderer.item._initFullEntries(item);
			item._fullEntries.push({
				type: "wrapper",
				wrapped: {
					type: "entries",
					name: "Base items",
					entries: [
						"This item variant can be applied to the following base items:",
						{
							type: "list",
							items: item.variants.map(({base, specificVariant}) => {
								return `{@item ${base.name}|${base.source}} ({@item ${specificVariant.name}|${specificVariant.source}})`;
							}),
						},
					],
				},
				data: {[VeCt.ENTDATA_ITEM_MERGED_ENTRY_TAG]: "magicvariant"},
			});
		}
			},

	_enhanceItem_getItemPropertyTypeEntries ({item, ent}) {
		if (!ent.entriesTemplate) return MiscUtil.copyFast(ent.entries);
		return MiscUtil
			.getWalker({
				keyBlocklist: MiscUtil.GENERIC_WALKER_ENTRIES_KEY_BLOCKLIST,
			})
			.walk(
				MiscUtil.copyFast(ent.entriesTemplate),
				{
					string: (str) => {
						return Renderer.utils.applyTemplate(
							item,
							str,
						);
					},
				},
			);
	},

	unenhanceItem (item) {
		if (!item._isEnhanced) return;
		delete item._isEnhanced;
		delete item._fullEntries;
	},

	async pGetSiteUnresolvedRefItemsFromPrereleaseBrew ({brewUtil, brew = null}) {
		if (brewUtil == null && brew == null) return [];

		brew = brew || await brewUtil.pGetBrewProcessed();

		(brew.itemProperty || []).forEach(p => Renderer.item._addProperty(p));
		(brew.itemType || []).forEach(t => Renderer.item._addType(t));
		(brew.itemEntry || []).forEach(it => Renderer.item._addEntry(it));
		(brew.itemTypeAdditionalEntries || []).forEach(it => Renderer.item._addAdditionalEntries(it));

		let items = [...(brew.baseitem || []), ...(brew.item || [])];

		if (brew.itemGroup) {
			const itemGroups = MiscUtil.copyFast(brew.itemGroup);
			itemGroups.forEach(it => it._isItemGroup = true);
			items = [...items, ...itemGroups];
		}

		Renderer.item._enhanceItems(items);

		let isReEnhanceVariants = false;

				if (brew.baseitem && brew.baseitem.length) {
			isReEnhanceVariants = true;

			const {genericVariants} = await Renderer.item._pGetCacheSiteGenericVariants();

			const variants = await Renderer.item.pGetGenericAndSpecificVariants(
				genericVariants,
				{baseItems: brew.baseitem || [], isSpecificVariantsOnly: true},
			);
			items = [...items, ...variants];
		}

				if (brew.magicvariant && brew.magicvariant.length) {
			isReEnhanceVariants = true;

			const variants = await Renderer.item.pGetGenericAndSpecificVariants(
				brew.magicvariant,
				{additionalBaseItems: brew.baseitem || []},
			);
			items = [...items, ...variants];
		}

						if (isReEnhanceVariants) {
			const {genericVariants} = await Renderer.item._pGetCacheSiteGenericVariants();
			genericVariants.forEach(item => {
				item.variants.sort((a, b) => SortUtil.ascSortLower(a.base.name, b.base.name) || SortUtil.ascSortLower(a.base.source, b.base.source));
				Renderer.item.unenhanceItem(item);
				Renderer.item.enhanceItem(item);
			});
		}

		return items;
	},

	async pGetItemsFromPrerelease () {
		return DataLoader.pCacheAndGetAllPrerelease(UrlUtil.PG_ITEMS);
	},

	async pGetItemsFromBrew () {
		return DataLoader.pCacheAndGetAllBrew(UrlUtil.PG_ITEMS);
	},

	_pPopulatePropertyAndTypeReference: null,
	pPopulatePropertyAndTypeReference: () => {
		return Renderer.item._pPopulatePropertyAndTypeReference || (async () => {
			const data = await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/items-base.json`);

			Object.entries(Parser.ITEM_TYPE_JSON_TO_ABV).forEach(([abv, name]) => Renderer.item._addType({abbreviation: abv, name}));
			data.itemProperty.forEach(p => Renderer.item._addProperty(p));
			data.itemType.forEach(t => Renderer.item._addType(t));
			data.itemEntry.forEach(it => Renderer.item._addEntry(it));
			data.itemTypeAdditionalEntries.forEach(e => Renderer.item._addAdditionalEntries(e));

			await Renderer.item._pAddPrereleaseBrewPropertiesAndTypes();
		})();
	},

		async getAllIndexableItems (rawVariants, rawBaseItems) {
		const basicItems = await Renderer.item._pGetAndProcBaseItems(rawBaseItems);
		const [genericVariants, linkedLootTables] = await Renderer.item._getAndProcGenericVariants(rawVariants);
		const specificVariants = Renderer.item._createSpecificVariants(basicItems, genericVariants, {linkedLootTables});

		[...genericVariants, ...specificVariants].forEach(item => {
			if (item.variants) delete item.variants; 		});

		return specificVariants;
	},

	isMundane (item) { return item.rarity === "none" || item.rarity === "unknown" || item._category === "Basic"; },

	isExcluded (item, {hash = null} = {}) {
		const name = item.name;
		const source = item.source || item.inherits?.source;

		hash = hash || UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS]({name, source});

		if (ExcludeUtil.isExcluded(hash, "item", source)) return true;

		if (item._isBaseItem) return ExcludeUtil.isExcluded(hash, "baseitem", source);
		if (item._isItemGroup) return ExcludeUtil.isExcluded(hash, "itemGroup", source);
		if (item._variantName) {
			if (ExcludeUtil.isExcluded(hash, "_specificVariant", source)) return true;

			const baseHash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS]({name: item._baseName, source: item._baseSource || source});
			if (ExcludeUtil.isExcluded(baseHash, "baseitem", item._baseSource || source)) return true;

			const variantHash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS]({name: item._variantName, source: source});
			return ExcludeUtil.isExcluded(variantHash, "magicvariant", source);
		}
		if (item.type === "GV") return ExcludeUtil.isExcluded(hash, "magicvariant", source);

		return false;
	},

	pGetFluff (item) {
		return Renderer.utils.pGetFluff({
			entity: item,
			fnGetFluffData: DataUtil.itemFluff.loadJSON.bind(DataUtil.itemFluff),
			fluffProp: "itemFluff",
		});
	},
};

Renderer.psionic = {
	enhanceMode: (mode) => {
		if (!mode.enhanced) {
			mode.name = [mode.name, getModeSuffix(mode, false)].filter(Boolean).join(" ");

			if (mode.submodes) {
				mode.submodes.forEach(sm => {
					sm.name = [sm.name, getModeSuffix(sm, true)].filter(Boolean).join(" ");
				});
			}

			mode.enhanced = true;
		}

		function getModeSuffix (mode, subMode) {
			subMode = subMode == null ? false : subMode;
			const modeTitleArray = [];
			const bracketPart = getModeTitleBracketPart();
			if (bracketPart != null) modeTitleArray.push(bracketPart);
			if (subMode) return `${modeTitleArray.join(" ")}`;
			else return `${modeTitleArray.join(" ")}`;

			function getModeTitleBracketPart () {
				const modeTitleBracketArray = [];

				if (mode.cost) modeTitleBracketArray.push(getModeTitleCost());
				if (mode.concentration) modeTitleBracketArray.push(getModeTitleConcentration());

				if (modeTitleBracketArray.length === 0) return null;
				return `(${modeTitleBracketArray.join("; ")})`;

				function getModeTitleCost () {
					const costMin = mode.cost.min;
					const costMax = mode.cost.max;
					const costString = costMin === costMax ? costMin : `${costMin}-${costMax}`;
					return `${costString} psi`;
				}

				function getModeTitleConcentration () {
					return `conc., ${mode.concentration.duration} ${mode.concentration.unit}.`;
				}
			}
		}
	},

	getBodyText (psi, renderer) {
		const renderStack = [];
		if (psi.entries) Renderer.get().recursiveRender(({entries: psi.entries, type: "entries"}), renderStack);
		if (psi.focus) renderStack.push(Renderer.psionic.getFocusString(psi, renderer));
		if (psi.modes) renderStack.push(...psi.modes.map(mode => Renderer.psionic.getModeString(mode, renderer)));
		return renderStack.join("");
	},

	getDescriptionString: (psionic, renderer) => {
		return `<p>${renderer.render({type: "inline", entries: [psionic.description]})}</p>`;
	},

	getFocusString: (psionic, renderer) => {
		return `<p><span class="psi-focus-title">Psychic Focus.</span> ${renderer.render({type: "inline", entries: [psionic.focus]})}</p>`;
	},

	getModeString: (mode, renderer) => {
		Renderer.psionic.enhanceMode(mode);

		const renderStack = [];
		renderer.recursiveRender(mode, renderStack, {depth: 2});
		const modeString = renderStack.join("");
		if (mode.submodes == null) return modeString;
		const subModeString = Renderer.psionic.getSubModeString(mode.submodes, renderer);
		return `${modeString}${subModeString}`;
	},

	getSubModeString (subModes, renderer) {
		const fauxEntry = {
			type: "list",
			style: "list-hang-notitle",
			items: [],
		};

		for (let i = 0; i < subModes.length; ++i) {
			fauxEntry.items.push({
				type: "item",
				name: subModes[i].name,
				entry: subModes[i].entries.join("<br>"),
			});
		}
		const renderStack = [];
		renderer.recursiveRender(fauxEntry, renderStack, {depth: 2});
		return renderStack.join("");
	},

	getTypeOrderString (psi) {
		const typeMeta = Parser.psiTypeToMeta(psi.type);
				return typeMeta.hasOrder
			? typeMeta.isAltDisplay ? `${typeMeta.full} (${psi.order})` : `${psi.order} ${typeMeta.full}`
			: typeMeta.full;
	},

	getCompactRenderedString (psi) {
		return `
			${Renderer.utils.getExcludedTr({entity: psi, dataProp: "psionic", page: UrlUtil.PG_PSIONICS})}
			${Renderer.utils.getNameTr(psi, {page: UrlUtil.PG_PSIONICS})}
			<tr class="text"><td colspan="6">
			<p><i>${Renderer.psionic.getTypeOrderString(psi)}</i></p>
			${Renderer.psionic.getBodyText(psi, Renderer.get().setFirstSection(true))}
			</td></tr>
		`;
	},
};

Renderer.rule = {
	getCompactRenderedString (rule) {
		return `
			<tr><td colspan="6">
			${Renderer.get().setFirstSection(true).render(rule)}
			</td></tr>
		`;
	},
};

Renderer.variantrule = {
	getCompactRenderedString (rule) {
		const cpy = MiscUtil.copyFast(rule);
		delete cpy.name;
		return `
			${Renderer.utils.getExcludedTr({entity: rule, dataProp: "variantrule", page: UrlUtil.PG_VARIANTRULES})}
			${Renderer.utils.getNameTr(rule, {page: UrlUtil.PG_VARIANTRULES})}
			<tr><td colspan="6">
			${Renderer.get().setFirstSection(true).render(cpy)}
			</td></tr>
		`;
	},
};

Renderer.table = {
	getCompactRenderedString (it) {
		it.type = it.type || "table";
		const cpy = MiscUtil.copyFast(it);
		delete cpy.name;
		return `
			${Renderer.utils.getExcludedTr({entity: it, dataProp: "table", page: UrlUtil.PG_TABLES})}
			${Renderer.utils.getNameTr(it, {page: UrlUtil.PG_TABLES})}
			<tr><td colspan="6">
			${Renderer.get().setFirstSection(true).render(it)}
			</td></tr>
		`;
	},

	getConvertedEncounterOrNamesTable ({group, tableRaw, fnGetNameCaption, colLabel1}) {
		const getPadded = (number) => {
			if (tableRaw.diceExpression === "d100") return String(number).padStart(2, "0");
			return String(number);
		};

		const nameCaption = fnGetNameCaption(group, tableRaw);
		return {
			name: nameCaption,
			type: "table",
			source: group?.source,
			page: group?.page,
			caption: nameCaption,
			colLabels: [
				`{@dice ${tableRaw.diceExpression}}`,
				colLabel1,
				tableRaw.rollAttitude ? `Attitude` : null,
			].filter(Boolean),
			colStyles: [
				"col-2 text-center",
				tableRaw.rollAttitude ? "col-8" : "col-10",
				tableRaw.rollAttitude ? `col-2 text-center` : null,
			].filter(Boolean),
			rows: tableRaw.table.map(it => [
				`${getPadded(it.min)}${it.max != null && it.max !== it.min ? `-${getPadded(it.max)}` : ""}`,
				it.result,
				tableRaw.rollAttitude ? it.resultAttitude || "\u2014" : null,
			].filter(Boolean)),
			footnotes: tableRaw.footnotes,
		};
	},

	getConvertedEncounterTableName (group, tableRaw) {
		return `${group.name}${/\bencounters?\b/i.test(group.name) ? "" : " Encounters"}${tableRaw.minlvl && tableRaw.maxlvl ? ` (Levels ${tableRaw.minlvl}\u2014${tableRaw.maxlvl})` : ""}`;
	},

	getConvertedNameTableName (group, tableRaw) {
		return `${group.name} Names \u2013 ${tableRaw.option}`;
	},

	getHeaderRowMetas (ent) {
		if (!ent.colLabels?.length && !ent.colLabelGroups?.length) return null;

		if (ent.colLabels?.length) return [ent.colLabels];

		const maxHeight = Math.max(...ent.colLabelGroups.map(clg => clg.colLabels?.length || 0));

		const padded = ent.colLabelGroups
			.map(clg => {
				const out = [...(clg.colLabels || [])];
				while (out.length < maxHeight) out.unshift("");
				return out;
			});

		return [...new Array(maxHeight)]
			.map((_, i) => padded.map(lbls => lbls[i]));
	},

	_RE_TABLE_ROW_DASHED_NUMBERS: /^\d+([-\u2012\u2013]\d+)?/,
	getAutoConvertedRollMode (table, {headerRowMetas} = {}) {
		if (headerRowMetas === undefined) headerRowMetas = Renderer.table.getHeaderRowMetas(table);

		if (!headerRowMetas || headerRowMetas.last().length < 2) return RollerUtil.ROLL_COL_NONE;

		const rollColMode = RollerUtil.getColRollType(headerRowMetas.last()[0]);
		if (!rollColMode) return RollerUtil.ROLL_COL_NONE;

				if (!table.rows.every(it => {
			if (it?.[0] == null) return false;
			if (it?.[0]?.roll) return true;

			if (typeof it[0] === "number") return Number.isInteger(it[0]);

						return typeof it[0] === "string" && Renderer.table._RE_TABLE_ROW_DASHED_NUMBERS.test(it[0]);
		})) return RollerUtil.ROLL_COL_NONE;

		return rollColMode;
	},
};

Renderer.vehicle = {
	CHILD_PROPS: ["movement", "weapon", "other", "action", "trait", "reaction", "control", "actionStation"],

	getCompactRenderedString (veh, opts) {
		return Renderer.vehicle.getRenderedString(veh, {...opts, isCompact: true});
	},

	getRenderedString (veh, opts) {
		opts = opts || {};

		if (veh.upgradeType) return Renderer.vehicle._getRenderedString_upgrade(veh, opts);

		veh.vehicleType = veh.vehicleType || "SHIP";
		switch (veh.vehicleType) {
			case "SHIP": return Renderer.vehicle._getRenderedString_ship(veh, opts);
			case "SPELLJAMMER": return Renderer.vehicle._getRenderedString_spelljammer(veh, opts);
			case "INFWAR": return Renderer.vehicle._getRenderedString_infwar(veh, opts);
			case "CREATURE": return Renderer.monster.getCompactRenderedString(veh, {...opts, isHideLanguages: true, isHideSenses: true, isCompact: false, page: UrlUtil.PG_VEHICLES});
			case "OBJECT": return Renderer.object.getCompactRenderedString(veh, {...opts, isCompact: false, page: UrlUtil.PG_VEHICLES});
			default: throw new Error(`Unhandled vehicle type "${veh.vehicleType}"`);
		}
	},

	getUpgradeSummary (it) {
		return [
			it.upgradeType ? it.upgradeType.map(t => Parser.vehicleTypeToFull(t)) : null,
			it.prerequisite ? Renderer.utils.prerequisite.getHtml(it.prerequisite) : "",
		].filter(Boolean).join(", ");
	},

	_getRenderedString_upgrade (it, opts) {
		return $$`${Renderer.utils.getExcludedTr({entity: it, dataProp: "vehicleUpgrade", page: UrlUtil.PG_VEHICLES})}
			${Renderer.utils.getNameTr(it, {page: UrlUtil.PG_VEHICLES})}
			<tr><td colspan="6"><i>${Renderer.vehicle.getUpgradeSummary(it)}</i></td></tr>
			<tr><td class="divider" colspan="6"><div></div></td></tr>
			<tr><td colspan="6">${Renderer.get().render({entries: it.entries}, 1)}</td></tr>`;
	},

	ship: {
		getLocomotionEntries (loc) {
			return {
				type: "list",
				style: "list-hang-notitle",
				items: [
					{
						type: "item",
						name: `Locomotion (${loc.mode})`,
						entries: loc.entries,
					},
				],
			};
		},

		getSpeedEntries (spd) {
			return {
				type: "list",
				style: "list-hang-notitle",
				items: [
					{
						type: "item",
						name: `Speed (${spd.mode})`,
						entries: spd.entries,
					},
				],
			};
		},

		getActionPart_ (renderer, veh) {
			return renderer.render({entries: veh.action});
		},

		getSectionTitle_ (title) {
			return `<tr class="mon__stat-header-underline"><td colspan="6"><h3 class="mon__sect-header-inner">${title}</h3></td></tr>`;
		},

		getSectionHpPart_ (renderer, sect, each) {
			if (!sect.ac && !sect.hp) return "";
			return `
				<div><b>Armor Class</b> ${sect.ac}</div>
				<div><b>Hit Points</b> ${sect.hp}${each ? ` each` : ""}${sect.dt ? ` (damage threshold ${sect.dt})` : ""}${sect.hpNote ? `; ${renderer.render(sect.hpNote)}` : ""}</div>
			`;
		},

		getControlSection_ (renderer, control) {
			if (!control) return "";
			return `
				<tr class="mon__stat-header-underline"><td colspan="6"><h3 class="mon__sect-header-inner">Control: ${control.name}</h3></td></tr>
				<tr><td colspan="6" class="mon__sect-row-inner">
				${Renderer.vehicle.ship.getSectionHpPart_(renderer, control)}
				<div class="rd__b--1">${renderer.render({entries: control.entries})}</div>
				</td></tr>
			`;
		},

		getMovementSection_ (renderer, move) {
			if (!move) return "";

			function getLocomotionSection (loc) {
				const asList = Renderer.vehicle.ship.getLocomotionEntries(loc);
				return `<div class="rd__b--1">${renderer.render(asList)}</div>`;
			}

			function getSpeedSection (spd) {
				const asList = Renderer.vehicle.ship.getSpeedEntries(spd);
				return `<div class="rd__b--1">${renderer.render(asList)}</div>`;
			}

			return `
				<tr class="mon__stat-header-underline"><td colspan="6"><h3 class="mon__sect-header-inner">${move.isControl ? `Control and ` : ""}Movement: ${move.name}</h3></td></tr>
				<tr><td colspan="6" class="mon__sect-row-inner">
				${Renderer.vehicle.ship.getSectionHpPart_(renderer, move)}
				${(move.locomotion || []).map(getLocomotionSection)}
				${(move.speed || []).map(getSpeedSection)}
				</td></tr>
			`;
		},

		getWeaponSection_ (renderer, weap) {
			return `
				<tr class="mon__stat-header-underline"><td colspan="6"><h3 class="mon__sect-header-inner">Weapons: ${weap.name}${weap.count ? ` (${weap.count})` : ""}</h3></td></tr>
				<tr><td colspan="6" class="mon__sect-row-inner">
				${Renderer.vehicle.ship.getSectionHpPart_(renderer, weap, !!weap.count)}
				${renderer.render({entries: weap.entries})}
				</td></tr>
			`;
		},

		getOtherSection_ (renderer, oth) {
			return `
				<tr class="mon__stat-header-underline"><td colspan="6"><h3 class="mon__sect-header-inner">${oth.name}</h3></td></tr>
				<tr><td colspan="6" class="mon__sect-row-inner">
				${Renderer.vehicle.ship.getSectionHpPart_(renderer, oth)}
				${renderer.render({entries: oth.entries})}
				</td></tr>
			`;
		},

		getSizeDimensionsSection_ (renderer, veh) {
			return `<tr class="text"><td colspan="6"><i>${Parser.sizeAbvToFull(veh.size)} vehicle${veh.dimensions ? ` (${veh.dimensions.join(" by ")})` : ""}</i><br></td></tr>`;
		},

		getCrewCargoPageSection_ (renderer, veh) {
			if (veh.capCrew == null && veh.capCargo == null && veh.pace == null) return "";

			return `<tr class="text"><td colspan="6">
				${veh.capCrew != null || veh.capPassenger != null ? `<div><b>Creature Capacity</b> ${Renderer.vehicle.getShipCreatureCapacity(veh)}</div>` : ""}
				${veh.capCargo != null ? `<div><b>Cargo Capacity</b> ${Renderer.vehicle.getShipCargoCapacity(veh)}</div>` : ""}
				${veh.pace != null ? `<div><b>Travel Pace</b> ${veh.pace} miles per hour (${veh.pace * 24} miles per day)</div>
				<div class="ve-muted ve-small help-subtle ml-2" title="Based on &quot;Special Travel Pace,&quot; DMG p242">[<b>Speed</b> ${veh.pace * 10} ft.]</div>` : ""}
			</td></tr>`;
		},
	},

	spelljammer: {
		getSummarySection_ (renderer, veh) {
			const ptAc = veh.hull?.ac
				? `${veh.hull.ac}${veh.hull.acFrom ? ` (${veh.hull.acFrom.join(", ")})` : ""}`
				: "\u2014";

			const ptSpeed = veh.speed != null
				? Parser.getSpeedString(veh, {isSkipZeroWalk: true})
				: "";
			const ptPace = Renderer.vehicle.spelljammer._getPtPace(renderer, veh);

			const ptSpeedPace = [ptSpeed, ptPace].filter(Boolean).join(" ");

			return `<tr><td colspan="6">
				<table class="w-100 summary stripe-odd-table">
					<tr>
						<td class="col-6"><b>Armor Class:</b> ${ptAc}</td>
						<td class="col-6"><b>Cargo:</b> ${veh.capCargo ? `${veh.capCargo} ton${veh.capCargo === 1 ? "" : "s"}` : "\u2014"}</td>
					</tr>
					<tr>
						<td class="col-6"><b>Hit Points:</b> ${veh.hull?.hp ?? "\u2014"}</td>
						<td class="col-6"><b>Crew:</b> ${veh.capCrew ?? "\u2014"}${veh.capCrewNote ? ` ${renderer.render(veh.capCrewNote)}` : ""}</td>
					</tr>
					<tr>
						<td class="col-6"><b>Damage Threshold:</b> ${veh.hull?.dt ?? "\u2014"}</td>
						<td class="col-6"><b>Keel/Beam:</b> ${(veh.dimensions || ["\u2014"]).join("/")}</td>
					</tr>
					<tr>
						<td class="col-6"><b>Speed:</b> ${ptSpeedPace}</td>
						<td class="col-6"><b>Cost:</b> ${veh.cost != null ? Parser.vehicleCostToFull(veh) : "\u2014"}</td>
					</tr>
				</table>
			</td></tr>`;
		},

		_getPtPace (renderer, veh) {
			if (!veh.pace) return "";

			const isMulti = Object.keys(veh.pace).length > 1;

			const out = Parser.SPEED_MODES
				.map(mode => {
					const pace = veh.pace[mode];
					if (!pace) return null;

					const asNum = Parser.vulgarToNumber(pace);
					return `<span class="help-subtle" title="${asNum * 24} miles per day">${isMulti && mode !== "walk" ? `${mode} ` : ""}${pace} mph</span>`;
				})
				.filter(Boolean)
				.join(", ");

			return `(${out})`;
		},

		getWeaponSection_ (renderer, weap) {
			const isMultiple = weap.count != null && weap.count > 1;
			const ptAction = weap.action?.length
				? weap.action.map(act => `<div class="mt-1">${renderer.render(act, 2)}</div>`).join("")
				: "";
			return `
				<tr class="mon__stat-header-underline"><td colspan="6"><h3 class="mon__sect-header-inner">${isMultiple ? `${weap.count} ` : ""}${weap.name}${weap.crew ? ` (Crew: ${weap.crew}${isMultiple ? " each" : ""})` : ""}</h3></td></tr>
				<tr><td colspan="6" class="mon__sect-row-inner">
				${Renderer.vehicle.spelljammer.getSectionHpCostPart_(renderer, weap)}
				${weap.entries?.length ? `<div>${renderer.render({entries: weap.entries})}</div>` : ""}
				${ptAction}
				</td></tr>
			`;
		},

		getSectionHpCostPart_ (renderer, sect) {
			const ptCosts = sect.costs?.length
				? sect.costs.map(cost => {
					return `${Parser.vehicleCostToFull(cost) || "\u2014"}${cost.note ? `  (${renderer.render(cost.note)})` : ""}`;
				}).join(", ")
				: "\u2014";
			return `
				<div><b>Armor Class:</b> ${sect.ac == null ? "\u2014" : sect.ac}</div>
				<div><b>Hit Points:</b> ${sect.hp == null ? "\u2014" : sect.hp}</div>
				<div class="mb-2"><b>Cost:</b> ${ptCosts}</div>
			`;
		},
	},

	_getAbilitySection (veh) {
		return Parser.ABIL_ABVS.some(it => veh[it] != null) ? `<tr><td colspan="6">
			<table class="w-100 summary stripe-even-table">
				<tr>
					<th class="col-2 text-center">STR</th>
					<th class="col-2 text-center">DEX</th>
					<th class="col-2 text-center">CON</th>
					<th class="col-2 text-center">INT</th>
					<th class="col-2 text-center">WIS</th>
					<th class="col-2 text-center">CHA</th>
				</tr>
				<tr>
					<td class="text-center">${Renderer.utils.getAbilityRoller(veh, "str")}</td>
					<td class="text-center">${Renderer.utils.getAbilityRoller(veh, "dex")}</td>
					<td class="text-center">${Renderer.utils.getAbilityRoller(veh, "con")}</td>
					<td class="text-center">${Renderer.utils.getAbilityRoller(veh, "int")}</td>
					<td class="text-center">${Renderer.utils.getAbilityRoller(veh, "wis")}</td>
					<td class="text-center">${Renderer.utils.getAbilityRoller(veh, "cha")}</td>
				</tr>
			</table>
		</td></tr>` : "";
	},

	_getResImmVulnSection (veh) {
		if (!veh.immune && !veh.conditionImmune) return "";

		return `<tr class="text"><td colspan="6">
			${veh.immune ? `<div><b>Damage Immunities</b> ${Parser.getFullImmRes(veh.immune)}</div>` : ""}
			${veh.conditionImmune ? `<div><b>Condition Immunities</b> ${Parser.getFullCondImm(veh.conditionImmune)}</div>` : ""}
		</td></tr>`;
	},

	_getTraitSection (renderer, veh) {
		return veh.trait ? `<tr class="mon__stat-header-underline"><td colspan="6"><h3 class="mon__sect-header-inner">Traits</h3></td></tr>
		<tr><td colspan="6"><div class="border"></div></td></tr>
		<tr class="text"><td colspan="6">
		${Renderer.monster.getOrderedTraits(veh, renderer).map(it => it.rendered || renderer.render(it, 2)).join("")}
		</td></tr>` : "";
	},

	_getRenderedString_ship (veh, opts) {
		const renderer = Renderer.get();

				const otherSectionActions = (veh.other || []).filter(it => it.name === "Actions");
		const otherSectionOthers = (veh.other || []).filter(it => it.name !== "Actions");

		const hasToken = veh.tokenUrl || veh.hasToken;
		const extraThClasses = !opts.isCompact && hasToken ? ["veh__name--token"] : null;

		return `
			${Renderer.utils.getExcludedTr({entity: veh, dataProp: "vehicle", page: UrlUtil.PG_VEHICLES})}
			${Renderer.utils.getNameTr(veh, {extraThClasses, page: UrlUtil.PG_VEHICLES})}
			${Renderer.vehicle.ship.getSizeDimensionsSection_(renderer, veh)}
			${Renderer.vehicle.ship.getCrewCargoPageSection_(renderer, veh)}
			${Renderer.vehicle._getAbilitySection(veh)}
			${Renderer.vehicle._getResImmVulnSection(veh)}
			${veh.action ? Renderer.vehicle.ship.getSectionTitle_("Actions") : ""}
			${veh.action ? `<tr><td colspan="6" class="mon__sect-row-inner">${Renderer.vehicle.ship.getActionPart_(renderer, veh)}</td></tr>` : ""}
			${otherSectionActions.map(Renderer.vehicle.ship.getOtherSection_.bind(this, renderer)).join("")}
			${veh.hull ? `${Renderer.vehicle.ship.getSectionTitle_("Hull")}
			<tr><td colspan="6" class="mon__sect-row-inner">
			${Renderer.vehicle.ship.getSectionHpPart_(renderer, veh.hull)}
			</td></tr>` : ""}
			${Renderer.vehicle._getTraitSection(renderer, veh)}
			${(veh.control || []).map(Renderer.vehicle.ship.getControlSection_.bind(this, renderer)).join("")}
			${(veh.movement || []).map(Renderer.vehicle.ship.getMovementSection_.bind(this, renderer)).join("")}
			${(veh.weapon || []).map(Renderer.vehicle.ship.getWeaponSection_.bind(this, renderer)).join("")}
			${otherSectionOthers.map(Renderer.vehicle.ship.getOtherSection_.bind(this, renderer)).join("")}
		`;
	},

	getShipCreatureCapacity (veh) {
		return [
			veh.capCrew ? `${veh.capCrew} crew` : null,
			veh.capPassenger ? `${veh.capPassenger} passenger${veh.capPassenger === 1 ? "" : "s"}` : null,
		].filter(Boolean).join(", ");
	},
	getShipCargoCapacity (veh) { return typeof veh.capCargo === "string" ? veh.capCargo : `${veh.capCargo} ton${veh.capCargo === 1 ? "" : "s"}`; },

	_getRenderedString_spelljammer (veh, opts) {
		const renderer = Renderer.get();

		const hasToken = veh.tokenUrl || veh.hasToken;
		const extraThClasses = !opts.isCompact && hasToken ? ["veh__name--token"] : null;

		return `
			${Renderer.utils.getExcludedTr({entity: veh, dataProp: "vehicle", page: UrlUtil.PG_VEHICLES})}
			${Renderer.utils.getNameTr(veh, {extraThClasses, page: UrlUtil.PG_VEHICLES})}
			${Renderer.vehicle.spelljammer.getSummarySection_(renderer, veh)}
			${(veh.weapon || []).map(Renderer.vehicle.spelljammer.getWeaponSection_.bind(this, renderer)).join("")}
		`;
	},

	_getRenderedString_infwar (veh, opts) {
		const renderer = Renderer.get();
		const dexMod = Parser.getAbilityModNumber(veh.dex);

		const hasToken = veh.tokenUrl || veh.hasToken;
		const extraThClasses = !opts.isCompact && hasToken ? ["veh__name--token"] : null;

		return `
			${Renderer.utils.getExcludedTr({entity: veh, datProp: "vehicle", page: UrlUtil.PG_VEHICLES})}
			${Renderer.utils.getNameTr(veh, {extraThClasses, page: UrlUtil.PG_VEHICLES})}
			<tr class="text"><td colspan="6"><i>${Parser.sizeAbvToFull(veh.size)} vehicle (${veh.weight.toLocaleString()} lb.)</i><br></td></tr>
			<tr class="text"><td colspan="6">
				<div><b>Creature Capacity</b> ${Renderer.vehicle.getInfwarCreatureCapacity(veh)}</div>
				<div><b>Cargo Capacity</b> ${Parser.weightToFull(veh.capCargo)}</div>
				<div><b>Armor Class</b> ${dexMod === 0 ? `19` : `${19 + dexMod} (19 while motionless)`}</div>
				<div><b>Hit Points</b> ${veh.hp.hp} (damage threshold ${veh.hp.dt}, mishap threshold ${veh.hp.mt})</div>
				<div><b>Speed</b> ${veh.speed} ft.</div>
				<div class="ve-muted ve-small help-subtle ml-2" title="Based on &quot;Special Travel Pace,&quot; DMG p242">[<b>Travel Pace</b> ${Math.floor(veh.speed / 10)} miles per hour (${Math.floor(veh.speed * 24 / 10)} miles per day)]</div>
			</td></tr>
			${Renderer.vehicle._getAbilitySection(veh)}
			${Renderer.vehicle._getResImmVulnSection(veh)}
			${Renderer.vehicle._getTraitSection(renderer, veh)}
			${Renderer.monster.getCompactRenderedStringSection(veh, renderer, "Action Stations", "actionStation", 2)}
			${Renderer.monster.getCompactRenderedStringSection(veh, renderer, "Reactions", "reaction", 2)}
		`;
	},

	getInfwarCreatureCapacity (veh) { return `${veh.capCreature} Medium creatures`; },

	pGetFluff (veh) {
		return Renderer.utils.pGetFluff({
			entity: veh,
			fnGetFluffData: DataUtil.vehicleFluff.loadJSON.bind(DataUtil.vehicleFluff),
			fluffProp: "vehicleFluff",
		});
	},

	getTokenUrl (veh) {
		return veh.tokenUrl || UrlUtil.link(`${Renderer.get().baseMediaUrls["img"] || Renderer.get().baseUrl}img/vehicles/tokens/${Parser.sourceJsonToAbv(veh.source)}/${Parser.nameToTokenName(veh.name)}.png`);
	},
};

Renderer.action = {
	getCompactRenderedString (it) {
		const cpy = MiscUtil.copyFast(it);
		delete cpy.name;
		return `${Renderer.utils.getExcludedTr({entity: it, dataProp: "action", page: UrlUtil.PG_ACTIONS})}
		${Renderer.utils.getNameTr(it, {page: UrlUtil.PG_ACTIONS})}
		<tr><td colspan="6">${Renderer.get().setFirstSection(true).render(cpy)}</td></tr>`;
	},
};

Renderer.language = {
	getCompactRenderedString (it) {
		return Renderer.language.getRenderedString(it);
	},

	getRenderedString (it, {isSkipNameRow = false} = {}) {
		const allEntries = [];

		const hasMeta = it.typicalSpeakers || it.script;

		if (it.entries) allEntries.push(...it.entries);
		if (it.dialects) {
			allEntries.push(`This language is a family which includes the following dialects: ${it.dialects.sort(SortUtil.ascSortLower).join(", ")}. Creatures that speak different dialects of the same language can communicate with one another.`);
		}

		if (!allEntries.length && !hasMeta) allEntries.push("{@i No information available.}");

		return `
		${Renderer.utils.getExcludedTr({entity: it, dataProp: "language", page: UrlUtil.PG_LANGUAGES})}
		${isSkipNameRow ? "" : Renderer.utils.getNameTr(it, {page: UrlUtil.PG_LANGUAGES})}
		${it.type ? `<tr class="text"><td colspan="6" class="pt-0"><i>${it.type.toTitleCase()} language</i></td></tr>` : ""}
		${hasMeta ? `<tr class="text"><td colspan="6">
		${it.typicalSpeakers ? `<div><b>Typical Speakers</b> ${Renderer.get().render(it.typicalSpeakers.join(", "))}</b>` : ""}
		${it.script ? `<div><b>Script</b> ${Renderer.get().render(it.script)}</div>` : ""}
		<div></div>
		</td></tr>` : ""}
		${allEntries.length ? `<tr class="text"><td colspan="6">
		${Renderer.get().setFirstSection(true).render({entries: allEntries})}
		</td></tr>` : ""}`;
	},

	pGetFluff (it) {
		return Renderer.utils.pGetFluff({
			entity: it,
			fnGetFluffData: DataUtil.languageFluff.loadJSON.bind(DataUtil.languageFluff),
			fluffProp: "languageFluff",
		});
	},
};

Renderer.adventureBook = {
	getEntryIdLookup (bookData, doThrowError = true) {
		const out = {};
		const titlesRel = {};

		let chapIx;
		const depthStack = [];
		const handlers = {
			object: (obj) => {
				Renderer.ENTRIES_WITH_ENUMERATED_TITLES
					.forEach(meta => {
						if (obj.type !== meta.type) return;

						const curDepth = depthStack.length ? depthStack.last() : 0;
						const nxtDepth = meta.depth ? meta.depth : meta.depthIncrement ? curDepth + meta.depthIncrement : curDepth;

						depthStack.push(
							Math.min(
								nxtDepth,
								2,
							),
						);

						if (obj.id) {
							if (out[obj.id]) {
								(out.__BAD = out.__BAD || []).push(obj.id);
							} else {
								out[obj.id] = {
									chapter: chapIx,
									entry: obj,
									depth: depthStack.last(),
								};

								if (obj.name) {
									const cleanName = obj.name.toLowerCase();
									titlesRel[cleanName] = titlesRel[cleanName] || 0;
									out[obj.id].ixTitleRel = titlesRel[cleanName]++;
									out[obj.id].nameClean = cleanName;
								}
							}
						}
					});

				return obj;
			},
			postObject: (obj) => {
				Renderer.ENTRIES_WITH_ENUMERATED_TITLES
					.forEach(meta => {
						if (obj.type !== meta.type) return;

						depthStack.pop();
					});
			},
		};

		bookData.forEach((chap, _chapIx) => {
			chapIx = _chapIx;
			MiscUtil.getWalker({isNoModification: true}).walk(chap, handlers);
		});

		if (doThrowError) if (out.__BAD) throw new Error(`IDs were already in storage: ${out.__BAD.map(it => `"${it}"`).join(", ")}`);

		return out;
	},

	_isAltMissingCoverUsed: false,
	getCoverUrl (contents) {
		return contents.coverUrl
			|| `${Renderer.get().baseMediaUrls["img"] || Renderer.get().baseUrl}img/covers/blank${Math.random() <= 0.05 && !Renderer.adventureBook._isAltMissingCoverUsed && (Renderer.adventureBook._isAltMissingCoverUsed = true) ? "-alt" : ""}.png`;
	},
};

Renderer.charoption = {
	getCompactRenderedString (it) {
		const prerequisite = Renderer.utils.prerequisite.getHtml(it.prerequisite);
		const preText = Renderer.charoption.getOptionTypePreText(it.optionType);
		return `
		${Renderer.utils.getExcludedTr({entity: it, dataProp: "charoption", page: UrlUtil.PG_CHAR_CREATION_OPTIONS})}
		${Renderer.utils.getNameTr(it, {page: UrlUtil.PG_CHAR_CREATION_OPTIONS})}
		<tr class="text"><td colspan="6">
		${prerequisite ? `<p>${prerequisite}</p>` : ""}
		${preText || ""}${Renderer.get().setFirstSection(true).render({type: "entries", entries: it.entries})}
		</td></tr>
		`;
	},

	_OPTION_TYPE_ENTRIES: {
		"RF:B": `{@note You may replace the standard feature of your background with this feature.}`,
		"CS": `{@note See the {@adventure Character Secrets|IDRotF|0|character secrets} section for more information.}`,
	},
	getOptionTypePreText (optionTypes) {
		const mapped = optionTypes.map(it => Renderer.charoption._OPTION_TYPE_ENTRIES[it]).filter(Boolean);
		return mapped.length ? Renderer.get().render({type: "entries", entries: mapped}) : "";
	},

	pGetFluff (it) {
		return Renderer.utils.pGetFluff({
			entity: it,
			fnGetFluffData: DataUtil.charoptionFluff.loadJSON.bind(DataUtil.charoptionFluff),
			fluffProp: "charoptionFluff",
		});
	},
};

Renderer.recipe = {
	getCompactRenderedString (it) {
		return `${Renderer.utils.getExcludedTr({entity: it, dataProp: "recipe", page: UrlUtil.PG_RECIPES})}
		${Renderer.utils.getNameTr(it, {page: UrlUtil.PG_RECIPES})}
		<tr><td colspan="6">
		${Renderer.recipe.getBodyHtml(it)}
		</td></tr>`;
	},

	getBodyHtml (it) {
		const {ptMakes, ptServes} = Renderer.recipe._getMakesServesHtml(it);

		return `<div class="ve-flex w-100 rd-recipes__wrp-recipe">
			<div class="ve-flex-1 ve-flex-col br-1p pr-2">
				${ptMakes || ""}
				${ptServes || ""}

				<div class="rd-recipes__wrp-ingredients ${ptMakes || ptServes ? "mt-1" : ""}">${Renderer.get().render({entries: it._fullIngredients}, 0)}</div>

				${it._fullEquipment?.length ? `<div class="rd-recipes__wrp-ingredients mt-4"><div class="ve-flex-vh-center bold mb-1 small-caps">Equipment</div><div>${Renderer.get().render({entries: it._fullEquipment})}</div></div>` : ""}

				${it.noteCook ? `<div class="w-100 ve-flex-col mt-4"><div class="ve-flex-vh-center bold mb-1 small-caps">Cook's Notes</div><div class="italic">${Renderer.get().render({entries: it.noteCook})}</div></div>` : ""}
			</div>

			<div class="pl-2 ve-flex-2 rd-recipes__wrp-instructions">
				${Renderer.get().setFirstSection(true).render({entries: it.instructions}, 2)}
			</div>
		</div>`;
	},

	_getMakesServesHtml (it) {
		const ptMakes = it.makes ? `<div class="mb-2 ve-flex-v-center">
			<div class="bold small-caps mr-2">Makes</div>
			<div>${it._scaleFactor ? `${it._scaleFactor}× ` : ""}${Renderer.get().render(it.makes || it.serves)}</div>
		</div>` : null;

		const ptServes = it.serves ? `<div class="mb-2 ve-flex-v-center">
			<div class="bold small-caps mr-2">Serves</div>
			<div>${it.serves.min ?? it.serves.exact}${it.serves.min != null ? " to " : ""}${it.serves.max ?? ""}</div>
		</div>` : null;

		return {ptMakes, ptServes};
	},

	pGetFluff (it) {
		return Renderer.utils.pGetFluff({
			entity: it,
			fnGetFluffData: DataUtil.recipeFluff.loadJSON.bind(DataUtil.recipeFluff),
			fluffProp: "recipeFluff",
		});
	},

	populateFullIngredients (r) {
		r._fullIngredients = Renderer.applyAllProperties(MiscUtil.copyFast(r.ingredients));
		if (r.equipment) r._fullEquipment = Renderer.applyAllProperties(MiscUtil.copyFast(r.equipment));
	},

	_RE_AMOUNT: /(?<tagAmount>{=amount\d+(?:\/[^}]+)?})/g,
	getScaledRecipe (r, scaleFactor) {
		const cpyR = MiscUtil.copyFast(r);

		["ingredients", "equipment"]
			.forEach(prop => {
				if (!cpyR[prop]) return;

				MiscUtil.getWalker({keyBlocklist: MiscUtil.GENERIC_WALKER_ENTRIES_KEY_BLOCKLIST}).walk(
					cpyR[prop],
					{
						object: (obj) => {
							if (obj.type !== "ingredient") return obj;

							const objOriginal = MiscUtil.copyFast(obj);

							Object.keys(obj)
								.filter(k => /^amount\d+/.test(k))
								.forEach(k => {
									let base = obj[k];

									if (Math.round(base) !== base && base < 20) {
										const divOneSixth = obj[k] / 0.166;
										if (Math.abs(divOneSixth - Math.round(divOneSixth)) < 0.05) base = (1 / 6) * Math.round(divOneSixth);
									}

									let scaled = base * scaleFactor;
									if (Math.abs(scaled - Math.round(scaled)) < 0.1) {
										scaled = Math.round(scaled);
									}
									obj[k] = scaled;
								});

														const amountsOriginal = Object.keys(objOriginal).filter(k => /^amount\d+$/.test(k)).map(k => objOriginal[k]);
							const amountsScaled = Object.keys(obj).filter(k => /^amount\d+$/.test(k)).map(k => obj[k]);

							const entryParts = obj.entry.split(Renderer.recipe._RE_AMOUNT).filter(Boolean);
							const entryPartsOut = entryParts.slice(0, entryParts.findIndex(it => Renderer.recipe._RE_AMOUNT.test(it)) + 1);
							let ixAmount = 0;
							for (let i = entryPartsOut.length; i < entryParts.length; ++i) {
								let pt = entryParts[i];

								if (Renderer.recipe._RE_AMOUNT.test(pt)) {
									ixAmount++;
									entryPartsOut.push(pt);
									continue;
								}

								if (amountsOriginal[ixAmount] == null || amountsScaled[ixAmount] == null) {
									entryPartsOut.push(pt);
									continue;
								}

								const isSingleToPlural = amountsOriginal[ixAmount] <= 1 && amountsScaled[ixAmount] > 1;
								const isPluralToSingle = amountsOriginal[ixAmount] > 1 && amountsScaled[ixAmount] <= 1;

								if (!isSingleToPlural && !isPluralToSingle) {
									entryPartsOut.push(pt);
									continue;
								}

								if (isSingleToPlural) pt = Renderer.recipe._getPluralizedUnits(pt);
								else if (isPluralToSingle) pt = Renderer.recipe._getSingleizedUnits(pt);
								entryPartsOut.push(pt);
							}

							obj.entry = entryPartsOut.join("");
							
							Renderer.recipe._mutWrapOriginalAmounts({obj, objOriginal});

							return obj;
						},
					},
				);
			});

		Renderer.recipe.populateFullIngredients(cpyR);

		if (cpyR.serves) {
			if (cpyR.serves.min) cpyR.serves.min *= scaleFactor;
			if (cpyR.serves.max) cpyR.serves.max *= scaleFactor;
			if (cpyR.serves.exact) cpyR.serves.exact *= scaleFactor;
		}

		cpyR._displayName = `${cpyR.name} (×${scaleFactor})`;
		cpyR._scaleFactor = scaleFactor;

		return cpyR;
	},

	_UNITS_SINGLE_TO_PLURAL_S: [
		"bundle",
		"cup",
		"handful",
		"ounce",
		"piece",
		"pound",
		"slice",
		"sprig",
		"square",
		"strip",
		"tablespoon",
		"teaspoon",
		"wedge",
	],
	_UNITS_SINGLE_TO_PLURAL_ES: [
		"dash",
		"inch",
	],
	_FNS_SINGLE_TO_PLURAL: [],
	_FNS_PLURAL_TO_SINGLE: [],

	_getSingleizedUnits (str) {
		if (!Renderer.recipe._FNS_PLURAL_TO_SINGLE.length) {
			Renderer.recipe._FNS_PLURAL_TO_SINGLE = [
				...Renderer.recipe._UNITS_SINGLE_TO_PLURAL_S.map(word => str => str.replace(new RegExp(`\\b${word.escapeRegexp()}s\\b`, "gi"), (...m) => m[0].slice(0, -1))),
				...Renderer.recipe._UNITS_SINGLE_TO_PLURAL_ES.map(word => str => str.replace(new RegExp(`\\b${word.escapeRegexp()}es\\b`, "gi"), (...m) => m[0].slice(0, -2))),
			];
		}

		Renderer.recipe._FNS_PLURAL_TO_SINGLE.forEach(fn => str = fn(str));

		return str;
	},

	_getPluralizedUnits (str) {
		if (!Renderer.recipe._FNS_SINGLE_TO_PLURAL.length) {
			Renderer.recipe._FNS_SINGLE_TO_PLURAL = [
				...Renderer.recipe._UNITS_SINGLE_TO_PLURAL_S.map(word => str => str.replace(new RegExp(`\\b${word.escapeRegexp()}\\b`, "gi"), (...m) => `${m[0]}s`)),
				...Renderer.recipe._UNITS_SINGLE_TO_PLURAL_ES.map(word => str => str.replace(new RegExp(`\\b${word.escapeRegexp()}\\b`, "gi"), (...m) => `${m[0]}es`)),
			];
		}

		Renderer.recipe._FNS_SINGLE_TO_PLURAL.forEach(fn => str = fn(str));

		return str;
	},

		_mutWrapOriginalAmounts ({obj, objOriginal}) {
		const parts = [];
		let stack = "";
		let depth = 0;
		for (let i = 0; i < obj.entry.length; ++i) {
			const c = obj.entry[i];
			switch (c) {
				case "{": {
					depth++;
					stack += c;
					break;
				}
				case "}": {
					depth--;
					stack += c;
					if (!depth && stack) {
						parts.push(stack);
						stack = "";
					}
					break;
				}
				default: stack += c;
			}
		}
		if (stack) parts.push(stack);
		obj.entry = parts
			.map(pt => pt.replace(Renderer.recipe._RE_AMOUNT, (...m) => {
				const ixStart = m.slice(-3, -2)[0];
				if (ixStart !== 0 || m[0].length !== pt.length) return m[0];

				const originalValue = Renderer.applyProperties(m.last().tagAmount, objOriginal);
				return `{@help ${m.last().tagAmount}|In the original recipe: ${originalValue}}`;
			}))
			.join("");
	},

		getCustomHashId (it) {
		if (!it._scaleFactor) return null;

		const {
			name,
			source,
			_scaleFactor: scaleFactor,
		} = it;

		return [
			name,
			source,
			scaleFactor ?? "",
		].join("__").toLowerCase();
	},

	getUnpackedCustomHashId (customHashId) {
		if (!customHashId) return null;

		const [, , scaleFactor] = customHashId.split("__").map(it => it.trim());

		if (!scaleFactor) return null;

		return {
			_scaleFactor: scaleFactor ? Number(scaleFactor) : null,
			customHashId,
		};
	},
	};

Renderer.card = {
	getFullEntries (ent) {
		const entries = [...ent.entries || []];
		if (ent.suit && (ent.valueName || ent.value)) {
			const suitAndValue = `${((ent.valueName || "") || Parser.numberToText(ent.value)).toTitleCase()} of ${ent.suit.toTitleCase()}`;
			if (suitAndValue.toLowerCase() !== ent.name.toLowerCase()) entries.unshift(`{@i ${suitAndValue}}`);
		}
		return entries;
	},

	getCompactRenderedString (ent) {
		const fullEntries = Renderer.card.getFullEntries(ent);
		return `
			${Renderer.utils.getNameTr(ent)}
			<tr class="text"><td colspan="6">
			${Renderer.get().setFirstSection(true).render({...ent.face, maxHeight: 40, maxHeightUnits: "vh"})}
			${fullEntries?.length ? `<hr class="hr-3">
			${Renderer.get().setFirstSection(true).render({type: "entries", entries: fullEntries}, 1)}` : ""}
			</td></tr>
		`;
	},
};

Renderer.deck = {
	getCompactRenderedString (ent) {
		const lstCards = {
			name: "Cards",
			entries: [
				{
					type: "list",
					columns: 3,
					items: ent.cards.map(card => `{@card ${card.name}|${card.set}|${card.source}}`),
				},
			],
		};

		return `
			${Renderer.utils.getNameTr(ent)}
			<tr class="text"><td colspan="6">
			${Renderer.get().setFirstSection(true).render({type: "entries", entries: ent.entries}, 1)}
			<hr class="hr-3">
			${Renderer.get().setFirstSection(true).render(lstCards, 1)}
			</td></tr>
		`;
	},
};

Renderer.skill = {
	getCompactRenderedString (ent) {
		return Renderer.generic.getCompactRenderedString(ent);
	},
};

Renderer.sense = {
	getCompactRenderedString (ent) {
		return Renderer.generic.getCompactRenderedString(ent);
	},
};

Renderer.itemMastery = {
	getCompactRenderedString (ent) {
		return Renderer.generic.getCompactRenderedString(ent);
	},
};

Renderer.generic = {
		getCompactRenderedString (it, opts) {
		opts = opts || {};
		const prerequisite = Renderer.utils.prerequisite.getHtml(it.prerequisite);

		return `
		${opts.dataProp && opts.page ? Renderer.utils.getExcludedTr({entity: it, dataProp: opts.dataProp, page: opts.page}) : ""}
		${opts.isSkipNameRow ? "" : Renderer.utils.getNameTr(it, {page: opts.page})}
		<tr class="text"><td colspan="6">
		${prerequisite ? `<p>${prerequisite}</p>` : ""}
		${Renderer.get().setFirstSection(true).render({entries: it.entries})}
		</td></tr>
		${opts.isSkipPageRow ? "" : Renderer.utils.getPageTr(it)}`;
	},
};

Renderer.hover = {
	LinkMeta: function () {
		this.isHovered = false;
		this.isLoading = false;
		this.isPermanent = false;
		this.windowMeta = null;
	},

	_BAR_HEIGHT: 16,

	_linkCache: {},
	_eleCache: new Map(),
	_entryCache: {},
	_isInit: false,
	_dmScreen: null,
	_lastId: 0,
	_contextMenu: null,
	_contextMenuLastClicked: null,

	bindDmScreen (screen) { this._dmScreen = screen; },

	_getNextId () { return ++Renderer.hover._lastId; },

	_doInit () {
		if (!Renderer.hover._isInit) {
			Renderer.hover._isInit = true;

			$(document.body).on("click", () => Renderer.hover.cleanTempWindows());

			Renderer.hover._contextMenu = ContextUtil.getMenu([
				new ContextUtil.Action(
					"Maximize All",
					() => {
						const $permWindows = $(`.hoverborder[data-perm="true"]`);
						$permWindows.attr("data-display-title", "false");
					},
				),
				new ContextUtil.Action(
					"Minimize All",
					() => {
						const $permWindows = $(`.hoverborder[data-perm="true"]`);
						$permWindows.attr("data-display-title", "true");
					},
				),
				null,
				new ContextUtil.Action(
					"Close Others",
					() => {
						const hoverId = Renderer.hover._contextMenuLastClicked?.hoverId;
						Renderer.hover._doCloseAllWindows({hoverIdBlocklist: new Set([hoverId])});
					},
				),
				new ContextUtil.Action(
					"Close All",
					() => Renderer.hover._doCloseAllWindows(),
				),
			]);
		}
	},

	cleanTempWindows () {
		for (const [ele, meta] of Renderer.hover._eleCache.entries()) {
			if (!meta.isPermanent && meta.windowMeta && !document.body.contains(ele)) {
				meta.windowMeta.doClose();
			} else if (!meta.isPermanent && meta.isHovered && meta.windowMeta) {
								const bounds = ele.getBoundingClientRect();
				if (EventUtil._mouseX < bounds.x
					|| EventUtil._mouseY < bounds.y
					|| EventUtil._mouseX > bounds.x + bounds.width
					|| EventUtil._mouseY > bounds.y + bounds.height) {
					meta.windowMeta.doClose();
				}
			}
		}
	},

	_doCloseAllWindows ({hoverIdBlocklist = null} = {}) {
		Object.entries(Renderer.hover._WINDOW_METAS)
			.filter(([hoverId, meta]) => hoverIdBlocklist == null || !hoverIdBlocklist.has(Number(hoverId)))
			.forEach(([, meta]) => meta.doClose());
	},

	_getSetMeta (ele) {
		if (!Renderer.hover._eleCache.has(ele)) Renderer.hover._eleCache.set(ele, new Renderer.hover.LinkMeta());
		return Renderer.hover._eleCache.get(ele);
	},

	_handleGenericMouseOverStart (evt, ele) {
				if (Renderer.hover.isSmallScreen(evt) && !evt.shiftKey) return;

		Renderer.hover.cleanTempWindows();

		const meta = Renderer.hover._getSetMeta(ele);
		if (meta.isHovered || meta.isLoading) return; 
				ele.style.cursor = "progress";

		meta.isHovered = true;
		meta.isLoading = true;
		meta.isPermanent = evt.shiftKey;

		return meta;
	},

		async pHandleLinkMouseOver (evt, ele, opts) {
		Renderer.hover._doInit();

		let page, source, hash, preloadId, customHashId, isFauxPage;
		if (opts) {
			page = opts.page;
			source = opts.source;
			hash = opts.hash;
			preloadId = opts.preloadId;
			customHashId = opts.customHashId;
			isFauxPage = !!opts.isFauxPage;
		} else {
			page = ele.dataset.vetPage;
			source = ele.dataset.vetSource;
			hash = ele.dataset.vetHash;
			preloadId = ele.dataset.vetPreloadId;
			isFauxPage = ele.dataset.vetIsFauxPage;
		}

		let meta = Renderer.hover._handleGenericMouseOverStart(evt, ele);
		if (meta == null) return;

		if ((evt.ctrlKey || evt.metaKey) && Renderer.hover._pageToFluffFn(page)) meta.isFluff = true;

		let toRender;
		if (preloadId != null) { 			switch (page) {
				case UrlUtil.PG_BESTIARY: {
					const {_scaledCr: scaledCr, _scaledSpellSummonLevel: scaledSpellSummonLevel, _scaledClassSummonLevel: scaledClassSummonLevel} = Renderer.monster.getUnpackedCustomHashId(preloadId);

					const baseMon = await DataLoader.pCacheAndGet(page, source, hash);
					if (scaledCr != null) {
						toRender = await ScaleCreature.scale(baseMon, scaledCr);
					} else if (scaledSpellSummonLevel != null) {
						toRender = await ScaleSpellSummonedCreature.scale(baseMon, scaledSpellSummonLevel);
					} else if (scaledClassSummonLevel != null) {
						toRender = await ScaleClassSummonedCreature.scale(baseMon, scaledClassSummonLevel);
					}
					break;
				}
			}
		} else if (customHashId) {
			toRender = await DataLoader.pCacheAndGet(page, source, hash);
			toRender = await Renderer.hover.pApplyCustomHashId(page, toRender, customHashId);
		} else {
			if (meta.isFluff) toRender = await Renderer.hover.pGetHoverableFluff(page, source, hash);
			else toRender = await DataLoader.pCacheAndGet(page, source, hash);
		}

		meta.isLoading = false;

		if (opts?.isDelay) {
			meta.isDelayed = true;
			ele.style.cursor = "help";
			await MiscUtil.pDelay(1100);
			meta.isDelayed = false;
		}

				ele.style.cursor = "";

				if (!meta || (!meta.isHovered && !meta.isPermanent)) return;

		const tmpEvt = meta._tmpEvt;
		delete meta._tmpEvt;

				const win = (evt.view || {}).window;

		const $content = meta.isFluff
			? Renderer.hover.$getHoverContent_fluff(page, toRender)
			: Renderer.hover.$getHoverContent_stats(page, toRender);

				const compactReferenceData = {
			page,
			source,
			hash,
		};

		if (meta.windowMeta && !meta.isPermanent) {
			meta.windowMeta.doClose();
			meta.windowMeta = null;
		}

		meta.windowMeta = Renderer.hover.getShowWindow(
			$content,
			Renderer.hover.getWindowPositionFromEvent(tmpEvt || evt, {isPreventFlicker: !meta.isPermanent}),
			{
				title: toRender ? toRender.name : "",
				isPermanent: meta.isPermanent,
				pageUrl: isFauxPage ? null : `${Renderer.get().baseUrl}${page}#${hash}`,
				cbClose: () => meta.isHovered = meta.isPermanent = meta.isLoading = meta.isFluff = false,
				isBookContent: page === UrlUtil.PG_RECIPES,
				compactReferenceData,
				sourceData: toRender,
			},
		);

		if (!meta.isFluff && !win?._IS_POPOUT) {
			const fnBind = Renderer.hover.getFnBindListenersCompact(page);
			if (fnBind) fnBind(toRender, $content);
		}
	},

	async pGetHoverableFluff (page, source, hash, opts) {
				let toRender = await DataLoader.pCacheAndGet(`${page}Fluff`, source, hash, opts);

		if (!toRender) {
						const entity = await DataLoader.pCacheAndGet(page, source, hash, opts);

			const pFnGetFluff = Renderer.hover._pageToFluffFn(page);
			if (!pFnGetFluff && opts?.isSilent) return null;

			toRender = await pFnGetFluff(entity);
		}

		if (!toRender) return toRender;

				if (toRender && (!toRender.name || !toRender.source)) {
			const toRenderParent = await DataLoader.pCacheAndGet(page, source, hash, opts);
			toRender = MiscUtil.copyFast(toRender);
			toRender.name = toRenderParent.name;
			toRender.source = toRenderParent.source;
		}

		return toRender;
	},

		handleLinkMouseLeave (evt, ele) {
		const meta = Renderer.hover._eleCache.get(ele);
		ele.style.cursor = "";

		if (!meta || meta.isPermanent) return;

		if (evt.shiftKey) {
			meta.isPermanent = true;
			meta.windowMeta.setIsPermanent(true);
			return;
		}

		meta.isHovered = false;
		if (meta.windowMeta) {
			meta.windowMeta.doClose();
			meta.windowMeta = null;
		}
	},

		handleLinkMouseMove (evt, ele) {
		const meta = Renderer.hover._eleCache.get(ele);
		if (!meta || meta.isPermanent) return;

				if (meta.isDelayed) {
			meta._tmpEvt = evt;
			return;
		}

		if (!meta.windowMeta) return;

		meta.windowMeta.setPosition(Renderer.hover.getWindowPositionFromEvent(evt, {isPreventFlicker: !evt.shiftKey && !meta.isPermanent}));

		if (evt.shiftKey && !meta.isPermanent) {
			meta.isPermanent = true;
			meta.windowMeta.setIsPermanent(true);
		}
	},

		handlePredefinedMouseOver (evt, ele, entryId, opts) {
		opts = opts || {};

		const meta = Renderer.hover._handleGenericMouseOverStart(evt, ele);
		if (meta == null) return;

		Renderer.hover.cleanTempWindows();

		const toRender = Renderer.hover._entryCache[entryId];

		meta.isLoading = false;
				if (!meta.isHovered && !meta.isPermanent) return;

		const $content = Renderer.hover.$getHoverContent_generic(toRender, opts);
		meta.windowMeta = Renderer.hover.getShowWindow(
			$content,
			Renderer.hover.getWindowPositionFromEvent(evt, {isPreventFlicker: !meta.isPermanent}),
			{
				title: toRender.data && toRender.data.hoverTitle != null ? toRender.data.hoverTitle : toRender.name,
				isPermanent: meta.isPermanent,
				cbClose: () => meta.isHovered = meta.isPermanent = meta.isLoading = false,
				sourceData: toRender,
			},
		);

				ele.style.cursor = "";
	},

		handlePredefinedMouseLeave (evt, ele) { return Renderer.hover.handleLinkMouseLeave(evt, ele); },

		handlePredefinedMouseMove (evt, ele) { return Renderer.hover.handleLinkMouseMove(evt, ele); },

	_WINDOW_POSITION_PROPS_FROM_EVENT: [
		"isFromBottom",
		"isFromRight",
		"clientX",
		"window",
		"isPreventFlicker",
		"bcr",
	],

	getWindowPositionFromEvent (evt, {isPreventFlicker = false} = {}) {
		const ele = evt.target;
		const win = evt?.view?.window || window;

		const bcr = ele.getBoundingClientRect().toJSON();

		const isFromBottom = bcr.top > win.innerHeight / 2;
		const isFromRight = bcr.left > win.innerWidth / 2;

		return {
			mode: "autoFromElement",
			isFromBottom,
			isFromRight,
			clientX: EventUtil.getClientX(evt),
			window: win,
			isPreventFlicker,
			bcr,
		};
	},

	getWindowPositionExact (x, y, evt = null) {
		return {
			window: evt?.view?.window || window,
			mode: "exact",
			x,
			y,
		};
	},

	getWindowPositionExactVisibleBottom (x, y, evt = null) {
		return {
			...Renderer.hover.getWindowPositionExact(x, y, evt),
			mode: "exactVisibleBottom",
		};
	},

	_WINDOW_METAS: {},
	MIN_Z_INDEX: 200,
	_MAX_Z_INDEX: 300,
	_DEFAULT_WIDTH_PX: 600,
	_BODY_SCROLLER_WIDTH_PX: 15,

	_getZIndex () {
		const zIndices = Object.values(Renderer.hover._WINDOW_METAS).map(it => it.zIndex);
		if (!zIndices.length) return Renderer.hover.MIN_Z_INDEX;
		return Math.max(...zIndices);
	},

	_getNextZIndex (hoverId) {
		const cur = Renderer.hover._getZIndex();
				if (hoverId != null && Renderer.hover._WINDOW_METAS[hoverId].zIndex === cur) return cur;
				const out = cur + 1;

				if (out > Renderer.hover._MAX_Z_INDEX) {
			const sortedWindowMetas = Object.entries(Renderer.hover._WINDOW_METAS)
				.sort(([kA, vA], [kB, vB]) => SortUtil.ascSort(vA.zIndex, vB.zIndex));

			if (sortedWindowMetas.length >= (Renderer.hover._MAX_Z_INDEX - Renderer.hover.MIN_Z_INDEX)) {
								sortedWindowMetas.forEach(([k, v]) => {
					v.setZIndex(Renderer.hover.MIN_Z_INDEX);
				});
			} else {
								sortedWindowMetas.forEach(([k, v], i) => {
					v.setZIndex(Renderer.hover.MIN_Z_INDEX + i);
				});
			}

			return Renderer.hover._getNextZIndex(hoverId);
		} else return out;
	},

	_isIntersectRect (r1, r2) {
		return r1.left <= r2.right
			&& r2.left <= r1.right
			&& r1.top <= r2.bottom
			&& r2.top <= r1.bottom;
	},

		getShowWindow ($content, position, opts) {
		opts = opts || {};

		Renderer.hover._doInit();

		const initialWidth = opts.width == null ? Renderer.hover._DEFAULT_WIDTH_PX : opts.width;
		const initialZIndex = Renderer.hover._getNextZIndex();

		const $body = $(position.window.document.body);
		const $hov = $(`<div class="hwin"></div>`)
			.css({
				"right": -initialWidth,
				"width": initialWidth,
				"zIndex": initialZIndex,
			});
		const $wrpContent = $(`<div class="hwin__wrp-table"></div>`);
		if (opts.height != null) $wrpContent.css("height", opts.height);
		const $hovTitle = $(`<span class="window-title min-w-0 overflow-ellipsis" title="${`${opts.title || ""}`.qq()}">${opts.title || ""}</span>`);

		const hoverWindow = {};
		const hoverId = Renderer.hover._getNextId();
		Renderer.hover._WINDOW_METAS[hoverId] = hoverWindow;
		const mouseUpId = `mouseup.${hoverId} touchend.${hoverId}`;
		const mouseMoveId = `mousemove.${hoverId} touchmove.${hoverId}`;
		const resizeId = `resize.${hoverId}`;
		const drag = {};

		const $brdrTopRightResize = $(`<div class="hoverborder__resize-ne"></div>`)
			.on("mousedown touchstart", (evt) => Renderer.hover._getShowWindow_handleDragMousedown({hoverWindow, hoverId, $hov, drag, $wrpContent}, {evt, type: 1}));

		const $brdrRightResize = $(`<div class="hoverborder__resize-e"></div>`)
			.on("mousedown touchstart", (evt) => Renderer.hover._getShowWindow_handleDragMousedown({hoverWindow, hoverId, $hov, drag, $wrpContent}, {evt, type: 2}));

		const $brdrBottomRightResize = $(`<div class="hoverborder__resize-se"></div>`)
			.on("mousedown touchstart", (evt) => Renderer.hover._getShowWindow_handleDragMousedown({hoverWindow, hoverId, $hov, drag, $wrpContent}, {evt, type: 3}));

		const $brdrBtm = $(`<div class="hoverborder hoverborder--btm ${opts.isBookContent ? "hoverborder-book" : ""}"><div class="hoverborder__resize-s"></div></div>`)
			.on("mousedown touchstart", (evt) => Renderer.hover._getShowWindow_handleDragMousedown({hoverWindow, hoverId, $hov, drag, $wrpContent}, {evt, type: 4}));

		const $brdrBtmLeftResize = $(`<div class="hoverborder__resize-sw"></div>`)
			.on("mousedown touchstart", (evt) => Renderer.hover._getShowWindow_handleDragMousedown({hoverWindow, hoverId, $hov, drag, $wrpContent}, {evt, type: 5}));

		const $brdrLeftResize = $(`<div class="hoverborder__resize-w"></div>`)
			.on("mousedown touchstart", (evt) => Renderer.hover._getShowWindow_handleDragMousedown({hoverWindow, hoverId, $hov, drag, $wrpContent}, {evt, type: 6}));

		const $brdrTopLeftResize = $(`<div class="hoverborder__resize-nw"></div>`)
			.on("mousedown touchstart", (evt) => Renderer.hover._getShowWindow_handleDragMousedown({hoverWindow, hoverId, $hov, drag, $wrpContent}, {evt, type: 7}));

		const $brdrTopResize = $(`<div class="hoverborder__resize-n"></div>`)
			.on("mousedown touchstart", (evt) => Renderer.hover._getShowWindow_handleDragMousedown({hoverWindow, hoverId, $hov, drag, $wrpContent}, {evt, type: 8}));

		const $brdrTop = $(`<div class="hoverborder hoverborder--top ${opts.isBookContent ? "hoverborder-book" : ""}" ${opts.isPermanent ? `data-perm="true"` : ""}></div>`)
			.on("mousedown touchstart", (evt) => Renderer.hover._getShowWindow_handleDragMousedown({hoverWindow, hoverId, $hov, drag, $wrpContent}, {evt, type: 9}))
			.on("contextmenu", (evt) => {
				Renderer.hover._contextMenuLastClicked = {
					hoverId,
				};
				ContextUtil.pOpenMenu(evt, Renderer.hover._contextMenu);
			});

		$(position.window.document)
			.on(mouseUpId, (evt) => {
				if (drag.type) {
					if (drag.type < 9) {
						$wrpContent.css("max-height", "");
						$hov.css("max-width", "");
					}
					Renderer.hover._getShowWindow_adjustPosition({$hov, $wrpContent, position});

					if (drag.type === 9) {
												if (EventUtil.isUsingTouch() && evt.target.classList.contains("hwin__top-border-icon")) {
							evt.preventDefault();
							drag.type = 0;
							$(evt.target).click();
							return;
						}

												if (this._dmScreen && opts.compactReferenceData) {
							const panel = this._dmScreen.getPanelPx(EventUtil.getClientX(evt), EventUtil.getClientY(evt));
							if (!panel) return;
							this._dmScreen.setHoveringPanel(panel);
							const target = panel.getAddButtonPos();

							if (Renderer.hover._getShowWindow_isOverHoverTarget({evt, target})) {
								panel.doPopulate_Stats(opts.compactReferenceData.page, opts.compactReferenceData.source, opts.compactReferenceData.hash);
								Renderer.hover._getShowWindow_doClose({$hov, position, mouseUpId, mouseMoveId, resizeId, hoverId, opts, hoverWindow});
							}
							this._dmScreen.resetHoveringButton();
						}
					}
					drag.type = 0;
				}
			})
			.on(mouseMoveId, (evt) => {
				const args = {$wrpContent, $hov, drag, evt};
				switch (drag.type) {
					case 1: Renderer.hover._getShowWindow_handleNorthDrag(args); Renderer.hover._getShowWindow_handleEastDrag(args); break;
					case 2: Renderer.hover._getShowWindow_handleEastDrag(args); break;
					case 3: Renderer.hover._getShowWindow_handleSouthDrag(args); Renderer.hover._getShowWindow_handleEastDrag(args); break;
					case 4: Renderer.hover._getShowWindow_handleSouthDrag(args); break;
					case 5: Renderer.hover._getShowWindow_handleSouthDrag(args); Renderer.hover._getShowWindow_handleWestDrag(args); break;
					case 6: Renderer.hover._getShowWindow_handleWestDrag(args); break;
					case 7: Renderer.hover._getShowWindow_handleNorthDrag(args); Renderer.hover._getShowWindow_handleWestDrag(args); break;
					case 8: Renderer.hover._getShowWindow_handleNorthDrag(args); break;
					case 9: {
						const diffX = drag.startX - EventUtil.getClientX(evt);
						const diffY = drag.startY - EventUtil.getClientY(evt);
						$hov.css("left", drag.baseLeft - diffX)
							.css("top", drag.baseTop - diffY);
						drag.startX = EventUtil.getClientX(evt);
						drag.startY = EventUtil.getClientY(evt);
						drag.baseTop = parseFloat($hov.css("top"));
						drag.baseLeft = parseFloat($hov.css("left"));

												if (this._dmScreen) {
							const panel = this._dmScreen.getPanelPx(EventUtil.getClientX(evt), EventUtil.getClientY(evt));
							if (!panel) return;
							this._dmScreen.setHoveringPanel(panel);
							const target = panel.getAddButtonPos();

							if (Renderer.hover._getShowWindow_isOverHoverTarget({evt, target})) this._dmScreen.setHoveringButton(panel);
							else this._dmScreen.resetHoveringButton();
						}
						break;
					}
				}
			});
		$(position.window).on(resizeId, () => Renderer.hover._getShowWindow_adjustPosition({$hov, $wrpContent, position}));

		$brdrTop.attr("data-display-title", false);
		$brdrTop.on("dblclick", () => Renderer.hover._getShowWindow_doToggleMinimizedMaximized({$brdrTop, $hov}));
		$brdrTop.append($hovTitle);
		const $brdTopRhs = $(`<div class="ve-flex ml-auto no-shrink"></div>`).appendTo($brdrTop);

		if (opts.pageUrl && !position.window._IS_POPOUT && !Renderer.get().isInternalLinksDisabled()) {
			const $btnGotoPage = $(`<a class="hwin__top-border-icon glyphicon glyphicon-modal-window" title="Go to Page" href="${opts.pageUrl}"></a>`)
				.appendTo($brdTopRhs);
		}

		if (!position.window._IS_POPOUT && !opts.isPopout) {
			const $btnPopout = $(`<span class="hwin__top-border-icon glyphicon glyphicon-new-window hvr__popout" title="Open as Popup Window"></span>`)
				.on("click", evt => {
					evt.stopPropagation();
					return Renderer.hover._getShowWindow_pDoPopout({$hov, position, mouseUpId, mouseMoveId, resizeId, hoverId, opts, hoverWindow, $content}, {evt});
				})
				.appendTo($brdTopRhs);
		}

		if (opts.sourceData) {
			const btnPopout = e_({
				tag: "span",
				clazz: `hwin__top-border-icon hwin__top-border-icon--text`,
				title: "Show Source Data",
				text: "{}",
				click: evt => {
					evt.stopPropagation();
					evt.preventDefault();

					const $content = Renderer.hover.$getHoverContent_statsCode(opts.sourceData);
					Renderer.hover.getShowWindow(
						$content,
						Renderer.hover.getWindowPositionFromEvent(evt),
						{
							title: [opts.sourceData._displayName || opts.sourceData.name, "Source Data"].filter(Boolean).join(" \u2014 "),
							isPermanent: true,
							isBookContent: true,
						},
					);
				},
			});
			$brdTopRhs.append(btnPopout);
		}

		const $btnClose = $(`<span class="hwin__top-border-icon glyphicon glyphicon-remove" title="Close (CTRL to Close All)"></span>`)
			.on("click", (evt) => {
				evt.stopPropagation();

				if (evt.ctrlKey || evt.metaKey) {
					Renderer.hover._doCloseAllWindows();
					return;
				}

				Renderer.hover._getShowWindow_doClose({$hov, position, mouseUpId, mouseMoveId, resizeId, hoverId, opts, hoverWindow});
			}).appendTo($brdTopRhs);

		$wrpContent.append($content);

		$hov.append($brdrTopResize).append($brdrTopRightResize).append($brdrRightResize).append($brdrBottomRightResize)
			.append($brdrBtmLeftResize).append($brdrLeftResize).append($brdrTopLeftResize)

			.append($brdrTop)
			.append($wrpContent)
			.append($brdrBtm);

		$body.append($hov);

		Renderer.hover._getShowWindow_setPosition({$hov, $wrpContent, position}, position);

		hoverWindow.$windowTitle = $hovTitle;
		hoverWindow.zIndex = initialZIndex;
		hoverWindow.setZIndex = Renderer.hover._getNextZIndex.bind(this, {$hov, hoverWindow});

		hoverWindow.setPosition = Renderer.hover._getShowWindow_setPosition.bind(this, {$hov, $wrpContent, position});
		hoverWindow.setIsPermanent = Renderer.hover._getShowWindow_setIsPermanent.bind(this, {opts, $brdrTop});
		hoverWindow.doClose = Renderer.hover._getShowWindow_doClose.bind(this, {$hov, position, mouseUpId, mouseMoveId, resizeId, hoverId, opts, hoverWindow});
		hoverWindow.doMaximize = Renderer.hover._getShowWindow_doMaximize.bind(this, {$brdrTop, $hov});
		hoverWindow.doZIndexToFront = Renderer.hover._getShowWindow_doZIndexToFront.bind(this, {$hov, hoverWindow, hoverId});

		if (opts.isPopout) pDoPopout().then(null);

		return hoverWindow;
	},

	_getShowWindow_doClose ({$hov, position, mouseUpId, mouseMoveId, resizeId, hoverId, opts, hoverWindow}) {
		$hov.remove();
		$(position.window.document).off(mouseUpId);
		$(position.window.document).off(mouseMoveId);
		$(position.window).off(resizeId);

		delete Renderer.hover._WINDOW_METAS[hoverId];

		if (opts.cbClose) opts.cbClose(hoverWindow);
	},

	_getShowWindow_handleDragMousedown ({hoverWindow, hoverId, $hov, drag, $wrpContent}, {evt, type}) {
		if (evt.which === 0 || evt.which === 1) evt.preventDefault();
		hoverWindow.zIndex = Renderer.hover._getNextZIndex(hoverId);
		$hov.css({
			"z-index": hoverWindow.zIndex,
			"animation": "initial",
		});
		drag.type = type;
		drag.startX = EventUtil.getClientX(evt);
		drag.startY = EventUtil.getClientY(evt);
		drag.baseTop = parseFloat($hov.css("top"));
		drag.baseLeft = parseFloat($hov.css("left"));
		drag.baseHeight = $wrpContent.height();
		drag.baseWidth = parseFloat($hov.css("width"));
		if (type < 9) {
			$wrpContent.css({
				"height": drag.baseHeight,
				"max-height": "initial",
			});
			$hov.css("max-width", "initial");
		}
	},

	_getShowWindow_isOverHoverTarget ({evt, target}) {
		return EventUtil.getClientX(evt) >= target.left
			&& EventUtil.getClientX(evt) <= target.left + target.width
			&& EventUtil.getClientY(evt) >= target.top
			&& EventUtil.getClientY(evt) <= target.top + target.height;
	},

	_getShowWindow_handleNorthDrag ({$wrpContent, $hov, drag, evt}) {
		const diffY = Math.max(drag.startY - EventUtil.getClientY(evt), 80 - drag.baseHeight); 		$wrpContent.css("height", drag.baseHeight + diffY);
		$hov.css("top", drag.baseTop - diffY);
		drag.startY = EventUtil.getClientY(evt);
		drag.baseHeight = $wrpContent.height();
		drag.baseTop = parseFloat($hov.css("top"));
	},

	_getShowWindow_handleEastDrag ({$wrpContent, $hov, drag, evt}) {
		const diffX = drag.startX - EventUtil.getClientX(evt);
		$hov.css("width", drag.baseWidth - diffX);
		drag.startX = EventUtil.getClientX(evt);
		drag.baseWidth = parseFloat($hov.css("width"));
	},

	_getShowWindow_handleSouthDrag ({$wrpContent, $hov, drag, evt}) {
		const diffY = drag.startY - EventUtil.getClientY(evt);
		$wrpContent.css("height", drag.baseHeight - diffY);
		drag.startY = EventUtil.getClientY(evt);
		drag.baseHeight = $wrpContent.height();
	},

	_getShowWindow_handleWestDrag ({$wrpContent, $hov, drag, evt}) {
		const diffX = Math.max(drag.startX - EventUtil.getClientX(evt), 150 - drag.baseWidth);
		$hov.css("width", drag.baseWidth + diffX)
			.css("left", drag.baseLeft - diffX);
		drag.startX = EventUtil.getClientX(evt);
		drag.baseWidth = parseFloat($hov.css("width"));
		drag.baseLeft = parseFloat($hov.css("left"));
	},

	_getShowWindow_doToggleMinimizedMaximized ({$brdrTop, $hov}) {
		const curState = $brdrTop.attr("data-display-title");
		const isNextMinified = curState === "false";
		$brdrTop.attr("data-display-title", isNextMinified);
		$brdrTop.attr("data-perm", true);
		$hov.toggleClass("hwin--minified", isNextMinified);
	},

	_getShowWindow_doMaximize ({$brdrTop, $hov}) {
		$brdrTop.attr("data-display-title", false);
		$hov.toggleClass("hwin--minified", false);
	},

	async _getShowWindow_pDoPopout ({$hov, position, mouseUpId, mouseMoveId, resizeId, hoverId, opts, hoverWindow, $content}, {evt}) {
		const dimensions = opts.fnGetPopoutSize ? opts.fnGetPopoutSize() : {width: 600, height: $content.height()};
		const win = window.open(
			"",
			opts.title || "",
			`width=${dimensions.width},height=${dimensions.height}location=0,menubar=0,status=0,titlebar=0,toolbar=0`,
		);

						if (!win._IS_POPOUT) {
			win._IS_POPOUT = true;
			win.document.write(`
				<!DOCTYPE html>
				<html lang="en" class="ve-popwindow ${typeof styleSwitcher !== "undefined" ? styleSwitcher.getDayNightClassNames() : ""}"><head>
					<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
					<title>${opts.title}</title>
					${$(`link[rel="stylesheet"][href]`).map((i, e) => e.outerHTML).get().join("\n")}
					<!-- Favicons -->
					<link rel="icon" type="image/svg+xml" href="favicon.svg">
					<link rel="icon" type="image/png" sizes="256x256" href="favicon-256x256.png">
					<link rel="icon" type="image/png" sizes="144x144" href="favicon-144x144.png">
					<link rel="icon" type="image/png" sizes="128x128" href="favicon-128x128.png">
					<link rel="icon" type="image/png" sizes="64x64" href="favicon-64x64.png">
					<link rel="icon" type="image/png" sizes="48x48" href="favicon-48x48.png">
					<link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
					<link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">

					<!-- Chrome Web App Icons -->
					<link rel="manifest" href="manifest.webmanifest">
					<meta name="application-name" content="5etools">
					<meta name="theme-color" content="#006bc4">

					<!-- Windows Start Menu tiles -->
					<meta name="msapplication-config" content="browserconfig.xml"/>
					<meta name="msapplication-TileColor" content="#006bc4">

					<!-- Apple Touch Icons -->
					<link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon-180x180.png">
					<link rel="apple-touch-icon" sizes="360x360" href="apple-touch-icon-360x360.png">
					<link rel="apple-touch-icon" sizes="167x167" href="apple-touch-icon-167x167.png">
					<link rel="apple-touch-icon" sizes="152x152" href="apple-touch-icon-152x152.png">
					<link rel="apple-touch-icon" sizes="120x120" href="apple-touch-icon-120x120.png">
					<meta name="apple-mobile-web-app-title" content="5etools">

					<!-- macOS Safari Pinned Tab and Touch Bar -->
					<link rel="mask-icon" href="safari-pinned-tab.svg" color="#006bc4">

					<style>
						html, body { width: 100%; height: 100%; }
						body { overflow-y: scroll; }
						.hwin--popout { max-width: 100%; max-height: 100%; box-shadow: initial; width: 100%; overflow-y: auto; }
					</style>
				</head><body class="rd__body-popout">
				<div class="hwin hoverbox--popout hwin--popout"></div>
				<script type="text/javascript" src="js/parser.js"></script>
				<script type="text/javascript" src="js/utils.js"></script>
				<script type="text/javascript" src="lib/jquery.js"></script>
				</body></html>
			`);

			win.Renderer = Renderer;

			let ticks = 50;
			while (!win.document.body && ticks-- > 0) await MiscUtil.pDelay(5);

			win.$wrpHoverContent = $(win.document).find(`.hoverbox--popout`);
		}

		let $cpyContent;
		if (opts.$pFnGetPopoutContent) {
			$cpyContent = await opts.$pFnGetPopoutContent();
		} else {
			$cpyContent = $content.clone(true, true);
		}

		$cpyContent.appendTo(win.$wrpHoverContent.empty());

		Renderer.hover._getShowWindow_doClose({$hov, position, mouseUpId, mouseMoveId, resizeId, hoverId, opts, hoverWindow});
	},

	_getShowWindow_setPosition ({$hov, $wrpContent, position}, positionNxt) {
		switch (positionNxt.mode) {
			case "autoFromElement": {
				const bcr = $hov[0].getBoundingClientRect();

				if (positionNxt.isFromBottom) $hov.css("top", positionNxt.bcr.top - (bcr.height + 10));
				else $hov.css("top", positionNxt.bcr.top + positionNxt.bcr.height + 10);

				if (positionNxt.isFromRight) $hov.css("left", (positionNxt.clientX || positionNxt.bcr.left) - (bcr.width + 10));
				else $hov.css("left", (positionNxt.clientX || (positionNxt.bcr.left + positionNxt.bcr.width)) + 10);

								if (position !== positionNxt) {
					Renderer.hover._WINDOW_POSITION_PROPS_FROM_EVENT
						.forEach(prop => {
							position[prop] = positionNxt[prop];
						});
				}
				
				break;
			}
			case "exact": {
				$hov.css({
					"left": positionNxt.x,
					"top": positionNxt.y,
				});
				break;
			}
			case "exactVisibleBottom": {
				$hov.css({
					"left": positionNxt.x,
					"top": positionNxt.y,
					"animation": "initial", 				});

				let yPos = positionNxt.y;

				const {bottom: posBottom, height: winHeight} = $hov[0].getBoundingClientRect();
				const height = position.window.innerHeight;
				if (posBottom > height) {
					yPos = position.window.innerHeight - winHeight;
					$hov.css({
						"top": yPos,
						"animation": "",
					});
				}

				break;
			}
			default: throw new Error(`Positiong mode unimplemented: "${positionNxt.mode}"`);
		}

		Renderer.hover._getShowWindow_adjustPosition({$hov, $wrpContent, position});
	},

	_getShowWindow_adjustPosition ({$hov, $wrpContent, position}) {
		const eleHov = $hov[0];
		const wrpContent = $wrpContent[0];

		const bcr = eleHov.getBoundingClientRect().toJSON();
		const screenHeight = position.window.innerHeight;
		const screenWidth = position.window.innerWidth;

						if (bcr.top < 0) {
			bcr.top = 0;
			bcr.bottom = bcr.top + bcr.height;
			eleHov.style.top = `${bcr.top}px`;
		} else if (bcr.top >= screenHeight - Renderer.hover._BAR_HEIGHT) {
			bcr.top = screenHeight - Renderer.hover._BAR_HEIGHT;
			bcr.bottom = bcr.top + bcr.height;
			eleHov.style.top = `${bcr.top}px`;
		}

				if (bcr.left < 0) {
			bcr.left = 0;
			bcr.right = bcr.left + bcr.width;
			eleHov.style.left = `${bcr.left}px`;
		} else if (bcr.left + bcr.width + Renderer.hover._BODY_SCROLLER_WIDTH_PX > screenWidth) {
			bcr.left = Math.max(screenWidth - bcr.width - Renderer.hover._BODY_SCROLLER_WIDTH_PX, 0);
			bcr.right = bcr.left + bcr.width;
			eleHov.style.left = `${bcr.left}px`;
		}

				if (
			position.isPreventFlicker
			&& Renderer.hover._isIntersectRect(bcr, position.bcr)
		) {
			if (position.isFromBottom) {
				bcr.height = position.bcr.top - 5;
				wrpContent.style.height = `${bcr.height}px`;
			} else {
				bcr.height = screenHeight - position.bcr.bottom - 5;
				wrpContent.style.height = `${bcr.height}px`;
			}
		}
	},

	_getShowWindow_setIsPermanent ({opts, $brdrTop}, isPermanent) {
		opts.isPermanent = isPermanent;
		$brdrTop.attr("data-perm", isPermanent);
	},

	_getShowWindow_setZIndex ({$hov, hoverWindow}, zIndex) {
		$hov.css("z-index", zIndex);
		hoverWindow.zIndex = zIndex;
	},

	_getShowWindow_doZIndexToFront ({$hov, hoverWindow, hoverId}) {
		const nxtZIndex = Renderer.hover._getNextZIndex(hoverId);
		Renderer.hover._getNextZIndex({$hov, hoverWindow}, nxtZIndex);
	},

		getMakePredefinedHover (entry, opts) {
		opts = opts || {};

		const id = opts.id ?? Renderer.hover._getNextId();
		Renderer.hover._entryCache[id] = entry;
		return {
			id,
			html: `onmouseover="Renderer.hover.handlePredefinedMouseOver(event, this, ${id}, ${JSON.stringify(opts).escapeQuotes()})" onmousemove="Renderer.hover.handlePredefinedMouseMove(event, this)" onmouseleave="Renderer.hover.handlePredefinedMouseLeave(event, this)" ${Renderer.hover.getPreventTouchString()}`,
			mouseOver: (evt, ele) => Renderer.hover.handlePredefinedMouseOver(evt, ele, id, opts),
			mouseMove: (evt, ele) => Renderer.hover.handlePredefinedMouseMove(evt, ele),
			mouseLeave: (evt, ele) => Renderer.hover.handlePredefinedMouseLeave(evt, ele),
			touchStart: (evt, ele) => Renderer.hover.handleTouchStart(evt, ele),
		};
	},

	updatePredefinedHover (id, entry) {
		Renderer.hover._entryCache[id] = entry;
	},

	getPreventTouchString () {
		return `ontouchstart="Renderer.hover.handleTouchStart(event, this)"`;
	},

	handleTouchStart (evt, ele) {
				if (!Renderer.hover.isSmallScreen(evt)) {
						$(ele).data("href", $(ele).data("href") || $(ele).attr("href"));
			$(ele).attr("href", "javascript:void(0)");
									setTimeout(() => {
				const data = $(ele).data("href");
				if (data) {
					$(ele).attr("href", data);
					$(ele).data("href", null);
				}
			}, 100);
		}
	},

		getEntityLink (
		ent,
		{
			displayText = null,
			prop = null,
			isLowerCase = false,
			isTitleCase = false,
		} = {},
	) {
		if (isLowerCase && isTitleCase) throw new Error(`"isLowerCase" and "isTitleCase" are mutually exclusive!`);

		const name = isLowerCase ? ent.name.toLowerCase() : isTitleCase ? ent.name.toTitleCase() : ent.name;

		let parts = [
			name,
			ent.source,
			displayText || "",
		];

		switch (prop || ent.__prop) {
			case "monster": {
				if (ent._isScaledCr) {
					parts.push(`${VeCt.HASH_SCALED}=${Parser.numberToCr(ent._scaledCr)}`);
				}

				if (ent._isScaledSpellSummon) {
					parts.push(`${VeCt.HASH_SCALED_SPELL_SUMMON}=${ent._scaledSpellSummonLevel}`);
				}

				if (ent._isScaledClassSummon) {
					parts.push(`${VeCt.HASH_SCALED_CLASS_SUMMON}=${ent._scaledClassSummonLevel}`);
				}

				break;
			}

			
			case "deity": {
				parts.splice(1, 0, ent.pantheon);
				break;
			}
		}

		while (parts.length && !parts.last()?.length) parts.pop();

		return Renderer.get().render(`{@${Parser.getPropTag(prop || ent.__prop)} ${parts.join("|")}}`);
	},

	getRefMetaFromTag (str) {
						str = str.slice(2, -1);
		const [tag, ...refParts] = str.split(" ");
		const ref = refParts.join(" ");
		const type = `ref${tag.uppercaseFirst()}`;
		return {type, [tag]: ref};
	},
	
		async pApplyCustomHashId (page, ent, customHashId) {
		switch (page) {
			case UrlUtil.PG_BESTIARY: {
				if (!customHashId) {
					Renderer.monster.initParsed(ent);
					return ent;
				}

				const {_scaledCr, _scaledSpellSummonLevel, _scaledClassSummonLevel} = Renderer.monster.getUnpackedCustomHashId(customHashId);
				if (_scaledCr != null) ent = await ScaleCreature.scale(ent, _scaledCr);
				else if (_scaledSpellSummonLevel != null) ent = await ScaleSpellSummonedCreature.scale(ent, _scaledSpellSummonLevel);
				else if (_scaledClassSummonLevel != null) ent = await ScaleClassSummonedCreature.scale(ent, _scaledClassSummonLevel);

				Renderer.monster.updateParsed(ent);

				return ent;
			}

			case UrlUtil.PG_RECIPES: {
				if (!customHashId) return ent;
				const {_scaleFactor} = Renderer.recipe.getUnpackedCustomHashId(customHashId);
				if (_scaleFactor == null) return ent;
				return Renderer.recipe.getScaledRecipe(ent, _scaleFactor);
			}

			default: return ent;
		}
	},
	
	getGenericCompactRenderedString (entry, depth = 0) {
		return `
			<tr class="text homebrew-hover"><td colspan="6">
			${Renderer.get().setFirstSection(true).render(entry, depth)}
			</td></tr>
		`;
	},

	getFnRenderCompact (page, {isStatic = false} = {}) {
		switch (page) {
			case "generic":
			case "hover": return Renderer.hover.getGenericCompactRenderedString;
			case UrlUtil.PG_QUICKREF: return Renderer.hover.getGenericCompactRenderedString;
			case UrlUtil.PG_CLASSES: return Renderer.class.getCompactRenderedString;
			case UrlUtil.PG_SPELLS: return Renderer.spell.getCompactRenderedString;
			case UrlUtil.PG_ITEMS: return Renderer.item.getCompactRenderedString;
			case UrlUtil.PG_BESTIARY: return it => Renderer.monster.getCompactRenderedString(it, {isShowScalers: !isStatic, isScaledCr: it._originalCr != null, isScaledSpellSummon: it._isScaledSpellSummon, isScaledClassSummon: it._isScaledClassSummon});
			case UrlUtil.PG_CONDITIONS_DISEASES: return Renderer.condition.getCompactRenderedString;
			case UrlUtil.PG_BACKGROUNDS: return Renderer.background.getCompactRenderedString;
			case UrlUtil.PG_FEATS: return Renderer.feat.getCompactRenderedString;
			case UrlUtil.PG_OPT_FEATURES: return Renderer.optionalfeature.getCompactRenderedString;
			case UrlUtil.PG_PSIONICS: return Renderer.psionic.getCompactRenderedString;
			case UrlUtil.PG_REWARDS: return Renderer.reward.getCompactRenderedString;
			case UrlUtil.PG_RACES: return it => Renderer.race.getCompactRenderedString(it, {isStatic});
			case UrlUtil.PG_DEITIES: return Renderer.deity.getCompactRenderedString;
			case UrlUtil.PG_OBJECTS: return Renderer.object.getCompactRenderedString;
			case UrlUtil.PG_TRAPS_HAZARDS: return Renderer.traphazard.getCompactRenderedString;
			case UrlUtil.PG_VARIANTRULES: return Renderer.variantrule.getCompactRenderedString;
			case UrlUtil.PG_CULTS_BOONS: return Renderer.cultboon.getCompactRenderedString;
			case UrlUtil.PG_TABLES: return Renderer.table.getCompactRenderedString;
			case UrlUtil.PG_VEHICLES: return Renderer.vehicle.getCompactRenderedString;
			case UrlUtil.PG_ACTIONS: return Renderer.action.getCompactRenderedString;
			case UrlUtil.PG_LANGUAGES: return Renderer.language.getCompactRenderedString;
			case UrlUtil.PG_CHAR_CREATION_OPTIONS: return Renderer.charoption.getCompactRenderedString;
			case UrlUtil.PG_RECIPES: return Renderer.recipe.getCompactRenderedString;
			case UrlUtil.PG_CLASS_SUBCLASS_FEATURES: return Renderer.hover.getGenericCompactRenderedString;
			case UrlUtil.PG_DECKS: return Renderer.deck.getCompactRenderedString;
						case "classfeature":
			case "classFeature":
				return Renderer.hover.getGenericCompactRenderedString;
			case "subclassfeature":
			case "subclassFeature":
				return Renderer.hover.getGenericCompactRenderedString;
						default:
				if (Renderer[page]?.getCompactRenderedString) return Renderer[page].getCompactRenderedString;
				return null;
		}
	},

	getFnBindListenersCompact (page) {
		switch (page) {
			case UrlUtil.PG_BESTIARY: return Renderer.monster.bindListenersCompact;
			case UrlUtil.PG_RACES: return Renderer.race.bindListenersCompact;
			default: return null;
		}
	},

	_pageToFluffFn (page) {
		switch (page) {
			case UrlUtil.PG_BESTIARY: return Renderer.monster.pGetFluff;
			case UrlUtil.PG_ITEMS: return Renderer.item.pGetFluff;
			case UrlUtil.PG_CONDITIONS_DISEASES: return Renderer.condition.pGetFluff;
			case UrlUtil.PG_SPELLS: return Renderer.spell.pGetFluff;
			case UrlUtil.PG_RACES: return Renderer.race.pGetFluff;
			case UrlUtil.PG_BACKGROUNDS: return Renderer.background.pGetFluff;
			case UrlUtil.PG_FEATS: return Renderer.feat.pGetFluff;
			case UrlUtil.PG_LANGUAGES: return Renderer.language.pGetFluff;
			case UrlUtil.PG_VEHICLES: return Renderer.vehicle.pGetFluff;
			case UrlUtil.PG_CHAR_CREATION_OPTIONS: return Renderer.charoption.pGetFluff;
			case UrlUtil.PG_RECIPES: return Renderer.recipe.pGetFluff;
			default: return null;
		}
	},

	isSmallScreen (evt) {
		if (typeof window === "undefined") return false;

		evt = evt || {};
		const win = (evt.view || {}).window || window;
		return win.innerWidth <= 768;
	},

		$getHoverContent_stats (page, toRender, opts, renderFnOpts) {
		opts = opts || {};
		if (page === UrlUtil.PG_RECIPES) opts = {...MiscUtil.copyFast(opts), isBookContent: true};

		const fnRender = opts.fnRender || Renderer.hover.getFnRenderCompact(page, {isStatic: opts.isStatic});
		const $out = $$`<table class="w-100 stats ${opts.isBookContent ? `stats--book` : ""}">${fnRender(toRender, renderFnOpts)}</table>`;

		if (!opts.isStatic) {
			const fnBind = Renderer.hover.getFnBindListenersCompact(page);
			if (fnBind) fnBind(toRender, $out[0]);
		}

		return $out;
	},

		$getHoverContent_fluff (page, toRender, opts, renderFnOpts) {
		opts = opts || {};
		if (page === UrlUtil.PG_RECIPES) opts = {...MiscUtil.copyFast(opts), isBookContent: true};

		if (!toRender) {
			return $$`<table class="w-100 stats ${opts.isBookContent ? `stats--book` : ""}"><tr class="text"><td colspan="6" class="p-2 text-center">${Renderer.utils.HTML_NO_INFO}</td></tr></table>`;
		}

		toRender = MiscUtil.copyFast(toRender);

		if (toRender.images && toRender.images.length) {
			const cachedImages = MiscUtil.copyFast(toRender.images);
			delete toRender.images;

			toRender.entries = toRender.entries || [];
			const hasText = toRender.entries.length > 0;
						if (hasText) toRender.entries.unshift({type: "hr"});
			cachedImages[0].maxHeight = 33;
			cachedImages[0].maxHeightUnits = "vh";
			toRender.entries.unshift(cachedImages[0]);

						if (cachedImages.length > 1) {
				if (hasText) toRender.entries.push({type: "hr"});
				toRender.entries.push(...cachedImages.slice(1));
			}
		}

		return $$`<table class="w-100 stats ${opts.isBookContent ? `stats--book` : ""}">${Renderer.generic.getCompactRenderedString(toRender, renderFnOpts)}</table>`;
	},

	$getHoverContent_statsCode (toRender, {isSkipClean = false, title = null} = {}) {
		const cleanCopy = isSkipClean ? toRender : DataUtil.cleanJson(MiscUtil.copyFast(toRender));
		return Renderer.hover.$getHoverContent_miscCode(
			title || [cleanCopy.name, "Source Data"].filter(Boolean).join(" \u2014 "),
			JSON.stringify(cleanCopy, null, "\t"),
		);
	},

	$getHoverContent_miscCode (name, code) {
		const toRenderCode = {
			type: "code",
			name,
			preformatted: code,
		};
		return $$`<table class="w-100 stats stats--book">${Renderer.get().render(toRenderCode)}</table>`;
	},

		$getHoverContent_generic (toRender, opts) {
		opts = opts || {};

		return $$`<table class="w-100 stats ${opts.isBookContent || opts.isLargeBookContent ? "stats--book" : ""} ${opts.isLargeBookContent ? "stats--book-large" : ""}">${Renderer.hover.getGenericCompactRenderedString(toRender, opts.depth || 0)}</table>`;
	},

		doPopoutCurPage (evt, entity) {
		const page = UrlUtil.getCurrentPage();
		const $content = Renderer.hover.$getHoverContent_stats(page, entity);
		Renderer.hover.getShowWindow(
			$content,
			Renderer.hover.getWindowPositionFromEvent(evt),
			{
				pageUrl: `#${UrlUtil.autoEncodeHash(entity)}`,
				title: entity._displayName || entity.name,
				isPermanent: true,
				isBookContent: page === UrlUtil.PG_RECIPES,
				sourceData: entity,
			},
		);
	},
};

Renderer.getNames = function (nameStack, entry, opts) {
	opts = opts || {};
	if (opts.maxDepth == null) opts.maxDepth = false;
	if (opts.depth == null) opts.depth = 0;

	if (opts.typeBlocklist && entry.type && opts.typeBlocklist.has(entry.type)) return;

	if (opts.maxDepth !== false && opts.depth > opts.maxDepth) return;
	if (entry.name) nameStack.push(Renderer.stripTags(entry.name));
	if (entry.entries) {
		let nextDepth = entry.type === "section" ? -1 : entry.type === "entries" ? opts.depth + 1 : opts.depth;
		for (const eX of entry.entries) {
			const nxtOpts = {...opts};
			nxtOpts.depth = nextDepth;
			Renderer.getNames(nameStack, eX, nxtOpts);
		}
	} else if (entry.items) {
		for (const eX of entry.items) {
			Renderer.getNames(nameStack, eX, opts);
		}
	}
};

Renderer.getNumberedNames = function (entry) {
	const renderer = new Renderer().setTrackTitles(true);
	renderer.render(entry);
	const titles = renderer.getTrackedTitles();
	const out = {};
	Object.entries(titles).forEach(([k, v]) => {
		v = Renderer.stripTags(v);
		out[v] = Number(k);
	});
	return out;
};

Renderer.findName = function (entry) { return CollectionUtil.dfs(entry, {prop: "name"}); };
Renderer.findSource = function (entry) { return CollectionUtil.dfs(entry, {prop: "source"}); };
Renderer.findEntry = function (entry) { return CollectionUtil.dfs(entry, {fnMatch: obj => obj.name && obj?.entries?.length}); };

Renderer.stripTags = function (str) {
	if (!str) return str;
	let nxtStr = Renderer._stripTagLayer(str);
	while (nxtStr.length !== str.length) {
		str = nxtStr;
		nxtStr = Renderer._stripTagLayer(str);
	}
	return nxtStr;
};

Renderer._stripTagLayer = function (str) {
	if (str.includes("{@")) {
		const tagSplit = Renderer.splitByTags(str);
		return tagSplit.filter(it => it).map(it => {
			if (it.startsWith("{@")) {
				let [tag, text] = Renderer.splitFirstSpace(it.slice(1, -1));
				const tagInfo = Renderer.tag.TAG_LOOKUP[tag];
				if (!tagInfo) throw new Error(`Unhandled tag: "${tag}"`);
				return tagInfo.getStripped(tag, text);
			} else return it;
		}).join("");
	} return str;
};

Renderer.getRollableRow = function (row, opts) {
	opts = opts || {};

	if (
		row[0]?.type === "cell"
		&& (
			row[0]?.roll?.exact != null
			|| (row[0]?.roll?.min != null && row[0]?.roll?.max != null)
		)
	) return row;

	row = MiscUtil.copyFast(row);
	try {
		const cleanRow = String(row[0]).trim();

				const mLowHigh = /^(\d+) or (lower|higher)$/i.exec(cleanRow);
		if (mLowHigh) {
			row[0] = {type: "cell", entry: cleanRow}; 
			if (mLowHigh[2].toLowerCase() === "lower") {
				row[0].roll = {
					min: -Renderer.dice.POS_INFINITE,
					max: Number(mLowHigh[1]),
				};
			} else {
				row[0].roll = {
					min: Number(mLowHigh[1]),
					max: Renderer.dice.POS_INFINITE,
				};
			}

			return row;
		}

						const m = /^(\d+)([-\u2012\u2013](\d+))?$/.exec(cleanRow);
		if (m) {
			if (m[1] && !m[2]) {
				row[0] = {
					type: "cell",
					roll: {
						exact: Number(m[1]),
					},
				};
				if (m[1][0] === "0") row[0].roll.pad = true;
				Renderer.getRollableRow._handleInfiniteOpts(row, opts);
			} else {
				row[0] = {
					type: "cell",
					roll: {
						min: Number(m[1]),
						max: Number(m[3]),
					},
				};
				if (m[1][0] === "0" || m[3][0] === "0") row[0].roll.pad = true;
				Renderer.getRollableRow._handleInfiniteOpts(row, opts);
			}
		} else {
						const m = /^(\d+)\+$/.exec(row[0]);
			row[0] = {
				type: "cell",
				roll: {
					min: Number(m[1]),
					max: Renderer.dice.POS_INFINITE,
				},
			};
		}
	} catch (e) {
		if (opts.cbErr) opts.cbErr(row[0], e);
	}
	return row;
};
Renderer.getRollableRow._handleInfiniteOpts = function (row, opts) {
	if (!opts.isForceInfiniteResults) return;

	const isExact = row[0].roll.exact != null;

	if (opts.isFirstRow) {
		if (!isExact) row[0].roll.displayMin = row[0].roll.min;
		row[0].roll.min = -Renderer.dice.POS_INFINITE;
	}

	if (opts.isLastRow) {
		if (!isExact) row[0].roll.displayMax = row[0].roll.max;
		row[0].roll.max = Renderer.dice.POS_INFINITE;
	}
};

Renderer.initLazyImageLoaders = function () {
	const images = document.querySelectorAll(`img[data-src]`);

	Renderer.utils.lazy.destroyObserver({observerId: "images"});

	const observer = Renderer.utils.lazy.getCreateObserver({
		observerId: "images",
		fnOnObserve: ({entry}) => {
			const $img = $(entry.target);
			$img.attr("src", $img.attr("data-src")).removeAttr("data-src");
		},
	});

	images.forEach(img => observer.track(img));
};

Renderer.HEAD_NEG_1 = "rd__b--0";
Renderer.HEAD_0 = "rd__b--1";
Renderer.HEAD_1 = "rd__b--2";
Renderer.HEAD_2 = "rd__b--3";
Renderer.HEAD_2_SUB_VARIANT = "rd__b--4";
Renderer.DATA_NONE = "data-none";

"use strict";

Renderer.dice = {
	SYSTEM_USER: {
		name: "Avandra", 	},
	POS_INFINITE: 100000000000000000000, 	_SYMBOL_PARSE_FAILED: Symbol("parseFailed"),

	_$wrpRoll: null,
	_$minRoll: null,
	_$iptRoll: null,
	_$outRoll: null,
	_$head: null,
	_hist: [],
	_histIndex: null,
	_$lastRolledBy: null,
	_storage: null,

	_isManualMode: false,

		DICE: [4, 6, 8, 10, 12, 20, 100],
	getNextDice (faces) {
		const idx = Renderer.dice.DICE.indexOf(faces);
		if (~idx) return Renderer.dice.DICE[idx + 1];
		else return null;
	},

	getPreviousDice (faces) {
		const idx = Renderer.dice.DICE.indexOf(faces);
		if (~idx) return Renderer.dice.DICE[idx - 1];
		else return null;
	},
	
		_panel: null,
	bindDmScreenPanel (panel, title) {
		if (Renderer.dice._panel) { 			Renderer.dice.unbindDmScreenPanel();
		}
		Renderer.dice._showBox();
		Renderer.dice._panel = panel;
		panel.doPopulate_Rollbox(title);
	},

	unbindDmScreenPanel () {
		if (Renderer.dice._panel) {
			$(`body`).append(Renderer.dice._$wrpRoll);
			Renderer.dice._panel.close$TabContent();
			Renderer.dice._panel = null;
			Renderer.dice._hideBox();
			Renderer.dice._$wrpRoll.removeClass("rollbox-panel");
		}
	},

	get$Roller () {
		return Renderer.dice._$wrpRoll;
	},
	
		parseRandomise2 (str) {
		if (!str || !str.trim()) return null;
		const wrpTree = Renderer.dice.lang.getTree3(str);
		if (wrpTree) return wrpTree.tree.evl({});
		else return null;
	},

		parseAverage (str) {
		if (!str || !str.trim()) return null;
		const wrpTree = Renderer.dice.lang.getTree3(str);
		if (wrpTree) return wrpTree.tree.avg({});
		else return null;
	},

		_showBox () {
		Renderer.dice._$minRoll.hideVe();
		Renderer.dice._$wrpRoll.showVe();
		Renderer.dice._$iptRoll.prop("placeholder", `${Renderer.dice._getRandomPlaceholder()} or "/help"`);
	},

	_hideBox () {
		Renderer.dice._$minRoll.showVe();
		Renderer.dice._$wrpRoll.hideVe();
	},

	_getRandomPlaceholder () {
		const count = RollerUtil.randomise(10);
		const faces = Renderer.dice.DICE[RollerUtil.randomise(Renderer.dice.DICE.length - 1)];
		const mod = (RollerUtil.randomise(3) - 2) * RollerUtil.randomise(10);
		const drop = (count > 1) && RollerUtil.randomise(5) === 5;
		const dropDir = drop ? RollerUtil.randomise(2) === 2 ? "h" : "l" : "";
		const dropAmount = drop ? RollerUtil.randomise(count - 1) : null;
		return `${count}d${faces}${drop ? `d${dropDir}${dropAmount}` : ""}${mod < 0 ? mod : mod > 0 ? `+${mod}` : ""}`;
	},

		async _pInit () {
		const $wrpRoll = $(`<div class="rollbox ve-flex-col min-h-0"></div>`).hideVe();
		const $minRoll = $(`<button class="rollbox-min"><span class="glyphicon glyphicon-chevron-up"></span></button>`).on("click", () => {
			Renderer.dice._showBox();
			Renderer.dice._$iptRoll.focus();
		});
		const $head = $(`<div class="head-roll"><span class="hdr-roll">Dice Roller</span><span class="p-2 glyphicon glyphicon-remove"></span></div>`)
			.on("click", () => {
				if (!Renderer.dice._panel) Renderer.dice._hideBox();
			});
		const $outRoll = $(`<div class="out-roll">`);
		const $iptRoll = $(`<input class="ipt-roll form-control" autocomplete="off" spellcheck="false">`)
			.on("keypress", async evt => {
				evt.stopPropagation();
				if (evt.key !== "Enter") return;

				const strDice = $iptRoll.val();
				const result = await Renderer.dice.pRoll2(
					strDice,
					{
						isUser: true,
						name: "Anon",
					},
				);
				$iptRoll.val("");

				if (result === Renderer.dice._SYMBOL_PARSE_FAILED) {
					Renderer.dice._showInvalid();
					$iptRoll.addClass("form-control--error");
				}
			}).on("keydown", (evt) => {
				$iptRoll.removeClass("form-control--error");

								if (evt.key === "ArrowUp") {
					evt.preventDefault();
					Renderer.dice._prevHistory();
					return;
				}

				if (evt.key === "ArrowDown") {
					evt.preventDefault();
					Renderer.dice._nextHistory();
				}
			});
		$wrpRoll.append($head).append($outRoll).append($iptRoll);

		Renderer.dice._$wrpRoll = $wrpRoll;
		Renderer.dice._$minRoll = $minRoll;
		Renderer.dice._$head = $head;
		Renderer.dice._$outRoll = $outRoll;
		Renderer.dice._$iptRoll = $iptRoll;

		$(`body`).append($minRoll).append($wrpRoll);

		$wrpRoll.on("click", ".out-roll-item-code", (evt) => Renderer.dice._$iptRoll.val($(evt.target).text()).focus());

		Renderer.dice.storage = await StorageUtil.pGet(VeCt.STORAGE_ROLLER_MACRO) || {};
	},

	_prevHistory () { Renderer.dice._histIndex--; Renderer.dice._prevNextHistory_load(); },
	_nextHistory () { Renderer.dice._histIndex++; Renderer.dice._prevNextHistory_load(); },

	_prevNextHistory_load () {
		Renderer.dice._cleanHistoryIndex();
		const nxtVal = Renderer.dice._hist[Renderer.dice._histIndex];
		Renderer.dice._$iptRoll.val(nxtVal);
		if (nxtVal) Renderer.dice._$iptRoll[0].selectionStart = Renderer.dice._$iptRoll[0].selectionEnd = nxtVal.length;
	},

	_cleanHistoryIndex: () => {
		if (!Renderer.dice._hist.length) {
			Renderer.dice._histIndex = null;
		} else {
			Renderer.dice._histIndex = Math.min(Renderer.dice._hist.length, Math.max(Renderer.dice._histIndex, 0));
		}
	},

	_addHistory: (str) => {
		Renderer.dice._hist.push(str);
				Renderer.dice._histIndex = Renderer.dice._hist.length;
	},

	_scrollBottom: () => {
		Renderer.dice._$outRoll.scrollTop(1e10);
	},
	
		async pRollerClickUseData (evt, ele) {
		const $ele = $(ele);
		const rollData = $ele.data("packed-dice");
		let name = $ele.data("roll-name");
		let shiftKey = evt.shiftKey;
		let ctrlKey = evt.ctrlKey || evt.metaKey;

		const options = rollData.toRoll.split(";").map(it => it.trim()).filter(Boolean);

		let chosenRollData;
		if (options.length > 1) {
			const cpyRollData = MiscUtil.copyFast(rollData);
			const menu = ContextUtil.getMenu([
				new ContextUtil.Action(
					"Choose Roll",
					null,
					{isDisabled: true},
				),
				null,
				...options.map(it => new ContextUtil.Action(
					`Roll ${it}`,
					evt => {
						shiftKey = shiftKey || evt.shiftKey;
						ctrlKey = ctrlKey || (evt.ctrlKey || evt.metaKey);
						cpyRollData.toRoll = it;
						return cpyRollData;
					},
				)),
			]);

			chosenRollData = await ContextUtil.pOpenMenu(evt, menu);
		} else chosenRollData = rollData;

		if (!chosenRollData) return;

		const rePrompt = /#\$prompt_number:?([^$]*)\$#/g;
		const results = [];
		let m;
		while ((m = rePrompt.exec(chosenRollData.toRoll))) {
			const optionsRaw = m[1];
			const opts = {};
			if (optionsRaw) {
				const spl = optionsRaw.split(",");
				spl.map(it => it.trim()).forEach(part => {
					const [k, v] = part.split("=").map(it => it.trim());
					switch (k) {
						case "min":
						case "max":
							opts[k] = Number(v); break;
						default:
							opts[k] = v; break;
					}
				});
			}

			if (opts.min == null) opts.min = 0;
			if (opts.max == null) opts.max = Renderer.dice.POS_INFINITE;
			if (opts.default == null) opts.default = 0;

			const input = await InputUiUtil.pGetUserNumber(opts);
			if (input == null) return;
			results.push(input);
		}

		const rollDataCpy = MiscUtil.copyFast(chosenRollData);
		rePrompt.lastIndex = 0;
		rollDataCpy.toRoll = rollDataCpy.toRoll.replace(rePrompt, () => results.shift());

				let rollDataCpyToRoll;
		if (rollData.prompt) {
			const sortedKeys = Object.keys(rollDataCpy.prompt.options).sort(SortUtil.ascSortLower);
			const menu = ContextUtil.getMenu([
				new ContextUtil.Action(rollDataCpy.prompt.entry, null, {isDisabled: true}),
				null,
				...sortedKeys
					.map(it => {
						const title = rollDataCpy.prompt.mode === "psi"
							? `${it} point${it === "1" ? "" : "s"}`
							: `${Parser.spLevelToFull(it)} level`;

						return new ContextUtil.Action(
							title,
							evt => {
								shiftKey = shiftKey || evt.shiftKey;
								ctrlKey = ctrlKey || (evt.ctrlKey || evt.metaKey);

								const fromScaling = rollDataCpy.prompt.options[it];
								if (!fromScaling) {
									name = "";
									return rollDataCpy;
								} else {
									name = rollDataCpy.prompt.mode === "psi" ? `${it} psi activation` : `${Parser.spLevelToFull(it)}-level cast`;
									rollDataCpy.toRoll += `+${fromScaling}`;
									return rollDataCpy;
								}
							},
						);
					}),
			]);

			rollDataCpyToRoll = await ContextUtil.pOpenMenu(evt, menu);
		} else rollDataCpyToRoll = rollDataCpy;

		if (!rollDataCpyToRoll) return;
		await Renderer.dice.pRollerClick({shiftKey, ctrlKey}, ele, JSON.stringify(rollDataCpyToRoll), name);
	},

	__rerollNextInlineResult (ele) {
		const $ele = $(ele);
		const $result = $ele.next(`.result`);
		const r = Renderer.dice.__rollPackedData($ele);
		$result.text(r);
	},

	__rollPackedData ($ele) {
				const wrpTree = Renderer.dice.lang.getTree3($ele.data("packed-dice").toRoll);
		return wrpTree.tree.evl({});
	},

	$getEleUnknownTableRoll (total) { return $(Renderer.dice._pRollerClick_getMsgBug(total)); },

	_pRollerClick_getMsgBug (total) { return `<span class="message">No result found matching roll ${total}?! <span class="help-subtle" title="Bug!">🐛</span></span>`; },

	async pRollerClick (evtMock, ele, packed, name) {
		const $ele = $(ele);
		const entry = JSON.parse(packed);
		const additionalData = {...ele.dataset};

		const rolledBy = {
			name: Renderer.dice._pRollerClick_attemptToGetNameOfRoller({$ele}),
			label: name != null ? name : Renderer.dice._pRollerClick_attemptToGetNameOfRoll({entry, $ele}),
		};

		const modRollMeta = Renderer.dice.getEventModifiedRollMeta(evtMock, entry);
		const $parent = $ele.closest("th, p, table");

		const rollResult = await this._pRollerClick_pGetResult({
			$parent,
			$ele,
			entry,
			modRollMeta,
			rolledBy,
			additionalData,
		});

		if (!entry.autoRoll) return;

		const $tgt = $ele.next(`[data-rd-is-autodice-result="true"]`);
		const curTxt = $tgt.text();
		$tgt.text(rollResult);
		JqueryUtil.showCopiedEffect($tgt, curTxt, true);
	},

	async _pRollerClick_pGetResult ({$parent, $ele, entry, modRollMeta, rolledBy, additionalData}) {
		const sharedRollOpts = {
			rollCount: modRollMeta.rollCount,
			additionalData,
			isHidden: !!entry.autoRoll,
		};

		if ($parent.is("th") && $parent.attr("data-rd-isroller") === "true") {
			if ($parent.attr("data-rd-namegeneratorrolls")) {
				return Renderer.dice._pRollerClick_pRollGeneratorTable({
					$parent,
					$ele,
					rolledBy,
					modRollMeta,
					rollOpts: sharedRollOpts,
				});
			}

			return Renderer.dice.pRollEntry(
				modRollMeta.entry,
				rolledBy,
				{
					...sharedRollOpts,
					fnGetMessage: Renderer.dice._pRollerClick_fnGetMessageTable.bind(Renderer.dice, $ele),
				},
			);
		}

		return Renderer.dice.pRollEntry(
			modRollMeta.entry,
			rolledBy,
			{
				...sharedRollOpts,
			},
		);
	},

	_pRollerClick_fnGetMessageTable ($ele, total) {
		const elesTd = Renderer.dice._pRollerClick_$getTdsFromTotal($ele, total);
		if (elesTd) {
			const tableRow = elesTd.map(ele => ele.innerHTML.trim()).filter(it => it).join(" | ");
			const $row = $(`<span class="message">${tableRow}</span>`);
			Renderer.dice._pRollerClick_rollInlineRollers($ele);
			return $row.html();
		}
		return Renderer.dice._pRollerClick_getMsgBug(total);
	},

		_pRollerClick_attemptToGetNameOfRoll ({entry, $ele}) {
				if (entry.name) return entry.name;

				let titleMaybe = $ele.closest(`table:not(.stats)`).children(`caption`).text();
		if (titleMaybe) return titleMaybe.trim();

				titleMaybe = $ele.parent().children(`.rd__list-item-name`).text();
		if (titleMaybe) return titleMaybe.trim().replace(/[.,:]$/, "");

				titleMaybe = $ele.closest(`div`).children(`.rd__h`).first().find(`.entry-title-inner`).text();
		if (titleMaybe) {
			titleMaybe = titleMaybe.trim().replace(/[.,:]$/, "");
			return titleMaybe;
		}

				titleMaybe = $ele.closest(`table.stats`).children(`tbody`).first().children(`tr`).first().find(`.rnd-name .stats-name`).text();
		if (titleMaybe) return titleMaybe.trim();

		if (UrlUtil.getCurrentPage() === UrlUtil.PG_CHARACTERS) {
						titleMaybe = ($ele.closest(`.chr-entity__row`).find(".chr-entity__ipt-name").val() || "").trim();
			if (titleMaybe) return titleMaybe;
		}

		return titleMaybe;
	},

	_pRollerClick_attemptToGetNameOfRoller ({$ele}) {
		const $hov = $ele.closest(`.hwin`);
		if ($hov.length) return $hov.find(`.stats-name`).first().text();
		const $roll = $ele.closest(`.out-roll-wrp`);
		if ($roll.length) return $roll.data("name");
		const $dispPanelTitle = $ele.closest(`.dm-screen-panel`).children(`.panel-control-title`);
		if ($dispPanelTitle.length) return $dispPanelTitle.text().trim();
		let name = document.title.replace("- 5etools", "").trim();
		return name === "DM Screen" ? "Dungeon Master" : name;
	},

	_pRollerClick_$getTdsFromTotal ($ele, total) {
		const $table = $ele.closest(`table`);
		const $tdRoll = $table.find(`td`).filter((i, e) => {
			const $e = $(e);
			if (!$e.closest(`table`).is($table)) return false;
			return total >= Number($e.data("roll-min")) && total <= Number($e.data("roll-max"));
		});
		if ($tdRoll.length && $tdRoll.nextAll().length) {
			return $tdRoll.nextAll().get();
		}
		return null;
	},

		_pRollerClick_rollInlineRollers ($ele) {
		$ele.find(`.render-roller`).each((i, e) => {
			const $e = $(e);
			const r = Renderer.dice.__rollPackedData($e);
			$e.attr("onclick", `Renderer.dice.__rerollNextInlineResult(this)`);
			$e.after(` (<span class="result">${r}</span>)`);
		});
	},

	_pRollerClick_fnGetMessageGeneratorTable ($ele, ix, total) {
		const elesTd = Renderer.dice._pRollerClick_$getTdsFromTotal($ele, total);
		if (elesTd) {
			const $row = $(`<span class="message">${elesTd[ix].innerHTML.trim()}</span>`);
			Renderer.dice._pRollerClick_rollInlineRollers($ele);
			return $row.html();
		}
		return Renderer.dice._pRollerClick_getMsgBug(total);
	},

	async _pRollerClick_pRollGeneratorTable ({$parent, $ele, rolledBy, modRollMeta, rollOpts}) {
		Renderer.dice.addElement({rolledBy, html: `<i>${rolledBy.label}:</i>`, isMessage: true});

				let total = 0;

		const out = [];
		const numRolls = Number($parent.attr("data-rd-namegeneratorrolls"));
		const $ths = $ele.closest(`table`).find(`th`);
		for (let i = 0; i < numRolls; ++i) {
			const cpyRolledBy = MiscUtil.copyFast(rolledBy);
			cpyRolledBy.label = $($ths.get(i + 1)).text().trim();

			const result = await Renderer.dice.pRollEntry(
				modRollMeta.entry,
				cpyRolledBy,
				{
					...rollOpts,
					fnGetMessage: Renderer.dice._pRollerClick_fnGetMessageGeneratorTable.bind(Renderer.dice, $ele, i),
				},
			);
			total += result;
			const elesTd = Renderer.dice._pRollerClick_$getTdsFromTotal($ele, result);

			if (!elesTd) {
				out.push(`(no result)`);
				continue;
			}

			out.push(elesTd[i].innerHTML.trim());
		}

		Renderer.dice.addElement({rolledBy, html: `= ${out.join(" ")}`, isMessage: true});

		return total;
	},

	getEventModifiedRollMeta (evt, entry) {
				const out = {rollCount: 1, entry};

		if (evt.shiftKey) {
			if (entry.subType === "damage") { 				const dice = [];
								entry.toRoll
					.replace(/\s+/g, "") 					.replace(/\d*?d\d+/gi, m0 => dice.push(m0));
				entry.toRoll = `${entry.toRoll}${dice.length ? `+${dice.join("+")}` : ""}`;
			} else if (entry.subType === "d20") { 								if (entry.d20mod != null) entry.toRoll = `2d20dl1${entry.d20mod}`;
				else entry.toRoll = entry.toRoll.replace(/^\s*1?\s*d\s*20/, "2d20dl1");
			} else out.rollCount = 2; 		}

		if (evt.ctrlKey || evt.metaKey) {
			if (entry.subType === "damage") { 				entry.toRoll = `floor((${entry.toRoll}) / 2)`;
			} else if (entry.subType === "d20") { 								if (entry.d20mod != null) entry.toRoll = `2d20dh1${entry.d20mod}`;
				else entry.toRoll = entry.toRoll.replace(/^\s*1?\s*d\s*20/, "2d20dh1");
			} else out.rollCount = 2; 		}

		return out;
	},
	
		async pRoll2 (str, rolledBy, opts) {
		opts = opts || {};
		str = str
			.trim()
			.replace(/\/r(?:oll)? /gi, "").trim() 		;
		if (!str) return;
		if (rolledBy.isUser) Renderer.dice._addHistory(str);

		if (str.startsWith("/")) return Renderer.dice._pHandleCommand(str, rolledBy);
		if (str.startsWith("#")) return Renderer.dice._pHandleSavedRoll(str, rolledBy, opts);

		const [head, ...tail] = str.split(":");
		if (tail.length) {
			str = tail.join(":");
			rolledBy.label = head;
		}
		const wrpTree = Renderer.dice.lang.getTree3(str);
		if (!wrpTree) return Renderer.dice._SYMBOL_PARSE_FAILED;
		return Renderer.dice._pHandleRoll2(wrpTree, rolledBy, opts);
	},

		async pRollEntry (entry, rolledBy, opts) {
		opts = opts || {};

		const rollCount = Math.round(opts.rollCount || 1);
		delete opts.rollCount;
		if (rollCount <= 0) throw new Error(`Invalid roll count: ${rollCount} (must be a positive integer)`);

		const wrpTree = Renderer.dice.lang.getTree3(entry.toRoll);
		wrpTree.tree.successThresh = entry.successThresh;
		wrpTree.tree.successMax = entry.successMax;
		wrpTree.tree.chanceSuccessText = entry.chanceSuccessText;
		wrpTree.tree.chanceFailureText = entry.chanceFailureText;
		wrpTree.tree.isColorSuccessFail = entry.isColorSuccessFail;

				const results = [];
		if (rollCount > 1 && !opts.isHidden) Renderer.dice._showMessage(`Rolling twice...`, rolledBy);
		for (let i = 0; i < rollCount; ++i) {
			const result = await Renderer.dice._pHandleRoll2(wrpTree, rolledBy, opts);
			if (result == null) return null;
			results.push(result);
		}
		return Math.max(...results);
	},

		async _pHandleRoll2 (wrpTree, rolledBy, opts) {
		opts = {...opts};

		if (wrpTree.meta && wrpTree.meta.hasPb) {
			const userPb = await InputUiUtil.pGetUserNumber({
				min: 0,
				int: true,
				title: "Enter Proficiency Bonus",
				default: 2,
				storageKey_default: "dice.playerProficiencyBonus",
				isGlobal_default: true,
			});
			if (userPb == null) return null;
			opts.pb = userPb;
		}

		if (wrpTree.meta && wrpTree.meta.hasSummonSpellLevel) {
			const predefinedSpellLevel = opts.additionalData?.summonedBySpellLevel != null && !isNaN(opts.additionalData?.summonedBySpellLevel)
				? Number(opts.additionalData.summonedBySpellLevel)
				: null;

			const userSummonSpellLevel = await InputUiUtil.pGetUserNumber({
				min: predefinedSpellLevel ?? 0,
				int: true,
				title: "Enter Spell Level",
				default: predefinedSpellLevel ?? 1,
			});
			if (userSummonSpellLevel == null) return null;
			opts.summonSpellLevel = userSummonSpellLevel;
		}

		if (wrpTree.meta && wrpTree.meta.hasSummonClassLevel) {
			const predefinedClassLevel = opts.additionalData?.summonedByClassLevel != null && !isNaN(opts.additionalData?.summonedByClassLevel)
				? Number(opts.additionalData.summonedByClassLevel)
				: null;

			const userSummonClassLevel = await InputUiUtil.pGetUserNumber({
				min: predefinedClassLevel ?? 0,
				int: true,
				title: "Enter Class Level",
				default: predefinedClassLevel ?? 1,
			});
			if (userSummonClassLevel == null) return null;
			opts.summonClassLevel = userSummonClassLevel;
		}

		if (Renderer.dice._isManualMode) return Renderer.dice._pHandleRoll2_manual(wrpTree.tree, rolledBy, opts);
		else return Renderer.dice._pHandleRoll2_automatic(wrpTree.tree, rolledBy, opts);
	},

		_pHandleRoll2_automatic (tree, rolledBy, opts) {
		opts = opts || {};

		if (!opts.isHidden) Renderer.dice._showBox();
		Renderer.dice._checkHandleName(rolledBy.name);
		const $out = Renderer.dice._$lastRolledBy;

		if (tree) {
			const meta = {};
			if (opts.pb) meta.pb = opts.pb;
			if (opts.summonSpellLevel) meta.summonSpellLevel = opts.summonSpellLevel;
			if (opts.summonClassLevel) meta.summonClassLevel = opts.summonClassLevel;

			const result = tree.evl(meta);
			const fullHtml = (meta.html || []).join("");
			const allMax = meta.allMax && meta.allMax.length && !(meta.allMax.filter(it => !it).length);
			const allMin = meta.allMin && meta.allMin.length && !(meta.allMin.filter(it => !it).length);

			const lbl = rolledBy.label && (!rolledBy.name || rolledBy.label.trim().toLowerCase() !== rolledBy.name.trim().toLowerCase()) ? rolledBy.label : null;

			const ptTarget = opts.target != null
				? result >= opts.target ? ` <b>&geq;${opts.target}</b>` : ` <span class="ve-muted">&lt;${opts.target}</span>`
				: "";

			const isThreshSuccess = tree.successThresh != null && result > (tree.successMax || 100) - tree.successThresh;
			const isColorSuccess = tree.isColorSuccessFail || !tree.chanceSuccessText;
			const isColorFail = tree.isColorSuccessFail || !tree.chanceFailureText;
			const totalPart = tree.successThresh != null
				? `<span class="roll ${isThreshSuccess && isColorSuccess ? "roll-max" : !isThreshSuccess && isColorFail ? "roll-min" : ""}">${isThreshSuccess ? (tree.chanceSuccessText || "Success!") : (tree.chanceFailureText || "Failure")}</span>`
				: `<span class="roll ${allMax ? "roll-max" : allMin ? "roll-min" : ""}">${result}</span>`;

			const title = `${rolledBy.name ? `${rolledBy.name} \u2014 ` : ""}${lbl ? `${lbl}: ` : ""}${tree}`;

			const message = opts.fnGetMessage ? opts.fnGetMessage(result) : null;
			ExtensionUtil.doSendRoll({
				dice: tree.toString(),
				result,
				rolledBy: rolledBy.name,
				label: [lbl, message].filter(Boolean).join(" \u2013 "),
			});

			if (!opts.isHidden) {
				$out.append(`
					<div class="out-roll-item" title="${title}">
						<div>
							${lbl ? `<span class="roll-label">${lbl}: </span>` : ""}
							${totalPart}
							${ptTarget}
							<span class="all-rolls ve-muted">${fullHtml}</span>
							${message ? `<span class="message">${message}</span>` : ""}
						</div>
						<div class="out-roll-item-button-wrp">
							<button title="Copy to input" class="btn btn-default btn-xs btn-copy-roll" onclick="Renderer.dice._$iptRoll.val('${tree.toString().replace(/\s+/g, "")}'); Renderer.dice._$iptRoll.focus()"><span class="glyphicon glyphicon-pencil"></span></button>
						</div>
					</div>`);

				Renderer.dice._scrollBottom();
			}

			return result;
		} else {
			if (!opts.isHidden) {
				$out.append(`<div class="out-roll-item">Invalid input! Try &quot;/help&quot;</div>`);
				Renderer.dice._scrollBottom();
			}
			return null;
		}
	},

	_pHandleRoll2_manual (tree, rolledBy, opts) {
		opts = opts || {};

		if (!tree) return JqueryUtil.doToast({type: "danger", content: `Invalid roll input!`});

		const title = (rolledBy.label || "").toTitleCase() || "Roll Dice";
		const $dispDice = $(`<div class="p-2 bold ve-flex-vh-center rll__prompt-header">${tree.toString()}</div>`);
		if (opts.isResultUsed) {
			return InputUiUtil.pGetUserNumber({
				title,
				$elePre: $dispDice,
			});
		} else {
			const {$modalInner} = UiUtil.getShowModal({
				title,
				isMinHeight0: true,
			});
			$dispDice.appendTo($modalInner);
			return null;
		}
	},

	_showMessage (message, rolledBy) {
		Renderer.dice._showBox();
		Renderer.dice._checkHandleName(rolledBy.name);
		const $out = Renderer.dice._$lastRolledBy;
		$out.append(`<div class="out-roll-item out-roll-item--message">${message}</div>`);
		Renderer.dice._scrollBottom();
	},

	_showInvalid () {
		Renderer.dice._showMessage("Invalid input! Try &quot;/help&quot;", Renderer.dice.SYSTEM_USER);
	},

	_validCommands: new Set(["/c", "/cls", "/clear", "/iterroll"]),
	async _pHandleCommand (com, rolledBy) {
		Renderer.dice._showMessage(`<span class="out-roll-item-code">${com}</span>`, rolledBy); 
		const comParsed = Renderer.dice._getParsedCommand(com);
		const [comOp] = comParsed;

		if (comOp === "/help" || comOp === "/h") {
			Renderer.dice._showMessage(
				`<ul class="rll__list">
					<li>Keep highest; <span class="out-roll-item-code">4d6kh3</span></li>
					<li>Drop lowest; <span class="out-roll-item-code">4d6dl1</span></li>
					<li>Drop highest; <span class="out-roll-item-code">3d4dh1</span></li>
					<li>Keep lowest; <span class="out-roll-item-code">3d4kl1</span></li>

					<li>Reroll equal; <span class="out-roll-item-code">2d4r1</span></li>
					<li>Reroll less; <span class="out-roll-item-code">2d4r&lt;2</span></li>
					<li>Reroll less or equal; <span class="out-roll-item-code">2d4r&lt;=2</span></li>
					<li>Reroll greater; <span class="out-roll-item-code">2d4r&gt;2</span></li>
					<li>Reroll greater equal; <span class="out-roll-item-code">2d4r&gt;=3</span></li>

					<li>Explode equal; <span class="out-roll-item-code">2d4x4</span></li>
					<li>Explode less; <span class="out-roll-item-code">2d4x&lt;2</span></li>
					<li>Explode less or equal; <span class="out-roll-item-code">2d4x&lt;=2</span></li>
					<li>Explode greater; <span class="out-roll-item-code">2d4x&gt;2</span></li>
					<li>Explode greater equal; <span class="out-roll-item-code">2d4x&gt;=3</span></li>

					<li>Count Successes equal; <span class="out-roll-item-code">2d4cs=4</span></li>
					<li>Count Successes less; <span class="out-roll-item-code">2d4cs&lt;2</span></li>
					<li>Count Successes less or equal; <span class="out-roll-item-code">2d4cs&lt;=2</span></li>
					<li>Count Successes greater; <span class="out-roll-item-code">2d4cs&gt;2</span></li>
					<li>Count Successes greater equal; <span class="out-roll-item-code">2d4cs&gt;=3</span></li>

					<li>Margin of Success; <span class="out-roll-item-code">2d4ms=4</span></li>

					<li>Dice pools; <span class="out-roll-item-code">{2d8, 1d6}</span></li>
					<li>Dice pools with modifiers; <span class="out-roll-item-code">{1d20+7, 10}kh1</span></li>

					<li>Rounding; <span class="out-roll-item-code">floor(1.5)</span>, <span class="out-roll-item-code">ceil(1.5)</span>, <span class="out-roll-item-code">round(1.5)</span></li>

					<li>Average; <span class="out-roll-item-code">avg(8d6)</span></li>
					<li>Maximize dice; <span class="out-roll-item-code">dmax(8d6)</span></li>
					<li>Minimize dice; <span class="out-roll-item-code">dmin(8d6)</span></li>

					<li>Other functions; <span class="out-roll-item-code">sign(1d6-3)</span>, <span class="out-roll-item-code">abs(1d6-3)</span>, ...etc.</li>
				</ul>
				Up and down arrow keys cycle input history.<br>
				Anything before a colon is treated as a label (<span class="out-roll-item-code">Fireball: 8d6</span>)<br>
Use <span class="out-roll-item-code">/macro list</span> to list saved macros.<br>
				Use <span class="out-roll-item-code">/macro add myName 1d2+3</span> to add (or update) a macro. Macro names should not contain spaces or hashes.<br>
				Use <span class="out-roll-item-code">/macro remove myName</span> to remove a macro.<br>
				Use <span class="out-roll-item-code">#myName</span> to roll a macro.<br>
				Use <span class="out-roll-item-code">/iterroll roll count [target]</span> to roll multiple times, optionally against a target.
				Use <span class="out-roll-item-code">/clear</span> to clear the roller.`,
				Renderer.dice.SYSTEM_USER,
			);
			return;
		}

		if (comOp === "/macro") {
			const [, mode, ...others] = comParsed;

			if (!["list", "add", "remove", "clear"].includes(mode)) Renderer.dice._showInvalid();
			else {
				switch (mode) {
					case "list":
						if (!others.length) {
							Object.keys(Renderer.dice.storage).forEach(name => {
								Renderer.dice._showMessage(`<span class="out-roll-item-code">#${name}</span> \u2014 ${Renderer.dice.storage[name]}`, Renderer.dice.SYSTEM_USER);
							});
						} else {
							Renderer.dice._showInvalid();
						}
						break;
					case "add": {
						if (others.length === 2) {
							const [name, macro] = others;
							if (name.includes(" ") || name.includes("#")) Renderer.dice._showInvalid();
							else {
								Renderer.dice.storage[name] = macro;
								await Renderer.dice._pSaveMacros();
								Renderer.dice._showMessage(`Saved macro <span class="out-roll-item-code">#${name}</span>`, Renderer.dice.SYSTEM_USER);
							}
						} else {
							Renderer.dice._showInvalid();
						}
						break;
					}
					case "remove":
						if (others.length === 1) {
							if (Renderer.dice.storage[others[0]]) {
								delete Renderer.dice.storage[others[0]];
								await Renderer.dice._pSaveMacros();
								Renderer.dice._showMessage(`Removed macro <span class="out-roll-item-code">#${others[0]}</span>`, Renderer.dice.SYSTEM_USER);
							} else {
								Renderer.dice._showMessage(`Macro <span class="out-roll-item-code">#${others[0]}</span> not found`, Renderer.dice.SYSTEM_USER);
							}
						} else {
							Renderer.dice._showInvalid();
						}
						break;
				}
			}
			return;
		}

		if (Renderer.dice._validCommands.has(comOp)) {
			switch (comOp) {
				case "/c":
				case "/cls":
				case "/clear":
					Renderer.dice._$outRoll.empty();
					Renderer.dice._$lastRolledBy.empty();
					Renderer.dice._$lastRolledBy = null;
					return;

				case "/iterroll": {
					let [, exp, count, target] = comParsed;

					if (!exp) return Renderer.dice._showInvalid();
					const wrpTree = Renderer.dice.lang.getTree3(exp);
					if (!wrpTree) return Renderer.dice._showInvalid();

					count = count && !isNaN(count) ? Number(count) : 1;
					target = target && !isNaN(target) ? Number(target) : undefined;

					for (let i = 0; i < count; ++i) {
						await Renderer.dice.pRoll2(
							exp,
							{
								name: "Anon",
							},
							{
								target,
							},
						);
					}
				}
			}
			return;
		}

		Renderer.dice._showInvalid();
	},

	async _pSaveMacros () {
		await StorageUtil.pSet(VeCt.STORAGE_ROLLER_MACRO, Renderer.dice.storage);
	},

	_getParsedCommand (str) {
				return str.split(/\s+/);
	},

	_pHandleSavedRoll (id, rolledBy, opts) {
		id = id.replace(/^#/, "");
		const macro = Renderer.dice.storage[id];
		if (macro) {
			rolledBy.label = id;
			const wrpTree = Renderer.dice.lang.getTree3(macro);
			return Renderer.dice._pHandleRoll2(wrpTree, rolledBy, opts);
		} else Renderer.dice._showMessage(`Macro <span class="out-roll-item-code">#${id}</span> not found`, Renderer.dice.SYSTEM_USER);
	},

	addRoll ({rolledBy, html, $ele}) {
		if (html && $ele) throw new Error(`Must specify one of html or $ele!`);

		if (html != null && !html.trim()) return;

		Renderer.dice._showBox();
		Renderer.dice._checkHandleName(rolledBy.name);

		if (html) {
			Renderer.dice._$lastRolledBy.append(`<div class="out-roll-item" title="${(rolledBy.name || "").qq()}">${html}</div>`);
		} else {
			$$`<div class="out-roll-item" title="${(rolledBy.name || "").qq()}">${$ele}</div>`
				.appendTo(Renderer.dice._$lastRolledBy);
		}

		Renderer.dice._scrollBottom();
	},

	addElement ({rolledBy, html, $ele}) {
		if (html && $ele) throw new Error(`Must specify one of html or $ele!`);

		if (html != null && !html.trim()) return;

		Renderer.dice._showBox();
		Renderer.dice._checkHandleName(rolledBy.name);

		if (html) {
			Renderer.dice._$lastRolledBy.append(`<div class="out-roll-item out-roll-item--message" title="${(rolledBy.name || "").qq()}">${html}</div>`);
		} else {
			$$`<div class="out-roll-item out-roll-item--message" title="${(rolledBy.name || "").qq()}">${$ele}</div>`
				.appendTo(Renderer.dice._$lastRolledBy);
		}

		Renderer.dice._scrollBottom();
	},

	_checkHandleName (name) {
		if (!Renderer.dice._$lastRolledBy || Renderer.dice._$lastRolledBy.data("name") !== name) {
			Renderer.dice._$outRoll.prepend(`<div class="ve-muted out-roll-id">${name}</div>`);
			Renderer.dice._$lastRolledBy = $(`<div class="out-roll-wrp"></div>`).data("name", name);
			Renderer.dice._$outRoll.prepend(Renderer.dice._$lastRolledBy);
		}
	},
};

Renderer.dice.util = {
	getReducedMeta (meta) {
		return {pb: meta.pb};
	},
};

Renderer.dice.lang = {
		validate3 (str) {
		str = str.trim();

				let lexed;
		try {
			lexed = Renderer.dice.lang._lex3(str).lexed;
		} catch (e) {
			return e.message;
		}
		
				try {
			Renderer.dice.lang._parse3(lexed);
		} catch (e) {
			return e.message;
		}
		
		return null;
	},

	getTree3 (str, isSilent = true) {
		str = str.trim();
		if (isSilent) {
			try {
				const {lexed, lexedMeta} = Renderer.dice.lang._lex3(str);
				return {tree: Renderer.dice.lang._parse3(lexed), meta: lexedMeta};
			} catch (e) {
				return null;
			}
		} else {
			const {lexed, lexedMeta} = Renderer.dice.lang._lex3(str);
			return {tree: Renderer.dice.lang._parse3(lexed), meta: lexedMeta};
		}
	},
	
		_M_NUMBER_CHAR: /[0-9.]/,
	_M_SYMBOL_CHAR: /[-+/*^=><florceidhkxunavgsmpbtqw,]/,

	_M_NUMBER: /^[\d.,]+$/,
	_lex3 (str) {
		const self = {
			tokenStack: [],
			parenCount: 0,
			braceCount: 0,
			mode: null,
			token: "",
			hasPb: false,
			hasSummonSpellLevel: false,
			hasSummonClassLevel: false,
		};

		str = str
			.trim()
			.toLowerCase()
						.replace(/\s*?\bplus\b\s*?/g, " + ")
			.replace(/\s*?\bminus\b\s*?/g, " - ")
			.replace(/\s*?\btimes\b\s*?/g, " * ")
			.replace(/\s*?\bover\b\s*?/g, " / ")
			.replace(/\s*?\bdivided by\b\s*?/g, " / ")
						.replace(/\s+/g, "")
			.replace(/[\u2012\u2013\u2014]/g, "-") 			.replace(/[×]/g, "*") 			.replace(/\*\*/g, "^") 			.replace(/÷/g, "/") 			.replace(/--/g, "+") 			.replace(/\+-|-\+/g, "-") 		;

		if (!str) return {lexed: [], lexedMeta: {}};

		this._lex3_lex(self, str);

		return {lexed: self.tokenStack, lexedMeta: {hasPb: self.hasPb, hasSummonSpellLevel: self.hasSummonSpellLevel, hasSummonClassLevel: self.hasSummonClassLevel}};
	},

	_lex3_lex (self, l) {
		const len = l.length;

		for (let i = 0; i < len; ++i) {
			const c = l[i];

			switch (c) {
				case "(":
					self.parenCount++;
					this._lex3_outputToken(self);
					self.token = "(";
					this._lex3_outputToken(self);
					break;
				case ")":
					self.parenCount--;
					if (self.parenCount < 0) throw new Error(`Syntax error: closing <code>)</code> without opening <code>(</code>`);
					this._lex3_outputToken(self);
					self.token = ")";
					this._lex3_outputToken(self);
					break;
				case "{":
					self.braceCount++;
					this._lex3_outputToken(self);
					self.token = "{";
					this._lex3_outputToken(self);
					break;
				case "}":
					self.braceCount--;
					if (self.parenCount < 0) throw new Error(`Syntax error: closing <code>}</code> without opening <code>(</code>`);
					this._lex3_outputToken(self);
					self.token = "}";
					this._lex3_outputToken(self);
					break;
								case "+": case "-": case "*": case "/": case "^": case ",":
					this._lex3_outputToken(self);
					self.token += c;
					this._lex3_outputToken(self);
					break;
				default: {
					if (Renderer.dice.lang._M_NUMBER_CHAR.test(c)) {
						if (self.mode === "symbol") this._lex3_outputToken(self);
						self.token += c;
						self.mode = "text";
					} else if (Renderer.dice.lang._M_SYMBOL_CHAR.test(c)) {
						if (self.mode === "text") this._lex3_outputToken(self);
						self.token += c;
						self.mode = "symbol";
					} else throw new Error(`Syntax error: unexpected character <code>${c}</code>`);
					break;
				}
			}
		}

				this._lex3_outputToken(self);
	},

	_lex3_outputToken (self) {
		if (!self.token) return;

		switch (self.token) {
			case "(": self.tokenStack.push(Renderer.dice.tk.PAREN_OPEN); break;
			case ")": self.tokenStack.push(Renderer.dice.tk.PAREN_CLOSE); break;
			case "{": self.tokenStack.push(Renderer.dice.tk.BRACE_OPEN); break;
			case "}": self.tokenStack.push(Renderer.dice.tk.BRACE_CLOSE); break;
			case ",": self.tokenStack.push(Renderer.dice.tk.COMMA); break;
			case "+": self.tokenStack.push(Renderer.dice.tk.ADD); break;
			case "-": self.tokenStack.push(Renderer.dice.tk.SUB); break;
			case "*": self.tokenStack.push(Renderer.dice.tk.MULT); break;
			case "/": self.tokenStack.push(Renderer.dice.tk.DIV); break;
			case "^": self.tokenStack.push(Renderer.dice.tk.POW); break;
			case "pb": self.tokenStack.push(Renderer.dice.tk.PB); self.hasPb = true; break;
			case "summonspelllevel": self.tokenStack.push(Renderer.dice.tk.SUMMON_SPELL_LEVEL); self.hasSummonSpellLevel = true; break;
			case "summonclasslevel": self.tokenStack.push(Renderer.dice.tk.SUMMON_CLASS_LEVEL); self.hasSummonClassLevel = true; break;
			case "floor": self.tokenStack.push(Renderer.dice.tk.FLOOR); break;
			case "ceil": self.tokenStack.push(Renderer.dice.tk.CEIL); break;
			case "round": self.tokenStack.push(Renderer.dice.tk.ROUND); break;
			case "avg": self.tokenStack.push(Renderer.dice.tk.AVERAGE); break;
			case "dmax": self.tokenStack.push(Renderer.dice.tk.DMAX); break;
			case "dmin": self.tokenStack.push(Renderer.dice.tk.DMIN); break;
			case "sign": self.tokenStack.push(Renderer.dice.tk.SIGN); break;
			case "abs": self.tokenStack.push(Renderer.dice.tk.ABS); break;
			case "cbrt": self.tokenStack.push(Renderer.dice.tk.CBRT); break;
			case "sqrt": self.tokenStack.push(Renderer.dice.tk.SQRT); break;
			case "exp": self.tokenStack.push(Renderer.dice.tk.EXP); break;
			case "log": self.tokenStack.push(Renderer.dice.tk.LOG); break;
			case "random": self.tokenStack.push(Renderer.dice.tk.RANDOM); break;
			case "trunc": self.tokenStack.push(Renderer.dice.tk.TRUNC); break;
			case "pow": self.tokenStack.push(Renderer.dice.tk.POW); break;
			case "max": self.tokenStack.push(Renderer.dice.tk.MAX); break;
			case "min": self.tokenStack.push(Renderer.dice.tk.MIN); break;
			case "d": self.tokenStack.push(Renderer.dice.tk.DICE); break;
			case "dh": self.tokenStack.push(Renderer.dice.tk.DROP_HIGHEST); break;
			case "kh": self.tokenStack.push(Renderer.dice.tk.KEEP_HIGHEST); break;
			case "dl": self.tokenStack.push(Renderer.dice.tk.DROP_LOWEST); break;
			case "kl": self.tokenStack.push(Renderer.dice.tk.KEEP_LOWEST); break;
			case "r": self.tokenStack.push(Renderer.dice.tk.REROLL_EXACT); break;
			case "r>": self.tokenStack.push(Renderer.dice.tk.REROLL_GT); break;
			case "r>=": self.tokenStack.push(Renderer.dice.tk.REROLL_GTEQ); break;
			case "r<": self.tokenStack.push(Renderer.dice.tk.REROLL_LT); break;
			case "r<=": self.tokenStack.push(Renderer.dice.tk.REROLL_LTEQ); break;
			case "x": self.tokenStack.push(Renderer.dice.tk.EXPLODE_EXACT); break;
			case "x>": self.tokenStack.push(Renderer.dice.tk.EXPLODE_GT); break;
			case "x>=": self.tokenStack.push(Renderer.dice.tk.EXPLODE_GTEQ); break;
			case "x<": self.tokenStack.push(Renderer.dice.tk.EXPLODE_LT); break;
			case "x<=": self.tokenStack.push(Renderer.dice.tk.EXPLODE_LTEQ); break;
			case "cs=": self.tokenStack.push(Renderer.dice.tk.COUNT_SUCCESS_EXACT); break;
			case "cs>": self.tokenStack.push(Renderer.dice.tk.COUNT_SUCCESS_GT); break;
			case "cs>=": self.tokenStack.push(Renderer.dice.tk.COUNT_SUCCESS_GTEQ); break;
			case "cs<": self.tokenStack.push(Renderer.dice.tk.COUNT_SUCCESS_LT); break;
			case "cs<=": self.tokenStack.push(Renderer.dice.tk.COUNT_SUCCESS_LTEQ); break;
			case "ms=": self.tokenStack.push(Renderer.dice.tk.MARGIN_SUCCESS_EXACT); break;
			case "ms>": self.tokenStack.push(Renderer.dice.tk.MARGIN_SUCCESS_GT); break;
			case "ms>=": self.tokenStack.push(Renderer.dice.tk.MARGIN_SUCCESS_GTEQ); break;
			case "ms<": self.tokenStack.push(Renderer.dice.tk.MARGIN_SUCCESS_LT); break;
			case "ms<=": self.tokenStack.push(Renderer.dice.tk.MARGIN_SUCCESS_LTEQ); break;
			default: {
				if (Renderer.dice.lang._M_NUMBER.test(self.token)) {
					if (self.token.split(Parser._decimalSeparator).length > 2) throw new Error(`Syntax error: too many decimal separators <code>${self.token}</code>`);
					self.tokenStack.push(Renderer.dice.tk.NUMBER(self.token));
				} else throw new Error(`Syntax error: unexpected token <code>${self.token}</code>`);
			}
		}

		self.token = "";
	},
	
		_parse3 (lexed) {
		const self = {
			ixSym: -1,
			syms: lexed,
			sym: null,
			lastAccepted: null,
									isIgnoreCommas: true,
		};

		this._parse3_nextSym(self);
		return this._parse3_expression(self);
	},

	_parse3_nextSym (self) {
		const cur = self.syms[self.ixSym];
		self.ixSym++;
		self.sym = self.syms[self.ixSym];
		return cur;
	},

	_parse3_match (self, symbol) {
		if (self.sym == null) return false;
		if (symbol.type) symbol = symbol.type; 		return self.sym.type === symbol;
	},

	_parse3_accept (self, symbol) {
		if (this._parse3_match(self, symbol)) {
			const out = self.sym;
			this._parse3_nextSym(self);
			self.lastAccepted = out;
			return out;
		}
		return false;
	},

	_parse3_expect (self, symbol) {
		const accepted = this._parse3_accept(self, symbol);
		if (accepted) return accepted;
		if (self.sym) throw new Error(`Unexpected input: Expected <code>${symbol}</code> but found <code>${self.sym}</code>`);
		else throw new Error(`Unexpected end of input: Expected <code>${symbol}</code>`);
	},

	_parse3_factor (self, {isSilent = false} = {}) {
		if (this._parse3_accept(self, Renderer.dice.tk.TYP_NUMBER)) {
						if (self.isIgnoreCommas) {
								const syms = [self.lastAccepted];
				while (this._parse3_accept(self, Renderer.dice.tk.COMMA)) {
					const sym = this._parse3_expect(self, Renderer.dice.tk.TYP_NUMBER);
					syms.push(sym);
				}
				const sym = Renderer.dice.tk.NUMBER(syms.map(it => it.value).join(""));
				return new Renderer.dice.parsed.Factor(sym);
			}

			return new Renderer.dice.parsed.Factor(self.lastAccepted);
		} else if (this._parse3_accept(self, Renderer.dice.tk.PB)) {
			return new Renderer.dice.parsed.Factor(Renderer.dice.tk.PB);
		} else if (this._parse3_accept(self, Renderer.dice.tk.SUMMON_SPELL_LEVEL)) {
			return new Renderer.dice.parsed.Factor(Renderer.dice.tk.SUMMON_SPELL_LEVEL);
		} else if (this._parse3_accept(self, Renderer.dice.tk.SUMMON_CLASS_LEVEL)) {
			return new Renderer.dice.parsed.Factor(Renderer.dice.tk.SUMMON_CLASS_LEVEL);
		} else if (
						this._parse3_match(self, Renderer.dice.tk.FLOOR)
			|| this._parse3_match(self, Renderer.dice.tk.CEIL)
			|| this._parse3_match(self, Renderer.dice.tk.ROUND)
			|| this._parse3_match(self, Renderer.dice.tk.AVERAGE)
			|| this._parse3_match(self, Renderer.dice.tk.DMAX)
			|| this._parse3_match(self, Renderer.dice.tk.DMIN)
			|| this._parse3_match(self, Renderer.dice.tk.SIGN)
			|| this._parse3_match(self, Renderer.dice.tk.ABS)
			|| this._parse3_match(self, Renderer.dice.tk.CBRT)
			|| this._parse3_match(self, Renderer.dice.tk.SQRT)
			|| this._parse3_match(self, Renderer.dice.tk.EXP)
			|| this._parse3_match(self, Renderer.dice.tk.LOG)
			|| this._parse3_match(self, Renderer.dice.tk.RANDOM)
			|| this._parse3_match(self, Renderer.dice.tk.TRUNC)
		) {
			const children = [];

			children.push(this._parse3_nextSym(self));
			this._parse3_expect(self, Renderer.dice.tk.PAREN_OPEN);
			children.push(this._parse3_expression(self));
			this._parse3_expect(self, Renderer.dice.tk.PAREN_CLOSE);

			return new Renderer.dice.parsed.Function(children);
		} else if (
						this._parse3_match(self, Renderer.dice.tk.POW)
		) {
			self.isIgnoreCommas = false;

			const children = [];

			children.push(this._parse3_nextSym(self));
			this._parse3_expect(self, Renderer.dice.tk.PAREN_OPEN);
			children.push(this._parse3_expression(self));
			this._parse3_expect(self, Renderer.dice.tk.COMMA);
			children.push(this._parse3_expression(self));
			this._parse3_expect(self, Renderer.dice.tk.PAREN_CLOSE);

			self.isIgnoreCommas = true;

			return new Renderer.dice.parsed.Function(children);
		} else if (
						this._parse3_match(self, Renderer.dice.tk.MAX)
			|| this._parse3_match(self, Renderer.dice.tk.MIN)
		) {
			self.isIgnoreCommas = false;

			const children = [];

			children.push(this._parse3_nextSym(self));
			this._parse3_expect(self, Renderer.dice.tk.PAREN_OPEN);
			children.push(this._parse3_expression(self));
			while (this._parse3_accept(self, Renderer.dice.tk.COMMA)) children.push(this._parse3_expression(self));
			this._parse3_expect(self, Renderer.dice.tk.PAREN_CLOSE);

			self.isIgnoreCommas = true;

			return new Renderer.dice.parsed.Function(children);
		} else if (this._parse3_accept(self, Renderer.dice.tk.PAREN_OPEN)) {
			const exp = this._parse3_expression(self);
			this._parse3_expect(self, Renderer.dice.tk.PAREN_CLOSE);
			return new Renderer.dice.parsed.Factor(exp, {hasParens: true});
		} else if (this._parse3_accept(self, Renderer.dice.tk.BRACE_OPEN)) {
			self.isIgnoreCommas = false;

			const children = [];

			children.push(this._parse3_expression(self));
			while (this._parse3_accept(self, Renderer.dice.tk.COMMA)) children.push(this._parse3_expression(self));

			this._parse3_expect(self, Renderer.dice.tk.BRACE_CLOSE);

			self.isIgnoreCommas = true;

			const modPart = [];
			this._parse3__dice_modifiers(self, modPart);

			return new Renderer.dice.parsed.Pool(children, modPart[0]);
		} else {
			if (isSilent) return null;

			if (self.sym) throw new Error(`Unexpected input: <code>${self.sym}</code>`);
			else throw new Error(`Unexpected end of input`);
		}
	},

	_parse3_dice (self) {
		const children = [];

				if (this._parse3_match(self, Renderer.dice.tk.DICE)) children.push(new Renderer.dice.parsed.Factor(Renderer.dice.tk.NUMBER(1)));
		else children.push(this._parse3_factor(self));

		while (this._parse3_match(self, Renderer.dice.tk.DICE)) {
			this._parse3_nextSym(self);
			children.push(this._parse3_factor(self));
			this._parse3__dice_modifiers(self, children);
		}
		return new Renderer.dice.parsed.Dice(children);
	},

	_parse3__dice_modifiers (self, children) { 				const modsMeta = new Renderer.dice.lang.DiceModMeta();

		while (
			this._parse3_match(self, Renderer.dice.tk.DROP_HIGHEST)
			|| this._parse3_match(self, Renderer.dice.tk.KEEP_HIGHEST)
			|| this._parse3_match(self, Renderer.dice.tk.DROP_LOWEST)
			|| this._parse3_match(self, Renderer.dice.tk.KEEP_LOWEST)
			|| this._parse3_match(self, Renderer.dice.tk.REROLL_EXACT)
			|| this._parse3_match(self, Renderer.dice.tk.REROLL_GT)
			|| this._parse3_match(self, Renderer.dice.tk.REROLL_GTEQ)
			|| this._parse3_match(self, Renderer.dice.tk.REROLL_LT)
			|| this._parse3_match(self, Renderer.dice.tk.REROLL_LTEQ)
			|| this._parse3_match(self, Renderer.dice.tk.EXPLODE_EXACT)
			|| this._parse3_match(self, Renderer.dice.tk.EXPLODE_GT)
			|| this._parse3_match(self, Renderer.dice.tk.EXPLODE_GTEQ)
			|| this._parse3_match(self, Renderer.dice.tk.EXPLODE_LT)
			|| this._parse3_match(self, Renderer.dice.tk.EXPLODE_LTEQ)
			|| this._parse3_match(self, Renderer.dice.tk.COUNT_SUCCESS_EXACT)
			|| this._parse3_match(self, Renderer.dice.tk.COUNT_SUCCESS_GT)
			|| this._parse3_match(self, Renderer.dice.tk.COUNT_SUCCESS_GTEQ)
			|| this._parse3_match(self, Renderer.dice.tk.COUNT_SUCCESS_LT)
			|| this._parse3_match(self, Renderer.dice.tk.COUNT_SUCCESS_LTEQ)
			|| this._parse3_match(self, Renderer.dice.tk.MARGIN_SUCCESS_EXACT)
			|| this._parse3_match(self, Renderer.dice.tk.MARGIN_SUCCESS_GT)
			|| this._parse3_match(self, Renderer.dice.tk.MARGIN_SUCCESS_GTEQ)
			|| this._parse3_match(self, Renderer.dice.tk.MARGIN_SUCCESS_LT)
			|| this._parse3_match(self, Renderer.dice.tk.MARGIN_SUCCESS_LTEQ)
		) {
			const nxtSym = this._parse3_nextSym(self);
			const nxtFactor = this._parse3__dice_modifiers_nxtFactor(self, nxtSym);

			if (nxtSym.isSuccessMode) modsMeta.isSuccessMode = true;
			modsMeta.mods.push({modSym: nxtSym, numSym: nxtFactor});
		}

		if (modsMeta.mods.length) children.push(modsMeta);
	},

	_parse3__dice_modifiers_nxtFactor (self, nxtSym) {
		if (nxtSym.diceModifierImplicit == null) return this._parse3_factor(self, {isSilent: true});

		const fallback = new Renderer.dice.parsed.Factor(Renderer.dice.tk.NUMBER(nxtSym.diceModifierImplicit));
		if (self.sym == null) return fallback;

		const out = this._parse3_factor(self, {isSilent: true});
		if (out) return out;

		return fallback;
	},

	_parse3_exponent (self) {
		const children = [];
		children.push(this._parse3_dice(self));
		while (this._parse3_match(self, Renderer.dice.tk.POW)) {
			this._parse3_nextSym(self);
			children.push(this._parse3_dice(self));
		}
		return new Renderer.dice.parsed.Exponent(children);
	},

	_parse3_term (self) {
		const children = [];
		children.push(this._parse3_exponent(self));
		while (this._parse3_match(self, Renderer.dice.tk.MULT) || this._parse3_match(self, Renderer.dice.tk.DIV)) {
			children.push(this._parse3_nextSym(self));
			children.push(this._parse3_exponent(self));
		}
		return new Renderer.dice.parsed.Term(children);
	},

	_parse3_expression (self) {
		const children = [];
		if (this._parse3_match(self, Renderer.dice.tk.ADD) || this._parse3_match(self, Renderer.dice.tk.SUB)) children.push(this._parse3_nextSym(self));
		children.push(this._parse3_term(self));
		while (this._parse3_match(self, Renderer.dice.tk.ADD) || this._parse3_match(self, Renderer.dice.tk.SUB)) {
			children.push(this._parse3_nextSym(self));
			children.push(this._parse3_term(self));
		}
		return new Renderer.dice.parsed.Expression(children);
	},
	
		DiceModMeta: class {
		constructor () {
			this.isDiceModifierGroup = true;
			this.isSuccessMode = false;
			this.mods = [];
		}
	},
	};

Renderer.dice.tk = {
	Token: class {
				constructor (type, value, asString, opts) {
			opts = opts || {};
			this.type = type;
			this.value = value;
			this._asString = asString;
			if (opts.isDiceModifier) this.isDiceModifier = true;
			if (opts.diceModifierImplicit) this.diceModifierImplicit = true;
			if (opts.isSuccessMode) this.isSuccessMode = true;
		}

		eq (other) { return other && other.type === this.type; }

		toString () {
			if (this._asString) return this._asString;
			return this.toDebugString();
		}

		toDebugString () { return `${this.type}${this.value ? ` :: ${this.value}` : ""}`; }
	},

	_new (type, asString, opts) { return new Renderer.dice.tk.Token(type, null, asString, opts); },

	TYP_NUMBER: "NUMBER",
	TYP_DICE: "DICE",
	TYP_SYMBOL: "SYMBOL", 
	NUMBER (val) { return new Renderer.dice.tk.Token(Renderer.dice.tk.TYP_NUMBER, val); },
};
Renderer.dice.tk.PAREN_OPEN = Renderer.dice.tk._new("PAREN_OPEN", "(");
Renderer.dice.tk.PAREN_CLOSE = Renderer.dice.tk._new("PAREN_CLOSE", ")");
Renderer.dice.tk.BRACE_OPEN = Renderer.dice.tk._new("BRACE_OPEN", "{");
Renderer.dice.tk.BRACE_CLOSE = Renderer.dice.tk._new("BRACE_CLOSE", "}");
Renderer.dice.tk.COMMA = Renderer.dice.tk._new("COMMA", ",");
Renderer.dice.tk.ADD = Renderer.dice.tk._new("ADD", "+");
Renderer.dice.tk.SUB = Renderer.dice.tk._new("SUB", "-");
Renderer.dice.tk.MULT = Renderer.dice.tk._new("MULT", "*");
Renderer.dice.tk.DIV = Renderer.dice.tk._new("DIV", "/");
Renderer.dice.tk.POW = Renderer.dice.tk._new("POW", "^");
Renderer.dice.tk.PB = Renderer.dice.tk._new("PB", "pb");
Renderer.dice.tk.SUMMON_SPELL_LEVEL = Renderer.dice.tk._new("SUMMON_SPELL_LEVEL", "summonspelllevel");
Renderer.dice.tk.SUMMON_CLASS_LEVEL = Renderer.dice.tk._new("SUMMON_CLASS_LEVEL", "summonclasslevel");
Renderer.dice.tk.FLOOR = Renderer.dice.tk._new("FLOOR", "floor");
Renderer.dice.tk.CEIL = Renderer.dice.tk._new("CEIL", "ceil");
Renderer.dice.tk.ROUND = Renderer.dice.tk._new("ROUND", "round");
Renderer.dice.tk.AVERAGE = Renderer.dice.tk._new("AVERAGE", "avg");
Renderer.dice.tk.DMAX = Renderer.dice.tk._new("DMAX", "avg");
Renderer.dice.tk.DMIN = Renderer.dice.tk._new("DMIN", "avg");
Renderer.dice.tk.SIGN = Renderer.dice.tk._new("SIGN", "sign");
Renderer.dice.tk.ABS = Renderer.dice.tk._new("ABS", "abs");
Renderer.dice.tk.CBRT = Renderer.dice.tk._new("CBRT", "cbrt");
Renderer.dice.tk.SQRT = Renderer.dice.tk._new("SQRT", "sqrt");
Renderer.dice.tk.EXP = Renderer.dice.tk._new("EXP", "exp");
Renderer.dice.tk.LOG = Renderer.dice.tk._new("LOG", "log");
Renderer.dice.tk.RANDOM = Renderer.dice.tk._new("RANDOM", "random");
Renderer.dice.tk.TRUNC = Renderer.dice.tk._new("TRUNC", "trunc");
Renderer.dice.tk.POW = Renderer.dice.tk._new("POW", "pow");
Renderer.dice.tk.MAX = Renderer.dice.tk._new("MAX", "max");
Renderer.dice.tk.MIN = Renderer.dice.tk._new("MIN", "min");
Renderer.dice.tk.DICE = Renderer.dice.tk._new("DICE", "d");
Renderer.dice.tk.DROP_HIGHEST = Renderer.dice.tk._new("DH", "dh", {isDiceModifier: true, diceModifierImplicit: 1});
Renderer.dice.tk.KEEP_HIGHEST = Renderer.dice.tk._new("KH", "kh", {isDiceModifier: true, diceModifierImplicit: 1});
Renderer.dice.tk.DROP_LOWEST = Renderer.dice.tk._new("DL", "dl", {isDiceModifier: true, diceModifierImplicit: 1});
Renderer.dice.tk.KEEP_LOWEST = Renderer.dice.tk._new("KL", "kl", {isDiceModifier: true, diceModifierImplicit: 1});
Renderer.dice.tk.REROLL_EXACT = Renderer.dice.tk._new("REROLL", "r", {isDiceModifier: true});
Renderer.dice.tk.REROLL_GT = Renderer.dice.tk._new("REROLL_GT", "r>", {isDiceModifier: true});
Renderer.dice.tk.REROLL_GTEQ = Renderer.dice.tk._new("REROLL_GTEQ", "r>=", {isDiceModifier: true});
Renderer.dice.tk.REROLL_LT = Renderer.dice.tk._new("REROLL_LT", "r<", {isDiceModifier: true});
Renderer.dice.tk.REROLL_LTEQ = Renderer.dice.tk._new("REROLL_LTEQ", "r<=", {isDiceModifier: true});
Renderer.dice.tk.EXPLODE_EXACT = Renderer.dice.tk._new("EXPLODE", "x", {isDiceModifier: true});
Renderer.dice.tk.EXPLODE_GT = Renderer.dice.tk._new("EXPLODE_GT", "x>", {isDiceModifier: true});
Renderer.dice.tk.EXPLODE_GTEQ = Renderer.dice.tk._new("EXPLODE_GTEQ", "x>=", {isDiceModifier: true});
Renderer.dice.tk.EXPLODE_LT = Renderer.dice.tk._new("EXPLODE_LT", "x<", {isDiceModifier: true});
Renderer.dice.tk.EXPLODE_LTEQ = Renderer.dice.tk._new("EXPLODE_LTEQ", "x<=", {isDiceModifier: true});
Renderer.dice.tk.COUNT_SUCCESS_EXACT = Renderer.dice.tk._new("COUNT_SUCCESS_EXACT", "cs=", {isDiceModifier: true, isSuccessMode: true});
Renderer.dice.tk.COUNT_SUCCESS_GT = Renderer.dice.tk._new("COUNT_SUCCESS_GT", "cs>", {isDiceModifier: true, isSuccessMode: true});
Renderer.dice.tk.COUNT_SUCCESS_GTEQ = Renderer.dice.tk._new("COUNT_SUCCESS_GTEQ", "cs>=", {isDiceModifier: true, isSuccessMode: true});
Renderer.dice.tk.COUNT_SUCCESS_LT = Renderer.dice.tk._new("COUNT_SUCCESS_LT", "cs<", {isDiceModifier: true, isSuccessMode: true});
Renderer.dice.tk.COUNT_SUCCESS_LTEQ = Renderer.dice.tk._new("COUNT_SUCCESS_LTEQ", "cs<=", {isDiceModifier: true, isSuccessMode: true});
Renderer.dice.tk.MARGIN_SUCCESS_EXACT = Renderer.dice.tk._new("MARGIN_SUCCESS_EXACT", "ms=", {isDiceModifier: true});
Renderer.dice.tk.MARGIN_SUCCESS_GT = Renderer.dice.tk._new("MARGIN_SUCCESS_GT", "ms>", {isDiceModifier: true});
Renderer.dice.tk.MARGIN_SUCCESS_GTEQ = Renderer.dice.tk._new("MARGIN_SUCCESS_GTEQ", "ms>=", {isDiceModifier: true});
Renderer.dice.tk.MARGIN_SUCCESS_LT = Renderer.dice.tk._new("MARGIN_SUCCESS_LT", "ms<", {isDiceModifier: true});
Renderer.dice.tk.MARGIN_SUCCESS_LTEQ = Renderer.dice.tk._new("MARGIN_SUCCESS_LTEQ", "ms<=", {isDiceModifier: true});

Renderer.dice.AbstractSymbol = class {
	constructor () { this.type = Renderer.dice.tk.TYP_SYMBOL; }
	eq (symbol) { return symbol && this.type === symbol.type; }
	evl (meta) { this.meta = meta; return this._evl(meta); }
	avg (meta) { this.meta = meta; return this._avg(meta); }
	min (meta) { this.meta = meta; return this._min(meta); } 	max (meta) { this.meta = meta; return this._max(meta); } 	_evl () { throw new Error("Unimplemented!"); }
	_avg () { throw new Error("Unimplemented!"); }
	_min () { throw new Error("Unimplemented!"); } 	_max () { throw new Error("Unimplemented!"); } 	toString () { throw new Error("Unimplemented!"); }
	addToMeta (meta, {text, html = null, md = null} = {}) {
		if (!meta) return;
		html = html || text;
		md = md || text;
		(meta.html = meta.html || []).push(html);
		(meta.text = meta.text || []).push(text);
		(meta.md = meta.md || []).push(md);
	}
};

Renderer.dice.parsed = {
	_PARTITION_EQ: (r, compareTo) => r === compareTo,
	_PARTITION_GT: (r, compareTo) => r > compareTo,
	_PARTITION_GTEQ: (r, compareTo) => r >= compareTo,
	_PARTITION_LT: (r, compareTo) => r < compareTo,
	_PARTITION_LTEQ: (r, compareTo) => r <= compareTo,

		_handleModifiers (fnName, meta, vals, nodeMod, opts) {
		opts = opts || {};

		const displayVals = vals.slice(); 
		const {mods} = nodeMod;

		for (const mod of mods) {
			vals.sort(SortUtil.ascSortProp.bind(null, "val")).reverse();
			const valsAlive = vals.filter(it => !it.isDropped);

			const modNum = mod.numSym[fnName]();

			switch (mod.modSym.type) {
				case Renderer.dice.tk.DROP_HIGHEST.type:
				case Renderer.dice.tk.KEEP_HIGHEST.type:
				case Renderer.dice.tk.DROP_LOWEST.type:
				case Renderer.dice.tk.KEEP_LOWEST.type: {
					const isHighest = mod.modSym.type.endsWith("H");

					const splitPoint = isHighest ? modNum : valsAlive.length - modNum;

					const highSlice = valsAlive.slice(0, splitPoint);
					const lowSlice = valsAlive.slice(splitPoint, valsAlive.length);

					switch (mod.modSym.type) {
						case Renderer.dice.tk.DROP_HIGHEST.type:
						case Renderer.dice.tk.KEEP_LOWEST.type:
							highSlice.forEach(val => val.isDropped = true);
							break;
						case Renderer.dice.tk.KEEP_HIGHEST.type:
						case Renderer.dice.tk.DROP_LOWEST.type:
							lowSlice.forEach(val => val.isDropped = true);
							break;
						default: throw new Error(`Unimplemented!`);
					}
					break;
				}

				case Renderer.dice.tk.REROLL_EXACT.type:
				case Renderer.dice.tk.REROLL_GT.type:
				case Renderer.dice.tk.REROLL_GTEQ.type:
				case Renderer.dice.tk.REROLL_LT.type:
				case Renderer.dice.tk.REROLL_LTEQ.type: {
					let fnPartition;
					switch (mod.modSym.type) {
						case Renderer.dice.tk.REROLL_EXACT.type: fnPartition = Renderer.dice.parsed._PARTITION_EQ; break;
						case Renderer.dice.tk.REROLL_GT.type: fnPartition = Renderer.dice.parsed._PARTITION_GT; break;
						case Renderer.dice.tk.REROLL_GTEQ.type: fnPartition = Renderer.dice.parsed._PARTITION_GTEQ; break;
						case Renderer.dice.tk.REROLL_LT.type: fnPartition = Renderer.dice.parsed._PARTITION_LT; break;
						case Renderer.dice.tk.REROLL_LTEQ.type: fnPartition = Renderer.dice.parsed._PARTITION_LTEQ; break;
						default: throw new Error(`Unimplemented!`);
					}

					const toReroll = valsAlive.filter(val => fnPartition(val.val, modNum));
					toReroll.forEach(val => val.isDropped = true);

					const nuVals = opts.fnGetRerolls(toReroll);

					vals.push(...nuVals);
					displayVals.push(...nuVals);
					break;
				}

				case Renderer.dice.tk.EXPLODE_EXACT.type:
				case Renderer.dice.tk.EXPLODE_GT.type:
				case Renderer.dice.tk.EXPLODE_GTEQ.type:
				case Renderer.dice.tk.EXPLODE_LT.type:
				case Renderer.dice.tk.EXPLODE_LTEQ.type: {
					let fnPartition;
					switch (mod.modSym.type) {
						case Renderer.dice.tk.EXPLODE_EXACT.type: fnPartition = Renderer.dice.parsed._PARTITION_EQ; break;
						case Renderer.dice.tk.EXPLODE_GT.type: fnPartition = Renderer.dice.parsed._PARTITION_GT; break;
						case Renderer.dice.tk.EXPLODE_GTEQ.type: fnPartition = Renderer.dice.parsed._PARTITION_GTEQ; break;
						case Renderer.dice.tk.EXPLODE_LT.type: fnPartition = Renderer.dice.parsed._PARTITION_LT; break;
						case Renderer.dice.tk.EXPLODE_LTEQ.type: fnPartition = Renderer.dice.parsed._PARTITION_LTEQ; break;
						default: throw new Error(`Unimplemented!`);
					}

					let tries = 999; 					let lastLen;
					let toExplodeNext = valsAlive;
					do {
						lastLen = vals.length;

						const [toExplode] = toExplodeNext.partition(roll => !roll.isExploded && fnPartition(roll.val, modNum));
						toExplode.forEach(roll => roll.isExploded = true);

						const nuVals = opts.fnGetExplosions(toExplode);

												toExplodeNext = nuVals;

						vals.push(...nuVals);
						displayVals.push(...nuVals);
					} while (tries-- > 0 && vals.length !== lastLen);

					if (!~tries) JqueryUtil.doToast({type: "warning", content: `Stopped exploding after 999 additional rolls.`});

					break;
				}

				case Renderer.dice.tk.COUNT_SUCCESS_EXACT.type:
				case Renderer.dice.tk.COUNT_SUCCESS_GT.type:
				case Renderer.dice.tk.COUNT_SUCCESS_GTEQ.type:
				case Renderer.dice.tk.COUNT_SUCCESS_LT.type:
				case Renderer.dice.tk.COUNT_SUCCESS_LTEQ.type: {
					let fnPartition;
					switch (mod.modSym.type) {
						case Renderer.dice.tk.COUNT_SUCCESS_EXACT.type: fnPartition = Renderer.dice.parsed._PARTITION_EQ; break;
						case Renderer.dice.tk.COUNT_SUCCESS_GT.type: fnPartition = Renderer.dice.parsed._PARTITION_GT; break;
						case Renderer.dice.tk.COUNT_SUCCESS_GTEQ.type: fnPartition = Renderer.dice.parsed._PARTITION_GTEQ; break;
						case Renderer.dice.tk.COUNT_SUCCESS_LT.type: fnPartition = Renderer.dice.parsed._PARTITION_LT; break;
						case Renderer.dice.tk.COUNT_SUCCESS_LTEQ.type: fnPartition = Renderer.dice.parsed._PARTITION_LTEQ; break;
						default: throw new Error(`Unimplemented!`);
					}

					const successes = valsAlive.filter(val => fnPartition(val.val, modNum));
					successes.forEach(val => val.isSuccess = true);

					break;
				}

				case Renderer.dice.tk.MARGIN_SUCCESS_EXACT.type:
				case Renderer.dice.tk.MARGIN_SUCCESS_GT.type:
				case Renderer.dice.tk.MARGIN_SUCCESS_GTEQ.type:
				case Renderer.dice.tk.MARGIN_SUCCESS_LT.type:
				case Renderer.dice.tk.MARGIN_SUCCESS_LTEQ.type: {
					const total = valsAlive.map(it => it.val).reduce((valA, valB) => valA + valB, 0);

					const subDisplayDice = displayVals.map(r => `[${Renderer.dice.parsed._rollToNumPart_html(r, opts.faces)}]`).join("+");

					let delta;
					let subDisplay;
					switch (mod.modSym.type) {
						case Renderer.dice.tk.MARGIN_SUCCESS_EXACT.type:
						case Renderer.dice.tk.MARGIN_SUCCESS_GT.type:
						case Renderer.dice.tk.MARGIN_SUCCESS_GTEQ.type: {
							delta = total - modNum;

							subDisplay = `(${subDisplayDice})-${modNum}`;

							break;
						}
						case Renderer.dice.tk.MARGIN_SUCCESS_LT.type:
						case Renderer.dice.tk.MARGIN_SUCCESS_LTEQ.type: {
							delta = modNum - total;

							subDisplay = `${modNum}-(${subDisplayDice})`;

							break;
						}
						default: throw new Error(`Unimplemented!`);
					}

					while (vals.length) {
						vals.pop();
						displayVals.pop();
					}

					vals.push({val: delta});
					displayVals.push({val: delta, htmlDisplay: subDisplay});

					break;
				}

				default: throw new Error(`Unimplemented!`);
			}
		}

		return displayVals;
	},

	_rollToNumPart_html (r, faces) {
		if (faces == null) return r.val;
		return r.val === faces ? `<span class="rll__max--muted">${r.val}</span>` : r.val === 1 ? `<span class="rll__min--muted">${r.val}</span>` : r.val;
	},

	Function: class extends Renderer.dice.AbstractSymbol {
		constructor (nodes) {
			super();
			this._nodes = nodes;
		}

		_evl (meta) { return this._invoke("evl", meta); }
		_avg (meta) { return this._invoke("avg", meta); }
		_min (meta) { return this._invoke("min", meta); }
		_max (meta) { return this._invoke("max", meta); }

		_invoke (fnName, meta) {
			const [symFunc] = this._nodes;
			switch (symFunc.type) {
				case Renderer.dice.tk.FLOOR.type:
				case Renderer.dice.tk.CEIL.type:
				case Renderer.dice.tk.ROUND.type:
				case Renderer.dice.tk.SIGN.type:
				case Renderer.dice.tk.CBRT.type:
				case Renderer.dice.tk.SQRT.type:
				case Renderer.dice.tk.EXP.type:
				case Renderer.dice.tk.LOG.type:
				case Renderer.dice.tk.RANDOM.type:
				case Renderer.dice.tk.TRUNC.type:
				case Renderer.dice.tk.POW.type:
				case Renderer.dice.tk.MAX.type:
				case Renderer.dice.tk.MIN.type: {
					const [, ...symExps] = this._nodes;
					this.addToMeta(meta, {text: `${symFunc.toString()}(`});
					const args = [];
					symExps.forEach((symExp, i) => {
						if (i !== 0) this.addToMeta(meta, {text: `, `});
						args.push(symExp[fnName](meta));
					});
					const out = Math[symFunc.toString()](...args);
					this.addToMeta(meta, {text: ")"});
					return out;
				}
				case Renderer.dice.tk.AVERAGE.type: {
					const [, symExp] = this._nodes;
					return symExp.avg(meta);
				}
				case Renderer.dice.tk.DMAX.type: {
					const [, symExp] = this._nodes;
					return symExp.max(meta);
				}
				case Renderer.dice.tk.DMIN.type: {
					const [, symExp] = this._nodes;
					return symExp.min(meta);
				}
				default: throw new Error(`Unimplemented!`);
			}
		}

		toString () {
			let out;
			const [symFunc, symExp] = this._nodes;
			switch (symFunc.type) {
				case Renderer.dice.tk.FLOOR.type:
				case Renderer.dice.tk.CEIL.type:
				case Renderer.dice.tk.ROUND.type:
				case Renderer.dice.tk.AVERAGE.type:
				case Renderer.dice.tk.DMAX.type:
				case Renderer.dice.tk.DMIN.type:
				case Renderer.dice.tk.SIGN.type:
				case Renderer.dice.tk.ABS.type:
				case Renderer.dice.tk.CBRT.type:
				case Renderer.dice.tk.SQRT.type:
				case Renderer.dice.tk.EXP.type:
				case Renderer.dice.tk.LOG.type:
				case Renderer.dice.tk.RANDOM.type:
				case Renderer.dice.tk.TRUNC.type:
				case Renderer.dice.tk.POW.type:
				case Renderer.dice.tk.MAX.type:
				case Renderer.dice.tk.MIN.type:
					out = symFunc.toString(); break;
				default: throw new Error(`Unimplemented!`);
			}
			out += `(${symExp.toString()})`;
			return out;
		}
	},

	Pool: class extends Renderer.dice.AbstractSymbol {
		constructor (nodesPool, nodeMod) {
			super();
			this._nodesPool = nodesPool;
			this._nodeMod = nodeMod;
		}

		_evl (meta) { return this._invoke("evl", meta); }
		_avg (meta) { return this._invoke("avg", meta); }
		_min (meta) { return this._invoke("min", meta); }
		_max (meta) { return this._invoke("max", meta); }

		_invoke (fnName, meta) {
			const vals = this._nodesPool.map(it => {
				const subMeta = {};
				return {node: it, val: it[fnName](subMeta), meta: subMeta};
			});

			if (this._nodeMod && vals.length) {
				const isSuccessMode = this._nodeMod.isSuccessMode;

				const modOpts = {
					fnGetRerolls: toReroll => toReroll.map(val => {
						const subMeta = {};
						return {node: val.node, val: val.node[fnName](subMeta), meta: subMeta};
					}),
					fnGetExplosions: toExplode => toExplode.map(val => {
						const subMeta = {};
						return {node: val.node, val: val.node[fnName](subMeta), meta: subMeta};
					}),
				};

				const displayVals = Renderer.dice.parsed._handleModifiers(fnName, meta, vals, this._nodeMod, modOpts);

				const asHtml = displayVals.map(v => {
					const html = v.meta.html.join("");
					if (v.isDropped) return `<span class="rll__dropped">(${html})</span>`;
					else if (v.isExploded) return `<span class="rll__exploded">(</span>${html}<span class="rll__exploded">)</span>`;
					else if (v.isSuccess) return `<span class="rll__success">(${html})</span>`;
					else return `(${html})`;
				}).join("+");

				const asText = displayVals.map(v => `(${v.meta.text.join("")})`).join("+");
				const asMd = displayVals.map(v => `(${v.meta.md.join("")})`).join("+");

				this.addToMeta(meta, {html: asHtml, text: asText, md: asMd});

				if (isSuccessMode) {
					return vals.filter(it => !it.isDropped && it.isSuccess).length;
				} else {
					return vals.filter(it => !it.isDropped).map(it => it.val).sum();
				}
			} else {
				this.addToMeta(
					meta,
					["html", "text", "md"].mergeMap(prop => ({
						[prop]: `${vals.map(it => `(${it.meta[prop].join("")})`).join("+")}`,
					})),
				);
				return vals.map(it => it.val).sum();
			}
		}

		toString () {
			return `{${this._nodesPool.map(it => it.toString()).join(", ")}}${this._nodeMod ? this._nodeMod.toString() : ""}`;
		}
	},

	Factor: class extends Renderer.dice.AbstractSymbol {
		constructor (node, opts) {
			super();
			opts = opts || {};
			this._node = node;
			this._hasParens = !!opts.hasParens;
		}

		_evl (meta) { return this._invoke("evl", meta); }
		_avg (meta) { return this._invoke("avg", meta); }
		_min (meta) { return this._invoke("min", meta); }
		_max (meta) { return this._invoke("max", meta); }

		_invoke (fnName, meta) {
			switch (this._node.type) {
				case Renderer.dice.tk.TYP_NUMBER: {
					this.addToMeta(meta, {text: this.toString()});
					return Number(this._node.value);
				}
				case Renderer.dice.tk.TYP_SYMBOL: {
					if (this._hasParens) this.addToMeta(meta, {text: "("});
					const out = this._node[fnName](meta);
					if (this._hasParens) this.addToMeta(meta, {text: ")"});
					return out;
				}
				case Renderer.dice.tk.PB.type: {
					this.addToMeta(meta, {text: this.toString(meta)});
					return meta.pb == null ? 0 : meta.pb;
				}
				case Renderer.dice.tk.SUMMON_SPELL_LEVEL.type: {
					this.addToMeta(meta, {text: this.toString(meta)});
					return meta.summonSpellLevel == null ? 0 : meta.summonSpellLevel;
				}
				case Renderer.dice.tk.SUMMON_CLASS_LEVEL.type: {
					this.addToMeta(meta, {text: this.toString(meta)});
					return meta.summonClassLevel == null ? 0 : meta.summonClassLevel;
				}
				default: throw new Error(`Unimplemented!`);
			}
		}

		toString (indent) {
			let out;
			switch (this._node.type) {
				case Renderer.dice.tk.TYP_NUMBER: out = this._node.value; break;
				case Renderer.dice.tk.TYP_SYMBOL: out = this._node.toString(); break;
				case Renderer.dice.tk.PB.type: out = this.meta ? (this.meta.pb || 0) : "PB"; break;
				case Renderer.dice.tk.SUMMON_SPELL_LEVEL.type: out = this.meta ? (this.meta.summonSpellLevel || 0) : "the spell's level"; break;
				case Renderer.dice.tk.SUMMON_CLASS_LEVEL.type: out = this.meta ? (this.meta.summonClassLevel || 0) : "your class level"; break;
				default: throw new Error(`Unimplemented!`);
			}
			return this._hasParens ? `(${out})` : out;
		}
	},

	Dice: class extends Renderer.dice.AbstractSymbol {
		static _facesToValue (faces, fnName) {
			switch (fnName) {
				case "evl": return RollerUtil.randomise(faces);
				case "avg": return (faces + 1) / 2;
				case "min": return 1;
				case "max": return faces;
			}
		}

		constructor (nodes) {
			super();
			this._nodes = nodes;
		}

		_evl (meta) { return this._invoke("evl", meta); }
		_avg (meta) { return this._invoke("avg", meta); }
		_min (meta) { return this._invoke("min", meta); }
		_max (meta) { return this._invoke("max", meta); }

		_invoke (fnName, meta) {
			if (this._nodes.length === 1) return this._nodes[0][fnName](meta); 
						
			const view = this._nodes.slice();
									const numSym = view.shift();
			let tmp = numSym[fnName](Renderer.dice.util.getReducedMeta(meta));

			while (view.length) {
				if (Math.round(tmp) !== tmp) throw new Error(`Number of dice to roll (${tmp}) was not an integer!`);

																								const facesSym = view.shift();
				const faces = facesSym[fnName]();
				if (Math.round(faces) !== faces) throw new Error(`Dice face count (${faces}) was not an integer!`);

				const isLast = view.length === 0 || (view.length === 1 && view.last().isDiceModifierGroup);
				tmp = this._invoke_handlePart(fnName, meta, view, tmp, faces, isLast);
			}

			return tmp;
		}

		_invoke_handlePart (fnName, meta, view, num, faces, isLast) {
			const rolls = [...new Array(num)].map(() => ({val: Renderer.dice.parsed.Dice._facesToValue(faces, fnName)}));
			let displayRolls;
			let isSuccessMode = false;

			if (view.length && view[0].isDiceModifierGroup) {
				const nodeMod = view[0];

				if (fnName === "evl" || fnName === "min" || fnName === "max") { 					isSuccessMode = nodeMod.isSuccessMode;

					const modOpts = {
						faces,
						fnGetRerolls: toReroll => [...new Array(toReroll.length)].map(() => ({val: Renderer.dice.parsed.Dice._facesToValue(faces, fnName)})),
						fnGetExplosions: toExplode => [...new Array(toExplode.length)].map(() => ({val: Renderer.dice.parsed.Dice._facesToValue(faces, fnName)})),
					};

					displayRolls = Renderer.dice.parsed._handleModifiers(fnName, meta, rolls, nodeMod, modOpts);
				}

				view.shift();
			} else displayRolls = rolls;

			if (isLast) { 				const asHtml = displayRolls.map(r => {
					if (r.htmlDisplay) return r.htmlDisplay;

					const numPart = Renderer.dice.parsed._rollToNumPart_html(r, faces);

					if (r.isDropped) return `<span class="rll__dropped">[${numPart}]</span>`;
					else if (r.isExploded) return `<span class="rll__exploded">[</span>${numPart}<span class="rll__exploded">]</span>`;
					else if (r.isSuccess) return `<span class="rll__success">[${numPart}]</span>`;
					else return `[${numPart}]`;
				}).join("+");

				const asText = displayRolls.map(r => `[${r.val}]`).join("+");

				const asMd = displayRolls.map(r => {
					if (r.isDropped) return `~~[${r.val}]~~`;
					else if (r.isExploded) return `_[${r.val}]_`;
					else if (r.isSuccess) return `**[${r.val}]**`;
					else return `[${r.val}]`;
				}).join("+");

				this.addToMeta(
					meta,
					{
						html: asHtml,
						text: asText,
						md: asMd,
					},
				);
			}

			if (fnName === "evl") {
				const maxRolls = rolls.filter(it => it.val === faces && !it.isDropped);
				const minRolls = rolls.filter(it => it.val === 1 && !it.isDropped);
				meta.allMax = meta.allMax || [];
				meta.allMin = meta.allMin || [];
				meta.allMax.push(maxRolls.length && maxRolls.length === rolls.length);
				meta.allMin.push(minRolls.length && minRolls.length === rolls.length);
			}

			if (isSuccessMode) {
				return rolls.filter(it => !it.isDropped && it.isSuccess).length;
			} else {
				return rolls.filter(it => !it.isDropped).map(it => it.val).sum();
			}
		}

		toString () {
			if (this._nodes.length === 1) return this._nodes[0].toString(); 
			const [numSym, facesSym] = this._nodes;
			let out = `${numSym.toString()}d${facesSym.toString()}`;

			for (let i = 2; i < this._nodes.length; ++i) {
				const n = this._nodes[i];
				if (n.isDiceModifierGroup) out += n.mods.map(it => `${it.modSym.toString()}${it.numSym.toString()}`).join("");
				else out += `d${n.toString()}`;
			}

			return out;
		}
	},

	Exponent: class extends Renderer.dice.AbstractSymbol {
		constructor (nodes) {
			super();
			this._nodes = nodes;
		}

		_evl (meta) { return this._invoke("evl", meta); }
		_avg (meta) { return this._invoke("avg", meta); }
		_min (meta) { return this._invoke("min", meta); }
		_max (meta) { return this._invoke("max", meta); }

		_invoke (fnName, meta) {
			const view = this._nodes.slice();
			let val = view.pop()[fnName](meta);
			while (view.length) {
				this.addToMeta(meta, {text: "^"});
				val = view.pop()[fnName](meta) ** val;
			}
			return val;
		}

		toString () {
			const view = this._nodes.slice();
			let out = view.pop().toString();
			while (view.length) out = `${view.pop().toString()}^${out}`;
			return out;
		}
	},

	Term: class extends Renderer.dice.AbstractSymbol {
		constructor (nodes) {
			super();
			this._nodes = nodes;
		}

		_evl (meta) { return this._invoke("evl", meta); }
		_avg (meta) { return this._invoke("avg", meta); }
		_min (meta) { return this._invoke("min", meta); }
		_max (meta) { return this._invoke("max", meta); }

		_invoke (fnName, meta) {
			let out = this._nodes[0][fnName](meta);

			for (let i = 1; i < this._nodes.length; i += 2) {
				if (this._nodes[i].eq(Renderer.dice.tk.MULT)) {
					this.addToMeta(meta, {text: " × "});
					out *= this._nodes[i + 1][fnName](meta);
				} else if (this._nodes[i].eq(Renderer.dice.tk.DIV)) {
					this.addToMeta(meta, {text: " ÷ "});
					out /= this._nodes[i + 1][fnName](meta);
				} else throw new Error(`Unimplemented!`);
			}

			return out;
		}

		toString () {
			let out = this._nodes[0].toString();
			for (let i = 1; i < this._nodes.length; i += 2) {
				if (this._nodes[i].eq(Renderer.dice.tk.MULT)) out += ` * ${this._nodes[i + 1].toString()}`;
				else if (this._nodes[i].eq(Renderer.dice.tk.DIV)) out += ` / ${this._nodes[i + 1].toString()}`;
				else throw new Error(`Unimplemented!`);
			}
			return out;
		}
	},

	Expression: class extends Renderer.dice.AbstractSymbol {
		constructor (nodes) {
			super();
			this._nodes = nodes;
		}

		_evl (meta) { return this._invoke("evl", meta); }
		_avg (meta) { return this._invoke("avg", meta); }
		_min (meta) { return this._invoke("min", meta); }
		_max (meta) { return this._invoke("max", meta); }

		_invoke (fnName, meta) {
			const view = this._nodes.slice();

			let isNeg = false;
			if (view[0].eq(Renderer.dice.tk.ADD) || view[0].eq(Renderer.dice.tk.SUB)) {
				isNeg = view.shift().eq(Renderer.dice.tk.SUB);
				if (isNeg) this.addToMeta(meta, {text: "-"});
			}

			let out = view[0][fnName](meta);
			if (isNeg) out = -out;

			for (let i = 1; i < view.length; i += 2) {
				if (view[i].eq(Renderer.dice.tk.ADD)) {
					this.addToMeta(meta, {text: " + "});
					out += view[i + 1][fnName](meta);
				} else if (view[i].eq(Renderer.dice.tk.SUB)) {
					this.addToMeta(meta, {text: " - "});
					out -= view[i + 1][fnName](meta);
				} else throw new Error(`Unimplemented!`);
			}

			return out;
		}

		toString (indent = 0) {
			let out = "";
			const view = this._nodes.slice();

			let isNeg = false;
			if (view[0].eq(Renderer.dice.tk.ADD) || view[0].eq(Renderer.dice.tk.SUB)) {
				isNeg = view.shift().eq(Renderer.dice.tk.SUB);
				if (isNeg) out += "-";
			}

			out += view[0].toString(indent);
			for (let i = 1; i < view.length; i += 2) {
				if (view[i].eq(Renderer.dice.tk.ADD)) out += ` + ${view[i + 1].toString(indent)}`;
				else if (view[i].eq(Renderer.dice.tk.SUB)) out += ` - ${view[i + 1].toString(indent)}`;
				else throw new Error(`Unimplemented!`);
			}
			return out;
		}
	},
};

if (!IS_VTT && typeof window !== "undefined") {
	window.addEventListener("load", Renderer.dice._pInit);
}

"use strict";

let RendererMarkdown$1 = class RendererMarkdown {
	static async pInit () {
		const settings = await StorageUtil.pGet("bookViewSettingsMarkdown") || Object.entries(RendererMarkdown$1._CONFIG).mergeMap(([k, v]) => ({[k]: v.default}));
		Object.assign(RendererMarkdown$1, settings);
		RendererMarkdown$1._isInit = true;
	}

	static checkInit () {
		if (!RendererMarkdown$1._isInit) throw new Error(`RendererMarkdown has not been initialised!`);
	}

	getLineBreak () { return "\n"; }

	constructor () {
				const renderer = new Renderer();
		this.__super = {};
		for (const k in renderer) {
			if (this[k] === undefined) {
				if (typeof renderer[k] === "function") this[k] = renderer[k].bind(this);
				else this[k] = MiscUtil.copy(renderer[k]);
			} else {
				if (typeof renderer[k] === "function") this.__super[k] = renderer[k].bind(this);
				else this.__super[k] = MiscUtil.copy(renderer[k]);
			}
		}

		this._isSkipStylingItemLinks = false;
	}

	set isSkipStylingItemLinks (val) { this._isSkipStylingItemLinks = val; }

	static get () {
		RendererMarkdown$1.checkInit();

		return new RendererMarkdown$1().setFnPostProcess(RendererMarkdown$1._fnPostProcess);
	}

	static _fnPostProcess (str) {
		return str
			.trim()
			.replace(/\n\n+/g, "\n\n")
			.replace(/(>\n>\n)+/g, ">\n");
	}

	static _getNextPrefix (options, prefix) {
		return options.prefix === ">" || options.prefix === ">>" ? `${options.prefix}${prefix || ""}` : prefix || "";
	}

		
	_renderEntriesSubtypes (entry, textStack, meta, options, incDepth) {
		const isInlineTitle = meta.depth >= 2;
		const nextDepth = incDepth && meta.depth < 2 ? meta.depth + 1 : meta.depth;

		const nxtPrefix = RendererMarkdown$1._getNextPrefix(options);
		if (entry.name) {
			if (isInlineTitle) {
				textStack[0] += `${nxtPrefix}***${Renderer.stripTags(entry.name)}.*** `;
			} else {
				const hashCount = meta._typeStack.length === 1 && meta.depth === -1 ? 1 : Math.min(6, meta.depth + 3);
				textStack[0] += `\n${nxtPrefix}${"#".repeat(hashCount)} ${Renderer.stripTags(entry.name)}\n\n`;
			}
		}

		if (entry.entries) {
			this._renderEntriesSubtypes_renderPreReqText(entry, textStack, meta);
			const cacheDepth = meta.depth;
			const len = entry.entries.length;
			for (let i = 0; i < len; ++i) {
				meta.depth = nextDepth;
				const isFirstInline = i === 0 && entry.name && isInlineTitle;
				const suffix = meta.isStatblockInlineMonster ? `  \n` : `\n\n`;
				this._recursiveRender(entry.entries[i], textStack, meta, {prefix: isFirstInline ? "" : RendererMarkdown$1._getNextPrefix(options), suffix});
			}
			if (meta.isStatblockInlineMonster) textStack[0] += "\n";
			meta.depth = cacheDepth;
		}
	}

	_renderEntriesSubtypes_renderPreReqText (entry, textStack, meta) {
		if (entry.prerequisite) {
			textStack[0] += `*Prerequisite: `;
			this._recursiveRender({type: "inline", entries: [entry.prerequisite]}, textStack, meta);
			textStack[0] += `*\n\n`;
		}
	}

	
	_renderList (entry, textStack, meta, options) {
		if (!entry.items) return;

		if (textStack[0] && textStack[0].slice(-1) !== "\n") textStack[0] += "\n";

		const listDepth = Math.max(meta._typeStack.filter(it => it === "list").length - 1, 0);

		if (entry.name) textStack[0] += `##### ${entry.name}`;
		const indentSpaces = "  ".repeat(listDepth);
		const len = entry.items.length;

				if (entry.data && entry.data.isSpellList) {
			textStack[0] += `${RendererMarkdown$1._getNextPrefix(options)}\n`;
			for (let i = 0; i < len; ++i) {
				textStack[0] += `${RendererMarkdown$1._getNextPrefix(options)}${indentSpaces}`;
				const cacheDepth = this._adjustDepth(meta, 1);
				this._recursiveRender(entry.items[i], textStack, meta, {suffix: "\n"});
				meta.depth = cacheDepth;
			}
		} else {
			for (let i = 0; i < len; ++i) {
				const item = entry.items[i];
								textStack[0] += `${RendererMarkdown$1._getNextPrefix(options)}${indentSpaces}${item.type === "list" ? "" : `- `}`;

				const cacheDepth = this._adjustDepth(meta, 1);
				this._recursiveRender(entry.items[i], textStack, meta, {suffix: "\n"});
				if (textStack[0].slice(-2) === "\n\n") textStack[0] = textStack[0].slice(0, -1);
				meta.depth = cacheDepth;
			}
		}

		textStack[0] += "\n";
	}

	_renderTable (entry, textStack, meta, options) {
		if (entry.intro) for (const ent of entry.intro) this._recursiveRender(ent, textStack, meta);

		textStack[0] += "\n";

		if (entry.caption) textStack[0] += `##### ${entry.caption}\n`;

		const headerRowMetas = Renderer.table.getHeaderRowMetas(entry);

		const hasLabels = headerRowMetas != null;
				if (!hasLabels && (!entry.rows || !entry.rows.length)) {
			textStack[0] += `|   |\n`;
			textStack[0] += `|---|\n`;
			textStack[0] += `|   |\n`;
			return;
		}

				let labelRows = MiscUtil.copyFast(headerRowMetas || []);
		if (!hasLabels) {
			const numCells = Math.max(...entry.rows.map(r => r.length));
			labelRows = [
				[...new Array(numCells)].map(() => ""),
			];
		}

				if (entry.colStyles) {
			labelRows
				.filter(labelRow => labelRow.length < entry.colStyles.length)
				.forEach(labelRow => {
					labelRow.push(
						...[...new Array(entry.colStyles.length - labelRow.length)].map(() => ""),
					);
				});
		}

				let styles = null;
		if (entry.colStyles) {
			styles = [...entry.colStyles];
						labelRows
				.forEach(labelRow => {
					if (labelRow.length > styles.length) {
						styles = styles.concat([...new Array(labelRow.length - styles.length)].map(() => ""));
					}
				});
		}
		
		const mdHeaderRows = labelRows.map(labelRow => labelRow.map(label => ` ${Renderer.stripTags(label)} `));

				const widths = [
			...new Array(
				Math.max(...mdHeaderRows.map(mdHeaderRow => mdHeaderRow.length)),
			),
		]
			.map((_, i) => Math.max(...mdHeaderRows.map(mdHeaderRow => (mdHeaderRow[i] || "").length)));

				const mdTable = [];

		const numRows = entry.rows.length;
		for (let ixRow = 0; ixRow < numRows; ++ixRow) {
			const row = entry.rows[ixRow];

			const rowRender = row.type === "row" ? row.row : row;

			const numCells = rowRender.length;
			for (let ixCell = 0; ixCell < numCells; ++ixCell) {
				const cell = rowRender[ixCell];

				let toRenderCell;

				if (cell.type === "cell") {
					if (cell.roll) {
						if (cell.roll.entry) toRenderCell = cell.roll.entry;
						else if (cell.roll.exact != null) toRenderCell = cell.roll.pad ? StrUtil.padNumber(cell.roll.exact, 2, "0") : cell.roll.exact;
						else {
							toRenderCell = cell.roll.pad
								? `${StrUtil.padNumber(cell.roll.min, 2, "0")}-${StrUtil.padNumber(cell.roll.max, 2, "0")}`
								: `${cell.roll.min}-${cell.roll.max}`;
						}
					} else if (cell.entry) {
						toRenderCell = cell.entry;
					}
				} else {
					toRenderCell = cell;
				}

				const textStackCell = [""];
				const cacheDepth = this._adjustDepth(meta, 1);
				this._recursiveRender(toRenderCell, textStackCell, meta);
				meta.depth = cacheDepth;

				const mdCell = ` ${textStackCell.join("").trim()} `
										.split(/\n+/)
					.join("<br>");

				widths[ixCell] = Math.max(widths[ixCell] || 0, mdCell.length);
				(mdTable[ixRow] = mdTable[ixRow] || [])[ixCell] = mdCell;
			}
		}
		
		const mdHeaderRowsPadded = mdHeaderRows
			.map(mdHeaderRow => {
				return mdHeaderRow
					.map((header, ixCell) => RendererMarkdown$1._md_getPaddedTableText({text: header, width: widths[ixCell], ixCell, styles}));
			});

				const mdStyles = [];
		if (styles) {
			styles.forEach((style, i) => {
				const w = widths[i];

				if (style.includes("text-center")) mdStyles.push(`:${"-".repeat(Math.max(w - 2, 3))}:`);
				else if (style.includes("text-right")) mdStyles.push(`${"-".repeat(Math.max(w - 1, 3))}:`);
				else mdStyles.push("-".repeat(Math.max(w, 3)));
			});
		}
		
				for (const mdHeaderRowPadded of mdHeaderRowsPadded) {
			textStack[0] += `|${mdHeaderRowPadded.join("|")}|\n`;
		}
		if (mdStyles.length) textStack[0] += `|${mdStyles.join("|")}|\n`;
		for (const mdRow of mdTable) {
			textStack[0] += "|";

			const numCells = mdRow.length;
			for (let ixCell = 0; ixCell < numCells; ++ixCell) {
				textStack[0] += RendererMarkdown$1._md_getPaddedTableText({text: mdRow[ixCell], width: widths[ixCell], ixCell, styles});
				textStack[0] += "|";
			}

			textStack[0] += "\n";
		}
		
		if (entry.footnotes) {
			for (const ent of entry.footnotes) {
				const cacheDepth = this._adjustDepth(meta, 1);
				this._recursiveRender(ent, textStack, meta);
				meta.depth = cacheDepth;
			}
		}
		if (entry.outro) for (const ent of entry.outro) this._recursiveRender(ent, textStack, meta);

		if (!entry.rows) {
			textStack[0] += `||\n`;
			return;
		}

		textStack[0] += "\n";
	}

	static _md_getPaddedTableText ({text, width, ixCell, styles}) {
		if (text.length >= width) return text;

		if (styles?.[ixCell]?.includes("text-center")) return text.padStart(Math.floor((width - text.length) / 2) + text.length, " ").padEnd(width, " ");
		if (styles?.[ixCell]?.includes("text-right")) return text.padStart(width, " ");
		return text.padEnd(width, " ");
	}

	
	_renderInset (entry, textStack, meta, options) {
		textStack[0] += "\n";
		if (entry.name != null) textStack[0] += `> ##### ${entry.name}\n>\n`;
		if (entry.entries) {
			const len = entry.entries.length;
			for (let i = 0; i < len; ++i) {
				const cacheDepth = meta.depth;
				meta.depth = 2;
				this._recursiveRender(entry.entries[i], textStack, meta, {prefix: ">", suffix: "\n>\n"});
				meta.depth = cacheDepth;
			}
		}
		textStack[0] += `\n`;
	}

	_renderInsetReadaloud (entry, textStack, meta, options) {
		textStack[0] += "\n";
		if (entry.name != null) textStack[0] += `>> ##### ${entry.name}\n>>\n`;
		if (entry.entries) {
			const len = entry.entries.length;
			for (let i = 0; i < len; ++i) {
				const cacheDepth = meta.depth;
				meta.depth = 2;
				this._recursiveRender(entry.entries[i], textStack, meta, {prefix: ">>", suffix: "\n>>\n"});
				meta.depth = cacheDepth;
			}
		}
		textStack[0] += `\n`;
	}

	_renderVariant (entry, textStack, meta, options) {
		textStack[0] += "\n";
		if (entry.name != null) textStack[0] += `> ##### Variant: ${entry.name}\n>\n`;
		if (entry.entries) {
			const len = entry.entries.length;
			for (let i = 0; i < len; ++i) {
				const cacheDepth = meta.depth;
				meta.depth = 2;
				this._recursiveRender(entry.entries[i], textStack, meta, {prefix: ">", suffix: "\n>\n"});
				meta.depth = cacheDepth;
			}
		}
		if (entry.source) textStack[0] += `>${RendererMarkdown$1.utils.getPageText({source: entry.source, page: entry.page})}\n`;
		textStack[0] += "\n";
	}

	_renderVariantSub (entry, textStack, meta, options) {
		if (entry.name) textStack[0] += `*${entry.name}.* `;

		if (entry.entries) {
			const len = entry.entries.length;
			for (let i = 0; i < len; ++i) {
				this._recursiveRender(entry.entries[i], textStack, meta, {prefix: RendererMarkdown$1._getNextPrefix(options), suffix: "\n>\n"});
			}
		}
	}

	_renderSpellcasting (entry, textStack, meta, options) {
		const toRender = this._renderSpellcasting_getEntries(entry);
		this._recursiveRender({type: "entries", entries: toRender}, textStack, meta, {prefix: RendererMarkdown$1._getNextPrefix(options), suffix: "\n"});
	}

	_renderQuote (entry, textStack, meta, options) {
		const len = entry.entries.length;
		for (let i = 0; i < len; ++i) {
			this._recursiveRender(entry.entries[i], textStack, meta, {prefix: RendererMarkdown$1._getNextPrefix(options, "*"), suffix: "*"});
			if (i !== entry.entries.length - 1) textStack[0] += `\n\n`;
		}
		const byArr = this._renderQuote_getBy(entry);
		if (byArr) {
			const tempStack = [""];
			for (let i = 0, len = byArr.length; i < len; ++i) {
				const by = byArr[i];
				this._recursiveRender(by, tempStack, meta);
				if (i < len - 1) tempStack[0] += "\n";
			}
			textStack[0] += `\u2014 ${tempStack.join("")}${entry.from ? `, *${entry.from}*` : ""}`;
		}
	}

	
		_renderAbilityDc (entry, textStack, meta, options) {
		this._renderPrefix(entry, textStack, meta, options);
		textStack[0] += `**${entry.name} save DC** = 8 + your proficiency bonus + your ${Parser.attrChooseToFull(entry.attributes)}`;
		this._renderSuffix(entry, textStack, meta, options);
	}

	_renderAbilityAttackMod (entry, textStack, meta, options) {
		this._renderPrefix(entry, textStack, meta, options);
		textStack[0] += `**${entry.name} attack modifier** = your proficiency bonus + your ${Parser.attrChooseToFull(entry.attributes)}`;
		this._renderSuffix(entry, textStack, meta, options);
	}

	_renderAbilityGeneric (entry, textStack, meta, options) {
		this._renderPrefix(entry, textStack, meta, options);
		textStack[0] += `${entry.name ? `**${entry.name}**  = ` : ""}${entry.text}${entry.attributes ? ` ${Parser.attrChooseToFull(entry.attributes)}` : ""}`;
		this._renderSuffix(entry, textStack, meta, options);
	}
	
	
	_renderDice (entry, textStack, meta, options) {
		textStack[0] += Renderer.getEntryDiceDisplayText(entry, entry.name);
	}

	_renderLink (entry, textStack, meta, options) {
		const href = this._renderLink_getHref(entry);
		textStack[0] += `[${href}](${this.render(entry.text)})`;
	}

			_renderItem (entry, textStack, meta, options) {
		this._renderPrefix(entry, textStack, meta, options);
		textStack[0] += `**${this.render(entry.name)}** `;
		let addedNewline = false;
		if (entry.entry) this._recursiveRender(entry.entry, textStack, meta);
		else if (entry.entries) {
			const len = entry.entries.length;
			for (let i = 0; i < len; ++i) {
				const nxtPrefix = RendererMarkdown$1._getNextPrefix(options, i > 0 ? "  " : "");
				this._recursiveRender(entry.entries[i], textStack, meta, {prefix: nxtPrefix, suffix: "\n"});
			}
			addedNewline = true;
		}
		if (!addedNewline) textStack[0] += "\n";
		this._renderSuffix(entry, textStack, meta, options);
	}

	_renderItemSub (entry, textStack, meta, options) {
		this._renderPrefix(entry, textStack, meta, options);
		const nxtPrefix = RendererMarkdown$1._getNextPrefix(options, `*${this.render(entry.name)}* `);
		this._recursiveRender(entry.entry, textStack, meta, {prefix: nxtPrefix, suffix: "\n"});
		this._renderSuffix(entry, textStack, meta, options);
	}

	_renderItemSpell (entry, textStack, meta, options) {
		this._renderPrefix(entry, textStack, meta, options);
		this._recursiveRender(entry.entry, textStack, meta, {prefix: RendererMarkdown$1._getNextPrefix(options, `${entry.name} `), suffix: "  \n"});
		this._renderSuffix(entry, textStack, meta, options);
	}
	
			_renderStatblockInline (entry, textStack, meta, options) {
		const fnGetRenderCompact = RendererMarkdown$1.hover.getFnRenderCompact(entry.dataType);

		if (!fnGetRenderCompact) {
			this._renderPrefix(entry, textStack, meta, options);
			textStack[0] += `**Cannot render "${entry.type}"\u2014unknown type "${entry.dataType}"!**\n`;
			this._renderSuffix(entry, textStack, meta, options);
			return;
		}

		this._renderPrefix(entry, textStack, meta, options);
				textStack[0] += fnGetRenderCompact(entry.data, {...entry, meta});
		this._renderSuffix(entry, textStack, meta, options);
	}

		
		_renderImage (entry, textStack, meta, options) {
		this._renderPrefix(entry, textStack, meta, options);
		const href = this._renderImage_getUrl(entry);
		textStack[0] += `![${entry.title || ""}](${href})`;
		this._renderSuffix(entry, textStack, meta, options);
	}

	_renderGallery (entry, textStack, meta, options) {
		const len = entry.images.length;
		for (let i = 0; i < len; ++i) {
			const img = MiscUtil.copyFast(entry.images[i]);
			this._recursiveRender(img, textStack, meta);
		}
	}
	
		_renderFlowchart (entry, textStack, meta, options) {
		const len = entry.blocks.length;
		for (let i = 0; i < len; ++i) {
			this._recursiveRender(entry.blocks[i], textStack, meta, options);
		}
	}

	_renderFlowBlock (entry, textStack, meta, options) {
		textStack[0] += "\n";
		if (entry.name != null) textStack[0] += `> ##### ${entry.name}\n>\n`;
		if (entry.entries) {
			const len = entry.entries.length;
			for (let i = 0; i < len; ++i) {
				const cacheDepth = meta.depth;
				meta.depth = 2;
				this._recursiveRender(entry.entries[i], textStack, meta, {prefix: ">", suffix: "\n>\n"});
				meta.depth = cacheDepth;
			}
		}
		textStack[0] += `\n`;
	}
	
		_renderHomebrew (entry, textStack, meta, options) {
		if (entry.oldEntries) {
			let markerText;
			if (entry.movedTo) {
				markerText = "*Homebrew:* The following content has been moved:";
			} else if (entry.entries) {
				markerText = "*Homebrew:* The following content has been replaced:";
			} else {
				markerText = "*Homebrew:* The following content has been removed:";
			}

			textStack[0] += `##### ${markerText}\n`;
			this._recursiveRender({type: "entries", entries: entry.oldEntries}, textStack, meta, {suffix: "\n"});
		}

		if (entry.entries) {
			const len = entry.entries.length;
			if (entry.oldEntries) textStack[0] += `*The replacement is as follows:*\n`;
			for (let i = 0; i < len; ++i) this._recursiveRender(entry.entries[i], textStack, meta, {suffix: "\n"});
		} else if (entry.movedTo) {
			textStack[0] += `*This content has been moved to ${entry.movedTo}.*\n`;
		} else {
			textStack[0] += "*This content has been deleted.*\n";
		}
	}
	
		_renderCode (entry, textStack, meta, options) {
		textStack[0] += "\n```\n";
		textStack[0] += entry.preformatted;
		textStack[0] += "\n```\n";
	}

	_renderHr (entry, textStack, meta, options) {
		textStack[0] += `\n---\n`;
	}
	
		_renderString (entry, textStack, meta, options) {
		switch (RendererMarkdown$1._tagRenderMode || 0) {
						case 0: {
				this._renderString_renderMode0(entry, textStack, meta, options);
				break;
			}
						case 1: {
				textStack[0] += entry;
				break;
			}
						case 2: {
				textStack[0] += Renderer.stripTags(entry);
				break;
			}
		}
	}

	_renderString_renderMode0 (entry, textStack, meta, options) {
		const tagSplit = Renderer.splitByTags(entry);
		const len = tagSplit.length;
		for (let i = 0; i < len; ++i) {
			const s = tagSplit[i];
			if (!s) continue;
			if (s.startsWith("{@")) {
				const [tag, text] = Renderer.splitFirstSpace(s.slice(1, -1));
				this._renderString_renderTag(textStack, meta, options, tag, text);
			} else textStack[0] += s;
		}
	}

	_renderString_renderTag (textStack, meta, options, tag, text) {
		switch (tag) {
						case "@b":
			case "@bold":
				textStack[0] += `**`;
				this._recursiveRender(text, textStack, meta);
				textStack[0] += `**`;
				break;
			case "@i":
			case "@italic":
				textStack[0] += `*`;
				this._recursiveRender(text, textStack, meta);
				textStack[0] += `*`;
				break;
			case "@s":
			case "@strike":
				textStack[0] += `~~`;
				this._recursiveRender(text, textStack, meta);
				textStack[0] += `~~`;
				break;
			case "@atk": textStack[0] += `*${Renderer.attackTagToFull(text)}*`; break;
			case "@h": textStack[0] += `*Hit:* `; break;

						case "@dc": {
				const [dcText, displayText] = Renderer.splitTagByPipe(text);
				textStack[0] += `DC ${displayText || dcText}`;
				break;
			}

						case "@dice":
			case "@damage":
			case "@hit":
			case "@d20":
			case "@chance":
			case "@recharge":
			case "@coinflip":
				textStack[0] += Renderer.stripTags(`{${tag} ${text}}`); break;

						case "@scaledice":
			case "@scaledamage":
				textStack[0] += Renderer.stripTags(`{${tag} ${text}}`); break;

						case "@filter":
				textStack[0] += Renderer.stripTags(`{${tag} ${text}}`); break;

			case "@link":
			case "@5etools":
				this.__super._renderString_renderTag(textStack, meta, options, tag, text); break;

						case "@footnote":
			case "@homebrew":
			case "@skill":
			case "@sense":
			case "@area":
				textStack[0] += Renderer.stripTags(`{${tag} ${text}}`); break;

						case "@loader": {
								const {name, path} = this._renderString_getLoaderTagMeta(text, {isDefaultUrl: true});
				textStack[0] += `[${name}](${path})`;
				break;
			}

						case "@book":
			case "@adventure":
				textStack[0] += `*${Renderer.stripTags(`{${tag} ${text}}`)}*`; break;

			case "@deity":
				textStack[0] += `**${Renderer.stripTags(`{${tag} ${text}}`)}**`; break;

			default: {
				switch (tag) {
					case "@item": {
						if (this._isSkipStylingItemLinks) textStack[0] += `${Renderer.stripTags(`{${tag} ${text}}`)}`;
						else textStack[0] += `*${Renderer.stripTags(`{${tag} ${text}}`)}*`;
						break;
					}

					case "@spell":
					case "@psionic":
						textStack[0] += `*${Renderer.stripTags(`{${tag} ${text}}`)}*`; break;
					case "@creature":
						textStack[0] += `**${Renderer.stripTags(`{${tag} ${text}}`)}**`; break;
					default:
						textStack[0] += Renderer.stripTags(`{${tag} ${text}}`); break;
				}
			}
		}
	}

	_renderPrimitive (entry, textStack, meta, options) { textStack[0] += `${entry}`; }
	
		static async pShowSettingsModal () {
		RendererMarkdown$1.checkInit();

		const {$modalInner} = UiUtil.getShowModal({
			title: "Markdown Settings",
			cbClose: () => RendererMarkdown$1.__$wrpSettings.detach(),
		});
		if (!RendererMarkdown$1.__$wrpSettings) {
			const _compMarkdownSettings = BaseComponent.fromObject({
				_tagRenderMode: RendererMarkdown$1._tagRenderMode,
				_isAddColumnBreaks: RendererMarkdown$1._isAddColumnBreaks,
			});
			const compMarkdownSettings = _compMarkdownSettings.getPod();
			const saveMarkdownSettingsDebounced = MiscUtil.debounce(() => StorageUtil.pSet("bookViewSettingsMarkdown", _compMarkdownSettings.toObject()), 100);
			compMarkdownSettings.addHookAll(() => {
				Object.assign(RendererMarkdown$1, compMarkdownSettings.getState());
				saveMarkdownSettingsDebounced();
			});

			const $rows = Object.entries(RendererMarkdown$1._CONFIG)
				.map(([k, v]) => {
					let $ipt;
					switch (v.type) {
						case "boolean": {
							$ipt = ComponentUiUtil.$getCbBool(_compMarkdownSettings, k).addClass("mr-1");
							break;
						}
						case "enum": {
							$ipt = ComponentUiUtil.$getSelEnum(_compMarkdownSettings, k, {values: v.values, fnDisplay: v.fnDisplay});
							break;
						}
						default: throw new Error(`Unhandled input type!`);
					}

					return $$`<div class="m-1 stripe-even"><label class="split-v-center">
						<div class="w-100 mr-2">${v.name}</div>
						${$ipt.addClass("max-w-33")}
					</label></div>`;
				});

			RendererMarkdown$1.__$wrpSettings = $$`<div class="ve-flex-v-col w-100 h-100">${$rows}</div>`;
		}
		RendererMarkdown$1.__$wrpSettings.appendTo($modalInner);
	}
	
	static getSetting (key) { return this[`_${key}`]; }
};
RendererMarkdown$1._isInit = false;
RendererMarkdown$1.CHARS_PER_PAGE = 5500;
RendererMarkdown$1.__$wrpSettings = null;
RendererMarkdown$1._TAG_RENDER_MODES = ["Convert to Markdown", "Leave As-Is", "Convert to Text"];
RendererMarkdown$1._CONFIG = {
	_tagRenderMode: {default: 0, name: "Tag Handling (<code>@tag</code>)", fnDisplay: ix => RendererMarkdown$1._TAG_RENDER_MODES[ix], type: "enum", values: [0, 1, 2]},
	_isAddColumnBreaks: {default: false, name: "Add GM Binder Column Breaks (<code>\\columnbreak</code>)", type: "boolean"},
	_isAddPageBreaks: {default: false, name: "Add GM Binder Page Breaks (<code>\\pagebreak</code>)", type: "boolean"},
};

if (typeof window !== "undefined") window.addEventListener("load", () => RendererMarkdown$1.pInit());

RendererMarkdown$1.utils = class {
	static getPageText (it) {
		const sourceSub = Renderer.utils.getSourceSubText(it);
		const baseText = Renderer.utils.isDisplayPage(it.page) ? `**Source:** *${Parser.sourceJsonToAbv(it.source)}${sourceSub}*, page ${it.page}` : "";
		const addSourceText = this._getPageText_getAltSourceText(it, "additionalSources", "Additional information from");
		const otherSourceText = this._getPageText_getAltSourceText(it, "otherSources", "Also found in");
		const externalSourceText = this._getPageText_getAltSourceText(it, "externalSources", "External sources:");

		return `${[baseText, addSourceText, otherSourceText, externalSourceText].filter(it => it).join(". ")}${baseText && (addSourceText || otherSourceText || externalSourceText) ? "." : ""}`;
	}

	static _getPageText_getAltSourceText (it, prop, introText) {
		if (!it[prop] || !it[prop].length) return "";

		return `${introText} ${it[prop].map(as => {
			if (as.entry) return Renderer.get().render(as.entry);
			else return `*${Parser.sourceJsonToAbv(as.source)}*${Renderer.utils.isDisplayPage(as.page) ? `, page ${as.page}` : ""}`;
		}).join("; ")}`;
	}
};

RendererMarkdown$1.monster = class {
	static getCompactRenderedString (mon, opts = {}) {
		const legendaryGroup = opts.legendaryGroup;
		const meta = opts.meta || {};

		let addedStatblockInline;
		if (!meta.isStatblockInlineMonster) {
			meta.isStatblockInlineMonster = true;
			addedStatblockInline = true;
		}

		const monTypes = Parser.monTypeToFullObj(mon.type);
		RendererMarkdown$1.get().isSkipStylingItemLinks = true;
		const acPart = Parser.acToFull(mon.ac, RendererMarkdown$1.get());
		RendererMarkdown$1.get().isSkipStylingItemLinks = false;
		const resourcePart = mon.resource?.length
			? mon.resource
				.map(res => `\n>- **${res.name}** ${Renderer.monster.getRenderedResource(res, true)}`)
				.join("")
			: "";
		const savePart = mon.save ? `\n>- **Saving Throws** ${Object.keys(mon.save).sort(SortUtil.ascSortAtts).map(it => RendererMarkdown$1.monster.getSave(it, mon.save[it])).join(", ")}` : "";
		const skillPart = mon.skill ? `\n>- **Skills** ${RendererMarkdown$1.monster.getSkillsString(mon)}` : "";
		const damVulnPart = mon.vulnerable ? `\n>- **Damage Vulnerabilities** ${Parser.getFullImmRes(mon.vulnerable)}` : "";
		const damResPart = mon.resist ? `\n>- **Damage Resistances** ${Parser.getFullImmRes(mon.resist)}` : "";
		const damImmPart = mon.immune ? `\n>- **Damage Immunities** ${Parser.getFullImmRes(mon.immune)}` : "";
		const condImmPart = mon.conditionImmune ? `\n>- **Condition Immunities** ${Parser.getFullCondImm(mon.conditionImmune, true)}` : "";

		const fnGetSpellTraits = RendererMarkdown$1.monster.getSpellcastingRenderedTraits.bind(RendererMarkdown$1.monster, meta);
		const traitArray = Renderer.monster.getOrderedTraits(mon, {fnGetSpellTraits});
		const actionArray = Renderer.monster.getOrderedActions(mon, {fnGetSpellTraits});
		const bonusActionArray = Renderer.monster.getOrderedBonusActions(mon, {fnGetSpellTraits});
		const reactionArray = Renderer.monster.getOrderedReactions(mon, {fnGetSpellTraits});

		const traitsPart = traitArray?.length
			? `\n${RendererMarkdown$1.monster._getRenderedSection({prop: "trait", entries: traitArray, depth: 1, meta})}`
			: "";

		const actionsPart = actionArray?.length
			? `${RendererMarkdown$1.monster._getRenderedSectionHeader({mon, title: "Actions", prop: "action"})}${RendererMarkdown$1.monster._getRenderedSection({mon, prop: "action", entries: actionArray, depth: 1, meta})}`
			: "";
		const bonusActionsPart = bonusActionArray?.length
			? `${RendererMarkdown$1.monster._getRenderedSectionHeader({mon, title: "Bonus Actions", prop: "bonus"})}${RendererMarkdown$1.monster._getRenderedSection({mon, prop: "bonus", entries: bonusActionArray, depth: 1, meta})}`
			: "";
		const reactionsPart = reactionArray?.length
			? `${RendererMarkdown$1.monster._getRenderedSectionHeader({mon, title: "Reactions", prop: "reaction"})}${RendererMarkdown$1.monster._getRenderedSection({mon, prop: "reaction", entries: reactionArray, depth: 1, meta})}`
			: "";
		const legendaryActionsPart = mon.legendary
			? `${RendererMarkdown$1.monster._getRenderedSectionHeader({mon, title: "Legendary Actions", prop: "legendary"})}>${Renderer.monster.getLegendaryActionIntro(mon, {renderer: RendererMarkdown$1.get()})}\n>\n${RendererMarkdown$1.monster._getRenderedLegendarySection(mon.legendary, 1, meta)}`
			: "";
		const mythicActionsPart = mon.mythic
			? `${RendererMarkdown$1.monster._getRenderedSectionHeader({mon, title: "Mythic Actions", prop: "mythic"})}>${Renderer.monster.getSectionIntro(mon, {renderer: RendererMarkdown$1.get(), prop: "mythic"})}\n>\n${RendererMarkdown$1.monster._getRenderedLegendarySection(mon.mythic, 1, meta)}`
			: "";

		const legendaryGroupLairPart = legendaryGroup?.lairActions ? `\n>### Lair Actions\n${RendererMarkdown$1.monster._getRenderedSection({prop: "lairaction", entries: legendaryGroup.lairActions, depth: -1, meta})}` : "";
		const legendaryGroupRegionalPart = legendaryGroup?.regionalEffects ? `\n>### Regional Effects\n${RendererMarkdown$1.monster._getRenderedSection({prop: "regionaleffect", entries: legendaryGroup.regionalEffects, depth: -1, meta})}` : "";

		const footerPart = mon.footer ? `\n${RendererMarkdown$1.monster._getRenderedSectionEntries(mon.footer, 0, meta)}` : "";

		const unbreakablePart = `___
>## ${mon._displayName || mon.name}
>*${mon.level ? `${Parser.getOrdinalForm(mon.level)}-level ` : ""}${Renderer.utils.getRenderedSize(mon.size)} ${monTypes.asText}${mon.alignment ? `, ${mon.alignmentPrefix ? RendererMarkdown$1.get().render(mon.alignmentPrefix) : ""}${Parser.alignmentListToFull(mon.alignment)}` : ""}*
>___
>- **Armor Class** ${acPart}
>- **Hit Points** ${Renderer.monster.getRenderedHp(mon.hp, true)}${resourcePart}
>- **Speed** ${Parser.getSpeedString(mon)}
>___
>|${Parser.ABIL_ABVS.map(it => `${it.toUpperCase()}|`).join("")}
>|:---:|:---:|:---:|:---:|:---:|:---:|
>|${Parser.ABIL_ABVS.map(ab => `${mon[ab]} (${Parser.getAbilityModifier(mon[ab])})|`).join("")}
>___${savePart}${skillPart}${damVulnPart}${damResPart}${damImmPart}${condImmPart}
>- **Senses** ${mon.senses ? `${Renderer.monster.getRenderedSenses(mon.senses, true)}, ` : ""}passive Perception ${mon.passive || "\u2014"}
>- **Languages** ${Renderer.monster.getRenderedLanguages(mon.languages)}
>- **Challenge** ${mon.cr ? Parser.monCrToFull(mon.cr, {isMythic: !!mon.mythic}) : "\u2014"}
${mon.pbNote || Parser.crToNumber(mon.cr) < VeCt.CR_CUSTOM ? `>- **Proficiency Bonus** ${mon.pbNote ?? UiUtil.intToBonus(Parser.crToPb(mon.cr), {isPretty: true})}` : ""}
>___`;

		let breakablePart = `${traitsPart}${actionsPart}${bonusActionsPart}${reactionsPart}${legendaryActionsPart}${mythicActionsPart}${legendaryGroupLairPart}${legendaryGroupRegionalPart}${footerPart}`;

		if (RendererMarkdown$1.getSetting("isAddColumnBreaks")) {
			let charAllowanceFirstCol = 2200 - unbreakablePart.length;

			const breakableLines = breakablePart.split("\n");
			for (let i = 0; i < breakableLines.length; ++i) {
				const l = breakableLines[i];
				if ((charAllowanceFirstCol -= l.length) < 0) {
					breakableLines.splice(i, 0, ">", "> \\columnbreak", ">");
					break;
				}
			}
			breakablePart = breakableLines.join("\n");
		}

		const str = `${unbreakablePart}${breakablePart}`;

		const monRender = str.trim().split("\n").map(it => it.trim() ? it : `>`).join("\n");
		const out = `\n${monRender}\n\n`;

		if (addedStatblockInline) delete meta.isStatblockInlineMonster;

		return out;
	}

	static getSave (attr, mod) {
		if (attr === "special") return Renderer.stripTags(mod);
		return `${attr.uppercaseFirst()} ${mod}`;
	}

	static getSkillsString (mon) {
		function doSortMapJoinSkillKeys (obj, keys, joinWithOr) {
			const toJoin = keys.sort(SortUtil.ascSort).map(s => `${s.toTitleCase()} ${obj[s]}`);
			return joinWithOr ? toJoin.joinConjunct(", ", " or ") : toJoin.join(", ");
		}

		const skills = doSortMapJoinSkillKeys(mon.skill, Object.keys(mon.skill).filter(k => k !== "other" && k !== "special"));

		if (mon.skill.other || mon.skill.special) {
			const others = mon.skill.other && mon.skill.other.map(it => {
				if (it.oneOf) {
					return `plus one of the following: ${doSortMapJoinSkillKeys(it.oneOf, Object.keys(it.oneOf), true)}`;
				}
				throw new Error(`Unhandled monster "other" skill properties!`);
			});
			const special = mon.skill.special && Renderer.stripTags(mon.skill.special);
			return [skills, others, special].filter(Boolean).join(", ");
		} else return skills;
	}

	static _getRenderedSectionHeader ({mon, title, prop}) {
		const propNote = `${prop}Note`;
		const ptTitle = `\n>### ${title}`;
		if (!mon[propNote]) return `${ptTitle}\n`;
		return `${ptTitle} (${mon[propNote]})\n`;
	}

	static _getRenderedSection ({mon = null, prop, entries, depth = 1, meta}) {
		const ptHeader = mon
			? Renderer.monster.getSectionIntro(mon, {renderer: RendererMarkdown$1.get(), prop})
			: "";

		return `${ptHeader ? `>${ptHeader}\n>\n` : ""}${this._getRenderedSectionEntries(entries, depth, meta)}`;
	}

	static _getRenderedSectionEntries (sectionEntries, sectionLevel, meta) {
		const renderer = RendererMarkdown$1.get();
		const renderStack = [""];
		sectionEntries.forEach(e => {
			if (e.rendered) renderStack[0] += e.rendered;
			else {
				const cacheDepth = meta.depth;
				meta.depth = sectionLevel + 1;
				renderer._recursiveRender(e, renderStack, meta, {prefix: ">"});
				meta.depth = cacheDepth;
			}
		});
		return renderStack.join("");
	}

	static _getRenderedLegendarySection (sectionEntries, sectionLevel, meta) {
		const renderer = RendererMarkdown$1.get();
		const renderStack = [""];

		const cpy = MiscUtil.copyFast(sectionEntries).map(it => {
			if (it.name && it.entries) {
				it.name = `${it.name}.`;
				it.type = it.type || "item";
			}
			return it;
		});

		const toRender = {type: "list", style: "list-hang-notitle", items: cpy};
		const cacheDepth = meta.depth;
		meta.depth = sectionLevel;
		renderer._recursiveRender(toRender, renderStack, meta, {prefix: ">"});
		meta.depth = cacheDepth;

		return renderStack.join("");
	}

	static getSpellcastingRenderedTraits (meta, mon, displayAsProp = "trait") {
		const renderer = RendererMarkdown$1.get();
		const out = [];
		const cacheDepth = meta.depth;
		meta.depth = 2;
		(mon.spellcasting || []).filter(it => (it.displayAs || "trait") === displayAsProp).forEach(entry => {
			entry.type = entry.type || "spellcasting";
			const renderStack = [""];
			renderer._recursiveRender(entry, renderStack, meta, {prefix: ">"});
			out.push({name: entry.name, rendered: renderStack.join("")});
		});
		meta.depth = cacheDepth;
		return out;
	}

		static async pGetMarkdownDoc (monsters) {
		const asEntries = (await Promise.all(monsters
			.map(async (mon, i) => {
				const monEntry = ({type: "statblockInline", dataType: "monster", data: mon});

				const fluff = await Renderer.monster.pGetFluff(mon);

				const fluffEntries = (fluff || {}).entries || [];

				RendererMarkdown$1.get().setFirstSection(true);
				const fluffText = fluffEntries.map(ent => RendererMarkdown$1.get().render(ent)).join("\n\n");

				const out = [monEntry];

				const isAddPageBreaks = RendererMarkdown$1.getSetting("isAddPageBreaks");
				if (fluffText) {
										if (isAddPageBreaks) out.push("", "\\pagebreak", "");

					out.push(`## ${mon.name}`);

										let stack = [];
					let charLimit = RendererMarkdown$1.CHARS_PER_PAGE;
					fluffText.split("\n").forEach(l => {
						if ((charLimit -= l.length) < 0) {
							out.push(stack.join("\n"));
							if (isAddPageBreaks) out.push("", "\\pagebreak", "");
							stack = [];
							charLimit = RendererMarkdown$1.CHARS_PER_PAGE - l.length;
						}
						stack.push(l);
					});
					if (stack.length) out.push(stack.join("\n"));
				}

								if (i !== monsters.length - 1 && isAddPageBreaks) out.push("", "\\pagebreak", "");
				return out;
			})))
			.flat();

		return RendererMarkdown$1.get().render({entries: asEntries});
	}
	};

RendererMarkdown$1.spell = class {
	static getCompactRenderedString (sp, opts = {}) {
		const meta = opts.meta || {};

		const subStack = [""];

		subStack[0] += `#### ${sp._displayName || sp.name}
*${Parser.spLevelSchoolMetaToFull(sp.level, sp.school, sp.meta, sp.subschools)}*
___
- **Casting Time:** ${Parser.spTimeListToFull(sp.time)}
- **Range:** ${Parser.spRangeToFull(sp.range)}
- **Components:** ${Parser.spComponentsToFull(sp.components, sp.level, {isPlainText: true})}
- **Duration:** ${Parser.spDurationToFull(sp.duration)}
---\n`;

		const cacheDepth = meta.depth;
		meta.depth = 2;
		RendererMarkdown$1.get().recursiveRender({entries: sp.entries}, subStack, meta, {suffix: "\n"});
		if (sp.entriesHigherLevel) {
			RendererMarkdown$1.get().recursiveRender({entries: sp.entriesHigherLevel}, subStack, meta, {suffix: "\n"});
		}
		meta.depth = cacheDepth;

		const spellRender = subStack.join("").trim();
		return `\n${spellRender}\n\n`;
	}
};

RendererMarkdown$1.item = class {
	static getCompactRenderedString (item, opts = {}) {
		const meta = opts.meta || {};

		const subStack = [""];

		const [damage, damageType, propertiesTxt] = Renderer.item.getDamageAndPropertiesText(item, {renderer: RendererMarkdown$1.get()});
		const [typeRarityText, subTypeText, tierText] = RendererMarkdown$1.item.getTypeRarityAndAttunementText(item);

		const typeRarityTierValueWeight = [typeRarityText, subTypeText, tierText, Parser.itemValueToFullMultiCurrency(item), Parser.itemWeightToFull(item)].filter(Boolean).join(", ").uppercaseFirst();
		const damageProperties = [damage, damageType, propertiesTxt].filter(Boolean).join(" ").uppercaseFirst();

		const ptSubtitle = [typeRarityTierValueWeight, damageProperties].filter(Boolean).join("\n\n");

		subStack[0] += `#### ${item._displayName || item.name}${ptSubtitle ? `\n\n${ptSubtitle}` : ""}\n\n${ptSubtitle ? `---\n\n` : ""}`;

		if (Renderer.item.hasEntries(item)) {
			const cacheDepth = meta.depth;

			if (item._fullEntries || (item.entries?.length)) {
				const entry = {type: "entries", entries: item._fullEntries || item.entries};
				meta.depth = 1;
				RendererMarkdown$1.get().recursiveRender(entry, subStack, meta, {suffix: "\n"});
			}

			if (item._fullAdditionalEntries || item.additionalEntries) {
				const additionEntries = {type: "entries", entries: item._fullAdditionalEntries || item.additionalEntries};
				meta.depth = 1;
				RendererMarkdown$1.get().recursiveRender(additionEntries, subStack, meta, {suffix: "\n"});
			}

			meta.depth = cacheDepth;
		}

		const itemRender = subStack.join("").trim();
		return `\n${itemRender}\n\n`;
	}

	static getTypeRarityAndAttunementText (item) {
		const typeRarity = [
			item._typeHtml === "other" ? "" : $(`<div></div>`).html(item._typeHtml).text(),
			(item.rarity && Renderer.item.doRenderRarity(item.rarity) ? item.rarity : ""),
		].filter(Boolean).join(", ");

		return [
			item.reqAttune ? `${typeRarity} ${item._attunement}` : typeRarity,
			item._subTypeHtml || "",
			item.tier ? `${item.tier} tier` : "",
		];
	}
};

RendererMarkdown$1.legendaryGroup = class {
	static getCompactRenderedString (lg, opts = {}) {
		const meta = opts.meta || {};

		const subEntry = Renderer.legendaryGroup.getSummaryEntry(lg);
		if (!subEntry) return "";

		const subStack = [""];

		subStack[0] += `## ${lg._displayName || lg.name}`;
		RendererMarkdown$1.get().recursiveRender(subEntry, subStack, meta, {suffix: "\n"});

		const lgRender = subStack.join("").trim();
		return `\n${lgRender}\n\n`;
	}
};

RendererMarkdown$1.hover = class {
	static getFnRenderCompact (prop) {
		return RendererMarkdown$1[prop]?.getCompactRenderedString;
	}
};

class MarkdownConverter {
	static getEntries (mdStr) {
		mdStr = mdStr.trim();
		if (!mdStr) return [];

		mdStr = this._getCleanGmBinder(mdStr);

		const buf = mdStr.split("\n").map(line => line.trimEnd());

		this._coalesceCreatures(buf);
		this._convertCreatures(buf);

		this._coalesceInsetsReadalouds(buf);
		this._convertInsetsReadalouds(buf);

		this._coalesceTables(buf);
		this._convertTables(buf);

		this._coalesceLists(buf);
		this._convertLists(buf);

		this._coalesceHeaders(buf);

		this._convertInlineStyling(buf);
		this._cleanEmptyLines(buf);
		this._cleanEntries(buf);

		return buf;
	}

	static _getCleanGmBinder (mdStr) {
				mdStr = mdStr.replace(/(^|\n)\s*\\(pagebreakNum|pagebreak|columnbreak)/gi, "");

				try {
			const $jq = $(`<div>${mdStr}</div>`);
			$jq.find("*").remove();
			mdStr = $jq.text();
		} catch (e) {
			setTimeout(() => { throw e; });
		}

		return mdStr;
	}

	static _coalesceCreatures (buf) {
		for (let i = 0; i < buf.length; ++i) {
			const line = buf[i].trim();

			if (line === "___" || line === "---") {
				let j = 1;

								for (; i + j < buf.length; ++j) {
					const nxt = buf[i + j];
					if (!nxt || !nxt.startsWith(">")) break;
				}

				const creatureLines = buf.slice(i, i + j);
								if (creatureLines.length === 1) {
					buf.splice(i, 1);
					i--;
				} else buf.splice(i, j, {mdType: "creature", lines: creatureLines});
			}
		}
	}

	static _convertCreatures (buf) {
		for (let i = 0; i < buf.length; ++i) {
			const line = buf[i];
			if (typeof line === "string") continue;

			if (line.mdType === "creature") {
				buf[i] = {
					type: "inset",
					name: "(To convert creature stat blocks, please use the Text Converter utility)",
					entries: line.lines.slice(1).map(it => it.slice(1).trim()),
				};
			}
		}
	}

	static _coalesce_getLastH5Index (line, i, curCaptionIx) {
		if (typeof line === "string") {
			if (line.trim()) {
				if (line.startsWith("##### ")) return i;
				else return -1;
			}
		} else return -1;
		return curCaptionIx;
	}

		static _coalesceConvert_doRecurse (obj, fn) {
		if (typeof obj !== "object") throw new TypeError(`Non-object ${obj} passed to object handler!`);

		if (obj instanceof Array) {
			fn(obj);

			obj.forEach(it => {
				if (typeof it !== "object") return;
				this._coalesceConvert_doRecurse(it, fn);
			});
		} else {
			if (obj.type) {
				const childMeta = Renderer.ENTRIES_WITH_CHILDREN.find(it => it.type === obj.type && obj[it.key]);
				if (childMeta) {
					this._coalesceConvert_doRecurse(obj[childMeta.key], fn);
				}
			}
		}
	}

	static _coalesceTables (buf) {
		let lastCaptionIx = -1;

		for (let i = 0; i < buf.length; ++i) {
						if (i > 0) {
				const lPrev = buf[i - 1];
				lastCaptionIx = this._coalesce_getLastH5Index(lPrev, i - 1, lastCaptionIx);
			}

			let l1 = buf[i];
			let l2 = buf[i + 1];

												if (typeof l1 === "string" && typeof l2 === "string"
				&& l1.includes("|") && l2.includes("|")
				&& l2.includes("---") && /^[ |:-]+$/gi.exec(l2)
			) {
				l1 = l1.trim();
				l2 = l2.trim();

				let j = 2;
				for (; j < buf.length; ++j) {
					const lNxt = buf[i + j];
					if (!lNxt || !this._coalesceTables_isTableLine(lNxt)) break;
				}

				if (lastCaptionIx != null && ~lastCaptionIx) {
					const lines = buf.slice(lastCaptionIx, i + j);
					buf.splice(
						lastCaptionIx,
						j + (i - lastCaptionIx),
						{mdType: "table", caption: lines[0].replace("##### ", ""), lines: lines.slice(1)},
					);
				} else {
					const lines = buf.slice(i, i + j);
					buf.splice(i, j, {mdType: "table", lines});
				}
			}
		}
	}

	static _convertTables (buf) {
		for (let i = 0; i < buf.length; ++i) {
			const line = buf[i];
			if (typeof line === "string") continue;

			if (!line.mdType) {
				this._coalesceConvert_doRecurse(line, this._convertTables.bind(this));
			} else {
				if (line.mdType !== "table") continue;

				buf[i] = this.getConvertedTable(line.lines, line.caption);
			}
		}
	}

	static _coalesceTables_isTableLine (l) {
		if (typeof l !== "string") return false;
		l = l.trim();
		if (!l.includes("|")) return false;
		return !/^#+ /.test(l) && !l.startsWith("> ") && !/^[-*+]/.test(l);
	}

	static _coalesceLists (buf) {
		for (let i = 0; i < buf.length; ++i) {
			const line = buf[i];

			if (typeof line !== "string") {
				this._coalesceConvert_doRecurse(line, this._coalesceLists.bind(this));
			} else {
				const liM = this._coalesceLists_isListItem(line);
				if (liM) {
					let j = 1;
					let blankCount = 0;

										for (; i + j < buf.length; ++j) {
						const nxt = buf[i + j];
						if (!nxt || !nxt.trim()) {
														if (blankCount++ < 1) continue;
							else break;
						}
						blankCount = 0;
						if (typeof nxt !== "string") break;
						if (!this._coalesceLists_isListItem(nxt)) break;
					}

					const listLines = buf.slice(i, i + j);
					buf.splice(i, j, {mdType: "list", lines: listLines.filter(it => it.trim())});
				}
			}
		}
	}

	static _coalesceLists_isListItem (line) { return /^(\s*)\* /.test(line) || /^(\s*)- /.test(line) || /^(\s*)\+ /.test(line); }

	static _convertLists (buf) {
		for (let i = 0; i < buf.length; ++i) {
			const line = buf[i];
			if (typeof line === "string") continue;

			if (!line.mdType) {
				this._coalesceConvert_doRecurse(line, this._convertLists.bind(this));
			} else {
				if (line.mdType !== "list") continue;

								line.lines = this._convertLists_doNormalise(line.lines);

				const stack = [];

				const getStackDepth = () => {
					if (!stack.length) return null;
					return stack.length - 1;
				};

				line.lines.forEach(l => {
					const depth = l.length - l.trimStart().length;
					const lText = l.trim();

					if (getStackDepth() == null) {
						const list = {type: "list", items: [lText]};
						stack.push(list);
					} else {
						if (depth === getStackDepth()) stack.last().items.push(lText);
						else if (depth > getStackDepth()) {
							const list = {type: "list", items: [lText]};
							stack.last().items.push(list);
							stack.push(list);
						} else if (depth < getStackDepth()) {
							while (depth < getStackDepth()) stack.pop();

							if (stack.length) stack.last().items.push(lText);
							else stack.push({type: "list", items: [lText]});
						}
					}
				});

				buf.splice(i, 1, stack[0]);
			}
		}
	}

	static _convertLists_doNormalise (lst) {
		const getCleanLine = l => l.replace(/^\s*[-+*]\s*/, "");

				const isInDepthRange = (depthRange, depth) => (depthRange[0] == null && depthRange[1] == null) || (depth >= depthRange[0] - 1 && depth <= depthRange[1] + 1);

		const setDepthRange = (depthRange, depth) => depthRange[0] = depthRange[1] = depth;
		const expandDepthRange = (depthRange, depth) => {
			if (depthRange[0] == null && depthRange[1] == null) {
				depthRange[0] = depth;
				depthRange[1] = depth;
			} else {
				depthRange[0] = Math.min(depthRange[0], depth);
				depthRange[1] = Math.max(depthRange[1], depth);
			}
		};

				let targetDepth = 0;

		const depthRange = [null, null];

		return lst.map(l => {
			const depth = l.length - l.trimStart().length;

			if (isInDepthRange(depthRange, depth)) {
				expandDepthRange(depthRange, depth);
			} else if (depth > depthRange[1]) {
				targetDepth++;
				setDepthRange(depthRange, depth);
			} else if (depth < depthRange[0]) {
								const targetDepthReduction = Math.floor((depthRange[0] - depth) / 2);
				targetDepth = Math.max(0, targetDepth - targetDepthReduction);
				setDepthRange(depthRange, depth);
			}
			return `${" ".repeat(targetDepth)}${getCleanLine(l)}`;
		});
	}

	static _coalesceInsetsReadalouds (buf) {
		const getCleanLine = l => l.replace(/^>>?\s*/, "");

		for (let i = 0; i < buf.length; ++i) {
			let line = buf[i];

			if (typeof line !== "string") {
				this._coalesceConvert_doRecurse(line, this._coalesceInsetsReadalouds.bind(this));
			} else {
				line = line.trim();

				if (this._coalesceInsets_isInsetLine(line) || this._coalesceInsets_isReadaloudLine(line)) {
					let type = this._coalesceInsets_isReadaloudLine(line) ? "insetReadaloud" : "inset";

					let j = 1;
					const header = /^>\s*#####\s+/.test(line) ? line.replace(/^>\s*#####\s+/, "") : null;

					for (; j < buf.length; ++j) {
						const lNxt = buf[i + j];
						if (typeof lNxt === "object") continue;
						if (!lNxt) break;
						if (type === "insetReadaloud" && !this._coalesceInsets_isReadaloudLine(lNxt)) break;
						if (type === "inset" && !this._coalesceInsets_isInsetLine(lNxt)) break;
					}

					const lines = buf.slice(i, i + j).map(getCleanLine);
					const out = {mdType: type, lines};
					if (header) {
						out.name = header;
						lines.shift();
					}
					buf.splice(i, j, out);
				}
			}
		}
	}

	static _coalesceInsets_isReadaloudLine (l) {
		return l.trim().startsWith(">>");
	}

	static _coalesceInsets_isInsetLine (l) {
		return l.trim().startsWith(">");
	}

	static _convertInsetsReadalouds (buf) {
		for (let i = 0; i < buf.length; ++i) {
			const line = buf[i];
			if (typeof line === "string") continue;

			if (line.mdType === "inset" || line.mdType === "insetReadaloud") {
				const out = {
					type: line.mdType,
					name: line.name,
					entries: line.lines,
				};
				if (!out.name || !out.name.trim()) delete out.name;
				buf[i] = out;
			}
		}
	}

	static _coalesceHeaders (buf) {
		const stack = [];

		const i = {_: 0};
		for (; i._ < buf.length; ++i._) {
			let line = buf[i._];

			if (typeof line !== "string") {
				if (!stack.length) continue;
				else {
					buf.splice(i._--, 1);

					stack.last().entries.push(line);
					continue;
				}
			} else line = line.trim();

			const mHashes = /^(#+) /.exec(line);
			const mInlineHeaderStars = /\*\*\*\s*([^.?!:]+[.?!:])\s*\*\*\*(.*)/.exec(line);
			const mInlineHeaderUnders = /___\s*([^.?!:]+[.?!:])\s*___(.*)/.exec(line);
			if (mHashes) {
				const name = line.replace(/^#+ /, "");
				const numHashes = line.length - (name.length + 1); 				switch (numHashes) {
															case 1: this._coalesceHeaders_addBlock(buf, i, stack, -2, name); break;
					case 2: this._coalesceHeaders_addBlock(buf, i, stack, -1, name); break;
										case 3: this._coalesceHeaders_addBlock(buf, i, stack, 0, name); break;
															case 4: this._coalesceHeaders_addBlock(buf, i, stack, 1, name); break;
					case 5: this._coalesceHeaders_addBlock(buf, i, stack, 1, name); break;
				}
			} else if (mInlineHeaderStars || mInlineHeaderUnders) {
				const mInline = mInlineHeaderStars || mInlineHeaderUnders;
				const name = mInline[1];
				const text = mInline[2];
				this._coalesceHeaders_addBlock(buf, i, stack, 2, name.replace(/[.?!:]\s*$/, ""));
				stack.last().entries.push(text);
			} else {
				if (!stack.length) continue;

				buf.splice(i._--, 1);
				stack.last().entries.push(line);
			}
		}
	}

	static _coalesceHeaders_getStackDepth (stack) {
		if (!stack.length) return null;

		let count = 0;
		let start = 0;
		for (let i = stack.length - 1; i >= 0; --i) {
			const ent = stack[i];
			if (ent.type === "section") {
				start = -1;
				break;
			} else {
				count++;
			}
		}

		return start + count;
	}

	static _coalesceHeaders_addBlock (buf, i, stack, depth, name) {
		const targetDepth = depth === -2 ? -1 : depth;

		const curDepth = this._coalesceHeaders_getStackDepth(stack);
		if (curDepth == null || depth === -2) { 						while (stack.length) stack.pop();

			buf[i._] = this._coalesceHeaders_getRoot(stack, depth);
			if (depth <= 0) stack.last().name = name;
			else this._coalesceHeaders_handleTooShallow(stack, targetDepth, name);
		} else {
			if (curDepth === targetDepth) {
				this._coalesceHeaders_handleEqual(buf, i, stack, depth, targetDepth, name);
			} else if (curDepth < targetDepth) {
				buf.splice(i._--, 1);
				this._coalesceHeaders_handleTooShallow(stack, targetDepth, name);
			} else if (curDepth > targetDepth) {
				this._coalesceHeaders_handleTooDeep(buf, i, stack, depth, targetDepth, name);
			}
		}
	}

	static _coalesceHeaders_getRoot (stack, depth) {
		const root = {type: depth < 0 ? "section" : "entries", name: "", entries: []};
		stack.push(root);
		return root;
	}

	static _coalesceHeaders_handleEqual (buf, i, stack, depth, targetDepth, name) {
		if (stack.length > 1) stack.pop();
		else if (targetDepth !== -1) {
						const nuRoot = {
				type: "section",
				entries: [
					stack[0],
				],
			};
			const ixRoot = buf.indexOf(stack[0]);
			if (~ixRoot) throw new Error(`Could not find root in buffer!`);
			buf[ixRoot] = nuRoot;
			stack.pop();
			stack.push(nuRoot);
		}

		if (stack.length) {
			buf.splice(i._--, 1);
			const nxtBlock = {type: depth < 0 ? "section" : "entries", name, entries: []};
			stack.last().entries.push(nxtBlock);
			stack.push(nxtBlock);
		} else {
			buf[i._] = this._coalesceHeaders_getRoot(stack, depth);
			stack.last().name = name;
		}
	}

	static _coalesceHeaders_handleTooShallow (stack, targetDepth, name) {
		while (this._coalesceHeaders_getStackDepth(stack) < targetDepth) {
			const nxt = {type: "entries", name: "", entries: []};
			stack.last().entries.push(nxt);
			stack.push(nxt);
		}
		stack.last().name = name;
	}

	static _coalesceHeaders_handleTooDeep (buf, i, stack, depth, targetDepth, name) {
				while (this._coalesceHeaders_getStackDepth(stack) > targetDepth && stack.length > 1) stack.pop();
		this._coalesceHeaders_handleEqual(buf, i, stack, depth, targetDepth, name);
	}

	static _convertInlineStyling (buf) {
		const handlers = {
			object: (obj) => {
				for (const meta of Renderer.ENTRIES_WITH_CHILDREN) {
					if (obj.type !== meta.type) continue;
					if (!obj[meta.key]) continue;

					obj[meta.key] = obj[meta.key].map(ent => {
						if (typeof ent !== "string") return ent;

												ent = ent.replace(/(\*+)(.+?)(\*+)|(_+)(.+?)(_+)/g, (...m) => {
							const [open, text, close] = m[1] ? [m[1], m[2], m[3]] : [m[4], m[5], m[6]];

							const minLen = Math.min(open.length, close.length);
							const cleanOpen = open.slice(minLen);
							const cleanClose = close.slice(minLen);

							if (minLen === 1) return `{@i ${cleanOpen}${text}${cleanClose}}`;
							else if (minLen === 2) return `{@b ${cleanOpen}${text}${cleanClose}}`;
							else return `{@b {@i ${cleanOpen}${text}${cleanClose}}}`;
						});

												ent = ent.replace(/~~(.+?)~~/g, (...m) => `{@s ${m[1]}}`);

												ent = ent.replace(/\[(.+?)]\((.+?)\)/g, (...m) => `{@link ${m[1]}|${m[2]}}`);

						return ent;
					});
				}
				return obj;
			},
		};
		const nxtBuf = MiscUtil.getWalker().walk(buf, handlers);
		while (buf.length) buf.pop();
		buf.push(...nxtBuf);
	}

	static _cleanEmptyLines (buf) {
		const handlersDoTrim = {
			array: (arr) => arr.map(it => typeof it === "string" ? it.trim() : it),
		};
		const nxtBufTrim = MiscUtil.getWalker().walk(buf, handlersDoTrim);
		while (buf.length) buf.pop();
		buf.push(...nxtBufTrim);

		const handlersRmEmpty = {
			array: (arr) => arr.filter(it => it && (typeof it !== "string" || it.trim())),
		};
		const nxtBufRmEmpty = MiscUtil.getWalker().walk(buf, handlersRmEmpty);
		while (buf.length) buf.pop();
		buf.push(...nxtBufRmEmpty);
	}

	static _cleanEntries (buf) {
		function recursiveClean (obj) {
			if (typeof obj === "object") {
				if (obj instanceof Array) {
					obj.forEach(x => recursiveClean(x));
				} else {
					if ((obj.type === "section" || obj.type === "entries") && obj.name != null && !obj.name.trim()) delete obj.name;
					if (obj.entries && !obj.entries.length) delete obj.entries;

					Object.values(obj).forEach(v => recursiveClean(v));
				}
			}
		}

		recursiveClean(buf);
	}

		static getConvertedTable (lines, caption) {
				const contentLines = lines.filter(l => l && l.trim());
		if (contentLines.every(l => l.trim().startsWith("|"))) lines = lines.map(l => l.replace(/^\s*\|(.*?)$/, "$1"));
		if (contentLines.every(l => l.trim().endsWith("|"))) lines = lines.map(l => l.replace(/^(.*?)\|\s*$/, "$1"));

		const tbl = {
			type: "table",
			caption,
			colLabels: [],
			colStyles: [],
			rows: [],
		};

		let seenHeaderBreak = false;
		let alignment = [];
		lines.map(l => l.trim()).filter(Boolean).forEach(l => {
			const cells = l.split("|").map(it => it.trim());
			if (cells.length) {
				if (cells.every(c => !c || !!/^:?\s*---+\s*:?$/.exec(c))) { 					alignment = cells.map(c => {
						if (c.startsWith(":") && c.endsWith(":")) {
							return "text-center";
						} else if (c.startsWith(":")) {
							return "text-align-left";
						} else if (c.endsWith(":")) {
							return "text-right";
						} else {
							return "";
						}
					});
					seenHeaderBreak = true;
				} else if (seenHeaderBreak) {
					tbl.rows.push(cells);
				} else {
					tbl.colLabels = cells;
				}
			}
		});

		tbl.colStyles = alignment;
		this.postProcessTable(tbl);
		return tbl;
	}

		static postProcessTable (tbl, opts) {
		opts = opts || {};
		opts.tableWidth = opts.tableWidth || 80;
		opts.diceColWidth = opts.diceColWidth || 1;

		tbl.colStyles = tbl.colStyles || [];

				(function normalizeCellCounts () {
						const maxWidth = Math.max((tbl.colLabels || []).length, ...tbl.rows.map(it => it.length));
			tbl.rows.forEach(row => {
				while (row.length < maxWidth) row.push("");
			});
		})();

		let isDiceCol0 = true;
		(function doCheckDiceOrNumericCol0 () {
						tbl.rows.forEach(r => {
				const r0Clean = Renderer.stripTags((r[0] || "").trim());
								if (!/^[-+*/×÷x^.,0-9\u2012\u2013]+(?:st|nd|rd|th)?$/i.exec(r0Clean)) return isDiceCol0 = false;
			});
		})();

		(function doCalculateWidths () {
			const BASE_CHAR_CAP = opts.tableWidth; 
						let isAllBelowCap = true;
			const widthMeta = (() => {
				if (!tbl.rows.length) return null;

				const outAvgWidths = [...new Array(tbl.rows[0].length)].map(() => 0);
								const outMaxWidths = [...new Array(tbl.rows[0].length)].map((_, i) => tbl.colLabels[i] ? tbl.colLabels[i].length : 0);

				tbl.rows.forEach(r => {
					r.forEach((cell, i) => {
												const cellStripped = Renderer.stripTags(cell);
						if (cellStripped.length > BASE_CHAR_CAP) isAllBelowCap = false;
						outAvgWidths[i] += Math.min(BASE_CHAR_CAP, cellStripped.length);
						outMaxWidths[i] = Math.max(outMaxWidths[i], cellStripped.length);
					});
				});

				return {
					avgWidths: outAvgWidths.map(it => it / tbl.rows.length),
					maxWidths: outMaxWidths,
				};
			})();

			if (widthMeta == null) return;
			const {avgWidths, maxWidths} = widthMeta;

						const assignColWidths = (widths) => {
								const splitInto = isDiceCol0 ? 12 - opts.diceColWidth : 12;
				if (isDiceCol0) widths = widths.slice(1);

				const totalWidths = widths.reduce((a, b) => a + b, 0);
				const redistributedWidths = (() => {
					const MIN = totalWidths / splitInto;
					const sorted = widths.map((it, i) => ({ix: i, val: it})).sort((a, b) => SortUtil.ascSort(a.val, b.val));

					for (let i = 0; i < sorted.length - 1; ++i) {
						const it = sorted[i];
						if (it.val < MIN) {
							const diff = MIN - it.val;
							sorted[i].val = MIN;
							const toSteal = diff / sorted.length - (i + 1);
							for (let j = i + 1; j < sorted.length; ++j) {
								sorted[j].val -= toSteal;
							}
						}
					}

					return sorted.sort((a, b) => SortUtil.ascSort(a.ix, b.ix)).map(it => it.val);
				})();

				let nmlxWidths = redistributedWidths.map(it => it / totalWidths);
				while (nmlxWidths.reduce((a, b) => a + b, 0) > 1) {
					const diff = 1 - nmlxWidths.reduce((a, b) => a + b, 0);
					nmlxWidths = nmlxWidths.map(it => it + diff / nmlxWidths.length);
				}
				const twelfthWidths = nmlxWidths.map(it => Math.round(it * splitInto));

				if (isDiceCol0) tbl.colStyles[0] = `col-${opts.diceColWidth}`;
				twelfthWidths.forEach((it, i) => {
					const widthPart = `col-${it}`;
					const iOffset = isDiceCol0 ? i + 1 : i;

					tbl.colStyles[iOffset] = tbl.colStyles[iOffset] ? `${tbl.colStyles[iOffset]} ${widthPart}` : widthPart;
				});
			};

			assignColWidths(isAllBelowCap ? maxWidths : avgWidths);
		})();

		if (isDiceCol0 && !tbl.colStyles.includes("text-center")) tbl.colStyles[0] += " text-center";

		(function doCheckNumericCols () {
			if (isDiceCol0 && tbl.colStyles.length === 2) return; 
			tbl.colStyles.forEach((col, i) => {
				if (col.includes("text-center") || col.includes("text-right")) return;

				const counts = {number: 0, text: 0};

				tbl.rows.forEach(r => {
					if (typeof r[i] !== "string") return counts.text++;
					const clean = Renderer.stripTags(r[i])
						.replace(/[.,]/g, "") 						.replace(/(^| )(cp|sp|gp|pp|lb\.|ft\.)( |$)/g, "") 						.trim();
					counts[isNaN(Number(clean)) ? "text" : "number"]++;
				});

												if ((counts.number / tbl.rows.length) >= 0.80) {
					if (i === 0) tbl.colStyles[i] += ` text-center`;
					else tbl.colStyles[i] += ` text-right`;
				}
			});
		})();

				let isFewWordsCol1 = false;
		(function doCheckFewWordsCols () {
			if (isDiceCol0 && tbl.colStyles.length === 2) return; 
						for (let i = tbl.colStyles.length - 1; i >= 0; --i) {
				const col = tbl.colStyles[i];

								if (i === 0 && tbl.colStyles.length > 1 && tbl.colStyles.filter((_, i) => i !== 0).some(it => !it.includes("text-center"))) continue;

				const counts = {short: 0, long: 0};

				tbl.rows.forEach(r => {
					const cell = r[i];
					if (typeof cell !== "string") return counts.long++;
					const words = Renderer.stripTags(cell).split(" ");
					counts[words.length <= 3 ? "short" : "long"]++;
				});

								if ((counts.short / tbl.rows.length) >= 0.80) {
					if (i === 1) isFewWordsCol1 = true;
					if (col.includes("text-center") || col.includes("text-right")) continue;
					tbl.colStyles[i] += ` text-center`;
				}
			}
		})();

		this._doCleanTable(tbl);

		(function doEvenCenteredColumns () {
			if (!isDiceCol0) return;
			if (tbl.colStyles.length === 2 && isFewWordsCol1) {
				tbl.colStyles = ["col-6 text-center", "col-6 text-center"];
			}
		})();

				tbl.rows = tbl.rows.map(r => {
			return r.map(cell => {
				if (cell === "--") return "\u2014";
				return cell;
			});
		});
	}

	static _doCleanTable (tbl) {
		if (!tbl.caption) delete tbl.caption;
		if (tbl.colLabels && !tbl.colLabels.some(Boolean)) delete tbl.colLabels;
		if (tbl.colStyles && !tbl.colStyles.some(Boolean)) delete tbl.colStyles;
	}
	}

globalThis.RendererMarkdown = RendererMarkdown$1;
globalThis.MarkdownConverter = MarkdownConverter;

"use strict";

let Hist$1 = class Hist {
	static hashChange ({isForceLoad, isBlankFilterLoad = false} = {}) {
		if (Hist$1.isHistorySuppressed) {
			Hist$1.setSuppressHistory(false);
			return;
		}

		const [link, ...sub] = Hist$1.getHashParts();

		if (link !== Hist$1.lastLoadedLink || sub.length === 0 || isForceLoad) {
			Hist$1.lastLoadedLink = link;
			if (link === HASH_BLANK) {
				isBlankFilterLoad = true;
			} else {
				const listItem = Hist$1.getActiveListItem(link);

				if (listItem == null) {
					if (typeof pHandleUnknownHash === "function" && window.location.hash.length && Hist$1._lastUnknownLink !== link) {
						Hist$1._lastUnknownLink = link;
						pHandleUnknownHash(link, sub);
						return;
					} else {
						Hist$1._freshLoad();
						return;
					}
				}

				const toLoad = listItem.ix;
				if (toLoad === undefined) Hist$1._freshLoad();
				else {
					Hist$1.lastLoadedId = listItem.ix;
					loadHash(listItem.ix);
					document.title = `${listItem.name ? `${listItem.name} - ` : ""}5etools`;
				}
			}
		}

		if (typeof loadSubHash === "function" && (sub.length > 0 || isForceLoad)) loadSubHash(sub);
		if (isBlankFilterLoad) Hist$1._freshLoad();
	}

	static init (initialLoadComplete) {
		window.onhashchange = () => Hist$1.hashChange({isForceLoad: true});
		if (window.location.hash.length) {
			Hist$1.hashChange();
		} else {
			Hist$1._freshLoad();
		}
		if (initialLoadComplete) Hist$1.initialLoad = false;
	}

		static setSuppressHistory (val) {
		Hist$1.isHistorySuppressed = val;
	}

	static _listPage = null;

	static setListPage (listPage) { this._listPage = listPage; }

	static getSelectedListItem () {
		const [link] = Hist$1.getHashParts();
		return Hist$1.getActiveListItem(link);
	}

	static getSelectedListElementWithLocation () {
		const [link] = Hist$1.getHashParts();
		return Hist$1.getActiveListItem(link, true);
	}

	static getHashParts () {
		return Hist$1.util.getHashParts(window.location.hash);
	}

	static getActiveListItem (link, getIndex) {
		const primaryLists = this._listPage.primaryLists;
		if (primaryLists && primaryLists.length) {
			for (let x = 0; x < primaryLists.length; ++x) {
				const list = primaryLists[x];

				const foundItemIx = list.items.findIndex(it => it.values.hash === link);
				if (~foundItemIx) {
					if (getIndex) return {item: list.items[foundItemIx], x: x, y: foundItemIx, list};
					return list.items[foundItemIx];
				}
			}
		}
	}

	static _freshLoad () {
				setTimeout(() => {
			const goTo = $("#listcontainer").find(".list a").attr("href");
			if (goTo) {
				const parts = location.hash.split(HASH_PART_SEP);
				const fullHash = `${goTo}${parts.length > 1 ? `${HASH_PART_SEP}${parts.slice(1).join(HASH_PART_SEP)}` : ""}`;
				location.replace(fullHash);
			}
		}, 1);
	}

	static cleanSetHash (toSet) {
		window.location.hash = Hist$1.util.getCleanHash(toSet);
	}

	static getHashSource () {
		const [link] = Hist$1.getHashParts();
				return link ? link.split(HASH_LIST_SEP).last() : null;
	}

	static getSubHash (key) {
		return Hist$1.util.getSubHash(window.location.hash, key);
	}

		static setSubhash (key, val) {
		const nxtHash = Hist$1.util.setSubhash(window.location.hash, key, val);
		Hist$1.cleanSetHash(nxtHash);
	}

	static setMainHash (hash) {
		const subHashPart = Hist$1.util.getHashParts(window.location.hash, key, val).slice(1).join(HASH_PART_SEP);
		Hist$1.cleanSetHash([hash, subHashPart].filter(Boolean).join(HASH_PART_SEP));
	}

	static replaceHistoryHash (hash) {
		window.history.replaceState(
			{},
			document.title,
			`${location.origin}${location.pathname}${hash ? `#${hash}` : ""}`,
		);
	}
};
Hist$1.lastLoadedLink = null;
Hist$1._lastUnknownLink = null;
Hist$1.lastLoadedId = null;
Hist$1.initialLoad = true;
Hist$1.isHistorySuppressed = false;

Hist$1.util = class {
	static getCleanHash (hash) {
		return hash.replace(/,+/g, ",").replace(/,$/, "").toLowerCase();
	}

	static _SYMS_NO_ENCODE = [/(,)/g, /(:)/g, /(=)/g];

	static getHashParts (location) {
		if (location[0] === "#") location = location.slice(1);

				let pts = [location];
		this._SYMS_NO_ENCODE.forEach(re => {
			pts = pts.map(pt => pt.split(re)).flat();
		});
		pts = pts.map(pt => {
			if (this._SYMS_NO_ENCODE.some(re => re.test(pt))) return pt;
			return decodeURIComponent(pt).toUrlified();
		});
		location = pts.join("");
		
		return location
			.split(HASH_PART_SEP);
	}

	static getSubHash (location, key) {
		const [link, ...sub] = Hist$1.util.getHashParts(location);
		const hKey = `${key}${HASH_SUB_KV_SEP}`;
		const part = sub.find(it => it.startsWith(hKey));
		if (part) return part.slice(hKey.length);
		return null;
	}

	static setSubhash (location, key, val) {
		if (key.endsWith(HASH_SUB_KV_SEP)) key = key.slice(0, -1);

		const [link, ...sub] = Hist$1.util.getHashParts(location);
		if (!link) return "";

		const hKey = `${key}${HASH_SUB_KV_SEP}`;
		const out = [link];
		if (sub.length) sub.filter(it => !it.startsWith(hKey)).forEach(it => out.push(it));
		if (val != null) out.push(`${hKey}${val}`);

		return Hist$1.util.getCleanHash(out.join(HASH_PART_SEP));
	}
};

globalThis.Hist = Hist$1;

"use strict";

class FilterUtil {}
FilterUtil.SUB_HASH_PREFIX_LENGTH = 4;

let PageFilter$1 = class PageFilter {
	static defaultSourceSelFn (val) {
		return !SourceUtil.isNonstandardSource(val);
	}

	constructor (opts) {
		opts = opts || {};
		this._sourceFilter = new SourceFilter$1(opts.sourceFilterOpts);
		this._filterBox = null;
	}

	get filterBox () { return this._filterBox; }
	get sourceFilter () { return this._sourceFilter; }

	mutateAndAddToFilters (entity, isExcluded, opts) {
		this.constructor.mutateForFilters(entity, opts);
		this.addToFilters(entity, isExcluded, opts);
	}

	static mutateForFilters (entity, opts) { throw new Error("Unimplemented!"); }
	addToFilters (entity, isExcluded, opts) { throw new Error("Unimplemented!"); }
	toDisplay (values, entity) { throw new Error("Unimplemented!"); }
	async _pPopulateBoxOptions () { throw new Error("Unimplemented!"); }

	async pInitFilterBox (opts) {
		opts = opts || {};
		await this._pPopulateBoxOptions(opts);
		this._filterBox = new FilterBox$1(opts);
		await this._filterBox.pDoLoadState();
		return this._filterBox;
	}

	trimState () { return this._filterBox.trimState_(); }

		static _getClassFilterItem ({className, classSource, isVariantClass, definedInSource}) {
		const nm = className.split("(")[0].trim();
		const variantSuffix = isVariantClass ? ` [${definedInSource ? Parser.sourceJsonToAbv(definedInSource) : "Unknown"}]` : "";
		const sourceSuffix = (
			SourceUtil.isNonstandardSource(classSource || Parser.SRC_PHB)
			|| (typeof PrereleaseUtil !== "undefined" && PrereleaseUtil.hasSourceJson(classSource || Parser.SRC_PHB))
			|| (typeof BrewUtil2 !== "undefined" && BrewUtil2.hasSourceJson(classSource || Parser.SRC_PHB))
		)
			? ` (${Parser.sourceJsonToAbv(classSource)})` : "";
		const name = `${nm}${variantSuffix}${sourceSuffix}`;

		const opts = {
			item: name,
			userData: {
				group: SourceUtil.getFilterGroup(classSource || Parser.SRC_PHB),
			},
		};

		if (isVariantClass) {
			opts.nest = definedInSource ? Parser.sourceJsonToFull(definedInSource) : "Unknown";
			opts.userData.equivalentClassName = `${nm}${sourceSuffix}`;
			opts.userData.definedInSource = definedInSource;
		}

		return new FilterItem$1(opts);
	}

	static _getSubclassFilterItem ({className, classSource, subclassShortName, subclassName, subclassSource, subSubclassName, isVariantClass, definedInSource}) {
		const group = SourceUtil.isSubclassReprinted(className, classSource, subclassShortName, subclassSource) || Parser.sourceJsonToFull(subclassSource).startsWith(Parser.UA_PREFIX) || Parser.sourceJsonToFull(subclassSource).startsWith(Parser.PS_PREFIX);

		const classFilterItem = this._getClassFilterItem({
			className: subclassShortName || subclassName,
			classSource: subclassSource,
		});

		return new FilterItem$1({
			item: `${className}: ${classFilterItem.item}${subSubclassName ? `, ${subSubclassName}` : ""}`,
			nest: className,
			userData: {
				group,
			},
		});
	}

	static _isReprinted ({reprintedAs, tag, page, prop}) {
		return reprintedAs?.length && reprintedAs.some(it => {
			const {name, source} = DataUtil.generic.unpackUid(it?.uid ?? it, tag);
			const hash = UrlUtil.URL_TO_HASH_BUILDER[page]({name, source});
			return !ExcludeUtil.isExcluded(hash, prop, source, {isNoCount: true});
		});
	}
	};

globalThis.PageFilter = PageFilter$1;

let ModalFilter$1 = class ModalFilter {
	static _$getFilterColumnHeaders (btnMeta) {
		return btnMeta.map((it, i) => $(`<button class="col-${it.width} ${i === 0 ? "pl-0" : i === btnMeta.length ? "pr-0" : ""} ${it.disabled ? "" : "sort"} btn btn-default btn-xs" ${it.disabled ? "" : `data-sort="${it.sort}"`} ${it.title ? `title="${it.title}"` : ""} ${it.disabled ? "disabled" : ""}>${it.text}</button>`));
	}

		constructor (opts) {
		this._modalTitle = opts.modalTitle;
		this._fnSort = opts.fnSort;
		this._pageFilter = opts.pageFilter;
		this._namespace = opts.namespace;
		this._allData = opts.allData || null;
		this._isRadio = !!opts.isRadio;

		this._list = null;
		this._filterCache = null;
	}

	get pageFilter () { return this._pageFilter; }

	get allData () { return this._allData; }

	_$getWrpList () { return $(`<div class="list ui-list__wrp overflow-x-hidden overflow-y-auto h-100 min-h-0"></div>`); }

	_$getColumnHeaderPreviewAll (opts) {
		return $(`<button class="btn btn-default btn-xs ${opts.isBuildUi ? "col-1" : "col-0-5"}">${ListUiUtil.HTML_GLYPHICON_EXPAND}</button>`);
	}

		async pPopulateWrapper ($wrp, opts) {
		opts = opts || {};

		await this._pInit();

		const $ovlLoading = $(`<div class="w-100 h-100 ve-flex-vh-center"><i class="dnd-font ve-muted">Loading...</i></div>`).appendTo($wrp);

		const $iptSearch = (opts.$iptSearch || $(`<input class="form-control lst__search lst__search--no-border-h h-100" type="search" placeholder="Search...">`)).disableSpellcheck();
		const $btnReset = opts.$btnReset || $(`<button class="btn btn-default">Reset</button>`);
		const $dispNumVisible = $(`<div class="lst__wrp-search-visible no-events ve-flex-vh-center"></div>`);

		const $wrpIptSearch = $$`<div class="w-100 relative">
			${$iptSearch}
			<div class="lst__wrp-search-glass no-events ve-flex-vh-center"><span class="glyphicon glyphicon-search"></span></div>
			${$dispNumVisible}
		</div>`;

		const $wrpFormTop = $$`<div class="ve-flex input-group btn-group w-100 lst__form-top">${$wrpIptSearch}${$btnReset}</div>`;

		const $wrpFormBottom = opts.$wrpMiniPills || $(`<div class="w-100"></div>`);

		const $wrpFormHeaders = $(`<div class="input-group input-group--bottom ve-flex no-shrink"></div>`);
		const $cbSelAll = opts.isBuildUi || this._isRadio ? null : $(`<input type="checkbox">`);
		const $btnSendAllToRight = opts.isBuildUi ? $(`<button class="btn btn-xxs btn-default col-1" title="Add All"><span class="glyphicon glyphicon-arrow-right"></span></button>`) : null;

		if (!opts.isBuildUi) {
			if (this._isRadio) $wrpFormHeaders.append(`<label class="btn btn-default btn-xs col-0-5 ve-flex-vh-center" disabled></label>`);
			else $$`<label class="btn btn-default btn-xs col-0-5 ve-flex-vh-center">${$cbSelAll}</label>`.appendTo($wrpFormHeaders);
		}

		const $btnTogglePreviewAll = this._$getColumnHeaderPreviewAll(opts)
			.appendTo($wrpFormHeaders);

		this._$getColumnHeaders().forEach($ele => $wrpFormHeaders.append($ele));
		if (opts.isBuildUi) $btnSendAllToRight.appendTo($wrpFormHeaders);

		const $wrpForm = $$`<div class="ve-flex-col w-100 mb-1">${$wrpFormTop}${$wrpFormBottom}${$wrpFormHeaders}</div>`;
		const $wrpList = this._$getWrpList();

		const $btnConfirm = opts.isBuildUi ? null : $(`<button class="btn btn-default">Confirm</button>`);

		this._list = new List({
			$iptSearch,
			$wrpList,
			fnSort: this._fnSort,
		});
		const listSelectClickHandler = new ListSelectClickHandler({list: this._list});

		if (!opts.isBuildUi && !this._isRadio) listSelectClickHandler.bindSelectAllCheckbox($cbSelAll);
		ListUiUtil.bindPreviewAllButton($btnTogglePreviewAll, this._list);
		SortUtil.initBtnSortHandlers($wrpFormHeaders, this._list);
		this._list.on("updated", () => $dispNumVisible.html(`${this._list.visibleItems.length}/${this._list.items.length}`));

		this._allData = this._allData || await this._pLoadAllData();

		await this._pageFilter.pInitFilterBox({
			$wrpFormTop,
			$btnReset,
			$wrpMiniPills: $wrpFormBottom,
			namespace: this._namespace,
			$btnOpen: opts.$btnOpen,
			$btnToggleSummaryHidden: opts.$btnToggleSummaryHidden,
		});

		this._allData.forEach((it, i) => {
			this._pageFilter.mutateAndAddToFilters(it);
			const filterListItem = this._getListItem(this._pageFilter, it, i);
			this._list.addItem(filterListItem);
			if (!opts.isBuildUi) {
				if (this._isRadio) filterListItem.ele.addEventListener("click", evt => listSelectClickHandler.handleSelectClickRadio(filterListItem, evt));
				else filterListItem.ele.addEventListener("click", evt => listSelectClickHandler.handleSelectClick(filterListItem, evt));
			}
		});

		this._list.init();
		this._list.update();

		const handleFilterChange = () => {
			const f = this._pageFilter.filterBox.getValues();
			this._list.filter(li => this._isListItemMatchingFilter(f, li));
		};

		this._pageFilter.trimState();

		this._pageFilter.filterBox.on(FilterBox$1.EVNT_VALCHANGE, handleFilterChange);
		this._pageFilter.filterBox.render();
		handleFilterChange();

		$ovlLoading.remove();

		const $wrpInner = $$`<div class="ve-flex-col h-100">
			${$wrpForm}
			${$wrpList}
			${opts.isBuildUi ? null : $$`<hr class="hr-1"><div class="ve-flex-vh-center">${$btnConfirm}</div>`}
		</div>`.appendTo($wrp.empty());

		return {
			$wrpIptSearch,
			$iptSearch,
			$wrpInner,
			$btnConfirm,
			pageFilter: this._pageFilter,
			list: this._list,
			$cbSelAll,
			$btnSendAllToRight,
		};
	}

	_isListItemMatchingFilter (f, li) { return this._isEntityItemMatchingFilter(f, this._allData[li.ix]); }
	_isEntityItemMatchingFilter (f, it) { return this._pageFilter.toDisplay(f, it); }

	async pPopulateHiddenWrapper () {
		await this._pInit();

		this._allData = this._allData || await this._pLoadAllData();

		await this._pageFilter.pInitFilterBox({namespace: this._namespace});

		this._allData.forEach(it => {
			this._pageFilter.mutateAndAddToFilters(it);
		});

		this._pageFilter.trimState();
	}

	handleHiddenOpenButtonClick () {
		this._pageFilter.filterBox.show();
	}

	handleHiddenResetButtonClick (evt) {
		this._pageFilter.filterBox.reset(evt.shiftKey);
	}

	_getStateFromFilterExpression (filterExpression) {
		const filterSubhashMeta = Renderer.getFilterSubhashes(Renderer.splitTagByPipe(filterExpression), this._namespace);
		const subhashes = filterSubhashMeta.subhashes.map(it => `${it.key}${HASH_SUB_KV_SEP}${it.value}`);
		const unpackedSubhashes = this.pageFilter.filterBox.unpackSubHashes(subhashes, {force: true});
		return this.pageFilter.filterBox.getNextStateFromSubHashes({unpackedSubhashes});
	}

		getItemsMatchingFilterExpression ({filterExpression}) {
		const nxtStateOuter = this._getStateFromFilterExpression(filterExpression);

		const f = this._pageFilter.filterBox.getValues({nxtStateOuter});
		const filteredItems = this._filterCache.list.getFilteredItems({
			items: this._filterCache.list.items,
			fnFilter: li => this._isListItemMatchingFilter(f, li),
		});

		return this._filterCache.list.getSortedItems({items: filteredItems});
	}

	getEntitiesMatchingFilterExpression ({filterExpression}) {
		const nxtStateOuter = this._getStateFromFilterExpression(filterExpression);

		const f = this._pageFilter.filterBox.getValues({nxtStateOuter});
		return this._allData.filter(this._isEntityItemMatchingFilter.bind(this, f));
	}

	getRenderedFilterExpression ({filterExpression}) {
		const nxtStateOuter = this._getStateFromFilterExpression(filterExpression);
		return this.pageFilter.filterBox.getDisplayState({nxtStateOuter});
	}

		async pGetUserSelection ({filterExpression = null} = {}) {
				return new Promise(async resolve => {
			const {$modalInner, doClose} = await this._pGetShowModal(resolve);

			await this.pPreloadHidden($modalInner);

			this._doApplyFilterExpression(filterExpression);

			this._filterCache.$btnConfirm.off("click").click(async () => {
				const checked = this._filterCache.list.visibleItems.filter(it => it.data.cbSel.checked);
				resolve(checked);

				doClose(true);

								if (this._filterCache.$cbSelAll) this._filterCache.$cbSelAll.prop("checked", false);
				this._filterCache.list.items.forEach(it => {
					if (it.data.cbSel) it.data.cbSel.checked = false;
					it.ele.classList.remove("list-multi-selected");
				});
							});

			await UiUtil.pDoForceFocus(this._filterCache.$iptSearch[0]);
		});
	}

	async _pGetShowModal (resolve) {
		const {$modalInner, doClose} = await UiUtil.pGetShowModal({
			isHeight100: true,
			isWidth100: true,
			title: `Filter/Search for ${this._modalTitle}`,
			cbClose: (isDataEntered) => {
				this._filterCache.$wrpModalInner.detach();
				if (!isDataEntered) resolve([]);
			},
			isUncappedHeight: true,
		});

		return {$modalInner, doClose};
	}

	_doApplyFilterExpression (filterExpression) {
		if (!filterExpression) return;

		const filterSubhashMeta = Renderer.getFilterSubhashes(Renderer.splitTagByPipe(filterExpression), this._namespace);
		const subhashes = filterSubhashMeta.subhashes.map(it => `${it.key}${HASH_SUB_KV_SEP}${it.value}`);
		this.pageFilter.filterBox.setFromSubHashes(subhashes, {force: true, $iptSearch: this._filterCache.$iptSearch});
	}

	_getNameStyle () { return `bold`; }

		async pPreloadHidden ($modalInner) {
				$modalInner = $modalInner || $(`<div></div>`);

		if (this._filterCache) {
			this._filterCache.$wrpModalInner.appendTo($modalInner);
		} else {
			const meta = await this.pPopulateWrapper($modalInner);
			const {$iptSearch, $btnConfirm, pageFilter, list, $cbSelAll} = meta;
			const $wrpModalInner = meta.$wrpInner;

			this._filterCache = {$iptSearch, $wrpModalInner, $btnConfirm, pageFilter, list, $cbSelAll};
		}
	}

		_$getColumnHeaders () { throw new Error(`Unimplemented!`); }
	async _pInit () {  }
	async _pLoadAllData () { throw new Error(`Unimplemented!`); }
	async _getListItem () { throw new Error(`Unimplemented!`); }
};

globalThis.ModalFilter = ModalFilter$1;

let FilterBox$1 = class FilterBox extends ProxyBase {
	static TITLE_BTN_RESET = "Reset filters. SHIFT to reset everything.";

	static selectFirstVisible (entryList) {
		if (Hist.lastLoadedId == null && !Hist.initialLoad) {
			Hist._freshLoad();
		}

							}

		constructor (opts) {
		super();

		this._$iptSearch = opts.$iptSearch;
		this._$wrpFormTop = opts.$wrpFormTop;
		this._$btnReset = opts.$btnReset;
		this._$btnOpen = opts.$btnOpen;
		this._$wrpMiniPills = opts.$wrpMiniPills;
		this._$btnToggleSummaryHidden = opts.$btnToggleSummaryHidden;
		this._filters = opts.filters;
		this._isCompact = opts.isCompact;
		this._namespace = opts.namespace;

		this._doSaveStateThrottled = MiscUtil.throttle(() => this._pDoSaveState(), 50);
		this.__meta = this._getDefaultMeta();
		if (this._isCompact) this.__meta.isSummaryHidden = true;

		this._meta = this._getProxy("meta", this.__meta);
		this.__minisHidden = {};
		this._minisHidden = this._getProxy("minisHidden", this.__minisHidden);
		this.__combineAs = {};
		this._combineAs = this._getProxy("combineAs", this.__combineAs);
		this._modalMeta = null;
		this._isRendered = false;

		this._cachedState = null;

		this._compSearch = BaseComponent.fromObject({search: ""});
		this._metaIptSearch = null;

		this._filters.forEach(f => f.filterBox = this);

		this._eventListeners = {};
	}

	get filters () { return this._filters; }

	teardown () {
		this._filters.forEach(f => f._doTeardown());
		if (this._modalMeta) this._modalMeta.doTeardown();
	}

		on (identifier, fn) {
		const [eventName, namespace] = identifier.split(".");
		(this._eventListeners[eventName] = this._eventListeners[eventName] || []).push({namespace, fn});
		return this;
	}

	off (identifier, fn = null) {
		const [eventName, namespace] = identifier.split(".");
		this._eventListeners[eventName] = (this._eventListeners[eventName] || []).filter(it => {
			if (fn != null) return it.namespace !== namespace || it.fn !== fn;
			return it.namespace !== namespace;
		});
		if (!this._eventListeners[eventName].length) delete this._eventListeners[eventName];
		return this;
	}

	fireChangeEvent () {
		this._doSaveStateThrottled();
		this.fireEvent(FilterBox$1.EVNT_VALCHANGE);
	}

	fireEvent (eventName) {
		(this._eventListeners[eventName] || []).forEach(it => it.fn());
	}
	
	_getNamespacedStorageKey () { return `${FilterBox$1._STORAGE_KEY}${this._namespace ? `.${this._namespace}` : ""}`; }
	getNamespacedHashKey (k) { return `${k || "_".repeat(FilterUtil.SUB_HASH_PREFIX_LENGTH)}${this._namespace ? `.${this._namespace}` : ""}`; }

	async pGetStoredActiveSources () {
		const stored = await StorageUtil.pGetForPage(this._getNamespacedStorageKey());
		if (stored) {
			const sourceFilterData = stored.filters[FilterBox$1.SOURCE_HEADER];
			if (sourceFilterData) {
				const state = sourceFilterData.state;
				const blue = [];
				const white = [];
				Object.entries(state).forEach(([src, mode]) => {
					if (mode === 1) blue.push(src);
					else if (mode !== -1) white.push(src);
				});
				if (blue.length) return blue; 				else return white; 			}
		}
		return null;
	}

	registerMinisHiddenHook (prop, hook) {
		this._addHook("minisHidden", prop, hook);
	}

	isMinisHidden (header) {
		return !!this._minisHidden[header];
	}

	async pDoLoadState () {
		const toLoad = await StorageUtil.pGetForPage(this._getNamespacedStorageKey());
		if (toLoad != null) this._setStateFromLoaded(toLoad);
	}

	_setStateFromLoaded (state) {
		state.box = state.box || {};
		this._proxyAssign("meta", "_meta", "__meta", state.box.meta || {}, true);
		this._proxyAssign("minisHidden", "_minisHidden", "__minisHidden", state.box.minisHidden || {}, true);
		this._proxyAssign("combineAs", "_combineAs", "__combineAs", state.box.combineAs || {}, true);
		this._filters.forEach(it => it.setStateFromLoaded(state.filters));
	}

	_getSaveableState () {
		const filterOut = {};
		this._filters.forEach(it => Object.assign(filterOut, it.getSaveableState()));
		return {
			box: {
				meta: {...this.__meta},
				minisHidden: {...this.__minisHidden},
				combineAs: {...this.__combineAs},
			},
			filters: filterOut,
		};
	}

	async _pDoSaveState () {
		await StorageUtil.pSetForPage(this._getNamespacedStorageKey(), this._getSaveableState());
	}

	trimState_ () {
		this._filters.forEach(f => f.trimState_());
	}

	render () {
		if (this._isRendered) {
						this._filters.map(f => f.update());
			return;
		}
		this._isRendered = true;

		if (this._$wrpFormTop || this._$wrpMiniPills) {
			if (!this._$wrpMiniPills) {
				this._$wrpMiniPills = $(`<div class="fltr__mini-view btn-group"></div>`).insertAfter(this._$wrpFormTop);
			} else {
				this._$wrpMiniPills.addClass("fltr__mini-view");
			}
		}

		if (this._$btnReset) {
			this._$btnReset
				.title(FilterBox$1.TITLE_BTN_RESET)
				.click((evt) => this.reset(evt.shiftKey));
		}

		if (this._$wrpFormTop || this._$btnToggleSummaryHidden) {
			if (!this._$btnToggleSummaryHidden) {
				this._$btnToggleSummaryHidden = $(`<button class="btn btn-default ${this._isCompact ? "p-2" : ""}" title="Toggle Filter Summary"><span class="glyphicon glyphicon-resize-small"></span></button>`)
					.prependTo(this._$wrpFormTop);
			} else if (!this._$btnToggleSummaryHidden.parent().length) {
				this._$btnToggleSummaryHidden.prependTo(this._$wrpFormTop);
			}
			this._$btnToggleSummaryHidden
				.click(() => {
					this._meta.isSummaryHidden = !this._meta.isSummaryHidden;
					this._doSaveStateThrottled();
				});
			const summaryHiddenHook = () => {
				this._$btnToggleSummaryHidden.toggleClass("active", !!this._meta.isSummaryHidden);
				this._$wrpMiniPills.toggleClass("ve-hidden", !!this._meta.isSummaryHidden);
			};
			this._addHook("meta", "isSummaryHidden", summaryHiddenHook);
			summaryHiddenHook();
		}

		if (this._$wrpFormTop || this._$btnOpen) {
			if (!this._$btnOpen) {
				this._$btnOpen = $(`<button class="btn btn-default ${this._isCompact ? "px-2" : ""}">Filter</button>`)
					.prependTo(this._$wrpFormTop);
			} else if (!this._$btnOpen.parent().length) {
				this._$btnOpen.prependTo(this._$wrpFormTop);
			}
			this._$btnOpen.click(() => this.show());
		}

		const sourceFilter = this._filters.find(it => it.header === FilterBox$1.SOURCE_HEADER);
		if (sourceFilter) {
			const selFnAlt = (val) => !SourceUtil.isNonstandardSource(val) && !PrereleaseUtil.hasSourceJson(val) && !BrewUtil2.hasSourceJson(val);
			const hkSelFn = () => {
				if (this._meta.isBrewDefaultHidden) sourceFilter.setTempFnSel(selFnAlt);
				else sourceFilter.setTempFnSel(null);
				sourceFilter.updateMiniPillClasses();
			};
			this._addHook("meta", "isBrewDefaultHidden", hkSelFn);
			hkSelFn();
		}

		if (this._$wrpMiniPills) this._filters.map((f, i) => f.$renderMinis({filterBox: this, isFirst: i === 0, $wrpMini: this._$wrpMiniPills}));
	}

	async _render_pRenderModal () {
		this._isModalRendered = true;

		this._modalMeta = await UiUtil.pGetShowModal({
			isHeight100: true,
			isWidth100: true,
			isUncappedHeight: true,
			isIndestructible: true,
			isClosed: true,
			isEmpty: true,
			title: "Filter", 			cbClose: (isDataEntered) => this._pHandleHide(!isDataEntered),
		});

		const $children = this._filters.map((f, i) => f.$render({filterBox: this, isFirst: i === 0, $wrpMini: this._$wrpMiniPills}));

		this._metaIptSearch = ComponentUiUtil.$getIptStr(
			this._compSearch, "search",
			{decorationRight: "clear", asMeta: true, html: `<input class="form-control input-xs" placeholder="Search...">`},
		);
		this._compSearch._addHookBase("search", () => {
			const searchTerm = this._compSearch._state.search.toLowerCase();
			this._filters.forEach(f => f.handleSearch(searchTerm));
		});

		const $btnShowAllFilters = $(`<button class="btn btn-xs btn-default">Show All</button>`)
			.click(() => this.showAllFilters());
		const $btnHideAllFilters = $(`<button class="btn btn-xs btn-default">Hide All</button>`)
			.click(() => this.hideAllFilters());

		const $btnReset = $(`<button class="btn btn-xs btn-default mr-3" title="${FilterBox$1.TITLE_BTN_RESET}">Reset</button>`)
			.click(evt => this.reset(evt.shiftKey));

		const $btnSettings = $(`<button class="btn btn-xs btn-default mr-3"><span class="glyphicon glyphicon-cog"></span></button>`)
			.click(() => this._pOpenSettingsModal());

		const $btnSaveAlt = $(`<button class="btn btn-xs btn-primary" title="Save"><span class="glyphicon glyphicon-ok"></span></button>`)
			.click(() => this._modalMeta.doClose(true));

		const $wrpBtnCombineFilters = $(`<div class="btn-group mr-3"></div>`);
		const $btnCombineFilterSettings = $(`<button class="btn btn-xs btn-default"><span class="glyphicon glyphicon-cog"></span></button>`)
			.click(() => this._pOpenCombineAsModal());

		const btnCombineFiltersAs = e_({
			tag: "button",
			clazz: `btn btn-xs btn-default`,
			click: () => this._meta.modeCombineFilters = FilterBox$1._COMBINE_MODES.getNext(this._meta.modeCombineFilters),
			title: `"AND" requires every filter to match. "OR" requires any filter to match. "Custom" allows you to specify a combination (every "AND" filter must match; only one "OR" filter must match) .`,
		}).appendTo($wrpBtnCombineFilters[0]);

		const hook = () => {
			btnCombineFiltersAs.innerText = this._meta.modeCombineFilters === "custom" ? this._meta.modeCombineFilters.uppercaseFirst() : this._meta.modeCombineFilters.toUpperCase();
			if (this._meta.modeCombineFilters === "custom") $wrpBtnCombineFilters.append($btnCombineFilterSettings);
			else $btnCombineFilterSettings.detach();
			this._doSaveStateThrottled();
		};
		this._addHook("meta", "modeCombineFilters", hook);
		hook();

		const $btnSave = $(`<button class="btn btn-primary fltr__btn-close mr-2">Save</button>`)
			.click(() => this._modalMeta.doClose(true));

		const $btnCancel = $(`<button class="btn btn-default fltr__btn-close">Cancel</button>`)
			.click(() => this._modalMeta.doClose(false));

		$$(this._modalMeta.$modal)`<div class="split mb-2 mt-2 ve-flex-v-center mobile__ve-flex-col">
			<div class="ve-flex-v-baseline mobile__ve-flex-col">
				<h4 class="m-0 mr-2 mobile__mb-2">Filters</h4>
				${this._metaIptSearch.$wrp.addClass("mobile__mb-2")}
			</div>
			<div class="ve-flex-v-center mobile__ve-flex-col">
				<div class="ve-flex-v-center mobile__m-1">
					<div class="mr-2">Combine as</div>
					${$wrpBtnCombineFilters}
				</div>
				<div class="ve-flex-v-center mobile__m-1">
					<div class="btn-group mr-2 ve-flex-h-center">
						${$btnShowAllFilters}
						${$btnHideAllFilters}
					</div>
					${$btnReset}
					${$btnSettings}
					${$btnSaveAlt}
				</div>
			</div>
		</div>
		<hr class="w-100 m-0 mb-2">

		<hr class="mt-1 mb-1">
		<div class="ui-modal__scroller smooth-scroll px-1">
			${$children}
		</div>
		<hr class="my-1 w-100">
		<div class="w-100 ve-flex-vh-center my-1">${$btnSave}${$btnCancel}</div>`;
	}

	async _pOpenSettingsModal () {
		const {$modalInner} = await UiUtil.pGetShowModal({title: "Settings"});

		UiUtil.$getAddModalRowCb($modalInner, "Deselect Homebrew Sources by Default", this._meta, "isBrewDefaultHidden");

		UiUtil.addModalSep($modalInner);

		UiUtil.$getAddModalRowHeader($modalInner, "Hide summary for filter...", {helpText: "The summary is the small red and blue button panel which appear below the search bar."});
		this._filters.forEach(f => UiUtil.$getAddModalRowCb($modalInner, f.header, this._minisHidden, f.header));

		UiUtil.addModalSep($modalInner);

		const $rowResetAlwaysSave = UiUtil.$getAddModalRow($modalInner, "div").addClass("pr-2");
		$rowResetAlwaysSave.append(`<span>Always Save on Close</span>`);
		$(`<button class="btn btn-xs btn-default">Reset</button>`)
			.appendTo($rowResetAlwaysSave)
			.click(async () => {
				await StorageUtil.pRemove(FilterBox$1._STORAGE_KEY_ALWAYS_SAVE_UNCHANGED);
				JqueryUtil.doToast("Saved!");
			});
	}

	async _pOpenCombineAsModal () {
		const {$modalInner} = await UiUtil.pGetShowModal({title: "Filter Combination Logic"});
		const $btnReset = $(`<button class="btn btn-xs btn-default">Reset</button>`)
			.click(() => {
				Object.keys(this._combineAs).forEach(k => this._combineAs[k] = "and");
				$sels.forEach($sel => $sel.val("0"));
			});
		UiUtil.$getAddModalRowHeader($modalInner, "Combine filters as...", {$eleRhs: $btnReset});
		const $sels = this._filters.map(f => UiUtil.$getAddModalRowSel($modalInner, f.header, this._combineAs, f.header, ["and", "or"], {fnDisplay: (it) => it.toUpperCase()}));
	}

	getValues ({nxtStateOuter = null} = {}) {
		const outObj = {};
		this._filters.forEach(f => Object.assign(outObj, f.getValues({nxtState: nxtStateOuter?.filters})));
		return outObj;
	}

	addEventListener (type, listener) {
		(this._$wrpFormTop ? this._$wrpFormTop[0] : this._$btnOpen[0]).addEventListener(type, listener);
	}

	_mutNextState_reset_meta ({tgt}) {
		Object.assign(tgt, this._getDefaultMeta());
	}

	_mutNextState_minisHidden ({tgt}) {
		Object.assign(tgt, this._getDefaultMinisHidden(tgt));
	}

	_mutNextState_combineAs ({tgt}) {
		Object.assign(tgt, this._getDefaultCombineAs(tgt));
	}

	_reset_meta () {
		const nxtBoxState = this._getNextBoxState_base();
		this._mutNextState_reset_meta({tgt: nxtBoxState.meta});
		this._setBoxStateFromNextBoxState(nxtBoxState);
	}

	_reset_minisHidden () {
		const nxtBoxState = this._getNextBoxState_base();
		this._mutNextState_minisHidden({tgt: nxtBoxState.minisHidden});
		this._setBoxStateFromNextBoxState(nxtBoxState);
	}

	_reset_combineAs () {
		const nxtBoxState = this._getNextBoxState_base();
		this._mutNextState_combineAs({tgt: nxtBoxState.combineAs});
		this._setBoxStateFromNextBoxState(nxtBoxState);
	}

	reset (isResetAll) {
		this._filters.forEach(f => f.reset({isResetAll}));
		if (isResetAll) {
			this._reset_meta();
			this._reset_minisHidden();
			this._reset_combineAs();
		}
		this.render();
		this.fireChangeEvent();
	}

	async show () {
		if (!this._isModalRendered) await this._render_pRenderModal();
		this._cachedState = this._getSaveableState();
		this._modalMeta.doOpen();
		if (this._metaIptSearch?.$ipt) this._metaIptSearch.$ipt.focus();
	}

	async _pHandleHide (isCancel = false) {
		if (this._cachedState && isCancel) {
			const curState = this._getSaveableState();
			const hasChanges = !CollectionUtil.deepEquals(curState, this._cachedState);

			if (hasChanges) {
				const isSave = await InputUiUtil.pGetUserBoolean({
					title: "Unsaved Changes",
					textYesRemember: "Always Save",
					textYes: "Save",
					textNo: "Discard",
					storageKey: FilterBox$1._STORAGE_KEY_ALWAYS_SAVE_UNCHANGED,
					isGlobal: true,
				});
				if (isSave) {
					this._cachedState = null;
					this.fireChangeEvent();
					return;
				} else this._setStateFromLoaded(this._cachedState);
			}
		} else {
			this.fireChangeEvent();
		}

		this._cachedState = null;
	}

	showAllFilters () {
		this._filters.forEach(f => f.show());
	}

	hideAllFilters () {
		this._filters.forEach(f => f.hide());
	}

	unpackSubHashes (subHashes, {force = false} = {}) {
				const unpacked = {};
		subHashes.forEach(s => {
			const unpackedPart = UrlUtil.unpackSubHash(s, true);
			if (Object.keys(unpackedPart).length > 1) throw new Error(`Multiple keys in subhash!`);
			const k = Object.keys(unpackedPart)[0];
			unpackedPart[k] = {clean: unpackedPart[k], raw: s};
			Object.assign(unpacked, unpackedPart);
		});

		const urlHeaderToFilter = {};
		this._filters.forEach(f => {
			const childFilters = f.getChildFilters();
			if (childFilters.length) childFilters.forEach(f => urlHeaderToFilter[f.header.toLowerCase()] = f);
			urlHeaderToFilter[f.header.toLowerCase()] = f;
		});

		const urlHeadersUpdated = new Set();
		const subHashesConsumed = new Set();
		let filterInitialSearch;

		const filterBoxState = {};
		const statePerFilter = {};
		const prefixLen = this.getNamespacedHashKey().length;
		Object.entries(unpacked)
			.forEach(([hashKey, data]) => {
				const rawPrefix = hashKey.substring(0, prefixLen);
				const prefix = rawPrefix.substring(0, FilterUtil.SUB_HASH_PREFIX_LENGTH);

				const urlHeader = hashKey.substring(prefixLen);

				if (FilterUtil.SUB_HASH_PREFIXES.has(prefix) && urlHeaderToFilter[urlHeader]) {
					(statePerFilter[urlHeader] = statePerFilter[urlHeader] || {})[prefix] = data.clean;
					urlHeadersUpdated.add(urlHeader);
					subHashesConsumed.add(data.raw);
					return;
				}

				if (Object.values(FilterBox$1._SUB_HASH_PREFIXES).includes(prefix)) {
										if (prefix === VeCt.FILTER_BOX_SUB_HASH_SEARCH_PREFIX) filterInitialSearch = data.clean[0];
					else filterBoxState[prefix] = data.clean;
					subHashesConsumed.add(data.raw);
					return;
				}

				if (FilterUtil.SUB_HASH_PREFIXES.has(prefix)) throw new Error(`Could not find filter with header ${urlHeader} for subhash ${data.raw}`);
			});

		if (!subHashesConsumed.size && !force) return null;

		return {
			urlHeaderToFilter,
			filterBoxState,
			statePerFilter,
			urlHeadersUpdated,
			unpacked,
			subHashesConsumed,
			filterInitialSearch,
		};
	}

	setFromSubHashes (subHashes, {force = false, $iptSearch = null} = {}) {
		const unpackedSubhashes = this.unpackSubHashes(subHashes, {force});

		if (unpackedSubhashes == null) return subHashes;

		const {
			unpacked,
			subHashesConsumed,
			filterInitialSearch,
		} = unpackedSubhashes;

				const {box: nxtStateBox, filters: nxtStatesFilters} = this.getNextStateFromSubHashes({unpackedSubhashes});

		this._setBoxStateFromNextBoxState(nxtStateBox);

		this._filters
			.flatMap(f => [
				f,
				...f.getChildFilters(),
			])
			.filter(filter => nxtStatesFilters[filter.header])
			.forEach(filter => filter.setStateFromNextState(nxtStatesFilters));
		
				if (filterInitialSearch && ($iptSearch || this._$iptSearch)) ($iptSearch || this._$iptSearch).val(filterInitialSearch).change().keydown().keyup().trigger("instantKeyup");
		
				const [link] = Hist.getHashParts();

		const outSub = [];
		Object.values(unpacked)
			.filter(v => !subHashesConsumed.has(v.raw))
			.forEach(v => outSub.push(v.raw));

		Hist.setSuppressHistory(true);
		Hist.replaceHistoryHash(`${link}${outSub.length ? `${HASH_PART_SEP}${outSub.join(HASH_PART_SEP)}` : ""}`);

		this.fireChangeEvent();
		Hist.hashChange({isBlankFilterLoad: true});
		return outSub;
			}

	getNextStateFromSubHashes ({unpackedSubhashes}) {
		const {
			urlHeaderToFilter,
			filterBoxState,
			statePerFilter,
			urlHeadersUpdated,
		} = unpackedSubhashes;

		const nxtStateBox = this._getNextBoxStateFromSubHashes(urlHeaderToFilter, filterBoxState);

		const nxtStateFilters = {};

		Object.entries(statePerFilter)
			.forEach(([urlHeader, state]) => {
				const filter = urlHeaderToFilter[urlHeader];
				Object.assign(nxtStateFilters, filter.getNextStateFromSubhashState(state));
			});

				Object.keys(urlHeaderToFilter)
			.filter(k => !urlHeadersUpdated.has(k))
			.forEach(k => {
				const filter = urlHeaderToFilter[k];
				Object.assign(nxtStateFilters, filter.getNextStateFromSubhashState(null));
			});

		return {box: nxtStateBox, filters: nxtStateFilters};
	}

	_getNextBoxState_base () {
		return {
			meta: MiscUtil.copyFast(this.__meta),
			minisHidden: MiscUtil.copyFast(this.__minisHidden),
			combineAs: MiscUtil.copyFast(this.__combineAs),
		};
	}

	_getNextBoxStateFromSubHashes (urlHeaderToFilter, filterBoxState) {
		const nxtBoxState = this._getNextBoxState_base();

		let hasMeta = false;
		let hasMinisHidden = false;
		let hasCombineAs = false;

		Object.entries(filterBoxState).forEach(([k, vals]) => {
			const mappedK = this.getNamespacedHashKey(Parser._parse_bToA(FilterBox$1._SUB_HASH_PREFIXES, k));
			switch (mappedK) {
				case "meta": {
					hasMeta = true;
					const data = vals.map(v => UrlUtil.mini.decompress(v));
					Object.keys(this._getDefaultMeta()).forEach((k, i) => nxtBoxState.meta[k] = data[i]);
					break;
				}
				case "minisHidden": {
					hasMinisHidden = true;
					Object.keys(nxtBoxState.minisHidden).forEach(k => nxtBoxState.minisHidden[k] = false);
					vals.forEach(v => {
						const [urlHeader, isHidden] = v.split("=");
						const filter = urlHeaderToFilter[urlHeader];
						if (!filter) throw new Error(`Could not find filter with name "${urlHeader}"`);
						nxtBoxState.minisHidden[filter.header] = !!Number(isHidden);
					});
					break;
				}
				case "combineAs": {
					hasCombineAs = true;
					Object.keys(nxtBoxState.combineAs).forEach(k => nxtBoxState.combineAs[k] = "and");
					vals.forEach(v => {
						const [urlHeader, ixCombineMode] = v.split("=");
						const filter = urlHeaderToFilter[urlHeader];
						if (!filter) throw new Error(`Could not find filter with name "${urlHeader}"`);
						nxtBoxState.combineAs[filter.header] = FilterBox$1._COMBINE_MODES[ixCombineMode] || FilterBox$1._COMBINE_MODES[0];
					});
					break;
				}
			}
		});

		if (!hasMeta) this._mutNextState_reset_meta({tgt: nxtBoxState.meta});
		if (!hasMinisHidden) this._mutNextState_minisHidden({tgt: nxtBoxState.minisHidden});
		if (!hasCombineAs) this._mutNextState_combineAs({tgt: nxtBoxState.combineAs});

		return nxtBoxState;
	}

	_setBoxStateFromNextBoxState (nxtBoxState) {
		this._proxyAssignSimple("meta", nxtBoxState.meta, true);
		this._proxyAssignSimple("minisHidden", nxtBoxState.minisHidden, true);
		this._proxyAssignSimple("combineAs", nxtBoxState.combineAs, true);
	}

		getSubHashes (opts) {
		opts = opts || {};
		const out = [];
		const boxSubHashes = this.getBoxSubHashes();
		if (boxSubHashes) out.push(boxSubHashes);
		out.push(...this._filters.map(f => f.getSubHashes()).filter(Boolean));
		if (opts.isAddSearchTerm && this._$iptSearch) {
			const searchTerm = UrlUtil.encodeForHash(this._$iptSearch.val().trim());
			if (searchTerm) out.push(UrlUtil.packSubHash(this._getSubhashPrefix("search"), [searchTerm]));
		}
		return out.flat();
	}

	getBoxSubHashes () {
		const out = [];

		const defaultMeta = this._getDefaultMeta();

				const anyNotDefault = Object.keys(defaultMeta).find(k => this._meta[k] !== defaultMeta[k]);
		if (anyNotDefault) {
			const serMeta = Object.keys(defaultMeta).map(k => UrlUtil.mini.compress(this._meta[k] === undefined ? defaultMeta[k] : this._meta[k]));
			out.push(UrlUtil.packSubHash(this._getSubhashPrefix("meta"), serMeta));
		}

				const setMinisHidden = Object.entries(this._minisHidden).filter(([k, v]) => !!v).map(([k]) => `${k.toUrlified()}=1`);
		if (setMinisHidden.length) {
			out.push(UrlUtil.packSubHash(this._getSubhashPrefix("minisHidden"), setMinisHidden));
		}

				const setCombineAs = Object.entries(this._combineAs).filter(([k, v]) => v !== FilterBox$1._COMBINE_MODES[0]).map(([k, v]) => `${k.toUrlified()}=${FilterBox$1._COMBINE_MODES.indexOf(v)}`);
		if (setCombineAs.length) {
			out.push(UrlUtil.packSubHash(this._getSubhashPrefix("combineAs"), setCombineAs));
		}

		return out.length ? out : null;
	}

	getFilterTag () {
		const parts = this._filters.map(f => f.getFilterTagPart()).filter(Boolean);
		return `{@filter |${UrlUtil.getCurrentPage().replace(/\.html$/, "")}|${parts.join("|")}}`;
	}

	getDisplayState ({nxtStateOuter = null} = {}) {
		return this._filters
			.map(filter => filter.getDisplayStatePart({nxtState: nxtStateOuter?.filters}))
			.filter(Boolean)
			.join("; ");
	}

	setFromValues (values) {
		this._filters.forEach(it => it.setFromValues(values));
		this.fireChangeEvent();
	}

	toDisplay (boxState, ...entryVals) {
		return this._toDisplay(boxState, this._filters, entryVals);
	}

		toDisplayByFilters (boxState, ...filterToValueTuples) {
		return this._toDisplay(
			boxState,
			filterToValueTuples.map(it => it.filter),
			filterToValueTuples.map(it => it.value),
		);
	}

	_toDisplay (boxState, filters, entryVals) {
		switch (this._meta.modeCombineFilters) {
			case "and": return this._toDisplay_isAndDisplay(boxState, filters, entryVals);
			case "or": return this._toDisplay_isOrDisplay(boxState, filters, entryVals);
			case "custom": {
				if (entryVals.length !== filters.length) throw new Error(`Number of filters and number of values did not match!`);

				const andFilters = [];
				const andValues = [];
				const orFilters = [];
				const orValues = [];

				for (let i = 0; i < filters.length; ++i) {
					const f = filters[i];
					if (!this._combineAs[f.header] || this._combineAs[f.header] === "and") { 						andFilters.push(f);
						andValues.push(entryVals[i]);
					} else {
						orFilters.push(f);
						orValues.push(entryVals[i]);
					}
				}

				return this._toDisplay_isAndDisplay(boxState, andFilters, andValues) && this._toDisplay_isOrDisplay(boxState, orFilters, orValues);
			}
			default: throw new Error(`Unhandled combining mode "${this._meta.modeCombineFilters}"`);
		}
	}

	_toDisplay_isAndDisplay (boxState, filters, vals) {
		return filters
			.map((f, i) => f.toDisplay(boxState, vals[i]))
			.every(it => it);
	}

	_toDisplay_isOrDisplay (boxState, filters, vals) {
		const res = filters.map((f, i) => {
						if (!f.isActive(boxState)) return null;
			return f.toDisplay(boxState, vals[i]);
		}).filter(it => it != null);
		return res.length === 0 || res.find(it => it);
	}

	_getSubhashPrefix (prop) {
		if (FilterBox$1._SUB_HASH_PREFIXES[prop]) return this.getNamespacedHashKey(FilterBox$1._SUB_HASH_PREFIXES[prop]);
		throw new Error(`Unknown property "${prop}"`);
	}

	_getDefaultMeta () {
		const out = MiscUtil.copy(FilterBox$1._DEFAULT_META);
		if (this._isCompact) out.isSummaryHidden = true;
		return out;
	}

	_getDefaultMinisHidden (minisHidden) {
		if (!minisHidden) throw new Error(`Missing "minisHidden" argument!`);
		return Object.keys(minisHidden)
			.mergeMap(k => ({[k]: false}));
	}

	_getDefaultCombineAs (combineAs) {
		if (!combineAs) throw new Error(`Missing "combineAs" argument!`);
		return Object.keys(combineAs)
			.mergeMap(k => ({[k]: "and"}));
	}
};
FilterBox$1.EVNT_VALCHANGE = "valchange";
FilterBox$1.SOURCE_HEADER = "Source";
FilterBox$1._PILL_STATES = ["ignore", "yes", "no"];
FilterBox$1._COMBINE_MODES = ["and", "or", "custom"];
FilterBox$1._STORAGE_KEY = "filterBoxState";
FilterBox$1._DEFAULT_META = {
	modeCombineFilters: "and",
	isSummaryHidden: false,
	isBrewDefaultHidden: false,
};
FilterBox$1._STORAGE_KEY_ALWAYS_SAVE_UNCHANGED = "filterAlwaysSaveUnchanged";

FilterBox$1._SUB_HASH_BOX_META_PREFIX = "fbmt";
FilterBox$1._SUB_HASH_BOX_MINIS_HIDDEN_PREFIX = "fbmh";
FilterBox$1._SUB_HASH_BOX_COMBINE_AS_PREFIX = "fbca";
FilterBox$1._SUB_HASH_PREFIXES = {
	meta: FilterBox$1._SUB_HASH_BOX_META_PREFIX,
	minisHidden: FilterBox$1._SUB_HASH_BOX_MINIS_HIDDEN_PREFIX,
	combineAs: FilterBox$1._SUB_HASH_BOX_COMBINE_AS_PREFIX,
	search: VeCt.FILTER_BOX_SUB_HASH_SEARCH_PREFIX,
};

let FilterItem$1 = class FilterItem {
		constructor (options) {
		this.item = options.item;
		this.pFnChange = options.pFnChange;
		this.group = options.group;
		this.nest = options.nest;
		this.nestHidden = options.nestHidden;
		this.isIgnoreRed = options.isIgnoreRed;
		this.userData = options.userData;

		this.rendered = null;
		this.searchText = null;
	}
};

class FilterBase extends BaseComponent {
		constructor (opts) {
		super();
		this._filterBox = null;

		this.header = opts.header;
		this._headerHelp = opts.headerHelp;

		this.__meta = {...this.getDefaultMeta()};
		this._meta = this._getProxy("meta", this.__meta);
	}

	_getRenderedHeader () {
		return `<span ${this._headerHelp ? `title="${this._headerHelp.escapeQuotes()}" class="help-subtle"` : ""}>${this.header}</span>`;
	}

	set filterBox (it) { this._filterBox = it; }

	show () { this._meta.isHidden = false; }

	hide () { this._meta.isHidden = true; }

	getBaseSaveableState () { return {meta: {...this.__meta}}; }

	_getNextState_base () {
		return {
			[this.header]: {
				state: MiscUtil.copyFast(this.__state),
				meta: MiscUtil.copyFast(this.__meta),
			},
		};
	}

	setStateFromNextState (nxtState) {
		this._proxyAssignSimple("state", nxtState[this.header].state, true);
		this._proxyAssignSimple("meta", nxtState[this.header].meta, true);
	}

	reset ({isResetAll = false} = {}) {
		const nxtState = this._getNextState_base();
		this._mutNextState_reset(nxtState, {isResetAll});
		this.setStateFromNextState(nxtState);
	}

	_mutNextState_resetBase (nxtState, {isResetAll = false} = {}) {
		Object.assign(nxtState[this.header].meta, MiscUtil.copy(this.getDefaultMeta()));
	}

	getMetaSubHashes () {
		const compressedMeta = this._getCompressedMeta();
		if (!compressedMeta) return null;
		return [UrlUtil.packSubHash(this.getSubHashPrefix("meta", this.header), compressedMeta)];
	}

	_mutNextState_meta_fromSubHashState (nxtState, subHashState) {
		const hasMeta = this._mutNextState_meta_fromSubHashState_mutGetHasMeta(nxtState, subHashState, this.getDefaultMeta());
		if (!hasMeta) this._mutNextState_resetBase(nxtState);
	}

	_mutNextState_meta_fromSubHashState_mutGetHasMeta (nxtState, state, defaultMeta) {
		let hasMeta = false;

		Object.entries(state)
			.forEach(([k, vals]) => {
				const prop = FilterBase.getProp(k);
				if (prop !== "meta") return;

				hasMeta = true;
				const data = vals.map(v => UrlUtil.mini.decompress(v));
				Object.keys(defaultMeta).forEach((k, i) => {
					if (data[i] !== undefined) nxtState[this.header].meta[k] = data[i];
					else nxtState[this.header].meta[k] = defaultMeta[k];
				});
			});

		return hasMeta;
	}

	setBaseStateFromLoaded (toLoad) { Object.assign(this._meta, toLoad.meta); }

	getSubHashPrefix (prop, header) {
		if (FilterBase._SUB_HASH_PREFIXES[prop]) {
			const prefix = this._filterBox.getNamespacedHashKey(FilterBase._SUB_HASH_PREFIXES[prop]);
			return `${prefix}${header.toUrlified()}`;
		}
		throw new Error(`Unknown property "${prop}"`);
	}

	static getProp (prefix) {
		return Parser._parse_bToA(FilterBase._SUB_HASH_PREFIXES, prefix);
	}

	_getBtnMobToggleControls (wrpControls) {
		const btnMobToggleControls = e_({
			tag: "button",
			clazz: `btn btn-xs btn-default mobile__visible ml-auto px-3 mr-2`,
			html: `<span class="glyphicon glyphicon-option-vertical"></span>`,
			click: () => this._meta.isMobileHeaderHidden = !this._meta.isMobileHeaderHidden,
		});
		const hkMobHeaderHidden = () => {
			btnMobToggleControls.toggleClass("active", !this._meta.isMobileHeaderHidden);
			wrpControls.toggleClass("mobile__hidden", !!this._meta.isMobileHeaderHidden);
		};
		this._addHook("meta", "isMobileHeaderHidden", hkMobHeaderHidden);
		hkMobHeaderHidden();

		return btnMobToggleControls;
	}

	getChildFilters () { return []; }
	getDefaultMeta () { return {...FilterBase._DEFAULT_META}; }

		isActive (vals) {
		vals = vals || this.getValues();
		return vals[this.header]._isActive;
	}

	_getCompressedMeta ({isStripUiKeys = false} = {}) {
		const defaultMeta = this.getDefaultMeta();
		const isAnyNotDefault = Object.keys(defaultMeta).some(k => this._meta[k] !== defaultMeta[k]);
		if (!isAnyNotDefault) return null;

		let keys = Object.keys(defaultMeta);

		if (isStripUiKeys) {
						const popCount = Object.keys(FilterBase._DEFAULT_META).length;
			if (popCount) keys = keys.slice(0, -popCount);
		}

				while (keys.length && defaultMeta[keys.last()] === this._meta[keys.last()]) keys.pop();

		return keys.map(k => UrlUtil.mini.compress(this._meta[k] === undefined ? defaultMeta[k] : this._meta[k]));
	}

	$render () { throw new Error(`Unimplemented!`); }
	$renderMinis () { throw new Error(`Unimplemented!`); }
	getValues ({nxtState = null} = {}) { throw new Error(`Unimplemented!`); }
	_mutNextState_reset () { throw new Error(`Unimplemented!`); }
	update () { throw new Error(`Unimplemented!`); }
	toDisplay () { throw new Error(`Unimplemented!`); }
	addItem () { throw new Error(`Unimplemented!`); }
		getSaveableState () { throw new Error(`Unimplemented!`); }
	setStateFromLoaded () { throw new Error(`Unimplemented!`); }
	getSubHashes () { throw new Error(`Unimplemented!`); }
	getNextStateFromSubhashState () { throw new Error(`Unimplemented!`); }
	setFromValues () { throw new Error(`Unimplemented!`); }
	handleSearch () { throw new Error(`Unimplemented`); }
	getFilterTagPart () { throw new Error(`Unimplemented`); }
	getDisplayStatePart ({nxtState = null} = {}) { throw new Error(`Unimplemented`); }
	_doTeardown () {  }
	trimState_ () {  }
}
FilterBase._DEFAULT_META = {
	isHidden: false,
	isMobileHeaderHidden: true,
};
FilterBase._SUB_HASH_STATE_PREFIX = "flst";
FilterBase._SUB_HASH_META_PREFIX = "flmt";
FilterBase._SUB_HASH_NESTS_HIDDEN_PREFIX = "flnh";
FilterBase._SUB_HASH_OPTIONS_PREFIX = "flop";
FilterBase._SUB_HASH_PREFIXES = {
	state: FilterBase._SUB_HASH_STATE_PREFIX,
	meta: FilterBase._SUB_HASH_META_PREFIX,
	nestsHidden: FilterBase._SUB_HASH_NESTS_HIDDEN_PREFIX,
	options: FilterBase._SUB_HASH_OPTIONS_PREFIX,
};

let Filter$1 = class Filter extends FilterBase {
	static _getAsFilterItems (items) {
		return items ? items.map(it => it instanceof FilterItem$1 ? it : new FilterItem$1({item: it})) : null;
	}

	static _validateItemNests (items, nests) {
		if (!nests) return;
		items = items.filter(it => it.nest);
		const noNest = items.find(it => !nests[it.nest]);
		if (noNest) throw new Error(`Filter does not have matching nest: "${noNest.item}" (call addNest first)`);
		const invalid = items.find(it => !it.nest || !nests[it.nest]);
		if (invalid) throw new Error(`Invalid nest: "${invalid.item}"`);
	}

		static _validateItemNest (item, nests) {
		if (!nests || !item.nest) return;
		if (!nests[item.nest]) throw new Error(`Filter does not have matching nest: "${item.item}" (call addNest first)`);
		if (!item.nest || !nests[item.nest]) throw new Error(`Invalid nest: "${item.item}"`);
	}

		constructor (opts) {
		super(opts);
		this._items = Filter$1._getAsFilterItems(opts.items || []);
		this.__itemsSet = new Set(this._items.map(it => it.item)); 		this._nests = opts.nests;
		this._displayFn = opts.displayFn;
		this._displayFnMini = opts.displayFnMini;
		this._displayFnTitle = opts.displayFnTitle;
		this._selFn = opts.selFn;
		this._selFnCache = null;
		this._deselFn = opts.deselFn;
		this._itemSortFn = opts.itemSortFn === undefined ? SortUtil.ascSort : opts.itemSortFn;
		this._itemSortFnMini = opts.itemSortFnMini;
		this._groupFn = opts.groupFn;
		this._minimalUi = opts.minimalUi;
		this._umbrellaItems = Filter$1._getAsFilterItems(opts.umbrellaItems);
		this._umbrellaExcludes = Filter$1._getAsFilterItems(opts.umbrellaExcludes);
		this._isSortByDisplayItems = !!opts.isSortByDisplayItems;
		this._isReprintedFilter = !!opts.isMiscFilter && this._items.some(it => it.item === "Reprinted");
		this._isSrdFilter = !!opts.isMiscFilter && this._items.some(it => it.item === "SRD");
		this._isBasicRulesFilter = !!opts.isMiscFilter && this._items.some(it => it.item === "Basic Rules");

		Filter$1._validateItemNests(this._items, this._nests);

		this._filterBox = null;
		this._items.forEach(it => this._defaultItemState(it));
		this.__$wrpFilter = null;
		this.__wrpPills = null;
		this.__wrpMiniPills = null;
		this.__$wrpNestHeadInner = null;
		this._updateNestSummary = null;
		this.__nestsHidden = {};
		this._nestsHidden = this._getProxy("nestsHidden", this.__nestsHidden);
		this._isNestsDirty = false;
		this._isItemsDirty = false;
		this._pillGroupsMeta = {};
	}

	get isReprintedFilter () { return this._isReprintedFilter; }
	get isSrdFilter () { return this._isSrdFilter; }
	get isBasicRulesFilter () { return this._isBasicRulesFilter; }

	getSaveableState () {
		return {
			[this.header]: {
				...this.getBaseSaveableState(),
				state: {...this.__state},
				nestsHidden: {...this.__nestsHidden},
			},
		};
	}

	setStateFromLoaded (filterState) {
		if (filterState && filterState[this.header]) {
			const toLoad = filterState[this.header];
			this.setBaseStateFromLoaded(toLoad);
			Object.assign(this._state, toLoad.state);
			Object.assign(this._nestsHidden, toLoad.nestsHidden);
		}
	}

	_getStateNotDefault ({nxtState = null} = {}) {
		const state = nxtState?.[this.header]?.state || this.__state;

		return Object.entries(state)
			.filter(([k, v]) => {
				if (k.startsWith("_")) return false;
				const defState = this._getDefaultState(k);
				return defState !== v;
			});
	}

	getSubHashes () {
		const out = [];

		const baseMeta = this.getMetaSubHashes();
		if (baseMeta) out.push(...baseMeta);

		const areNotDefaultState = this._getStateNotDefault();
		if (areNotDefaultState.length) {
						const serPillStates = areNotDefaultState.map(([k, v]) => `${k.toUrlified()}=${v}`);
			out.push(UrlUtil.packSubHash(this.getSubHashPrefix("state", this.header), serPillStates));
		}

		const areNotDefaultNestsHidden = Object.entries(this._nestsHidden).filter(([k, v]) => this._nests[k] && !(this._nests[k].isHidden === v));
		if (areNotDefaultNestsHidden.length) {
						const nestsHidden = areNotDefaultNestsHidden.map(([k]) => `${k.toUrlified()}=1`);
			out.push(UrlUtil.packSubHash(this.getSubHashPrefix("nestsHidden", this.header), nestsHidden));
		}

		if (!out.length) return null;

				out.push(UrlUtil.packSubHash(this.getSubHashPrefix("options", this.header), ["extend"]));
		return out;
	}

	getFilterTagPart () {
		const areNotDefaultState = this._getStateNotDefault();
		const compressedMeta = this._getCompressedMeta({isStripUiKeys: true});

						if (!areNotDefaultState.length && !compressedMeta) return null;

		const pt = Object.entries(this._state)
			.filter(([k]) => !k.startsWith("_"))
			.filter(([, v]) => v)
			.map(([k, v]) => `${v === 2 ? "!" : ""}${k}`)
			.join(";")
			.toLowerCase();

		return [
			this.header.toLowerCase(),
			pt,
			compressedMeta ? compressedMeta.join(HASH_SUB_LIST_SEP) : null,
		]
			.filter(it => it != null)
			.join("=");
	}

	getDisplayStatePart ({nxtState = null} = {}) {
		const state = nxtState?.[this.header]?.state || this.__state;

		const areNotDefaultState = this._getStateNotDefault({nxtState});

				if (!areNotDefaultState.length) return null;

		const ptState = Object.entries(state)
			.filter(([k]) => !k.startsWith("_"))
			.filter(([, v]) => v)
			.map(([k, v]) => {
				const item = this._items.find(item => `${item.item}` === k);
				if (!item) return null; 				return `${v === 2 ? "not " : ""}${this._displayFn ? this._displayFn(item.item, item) : item.item}`;
			})
			.filter(Boolean)
			.join(", ");

		if (!ptState) return null;

		return `${this.header}: ${ptState}`;
	}

		_getOptionsFromSubHashState (state) {
				const opts = {};
		Object.entries(state).forEach(([k, vals]) => {
			const prop = FilterBase.getProp(k);
			switch (prop) {
				case "options": {
					vals.forEach(val => {
						switch (val) {
							case "extend": {
								opts.isExtendDefaultState = true;
							}
						}
					});
				}
			}
		});
		return new FilterTransientOptions(opts);
	}

	setStateFromNextState (nxtState) {
		super.setStateFromNextState(nxtState);
		this._proxyAssignSimple("nestsHidden", nxtState[this.header].nestsHidden, true);
	}

	getNextStateFromSubhashState (state) {
		const nxtState = this._getNextState_base();

		if (state == null) {
			this._mutNextState_reset(nxtState);
			return nxtState;
		}

		this._mutNextState_meta_fromSubHashState(nxtState, state);
		const transientOptions = this._getOptionsFromSubHashState(state);

		let hasState = false;
		let hasNestsHidden = false;

		Object.entries(state).forEach(([k, vals]) => {
			const prop = FilterBase.getProp(k);
			switch (prop) {
				case "state": {
					hasState = true;
					if (transientOptions.isExtendDefaultState) {
						Object.keys(nxtState[this.header].state).forEach(k => nxtState[this.header].state[k] = this._getDefaultState(k));
					} else {
												Object.keys(nxtState[this.header].state).forEach(k => nxtState[this.header].state[k] = 0);
					}

					vals.forEach(v => {
						const [statePropLower, state] = v.split("=");
						const stateProp = Object.keys(nxtState[this.header].state).find(k => k.toLowerCase() === statePropLower);
						if (stateProp) nxtState[this.header].state[stateProp] = Number(state);
					});
					break;
				}
				case "nestsHidden": {
					hasNestsHidden = true;
					Object.keys(nxtState[this.header].nestsHidden).forEach(k => {
						const nestKey = Object.keys(this._nests).find(it => k.toLowerCase() === it.toLowerCase());
						nxtState[this.header].nestsHidden[k] = this._nests[nestKey] && this._nests[nestKey].isHidden;
					});
					vals.forEach(v => {
						const [nestNameLower, state] = v.split("=");
						const nestName = Object.keys(nxtState[this.header].nestsHidden).find(k => k.toLowerCase() === nestNameLower);
						if (nestName) nxtState[this.header].nestsHidden[nestName] = !!Number(state);
					});
					break;
				}
			}
		});

		if (!hasState) this._mutNextState_reset(nxtState);
		if (!hasNestsHidden && this._nests) this._mutNextState_resetNestsHidden({tgt: nxtState[this.header].nestsHidden});

		return nxtState;
	}

	setFromValues (values) {
		if (values[this.header]) {
			Object.keys(this._state).forEach(k => this._state[k] = 0);
			Object.assign(this._state, values[this.header]);
		}
	}

	setValue (k, v) { this._state[k] = v; }

	_mutNextState_resetNestsHidden ({tgt}) {
		if (!this._nests) return;
		Object.entries(this._nests).forEach(([nestName, nestMeta]) => tgt[nestName] = !!nestMeta.isHidden);
	}

	_defaultItemState (item) {
				this._state[item.item] = this._getDefaultState(item.item);
	}

	_getDefaultState (k) { return this._deselFn && this._deselFn(k) ? 2 : this._selFn && this._selFn(k) ? 1 : 0; }

	_getDisplayText (item) {
		return this._displayFn ? this._displayFn(item.item, item) : item.item;
	}

	_getDisplayTextMini (item) {
		return this._displayFnMini
			? this._displayFnMini(item.item, item)
			: this._getDisplayText(item);
	}

	_getPill (item) {
		const displayText = this._getDisplayText(item);

		const btnPill = e_({
			tag: "div",
			clazz: "fltr__pill",
			html: displayText,
			click: evt => this._getPill_handleClick({evt, item}),
			contextmenu: evt => this._getPill_handleContextmenu({evt, item}),
		});

		this._getPill_bindHookState({btnPill, item});

		item.searchText = displayText.toLowerCase();

		return btnPill;
	}

	_getPill_handleClick ({evt, item}) {
		if (evt.shiftKey) {
			this._doSetPillsClear();
		}

		if (++this._state[item.item] > 2) this._state[item.item] = 0;
	}

	_getPill_handleContextmenu ({evt, item}) {
		evt.preventDefault();

		if (evt.shiftKey) {
			this._doSetPillsClear();
		}

		if (--this._state[item.item] < 0) this._state[item.item] = 2;
	}

	_getPill_bindHookState ({btnPill, item}) {
		this._addHook("state", item.item, () => {
			const val = FilterBox$1._PILL_STATES[this._state[item.item]];
			btnPill.attr("state", val);
		})();
	}

	setTempFnSel (tempFnSel) {
		this._selFnCache = this._selFnCache || this._selFn;
		if (tempFnSel) this._selFn = tempFnSel;
		else this._selFn = this._selFnCache;
	}

	updateMiniPillClasses () {
		this._items.filter(it => it.btnMini).forEach(it => {
			const isDefaultDesel = this._deselFn && this._deselFn(it.item);
			const isDefaultSel = this._selFn && this._selFn(it.item);
			it.btnMini
				.toggleClass("fltr__mini-pill--default-desel", isDefaultDesel)
				.toggleClass("fltr__mini-pill--default-sel", isDefaultSel);
		});
	}

	_getBtnMini (item) {
		const toDisplay = this._getDisplayTextMini(item);

		const btnMini = e_({
			tag: "div",
			clazz: `fltr__mini-pill ${this._filterBox.isMinisHidden(this.header) ? "ve-hidden" : ""} ${this._deselFn && this._deselFn(item.item) ? "fltr__mini-pill--default-desel" : ""} ${this._selFn && this._selFn(item.item) ? "fltr__mini-pill--default-sel" : ""}`,
			html: toDisplay,
			title: `${this._displayFnTitle ? `${this._displayFnTitle(item.item, item)} (` : ""}Filter: ${this.header}${this._displayFnTitle ? ")" : ""}`,
			click: () => {
				this._state[item.item] = 0;
				this._filterBox.fireChangeEvent();
			},
		}).attr("state", FilterBox$1._PILL_STATES[this._state[item.item]]);

		const hook = () => {
			const val = FilterBox$1._PILL_STATES[this._state[item.item]];
			btnMini.attr("state", val);
						if (item.pFnChange) item.pFnChange(item.item, val);
		};
		this._addHook("state", item.item, hook);

		const hideHook = () => btnMini.toggleClass("ve-hidden", this._filterBox.isMinisHidden(this.header));
		this._filterBox.registerMinisHiddenHook(this.header, hideHook);

		return btnMini;
	}

	_doSetPillsAll () {
		this._proxyAssignSimple(
			"state",
			Object.keys(this._state)
				.mergeMap(k => ({[k]: 1})),
			true,
		);
	}

	_doSetPillsClear () {
		this._proxyAssignSimple(
			"state",
			Object.keys(this._state)
				.mergeMap(k => ({[k]: 0})),
			true,
		);
	}

	_doSetPillsNone () {
		this._proxyAssignSimple(
			"state",
			Object.keys(this._state)
				.mergeMap(k => ({[k]: 2})),
			true,
		);
	}

	_doSetPinsDefault () {
		this.reset();
	}

	_getHeaderControls (opts) {
		const btnAll = e_({
			tag: "button",
			clazz: `btn btn-default ${opts.isMulti ? "btn-xxs" : "btn-xs"} fltr__h-btn--all w-100`,
			click: () => this._doSetPillsAll(),
			html: "All",
		});
		const btnClear = e_({
			tag: "button",
			clazz: `btn btn-default ${opts.isMulti ? "btn-xxs" : "btn-xs"} fltr__h-btn--clear w-100`,
			click: () => this._doSetPillsClear(),
			html: "Clear",
		});
		const btnNone = e_({
			tag: "button",
			clazz: `btn btn-default ${opts.isMulti ? "btn-xxs" : "btn-xs"} fltr__h-btn--none w-100`,
			click: () => this._doSetPillsNone(),
			html: "None",
		});
		const btnDefault = e_({
			tag: "button",
			clazz: `btn btn-default ${opts.isMulti ? "btn-xxs" : "btn-xs"} w-100`,
			click: () => this._doSetPinsDefault(),
			html: "Default",
		});

		const wrpStateBtnsOuter = e_({
			tag: "div",
			clazz: "ve-flex-v-center fltr__h-wrp-state-btns-outer",
			children: [
				e_({
					tag: "div",
					clazz: "btn-group ve-flex-v-center w-100",
					children: [
						btnAll,
						btnClear,
						btnNone,
						btnDefault,
					],
				}),
			],
		});
		this._getHeaderControls_addExtraStateBtns(opts, wrpStateBtnsOuter);

		const wrpSummary = e_({tag: "div", clazz: "ve-flex-vh-center ve-hidden"});

		const btnCombineBlue = e_({
			tag: "button",
			clazz: `btn btn-default ${opts.isMulti ? "btn-xxs" : "btn-xs"} fltr__h-btn-logic--blue fltr__h-btn-logic w-100`,
			click: () => this._meta.combineBlue = Filter$1._getNextCombineMode(this._meta.combineBlue),
			title: `Blue match mode for this filter. "AND" requires all blues to match, "OR" requires at least one blue to match, "XOR" requires exactly one blue to match.`,
		});
		const hookCombineBlue = () => e_({ele: btnCombineBlue, text: `${this._meta.combineBlue}`.toUpperCase()});
		this._addHook("meta", "combineBlue", hookCombineBlue);
		hookCombineBlue();

		const btnCombineRed = e_({
			tag: "button",
			clazz: `btn btn-default ${opts.isMulti ? "btn-xxs" : "btn-xs"} fltr__h-btn-logic--red fltr__h-btn-logic w-100`,
			click: () => this._meta.combineRed = Filter$1._getNextCombineMode(this._meta.combineRed),
			title: `Red match mode for this filter. "AND" requires all reds to match, "OR" requires at least one red to match, "XOR" requires exactly one red to match.`,
		});
		const hookCombineRed = () => e_({ele: btnCombineRed, text: `${this._meta.combineRed}`.toUpperCase()});
		this._addHook("meta", "combineRed", hookCombineRed);
		hookCombineRed();

		const btnShowHide = e_({
			tag: "button",
			clazz: `btn btn-default ${opts.isMulti ? "btn-xxs" : "btn-xs"} ml-2`,
			click: () => this._meta.isHidden = !this._meta.isHidden,
			html: "Hide",
		});
		const hookShowHide = () => {
			e_({ele: btnShowHide}).toggleClass("active", this._meta.isHidden);
			wrpStateBtnsOuter.toggleVe(!this._meta.isHidden);

						const cur = this.getValues()[this.header];

			const htmlSummary = [
				cur._totals.yes
					? `<span class="fltr__summary_item fltr__summary_item--include" title="${cur._totals.yes} hidden &quot;required&quot; tags">${cur._totals.yes}</span>`
					: null,
				cur._totals.yes && cur._totals.no
					? `<span class="fltr__summary_item_spacer"></span>`
					: null,
				cur._totals.no
					? `<span class="fltr__summary_item fltr__summary_item--exclude" title="${cur._totals.no} hidden &quot;excluded&quot; tags">${cur._totals.no}</span>`
					: null,
			].filter(Boolean).join("");
			e_({ele: wrpSummary, html: htmlSummary}).toggleVe(this._meta.isHidden);
		};
		this._addHook("meta", "isHidden", hookShowHide);
		hookShowHide();

		return e_({
			tag: "div",
			clazz: `ve-flex-v-center fltr__h-wrp-btns-outer`,
			children: [
				wrpSummary,
				wrpStateBtnsOuter,
				e_({tag: "span", clazz: `btn-group ml-2 ve-flex-v-center`, children: [btnCombineBlue, btnCombineRed]}),
				btnShowHide,
			],
		});
	}

	_getHeaderControls_addExtraStateBtns () {
			}

		$render (opts) {
		this._filterBox = opts.filterBox;
		this.__wrpMiniPills = opts.$wrpMini ? e_({ele: opts.$wrpMini[0]}) : null;

		const wrpControls = this._getHeaderControls(opts);

		if (this._nests) {
			const wrpNestHead = e_({tag: "div", clazz: "fltr__wrp-pills--sub"}).appendTo(this.__wrpPills);
			this.__$wrpNestHeadInner = e_({tag: "div", clazz: "ve-flex ve-flex-wrap fltr__container-pills"}).appendTo(wrpNestHead);

			const wrpNestHeadSummary = e_({tag: "div", clazz: "fltr__summary_nest"}).appendTo(wrpNestHead);

			this._updateNestSummary = () => {
				const stats = {high: 0, low: 0};
				this._items.filter(it => this._state[it.item] && this._nestsHidden[it.nest]).forEach(it => {
					const key = this._state[it.item] === 1 ? "high" : "low";
					stats[key]++;
				});

				wrpNestHeadSummary.empty();

				if (stats.high) {
					e_({
						tag: "span",
						clazz: "fltr__summary_item fltr__summary_item--include",
						text: stats.high,
						title: `${stats.high} hidden "required" tag${stats.high === 1 ? "" : "s"}`,
					}).appendTo(wrpNestHeadSummary);
				}

				if (stats.high && stats.low) e_({tag: "span", clazz: "fltr__summary_item_spacer"}).appendTo(wrpNestHeadSummary);

				if (stats.low) {
					e_({
						tag: "span",
						clazz: "fltr__summary_item fltr__summary_item--exclude",
						text: stats.low,
						title: `${stats.low} hidden "excluded" tag${stats.low === 1 ? "" : "s"}`,
					}).appendTo(wrpNestHeadSummary);
				}
			};

			this._doRenderNests();
		}

		this._doRenderPills();

		const btnMobToggleControls = this._getBtnMobToggleControls(wrpControls);

		this.__$wrpFilter = $$`<div>
			${opts.isFirst ? "" : `<div class="fltr__dropdown-divider ${opts.isMulti ? "fltr__dropdown-divider--indented" : ""} mb-1"></div>`}
			<div class="split fltr__h ${this._minimalUi ? "fltr__minimal-hide" : ""} mb-1">
				<div class="fltr__h-text ve-flex-h-center mobile__w-100">
					${opts.isMulti ? `<span class="mr-2">\u2012</span>` : ""}
					${this._getRenderedHeader()}
					${btnMobToggleControls}
				</div>
				${wrpControls}
			</div>
			${this.__wrpPills}
		</div>`;

		this._doToggleDisplay();

		return this.__$wrpFilter;
	}

		$renderMinis (opts) {
		if (!opts.$wrpMini) return;

		this._filterBox = opts.filterBox;
		this.__wrpMiniPills = e_({ele: opts.$wrpMini[0]});

		this._renderMinis_initWrpPills();

		this._doRenderMiniPills();
	}

	_renderMinis_initWrpPills () {
		this.__wrpPills = e_({tag: "div", clazz: `fltr__wrp-pills ${this._groupFn ? "fltr__wrp-subs" : "fltr__container-pills"}`});
		const hook = () => this.__wrpPills.toggleVe(!this._meta.isHidden);
		this._addHook("meta", "isHidden", hook);
		hook();
	}

	getValues ({nxtState = null} = {}) {
		const state = MiscUtil.copy(nxtState?.[this.header]?.state || this.__state);
		const meta = nxtState?.[this.header]?.meta || this.__meta;

				Object.keys(state).filter(k => !this._items.some(it => `${it.item}` === k)).forEach(k => delete state[k]);
		const out = {...state};

				out._isActive = Object.values(state).some(Boolean);
		out._totals = {yes: 0, no: 0, ignored: 0};
		Object.values(state).forEach(v => {
			const totalKey = v === 0 ? "ignored" : v === 1 ? "yes" : "no";
			out._totals[totalKey]++;
		});
		out._combineBlue = meta.combineBlue;
		out._combineRed = meta.combineRed;
		return {[this.header]: out};
	}

	_getNextState_base () {
		return {
			[this.header]: {
				...super._getNextState_base()[this.header],
				nestsHidden: MiscUtil.copyFast(this.__nestsHidden),
			},
		};
	}

	_mutNextState_reset (nxtState, {isResetAll = false} = {}) {
		if (isResetAll) {
			this._mutNextState_resetBase(nxtState);
			this._mutNextState_resetNestsHidden({tgt: nxtState[this.header].nestsHidden});
		} else {
						Object.assign(nxtState[this.header].meta, {combineBlue: Filter$1._DEFAULT_META.combineBlue, combineRed: Filter$1._DEFAULT_META.combineRed});
		}
		Object.keys(nxtState[this.header].state).forEach(k => delete nxtState[this.header].state[k]);
		this._items.forEach(item => nxtState[this.header].state[item.item] = this._getDefaultState(item.item));
	}

	_doRenderPills () {
		if (this._itemSortFn) this._items.sort(this._isSortByDisplayItems && this._displayFn ? (a, b) => this._itemSortFn(this._displayFn(a.item, a), this._displayFn(b.item, b)) : this._itemSortFn);

		this._items.forEach(it => {
			if (!it.rendered) {
				it.rendered = this._getPill(it);
				if (it.nest) {
					const hook = () => it.rendered.toggleVe(!this._nestsHidden[it.nest]);
					this._addHook("nestsHidden", it.nest, hook);
					hook();
				}
			}

			if (this._groupFn) {
				const group = this._groupFn(it);
				this._doRenderPills_doRenderWrpGroup(group);
				this._pillGroupsMeta[group].wrpPills.append(it.rendered);
			} else it.rendered.appendTo(this.__wrpPills);
		});
	}

	_doRenderPills_doRenderWrpGroup (group) {
		const existingMeta = this._pillGroupsMeta[group];
		if (existingMeta && !existingMeta.isAttached) {
			existingMeta.hrDivider.appendTo(this.__wrpPills);
			existingMeta.wrpPills.appendTo(this.__wrpPills);
			existingMeta.isAttached = true;
		}
		if (existingMeta) return;

		this._pillGroupsMeta[group] = {
			hrDivider: this._doRenderPills_doRenderWrpGroup_getHrDivider(group).appendTo(this.__wrpPills),
			wrpPills: this._doRenderPills_doRenderWrpGroup_getWrpPillsSub(group).appendTo(this.__wrpPills),
			isAttached: true,
		};

		Object.entries(this._pillGroupsMeta)
			.sort((a, b) => SortUtil.ascSortLower(a[0], b[0]))
			.forEach(([groupKey, groupMeta], i) => {
				groupMeta.hrDivider.appendTo(this.__wrpPills);
				groupMeta.hrDivider.toggleVe(!this._isGroupDividerHidden(groupKey, i));
				groupMeta.wrpPills.appendTo(this.__wrpPills);
			});

		if (this._nests) {
			this._pillGroupsMeta[group].toggleDividerFromNestVisibility = () => {
				this._pillGroupsMeta[group].hrDivider.toggleVe(!this._isGroupDividerHidden(group));
			};

						Object.keys(this._nests).forEach(nestName => {
				const hook = () => this._pillGroupsMeta[group].toggleDividerFromNestVisibility();
				this._addHook("nestsHidden", nestName, hook);
				hook();
				this._pillGroupsMeta[group].toggleDividerFromNestVisibility();
			});
		}
	}

	_isGroupDividerHidden (group, ixSortedGroups) {
		if (!this._nests) {
						if (ixSortedGroups === undefined) return `${group}` === `${Object.keys(this._pillGroupsMeta).sort((a, b) => SortUtil.ascSortLower(a, b))[0]}`;
			return ixSortedGroups === 0;
		}

		const groupItems = this._items.filter(it => this._groupFn(it) === group);
		const hiddenGroupItems = groupItems.filter(it => this._nestsHidden[it.nest]);
		return groupItems.length === hiddenGroupItems.length;
	}

	_doRenderPills_doRenderWrpGroup_getHrDivider () { return e_({tag: "hr", clazz: `fltr__dropdown-divider--sub hr-2 mx-3`}); }
	_doRenderPills_doRenderWrpGroup_getWrpPillsSub () { return e_({tag: "div", clazz: `fltr__wrp-pills--sub fltr__container-pills`}); }

	_doRenderMiniPills () {
				const view = this._items.slice(0);
		if (this._itemSortFnMini || this._itemSortFn) {
			const fnSort = this._itemSortFnMini || this._itemSortFn;
			view.sort(this._isSortByDisplayItems && this._displayFn ? (a, b) => fnSort(this._displayFn(a.item, a), this._displayFn(b.item, b)) : fnSort);
		}

		if (this.__wrpMiniPills) {
			view.forEach(it => {
								(it.btnMini = it.btnMini || this._getBtnMini(it)).appendTo(this.__wrpMiniPills);
			});
		}
	}

	_doToggleDisplay () {
				if (this.__$wrpFilter) this.__$wrpFilter.toggleClass("fltr__no-items", !this._items.length);
	}

	_doRenderNests () {
		Object.entries(this._nests)
			.sort((a, b) => SortUtil.ascSort(a[0], b[0])) 			.forEach(([nestName, nestMeta]) => {
				if (nestMeta._$btnNest == null) {
										if (this._nestsHidden[nestName] == null) this._nestsHidden[nestName] = !!nestMeta.isHidden;

					const $btnText = $(`<span>${nestName} [${this._nestsHidden[nestName] ? "+" : "\u2212"}]</span>`);
					nestMeta._$btnNest = $$`<div class="fltr__btn_nest">${$btnText}</div>`
						.click(() => this._nestsHidden[nestName] = !this._nestsHidden[nestName]);

					const hook = () => {
						$btnText.text(`${nestName} [${this._nestsHidden[nestName] ? "+" : "\u2212"}]`);

						const stats = {high: 0, low: 0, total: 0};
						this._items
							.filter(it => it.nest === nestName)
							.find(it => {
								const key = this._state[it.item] === 1 ? "high" : this._state[it.item] ? "low" : "ignored";
								stats[key]++;
								stats.total++;
							});
						const allHigh = stats.total === stats.high;
						const allLow = stats.total === stats.low;
						nestMeta._$btnNest.toggleClass("fltr__btn_nest--include-all", this._nestsHidden[nestName] && allHigh)
							.toggleClass("fltr__btn_nest--exclude-all", this._nestsHidden[nestName] && allLow)
							.toggleClass("fltr__btn_nest--include", this._nestsHidden[nestName] && !!(!allHigh && !allLow && stats.high && !stats.low))
							.toggleClass("fltr__btn_nest--exclude", this._nestsHidden[nestName] && !!(!allHigh && !allLow && !stats.high && stats.low))
							.toggleClass("fltr__btn_nest--both", this._nestsHidden[nestName] && !!(!allHigh && !allLow && stats.high && stats.low));

						if (this._updateNestSummary) this._updateNestSummary();
					};

					this._items
						.filter(it => it.nest === nestName)
						.find(it => {
							this._addHook("state", it.item, hook);
						});

					this._addHook("nestsHidden", nestName, hook);
					hook();
				}
				nestMeta._$btnNest.appendTo(this.__$wrpNestHeadInner);
			});

		if (this._updateNestSummary) this._updateNestSummary();
	}

	update () {
		if (this._isNestsDirty) {
			this._isNestsDirty = false;

			this._doRenderNests();
		}

		if (this._isItemsDirty) {
			this._isItemsDirty = false;

			this._doRenderPills();
		}

				this._doRenderMiniPills();
		this._doToggleDisplay();
	}

	addItem (item) {
		if (item == null) return;

		if (item instanceof Array) {
			const len = item.length;
			for (let i = 0; i < len; ++i) this.addItem(item[i]);
			return;
		}

		if (!this.__itemsSet.has(item.item || item)) {
			item = item instanceof FilterItem$1 ? item : new FilterItem$1({item});
			Filter$1._validateItemNest(item, this._nests);

			this._isItemsDirty = true;
			this._items.push(item);
			this.__itemsSet.add(item.item);
			if (this._state[item.item] == null) this._defaultItemState(item);
		}
	}

	static _isItemsEqual (item1, item2) {
		return (item1 instanceof FilterItem$1 ? item1.item : item1) === (item2 instanceof FilterItem$1 ? item2.item : item2);
	}

	removeItem (item) {
		const ixItem = this._items.findIndex(it => Filter$1._isItemsEqual(it, item));
		if (~ixItem) {
			const item = this._items[ixItem];

						this._isItemsDirty = true;
			item.rendered.detach();
			item.btnMini.detach();
			this._items.splice(ixItem, 1);
		}
	}

	addNest (nestName, nestMeta) {
						if (!this._nests) throw new Error(`Filter was not nested!`);
		if (!this._nests[nestName]) {
			this._isNestsDirty = true;
			this._nests[nestName] = nestMeta;

						if (this._groupFn) {
				Object.keys(this._pillGroupsMeta).forEach(group => {
					const hook = () => this._pillGroupsMeta[group].toggleDividerFromNestVisibility();
					this._addHook("nestsHidden", nestName, hook);
					hook();
					this._pillGroupsMeta[group].toggleDividerFromNestVisibility();
				});
			}
		}
	}

	_toDisplay_getMappedEntryVal (entryVal) {
		if (!(entryVal instanceof Array)) entryVal = [entryVal];
		entryVal = entryVal.map(it => it instanceof FilterItem$1 ? it : new FilterItem$1({item: it}));
		return entryVal;
	}

	_toDisplay_getFilterState (boxState) { return boxState[this.header]; }

	toDisplay (boxState, entryVal) {
		const filterState = this._toDisplay_getFilterState(boxState);
		if (!filterState) return true;

		const totals = filterState._totals;

		entryVal = this._toDisplay_getMappedEntryVal(entryVal);

		const isUmbrella = () => {
			if (this._umbrellaItems) {
				if (!entryVal) return false;

				if (this._umbrellaExcludes && this._umbrellaExcludes.some(it => filterState[it.item])) return false;

				return this._umbrellaItems.some(u => entryVal.includes(u.item))
					&& (this._umbrellaItems.some(u => filterState[u.item] === 0) || this._umbrellaItems.some(u => filterState[u.item] === 1));
			}
		};

		let hide = false;
		let display = false;

		switch (filterState._combineBlue) {
			case "or": {
								if (totals.yes === 0) display = true;

								display = display || entryVal.some(fi => filterState[fi.item] === 1 || isUmbrella());

				break;
			}
			case "xor": {
								if (totals.yes === 0) display = true;

								display = display || entryVal.filter(fi => filterState[fi.item] === 1 || isUmbrella()).length === 1;

				break;
			}
			case "and": {
				const totalYes = entryVal.filter(fi => filterState[fi.item] === 1).length;
				display = !totals.yes || totals.yes === totalYes;

				break;
			}
			default: throw new Error(`Unhandled combine mode "${filterState._combineBlue}"`);
		}

		switch (filterState._combineRed) {
			case "or": {
								hide = hide || entryVal.filter(fi => !fi.isIgnoreRed).some(fi => filterState[fi.item] === 2);

				break;
			}
			case "xor": {
								hide = hide || entryVal.filter(fi => !fi.isIgnoreRed).filter(fi => filterState[fi.item] === 2).length === 1;

				break;
			}
			case "and": {
				const totalNo = entryVal.filter(fi => !fi.isIgnoreRed).filter(fi => filterState[fi.item] === 2).length;
				hide = totals.no && totals.no === totalNo;

				break;
			}
			default: throw new Error(`Unhandled combine mode "${filterState._combineRed}"`);
		}

		return display && !hide;
	}

	_doInvertPins () {
		const cur = MiscUtil.copy(this._state);
		Object.keys(this._state).forEach(k => this._state[k] = cur[k] === 1 ? 0 : 1);
	}

	getDefaultMeta () {
				return {
			...super.getDefaultMeta(),
			...Filter$1._DEFAULT_META,
		};
	}

	handleSearch (searchTerm) {
		const isHeaderMatch = this.header.toLowerCase().includes(searchTerm);

		if (isHeaderMatch) {
			this._items.forEach(it => {
				if (!it.rendered) return;
				it.rendered.toggleClass("fltr__hidden--search", false);
			});

			if (this.__$wrpFilter) this.__$wrpFilter.toggleClass("fltr__hidden--search", false);

			return true;
		}

		let visibleCount = 0;
		this._items.forEach(it => {
			if (!it.rendered) return;
			const isVisible = it.searchText.includes(searchTerm);
			it.rendered.toggleClass("fltr__hidden--search", !isVisible);
			if (isVisible) visibleCount++;
		});

		if (this.__$wrpFilter) this.__$wrpFilter.toggleClass("fltr__hidden--search", visibleCount === 0);

		return visibleCount !== 0;
	}

	static _getNextCombineMode (combineMode) {
		let ix = Filter$1._COMBINE_MODES.indexOf(combineMode);
		if (ix === -1) ix = (Filter$1._COMBINE_MODES.length - 1);
		if (++ix === Filter$1._COMBINE_MODES.length) ix = 0;
		return Filter$1._COMBINE_MODES[ix];
	}

	_doTeardown () {
		this._items.forEach(it => {
			if (it.rendered) it.rendered.detach();
			if (it.btnMini) it.btnMini.detach();
		});

		Object.values(this._nests || {})
			.filter(nestMeta => nestMeta._$btnNest)
			.forEach(nestMeta => nestMeta._$btnNest.detach());

		Object.values(this._pillGroupsMeta || {})
			.forEach(it => {
				it.hrDivider.detach();
				it.wrpPills.detach();
				it.isAttached = false;
			});
	}
};
Filter$1._DEFAULT_META = {
	combineBlue: "or",
	combineRed: "or",
};
Filter$1._COMBINE_MODES = ["or", "and", "xor"];

class FilterTransientOptions {
		constructor (opts) {
		this.isExtendDefaultState = opts.isExtendDefaultState;
	}
}

let SearchableFilter$1 = class SearchableFilter extends Filter$1 {
	constructor (opts) {
		super(opts);

		this._compSearch = BaseComponent.fromObject({
			search: "",
			searchTermParent: "",
		});
	}

	handleSearch (searchTerm) {
		const out = super.handleSearch(searchTerm);

		this._compSearch._state.searchTermParent = searchTerm;

		return out;
	}

	_getPill (item) {
		const btnPill = super._getPill(item);

		const hkIsVisible = () => {
			if (this._compSearch._state.searchTermParent) return btnPill.toggleClass("fltr__hidden--inactive", false);

			btnPill.toggleClass("fltr__hidden--inactive", this._state[item.item] === 0);
		};
		this._addHook("state", item.item, hkIsVisible);
		this._compSearch._addHookBase("searchTermParent", hkIsVisible);
		hkIsVisible();

		return btnPill;
	}

	_getPill_handleClick ({evt, item}) {
		if (this._compSearch._state.searchTermParent) return super._getPill_handleClick({evt, item});

		this._state[item.item] = 0;
	}

	_getPill_handleContextmenu ({evt, item}) {
		if (this._compSearch._state.searchTermParent) return super._getPill_handleContextmenu({evt, item});

		evt.preventDefault();
		this._state[item.item] = 0;
	}

	_$render_getRowBtn ({fnsCleanup, $iptSearch, item, subtype, state}) {
		const handleClick = evt => {
			evt.stopPropagation();
			evt.preventDefault();

						$iptSearch.focus();

			if (evt.shiftKey) {
				this._doSetPillsClear();
			}

			if (this._state[item.item] === state) this._state[item.item] = 0;
			else this._state[item.item] = state;
		};

		const btn = e_({
			tag: "div",
			clazz: `no-shrink clickable fltr-search__btn-activate fltr-search__btn-activate--${subtype} ve-flex-vh-center`,
			click: evt => handleClick(evt),
			contextmenu: evt => handleClick(evt),
			mousedown: evt => {
				evt.stopPropagation();
				evt.preventDefault();
			},
		});

		const hkIsActive = () => {
			btn.innerText = this._state[item.item] === state ? "×" : "";
		};
		this._addHookBase(item.item, hkIsActive);
		hkIsActive();
		fnsCleanup.push(() => this._removeHookBase(item.item, hkIsActive));

		return btn;
	}

	$render (opts) {
		const $out = super.$render(opts);

		const $iptSearch = ComponentUiUtil.$getIptStr(
			this._compSearch,
			"search",
			{
				html: `<input class="form-control form-control--minimal input-xs" placeholder="Search...">`,
			},
		);

		const wrpValues = e_({
			tag: "div",
			clazz: "overflow-y-auto bt-0 absolute fltr-search__wrp-values",
		});

		const fnsCleanup = [];
		const rowMetas = [];

		this._$render_bindSearchHandler_keydown({$iptSearch, fnsCleanup, rowMetas});
		this._$render_bindSearchHandler_focus({$iptSearch, fnsCleanup, rowMetas, wrpValues});
		this._$render_bindSearchHandler_blur({$iptSearch});

		const $wrp = $$`<div class="fltr-search__wrp-search ve-flex-col relative mt-1 mx-2p mb-1">
			${$iptSearch}
			${wrpValues}
		</div>`.prependTo(this.__wrpPills);

		const hkParentSearch = () => {
			$wrp.toggleVe(!this._compSearch._state.searchTermParent);
		};
		this._compSearch._addHookBase("searchTermParent", hkParentSearch);
		hkParentSearch();

		return $out;
	}

	_$render_bindSearchHandler_keydown ({$iptSearch, rowMetas}) {
		$iptSearch
			.on("keydown", evt => {
				switch (evt.key) {
					case "Escape": evt.stopPropagation(); return $iptSearch.blur();

					case "ArrowDown": {
						evt.preventDefault();
						const visibleRowMetas = rowMetas.filter(it => it.isVisible);
						if (!visibleRowMetas.length) return;
						visibleRowMetas[0].row.focus();
						break;
					}

					case "Enter": {
						const visibleRowMetas = rowMetas.filter(it => it.isVisible);
						if (!visibleRowMetas.length) return;
						if (evt.shiftKey) this._doSetPillsClear();
						this._state[visibleRowMetas[0].item.item] = (evt.ctrlKey || evt.metaKey) ? 2 : 1;
						$iptSearch.blur();
						break;
					}
				}
			});
	}

	_$render_bindSearchHandler_focus ({$iptSearch, fnsCleanup, rowMetas, wrpValues}) {
		$iptSearch
			.on("focus", () => {
				fnsCleanup
					.splice(0, fnsCleanup.length)
					.forEach(fn => fn());

				rowMetas.splice(0, rowMetas.length);

				wrpValues.innerHTML = "";

				rowMetas.push(
					...this._items
						.map(item => this._$render_bindSearchHandler_focus_getRowMeta({$iptSearch, fnsCleanup, rowMetas, wrpValues, item})),
				);

				this._$render_bindSearchHandler_focus_addHookSearch({rowMetas, fnsCleanup});

				wrpValues.scrollIntoView({block: "nearest", inline: "nearest"});
			});
	}

	_$render_bindSearchHandler_focus_getRowMeta ({$iptSearch, fnsCleanup, rowMetas, wrpValues, item}) {
		const dispName = this._getDisplayText(item);

		const eleName = e_({
			tag: "div",
			clazz: "fltr-search__disp-name ml-2",
		});

		const btnBlue = this._$render_getRowBtn({
			fnsCleanup,
			$iptSearch,
			item,
			subtype: "yes",
			state: 1,
		});
		btnBlue.addClass("br-0");
		btnBlue.addClass("btr-0");
		btnBlue.addClass("bbr-0");

		const btnRed = this._$render_getRowBtn({
			fnsCleanup,
			$iptSearch,
			item,
			subtype: "no",
			state: 2,
		});
		btnRed.addClass("bl-0");
		btnRed.addClass("btl-0");
		btnRed.addClass("bbl-0");

		const row = e_({
			tag: "div",
			clazz: "py-1p px-2 ve-flex-v-center fltr-search__wrp-row",
			children: [
				btnBlue,
				btnRed,
				eleName,
			],
			attrs: {
				tabindex: "0",
			},
			keydown: evt => {
				switch (evt.key) {
					case "Escape": evt.stopPropagation(); return row.blur();

					case "ArrowDown": {
						evt.preventDefault();
						const visibleRowMetas = rowMetas.filter(it => it.isVisible);
						if (!visibleRowMetas.length) return;
						const ixCur = visibleRowMetas.indexOf(out);
						const nxt = visibleRowMetas[ixCur + 1];
						if (nxt) nxt.row.focus();
						break;
					}

					case "ArrowUp": {
						evt.preventDefault();
						const visibleRowMetas = rowMetas.filter(it => it.isVisible);
						if (!visibleRowMetas.length) return;
						const ixCur = visibleRowMetas.indexOf(out);
						const prev = visibleRowMetas[ixCur - 1];
						if (prev) return prev.row.focus();
						$iptSearch.focus();
						break;
					}

					case "Enter": {
						if (evt.shiftKey) this._doSetPillsClear();
						this._state[item.item] = (evt.ctrlKey || evt.metaKey) ? 2 : 1;
						row.blur();
						break;
					}
				}
			},
		});

		wrpValues.appendChild(row);

		const out = {
			isVisible: true,
			item,
			row,
			dispName,
			eleName,
		};

		return out;
	}

	_$render_bindSearchHandler_focus_addHookSearch ({rowMetas, fnsCleanup}) {
		const hkSearch = () => {
			const searchTerm = this._compSearch._state.search.toLowerCase();

			rowMetas.forEach(({item, row}) => {
				row.isVisible = item.searchText.includes(searchTerm);
				row.toggleVe(row.isVisible);
			});

						if (!this._compSearch._state.search) {
				rowMetas.forEach(({dispName, eleName}) => eleName.textContent = dispName);
				return;
			}

			const re = new RegExp(this._compSearch._state.search.qq().escapeRegexp(), "gi");

			rowMetas.forEach(({dispName, eleName}) => {
				eleName.innerHTML = dispName
					.qq()
					.replace(re, (...m) => `<u>${m[0]}</u>`);
			});
					};
		this._compSearch._addHookBase("search", hkSearch);
		hkSearch();
		fnsCleanup.push(() => this._compSearch._removeHookBase("search", hkSearch));
	}

	_$render_bindSearchHandler_blur ({$iptSearch}) {
		$iptSearch
			.on("blur", () => {
				this._compSearch._state.search = "";
			});
	}
};

globalThis.SearchableFilter = SearchableFilter$1;

class SourceFilterItem extends FilterItem$1 {
		constructor (options) {
		super(options);
		this.isOtherSource = options.isOtherSource;
	}
}

let SourceFilter$1 = class SourceFilter extends Filter$1 {
	static _SORT_ITEMS_MINI (a, b) {
		a = a.item ?? a;
		b = b.item ?? b;
		const valA = BrewUtil2.hasSourceJson(a) ? 2 : (SourceUtil.isNonstandardSource(a) || PrereleaseUtil.hasSourceJson(a)) ? 1 : 0;
		const valB = BrewUtil2.hasSourceJson(b) ? 2 : (SourceUtil.isNonstandardSource(b) || PrereleaseUtil.hasSourceJson(b)) ? 1 : 0;
		return SortUtil.ascSort(valA, valB) || SortUtil.ascSortLower(Parser.sourceJsonToFull(a), Parser.sourceJsonToFull(b));
	}

	static _getDisplayHtmlMini (item) {
		item = item.item || item;
		const isBrewSource = BrewUtil2.hasSourceJson(item);
		const isNonStandardSource = !isBrewSource && (SourceUtil.isNonstandardSource(item) || PrereleaseUtil.hasSourceJson(item));
		return `<span ${isBrewSource ? `title="(Homebrew)"` : isNonStandardSource ? `title="(UA/Etc.)"` : ""} class="glyphicon ${isBrewSource ? `glyphicon-glass` : isNonStandardSource ? `glyphicon-file` : `glyphicon-book`}"></span> ${Parser.sourceJsonToAbv(item)}`;
	}

	constructor (opts) {
		opts = opts || {};

		opts.header = opts.header === undefined ? FilterBox$1.SOURCE_HEADER : opts.header;
		opts.displayFn = opts.displayFn === undefined ? item => Parser.sourceJsonToFullCompactPrefix(item.item || item) : opts.displayFn;
		opts.displayFnMini = opts.displayFnMini === undefined ? SourceFilter$1._getDisplayHtmlMini.bind(SourceFilter$1) : opts.displayFnMini;
		opts.displayFnTitle = opts.displayFnTitle === undefined ? item => Parser.sourceJsonToFull(item.item || item) : opts.displayFnTitle;
		opts.itemSortFnMini = opts.itemSortFnMini === undefined ? SourceFilter$1._SORT_ITEMS_MINI.bind(SourceFilter$1) : opts.itemSortFnMini;
		opts.itemSortFn = opts.itemSortFn === undefined ? (a, b) => SortUtil.ascSortLower(Parser.sourceJsonToFull(a.item), Parser.sourceJsonToFull(b.item)) : opts.itemSortFn;
		opts.groupFn = opts.groupFn === undefined ? SourceUtil.getFilterGroup : opts.groupFn;
		opts.selFn = opts.selFn === undefined ? PageFilter$1.defaultSourceSelFn : opts.selFn;

		super(opts);

		this.__tmpState = {ixAdded: 0};
		this._tmpState = this._getProxy("tmpState", this.__tmpState);
	}

	doSetPillsClear () { return this._doSetPillsClear(); }

	addItem (item) {
		const out = super.addItem(item);
		this._tmpState.ixAdded++;
		return out;
	}

	removeItem (item) {
		const out = super.removeItem(item);
		this._tmpState.ixAdded--;
		return out;
	}

	_getHeaderControls_addExtraStateBtns (opts, wrpStateBtnsOuter) {
		const btnSupplements = e_({
			tag: "button",
			clazz: `btn btn-default w-100 ${opts.isMulti ? "btn-xxs" : "btn-xs"}`,
			title: `SHIFT to include UA/etc.`,
			html: `Core/Supplements`,
			click: evt => this._doSetPinsSupplements(evt.shiftKey),
		});

		const btnAdventures = e_({
			tag: "button",
			clazz: `btn btn-default w-100 ${opts.isMulti ? "btn-xxs" : "btn-xs"}`,
			title: `SHIFT to include UA/etc.`,
			html: `Adventures`,
			click: evt => this._doSetPinsAdventures(evt.shiftKey),
		});

		const btnHomebrew = e_({
			tag: "button",
			clazz: `btn btn-default w-100 ${opts.isMulti ? "btn-xxs" : "btn-xs"}`,
			html: `Homebrew`,
			click: () => this._doSetPinsHomebrew(),
		});

		const hkIsBrewActive = () => {
			const hasBrew = Object.keys(this.__state).some(src => SourceUtil.getFilterGroup(src) === 2);
			btnHomebrew.toggleClass("ve-hidden", !hasBrew);
		};
		this._addHook("tmpState", "ixAdded", hkIsBrewActive);
		hkIsBrewActive();

		const actionSelectDisplayMode = new ContextUtil.ActionSelect({
			values: Object.keys(SourceFilter$1._PILL_DISPLAY_MODE_LABELS).map(Number),
			fnGetDisplayValue: val => SourceFilter$1._PILL_DISPLAY_MODE_LABELS[val] || SourceFilter$1._PILL_DISPLAY_MODE_LABELS[0],
			fnOnChange: val => this._meta.pillDisplayMode = val,
		});
		this._addHook("meta", "pillDisplayMode", () => {
			actionSelectDisplayMode.setValue(this._meta.pillDisplayMode);
		})();

		const menu = ContextUtil.getMenu([
			new ContextUtil.Action(
				"Select All Standard Sources",
				() => this._doSetPinsStandard(),
			),
			new ContextUtil.Action(
				"Select All Non-Standard Sources",
				() => this._doSetPinsNonStandard(),
			),
			new ContextUtil.Action(
				"Select All Homebrew Sources",
				() => this._doSetPinsHomebrew(),
			),
			null,
			new ContextUtil.Action(
				`Select "Vanilla" Sources`,
				() => this._doSetPinsVanilla(),
				{title: `Select a baseline set of sources suitable for any campaign.`},
			),
			null,
			new ContextUtil.Action(
				"Select SRD Sources",
				() => this._doSetPinsSrd(),
				{title: `Select System Reference Document Sources.`},
			),
			new ContextUtil.Action(
				"Select Basic Rules Sources",
				() => this._doSetPinsBasicRules(),
			),
			null,
			new ContextUtil.Action(
				"Invert Selection",
				() => this._doInvertPins(),
			),
			null,
			actionSelectDisplayMode,
		]);
		const btnBurger = e_({
			tag: "button",
			clazz: `btn btn-default ${opts.isMulti ? "btn-xxs" : "btn-xs"}`,
			html: `<span class="glyphicon glyphicon-option-vertical"></span>`,
			click: evt => ContextUtil.pOpenMenu(evt, menu),
			title: "Other Options",
		});

		const btnOnlyPrimary = e_({
			tag: "button",
			clazz: `btn btn-default w-100 ${opts.isMulti ? "btn-xxs" : "btn-xs"}`,
			html: `Include References`,
			title: `Consider entities as belonging to every source they appear in (i.e. reprints) as well as their primary source`,
			click: () => this._meta.isIncludeOtherSources = !this._meta.isIncludeOtherSources,
		});
		const hkIsIncludeOtherSources = () => {
			btnOnlyPrimary.toggleClass("active", !!this._meta.isIncludeOtherSources);
		};
		hkIsIncludeOtherSources();
		this._addHook("meta", "isIncludeOtherSources", hkIsIncludeOtherSources);

		e_({
			tag: "div",
			clazz: `btn-group mr-2 w-100 ve-flex-v-center mobile__m-1 mobile__mb-2`,
			children: [
				btnSupplements,
				btnAdventures,
				btnHomebrew,
				btnBurger,
				btnOnlyPrimary,
			],
		}).prependTo(wrpStateBtnsOuter);
	}

	_doSetPinsStandard () {
		Object.keys(this._state).forEach(k => this._state[k] = SourceUtil.getFilterGroup(k) === 0 ? 1 : 0);
	}

	_doSetPinsNonStandard () {
		Object.keys(this._state).forEach(k => this._state[k] = SourceUtil.getFilterGroup(k) === 1 ? 1 : 0);
	}

	_doSetPinsSupplements (isIncludeUnofficial) {
		Object.keys(this._state).forEach(k => this._state[k] = SourceUtil.isCoreOrSupplement(k) && (isIncludeUnofficial || !SourceUtil.isNonstandardSource(k)) ? 1 : 0);
	}

	_doSetPinsAdventures (isIncludeUnofficial) {
		Object.keys(this._state).forEach(k => this._state[k] = SourceUtil.isAdventure(k) && (isIncludeUnofficial || !SourceUtil.isNonstandardSource(k)) ? 1 : 0);
	}

	_doSetPinsHomebrew () {
		Object.keys(this._state).forEach(k => this._state[k] = SourceUtil.getFilterGroup(k) === 2 ? 1 : 0);
	}

	_doSetPinsVanilla () {
		Object.keys(this._state).forEach(k => this._state[k] = Parser.SOURCES_VANILLA.has(k) ? 1 : 0);
	}

	_doSetPinsSrd () {
		SourceFilter$1._SRD_SOURCES = SourceFilter$1._SRD_SOURCES || new Set([Parser.SRC_PHB, Parser.SRC_MM, Parser.SRC_DMG]);

		Object.keys(this._state).forEach(k => this._state[k] = SourceFilter$1._SRD_SOURCES.has(k) ? 1 : 0);

		const srdFilter = this._filterBox.filters.find(it => it.isSrdFilter);
		if (srdFilter) srdFilter.setValue("SRD", 1);

		const basicRulesFilter = this._filterBox.filters.find(it => it.isBasicRulesFilter);
		if (basicRulesFilter) basicRulesFilter.setValue("Basic Rules", 0);

				const reprintedFilter = this._filterBox.filters.find(it => it.isReprintedFilter);
		if (reprintedFilter) reprintedFilter.setValue("Reprinted", 0);
	}

	_doSetPinsBasicRules () {
		SourceFilter$1._BASIC_RULES_SOURCES = SourceFilter$1._BASIC_RULES_SOURCES || new Set([Parser.SRC_PHB, Parser.SRC_MM, Parser.SRC_DMG]);

		Object.keys(this._state).forEach(k => this._state[k] = SourceFilter$1._BASIC_RULES_SOURCES.has(k) ? 1 : 0);

		const basicRulesFilter = this._filterBox.filters.find(it => it.isBasicRulesFilter);
		if (basicRulesFilter) basicRulesFilter.setValue("Basic Rules", 1);

		const srdFilter = this._filterBox.filters.find(it => it.isSrdFilter);
		if (srdFilter) srdFilter.setValue("SRD", 0);

				const reprintedFilter = this._filterBox.filters.find(it => it.isReprintedFilter);
		if (reprintedFilter) reprintedFilter.setValue("Reprinted", 0);
	}

	static getCompleteFilterSources (ent) {
		if (!ent.otherSources) return ent.source;

		const otherSourcesFilt = ent.otherSources.filter(src => !ExcludeUtil.isExcluded("*", "*", src.source, {isNoCount: true}));
		if (!otherSourcesFilt.length) return ent.source;

		return [ent.source].concat(otherSourcesFilt.map(src => new SourceFilterItem({item: src.source, isIgnoreRed: true, isOtherSource: true})));
	}

	_doRenderPills_doRenderWrpGroup_getHrDivider (group) {
		switch (group) {
			case 1: return this._doRenderPills_doRenderWrpGroup_getHrDivider_groupOne(group);
			case 2: return this._doRenderPills_doRenderWrpGroup_getHrDivider_groupTwo(group);
			default: return super._doRenderPills_doRenderWrpGroup_getHrDivider(group);
		}
	}

	_doRenderPills_doRenderWrpGroup_getHrDivider_groupOne (group) {
		let dates = [];
		const comp = BaseComponent.fromObject({
			min: 0,
			max: 0,
			curMin: 0,
			curMax: 0,
		});

		const wrpSlider = new ComponentUiUtil.RangeSlider({
			comp,
			propMin: "min",
			propMax: "max",
			propCurMin: "curMin",
			propCurMax: "curMax",
			fnDisplay: val => dates[val]?.str,
		}).get();

		const wrpWrpSlider = e_({
			tag: "div",
			clazz: `"w-100 ve-flex pt-2 pb-5 mb-2 mt-1 fltr-src__wrp-slider`,
			children: [
				wrpSlider,
			],
		}).hideVe();

		const btnCancel = e_({
			tag: "button",
			clazz: `btn btn-xs btn-default px-1`,
			html: "Cancel",
			click: () => {
				grpBtnsInactive.showVe();
				wrpWrpSlider.hideVe();
				grpBtnsActive.hideVe();
			},
		});

		const btnConfirm = e_({
			tag: "button",
			clazz: `btn btn-xs btn-default px-1`,
			html: "Confirm",
			click: () => {
				grpBtnsInactive.showVe();
				wrpWrpSlider.hideVe();
				grpBtnsActive.hideVe();

				const min = comp._state.curMin;
				const max = comp._state.curMax;

				const allowedDateSet = new Set(dates.slice(min, max + 1).map(it => it.str));
				const nxtState = {};
				Object.keys(this._state)
					.filter(k => SourceUtil.isNonstandardSource(k))
					.forEach(k => {
						const sourceDate = Parser.sourceJsonToDate(k);
						nxtState[k] = allowedDateSet.has(sourceDate) ? 1 : 0;
					});
				this._proxyAssign("state", "_state", "__state", nxtState);
			},
		});

		const btnShowSlider = e_({
			tag: "button",
			clazz: `btn btn-xxs btn-default px-1`,
			html: "Select by Date",
			click: () => {
				grpBtnsInactive.hideVe();
				wrpWrpSlider.showVe();
				grpBtnsActive.showVe();

				dates = Object.keys(this._state)
					.filter(it => SourceUtil.isNonstandardSource(it))
					.map(it => Parser.sourceJsonToDate(it))
					.filter(Boolean)
					.unique()
					.map(it => ({str: it, date: new Date(it)}))
					.sort((a, b) => SortUtil.ascSortDate(a.date, b.date))
					.reverse();

				comp._proxyAssignSimple(
					"state",
					{
						min: 0,
						max: dates.length - 1,
						curMin: 0,
						curMax: dates.length - 1,
					},
				);
			},
		});

		const btnClear = e_({
			tag: "button",
			clazz: `btn btn-xxs btn-default px-1`,
			html: "Clear",
			click: () => {
				const nxtState = {};
				Object.keys(this._state)
					.filter(k => SourceUtil.isNonstandardSource(k))
					.forEach(k => nxtState[k] = 0);
				this._proxyAssign("state", "_state", "__state", nxtState);
			},
		});

		const grpBtnsActive = e_({
			tag: "div",
			clazz: `ve-flex-v-center btn-group`,
			children: [
				btnCancel,
				btnConfirm,
			],
		}).hideVe();

		const grpBtnsInactive = e_({
			tag: "div",
			clazz: `ve-flex-v-center btn-group`,
			children: [
				btnClear,
				btnShowSlider,
			],
		});

		return e_({
			tag: "div",
			clazz: `ve-flex-col w-100`,
			children: [
				super._doRenderPills_doRenderWrpGroup_getHrDivider(),
				e_({
					tag: "div",
					clazz: `mb-1 ve-flex-h-right`,
					children: [
						grpBtnsActive,
						grpBtnsInactive,
					],
				}),
				wrpWrpSlider,
			],
		});
	}

	_doRenderPills_doRenderWrpGroup_getHrDivider_groupTwo (group) {
		const btnClear = e_({
			tag: "button",
			clazz: `btn btn-xxs btn-default px-1`,
			html: "Clear",
			click: () => {
				const nxtState = {};
				Object.keys(this._state)
					.filter(k => BrewUtil2.hasSourceJson(k))
					.forEach(k => nxtState[k] = 0);
				this._proxyAssign("state", "_state", "__state", nxtState);
			},
		});

		return e_({
			tag: "div",
			clazz: `ve-flex-col w-100`,
			children: [
				super._doRenderPills_doRenderWrpGroup_getHrDivider(),
				e_({
					tag: "div",
					clazz: `mb-1 ve-flex-h-right`,
					children: [
						e_({
							tag: "div",
							clazz: `ve-flex-v-center btn-group`,
							children: [
								btnClear,
							],
						}),
					],
				}),
			],
		});
	}

	_toDisplay_getMappedEntryVal (entryVal) {
		entryVal = super._toDisplay_getMappedEntryVal(entryVal);
		if (!this._meta.isIncludeOtherSources) entryVal = entryVal.filter(it => !it.isOtherSource);
		return entryVal;
	}

	_getPill (item) {
		const displayText = this._getDisplayText(item);
		const displayTextMini = this._getDisplayTextMini(item);

		const dispName = e_({
			tag: "span",
			html: displayText,
		});

		const spc = e_({
			tag: "span",
			clazz: "px-2 fltr-src__spc-pill",
			text: "|",
		});

		const dispAbbreviation = e_({
			tag: "span",
			html: displayTextMini,
		});

		const btnPill = e_({
			tag: "div",
			clazz: "fltr__pill",
			children: [
				dispAbbreviation,
				spc,
				dispName,
			],
			click: evt => this._getPill_handleClick({evt, item}),
			contextmenu: evt => this._getPill_handleContextmenu({evt, item}),
		});

		this._getPill_bindHookState({btnPill, item});

		this._addHook("meta", "pillDisplayMode", () => {
			dispAbbreviation.toggleVe(this._meta.pillDisplayMode !== 0);
			spc.toggleVe(this._meta.pillDisplayMode === 2);
			dispName.toggleVe(this._meta.pillDisplayMode !== 1);
		})();

		item.searchText = `${Parser.sourceJsonToAbv(item.item || item).toLowerCase()} -- ${displayText.toLowerCase()}`;

		return btnPill;
	}

	getSources () {
		const out = {
			all: [],
			official: [],
			unofficial: [],
			homebrew: [],
		};
		this._items.forEach(it => {
			out.all.push(it.item);
			switch (this._groupFn(it)) {
				case 0: out.official.push(it.item); break;
				case 1: out.unofficial.push(it.item); break;
				case 2: out.homebrew.push(it.item); break;
			}
		});
		return out;
	}

	getDefaultMeta () {
				return {
			...super.getDefaultMeta(),
			...SourceFilter$1._DEFAULT_META,
		};
	}
};
SourceFilter$1._DEFAULT_META = {
	isIncludeOtherSources: false,
	pillDisplayMode: 0,
};
SourceFilter$1._PILL_DISPLAY_MODE_LABELS = {
	"0": "As Names",
	"1": "As Abbreviations",
	"2": "As Names Plus Abbreviations",
};
SourceFilter$1._SRD_SOURCES = null;
SourceFilter$1._BASIC_RULES_SOURCES = null;

let AbilityScoreFilter$1 = class AbilityScoreFilter extends FilterBase {
	static _MODIFIER_SORT_OFFSET = 10000; 
	constructor (opts) {
		super(opts);

		this._items = [];
		this._isItemsDirty = false;
		this._itemsLookup = {}; 		this._seenUids = {};

		this.__$wrpFilter = null;
		this.__wrpPills = null;
		this.__wrpPillsRows = {};
		this.__wrpMiniPills = null;

		this._maxMod = 2;
		this._minMod = 0;

				Parser.ABIL_ABVS.forEach(ab => {
			const itemAnyIncrease = new AbilityScoreFilter$1.FilterItem({isAnyIncrease: true, ability: ab});
			const itemAnyDecrease = new AbilityScoreFilter$1.FilterItem({isAnyDecrease: true, ability: ab});
			this._items.push(itemAnyIncrease, itemAnyDecrease);
			this._itemsLookup[itemAnyIncrease.uid] = itemAnyIncrease;
			this._itemsLookup[itemAnyDecrease.uid] = itemAnyDecrease;
			if (this.__state[itemAnyIncrease.uid] == null) this.__state[itemAnyIncrease.uid] = 0;
			if (this.__state[itemAnyDecrease.uid] == null) this.__state[itemAnyDecrease.uid] = 0;
		});

		for (let i = this._minMod; i <= this._maxMod; ++i) {
			if (i === 0) continue;
			Parser.ABIL_ABVS.forEach(ab => {
				const item = new AbilityScoreFilter$1.FilterItem({modifier: i, ability: ab});
				this._items.push(item);
				this._itemsLookup[item.uid] = item;
				if (this.__state[item.uid] == null) this.__state[item.uid] = 0;
			});
		}
			}

		$render (opts) {
		this._filterBox = opts.filterBox;
		this.__wrpMiniPills = e_({ele: opts.$wrpMini[0]});

		const wrpControls = this._getHeaderControls(opts);

		this.__wrpPills = e_({tag: "div", clazz: `fltr__wrp-pills overflow-x-auto ve-flex-col w-100`});
		const hook = () => this.__wrpPills.toggleVe(!this._meta.isHidden);
		this._addHook("meta", "isHidden", hook);
		hook();

		this._doRenderPills();

				const btnMobToggleControls = Filter$1.prototype._getBtnMobToggleControls.bind(this)(wrpControls);

		this.__$wrpFilter = $$`<div>
			${opts.isFirst ? "" : `<div class="fltr__dropdown-divider ${opts.isMulti ? "fltr__dropdown-divider--indented" : ""} mb-1"></div>`}
			<div class="split fltr__h mb-1">
				<div class="ml-2 fltr__h-text ve-flex-h-center">${opts.isMulti ? `<span class="mr-2">\u2012</span>` : ""}${this._getRenderedHeader()}${btnMobToggleControls}</div>
				${wrpControls}
			</div>
			${this.__wrpPills}
		</div>`;

		this.update(); 
		return this.__$wrpFilter;
	}

	_getHeaderControls (opts) {
		const btnClear = e_({
			tag: "button",
			clazz: `btn btn-default ${opts.isMulti ? "btn-xxs" : "btn-xs"} fltr__h-btn--clear w-100`,
			click: () => this._doSetPillsClear(),
			html: "Clear",
		});

		const wrpStateBtnsOuter = e_({
			tag: "div",
			clazz: "ve-flex-v-center fltr__h-wrp-state-btns-outer",
			children: [
				e_({
					tag: "div",
					clazz: "btn-group ve-flex-v-center w-100",
					children: [
						btnClear,
					],
				}),
			],
		});

		const wrpSummary = e_({tag: "div", clazz: "ve-flex-vh-center ve-hidden"});

		const btnShowHide = e_({
			tag: "button",
			clazz: `btn btn-default ${opts.isMulti ? "btn-xxs" : "btn-xs"} ml-2`,
			click: () => this._meta.isHidden = !this._meta.isHidden,
			html: "Hide",
		});
		const hookShowHide = () => {
			e_({ele: btnShowHide}).toggleClass("active", this._meta.isHidden);
			wrpStateBtnsOuter.toggleVe(!this._meta.isHidden);

									const cur = this.getValues()[this.header];

			const htmlSummary = [
				cur._totals?.yes
					? `<span class="fltr__summary_item fltr__summary_item--include" title="${cur._totals.yes} hidden &quot;required&quot; tags">${cur._totals.yes}</span>`
					: null,
			].filter(Boolean).join("");
			e_({ele: wrpSummary, html: htmlSummary}).toggleVe(this._meta.isHidden);
					};
		this._addHook("meta", "isHidden", hookShowHide);
		hookShowHide();

		return e_({
			tag: "div",
			clazz: `ve-flex-v-center fltr__h-wrp-btns-outer`,
			children: [
				wrpSummary,
				wrpStateBtnsOuter,
				btnShowHide,
			],
		});
	}

	_doRenderPills () {
		this._items.sort(this.constructor._ascSortItems.bind(this.constructor));

		if (!this.__wrpPills) return;
		this._items.forEach(it => {
			if (!it.rendered) it.rendered = this._getPill(it);
			if (!it.isAnyIncrease && !it.isAnyDecrease) it.rendered.toggleClass("fltr__pill--muted", !this._seenUids[it.uid]);

			if (!this.__wrpPillsRows[it.ability]) {
				this.__wrpPillsRows[it.ability] = {
					row: e_({
						tag: "div",
						clazz: "ve-flex-v-center w-100 my-1",
						children: [
							e_({
								tag: "div",
								clazz: "mr-3 text-right fltr__label-ability-score no-shrink no-grow",
								text: Parser.attAbvToFull(it.ability),
							}),
						],
					}).appendTo(this.__wrpPills),
					searchText: Parser.attAbvToFull(it.ability).toLowerCase(),
				};
			}

			it.rendered.appendTo(this.__wrpPillsRows[it.ability].row);
		});
	}

	_getPill (item) {
		const unsetRow = () => {
			const nxtState = {};
			for (let i = this._minMod; i <= this._maxMod; ++i) {
				if (!i || i === item.modifier) continue;
				const siblingUid = AbilityScoreFilter$1.FilterItem.getUid_({ability: item.ability, modifier: i});
				nxtState[siblingUid] = 0;
			}

			if (!item.isAnyIncrease) nxtState[AbilityScoreFilter$1.FilterItem.getUid_({ability: item.ability, isAnyIncrease: true})] = 0;
			if (!item.isAnyDecrease) nxtState[AbilityScoreFilter$1.FilterItem.getUid_({ability: item.ability, isAnyDecrease: true})] = 0;

			this._proxyAssignSimple("state", nxtState);
		};

		const btnPill = e_({
			tag: "div",
			clazz: `fltr__pill fltr__pill--ability-bonus px-2`,
			html: item.getPillDisplayHtml(),
			click: evt => {
				if (evt.shiftKey) {
					const nxtState = {};
					Object.keys(this._state).forEach(k => nxtState[k] = 0);
					this._proxyAssign("state", "_state", "__state", nxtState, true);
				}

				this._state[item.uid] = this._state[item.uid] ? 0 : 1;
				if (this._state[item.uid]) unsetRow();
			},
			contextmenu: (evt) => {
				evt.preventDefault();

				this._state[item.uid] = this._state[item.uid] ? 0 : 1;
				if (this._state[item.uid]) unsetRow();
			},
		});

		const hook = () => {
			const val = FilterBox$1._PILL_STATES[this._state[item.uid] || 0];
			btnPill.attr("state", val);
		};
		this._addHook("state", item.uid, hook);
		hook();

		return btnPill;
	}

	_doRenderMiniPills () {
				this._items.slice(0)
			.sort(this.constructor._ascSortMiniPills.bind(this.constructor))
			.forEach(it => {
								(it.btnMini = it.btnMini || this._getBtnMini(it)).appendTo(this.__wrpMiniPills);
			});
	}

	_getBtnMini (item) {
		const btnMini = e_({
			tag: "div",
			clazz: `fltr__mini-pill ${this._filterBox.isMinisHidden(this.header) ? "ve-hidden" : ""}`,
			text: item.getMiniPillDisplayText(),
			title: `Filter: ${this.header}`,
			click: () => {
				this._state[item.uid] = 0;
				this._filterBox.fireChangeEvent();
			},
		}).attr("state", FilterBox$1._PILL_STATES[this._state[item.uid] || 0]);

		const hook = () => btnMini.attr("state", FilterBox$1._PILL_STATES[this._state[item.uid] || 0]);
		this._addHook("state", item.uid, hook);

		const hideHook = () => btnMini.toggleClass("ve-hidden", this._filterBox.isMinisHidden(this.header));
		this._filterBox.registerMinisHiddenHook(this.header, hideHook);

		return btnMini;
	}

	static _ascSortItems (a, b) {
		return SortUtil.ascSort(Number(b.isAnyIncrease), Number(a.isAnyIncrease))
			|| SortUtil.ascSortAtts(a.ability, b.ability)
									|| SortUtil.ascSort(b.modifier ? b.modifier + AbilityScoreFilter$1._MODIFIER_SORT_OFFSET : b.modifier, a.modifier ? a.modifier + AbilityScoreFilter$1._MODIFIER_SORT_OFFSET : a.modifier)
			|| SortUtil.ascSort(Number(b.isAnyDecrease), Number(a.isAnyDecrease));
	}

	static _ascSortMiniPills (a, b) {
		return SortUtil.ascSort(Number(b.isAnyIncrease), Number(a.isAnyIncrease))
			|| SortUtil.ascSort(Number(b.isAnyDecrease), Number(a.isAnyDecrease))
									|| SortUtil.ascSort(b.modifier ? b.modifier + AbilityScoreFilter$1._MODIFIER_SORT_OFFSET : b.modifier, a.modifier ? a.modifier + AbilityScoreFilter$1._MODIFIER_SORT_OFFSET : a.modifier)
			|| SortUtil.ascSortAtts(a.ability, b.ability);
	}

		$renderMinis (opts) {
		this._filterBox = opts.filterBox;
		this.__wrpMiniPills = e_({ele: opts.$wrpMini[0]});

		this._doRenderMiniPills();
	}

	getValues ({nxtState = null} = {}) {
		const out = {
			_totals: {yes: 0},
		};

		const state = nxtState?.[this.header]?.state || this.__state;

		Object.entries(state)
			.filter(([, value]) => value)
			.forEach(([uid]) => {
				out._totals.yes++;
				out[uid] = true;
			});

		return {[this.header]: out};
	}

	_mutNextState_reset (nxtState, {isResetAll = false} = {}) {
		Object.keys(nxtState[this.header].state).forEach(k => delete nxtState[this.header].state[k]);
	}

	update () {
		if (this._isItemsDirty) {
			this._isItemsDirty = false;

			this._doRenderPills();
		}

				this._doRenderMiniPills();
	}

	_doSetPillsClear () {
		Object.keys(this._state).forEach(k => {
			if (this._state[k] !== 0) this._state[k] = 0;
		});
	}

	toDisplay (boxState, entryVal) {
		const filterState = boxState[this.header];
		if (!filterState) return true;

		const activeItems = Object.keys(filterState)
			.filter(it => !it.startsWith("_"))
			.map(it => this._itemsLookup[it])
			.filter(Boolean);

		if (!activeItems.length) return true;
		if ((!entryVal || !entryVal.length) && activeItems.length) return false;

		return entryVal.some(abilObject => {
			const cpyAbilObject = MiscUtil.copy(abilObject);
			const vewActiveItems = [...activeItems];

						Parser.ABIL_ABVS.forEach(ab => {
				if (!cpyAbilObject[ab] || !vewActiveItems.length) return;

				const ixExact = vewActiveItems.findIndex(it => it.ability === ab && it.modifier === cpyAbilObject[ab]);
				if (~ixExact) return vewActiveItems.splice(ixExact, 1);
			});
			if (!vewActiveItems.length) return true;
			
						if (cpyAbilObject.choose?.from) {
				const amount = cpyAbilObject.choose.amount || 1;
				const count = cpyAbilObject.choose.count || 1;

				for (let i = 0; i < count; ++i) {
					if (!vewActiveItems.length) break;

					const ix = vewActiveItems.findIndex(it => cpyAbilObject.choose.from.includes(it.ability) && amount === it.modifier);
					if (~ix) {
						const [cpyActiveItem] = vewActiveItems.splice(ix, 1);
						cpyAbilObject.choose.from = cpyAbilObject.choose.from.filter(it => it !== cpyActiveItem.ability);
					}
				}
			} else if (cpyAbilObject.choose?.weighted?.weights && cpyAbilObject.choose?.weighted?.from) {
				cpyAbilObject.choose.weighted.weights.forEach(weight => {
					const ix = vewActiveItems.findIndex(it => cpyAbilObject.choose.weighted.from.includes(it.ability) && weight === it.modifier);
					if (~ix) {
						const [cpyActiveItem] = vewActiveItems.splice(ix, 1);
						cpyAbilObject.choose.weighted.from = cpyAbilObject.choose.weighted.from.filter(it => it !== cpyActiveItem.ability);
					}
				});
			}
			if (!vewActiveItems.length) return true;
			
						Parser.ABIL_ABVS.forEach(ab => {
				if (!cpyAbilObject[ab] || !vewActiveItems.length) return;

				const ix = vewActiveItems.findIndex(it => it.ability === ab && ((cpyAbilObject[ab] > 0 && it.isAnyIncrease) || (cpyAbilObject[ab] < 0 && it.isAnyDecrease)));
				if (~ix) return vewActiveItems.splice(ix, 1);
			});
			if (!vewActiveItems.length) return true;

			if (cpyAbilObject.choose?.from) {
				const amount = cpyAbilObject.choose.amount || 1;
				const count = cpyAbilObject.choose.count || 1;

				for (let i = 0; i < count; ++i) {
					if (!vewActiveItems.length) return true;

					const ix = vewActiveItems.findIndex(it => cpyAbilObject.choose.from.includes(it.ability) && ((amount > 0 && it.isAnyIncrease) || (amount < 0 && it.isAnyDecrease)));
					if (~ix) {
						const [cpyActiveItem] = vewActiveItems.splice(ix, 1);
						cpyAbilObject.choose.from = cpyAbilObject.choose.from.filter(it => it !== cpyActiveItem.ability);
					}
				}
			} else if (cpyAbilObject.choose?.weighted?.weights && cpyAbilObject.choose?.weighted?.from) {
				cpyAbilObject.choose.weighted.weights.forEach(weight => {
					if (!vewActiveItems.length) return;

					const ix = vewActiveItems.findIndex(it => cpyAbilObject.choose.weighted.from.includes(it.ability) && ((weight > 0 && it.isAnyIncrease) || (weight < 0 && it.isAnyDecrease)));
					if (~ix) {
						const [cpyActiveItem] = vewActiveItems.splice(ix, 1);
						cpyAbilObject.choose.weighted.from = cpyAbilObject.choose.weighted.from.filter(it => it !== cpyActiveItem.ability);
					}
				});
			}
			return !vewActiveItems.length;
					});
	}

	addItem (abilArr) {
		if (!abilArr?.length) return;

				let nxtMaxMod = this._maxMod;
		let nxtMinMod = this._minMod;

		abilArr.forEach(abilObject => {
			Parser.ABIL_ABVS.forEach(ab => {
				if (abilObject[ab] != null) {
					nxtMaxMod = Math.max(nxtMaxMod, abilObject[ab]);
					nxtMinMod = Math.min(nxtMinMod, abilObject[ab]);

					const uid = AbilityScoreFilter$1.FilterItem.getUid_({ability: ab, modifier: abilObject[ab]});
					if (!this._seenUids[uid]) this._isItemsDirty = true;
					this._seenUids[uid] = true;
				}
			});

			if (abilObject.choose?.from) {
				const amount = abilObject.choose.amount || 1;
				nxtMaxMod = Math.max(nxtMaxMod, amount);
				nxtMinMod = Math.min(nxtMinMod, amount);

				abilObject.choose.from.forEach(ab => {
					const uid = AbilityScoreFilter$1.FilterItem.getUid_({ability: ab, modifier: amount});
					if (!this._seenUids[uid]) this._isItemsDirty = true;
					this._seenUids[uid] = true;
				});
			}

			if (abilObject.choose?.weighted?.weights) {
				nxtMaxMod = Math.max(nxtMaxMod, ...abilObject.choose.weighted.weights);
				nxtMinMod = Math.min(nxtMinMod, ...abilObject.choose.weighted.weights);

				abilObject.choose.weighted.from.forEach(ab => {
					abilObject.choose.weighted.weights.forEach(weight => {
						const uid = AbilityScoreFilter$1.FilterItem.getUid_({ability: ab, modifier: weight});
						if (!this._seenUids[uid]) this._isItemsDirty = true;
						this._seenUids[uid] = true;
					});
				});
			}
		});
		
				if (nxtMaxMod > this._maxMod) {
			for (let i = this._maxMod + 1; i <= nxtMaxMod; ++i) {
				if (i === 0) continue;
				Parser.ABIL_ABVS.forEach(ab => {
					const item = new AbilityScoreFilter$1.FilterItem({modifier: i, ability: ab});
					this._items.push(item);
					this._itemsLookup[item.uid] = item;
					if (this.__state[item.uid] == null) this.__state[item.uid] = 0;
				});
			}

			this._isItemsDirty = true;
			this._maxMod = nxtMaxMod;
		}
		
				if (nxtMinMod < this._minMod) {
			for (let i = nxtMinMod; i < this._minMod; ++i) {
				if (i === 0) continue;
				Parser.ABIL_ABVS.forEach(ab => {
					const item = new AbilityScoreFilter$1.FilterItem({modifier: i, ability: ab});
					this._items.push(item);
					this._itemsLookup[item.uid] = item;
					if (this.__state[item.uid] == null) this.__state[item.uid] = 0;
				});
			}

			this._isItemsDirty = true;
			this._minMod = nxtMinMod;
		}
			}

	getSaveableState () {
		return {
			[this.header]: {
				...this.getBaseSaveableState(),
				state: {...this.__state},
			},
		};
	}

	setStateFromLoaded (filterState) {
		if (!filterState || !filterState[this.header]) return;
		const toLoad = filterState[this.header];
		this.setBaseStateFromLoaded(toLoad);
		Object.assign(this._state, toLoad.state);
	}

	getSubHashes () {
		const out = [];

		const baseMeta = this.getMetaSubHashes();
		if (baseMeta) out.push(...baseMeta);

		const areNotDefaultState = Object.entries(this._state).filter(([k, v]) => {
			if (k.startsWith("_")) return false;
			return !!v;
		});
		if (areNotDefaultState.length) {
						const serPillStates = areNotDefaultState.map(([k, v]) => `${k.toUrlified()}=${v}`);
			out.push(UrlUtil.packSubHash(this.getSubHashPrefix("state", this.header), serPillStates));
		}

		if (!out.length) return null;

		return out;
	}

	getNextStateFromSubhashState (state) {
		const nxtState = this._getNextState_base();

		if (state == null) {
			this._mutNextState_reset(nxtState);
			return nxtState;
		}

		let hasState = false;

		Object.entries(state).forEach(([k, vals]) => {
			const prop = FilterBase.getProp(k);
			switch (prop) {
				case "state": {
					hasState = true;
					Object.keys(nxtState[this.header].state).forEach(k => nxtState[this.header].state[k] = 0);

					vals.forEach(v => {
						const [statePropLower, state] = v.split("=");
						const stateProp = Object.keys(nxtState[this.header].state).find(k => k.toLowerCase() === statePropLower);
						if (stateProp) nxtState[this.header].state[stateProp] = Number(state) ? 1 : 0;
					});
					break;
				}
			}
		});

		if (!hasState) this._mutNextState_reset(nxtState);

		return nxtState;
	}

	setFromValues (values) {
		if (!values[this.header]) return;
		const nxtState = {};
		Object.keys(this._state).forEach(k => nxtState[k] = 0);
		Object.assign(nxtState, values[this.header]);
	}

	handleSearch (searchTerm) {
		const isHeaderMatch = this.header.toLowerCase().includes(searchTerm);

		if (isHeaderMatch) {
			Object.values(this.__wrpPillsRows).forEach(meta => meta.row.removeClass("fltr__hidden--search"));

			if (this.__$wrpFilter) this.__$wrpFilter.toggleClass("fltr__hidden--search", false);

			return true;
		}

				const isModNumber = /^[-+]\d*$/.test(searchTerm);

		let visibleCount = 0;
		Object.values(this.__wrpPillsRows).forEach(({row, searchText}) => {
			const isVisible = isModNumber || searchText.includes(searchTerm);
			row.toggleClass("fltr__hidden--search", !isVisible);
			if (isVisible) visibleCount++;
		});

		if (this.__$wrpFilter) this.__$wrpFilter.toggleClass("fltr__hidden--search", visibleCount === 0);

		return visibleCount !== 0;
	}

	_doTeardown () {
		this._items.forEach(it => {
			if (it.rendered) it.rendered.detach();
			if (it.btnMini) it.btnMini.detach();
		});

		Object.values(this.__wrpPillsRows).forEach(meta => meta.row.detach());
	}

	_getStateNotDefault () {
		return Object.entries(this._state)
			.filter(([, v]) => !!v);
	}

	getFilterTagPart () {
		const areNotDefaultState = this._getStateNotDefault();
		const compressedMeta = this._getCompressedMeta({isStripUiKeys: true});

						if (!areNotDefaultState.length && !compressedMeta) return null;

		const pt = Object.entries(this._state)
			.filter(([, v]) => !!v)
			.map(([k, v]) => `${v === 2 ? "!" : ""}${k}`)
			.join(";")
			.toLowerCase();

		return [
			this.header.toLowerCase(),
			pt,
			compressedMeta ? compressedMeta.join(HASH_SUB_LIST_SEP) : null,
		]
			.filter(it => it != null)
			.join("=");
	}

	getDisplayStatePart ({nxtState = null} = {}) {
		const state = nxtState?.[this.header]?.state || this.__state;

		const areNotDefaultState = this._getStateNotDefault({nxtState});

						if (!areNotDefaultState.length) return null;

		const ptState = Object.entries(state)
			.filter(([, v]) => !!v)
			.map(([k, v]) => {
				const item = this._items.find(item => item.uid === k);
				if (!item) return null; 				return `${v === 2 ? "not " : ""}${item.getMiniPillDisplayText()}`;
			})
			.join(", ");

		return `${this.header}: ${ptState}`;
	}
};

globalThis.AbilityScoreFilter = AbilityScoreFilter$1;

AbilityScoreFilter$1.FilterItem = class {
	static getUid_ ({ability = null, isAnyIncrease = false, isAnyDecrease = false, modifier = null}) {
		return `${Parser.attAbvToFull(ability)} ${modifier != null ? UiUtil.intToBonus(modifier) : (isAnyIncrease ? `+any` : isAnyDecrease ? `-any` : "?")}`;
	}

	constructor ({isAnyIncrease = false, isAnyDecrease = false, modifier = null, ability = null}) {
		if (isAnyIncrease && isAnyDecrease) throw new Error(`Invalid arguments!`);
		if ((isAnyIncrease || isAnyDecrease) && modifier != null) throw new Error(`Invalid arguments!`);

		this._ability = ability;
		this._modifier = modifier;
		this._isAnyIncrease = isAnyIncrease;
		this._isAnyDecrease = isAnyDecrease;
		this._uid = AbilityScoreFilter$1.FilterItem.getUid_({
			isAnyIncrease: this._isAnyIncrease,
			isAnyDecrease: this._isAnyDecrease,
			modifier: this._modifier,
			ability: this._ability,
		});
	}

	get ability () { return this._ability; }
	get modifier () { return this._modifier; }
	get isAnyIncrease () { return this._isAnyIncrease; }
	get isAnyDecrease () { return this._isAnyDecrease; }
	get uid () { return this._uid; }

	getMiniPillDisplayText () {
		if (this._isAnyIncrease) return `+Any ${Parser.attAbvToFull(this._ability)}`;
		if (this._isAnyDecrease) return `\u2012Any ${Parser.attAbvToFull(this._ability)}`;
		return `${UiUtil.intToBonus(this._modifier, {isPretty: true})} ${Parser.attAbvToFull(this._ability)}`;
	}

	getPillDisplayHtml () {
		if (this._isAnyIncrease) return `+Any`;
		if (this._isAnyDecrease) return `\u2012Any`;
		return UiUtil.intToBonus(this._modifier, {isPretty: true});
	}
};

let RangeFilter$1 = class RangeFilter extends FilterBase {
		constructor (opts) {
		super(opts);

		if (opts.labels && opts.min == null) opts.min = 0;
		if (opts.labels && opts.max == null) opts.max = opts.labels.length - 1;

		this._min = Number(opts.min || 0);
		this._max = Number(opts.max || 0);
		this._labels = opts.isLabelled ? opts.labels : null;
		this._isAllowGreater = !!opts.isAllowGreater;
		this._isRequireFullRangeMatch = !!opts.isRequireFullRangeMatch;
		this._sparseValues = opts.isSparse ? [] : null;
		this._suffix = opts.suffix;
		this._labelSortFn = opts.labelSortFn === undefined ? SortUtil.ascSort : opts.labelSortFn;
		this._labelDisplayFn = opts.labelDisplayFn;
		this._displayFn = opts.displayFn;
		this._displayFnTooltip = opts.displayFnTooltip;

		this._filterBox = null;
		Object.assign(
			this.__state,
			{
				min: this._min,
				max: this._max,
				curMin: this._min,
				curMax: this._max,
			},
		);
		this.__$wrpFilter = null;
		this.__$wrpMini = null;
		this._slider = null;

		this._labelSearchCache = null;

		this._$btnMiniGt = null;
		this._$btnMiniLt = null;
		this._$btnMiniEq = null;

				this._seenMin = this._min;
		this._seenMax = this._max;
			}

	set isUseDropdowns (val) { this._meta.isUseDropdowns = !!val; }

	getSaveableState () {
		return {
			[this.header]: {
				...this.getBaseSaveableState(),
				state: {...this.__state},
			},
		};
	}

	setStateFromLoaded (filterState) {
		if (!filterState?.[this.header]) return;

		const toLoad = filterState[this.header];

				const tgt = (toLoad.state || {});

		if (tgt.max == null) tgt.max = this._max;
		else if (this._max > tgt.max) {
			if (tgt.max === tgt.curMax) tgt.curMax = this._max; 			tgt.max = this._max;
		}

		if (tgt.curMax == null) tgt.curMax = tgt.max;
		else if (tgt.curMax > tgt.max) tgt.curMax = tgt.max;

		if (tgt.min == null) tgt.min = this._min;
		else if (this._min < tgt.min) {
			if (tgt.min === tgt.curMin) tgt.curMin = this._min; 			tgt.min = this._min;
		}

		if (tgt.curMin == null) tgt.curMin = tgt.min;
		else if (tgt.curMin < tgt.min) tgt.curMin = tgt.min;
		
		this.setBaseStateFromLoaded(toLoad);

		Object.assign(this._state, toLoad.state);
	}

	trimState_ () {
		if (this._seenMin <= this._state.min && this._seenMax >= this._state.max) return;

		const nxtState = {min: this._seenMin, curMin: this._seenMin, max: this._seenMax, curMax: this._seenMax};
		this._proxyAssignSimple("state", nxtState);
	}

	getSubHashes () {
		const out = [];

		const baseMeta = this.getMetaSubHashes();
		if (baseMeta) out.push(...baseMeta);

		const serSliderState = [
			this._state.min !== this._state.curMin ? `min=${this._state.curMin}` : null,
			this._state.max !== this._state.curMax ? `max=${this._state.curMax}` : null,
		].filter(Boolean);
		if (serSliderState.length) {
			out.push(UrlUtil.packSubHash(this.getSubHashPrefix("state", this.header), serSliderState));
		}

		return out.length ? out : null;
	}

	_isAtDefaultPosition ({nxtState = null} = {}) {
		const state = nxtState?.[this.header]?.state || this.__state;
		return state.min === state.curMin && state.max === state.curMax;
	}

		getFilterTagPart () {
		if (this._isAtDefaultPosition()) return null;

		if (!this._labels) {
			if (this._state.curMin === this._state.curMax) return `${this.header}=[${this._state.curMin}]`;
			return `${this.header}=[${this._state.curMin};${this._state.curMax}]`;
		}

		if (this._state.curMin === this._state.curMax) {
			const label = this._labels[this._state.curMin];
			return `${this.header}=[&${label}]`;
		}

		const labelLow = this._labels[this._state.curMin];
		const labelHigh = this._labels[this._state.curMax];
		return `${this.header}=[&${labelLow};&${labelHigh}]`;
	}

	getDisplayStatePart ({nxtState = null} = {}) {
		if (this._isAtDefaultPosition({nxtState})) return null;

		const {summary} = this._getDisplaySummary({nxtState});

		return `${this.header}: ${summary}`;
	}

	getNextStateFromSubhashState (state) {
		const nxtState = this._getNextState_base();

		if (state == null) {
			this._mutNextState_reset(nxtState);
			return nxtState;
		}

		this._mutNextState_meta_fromSubHashState(nxtState, state);

		let hasState = false;

		Object.entries(state).forEach(([k, vals]) => {
			const prop = FilterBase.getProp(k);
			if (prop === "state") {
				hasState = true;
				vals.forEach(v => {
					const [prop, val] = v.split("=");
					if (val.startsWith("&") && !this._labels) throw new Error(`Could not dereference label: "${val}"`);

					let num;
					if (val.startsWith("&")) { 						const clean = val.replace("&", "").toLowerCase();
						num = this._labels.findIndex(it => String(it).toLowerCase() === clean);
						if (!~num) throw new Error(`Could not find index for label "${clean}"`);
					} else num = Number(val);

					switch (prop) {
						case "min":
							if (num < nxtState[this.header].state.min) nxtState[this.header].state.min = num;
							nxtState[this.header].state.curMin = Math.max(nxtState[this.header].state.min, num);
							break;
						case "max":
							if (num > nxtState[this.header].state.max) nxtState[this.header].state.max = num;
							nxtState[this.header].state.curMax = Math.min(nxtState[this.header].state.max, num);
							break;
						default: throw new Error(`Unknown prop "${prop}"`);
					}
				});
			}
		});

		if (!hasState) this._mutNextState_reset(nxtState);

		return nxtState;
	}

	setFromValues (values) {
		if (!values[this.header]) return;

		const vals = values[this.header];

		if (vals.min != null) this._state.curMin = Math.max(this._state.min, vals.min);
		else this._state.curMin = this._state.min;

		if (vals.max != null) this._state.curMax = Math.max(this._state.max, vals.max);
		else this._state.curMax = this._state.max;
	}

	_$getHeaderControls () {
		const $btnForceMobile = ComponentUiUtil.$getBtnBool(
			this,
			"isUseDropdowns",
			{
				$ele: $(`<button class="btn btn-default btn-xs mr-2">Show as Dropdowns</button>`),
				stateName: "meta",
				stateProp: "_meta",
			},
		);
		const $btnReset = $(`<button class="btn btn-default btn-xs">Reset</button>`).click(() => this.reset());
		const $wrpBtns = $$`<div>${$btnForceMobile}${$btnReset}</div>`;

		const $wrpSummary = $(`<div class="ve-flex-v-center fltr__summary_item fltr__summary_item--include"></div>`).hideVe();

		const $btnShowHide = $(`<button class="btn btn-default btn-xs ml-2 ${this._meta.isHidden ? "active" : ""}">Hide</button>`)
			.click(() => this._meta.isHidden = !this._meta.isHidden);
		const hkIsHidden = () => {
			$btnShowHide.toggleClass("active", this._meta.isHidden);
			$wrpBtns.toggleVe(!this._meta.isHidden);
			$wrpSummary.toggleVe(this._meta.isHidden);

						const {summaryTitle, summary} = this._getDisplaySummary();
			$wrpSummary
				.title(summaryTitle)
				.text(summary);
		};
		this._addHook("meta", "isHidden", hkIsHidden);
		hkIsHidden();

		return $$`
		<div class="ve-flex-v-center">
			${$wrpBtns}
			${$wrpSummary}
			${$btnShowHide}
		</div>`;
	}

	_getDisplaySummary ({nxtState = null} = {}) {
		const cur = this.getValues({nxtState})[this.header];

		const isRange = !cur.isMinVal && !cur.isMaxVal;
		const isCapped = !cur.isMinVal || !cur.isMaxVal;

		return {
			summaryTitle: isRange ? `Hidden range` : isCapped ? `Hidden limit` : "",
			summary: isRange ? `${this._getDisplayText(cur.min)}-${this._getDisplayText(cur.max)}` : !cur.isMinVal ? `≥ ${this._getDisplayText(cur.min)}` : !cur.isMaxVal ? `≤ ${this._getDisplayText(cur.max)}` : "",
		};
	}

	_getDisplayText (value, {isBeyondMax = false, isTooltip = false} = {}) {
		value = `${this._labels ? this._labelDisplayFn ? this._labelDisplayFn(this._labels[value]) : this._labels[value] : (isTooltip && this._displayFnTooltip) ? this._displayFnTooltip(value) : this._displayFn ? this._displayFn(value) : value}${isBeyondMax ? "+" : ""}`;
		if (this._suffix) value += this._suffix;
		return value;
	}

		$render (opts) {
		this._filterBox = opts.filterBox;
		this.__$wrpMini = opts.$wrpMini;

		const $wrpControls = opts.isMulti ? null : this._$getHeaderControls();

		const $wrpSlider = $$`<div class="fltr__wrp-pills fltr__wrp-pills--flex"></div>`;
		const $wrpDropdowns = $$`<div class="fltr__wrp-pills fltr__wrp-pills--flex"></div>`;
		const hookHidden = () => {
			$wrpSlider.toggleVe(!this._meta.isHidden && !this._meta.isUseDropdowns);
			$wrpDropdowns.toggleVe(!this._meta.isHidden && !!this._meta.isUseDropdowns);
		};
		this._addHook("meta", "isHidden", hookHidden);
		this._addHook("meta", "isUseDropdowns", hookHidden);
		hookHidden();

						if (this._sparseValues?.length) {
			const sparseMin = this._sparseValues[0];
			if (this._state.min < sparseMin) {
				this._state.curMin = Math.max(this._state.curMin, sparseMin);
				this._state.min = sparseMin;
			}

			const sparseMax = this._sparseValues.last();
			if (this._state.max > sparseMax) {
				this._state.curMax = Math.min(this._state.curMax, sparseMax);
				this._state.max = sparseMax;
			}
		}

				const getSliderOpts = () => {
			const fnDisplay = (val, {isTooltip = false} = {}) => {
				return this._getDisplayText(val, {isBeyondMax: this._isAllowGreater && val === this._state.max, isTooltip});
			};

			return {
				propMin: "min",
				propMax: "max",
				propCurMin: "curMin",
				propCurMax: "curMax",
				fnDisplay: (val) => fnDisplay(val),
				fnDisplayTooltip: (val) => fnDisplay(val, {isTooltip: true}),
				sparseValues: this._sparseValues,
			};
		};

		const hkUpdateLabelSearchCache = () => {
			if (this._labels) return this._doUpdateLabelSearchCache();
			this._labelSearchCache = null;
		};
		this._addHook("state", "curMin", hkUpdateLabelSearchCache);
		this._addHook("state", "curMax", hkUpdateLabelSearchCache);
		hkUpdateLabelSearchCache();

		this._slider = new ComponentUiUtil.RangeSlider({comp: this, ...getSliderOpts()});
		$wrpSlider.append(this._slider.get());
		
				const selMin = e_({
			tag: "select",
			clazz: `form-control mr-2`,
			change: () => {
				const nxtMin = Number(selMin.val());
				const [min, max] = [nxtMin, this._state.curMax].sort(SortUtil.ascSort);
				this._state.curMin = min;
				this._state.curMax = max;
			},
		});
		const selMax = e_({
			tag: "select",
			clazz: `form-control`,
			change: () => {
				const nxMax = Number(selMax.val());
				const [min, max] = [this._state.curMin, nxMax].sort(SortUtil.ascSort);
				this._state.curMin = min;
				this._state.curMax = max;
			},
		});
		$$`<div class="ve-flex-v-center w-100 px-3 py-1">${selMin}${selMax}</div>`.appendTo($wrpDropdowns);
		
		const handleCurUpdate = () => {
						selMin.val(`${this._state.curMin}`);
			selMax.val(`${this._state.curMax}`);
		};

		const handleLimitUpdate = () => {
						this._doPopulateDropdown(selMin, this._state.curMin);
			this._doPopulateDropdown(selMax, this._state.curMax);
		};

		this._addHook("state", "min", handleLimitUpdate);
		this._addHook("state", "max", handleLimitUpdate);
		this._addHook("state", "curMin", handleCurUpdate);
		this._addHook("state", "curMax", handleCurUpdate);
		handleCurUpdate();
		handleLimitUpdate();

		if (opts.isMulti) {
			this._slider.get().classList.add("ve-grow");
			$wrpSlider.addClass("ve-grow");
			$wrpDropdowns.addClass("ve-grow");

			return this.__$wrpFilter = $$`<div class="ve-flex">
				<div class="fltr__range-inline-label">${this._getRenderedHeader()}</div>
				${$wrpSlider}
				${$wrpDropdowns}
			</div>`;
		} else {
			const btnMobToggleControls = this._getBtnMobToggleControls($wrpControls);

			return this.__$wrpFilter = $$`<div class="ve-flex-col">
				${opts.isFirst ? "" : `<div class="fltr__dropdown-divider mb-1"></div>`}
				<div class="split fltr__h ${this._minimalUi ? "fltr__minimal-hide" : ""} mb-1">
					<div class="fltr__h-text ve-flex-h-center">${this._getRenderedHeader()}${btnMobToggleControls}</div>
					${$wrpControls}
				</div>
				${$wrpSlider}
				${$wrpDropdowns}
			</div>`;
		}
	}

	$renderMinis (opts) {
		if (!opts.$wrpMini) return;

		this._filterBox = opts.filterBox;
		this.__$wrpMini = opts.$wrpMini;

				this._$btnMiniGt = this._$btnMiniGt || $(`<div class="fltr__mini-pill" state="ignore"></div>`)
			.click(() => {
				this._state.curMin = this._state.min;
				this._filterBox.fireChangeEvent();
			});
		this._$btnMiniGt.appendTo(this.__$wrpMini);

		this._$btnMiniLt = this._$btnMiniLt || $(`<div class="fltr__mini-pill" state="ignore"></div>`)
			.click(() => {
				this._state.curMax = this._state.max;
				this._filterBox.fireChangeEvent();
			});
		this._$btnMiniLt.appendTo(this.__$wrpMini);

		this._$btnMiniEq = this._$btnMiniEq || $(`<div class="fltr__mini-pill" state="ignore"></div>`)
			.click(() => {
				this._state.curMin = this._state.min;
				this._state.curMax = this._state.max;
				this._filterBox.fireChangeEvent();
			});
		this._$btnMiniEq.appendTo(this.__$wrpMini);

		const hideHook = () => {
			const isHidden = this._filterBox.isMinisHidden(this.header);
			this._$btnMiniGt.toggleClass("ve-hidden", isHidden);
			this._$btnMiniLt.toggleClass("ve-hidden", isHidden);
			this._$btnMiniEq.toggleClass("ve-hidden", isHidden);
		};
		this._filterBox.registerMinisHiddenHook(this.header, hideHook);
		hideHook();

		const handleMiniUpdate = () => {
			if (this._state.curMin === this._state.curMax) {
				this._$btnMiniGt.attr("state", FilterBox$1._PILL_STATES[0]);
				this._$btnMiniLt.attr("state", FilterBox$1._PILL_STATES[0]);

				this._$btnMiniEq
					.attr("state", this._isAtDefaultPosition() ? FilterBox$1._PILL_STATES[0] : FilterBox$1._PILL_STATES[1])
					.text(`${this.header} = ${this._getDisplayText(this._state.curMin, {isBeyondMax: this._isAllowGreater && this._state.curMin === this._state.max})}`);
			} else {
				if (this._state.min !== this._state.curMin) {
					this._$btnMiniGt.attr("state", FilterBox$1._PILL_STATES[1])
						.text(`${this.header} ≥ ${this._getDisplayText(this._state.curMin)}`);
				} else this._$btnMiniGt.attr("state", FilterBox$1._PILL_STATES[0]);

				if (this._state.max !== this._state.curMax) {
					this._$btnMiniLt.attr("state", FilterBox$1._PILL_STATES[1])
						.text(`${this.header} ≤ ${this._getDisplayText(this._state.curMax)}`);
				} else this._$btnMiniLt.attr("state", FilterBox$1._PILL_STATES[0]);

				this._$btnMiniEq.attr("state", FilterBox$1._PILL_STATES[0]);
			}
		};
		
		const handleCurUpdate = () => {
			handleMiniUpdate();
		};

		const handleLimitUpdate = () => {
			handleMiniUpdate();
		};

		this._addHook("state", "min", handleLimitUpdate);
		this._addHook("state", "max", handleLimitUpdate);
		this._addHook("state", "curMin", handleCurUpdate);
		this._addHook("state", "curMax", handleCurUpdate);
		handleCurUpdate();
		handleLimitUpdate();
	}

	_doPopulateDropdown (sel, curVal) {
		let tmp = "";
		for (let i = 0, len = this._state.max - this._state.min + 1; i < len; ++i) {
			const val = i + this._state.min;
			const label = `${this._getDisplayText(val)}`.qq();
			tmp += `<option value="${val}" ${curVal === val ? "selected" : ""}>${label}</option>`;
		}
		sel.innerHTML = tmp;
		return sel;
	}

	getValues ({nxtState = null} = {}) {
		const state = nxtState?.[this.header]?.state || this.__state;

		const out = {
			isMaxVal: state.max === state.curMax,
			isMinVal: state.min === state.curMin,
			max: state.curMax,
			min: state.curMin,
		};
		out._isActive = !(out.isMinVal && out.isMaxVal);
		return {[this.header]: out};
	}

	_mutNextState_reset (nxtState, {isResetAll = false} = {}) {
		if (isResetAll) this._mutNextState_resetBase(nxtState, {isResetAll});
		nxtState[this.header].state.curMin = nxtState[this.header].state.min;
		nxtState[this.header].state.curMax = nxtState[this.header].state.max;
	}

	update () {
		if (!this.__$wrpMini) return;

						if (this._$btnMiniGt) this.__$wrpMini.append(this._$btnMiniGt);
		if (this._$btnMiniLt) this.__$wrpMini.append(this._$btnMiniLt);
		if (this._$btnMiniEq) this.__$wrpMini.append(this._$btnMiniEq);
	}

	toDisplay (boxState, entryVal) {
		const filterState = boxState[this.header];
		if (!filterState) return true; 
				if (entryVal == null) return filterState.min === this._state.min && filterState.max === this._state.max;

		if (this._labels) {
			const slice = this._labels.slice(filterState.min, filterState.max + 1);

						if (this._isAllowGreater) {
				if (filterState.max === this._state.max && entryVal > this._labels[filterState.max]) return true;

				const sliceMin = Math.min(...slice);
				const sliceMax = Math.max(...slice);

				if (entryVal instanceof Array) return entryVal.some(it => it >= sliceMin && it <= sliceMax);
				return entryVal >= sliceMin && entryVal <= sliceMax;
			}

			if (entryVal instanceof Array) return entryVal.some(it => slice.includes(it));
			return slice.includes(entryVal);
		} else {
			if (entryVal instanceof Array) {
								if (this._isRequireFullRangeMatch) return filterState.min <= entryVal[0] && filterState.max >= entryVal.last();

								return entryVal.some(ev => this._toDisplay_isToDisplayEntry(filterState, ev));
			}
			return this._toDisplay_isToDisplayEntry(filterState, entryVal);
		}
	}

	_toDisplay_isToDisplayEntry (filterState, ev) {
		const isGtMin = filterState.min <= ev;
		const isLtMax = filterState.max >= ev;
		if (this._isAllowGreater) return isGtMin && (isLtMax || filterState.max === this._state.max);
		return isGtMin && isLtMax;
	}

	addItem (item) {
		if (item == null) return;

		if (item instanceof Array) {
			const len = item.length;
			for (let i = 0; i < len; ++i) this.addItem(item[i]);
			return;
		}

		if (this._labels) {
			if (!this._labels.some(it => it === item)) this._labels.push(item);

			this._doUpdateLabelSearchCache();

						this._addItem_addNumber(this._labels.length - 1);
		} else {
			this._addItem_addNumber(item);
		}
	}

	_doUpdateLabelSearchCache () {
		this._labelSearchCache = [...new Array(Math.max(0, this._max - this._min))]
			.map((_, i) => i + this._min)
			.map(val => this._getDisplayText(val, {isBeyondMax: this._isAllowGreater && val === this._state.max, isTooltip: true}))
			.join(" -- ")
			.toLowerCase();
	}

	_addItem_addNumber (number) {
		if (number == null || isNaN(number)) return;

		this._seenMin = Math.min(this._seenMin, number);
		this._seenMax = Math.max(this._seenMax, number);

		if (this._sparseValues && !this._sparseValues.includes(number)) {
			this._sparseValues.push(number);
			this._sparseValues.sort(SortUtil.ascSort);
		}

		if (number >= this._state.min && number <= this._state.max) return; 		if (this._state.min == null && this._state.max == null) this._state.min = this._state.max = number;
		else {
			const old = {...this.__state};

			if (number < old.min) this._state.min = number;
			if (number > old.max) this._state.max = number;

						if (old.curMin === old.min) this._state.curMin = this._state.min;
			if (old.curMax === old.max) this._state.curMax = this._state.max;
		}
	}

	getDefaultMeta () {
				const out = {
			...super.getDefaultMeta(),
			...RangeFilter$1._DEFAULT_META,
		};
		if (Renderer.hover.isSmallScreen()) out.isUseDropdowns = true;
		return out;
	}

	handleSearch (searchTerm) {
		if (this.__$wrpFilter == null) return;

		const isVisible = this.header.toLowerCase().includes(searchTerm)
			|| (this._labelSearchCache != null
				? this._labelSearchCache.includes(searchTerm)
				: [...new Array(this._state.max - this._state.min)].map((_, n) => n + this._state.min).join(" -- ").includes(searchTerm));

		this.__$wrpFilter.toggleClass("fltr__hidden--search", !isVisible);

		return isVisible;
	}
};
RangeFilter$1._DEFAULT_META = {
	isUseDropdowns: false,
};

let OptionsFilter$1 = class OptionsFilter extends FilterBase {
		constructor (opts) {
		super(opts);
		this._defaultState = opts.defaultState;
		this._displayFn = opts.displayFn;
		this._displayFnMini = opts.displayFnMini;

		Object.assign(
			this.__state,
			MiscUtil.copy(opts.defaultState),
		);

		this._filterBox = null;
		this.__$wrpMini = null;
	}

	getSaveableState () {
		return {
			[this.header]: {
				...this.getBaseSaveableState(),
				state: {...this.__state},
			},
		};
	}

	setStateFromLoaded (filterState) {
		if (!filterState || !filterState[this.header]) return;

		const toLoad = filterState[this.header];

		this.setBaseStateFromLoaded(toLoad);

		const toAssign = {};
		Object.keys(this._defaultState).forEach(k => {
			if (toLoad.state[k] == null) return;
			if (typeof toLoad.state[k] !== typeof this._defaultState[k]) return; 			toAssign[k] = toLoad.state[k];
		});

		Object.assign(this._state, toAssign);
	}

	_getStateNotDefault () {
		return Object.entries(this._state)
			.filter(([k, v]) => this._defaultState[k] !== v);
	}

	getSubHashes () {
		const out = [];

		const baseMeta = this.getMetaSubHashes();
		if (baseMeta) out.push(...baseMeta);

		const serOptionState = [];
		Object.entries(this._defaultState)
			.forEach(([k, vDefault]) => {
				if (this._state[k] !== vDefault) serOptionState.push(`${k.toLowerCase()}=${UrlUtil.mini.compress(this._state[k])}`);
			});
		if (serOptionState.length) {
			out.push(UrlUtil.packSubHash(this.getSubHashPrefix("state", this.header), serOptionState));
		}

		return out.length ? out : null;
	}

		getFilterTagPart () {
		const areNotDefaultState = this._getStateNotDefault();
		if (!areNotDefaultState.length) return null;

		const pt = areNotDefaultState
			.map(([k, v]) => `${v ? "" : "!"}${k}`)
			.join(";").toLowerCase();

		return `${this.header.toLowerCase()}=::${pt}::`;
	}

	getDisplayStatePart ({nxtState = null} = {}) {
				return null;
	}

	getNextStateFromSubhashState (state) {
		const nxtState = this._getNextState_base();

		if (state == null) {
			this._mutNextState_reset(nxtState);
			return nxtState;
		}

		this._mutNextState_meta_fromSubHashState(nxtState, state);

		let hasState = false;

		Object.entries(state).forEach(([k, vals]) => {
			const prop = FilterBase.getProp(k);
			if (prop !== "state") return;

			hasState = true;
			vals.forEach(v => {
				const [prop, valCompressed] = v.split("=");
				const val = UrlUtil.mini.decompress(valCompressed);

				const casedProp = Object.keys(this._defaultState).find(k => k.toLowerCase() === prop);
				if (!casedProp) return;

				if (this._defaultState[casedProp] != null && typeof val === typeof this._defaultState[casedProp]) nxtState[this.header].state[casedProp] = val;
			});
		});

		if (!hasState) this._mutNextState_reset(nxtState);

		return nxtState;
	}

	setFromValues (values) {
		if (!values[this.header]) return;
		const vals = values[this.header];
		Object.entries(vals).forEach(([k, v]) => {
			if (this._defaultState[k] && typeof this._defaultState[k] === typeof v) this._state[k] = v;
		});
	}

	setValue (k, v) { this._state[k] = v; }

		$render (opts) {
		this._filterBox = opts.filterBox;
		this.__$wrpMini = opts.$wrpMini;

		const $wrpControls = opts.isMulti ? null : this._$getHeaderControls();

		const $btns = Object.keys(this._defaultState)
			.map(k => this._$render_$getPill(k));
		const $wrpButtons = $$`<div>${$btns}</div>`;

		if (opts.isMulti) {
			return this.__$wrpFilter = $$`<div class="ve-flex">
				<div class="fltr__range-inline-label">${this._getRenderedHeader()}</div>
				${$wrpButtons}
			</div>`;
		} else {
			return this.__$wrpFilter = $$`<div class="ve-flex-col">
				${opts.isFirst ? "" : `<div class="fltr__dropdown-divider mb-1"></div>`}
				<div class="split fltr__h ${this._minimalUi ? "fltr__minimal-hide" : ""} mb-1">
					<div class="fltr__h-text ve-flex-h-center">${this._getRenderedHeader()}</div>
					${$wrpControls}
				</div>
				${$wrpButtons}
			</div>`;
		}
	}

	$renderMinis (opts) {
		if (!opts.$wrpMini) return;

		this._filterBox = opts.filterBox;
		this.__$wrpMini = opts.$wrpMini;

		const $btnsMini = Object.keys(this._defaultState)
			.map(k => this._$render_$getMiniPill(k));
		$btnsMini.forEach($btn => $btn.appendTo(this.__$wrpMini));
	}

	_$render_$getPill (key) {
		const displayText = this._displayFn(key);

		const $btnPill = $(`<div class="fltr__pill">${displayText}</div>`)
			.click(() => {
				this._state[key] = !this._state[key];
			})
			.contextmenu((evt) => {
				evt.preventDefault();
				this._state[key] = !this._state[key];
			});
		const hook = () => {
			const val = FilterBox$1._PILL_STATES[this._state[key] ? 1 : 2];
			$btnPill.attr("state", val);
		};
		this._addHook("state", key, hook);
		hook();

		return $btnPill;
	}

	_$render_$getMiniPill (key) {
		const displayTextFull = this._displayFnMini ? this._displayFn(key) : null;
		const displayText = this._displayFnMini ? this._displayFnMini(key) : this._displayFn(key);

		const $btnMini = $(`<div class="fltr__mini-pill ${this._filterBox.isMinisHidden(this.header) ? "ve-hidden" : ""}" state="${FilterBox$1._PILL_STATES[this._defaultState[key] === this._state[key] ? 0 : this._state[key] ? 1 : 2]}">${displayText}</div>`)
			.title(`${displayTextFull ? `${displayTextFull} (` : ""}Filter: ${this.header}${displayTextFull ? ")" : ""}`)
			.click(() => {
				this._state[key] = this._defaultState[key];
				this._filterBox.fireChangeEvent();
			});

		const hook = () => $btnMini.attr("state", FilterBox$1._PILL_STATES[this._defaultState[key] === this._state[key] ? 0 : this._state[key] ? 1 : 2]);
		this._addHook("state", key, hook);

		const hideHook = () => $btnMini.toggleClass("ve-hidden", this._filterBox.isMinisHidden(this.header));
		this._filterBox.registerMinisHiddenHook(this.header, hideHook);

		return $btnMini;
	}

	_$getHeaderControls () {
		const $btnReset = $(`<button class="btn btn-default btn-xs">Reset</button>`).click(() => this.reset());
		const $wrpBtns = $$`<div class="ve-flex-v-center">${$btnReset}</div>`;

		const $wrpSummary = $(`<div class="ve-flex-v-center fltr__summary_item fltr__summary_item--include"></div>`).hideVe();

		const $btnShowHide = $(`<button class="btn btn-default btn-xs ml-2 ${this._meta.isHidden ? "active" : ""}">Hide</button>`)
			.click(() => this._meta.isHidden = !this._meta.isHidden);
		const hkIsHidden = () => {
			$btnShowHide.toggleClass("active", this._meta.isHidden);
			$wrpBtns.toggleVe(!this._meta.isHidden);
			$wrpSummary.toggleVe(this._meta.isHidden);

						const cntNonDefault = Object.entries(this._defaultState).filter(([k, v]) => this._state[k] != null && this._state[k] !== v).length;

			$wrpSummary
				.title(`${cntNonDefault} non-default option${cntNonDefault === 1 ? "" : "s"} selected`)
				.text(cntNonDefault);
		};
		this._addHook("meta", "isHidden", hkIsHidden);
		hkIsHidden();

		return $$`
		<div class="ve-flex-v-center">
			${$wrpBtns}
			${$wrpSummary}
			${$btnShowHide}
		</div>`;
	}

	getValues ({nxtState = null} = {}) {
		const state = nxtState?.[this.header]?.state || this.__state;

		const out = Object.entries(this._defaultState)
			.mergeMap(([k, v]) => ({[k]: state[k] == null ? v : state[k]}));
		out._isActive = Object.entries(this._defaultState).some(([k, v]) => state[k] != null && state[k] !== v);
		return {
			[this.header]: out,
		};
	}

	_mutNextState_reset (nxtState, {isResetAll = false} = {}) {
		if (isResetAll) this._mutNextState_resetBase(nxtState, {isResetAll});
		Object.assign(nxtState[this.header].state, MiscUtil.copy(this._defaultState));
	}

	update () {  }

	toDisplay (boxState, entryVal) {
		const filterState = boxState[this.header];
		if (!filterState) return true; 
		if (entryVal == null) return true; 
				return Object.entries(entryVal)
			.every(([k, v]) => this._state[k] === v);
	}

	getDefaultMeta () {
				return {
			...super.getDefaultMeta(),
			...OptionsFilter$1._DEFAULT_META,
		};
	}

	handleSearch (searchTerm) {
		if (this.__$wrpFilter == null) return;

		const isVisible = this.header.toLowerCase().includes(searchTerm)
			|| Object.keys(this._defaultState).map(it => this._displayFn(it).toLowerCase()).some(it => it.includes(searchTerm));

		this.__$wrpFilter.toggleClass("fltr__hidden--search", !isVisible);

		return isVisible;
	}
};
OptionsFilter$1._DEFAULT_META = {};

let MultiFilter$1 = class MultiFilter extends FilterBase {
	constructor (opts) {
		super(opts);
		this._filters = opts.filters;
		this._isAddDropdownToggle = !!opts.isAddDropdownToggle;

		Object.assign(
			this.__state,
			{
				...MultiFilter$1._DETAULT_STATE,
				mode: opts.mode || MultiFilter$1._DETAULT_STATE.mode,
			},
		);
		this._defaultState = MiscUtil.copy(this.__state);
		this._state = this._getProxy("state", this.__state);

		this.__$wrpFilter = null;
		this._$wrpChildren = null;
	}

	getChildFilters () {
		return [...this._filters, ...this._filters.map(f => f.getChildFilters())].flat();
	}

	getSaveableState () {
		const out = {
			[this.header]: {
				...this.getBaseSaveableState(),
				state: {...this.__state},
			},
		};
		this._filters.forEach(it => Object.assign(out, it.getSaveableState()));
		return out;
	}

	setStateFromLoaded (filterState) {
		if (filterState && filterState[this.header]) {
			const toLoad = filterState[this.header];
			this.setBaseStateFromLoaded(toLoad);
			Object.assign(this._state, toLoad.state);
			this._filters.forEach(it => it.setStateFromLoaded(filterState));
		}
	}

	getSubHashes () {
		const out = [];

		const baseMeta = this.getMetaSubHashes();
		if (baseMeta) out.push(...baseMeta);

		const anyNotDefault = this._getStateNotDefault();
		if (anyNotDefault.length) {
			out.push(UrlUtil.packSubHash(this.getSubHashPrefix("state", this.header), this._getCompressedState()));
		}

						this._filters.map(it => it.getSubHashes()).filter(Boolean).forEach(it => out.push(...it));
		return out.length ? out : null;
	}

	_getStateNotDefault () {
		return Object.entries(this._defaultState)
			.filter(([k, v]) => this._state[k] !== v);
	}

		getFilterTagPart () {
		return [
			this._getFilterTagPart_self(),
			...this._filters.map(it => it.getFilterTagPart()).filter(Boolean),
		]
			.filter(it => it != null)
			.join("|");
	}

	_getFilterTagPart_self () {
		const areNotDefaultState = this._getStateNotDefault();
		if (!areNotDefaultState.length) return null;

		return `${this.header.toLowerCase()}=${this._getCompressedState().join(HASH_SUB_LIST_SEP)}`;
	}

	getDisplayStatePart ({nxtState = null} = {}) {
		return this._filters.map(it => it.getDisplayStatePart({nxtState}))
			.filter(Boolean)
			.join(", ");
	}

	_getCompressedState () {
		return Object.keys(this._defaultState)
			.map(k => UrlUtil.mini.compress(this._state[k] === undefined ? this._defaultState[k] : this._state[k]));
	}

	setStateFromNextState (nxtState) {
		super.setStateFromNextState(nxtState);
	}

	getNextStateFromSubhashState (state) {
		const nxtState = this._getNextState_base();

		if (state == null) {
			this._mutNextState_reset_self(nxtState);
			return nxtState;
		}

		this._mutNextState_meta_fromSubHashState(nxtState, state);

		let hasState = false;

		Object.entries(state).forEach(([k, vals]) => {
			const prop = FilterBase.getProp(k);
			if (prop === "state") {
				hasState = true;
				const data = vals.map(v => UrlUtil.mini.decompress(v));
				Object.keys(this._defaultState).forEach((k, i) => nxtState[this.header].state[k] = data[i]);
			}
		});

		if (!hasState) this._mutNextState_reset_self(nxtState);

		return nxtState;
	}

	setFromValues (values) {
		this._filters.forEach(it => it.setFromValues(values));
	}

	_getHeaderControls (opts) {
		const wrpSummary = e_({
			tag: "div",
			clazz: "fltr__summary_item",
		}).hideVe();

		const btnForceMobile = this._isAddDropdownToggle ? ComponentUiUtil.getBtnBool(
			this,
			"isUseDropdowns",
			{
				$ele: $(`<button class="btn btn-default btn-xs ml-2">Show as Dropdowns</button>`),
				stateName: "meta",
				stateProp: "_meta",
			},
		) : null;
				const hkChildrenDropdowns = () => {
			this._filters
				.filter(it => it instanceof RangeFilter$1)
				.forEach(it => it.isUseDropdowns = this._meta.isUseDropdowns);
		};
		this._addHook("meta", "isUseDropdowns", hkChildrenDropdowns);
		hkChildrenDropdowns();

		const btnResetAll = e_({
			tag: "button",
			clazz: "btn btn-default btn-xs ml-2",
			text: "Reset All",
			click: () => this._filters.forEach(it => it.reset()),
		});

		const wrpBtns = e_({tag: "div", clazz: "ve-flex", children: [btnForceMobile, btnResetAll].filter(Boolean)});
		this._getHeaderControls_addExtraStateBtns(opts, wrpBtns);

		const btnShowHide = e_({
			tag: "button",
			clazz: `btn btn-default btn-xs ml-2 ${this._meta.isHidden ? "active" : ""}`,
			text: "Hide",
			click: () => this._meta.isHidden = !this._meta.isHidden,
		});
		const wrpControls = e_({tag: "div", clazz: "ve-flex-v-center", children: [wrpSummary, wrpBtns, btnShowHide]});

		const hookShowHide = () => {
			wrpBtns.toggleVe(!this._meta.isHidden);
			btnShowHide.toggleClass("active", this._meta.isHidden);
			this._$wrpChildren.toggleVe(!this._meta.isHidden);
			wrpSummary.toggleVe(this._meta.isHidden);

			const numActive = this._filters.map(it => it.getValues()[it.header]._isActive).filter(Boolean).length;
			if (numActive) {
				e_({ele: wrpSummary, title: `${numActive} hidden active filter${numActive === 1 ? "" : "s"}`, text: `(${numActive})`});
			}
		};
		this._addHook("meta", "isHidden", hookShowHide);
		hookShowHide();

		return wrpControls;
	}

	_getHeaderControls_addExtraStateBtns (opts, wrpStateBtnsOuter) {}

	$render (opts) {
		const btnAndOr = e_({
			tag: "div",
			clazz: `fltr__group-comb-toggle ve-muted`,
			click: () => this._state.mode = this._state.mode === "and" ? "or" : "and",
			title: `"Group AND" requires all filters in this group to match. "Group OR" required any filter in this group to match.`,
		});

		const hookAndOr = () => btnAndOr.innerText = `(group ${this._state.mode.toUpperCase()})`;
		this._addHook("state", "mode", hookAndOr);
		hookAndOr();

		const $children = this._filters.map((it, i) => it.$render({...opts, isMulti: true, isFirst: i === 0}));
		this._$wrpChildren = $$`<div>${$children}</div>`;

		const wrpControls = this._getHeaderControls(opts);

		return this.__$wrpFilter = $$`<div class="ve-flex-col">
			${opts.isFirst ? "" : `<div class="fltr__dropdown-divider mb-1"></div>`}
			<div class="split fltr__h fltr__h--multi ${this._minimalUi ? "fltr__minimal-hide" : ""} mb-1">
				<div class="ve-flex-v-center">
					<div class="mr-2">${this._getRenderedHeader()}</div>
					${btnAndOr}
				</div>
				${wrpControls}
			</div>
			${this._$wrpChildren}
		</div>`;
	}

	$renderMinis (opts) {
		this._filters.map((it, i) => it.$renderMinis({...opts, isMulti: true, isFirst: i === 0}));
	}

		isActive (vals) {
		vals = vals || this.getValues();
		return this._filters.some(it => it.isActive(vals));
	}

	getValues ({nxtState = null} = {}) {
		const out = {};
		this._filters.forEach(it => Object.assign(out, it.getValues({nxtState})));
		return out;
	}

	_mutNextState_reset_self (nxtState) {
		Object.assign(nxtState[this.header].state, MiscUtil.copy(this._defaultState));
	}

	_mutNextState_reset (nxtState, {isResetAll = false} = {}) {
		if (isResetAll) this._mutNextState_resetBase(nxtState, {isResetAll});
		this._mutNextState_reset_self(nxtState);
	}

	reset ({isResetAll = false} = {}) {
		super.reset({isResetAll});
		this._filters.forEach(it => it.reset({isResetAll}));
	}

	update () {
		this._filters.forEach(it => it.update());
	}

	toDisplay (boxState, entryValArr) {
		if (this._filters.length !== entryValArr.length) throw new Error("Number of filters and number of values did not match");

		const results = [];
		for (let i = this._filters.length - 1; i >= 0; --i) {
			const f = this._filters[i];
			if (f instanceof RangeFilter$1) {
				results.push(f.toDisplay(boxState, entryValArr[i]));
			} else {
				const totals = boxState[f.header]._totals;

				if (totals.yes === 0 && totals.no === 0) results.push(null);
				else results.push(f.toDisplay(boxState, entryValArr[i]));
			}
		}

		const resultsActive = results.filter(r => r !== null);
		if (this._state.mode === "or") {
			if (!resultsActive.length) return true;
			return resultsActive.find(r => r);
		} else {
			return resultsActive.filter(r => r).length === resultsActive.length;
		}
	}

	addItem () { throw new Error(`Cannot add item to MultiFilter! Add the item to a child filter instead.`); }

	handleSearch (searchTerm) {
		const isHeaderMatch = this.header.toLowerCase().includes(searchTerm);

		if (isHeaderMatch) {
			if (this.__$wrpFilter) this.__$wrpFilter.toggleClass("fltr__hidden--search", false);
						this._filters.forEach(it => it.handleSearch(""));
			return true;
		}

		const numVisible = this._filters.map(it => it.handleSearch(searchTerm)).reduce((a, b) => a + b, 0);
		if (!this.__$wrpFilter) return;
		this.__$wrpFilter.toggleClass("fltr__hidden--search", numVisible === 0);
	}
};
MultiFilter$1._DETAULT_STATE = {
	mode: "and",
};

(() => {
	const boxPrefixes = Object.values(FilterBox$1._SUB_HASH_PREFIXES).filter(it => it.length !== FilterUtil.SUB_HASH_PREFIX_LENGTH);
	const filterPrefixes = Object.values(FilterBase._SUB_HASH_PREFIXES).filter(it => it.length !== FilterUtil.SUB_HASH_PREFIX_LENGTH);
	const allPrefixes = boxPrefixes.concat(filterPrefixes);
	if (allPrefixes.length) throw new Error(`Invalid prefixes! ${allPrefixes.map(it => `"${it}"`).join(", ")} ${allPrefixes.length === 1 ? `is` : `was`} not of length ${FilterUtil.SUB_HASH_PREFIX_LENGTH}`);
})();
FilterUtil.SUB_HASH_PREFIXES = new Set([...Object.values(FilterBox$1._SUB_HASH_PREFIXES), ...Object.values(FilterBase._SUB_HASH_PREFIXES)]);

globalThis.FilterUtil = FilterUtil;
globalThis.PageFilter = PageFilter$1;
globalThis.FilterBox = FilterBox$1;
globalThis.FilterItem = FilterItem$1;
globalThis.FilterBase = FilterBase;
globalThis.Filter = Filter$1;
globalThis.SourceFilter = SourceFilter$1;
globalThis.RangeFilter = RangeFilter$1;
globalThis.OptionsFilter = OptionsFilter$1;
globalThis.MultiFilter = MultiFilter$1;

"use strict";

let PageFilterClassesBase$1 = class PageFilterClassesBase extends PageFilter {
	constructor () {
		super();

		this._miscFilter = new Filter({
			header: "Miscellaneous",
			items: ["Reprinted", "Sidekick", "SRD", "Basic Rules"],
			deselFn: (it) => { return it === "Reprinted" || it === "Sidekick"; },
			displayFnMini: it => it === "Reprinted" ? "Repr." : it,
			displayFnTitle: it => it === "Reprinted" ? it : "",
			isMiscFilter: true,
		});

		this._optionsFilter = new OptionsFilter({
			header: "Other/Text Options",
			defaultState: {
				isDisplayClassIfSubclassActive: false,
				isClassFeatureVariant: true,
			},
			displayFn: k => {
				switch (k) {
					case "isClassFeatureVariant": return "Class Feature Options/Variants";
					case "isDisplayClassIfSubclassActive": return "Display Class if Any Subclass is Visible";
					default: throw new Error(`Unhandled key "${k}"`);
				}
			},
			displayFnMini: k => {
				switch (k) {
					case "isClassFeatureVariant": return "C.F.O/V.";
					case "isDisplayClassIfSubclassActive": return "Sc>C";
					default: throw new Error(`Unhandled key "${k}"`);
				}
			},
		});
	}

	get optionsFilter () { return this._optionsFilter; }

	static mutateForFilters (cls) {
		cls.source = cls.source || Parser.SRC_PHB;
		cls.subclasses = cls.subclasses || [];

		cls._fSources = SourceFilter.getCompleteFilterSources(cls);

		cls._fSourceSubclass = [
			...new Set([
				cls.source,
				...cls.subclasses.map(it => [it.source, ...(it.otherSources || []).map(it => it.source)]).flat(),
			]),
		];

		cls._fMisc = [];
		if (cls.isReprinted) cls._fMisc.push("Reprinted");
		if (cls.srd) cls._fMisc.push("SRD");
		if (cls.basicRules) cls._fMisc.push("Basic Rules");
		if (cls.isSidekick) cls._fMisc.push("Sidekick");

		cls.subclasses.forEach(sc => {
			sc.source = sc.source || cls.source; 			sc.shortName = sc.shortName || sc.name; 
			sc._fMisc = [];
			if (sc.srd) sc._fMisc.push("SRD");
			if (sc.basicRules) sc._fMisc.push("Basic Rules");
			if (sc.isReprinted) sc._fMisc.push("Reprinted");
		});
	}

	_addEntrySourcesToFilter (entry) { this._addEntrySourcesToFilter_walk(entry); }

	_addEntrySourcesToFilter_walk = (obj) => {
		if ((typeof obj !== "object") || obj == null) return;

		if (obj instanceof Array) return obj.forEach(this._addEntrySourcesToFilter_walk.bind(this));

		if (obj.source) this._sourceFilter.addItem(obj.source);
				if (obj.entries) this._addEntrySourcesToFilter_walk(obj.entries);
	};

		addToFilters (cls, isExcluded, opts) {
		if (isExcluded) return;
		opts = opts || {};
		const subclassExclusions = opts.subclassExclusions || {};

		this._sourceFilter.addItem(cls.source);

		if (cls.fluff) cls.fluff.forEach(it => this._addEntrySourcesToFilter(it));
		cls.classFeatures.forEach(lvlFeatures => lvlFeatures.forEach(feature => this._addEntrySourcesToFilter(feature)));

		cls.subclasses.forEach(sc => {
			const isScExcluded = (subclassExclusions[sc.source] || {})[sc.name] || false;
			if (!isScExcluded) {
				this._sourceFilter.addItem(sc.source);
				sc.subclassFeatures.forEach(lvlFeatures => lvlFeatures.forEach(feature => this._addEntrySourcesToFilter(feature)));
			}
		});
	}

	async _pPopulateBoxOptions (opts) {
		opts.filters = [
			this._sourceFilter,
			this._miscFilter,
			this._optionsFilter,
		];
		opts.isCompact = true;
	}

	isClassNaturallyDisplayed (values, cls) {
		return this._filterBox.toDisplay(
			values,
			...this.constructor._getIsClassNaturallyDisplayedToDisplayParams(cls),
		);
	}

	static _getIsClassNaturallyDisplayedToDisplayParams (cls) { return [cls._fSources, cls._fMisc]; }

	isAnySubclassDisplayed (values, cls) {
		return values[this._optionsFilter.header].isDisplayClassIfSubclassActive && (cls.subclasses || [])
			.some(sc => {
				if (this._filterBox.toDisplay(
					values,
					...this.constructor._getIsSubclassDisplayedToDisplayParams(cls, sc),
				)) return true;

				return sc.otherSources?.length && sc.otherSources.some(src => this._filterBox.toDisplay(
					values,
					...this.constructor._getIsSubclassDisplayedToDisplayParams(cls, sc, src),
				));
			});
	}

	static _getIsSubclassDisplayedToDisplayParams (cls, sc, otherSourcesSource) {
		return [
			otherSourcesSource || sc.source,
			sc._fMisc,
			null,
		];
	}

	isSubclassVisible (f, cls, sc) {
		if (this.filterBox.toDisplay(
			f,
			...this.constructor._getIsSubclassVisibleToDisplayParams(cls, sc),
		)) return true;

		if (!sc.otherSources?.length) return false;

		return sc.otherSources.some(src => this.filterBox.toDisplay(
			f,
			...this.constructor._getIsSubclassVisibleToDisplayParams(cls, sc, src.source),
		));
	}

	static _getIsSubclassVisibleToDisplayParams (cls, sc, otherSourcesSource) {
		return [
			otherSourcesSource || sc.source,
			sc._fMisc,
			null,
		];
	}

		getActiveSource (values) {
		const sourceFilterValues = values[this._sourceFilter.header];
		if (!sourceFilterValues) return null;
		return Object.keys(sourceFilterValues).find(it => this._sourceFilter.toDisplay(values, it));
	}

	toDisplay (values, it) {
		return this._filterBox.toDisplay(
			values,
			...this._getToDisplayParams(values, it),
		);
	}

	_getToDisplayParams (values, cls) {
		return [
			this.isAnySubclassDisplayed(values, cls)
				? cls._fSourceSubclass
				: (cls._fSources ?? cls.source),
			cls._fMisc,
			null,
		];
	}
};

globalThis.PageFilterClassesBase = PageFilterClassesBase$1;

class PageFilterClasses extends PageFilterClassesBase$1 {
	static _getClassSubclassLevelArray (it) {
		return it.classFeatures.map((_, i) => i + 1);
	}

	constructor () {
		super();

		this._levelFilter = new RangeFilter({
			header: "Feature Level",
			min: 1,
			max: 20,
		});
	}

	get levelFilter () { return this._levelFilter; }

	static mutateForFilters (cls) {
		super.mutateForFilters(cls);

		cls._fLevelRange = this._getClassSubclassLevelArray(cls);
	}

		addToFilters (cls, isExcluded, opts) {
		super.addToFilters(cls, isExcluded, opts);

		if (isExcluded) return;

		this._levelFilter.addItem(cls._fLevelRange);
	}

	async _pPopulateBoxOptions (opts) {
		await super._pPopulateBoxOptions(opts);

		opts.filters = [
			this._sourceFilter,
			this._miscFilter,
			this._levelFilter,
			this._optionsFilter,
		];
	}

	static _getIsClassNaturallyDisplayedToDisplayParams (cls) {
		return [cls._fSources, cls._fMisc, cls._fLevelRange];
	}

	static _getIsSubclassDisplayedToDisplayParams (cls, sc, otherSourcesSource) {
		return [otherSourcesSource || sc.source, sc._fMisc, cls._fLevelRange];
	}

	static _getIsSubclassVisibleToDisplayParams (cls, sc, otherSourcesSource) {
		return [otherSourcesSource || sc.source, sc._fMisc, cls._fLevelRange, null];
	}

	_getToDisplayParams (values, cls) {
		return [
			this.isAnySubclassDisplayed(values, cls)
				? cls._fSourceSubclass
				: (cls._fSources ?? cls.source),
			cls._fMisc,
			cls._fLevelRange,
		];
	}
}

globalThis.PageFilterClasses = PageFilterClasses;

"use strict";

let PageFilterClassesRaw$1 = class PageFilterClassesRaw extends PageFilterClassesBase {
	static _WALKER = null;
	static _IMPLS_SIDE_DATA = {};

	async _pPopulateBoxOptions (opts) {
		await super._pPopulateBoxOptions(opts);
		opts.isCompact = false;
	}

		addToFilters (cls, isExcluded, opts) {
		if (isExcluded) return;
		opts = opts || {};
		const subclassExclusions = opts.subclassExclusions || {};

		this._sourceFilter.addItem(cls.source);

		if (cls.fluff) cls.fluff.forEach(it => this._addEntrySourcesToFilter(it));

		cls.classFeatures.forEach(feature => feature.loadeds.forEach(ent => this._addEntrySourcesToFilter(ent.entity)));

		cls.subclasses.forEach(sc => {
			const isScExcluded = (subclassExclusions[sc.source] || {})[sc.name] || false;
			if (!isScExcluded) {
				this._sourceFilter.addItem(sc.source);
				sc.subclassFeatures.forEach(feature => feature.loadeds.forEach(ent => this._addEntrySourcesToFilter(ent.entity)));
			}
		});
	}

		static async _pGetParentClass (sc) {
				let baseClass = (await DataUtil.class.loadRawJSON()).class.find(bc => bc.name.toLowerCase() === sc.className.toLowerCase() && (bc.source.toLowerCase() || Parser.SRC_PHB) === sc.classSource.toLowerCase());

				baseClass = baseClass || await this._pGetParentClass_pPrerelease({sc});
		baseClass = baseClass || await this._pGetParentClass_pBrew({sc});

		return baseClass;
	}

	static async _pGetParentClass_pPrerelease ({sc}) {
		await this._pGetParentClass_pPrereleaseBrew({sc, brewUtil: PrereleaseUtil});
	}

	static async _pGetParentClass_pBrew ({sc}) {
		await this._pGetParentClass_pPrereleaseBrew({sc, brewUtil: BrewUtil2});
	}

	static async _pGetParentClass_pPrereleaseBrew ({sc, brewUtil}) {
		const brew = await brewUtil.pGetBrewProcessed();
		return (brew.class || [])
			.find(bc => bc.name.toLowerCase() === sc.className.toLowerCase() && (bc.source.toLowerCase() || Parser.SRC_PHB) === sc.classSource.toLowerCase());
	}

	static async pPostLoad (data, {...opts} = {}) {
		data = MiscUtil.copy(data);

				await PrereleaseUtil.pGetBrewProcessed();
		await BrewUtil2.pGetBrewProcessed();

		if (!data.class) data.class = [];

				if (data.subclass) {
						for (const sc of data.subclass) {
				if (!sc.className) continue; 				sc.classSource = sc.classSource || Parser.SRC_PHB;

				let cls = data.class.find(it => (it.name || "").toLowerCase() === sc.className.toLowerCase() && (it.source || Parser.SRC_PHB).toLowerCase() === sc.classSource.toLowerCase());

				if (!cls) {
					cls = await this._pGetParentClass(sc);
					if (cls) {
												cls = MiscUtil.copy(cls);
						cls.subclasses = [];
						data.class.push(cls);
					} else {
												cls = {name: sc.className, source: sc.classSource};
						data.class.push(cls);
					}
				}

				(cls.subclasses = cls.subclasses || []).push(sc);
			}

			delete data.subclass;
		}

				data.class.forEach(cls => {
			cls.source = cls.source || Parser.SRC_PHB;

			cls.subclasses = cls.subclasses || [];

			cls.subclasses.forEach(sc => {
				sc.name = sc.name || "(Unnamed subclass)";
				sc.source = sc.source || cls.source;
				sc.className = sc.className || cls.name;
				sc.classSource = sc.classSource || cls.source || Parser.SRC_PHB;
			});

			cls.subclasses.sort((a, b) => SortUtil.ascSortLower(a.name, b.name) || SortUtil.ascSortLower(a.source || cls.source, b.source || cls.source));

			cls._cntStartingSkillChoices = (MiscUtil.get(cls, "startingProficiencies", "skills") || [])
				.map(it => it.choose ? (it.choose.count || 1) : 0)
				.reduce((a, b) => a + b, 0);

			cls._cntStartingSkillChoicesMutliclass = (MiscUtil.get(cls, "multiclassing", "proficienciesGained", "skills") || [])
				.map(it => it.choose ? (it.choose.count || 1) : 0)
				.reduce((a, b) => a + b, 0);
		});
		data.class.sort((a, b) => SortUtil.ascSortLower(a.name, b.name) || SortUtil.ascSortLower(a.source, b.source));

				data.class.forEach(cls => {
			cls.classFeatures = (cls.classFeatures || []).map(cf => typeof cf === "string" ? {classFeature: cf} : cf);

			(cls.subclasses || []).forEach(sc => {
				sc.subclassFeatures = (sc.subclassFeatures || []).map(cf => typeof cf === "string" ? {subclassFeature: cf} : cf);
			});
		});

						await this._pPreloadSideData();

		for (const cls of data.class) {
			await (cls.classFeatures || []).pSerialAwaitMap(cf => this.pInitClassFeatureLoadeds({...opts, classFeature: cf, className: cls.name}));

			if (cls.classFeatures) cls.classFeatures = cls.classFeatures.filter(it => !it.isIgnored);

			for (const sc of cls.subclasses || []) {
				await (sc.subclassFeatures || []).pSerialAwaitMap(scf => this.pInitSubclassFeatureLoadeds({...opts, subclassFeature: scf, className: cls.name, subclassName: sc.name}));

				if (sc.subclassFeatures) sc.subclassFeatures = sc.subclassFeatures.filter(it => !it.isIgnored);
			}
		}

		return data;
	}

	static async pInitClassFeatureLoadeds ({classFeature, className, ...opts}) {
		if (typeof classFeature !== "object") throw new Error(`Expected an object of the form {classFeature: "<UID>"}`);

		const unpacked = DataUtil.class.unpackUidClassFeature(classFeature.classFeature);

		classFeature.hash = UrlUtil.URL_TO_HASH_BUILDER["classFeature"](unpacked);

		const {name, level, source} = unpacked;
		classFeature.name = name;
		classFeature.level = level;
		classFeature.source = source;

		const entityRoot = await DataLoader.pCacheAndGet("raw_classFeature", classFeature.source, classFeature.hash, {isCopy: true});
		const loadedRoot = {
			type: "classFeature",
			entity: entityRoot,
			page: "classFeature",
			source: classFeature.source,
			hash: classFeature.hash,
			className,
		};

		const isIgnored = await this._pGetIgnoredAndApplySideData(entityRoot, "classFeature");
		if (isIgnored) {
			classFeature.isIgnored = true;
			return;
		}

		const {entityRoot: entityRootNxt, subLoadeds} = await this._pLoadSubEntries(
			this._getPostLoadWalker(),
			entityRoot,
			{
				...opts,
				ancestorType: "classFeature",
				ancestorMeta: {
					_ancestorClassName: className,
				},
			},
		);
		loadedRoot.entity = entityRootNxt;

		classFeature.loadeds = [loadedRoot, ...subLoadeds];
	}

	static async pInitSubclassFeatureLoadeds ({subclassFeature, className, subclassName, ...opts}) {
		if (typeof subclassFeature !== "object") throw new Error(`Expected an object of the form {subclassFeature: "<UID>"}`);

		const unpacked = DataUtil.class.unpackUidSubclassFeature(subclassFeature.subclassFeature);

		subclassFeature.hash = UrlUtil.URL_TO_HASH_BUILDER["subclassFeature"](unpacked);

		const {name, level, source} = unpacked;
		subclassFeature.name = name;
		subclassFeature.level = level;
		subclassFeature.source = source;

		const entityRoot = await DataLoader.pCacheAndGet("raw_subclassFeature", subclassFeature.source, subclassFeature.hash, {isCopy: true});
		const loadedRoot = {
			type: "subclassFeature",
			entity: entityRoot,
			page: "subclassFeature",
			source: subclassFeature.source,
			hash: subclassFeature.hash,
			className,
			subclassName,
		};

		const isIgnored = await this._pGetIgnoredAndApplySideData(entityRoot, "subclassFeature");
		if (isIgnored) {
			subclassFeature.isIgnored = true;
			return;
		}

		if (entityRoot.isGainAtNextFeatureLevel) {
			subclassFeature.isGainAtNextFeatureLevel = true;
		}

		const {entityRoot: entityRootNxt, subLoadeds} = await this._pLoadSubEntries(
			this._getPostLoadWalker(),
			entityRoot,
			{
				...opts,
				ancestorType: "subclassFeature",
				ancestorMeta: {
					_ancestorClassName: className,
					_ancestorSubclassName: subclassName,
				},
			},
		);
		loadedRoot.entity = entityRootNxt;

		subclassFeature.loadeds = [loadedRoot, ...subLoadeds];
	}

	static async pInitFeatLoadeds ({feat, raw, ...opts}) {
		return this._pInitGenericLoadeds({
			...opts,
			ent: feat,
			prop: "feat",
			page: UrlUtil.PG_FEATS,
			propAncestorName: "_ancestorFeatName",
			raw,
		});
	}

	static async pInitOptionalFeatureLoadeds ({optionalfeature, raw, ...opts}) {
		return this._pInitGenericLoadeds({
			...opts,
			ent: optionalfeature,
			prop: "optionalfeature",
			page: UrlUtil.PG_OPT_FEATURES,
			propAncestorName: "_ancestorOptionalfeatureName",
			raw,
		});
	}

	static async pInitRewardLoadeds ({reward, raw, ...opts}) {
		return this._pInitGenericLoadeds({
			...opts,
			ent: reward,
			prop: "reward",
			page: UrlUtil.PG_REWARDS,
			propAncestorName: "_ancestorRewardName",
			raw,
		});
	}

	static async pInitCharCreationOptionLoadeds ({charoption, raw, ...opts}) {
		return this._pInitGenericLoadeds({
			...opts,
			ent: charoption,
			prop: "charoption",
			page: UrlUtil.PG_CHAR_CREATION_OPTIONS,
			propAncestorName: "_ancestorCharoptionName",
			raw,
		});
	}

	static async pInitVehicleUpgradeLoadeds ({vehicleUpgrade, raw, ...opts}) {
		return this._pInitGenericLoadeds({
			...opts,
			ent: vehicleUpgrade,
			prop: "vehicleUpgrade",
			page: UrlUtil.PG_VEHICLES,
			propAncestorName: "_ancestorVehicleUpgradeName",
			raw,
		});
	}

	static async _pInitGenericLoadeds ({ent, prop, page, propAncestorName, raw, ...opts}) {
		if (typeof ent !== "object") throw new Error(`Expected an object of the form {${prop}: "<UID>"}`);

		const unpacked = DataUtil.generic.unpackUid(ent[prop]);

		ent.hash = UrlUtil.URL_TO_HASH_BUILDER[page](unpacked);

		const {name, source} = unpacked;
		ent.name = name;
		ent.source = source;

		const entityRoot = raw != null ? MiscUtil.copy(raw) : await DataLoader.pCacheAndGet(`raw_${prop}`, ent.source, ent.hash, {isCopy: true});
		const loadedRoot = {
			type: prop,
			entity: entityRoot,
			page,
			source: ent.source,
			hash: ent.hash,
		};

		const isIgnored = await this._pGetIgnoredAndApplySideData(entityRoot, prop);
		if (isIgnored) {
			ent.isIgnored = true;
			return;
		}

		const {entityRoot: entityRootNxt, subLoadeds} = await this._pLoadSubEntries(
			this._getPostLoadWalker(),
			entityRoot,
			{
				...opts,
				ancestorType: prop,
				ancestorMeta: {
					[propAncestorName]: entityRoot.name,
				},
			},
		);
		loadedRoot.entity = entityRootNxt;

		ent.loadeds = [loadedRoot, ...subLoadeds];
	}

		static async _pPreloadSideData () {
		await Promise.all(Object.values(PageFilterClassesRaw$1._IMPLS_SIDE_DATA).map(Impl => Impl.pPreloadSideData()));
	}

		static async _pGetIgnoredAndApplySideData (entity, type) {
		if (!PageFilterClassesRaw$1._IMPLS_SIDE_DATA[type]) throw new Error(`Unhandled type "${type}"`);

		const sideData = await PageFilterClassesRaw$1._IMPLS_SIDE_DATA[type].pGetSideLoadedMatch(entity, {prop: type, isSilent: true});

		if (!sideData) return false;
		if (sideData.isIgnored) return true;

		if (sideData.entries) entity.entries = MiscUtil.copy(sideData.entries);
		if (sideData.entryData) entity.entryData = MiscUtil.copy(sideData.entryData);

		return false;
	}

		static async _pLoadSubEntries (walker, entityRoot, {ancestorType, ancestorMeta, ...opts}) {
		const out = [];

		const pRecurse = async (parent, toWalk) => {
			const references = [];
			const path = [];

			toWalk = walker.walk(
				toWalk,
				{
					array: (arr) => {
						arr = arr
							.map(it => this._pLoadSubEntries_getMappedWalkerArrayEntry({...opts, it, path, references}))
							.filter(Boolean);
						return arr;
					},
					preObject: (obj) => {
						if (obj.type === "options") {
							const parentName = (path.last() || {}).name ?? parent.name;

																					if (obj.count != null) {
								const optionSetId = CryptUtil.uid();
								obj.entries.forEach(ent => {
									ent._optionsMeta = {
										setId: optionSetId,
										count: obj.count,
										name: parentName,
									};
								});
							}

							if (parentName) {
								obj.entries.forEach(ent => {
									if (typeof ent !== "object") return;
									ent._displayNamePrefix = `${parentName}: `;
								});
							}
						}

						if (obj.name) path.push(obj);
					},
					postObject: (obj) => {
						if (obj.name) path.pop();
					},
				},
			);

			for (const ent of references) {
				const isRequiredOption = !!MiscUtil.get(ent, "data", "isRequiredOption");
				switch (ent.type) {
					case "refClassFeature": {
						const unpacked = DataUtil.class.unpackUidClassFeature(ent.classFeature);
						const {source} = unpacked;
						const hash = UrlUtil.URL_TO_HASH_BUILDER["classFeature"](unpacked);

						let entity = await DataLoader.pCacheAndGet("raw_classFeature", source, hash, {isCopy: true});

						if (!entity) {
							this._handleReferenceError(`Failed to load "classFeature" reference "${ent.classFeature}" (not found)`);
							continue;
						}

						if (toWalk.__prop === entity.__prop && UrlUtil.URL_TO_HASH_BUILDER["classFeature"](toWalk) === hash) {
							this._handleReferenceError(`Failed to load "classFeature" reference "${ent.classFeature}" (circular reference)`);
							continue;
						}

						const isIgnored = await this._pGetIgnoredAndApplySideData(entity, "classFeature");
						if (isIgnored) continue;

						this.populateEntityTempData({
							entity,
							displayName: ent._displayNamePrefix ? `${ent._displayNamePrefix}${entity.name}` : null,
							...ancestorMeta,
						});

						out.push({
							type: "classFeature",
							entry: `{@classFeature ${ent.classFeature}}`,
							entity,
							optionsMeta: ent._optionsMeta,
							page: "classFeature",
							source,
							hash,
							isRequiredOption,
						});

						entity = await pRecurse(entity, entity.entries);

						break;
					}
					case "refSubclassFeature": {
						const unpacked = DataUtil.class.unpackUidSubclassFeature(ent.subclassFeature);
						const {source} = unpacked;
						const hash = UrlUtil.URL_TO_HASH_BUILDER["subclassFeature"](unpacked);

						let entity = await DataLoader.pCacheAndGet("raw_subclassFeature", source, hash, {isCopy: true});

						if (!entity) {
							this._handleReferenceError(`Failed to load "subclassFeature" reference "${ent.subclassFeature}" (not found)`);
							continue;
						}

						if (toWalk.__prop === entity.__prop && UrlUtil.URL_TO_HASH_BUILDER["subclassFeature"](toWalk) === hash) {
							this._handleReferenceError(`Failed to load "subclassFeature" reference "${ent.subclassFeature}" (circular reference)`);
							continue;
						}

						const isIgnored = await this._pGetIgnoredAndApplySideData(entity, "subclassFeature");
						if (isIgnored) continue;

						this.populateEntityTempData({
							entity,
							displayName: ent._displayNamePrefix ? `${ent._displayNamePrefix}${entity.name}` : null,
							...ancestorMeta,
						});

						out.push({
							type: "subclassFeature",
							entry: `{@subclassFeature ${ent.subclassFeature}}`,
							entity,
							optionsMeta: ent._optionsMeta,
							page: "subclassFeature",
							source,
							hash,
							isRequiredOption,
						});

						entity = await pRecurse(entity, entity.entries);

						break;
					}
					case "refOptionalfeature": {
						const unpacked = DataUtil.generic.unpackUid(ent.optionalfeature, "optfeature");
						const page = UrlUtil.PG_OPT_FEATURES;
						const {source} = unpacked;
						const hash = UrlUtil.URL_TO_HASH_BUILDER[page](unpacked);

						const entity = await DataLoader.pCacheAndGet(page, source, hash, {isCopy: true});

						if (!entity) {
							this._handleReferenceError(`Failed to load "optfeature" reference "${ent.optionalfeature}" (not found)`);
							continue;
						}

						if (toWalk.__prop === entity.__prop && UrlUtil.URL_TO_HASH_BUILDER[page](toWalk) === hash) {
							this._handleReferenceError(`Failed to load "optfeature" reference "${ent.optionalfeature}" (circular reference)`);
							continue;
						}

						const isIgnored = await this._pGetIgnoredAndApplySideData(entity, "optionalfeature");
						if (isIgnored) continue;

						this.populateEntityTempData({
							entity,
														ancestorType,
							displayName: ent._displayNamePrefix ? `${ent._displayNamePrefix}${entity.name}` : null,
							...ancestorMeta,
							foundrySystem: {
								requirements: entityRoot.className ? `${entityRoot.className} ${entityRoot.level}${entityRoot.subclassShortName ? ` (${entityRoot.subclassShortName})` : ""}` : null,
							},
						});

						out.push({
							type: "optionalfeature",
							entry: `{@optfeature ${ent.optionalfeature}}`,
							entity,
							optionsMeta: ent._optionsMeta,
							page,
							source,
							hash,
							isRequiredOption,
						});

						break;
					}
					default: throw new Error(`Unhandled type "${ent.type}"`);
				}
			}

			return toWalk;
		};

		if (entityRoot.entries) entityRoot.entries = await pRecurse(entityRoot, entityRoot.entries);

		return {entityRoot, subLoadeds: out};
	}

	static _pLoadSubEntries_getMappedWalkerArrayEntry ({it, path, references, ...opts}) {
		if (it.type !== "refClassFeature" && it.type !== "refSubclassFeature" && it.type !== "refOptionalfeature") return it;

		it.parentName = (path.last() || {}).name;
		references.push(it);

		return null;
	}

	static populateEntityTempData (
		{
			entity,
			ancestorType,
			displayName,
			foundrySystem,
			...others
		},
	) {
		if (ancestorType) entity._ancestorType = ancestorType;
		if (displayName) entity._displayName = displayName;
		if (foundrySystem) entity._foundrySystem = foundrySystem;
		Object.assign(entity, {...others});
	}

	static _handleReferenceError (msg) {
		JqueryUtil.doToast({type: "danger", content: msg});
	}

	static _getPostLoadWalker () {
		PageFilterClassesRaw$1._WALKER = PageFilterClassesRaw$1._WALKER || MiscUtil.getWalker({
			keyBlocklist: MiscUtil.GENERIC_WALKER_ENTRIES_KEY_BLOCKLIST,
			isDepthFirst: true,
		});
		return PageFilterClassesRaw$1._WALKER;
	}

	static setImplSideData (prop, Impl) { PageFilterClassesRaw$1._IMPLS_SIDE_DATA[prop] = Impl; }
	};

globalThis.PageFilterClassesRaw = PageFilterClassesRaw$1;

let ModalFilterClasses$1 = class ModalFilterClasses extends ModalFilter {
		constructor (opts) {
		opts = opts || {};

		super({
			...opts,
			modalTitle: "Class and Subclass",
			pageFilter: new PageFilterClassesRaw$1(),
			fnSort: ModalFilterClasses$1.fnSort,
		});

		this._pLoadingAllData = null;

		this._ixPrevSelectedClass = null;
		this._isClassDisabled = false;
		this._isSubclassDisabled = false;
	}

	get pageFilter () { return this._pageFilter; }

	static fnSort (a, b, opts) {
		const out = SortUtil.listSort(a, b, opts);

		if (opts.sortDir === "desc" && a.data.ixClass === b.data.ixClass && (a.data.ixSubclass != null || b.data.ixSubclass != null)) {
			return a.data.ixSubclass != null ? -1 : 1;
		}

		return out;
	}

		async pGetSelection (classSubclassMeta) {
		const {className, classSource, subclassName, subclassSource} = classSubclassMeta;

		const allData = this._allData || await this._pLoadAllData();

		const cls = allData.find(it => it.name === className && it.source === classSource);
		if (!cls) throw new Error(`Could not find class with name "${className}" and source "${classSource}"`);

		const out = {
			class: cls,
		};

		if (subclassName && subclassSource) {
			const sc = cls.subclasses.find(it => it.name === subclassName && it.source === subclassSource);
			if (!sc) throw new Error(`Could not find subclass with name "${subclassName}" and source "${subclassSource}" on class with name "${className}" and source "${classSource}"`);

			out.subclass = sc;
		}

		return out;
	}

	async pGetUserSelection ({filterExpression = null, selectedClass = null, selectedSubclass = null, isClassDisabled = false, isSubclassDisabled = false} = {}) {
				return new Promise(async resolve => {
			const {$modalInner, doClose} = await this._pGetShowModal(resolve);

			await this.pPreloadHidden($modalInner);

			this._doApplyFilterExpression(filterExpression);

			this._filterCache.$btnConfirm.off("click").click(async () => {
								const checked = this._filterCache.list.items.filter(it => it.data.tglSel.classList.contains("active"));
				const out = {};
				checked.forEach(it => {
					if (it.data.ixSubclass == null) out.class = this._filterCache.allData[it.data.ixClass];
					else out.subclass = this._filterCache.allData[it.data.ixClass].subclasses[it.data.ixSubclass];
				});
				resolve(MiscUtil.copy(out));

				doClose(true);

				ModalFilterClasses$1._doListDeselectAll(this._filterCache.list);
			});

						this._ixPrevSelectedClass = selectedClass != null
				? this._filterCache.allData.findIndex(it => it.name === selectedClass.name && it.source === selectedClass.source)
				: null;
			this._isClassDisabled = isClassDisabled;
			this._isSubclassDisabled = isSubclassDisabled;
			this._filterCache.list.items.forEach(li => {
				const isScLi = li.data.ixSubclass != null;
				if (isScLi) {
					li.data.tglSel.classList.toggle("disabled", this._isSubclassDisabled || (this._isClassDisabled && li.data.ixClass !== this._ixPrevSelectedClass));
				} else {
					li.data.tglSel.classList.toggle("disabled", this._isClassDisabled);
				}
			});

			if (selectedClass != null) {
								const ixSubclass = ~this._ixPrevSelectedClass && selectedSubclass != null ? this._filterCache.allData[this._ixPrevSelectedClass].subclasses.findIndex(it => it.name === selectedSubclass.name && it.source === selectedSubclass.source) : -1;

				if (~this._ixPrevSelectedClass) {
					ModalFilterClasses$1._doListDeselectAll(this._filterCache.list);

					const clsItem = this._filterCache.list.items.find(it => it.data.ixClass === this._ixPrevSelectedClass && it.data.ixSubclass == null);
					if (clsItem) {
						clsItem.data.tglSel.classList.add("active");
						clsItem.ele.classList.add("list-multi-selected");
					}

					if (~ixSubclass && clsItem) {
						const scItem = this._filterCache.list.items.find(it => it.data.ixClass === this._ixPrevSelectedClass && it.data.ixSubclass === ixSubclass);
						scItem.data.tglSel.classList.add("active");
						scItem.ele.classList.add("list-multi-selected");
					}
				}
				
								this._filterCache.list.setFnSearch((li, searchTerm) => {
					if (li.data.ixClass !== this._ixPrevSelectedClass) return false;
					return List.isVisibleDefaultSearch(li, searchTerm);
				});
							} else {
				this._filterCache.list.setFnSearch(null);
			}

						this._filterCache.list.update();

			await UiUtil.pDoForceFocus(this._filterCache.$iptSearch[0]);
		});
	}

	async pPreloadHidden ($modalInner) {
				$modalInner = $modalInner || $(`<div></div>`);

		if (this._filterCache) {
			this._filterCache.$wrpModalInner.appendTo($modalInner);
		} else {
			await this._pInit();

			const $ovlLoading = $(`<div class="w-100 h-100 ve-flex-vh-center"><i class="dnd-font ve-muted">Loading...</i></div>`).appendTo($modalInner);

			const $iptSearch = $(`<input class="form-control" type="search" placeholder="Search...">`);
			const $btnReset = $(`<button class="btn btn-default">Reset</button>`);
			const $wrpFormTop = $$`<div class="ve-flex input-group btn-group w-100 lst__form-top">${$iptSearch}${$btnReset}</div>`;

			const $wrpFormBottom = $(`<div class="w-100"></div>`);

			const $wrpFormHeaders = $(`<div class="input-group input-group--bottom ve-flex no-shrink">
				<div class="btn btn-default disabled col-1 pl-0"></div>
				<button class="col-9 sort btn btn-default btn-xs" data-sort="name">Name</button>
				<button class="col-2 pr-0 sort btn btn-default btn-xs ve-grow" data-sort="source">Source</button>
			</div>`);

			const $wrpForm = $$`<div class="ve-flex-col w-100 mb-2">${$wrpFormTop}${$wrpFormBottom}${$wrpFormHeaders}</div>`;
			const $wrpList = this._$getWrpList();

			const $btnConfirm = $(`<button class="btn btn-default">Confirm</button>`);

			const list = new List({
				$iptSearch,
				$wrpList,
				fnSort: this._fnSort,
			});

			SortUtil.initBtnSortHandlers($wrpFormHeaders, list);

			const allData = this._allData || await this._pLoadAllData();
			const pageFilter = this._pageFilter;

			await pageFilter.pInitFilterBox({
				$wrpFormTop,
				$btnReset,
				$wrpMiniPills: $wrpFormBottom,
				namespace: this._namespace,
			});

			allData.forEach((it, i) => {
				pageFilter.mutateAndAddToFilters(it);
				const filterListItems = this._getListItems(pageFilter, it, i);
				filterListItems.forEach(li => {
					list.addItem(li);
					li.ele.addEventListener("click", evt => {
						const isScLi = li.data.ixSubclass != null;

						if (isScLi) {
							if (this._isSubclassDisabled) return;
							if (this._isClassDisabled && li.data.ixClass !== this._ixPrevSelectedClass) return;
						} else {
							if (this._isClassDisabled) return;
						}

						this._handleSelectClick({list,
							filterListItems,
							filterListItem: li,
							evt,
						});
					});
				});
			});

			list.init();
			list.update();

			const handleFilterChange = () => {
				return this.constructor.handleFilterChange({pageFilter, list, allData});
			};

			pageFilter.trimState();

			pageFilter.filterBox.on(FilterBox.EVNT_VALCHANGE, handleFilterChange);
			pageFilter.filterBox.render();
			handleFilterChange();

			$ovlLoading.remove();

			const $wrpModalInner = $$`<div class="ve-flex-col h-100">
				${$wrpForm}
				${$wrpList}
				<div class="ve-flex-vh-center">${$btnConfirm}</div>
			</div>`.appendTo($modalInner);

			this._filterCache = {$wrpModalInner, $btnConfirm, pageFilter, list, allData, $iptSearch};
		}
	}

	static handleFilterChange ({pageFilter, list, allData}) {
		const f = pageFilter.filterBox.getValues();

		list.filter(li => {
			const cls = allData[li.data.ixClass];

			if (li.data.ixSubclass != null) {
				const sc = cls.subclasses[li.data.ixSubclass];
								if (
					!pageFilter.toDisplay(
						f,
						cls,
						[],
						null,
					)
				) return false;

				return pageFilter.filterBox.toDisplay(
					f,
					sc.source,
					sc._fMisc,
					null,
				);
			}

			return pageFilter.toDisplay(f, cls, [], null);
		});
	}

	static _doListDeselectAll (list, {isSubclassItemsOnly = false} = {}) {
		list.items.forEach(it => {
			if (isSubclassItemsOnly && it.data.ixSubclass == null) return;

			if (it.data.tglSel) it.data.tglSel.classList.remove("active");
			it.ele.classList.remove("list-multi-selected");
		});
	}

	_handleSelectClick ({list, filterListItems, filterListItem, evt}) {
		evt.preventDefault();
		evt.stopPropagation();

		const isScLi = filterListItem.data.ixSubclass != null;

				if (this._isClassDisabled && this._ixPrevSelectedClass != null && isScLi) {
			if (!filterListItem.data.tglSel.classList.contains("active")) this.constructor._doListDeselectAll(list, {isSubclassItemsOnly: true});
			filterListItem.data.tglSel.classList.toggle("active");
			filterListItem.ele.classList.toggle("list-multi-selected");
			return;
		}

				if (filterListItem.data.tglSel.classList.contains("active")) {
			this.constructor._doListDeselectAll(list);
			return;
		}
		
				this.constructor._doListDeselectAll(list);

		if (isScLi) {
			const classItem = filterListItems[0];
			classItem.data.tglSel.classList.add("active");
			classItem.ele.classList.add("list-multi-selected");
		}

		filterListItem.data.tglSel.classList.add("active");
		filterListItem.ele.classList.add("list-multi-selected");
			}

		async _pLoadAllData () {
		this._pLoadingAllData = this._pLoadingAllData || (async () => {
			const [data, prerelease, brew] = await Promise.all([
				MiscUtil.copy(await DataUtil.class.loadRawJSON()),
				PrereleaseUtil.pGetBrewProcessed(),
				BrewUtil2.pGetBrewProcessed(),
			]);

						this._pLoadAllData_mutAddPrereleaseBrew({data, brew: prerelease, brewUtil: PrereleaseUtil});
			this._pLoadAllData_mutAddPrereleaseBrew({data, brew: brew, brewUtil: BrewUtil2});

			this._allData = (await PageFilterClassesRaw$1.pPostLoad(data)).class;
		})();

		await this._pLoadingAllData;
		return this._allData;
	}

	_pLoadAllData_mutAddPrereleaseBrew ({data, brew, brewUtil}) {
		const clsProps = brewUtil.getPageProps({page: UrlUtil.PG_CLASSES});

		if (!clsProps.includes("*")) {
			clsProps.forEach(prop => data[prop] = [...(data[prop] || []), ...MiscUtil.copy(brew[prop] || [])]);
			return;
		}

		Object.entries(brew)
			.filter(([, brewVal]) => brewVal instanceof Array)
			.forEach(([prop, brewArr]) => data[prop] = [...(data[prop] || []), ...MiscUtil.copy(brewArr)]);
	}

	_getListItems (pageFilter, cls, clsI) {
		return [
			this._getListItems_getClassItem(pageFilter, cls, clsI),
			...cls.subclasses.map((sc, scI) => this._getListItems_getSubclassItem(pageFilter, cls, clsI, sc, scI)),
		];
	}

	_getListItems_getClassItem (pageFilter, cls, clsI) {
		const eleLabel = document.createElement("label");
		eleLabel.className = `w-100 ve-flex lst--border veapp__list-row no-select lst__wrp-cells`;

		const source = Parser.sourceJsonToAbv(cls.source);

		eleLabel.innerHTML = `<div class="col-1 pl-0 ve-flex-vh-center"><div class="fltr-cls__tgl"></div></div>
		<div class="bold col-9 ${cls._versionBase_isVersion ? "italic" : ""}">${cls._versionBase_isVersion ? `<span class="px-3"></span>` : ""}${cls.name}</div>
		<div class="col-2 pr-0 text-center ${Parser.sourceJsonToColor(cls.source)}" title="${Parser.sourceJsonToFull(cls.source)}" ${Parser.sourceJsonToStyle(cls.source)}>${source}</div>`;

		return new ListItem(
			clsI,
			eleLabel,
			`${cls.name} -- ${cls.source}`,
			{
				source: `${source} -- ${cls.name}`,
			},
			{
				ixClass: clsI,
				tglSel: eleLabel.firstElementChild.firstElementChild,
			},
		);
	}

	_getListItems_getSubclassItem (pageFilter, cls, clsI, sc, scI) {
		const eleLabel = document.createElement("label");
		eleLabel.className = `w-100 ve-flex lst--border veapp__list-row no-select lst__wrp-cells`;

		const source = Parser.sourceJsonToAbv(sc.source);

		eleLabel.innerHTML = `<div class="col-1 pl-0 ve-flex-vh-center"><div class="fltr-cls__tgl"></div></div>
		<div class="col-9 pl-1 ve-flex-v-center ${sc._versionBase_isVersion ? "italic" : ""}">${sc._versionBase_isVersion ? `<span class="px-3"></span>` : ""}<span class="mx-3">\u2014</span> ${sc.name}</div>
		<div class="col-2 pr-0 text-center ${Parser.sourceJsonToColor(sc.source)}" title="${Parser.sourceJsonToFull(sc.source)}" ${Parser.sourceJsonToStyle(sc.source)}>${source}</div>`;

		return new ListItem(
			`${clsI}--${scI}`,
			eleLabel,
			`${cls.name} -- ${cls.source} -- ${sc.name} -- ${sc.source}`,
			{
				source: `${cls.source} -- ${cls.name} -- ${source} -- ${sc.name}`,
			},
			{
				ixClass: clsI,
				ixSubclass: scI,
				tglSel: eleLabel.firstElementChild.firstElementChild,
			},
		);
	}
};

globalThis.ModalFilterClasses = ModalFilterClasses$1;

"use strict";

let BlocklistUtil$1 = class BlocklistUtil {
	static _IGNORED_CATEGORIES = new Set([
		"_meta",
		"linkedLootTables",

				"itemProperty",
		"itemType",
		"itemEntry",
		"itemTypeAdditionalEntries",
	]);

	static _BASIC_FILES = [
		"actions.json",
		"adventures.json",
		"backgrounds.json",
		"books.json",
		"cultsboons.json",
		"charcreationoptions.json",
		"conditionsdiseases.json",
		"deities.json",
		"feats.json",
		"items-base.json",
		"magicvariants.json",
		"items.json",
		"objects.json",
		"optionalfeatures.json",
		"psionics.json",
		"recipes.json",
		"rewards.json",
		"trapshazards.json",
		"variantrules.json",
		"vehicles.json",
		"decks.json",
	];

	static async pLoadData () {
		const out = {};

		this._addData(out, {monster: MiscUtil.copy(await DataUtil.monster.pLoadAll())});
		this._addData(out, {spell: MiscUtil.copy(await DataUtil.spell.pLoadAll())});
		this._addData(out, MiscUtil.copy(await DataUtil.class.loadRawJSON()));
		this._addData(out, MiscUtil.copy(await DataUtil.race.loadJSON({isAddBaseRaces: true})));

		const jsons = await Promise.all(this._BASIC_FILES.map(url => DataUtil.loadJSON(`${Renderer.get().baseUrl}data/${url}`)));
		for (let json of jsons) {
			if (json.magicvariant) {
				json = MiscUtil.copy(json);
				json.magicvariant.forEach(it => it.source = SourceUtil.getEntitySource(it));
			}
			this._addData(out, json);
		}

		return out;
	}

	static _addData (out, json) {
		Object.keys(json)
			.filter(it => !this._IGNORED_CATEGORIES.has(it))
			.forEach(k => out[k] ? out[k] = out[k].concat(json[k]) : out[k] = json[k]);
	}
};

globalThis.BlocklistUtil = BlocklistUtil$1;

let BlocklistUi$1 = class BlocklistUi {
	constructor (
		{
			$wrpContent,
			data,
			isCompactUi = false,
			isAutoSave = true,
		},
	) {
		this._$wrpContent = $wrpContent;
		this._data = data;
		this._isCompactUi = !!isCompactUi;
		this._isAutoSave = !!isAutoSave;

		this._excludes = ExcludeUtil.getList();

		this._subBlocklistEntries = {};

		this._allSources = null;
		this._allCategories = null;

		this._$wrpControls = null;

		this._comp = null;

		this._$wrpSelName = null;
		this._metaSelName = null;
	}

	_addExclude (displayName, hash, category, source) {
		if (!this._excludes.find(row => row.source === source && row.category === category && row.hash === hash)) {
			this._excludes.push({displayName, hash, category, source});
			if (this._isAutoSave) ExcludeUtil.pSetList(MiscUtil.copy(this._excludes)).then(null);
			return true;
		}
		return false;
	}

	_removeExclude (hash, category, source) {
		const ix = this._excludes.findIndex(row => row.source === source && row.category === category && row.hash === hash);
		if (~ix) {
			this._excludes.splice(ix, 1);
			if (this._isAutoSave) ExcludeUtil.pSetList(MiscUtil.copy(this._excludes)).then(null);
		}
	}

	_resetExcludes () {
		this._excludes = [];
		if (this._isAutoSave) ExcludeUtil.pSetList(MiscUtil.copy(this._excludes)).then(null);
	}

	async _pInitSubBlocklistEntries () {
		for (const c of (this._data.class || [])) {
			const classHash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES](c);

			const subBlocklist = this._data.classFeature
				.filter(it => it.className === c.name && it.classSource === c.source)
				.map(it => {
					const hash = UrlUtil.URL_TO_HASH_BUILDER["classFeature"](it);
					const displayName = `${this._getDisplayNamePrefix_classFeature(it)}${it.name}`;
					return {displayName, hash, category: "classFeature", source: it.source};
				});
			MiscUtil.set(this._subBlocklistEntries, "class", classHash, subBlocklist);
		}

		for (const sc of (this._data.subclass || [])) {
			const subclassHash = UrlUtil.URL_TO_HASH_BUILDER["subclass"](sc);

			const subBlocklist = this._data.subclassFeature
				.filter(it => it.className === sc.className && it.classSource === sc.classSource && it.subclassShortName === sc.shortName && it.subclassSource === sc.source)
				.map(it => {
					const hash = UrlUtil.URL_TO_HASH_BUILDER["subclassFeature"](it);
					const displayName = `${this._getDisplayNamePrefix_subclassFeature(it)}${it.name}`;
					return {displayName, hash, category: "subclassFeature", source: it.source};
				});
			MiscUtil.set(this._subBlocklistEntries, "subclass", subclassHash, subBlocklist);
		}

		for (const it of (this._data.itemGroup || [])) {
			const itemGroupHash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS](it);

			const subBlocklist = (await it.items.pSerialAwaitMap(async uid => {
				let [name, source] = uid.split("|");
				source = Parser.getTagSource("item", source);
				const hash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS]({name, source});
				const item = await DataLoader.pCacheAndGet(UrlUtil.PG_ITEMS, source, hash);
				if (!item) return null;
				return {displayName: item.name, hash, category: "item", source: item.source};
			})).filter(Boolean);

			MiscUtil.set(this._subBlocklistEntries, "itemGroup", itemGroupHash, subBlocklist);
		}

		for (const it of (this._data.race || []).filter(it => it._isBaseRace || it._versions?.length)) {
			const baseRaceHash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_RACES](it);
			const subBlocklist = [];

			if (it._isBaseRace) {
				subBlocklist.push(
					...it._subraces.map(sr => {
						const hash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_RACES](sr);
						return {displayName: sr.name, hash, category: "race", source: sr.source};
					}),
				);
			}

			if (it._versions?.length) {
				subBlocklist.push(
					...DataUtil.proxy.getVersions(it.__prop, it).map(ver => {
						const hash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_RACES](ver);
						return {displayName: ver.name, hash, category: "race", source: ver.source};
					}),
				);
			}

			MiscUtil.set(this._subBlocklistEntries, "race", baseRaceHash, subBlocklist);
		}
	}

	_getDisplayValues (category, source) {
		const displaySource = source === "*" ? source : Parser.sourceJsonToFullCompactPrefix(source);
		const displayCategory = category === "*" ? category : Parser.getPropDisplayName(category);
		return {displaySource, displayCategory};
	}

	_renderList () {
		this._excludes
			.sort((a, b) => SortUtil.ascSort(a.source, b.source) || SortUtil.ascSort(a.category, b.category) || SortUtil.ascSort(a.displayName, b.displayName))
			.forEach(({displayName, hash, category, source}) => this._addListItem(displayName, hash, category, source));
		this._list.init();
		this._list.update();
	}

	_getDisplayNamePrefix_classFeature (it) { return `${it.className} ${it.level}: `; }
	_getDisplayNamePrefix_subclassFeature (it) { return `${it.className} (${it.subclassShortName}) ${it.level}: `; }

	async pInit () {
		await this._pInitSubBlocklistEntries();
		this._pInit_initUi();
		this._pInit_render();
		this._renderList();
	}

	_pInit_initUi () {
		this._$wrpControls = $(`<div ${this._isCompactUi ? "" : `class="bg-solid py-5 px-3 shadow-big b-1p"`}></div>`);

		const $iptSearch = $(`<input type="search" class="search form-control lst__search lst__search--no-border-h h-100">`).disableSpellcheck();

		const $btnReset = $(`<button class="btn btn-default">Reset Search</button>`)
			.click(() => {
				$iptSearch.val("");
				this._list.reset();
			});

		const $wrpFilterTools = $$`<div class="input-group input-group--bottom ve-flex no-shrink">
			<button class="col-4 sort btn btn-default btn-xs ve-grow" data-sort="source">Source</button>
			<button class="col-2 sort btn btn-default btn-xs" data-sort="category">Category</button>
			<button class="col-5 sort btn btn-default btn-xs" data-sort="name">Name</button>
			<button class="col-1 sort btn btn-default btn-xs" disabled>&nbsp;</button>
		</div>`;

		const $wrpList = $(`<div class="list-display-only smooth-scroll overflow-y-auto h-100 min-h-0"></div>`);

		$$(this._$wrpContent.empty())`
			${this._$wrpControls}

			<hr class="${this._isCompactUi ? "hr-2" : "hr-5"}">

			<h4 class="my-0">Blocklist</h4>
			<div class="text-muted ${this._isCompactUi ? "mb-2" : "mb-3"}"><i>Rows marked with an asterisk (*) in a field match everything in that field.</i></div>

			<div class="ve-flex-col min-h-0">
				<div class="ve-flex-v-stretch input-group input-group--top no-shrink">
					<div class="w-100 relative">
						${$iptSearch}
						<div class="lst__wrp-search-glass no-events ve-flex-vh-center"><span class="glyphicon glyphicon-search"></span></div>
						<div class="lst__wrp-search-visible no-events ve-flex-vh-center"></div>
					</div>
					${$btnReset}
				</div>

				${$wrpFilterTools}

				${$wrpList}
			</div>`;

		this._list = new List({
			$iptSearch,
			$wrpList,
			isUseJquery: true,
		});
		this._listId = 1;

		SortUtil.initBtnSortHandlers($wrpFilterTools, this._list);
	}

	_pInit_render () {
				const $btnExcludeAllUa = $(this._getBtnHtml_addToBlocklist())
			.click(() => this._addAllUa());
		const $btnIncludeAllUa = $(this._getBtnHtml_removeFromBlocklist())
			.click(() => this._removeAllUa());

		const $btnExcludeAllSources = $(this._getBtnHtml_addToBlocklist())
			.click(() => this._addAllSources());
		const $btnIncludeAllSources = $(this._getBtnHtml_removeFromBlocklist())
			.click(() => this._removeAllSources());

		const $btnExcludeAllComedySources = $(this._getBtnHtml_addToBlocklist())
			.click(() => this._addAllComedySources());
		const $btnIncludeAllComedySources = $(this._getBtnHtml_removeFromBlocklist())
			.click(() => this._removeAllComedySources());

		const $btnExcludeAllNonForgottenRealmsSources = $(this._getBtnHtml_addToBlocklist())
			.click(() => this._addAllNonForgottenRealms());
		const $btnIncludeAllNonForgottenRealmsSources = $(this._getBtnHtml_removeFromBlocklist())
			.click(() => this._removeAllNonForgottenRealms());
		
				const sourceSet = new Set();
		const propSet = new Set();
		Object.keys(this._data).forEach(prop => {
			propSet.add(prop);
			const arr = this._data[prop];
			arr.forEach(it => sourceSet.has(it.source) || sourceSet.add(it.source));
		});

		this._allSources = [...sourceSet]
			.sort((a, b) => SortUtil.ascSort(Parser.sourceJsonToFull(a), Parser.sourceJsonToFull(b)));

		this._allCategories = [...propSet]
			.sort((a, b) => SortUtil.ascSort(Parser.getPropDisplayName(a), Parser.getPropDisplayName(b)));

		this._comp = new BlocklistUi$1.Component();

		const $selSource = ComponentUiUtil.$getSelSearchable(
			this._comp,
			"source",
			{
				values: ["*", ...this._allSources],
				fnDisplay: val => val === "*" ? val : Parser.sourceJsonToFull(val),
			},
		);
		this._comp.addHook("source", () => this._doHandleSourceCategorySelChange());

		const $selCategory = ComponentUiUtil.$getSelSearchable(
			this._comp,
			"category",
			{
				values: ["*", ...this._allCategories],
				fnDisplay: val => val === "*" ? val : Parser.getPropDisplayName(val),
			},
		);
		this._comp.addHook("category", () => this._doHandleSourceCategorySelChange());

		this._$wrpSelName = $(`<div class="w-100 ve-flex"></div>`);
		this._doHandleSourceCategorySelChange();

		const $btnAddExclusion = $(`<button class="btn btn-default btn-xs">Add to Blocklist</button>`)
			.click(() => this._pAdd());
		
				const $btnSendToFoundry = !IS_VTT && ExtensionUtil.ACTIVE
			? $(`<button title="Send to Foundry" class="btn btn-xs btn-default mr-2"><span class="glyphicon glyphicon-send"></span></button>`)
				.click(evt => this._pDoSendToFoundry({isTemp: !!evt.shiftKey}))
			: null;
		const $btnExport = $(`<button class="btn btn-default btn-xs">Export List</button>`)
			.click(() => this._export());
		const $btnImport = $(`<button class="btn btn-default btn-xs" title="SHIFT for Add Only">Import List</button>`)
			.click(evt => this._pImport(evt));
		const $btnReset = $(`<button class="btn btn-danger btn-xs">Reset List</button>`)
			.click(async () => {
				if (!await InputUiUtil.pGetUserBoolean({title: "Reset Blocklist", htmlDescription: "Are you sure?", textYes: "Yes", textNo: "Cancel"})) return;
				this._reset();
			});
		
		$$`<div class="${this._isCompactUi ? "mb-2" : "mb-5"} ve-flex-v-center">
			<div class="ve-flex-vh-center mr-4">
				<div class="mr-2">UA/Etc. Sources</div>
				<div class="ve-flex-v-center btn-group">
					${$btnExcludeAllUa}
					${$btnIncludeAllUa}
				</div>
			</div>

			<div class="ve-flex-vh-center mr-3">
				<div class="mr-2">Comedy Sources</div>
				<div class="ve-flex-v-center btn-group">
					${$btnExcludeAllComedySources}
					${$btnIncludeAllComedySources}
				</div>
			</div>

			<div class="ve-flex-vh-center mr-3">
				<div class="mr-2">Non-<i>Forgotten Realms</i></div>
				<div class="ve-flex-v-center btn-group">
					${$btnExcludeAllNonForgottenRealmsSources}
					${$btnIncludeAllNonForgottenRealmsSources}
				</div>
			</div>

			<div class="ve-flex-vh-center mr-3">
				<div class="mr-2">All Sources</div>
				<div class="ve-flex-v-center btn-group">
					${$btnExcludeAllSources}
					${$btnIncludeAllSources}
				</div>
			</div>
		</div>

		<div class="ve-flex-v-end ${this._isCompactUi ? "mb-2" : "mb-5"}">
			<div class="ve-flex-col w-25 pr-2">
				<label class="mb-1">Source</label>
				${$selSource}
			</div>

			<div class="ve-flex-col w-25 px-2">
				<label class="mb-1">Category</label>
				${$selCategory}
			</div>

			<div class="ve-flex-col w-25 px-2">
				<label class="mb-1">Name</label>
				${this._$wrpSelName}
			</div>

			<div class="ve-flex-col w-25 pl-2">
				<div class="mt-auto">
					${$btnAddExclusion}
				</div>
			</div>
		</div>

		<div class="w-100 ve-flex-v-center">
			${$btnSendToFoundry}
			<div class="ve-flex-v-center btn-group mr-2">
				${$btnExport}
				${$btnImport}
			</div>
			${$btnReset}
		</div>`.appendTo(this._$wrpControls.empty());
	}

	_getBtnHtml_addToBlocklist () {
		return `<button class="btn btn-danger btn-xs w-20p h-21p ve-flex-vh-center" title="Add to Blocklist"><span class="glyphicon glyphicon-trash"></span></button>`;
	}

	_getBtnHtml_removeFromBlocklist () {
		return `<button class="btn btn-success btn-xs w-20p h-21p ve-flex-vh-center" title="Remove from Blocklist"><span class="glyphicon glyphicon-thumbs-up"></span></button>`;
	}

	_doHandleSourceCategorySelChange () {
		if (this._metaSelName) this._metaSelName.unhook();
		this._$wrpSelName.empty();

		const filteredData = this._doHandleSourceCategorySelChange_getFilteredData();

		const $selName = ComponentUiUtil.$getSelSearchable(
			this._comp,
			"name",
			{
				values: [
					{hash: "*", name: "*", category: this._comp.category},
					...this._getDataUids(filteredData),
				],
				fnDisplay: val => val.name,
			},
		);

		this._$wrpSelName.append($selName);
	}

	_doHandleSourceCategorySelChange_getFilteredData () {
				if (this._comp.source === "*" && this._comp.category === "*") return [];

		if (this._comp.source === "*" && this._comp.category !== "*") {
			return this._data[this._comp.category].map(it => ({...it, category: this._comp.category}));
		}

		if (this._comp.source !== "*" && this._comp.category === "*") {
			return Object.entries(this._data).map(([cat, arr]) => arr.filter(it => it.source === this._comp.source).map(it => ({...it, category: cat}))).flat();
		}

		return this._data[this._comp.category].filter(it => it.source === this._comp.source).map(it => ({...it, category: this._comp.category}));
	}

	_getDataUids (arr) {
		const copy = arr
			.map(it => {
				switch (it.category) {
					case "subclass": {
						return {...it, name: it.name, source: it.source, className: it.className, classSource: it.classSource, shortName: it.shortName};
					}
					case "classFeature": {
						return {...it, name: it.name, source: it.source, className: it.className, classSource: it.classSource, level: it.level};
					}
					case "subclassFeature": {
						return {...it, name: it.name, source: it.source, className: it.className, classSource: it.classSource, level: it.level, subclassShortName: it.subclassShortName, subclassSource: it.subclassSource};
					}
					case "adventure":
					case "book": {
						return {...it, name: it.name, source: it.source, id: it.id};
					}
					default: {
						return it;
					}
				}
			})
			.sort(this.constructor._fnSortDataUids.bind(this.constructor));

		const dupes = new Set();
		return copy.map((it, i) => {
			let prefix = "";
			let hash;
			if (UrlUtil.URL_TO_HASH_BUILDER[it.category]) {
				hash = UrlUtil.URL_TO_HASH_BUILDER[it.category](it);
			}
			switch (it.category) {
				case "subclass": prefix = `${it.className}: `; break;
				case "classFeature": prefix = this._getDisplayNamePrefix_classFeature(it); break;
				case "subclassFeature": prefix = this._getDisplayNamePrefix_subclassFeature(it); break;
			}
			if (!hash) hash = UrlUtil.encodeForHash([it.name, it.source]);
			const displayName = `${prefix}${it.name}${(dupes.has(it.name) || (copy[i + 1] && copy[i + 1].name === it.name)) ? ` (${Parser.sourceJsonToAbv(it.source)})` : ""}`;

			dupes.add(it.name);
			return {
				hash,
				name: displayName,
				category: it.category,
			};
		});
	}

	static _fnSortDataUids (a, b) {
		if (a.category !== b.category) return SortUtil.ascSortLower(a.category, b.category);
		switch (a.category) {
			case "subclass": {
				return SortUtil.ascSortLower(a.className, b.className) || SortUtil.ascSortLower(a.name, b.name) || SortUtil.ascSortLower(a.source, b.source);
			}
			case "classFeature": {
				return SortUtil.ascSortLower(a.className, b.className) || SortUtil.ascSort(a.level, b.level) || SortUtil.ascSortLower(a.name, b.name) || SortUtil.ascSortLower(a.source, b.source);
			}
			case "subclassFeature": {
				return SortUtil.ascSortLower(a.className, b.className) || SortUtil.ascSortLower(a.subclassShortName, b.subclassShortName) || SortUtil.ascSort(a.level, b.level) || SortUtil.ascSortLower(a.name, b.name) || SortUtil.ascSortLower(a.source, b.source);
			}
			default: {
				return SortUtil.ascSortLower(a.name, b.name) || SortUtil.ascSortLower(a.source, b.source);
			}
		}
	}

	_addListItem (displayName, hash, category, source) {
		const display = this._getDisplayValues(category, source);

		const id = this._listId++;
		const sourceFull = Parser.sourceJsonToFull(source);

		const $btnRemove = $(`<button class="btn btn-xxs btn-danger">Remove</button>`)
			.click(() => {
				this._remove(id, hash, category, source);
			});

		const $ele = $$`<div class="${this._addListItem_getItemStyles()}">
			<span class="col-4 text-center">${sourceFull}</span>
			<span class="col-2 text-center">${display.displayCategory}</span>
			<span class="col-5 text-center">${displayName}</span>
			<span class="col-1 text-center">${$btnRemove}</span>
		</div>`;

		const listItem = new ListItem(
			id,
			$ele,
			displayName,
			{
				category: display.displayCategory,
				source: sourceFull,
			},
			{
				displayName: displayName,
				hash: hash,
				category: category,
				source: source,
			},
		);

		this._list.addItem(listItem);
	}

	_addListItem_getItemStyles () { return `no-click ve-flex-v-center lst__row lst--border veapp__list-row lst__row-inner no-shrink`; }

	async _pAdd () {
		const {hash, name: displayName, category: categoryName} = this._comp.name;
		const category = categoryName === "*" ? this._comp.category : categoryName;

		if (
			this._comp.source === "*"
			&& category === "*"
			&& hash === "*"
			&& !await InputUiUtil.pGetUserBoolean({title: "Exclude All", htmlDescription: `This will exclude all content from all list pages. Are you sure?`, textYes: "Yes", textNo: "Cancel"})
		) return;

		if (this._addExclude(displayName, hash, category, this._comp.source)) {
			this._addListItem(displayName, hash, category, this._comp.source);

			const subBlocklist = MiscUtil.get(this._subBlocklistEntries, category, hash);
			if (subBlocklist) {
				subBlocklist.forEach(it => {
					const {displayName, hash, category, source} = it;
					this._addExclude(displayName, hash, category, source);
					this._addListItem(displayName, hash, category, source);
				});
			}

			this._list.update();
		}
	}

	_addMassSources ({fnFilter = null} = {}) {
		const sources = fnFilter
			? this._allSources.filter(source => fnFilter(source))
			: this._allSources;
		sources
			.forEach(source => {
				if (this._addExclude("*", "*", "*", source)) {
					this._addListItem("*", "*", "*", source);
				}
			});
		this._list.update();
	}

	_removeMassSources ({fnFilter = null} = {}) {
		const sources = fnFilter
			? this._allSources.filter(source => fnFilter(source))
			: this._allSources;
		sources
			.forEach(source => {
				const item = this._list.items.find(it => it.data.hash === "*" && it.data.category === "*" && it.data.source === source);
				if (item) {
					this._remove(item.ix, "*", "*", source, {isSkipListUpdate: true});
				}
			});
		this._list.update();
	}

	_addAllUa () { this._addMassSources({fnFilter: SourceUtil.isNonstandardSource}); }
	_removeAllUa () { this._removeMassSources({fnFilter: SourceUtil.isNonstandardSource}); }

	_addAllSources () { this._addMassSources(); }
	_removeAllSources () { this._removeMassSources(); }

	_addAllComedySources () { this._addMassSources({fnFilter: source => Parser.SOURCES_COMEDY.has(source)}); }
	_removeAllComedySources () { this._removeMassSources({fnFilter: source => Parser.SOURCES_COMEDY.has(source)}); }

	_addAllNonForgottenRealms () { this._addMassSources({fnFilter: source => Parser.SOURCES_NON_FR.has(source)}); }
	_removeAllNonForgottenRealms () { this._removeMassSources({fnFilter: source => Parser.SOURCES_NON_FR.has(source)}); }

	_remove (ix, hash, category, source, {isSkipListUpdate = false} = {}) {
		this._removeExclude(hash, category, source);
		this._list.removeItemByIndex(ix);
		if (!isSkipListUpdate) this._list.update();
	}

	async _pDoSendToFoundry () {
		await ExtensionUtil.pDoSend({type: "5etools.blocklist.excludes", data: this._excludes});
	}

	_export () {
		DataUtil.userDownload(`content-blocklist`, {fileType: "content-blocklist", blocklist: this._excludes});
	}

	async _pImport_getUserUpload () {
		return DataUtil.pUserUpload({expectedFileTypes: ["content-blocklist", "content-blacklist"]}); 	}

	async _pImport (evt) {
		const {jsons, errors} = await this._pImport_getUserUpload();

		DataUtil.doHandleFileLoadErrorsGeneric(errors);

		if (!jsons?.length) return;

				this._list.removeAllItems();
		this._list.update();

		const json = jsons[0];

				const nxtList = evt.shiftKey
						? MiscUtil.copy(this._excludes).concat(json.blocklist || json.blacklist || [])
			: json.blocklist || json.blacklist || [];
		this._excludes = nxtList;
		if (this._isAutoSave) await ExcludeUtil.pSetList(nxtList);

				this._renderList();
	}

	_reset () {
		this._resetExcludes();
		this._list.removeAllItems();
		this._list.update();
	}
};

globalThis.BlocklistUi = BlocklistUi$1;

BlocklistUi$1.Component = class extends BaseComponent {
	get source () { return this._state.source; }
	get category () { return this._state.category; }
	get name () { return this._state.name; }

	addHook (prop, hk) { return this._addHookBase(prop, hk); }

	_getDefaultState () {
		return {
			source: "*",
			category: "*",
			name: {
				hash: "*",
				name: "*",
				category: "*",
			},
		};
	}
};

"use strict";

let PageFilterActions$1 = class PageFilterActions extends PageFilter {
	static getTimeText (time) {
		return typeof time === "string" ? time : Parser.getTimeToFull(time);
	}

	constructor () {
		super();

		this._timeFilter = new Filter({
			header: "Type",
			displayFn: StrUtil.uppercaseFirst,
			itemSortFn: SortUtil.ascSortLower,
		});
		this._miscFilter = new Filter({header: "Miscellaneous", items: ["Optional/Variant Action", "SRD", "Basic Rules"], isMiscFilter: true});
	}

	static mutateForFilters (it) {
		it._fTime = it.time ? it.time.map(it => it.unit || it) : null;
		it._fMisc = [];
		if (it.srd) it._fMisc.push("SRD");
		if (it.basicRules) it._fMisc.push("Basic Rules");
		if (it.fromVariant) it._fMisc.push("Optional/Variant Action");
	}

	addToFilters (it, isExcluded) {
		if (isExcluded) return;

		this._sourceFilter.addItem(it.source);
		this._timeFilter.addItem(it._fTime);
	}

	async _pPopulateBoxOptions (opts) {
		opts.filters = [
			this._sourceFilter,
			this._timeFilter,
			this._miscFilter,
		];
	}

	toDisplay (values, it) {
		return this._filterBox.toDisplay(
			values,
			it.source,
			it._fTime,
			it._fMisc,
		);
	}
};

globalThis.PageFilterActions = PageFilterActions$1;

"use strict";

let PageFilterBackgrounds$1 = class PageFilterBackgrounds extends PageFilter {
	static _getToolDisplayText (tool) {
		if (tool === "anyArtisansTool") return "Any Artisan's Tool";
		if (tool === "anyMusicalInstrument") return "Any Musical Instrument";
		return tool.toTitleCase();
	}

	constructor () {
		super();

		this._skillFilter = new Filter({header: "Skill Proficiencies", displayFn: StrUtil.toTitleCase});
		this._toolFilter = new Filter({header: "Tool Proficiencies", displayFn: PageFilterBackgrounds$1._getToolDisplayText.bind(PageFilterBackgrounds$1)});
		this._languageFilter = new Filter({header: "Language Proficiencies", displayFn: it => it === "anyStandard" ? "Any Standard" : StrUtil.toTitleCase(it)});
		this._asiFilter = new AbilityScoreFilter({header: "Ability Scores"});
		this._otherBenefitsFilter = new Filter({header: "Other Benefits"});
		this._miscFilter = new Filter({header: "Miscellaneous", items: ["Has Info", "Has Images", "SRD", "Basic Rules"], isMiscFilter: true});
	}

	static mutateForFilters (bg) {
		bg._fSources = SourceFilter.getCompleteFilterSources(bg);
		const skillDisplay = Renderer.background.getSkillSummary(bg.skillProficiencies, true, bg._fSkills = []);
		Renderer.background.getToolSummary(bg.toolProficiencies, true, bg._fTools = []);
		Renderer.background.getLanguageSummary(bg.languageProficiencies, true, bg._fLangs = []);
		bg._fMisc = [];
		if (bg.srd) bg._fMisc.push("SRD");
		if (bg.basicRules) bg._fMisc.push("Basic Rules");
		if (bg.hasFluff || bg.fluff?.entries) bg._fMisc.push("Has Info");
		if (bg.hasFluffImages || bg.fluff?.images) bg._fMisc.push("Has Images");
		bg._fOtherBenifits = [];
		if (bg.feats) bg._fOtherBenifits.push("Feat");
		if (bg.additionalSpells) bg._fOtherBenifits.push("Additional Spells");
		bg._skillDisplay = skillDisplay;
	}

	addToFilters (bg, isExcluded) {
		if (isExcluded) return;

		this._sourceFilter.addItem(bg._fSources);
		this._skillFilter.addItem(bg._fSkills);
		this._toolFilter.addItem(bg._fTools);
		this._languageFilter.addItem(bg._fLangs);
		this._asiFilter.addItem(bg.ability);
		this._otherBenefitsFilter.addItem(bg._fOtherBenifits);
	}

	async _pPopulateBoxOptions (opts) {
		opts.filters = [
			this._sourceFilter,
			this._skillFilter,
			this._toolFilter,
			this._languageFilter,
			this._asiFilter,
			this._otherBenefitsFilter,
			this._miscFilter,
		];
	}

	toDisplay (values, bg) {
		return this._filterBox.toDisplay(
			values,
			bg._fSources,
			bg._fSkills,
			bg._fTools,
			bg._fLangs,
			bg.ability,
			bg._fOtherBenifits,
			bg._fMisc,
		);
	}
};

globalThis.PageFilterBackgrounds = PageFilterBackgrounds$1;

let ModalFilterBackgrounds$1 = class ModalFilterBackgrounds extends ModalFilter {
		constructor (opts) {
		opts = opts || {};
		super({
			...opts,
			modalTitle: `Background${opts.isRadio ? "" : "s"}`,
			pageFilter: new PageFilterBackgrounds$1(),
		});
	}

	_$getColumnHeaders () {
		const btnMeta = [
			{sort: "name", text: "Name", width: "4"},
			{sort: "skills", text: "Skills", width: "6"},
			{sort: "source", text: "Source", width: "1"},
		];
		return ModalFilter._$getFilterColumnHeaders(btnMeta);
	}

	async _pLoadAllData () {
		return [
			...(await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/backgrounds.json`)).background,
			...((await PrereleaseUtil.pGetBrewProcessed()).background || []),
			...((await BrewUtil2.pGetBrewProcessed()).background || []),
		];
	}

	_getListItem (pageFilter, bg, bgI) {
		const eleRow = document.createElement("div");
		eleRow.className = "px-0 w-100 ve-flex-col no-shrink";

		const hash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BACKGROUNDS](bg);
		const source = Parser.sourceJsonToAbv(bg.source);

		eleRow.innerHTML = `<div class="w-100 ve-flex-vh-center lst--border veapp__list-row no-select lst__wrp-cells">
			<div class="col-0-5 pl-0 ve-flex-vh-center">${this._isRadio ? `<input type="radio" name="radio" class="no-events">` : `<input type="checkbox" class="no-events">`}</div>

			<div class="col-0-5 px-1 ve-flex-vh-center">
				<div class="ui-list__btn-inline px-2" title="Toggle Preview (SHIFT to Toggle Info Preview)">[+]</div>
			</div>

			<div class="col-4 ${bg._versionBase_isVersion ? "italic" : ""} ${this._getNameStyle()}">${bg._versionBase_isVersion ? `<span class="px-3"></span>` : ""}${bg.name}</div>
			<div class="col-6">${bg._skillDisplay}</div>
			<div class="col-1 pr-0 text-center ${Parser.sourceJsonToColor(bg.source)}" title="${Parser.sourceJsonToFull(bg.source)}" ${Parser.sourceJsonToStyle(bg.source)}>${source}</div>
		</div>`;

		const btnShowHidePreview = eleRow.firstElementChild.children[1].firstElementChild;

		const listItem = new ListItem(
			bgI,
			eleRow,
			bg.name,
			{
				hash,
				source,
				sourceJson: bg.source,
				skills: bg._skillDisplay,
			},
			{
				cbSel: eleRow.firstElementChild.firstElementChild.firstElementChild,
				btnShowHidePreview,
			},
		);

		ListUiUtil.bindPreviewButton(UrlUtil.PG_BACKGROUNDS, this._allData, listItem, btnShowHidePreview);

		return listItem;
	}
};

globalThis.ModalFilterBackgrounds = ModalFilterBackgrounds$1;

"use strict";

let PageFilterBestiary$1 = class PageFilterBestiary extends PageFilter {
	static _NEUT_ALIGNS = ["NX", "NY"];
	static MISC_FILTER_SPELLCASTER = "Spellcaster, ";
	static _RE_SPELL_TAG = /{@spell ([^}]+)}/g;
	static _WALKER = null;
	static _BASIC_ENTRY_PROPS = [
		"trait",
		"action",
		"bonus",
		"reaction",
		"legendary",
		"mythic",
	];
	static _DRAGON_AGES = ["wyrmling", "young", "adult", "ancient", "greatwyrm", "aspect"];

		static sortMonsters (a, b, o) {
		if (o.sortBy === "count") return SortUtil.ascSort(a.data.count, b.data.count) || SortUtil.compareListNames(a, b);
		switch (o.sortBy) {
			case "name": return SortUtil.compareListNames(a, b);
			case "type": return SortUtil.ascSort(a.values.type, b.values.type) || SortUtil.compareListNames(a, b);
			case "source": return SortUtil.ascSort(a.values.source, b.values.source) || SortUtil.compareListNames(a, b);
			case "cr": return SortUtil.ascSortCr(a.values.cr, b.values.cr) || SortUtil.compareListNames(a, b);
			case "page": return SortUtil.ascSort(a.values.page, b.values.page) || SortUtil.compareListNames(a, b);
		}
	}

	static ascSortMiscFilter (a, b) {
		a = a.item;
		b = b.item;
		if (a.includes(PageFilterBestiary$1.MISC_FILTER_SPELLCASTER) && b.includes(PageFilterBestiary$1.MISC_FILTER_SPELLCASTER)) {
			a = Parser.attFullToAbv(a.replace(PageFilterBestiary$1.MISC_FILTER_SPELLCASTER, ""));
			b = Parser.attFullToAbv(b.replace(PageFilterBestiary$1.MISC_FILTER_SPELLCASTER, ""));
			return SortUtil.ascSortAtts(a, b);
		} else {
			a = Parser.monMiscTagToFull(a);
			b = Parser.monMiscTagToFull(b);
			return SortUtil.ascSortLower(a, b);
		}
	}

	static _ascSortDragonAgeFilter (a, b) {
		a = a.item;
		b = b.item;
		const ixA = PageFilterBestiary$1._DRAGON_AGES.indexOf(a);
		const ixB = PageFilterBestiary$1._DRAGON_AGES.indexOf(b);
		if (~ixA && ~ixB) return SortUtil.ascSort(ixA, ixB);
		if (~ixA) return Number.MIN_SAFE_INTEGER;
		if (~ixB) return Number.MAX_SAFE_INTEGER;
		return SortUtil.ascSortLower(a, b);
	}

	static getAllImmRest (toParse, key) {
		const out = [];
		for (const it of toParse) this._getAllImmRest_recurse(it, key, out); 		return out;
	}

	static _getAllImmRest_recurse (it, key, out, conditional) {
		if (typeof it === "string") {
			out.push(conditional ? `${it} (Conditional)` : it);
		} else if (it[key]) {
			it[key].forEach(nxt => this._getAllImmRest_recurse(nxt, key, out, !!it.cond));
		}
	}

	static _getDamageTagDisplayText (tag) { return Parser.dmgTypeToFull(tag).toTitleCase(); }
	static _getConditionDisplayText (uid) { return uid.split("|")[0].toTitleCase(); }
	
	constructor () {
		super();

		this._crFilter = new RangeFilter({
			header: "Challenge Rating",
			isLabelled: true,
			labelSortFn: SortUtil.ascSortCr,
			labels: [...Parser.CRS, "Unknown", "\u2014"],
			labelDisplayFn: it => it === "\u2014" ? "None" : it,
		});
		this._sizeFilter = new Filter({
			header: "Size",
			items: [
				Parser.SZ_TINY,
				Parser.SZ_SMALL,
				Parser.SZ_MEDIUM,
				Parser.SZ_LARGE,
				Parser.SZ_HUGE,
				Parser.SZ_GARGANTUAN,
				Parser.SZ_VARIES,
			],
			displayFn: Parser.sizeAbvToFull,
			itemSortFn: null,
		});
		this._speedFilter = new RangeFilter({header: "Speed", min: 30, max: 30, suffix: " ft"});
		this._speedTypeFilter = new Filter({header: "Speed Type", items: [...Parser.SPEED_MODES, "hover"], displayFn: StrUtil.uppercaseFirst});
		this._strengthFilter = new RangeFilter({header: "Strength", min: 1, max: 30});
		this._dexterityFilter = new RangeFilter({header: "Dexterity", min: 1, max: 30});
		this._constitutionFilter = new RangeFilter({header: "Constitution", min: 1, max: 30});
		this._intelligenceFilter = new RangeFilter({header: "Intelligence", min: 1, max: 30});
		this._wisdomFilter = new RangeFilter({header: "Wisdom", min: 1, max: 30});
		this._charismaFilter = new RangeFilter({header: "Charisma", min: 1, max: 30});
		this._abilityScoreFilter = new MultiFilter({
			header: "Ability Scores",
			filters: [this._strengthFilter, this._dexterityFilter, this._constitutionFilter, this._intelligenceFilter, this._wisdomFilter, this._charismaFilter],
			isAddDropdownToggle: true,
		});
		this._acFilter = new RangeFilter({header: "Armor Class"});
		this._averageHpFilter = new RangeFilter({header: "Average Hit Points"});
		this._typeFilter = new Filter({
			header: "Type",
			items: [...Parser.MON_TYPES],
			displayFn: StrUtil.toTitleCase,
			itemSortFn: SortUtil.ascSortLower,
		});
		this._tagFilter = new Filter({header: "Tag", displayFn: StrUtil.toTitleCase});
		this._sidekickTypeFilter = new Filter({
			header: "Sidekick Type",
			items: ["expert", "spellcaster", "warrior"],
			displayFn: StrUtil.toTitleCase,
			itemSortFn: SortUtil.ascSortLower,
		});
		this._sidekickTagFilter = new Filter({header: "Sidekick Tag", displayFn: StrUtil.toTitleCase});
		this._alignmentFilter = new Filter({
			header: "Alignment",
			items: ["L", "NX", "C", "G", "NY", "E", "N", "U", "A", "No Alignment"],
			displayFn: alignment => Parser.alignmentAbvToFull(alignment).toTitleCase(),
			itemSortFn: null,
		});
		this._languageFilter = new Filter({
			header: "Languages",
			displayFn: (k) => Parser.monLanguageTagToFull(k).toTitleCase(),
			umbrellaItems: ["X", "XX"],
			umbrellaExcludes: ["CS"],
		});
		this._damageTypeFilterBase = new Filter({
			header: "Damage Inflicted by Traits/Actions",
			displayFn: this.constructor._getDamageTagDisplayText,
			displayFnMini: tag => `Deals ${this.constructor._getDamageTagDisplayText(tag)} (Trait/Action)`,
			items: Object.keys(Parser.DMGTYPE_JSON_TO_FULL),
		});
		this._damageTypeFilterLegendary = new Filter({
			header: "Damage Inflicted by Lair Actions/Regional Effects",
			displayFn: this.constructor._getDamageTagDisplayText,
			displayFnMini: tag => `Deals ${this.constructor._getDamageTagDisplayText(tag)} (Lair/Regional)`,
			items: Object.keys(Parser.DMGTYPE_JSON_TO_FULL),
		});
		this._damageTypeFilterSpells = new Filter({
			header: "Damage Inflicted by Spells",
			displayFn: this.constructor._getDamageTagDisplayText,
			displayFnMini: tag => `Deals ${this.constructor._getDamageTagDisplayText(tag)} (Spell)`,
			items: Object.keys(Parser.DMGTYPE_JSON_TO_FULL),
		});
		this._damageTypeFilter = new MultiFilter({header: "Damage Inflicted", filters: [this._damageTypeFilterBase, this._damageTypeFilterLegendary, this._damageTypeFilterSpells]});
		this._conditionsInflictedFilterBase = new Filter({
			header: "Conditions Inflicted by Traits/Actions",
			displayFn: this.constructor._getConditionDisplayText,
			displayFnMini: uid => `Inflicts ${this.constructor._getConditionDisplayText(uid)} (Trait/Action)`,
			items: [...Parser.CONDITIONS],
		});
		this._conditionsInflictedFilterLegendary = new Filter({
			header: "Conditions Inflicted by Lair Actions/Regional Effects",
			displayFn: this.constructor._getConditionDisplayText,
			displayFnMini: uid => `Inflicts ${this.constructor._getConditionDisplayText(uid)} (Lair/Regional)`,
			items: [...Parser.CONDITIONS],
		});
		this._conditionsInflictedFilterSpells = new Filter({
			header: "Conditions Inflicted by Spells",
			displayFn: this.constructor._getConditionDisplayText,
			displayFnMini: uid => `Inflicts ${this.constructor._getConditionDisplayText(uid)} (Spell)`,
			items: [...Parser.CONDITIONS],
		});
		this._conditionsInflictedFilter = new MultiFilter({header: "Conditions Inflicted", filters: [this._conditionsInflictedFilterBase, this._conditionsInflictedFilterLegendary, this._conditionsInflictedFilterSpells]});
		this._senseFilter = new Filter({
			header: "Senses",
			displayFn: (it) => Parser.monSenseTagToFull(it).toTitleCase(),
			items: ["B", "D", "SD", "T", "U"],
			itemSortFn: SortUtil.ascSortLower,
		});
		this._passivePerceptionFilter = new RangeFilter({header: "Passive Perception", min: 10, max: 10});
		this._skillFilter = new Filter({
			header: "Skills",
			displayFn: (it) => it.toTitleCase(),
			items: Object.keys(Parser.SKILL_TO_ATB_ABV),
		});
		this._saveFilter = new Filter({
			header: "Saves",
			displayFn: Parser.attAbvToFull,
			items: [...Parser.ABIL_ABVS],
			itemSortFn: null,
		});
		this._environmentFilter = new Filter({
			header: "Environment",
			items: ["arctic", "coastal", "desert", "forest", "grassland", "hill", "mountain", "none", "swamp", "underdark", "underwater", "urban"],
			displayFn: StrUtil.uppercaseFirst,
		});
		this._vulnerableFilter = FilterCommon.getDamageVulnerableFilter();
		this._resistFilter = FilterCommon.getDamageResistFilter();
		this._immuneFilter = FilterCommon.getDamageImmuneFilter();
		this._defenceFilter = new MultiFilter({header: "Damage", filters: [this._vulnerableFilter, this._resistFilter, this._immuneFilter]});
		this._conditionImmuneFilter = FilterCommon.getConditionImmuneFilter();
		this._traitFilter = new Filter({
			header: "Traits",
			items: [
				"Aggressive", "Ambusher", "Amorphous", "Amphibious", "Antimagic Susceptibility", "Brute", "Charge", "Damage Absorption", "Death Burst", "Devil's Sight", "False Appearance", "Fey Ancestry", "Flyby", "Hold Breath", "Illumination", "Immutable Form", "Incorporeal Movement", "Keen Senses", "Legendary Resistances", "Light Sensitivity", "Magic Resistance", "Magic Weapons", "Pack Tactics", "Pounce", "Rampage", "Reckless", "Regeneration", "Rejuvenation", "Shapechanger", "Siege Monster", "Sneak Attack", "Spider Climb", "Sunlight Sensitivity", "Tunneler", "Turn Immunity", "Turn Resistance", "Undead Fortitude", "Water Breathing", "Web Sense", "Web Walker",
			],
		});
		this._actionReactionFilter = new Filter({
			header: "Actions & Reactions",
			items: [
				"Frightful Presence", "Multiattack", "Parry", "Swallow", "Teleport", "Tentacles",
			],
		});
		this._miscFilter = new Filter({
			header: "Miscellaneous",
			items: ["Familiar", ...Object.keys(Parser.MON_MISC_TAG_TO_FULL), "Bonus Actions", "Lair Actions", "Legendary", "Mythic", "Adventure NPC", "Spellcaster", ...Object.values(Parser.ATB_ABV_TO_FULL).map(it => `${PageFilterBestiary$1.MISC_FILTER_SPELLCASTER}${it}`), "Regional Effects", "Reactions", "Reprinted", "Swarm", "Has Variants", "Modified Copy", "Has Alternate Token", "Has Info", "Has Images", "Has Token", "Has Recharge", "SRD", "Basic Rules", "AC from Item(s)", "AC from Natural Armor", "AC from Unarmored Defense", "Summoned by Spell", "Summoned by Class"],
			displayFn: (it) => Parser.monMiscTagToFull(it).uppercaseFirst(),
			deselFn: (it) => ["Adventure NPC", "Reprinted"].includes(it),
			itemSortFn: PageFilterBestiary$1.ascSortMiscFilter,
			isMiscFilter: true,
		});
		this._spellcastingTypeFilter = new Filter({
			header: "Spellcasting Type",
			items: ["F", "I", "P", "S", "O", "CA", "CB", "CC", "CD", "CP", "CR", "CS", "CL", "CW"],
			displayFn: Parser.monSpellcastingTagToFull,
		});
		this._spellSlotLevelFilter = new RangeFilter({
			header: "Spell Slot Level",
			min: 1,
			max: 9,
			displayFn: it => Parser.getOrdinalForm(it),
		});
		this._spellKnownFilter = new SearchableFilter({header: "Spells Known", displayFn: (it) => it.split("|")[0].toTitleCase(), itemSortFn: SortUtil.ascSortLower});
		this._dragonAgeFilter = new Filter({
			header: "Dragon Age",
			items: [...PageFilterBestiary$1._DRAGON_AGES],
			itemSortFn: PageFilterBestiary$1._ascSortDragonAgeFilter,
			displayFn: (it) => it.toTitleCase(),
		});
		this._dragonCastingColor = new Filter({
			header: "Dragon Casting Color",
			items: [...Renderer.monster.dragonCasterVariant.getAvailableColors()],
			displayFn: (it) => it.toTitleCase(),
		});
	}

	static mutateForFilters (mon) {
		Renderer.monster.initParsed(mon);

		if (typeof mon.speed === "number" && mon.speed > 0) {
			mon._fSpeedType = ["walk"];
			mon._fSpeed = mon.speed;
		} else {
			mon._fSpeedType = Object.keys(mon.speed).filter(k => mon.speed[k]);
			if (mon._fSpeedType.length) mon._fSpeed = mon._fSpeedType.map(k => mon.speed[k].number || mon.speed[k]).filter(it => !isNaN(it)).sort((a, b) => SortUtil.ascSort(b, a))[0];
			else mon._fSpeed = 0;
			if (mon.speed.canHover) mon._fSpeedType.push("hover");
		}

		mon._fAc = mon.ac.map(it => it.special ? null : (it.ac || it)).filter(it => it !== null);
		if (!mon._fAc.length) mon._fAc = null;
		mon._fHp = mon.hp.average;
		if (mon.alignment) {
			const tempAlign = typeof mon.alignment[0] === "object"
				? Array.prototype.concat.apply([], mon.alignment.map(a => a.alignment))
				: [...mon.alignment];
			if (tempAlign.includes("N") && !tempAlign.includes("G") && !tempAlign.includes("E")) tempAlign.push("NY");
			else if (tempAlign.includes("N") && !tempAlign.includes("L") && !tempAlign.includes("C")) tempAlign.push("NX");
			else if (tempAlign.length === 1 && tempAlign.includes("N")) Array.prototype.push.apply(tempAlign, PageFilterBestiary$1._NEUT_ALIGNS);
			mon._fAlign = tempAlign;
		} else {
			mon._fAlign = ["No Alignment"];
		}
		mon._fEnvironment = mon.environment || ["none"];
		mon._fVuln = mon.vulnerable ? PageFilterBestiary$1.getAllImmRest(mon.vulnerable, "vulnerable") : [];
		mon._fRes = mon.resist ? PageFilterBestiary$1.getAllImmRest(mon.resist, "resist") : [];
		mon._fImm = mon.immune ? PageFilterBestiary$1.getAllImmRest(mon.immune, "immune") : [];
		mon._fCondImm = mon.conditionImmune ? PageFilterBestiary$1.getAllImmRest(mon.conditionImmune, "conditionImmune") : [];
		mon._fSave = mon.save ? Object.keys(mon.save) : [];
		mon._fSkill = mon.skill ? Object.keys(mon.skill) : [];
		mon._fSources = SourceFilter.getCompleteFilterSources(mon);
		mon._fPassive = !isNaN(mon.passive) ? Number(mon.passive) : null;

		Parser.ABIL_ABVS
			.forEach(ab => {
				if (mon[ab] == null) return;
				const propF = `_f${ab.uppercaseFirst()}`;
				mon[propF] = typeof mon[ab] !== "number" ? null : mon[ab];
			});

		mon._fMisc = [...mon.miscTags || []];
		for (const it of (mon.trait || [])) {
			if (it.name && it.name.startsWith("Unarmored Defense")) mon._fMisc.push("AC from Unarmored Defense");
		}
		for (const it of (mon.ac || [])) {
			if (!it.from) continue;
			if (it.from.includes("natural armor")) mon._fMisc.push("AC from Natural Armor");
			if (it.from.some(x => x.startsWith("{@item "))) mon._fMisc.push("AC from Item(s)");
			if (!mon._fMisc.includes("AC from Unarmored Defense") && it.from.includes("Unarmored Defense")) mon._fMisc.push("AC from Unarmored Defense");
		}
		if (mon.legendary) mon._fMisc.push("Legendary");
		if (mon.familiar) mon._fMisc.push("Familiar");
		if (mon.type.swarmSize) mon._fMisc.push("Swarm");
		if (mon.spellcasting) {
			mon._fMisc.push("Spellcaster");
			for (const sc of mon.spellcasting) {
				if (sc.ability) mon._fMisc.push(`${PageFilterBestiary$1.MISC_FILTER_SPELLCASTER}${Parser.attAbvToFull(sc.ability)}`);
			}
		}
		if (mon.isNpc) mon._fMisc.push("Adventure NPC");
		const legGroup = DataUtil.monster.getMetaGroup(mon);
		if (legGroup) {
			if (legGroup.lairActions) mon._fMisc.push("Lair Actions");
			if (legGroup.regionalEffects) mon._fMisc.push("Regional Effects");
		}
		if (mon.reaction) mon._fMisc.push("Reactions");
		if (mon.bonus) mon._fMisc.push("Bonus Actions");
		if (mon.variant) mon._fMisc.push("Has Variants");
		if (mon._isCopy) mon._fMisc.push("Modified Copy");
		if (mon.altArt) mon._fMisc.push("Has Alternate Token");
		if (mon.srd) mon._fMisc.push("SRD");
		if (mon.basicRules) mon._fMisc.push("Basic Rules");
		if (mon.tokenUrl || mon.hasToken) mon._fMisc.push("Has Token");
		if (mon.mythic) mon._fMisc.push("Mythic");
		if (mon.hasFluff || mon.fluff?.entries) mon._fMisc.push("Has Info");
		if (mon.hasFluffImages || mon.fluff?.images) mon._fMisc.push("Has Images");
		if (this._isReprinted({reprintedAs: mon.reprintedAs, tag: "creature", prop: "monster", page: UrlUtil.PG_BESTIARY})) mon._fMisc.push("Reprinted");
		if (this._hasRecharge(mon)) mon._fMisc.push("Has Recharge");
		if (mon._versionBase_isVersion) mon._fMisc.push("Is Variant");
		if (mon.summonedBySpell) mon._fMisc.push("Summoned by Spell");
		if (mon.summonedByClass) mon._fMisc.push("Summoned by Class");

		const spellcasterMeta = this._getSpellcasterMeta(mon);
		if (spellcasterMeta) {
			if (spellcasterMeta.spellLevels.size) mon._fSpellSlotLevels = [...spellcasterMeta.spellLevels];
			if (spellcasterMeta.spellSet.size) mon._fSpellsKnown = [...spellcasterMeta.spellSet];
		}

		if (mon.languageTags?.length) mon._fLanguageTags = mon.languageTags;
		else mon._fLanguageTags = ["None"];
	}

	static _getSpellcasterMeta (mon) {
		if (!mon.spellcasting?.length) return null;

		PageFilterBestiary$1._WALKER = PageFilterBestiary$1._WALKER || MiscUtil.getWalker({isNoModification: true});

		const spellSet = new Set();
		const spellLevels = new Set();
		for (const spc of mon.spellcasting) {
			if (spc.spells) {
				const slotLevels = Object.keys(spc.spells).map(Number).filter(Boolean);
				for (const slotLevel of slotLevels) spellLevels.add(slotLevel);
			}

			PageFilterBestiary$1._WALKER.walk(
				spc,
				{
					string: this._getSpellcasterMeta_stringHandler.bind(null, spellSet),
				},
			);
		}

		return {spellLevels, spellSet};
	}

	static _getSpellcasterMeta_stringHandler (spellSet, str) {
		str.replace(PageFilterBestiary$1._RE_SPELL_TAG, (...m) => {
			const parts = m[1].split("|").slice(0, 2);
			parts[1] = parts[1] || Parser.SRC_PHB;
			spellSet.add(parts.join("|").toLowerCase());
			return "";
		});
	}

	static _hasRecharge (mon) {
		for (const prop of PageFilterBestiary$1._BASIC_ENTRY_PROPS) {
			if (!mon[prop]) continue;
			for (const ent of mon[prop]) {
				if (!ent?.name) continue;
				if (ent.name.includes("{@recharge")) return true;
			}
		}
		return false;
	}

	addToFilters (mon, isExcluded) {
		if (isExcluded) return;

		this._sourceFilter.addItem(mon._fSources);
		this._crFilter.addItem(mon._fCr);
		this._strengthFilter.addItem(mon._fStr);
		this._dexterityFilter.addItem(mon._fDex);
		this._constitutionFilter.addItem(mon._fCon);
		this._intelligenceFilter.addItem(mon._fInt);
		this._wisdomFilter.addItem(mon._fWis);
		this._charismaFilter.addItem(mon._fCha);
		this._speedFilter.addItem(mon._fSpeed);
		mon.ac.forEach(it => this._acFilter.addItem(it.ac || it));
		if (mon.hp.average) this._averageHpFilter.addItem(mon.hp.average);
		this._tagFilter.addItem(mon._pTypes.tags);
		this._sidekickTypeFilter.addItem(mon._pTypes.typeSidekick);
		this._sidekickTagFilter.addItem(mon._pTypes.tagsSidekick);
		this._traitFilter.addItem(mon.traitTags);
		this._actionReactionFilter.addItem(mon.actionTags);
		this._environmentFilter.addItem(mon._fEnvironment);
		this._vulnerableFilter.addItem(mon._fVuln);
		this._resistFilter.addItem(mon._fRes);
		this._immuneFilter.addItem(mon._fImm);
		this._senseFilter.addItem(mon.senseTags);
		this._passivePerceptionFilter.addItem(mon._fPassive);
		this._spellSlotLevelFilter.addItem(mon._fSpellSlotLevels);
		this._spellKnownFilter.addItem(mon._fSpellsKnown);
		if (mon._versionBase_isVersion) this._miscFilter.addItem("Is Variant");
		this._damageTypeFilterBase.addItem(mon.damageTags);
		this._damageTypeFilterLegendary.addItem(mon.damageTagsLegendary);
		this._damageTypeFilterSpells.addItem(mon.damageTagsSpell);
		this._conditionsInflictedFilterBase.addItem(mon.conditionInflict);
		this._conditionsInflictedFilterLegendary.addItem(mon.conditionInflictLegendary);
		this._conditionsInflictedFilterSpells.addItem(mon.conditionInflictSpell);
		this._dragonAgeFilter.addItem(mon.dragonAge);
		this._dragonCastingColor.addItem(mon.dragonCastingColor);
	}

	async _pPopulateBoxOptions (opts) {
		Object.entries(Parser.MON_LANGUAGE_TAG_TO_FULL)
			.sort(([, vA], [, vB]) => SortUtil.ascSortLower(vA, vB))
			.forEach(([k]) => this._languageFilter.addItem(k));
		this._languageFilter.addItem("None");

		opts.filters = [
			this._sourceFilter,
			this._crFilter,
			this._typeFilter,
			this._tagFilter,
			this._sidekickTypeFilter,
			this._sidekickTagFilter,
			this._environmentFilter,
			this._defenceFilter,
			this._conditionImmuneFilter,
			this._traitFilter,
			this._actionReactionFilter,
			this._miscFilter,
			this._spellcastingTypeFilter,
			this._spellSlotLevelFilter,
			this._sizeFilter,
			this._speedFilter,
			this._speedTypeFilter,
			this._alignmentFilter,
			this._saveFilter,
			this._skillFilter,
			this._senseFilter,
			this._passivePerceptionFilter,
			this._languageFilter,
			this._damageTypeFilter,
			this._conditionsInflictedFilter,
			this._dragonAgeFilter,
			this._dragonCastingColor,
			this._acFilter,
			this._averageHpFilter,
			this._abilityScoreFilter,
			this._spellKnownFilter,
		];
	}

	toDisplay (values, m) {
		return this._filterBox.toDisplay(
			values,
			m._fSources,
			m._fCr,
			m._pTypes.types,
			m._pTypes.tags,
			m._pTypes.typeSidekick,
			m._pTypes.tagsSidekick,
			m._fEnvironment,
			[
				m._fVuln,
				m._fRes,
				m._fImm,
			],
			m._fCondImm,
			m.traitTags,
			m.actionTags,
			m._fMisc,
			m.spellcastingTags,
			m._fSpellSlotLevels,
			m.size,
			m._fSpeed,
			m._fSpeedType,
			m._fAlign,
			m._fSave,
			m._fSkill,
			m.senseTags,
			m._fPassive,
			m._fLanguageTags,
			[
				m.damageTags,
				m.damageTagsLegendary,
				m.damageTagsSpell,
			],
			[
				m.conditionInflict,
				m.conditionInflictLegendary,
				m.conditionInflictSpell,
			],
			m.dragonAge,
			m.dragonCastingColor,
			m._fAc,
			m._fHp,
			[
				m._fStr,
				m._fDex,
				m._fCon,
				m._fInt,
				m._fWis,
				m._fCha,
			],
			m._fSpellsKnown,
		);
	}
};

globalThis.PageFilterBestiary = PageFilterBestiary$1;

class ModalFilterBestiary extends ModalFilter {
		constructor (opts) {
		opts = opts || {};
		super({
			...opts,
			modalTitle: `Creature${opts.isRadio ? "" : "s"}`,
			pageFilter: new PageFilterBestiary$1(),
			fnSort: PageFilterBestiary$1.sortMonsters,
		});
	}

	_$getColumnHeaders () {
		const btnMeta = [
			{sort: "name", text: "Name", width: "4"},
			{sort: "type", text: "Type", width: "4"},
			{sort: "cr", text: "CR", width: "2"},
			{sort: "source", text: "Source", width: "1"},
		];
		return ModalFilter._$getFilterColumnHeaders(btnMeta);
	}

	async _pLoadAllData () {
		return [
			...(await DataUtil.monster.pLoadAll()),
			...((await PrereleaseUtil.pGetBrewProcessed()).monster || []),
			...((await BrewUtil2.pGetBrewProcessed()).monster || []),
		];
	}

	_getListItem (pageFilter, mon, itI) {
		Renderer.monster.initParsed(mon);
		pageFilter.mutateAndAddToFilters(mon);

		const eleRow = document.createElement("div");
		eleRow.className = "px-0 w-100 ve-flex-col no-shrink";

		const hash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BESTIARY](mon);
		const source = Parser.sourceJsonToAbv(mon.source);
		const type = mon._pTypes.asText;
		const cr = mon._pCr;

		eleRow.innerHTML = `<div class="w-100 ve-flex-vh-center lst--border veapp__list-row no-select lst__wrp-cells">
			<div class="col-0-5 pl-0 ve-flex-vh-center">${this._isRadio ? `<input type="radio" name="radio" class="no-events">` : `<input type="checkbox" class="no-events">`}</div>

			<div class="col-0-5 px-1 ve-flex-vh-center">
				<div class="ui-list__btn-inline px-2" title="Toggle Preview (SHIFT to Toggle Info Preview)">[+]</div>
			</div>

			<div class="col-4 ${mon._versionBase_isVersion ? "italic" : ""} ${this._getNameStyle()}">${mon._versionBase_isVersion ? `<span class="px-3"></span>` : ""}${mon.name}</div>
			<div class="col-4">${type}</div>
			<div class="col-2 text-center">${cr}</div>
			<div class="col-1 text-center ${Parser.sourceJsonToColor(mon.source)} pr-0" title="${Parser.sourceJsonToFull(mon.source)}" ${Parser.sourceJsonToStyle(mon.source)}>${source}</div>
		</div>`;

		const btnShowHidePreview = eleRow.firstElementChild.children[1].firstElementChild;

		const listItem = new ListItem(
			itI,
			eleRow,
			mon.name,
			{
				hash,
				source,
				sourceJson: mon.source,
				type,
				cr,
			},
			{
				cbSel: eleRow.firstElementChild.firstElementChild.firstElementChild,
				btnShowHidePreview,
			},
		);

		ListUiUtil.bindPreviewButton(UrlUtil.PG_BESTIARY, this._allData, listItem, btnShowHidePreview);

		return listItem;
	}
}

globalThis.ModalFilterBestiary = ModalFilterBestiary;

let ListSyntaxBestiary$1 = class ListSyntaxBestiary extends ListUiUtil.ListSyntax {
	static _INDEXABLE_PROPS_ENTRIES = [
		"trait",
		"spellcasting",
		"action",
		"bonus",
		"reaction",
		"legendary",
		"mythic",
		"variant",
	];
	static _INDEXABLE_PROPS_LEG_GROUP = [
		"lairActions",
		"regionalEffects",
		"mythicEncounter",
	];

	_getSearchCacheStats (entity) {
		const legGroup = DataUtil.monster.getMetaGroup(entity);
		if (!legGroup && this.constructor._INDEXABLE_PROPS_ENTRIES.every(it => !entity[it])) return "";
		const ptrOut = {_: ""};
		this.constructor._INDEXABLE_PROPS_ENTRIES.forEach(it => this._getSearchCache_handleEntryProp(entity, it, ptrOut));
		if (legGroup) this.constructor._INDEXABLE_PROPS_LEG_GROUP.forEach(it => this._getSearchCache_handleEntryProp(legGroup, it, ptrOut));
		return ptrOut._;
	}
};

globalThis.ListSyntaxBestiary = ListSyntaxBestiary$1;

"use strict";

let PageFilterCharCreationOptions$1 = class PageFilterCharCreationOptions extends PageFilter {
	static _filterFeatureTypeSort (a, b) {
		return SortUtil.ascSort(Parser.charCreationOptionTypeToFull(a.item), Parser.charCreationOptionTypeToFull(b.item));
	}

	constructor () {
		super();
		this._typeFilter = new Filter({
			header: "Feature Type",
			items: [],
			displayFn: Parser.charCreationOptionTypeToFull,
			itemSortFn: PageFilterCharCreationOptions$1._filterFeatureTypeSort,
		});
		this._miscFilter = new Filter({header: "Miscellaneous", items: ["SRD", "Has Images", "Has Info"], isMiscFilter: true});
	}

	static mutateForFilters (it) {
		it._fOptionType = Parser.charCreationOptionTypeToFull(it.optionType);
		it._fMisc = it.srd ? ["SRD"] : [];
		if (it.hasFluff || it.fluff?.entries) it._fMisc.push("Has Info");
		if (it.hasFluffImages || it.fluff?.images) it._fMisc.push("Has Images");
	}

	addToFilters (it, isExcluded) {
		if (isExcluded) return;

		this._sourceFilter.addItem(it.source);
		this._typeFilter.addItem(it._fOptionType);
	}

	async _pPopulateBoxOptions (opts) {
		opts.filters = [
			this._sourceFilter,
			this._typeFilter,
			this._miscFilter,
		];
	}

	toDisplay (values, it) {
		return this._filterBox.toDisplay(
			values,
			it.source,
			it._fOptionType,
			it._fMisc,
		);
	}
};

globalThis.PageFilterCharCreationOptions = PageFilterCharCreationOptions$1;

"use strict";

let FilterCommon$1 = class FilterCommon {
	static getDamageVulnerableFilter () {
		return this._getDamageResistVulnImmuneFilter({
			header: "Vulnerabilities",
			headerShort: "Vuln.",
		});
	}

	static getDamageResistFilter () {
		return this._getDamageResistVulnImmuneFilter({
			header: "Resistance",
			headerShort: "Res.",
		});
	}

	static getDamageImmuneFilter () {
		return this._getDamageResistVulnImmuneFilter({
			header: "Immunity",
			headerShort: "Imm.",
		});
	}

	static _getDamageResistVulnImmuneFilter (
		{
			header,
			headerShort,
		},
	) {
		return new Filter({
			header: header,
			items: [...Parser.DMG_TYPES],
			displayFnMini: str => `${headerShort} ${str.toTitleCase()}`,
			displayFnTitle: str => `Damage ${header}: ${str.toTitleCase()}`,
			displayFn: StrUtil.uppercaseFirst,
		});
	}

	static _CONDS = [
		"blinded",
		"charmed",
		"deafened",
		"exhaustion",
		"frightened",
		"grappled",
		"incapacitated",
		"invisible",
		"paralyzed",
		"petrified",
		"poisoned",
		"prone",
		"restrained",
		"stunned",
		"unconscious",
				"disease",
	];

	static getConditionImmuneFilter () {
		return new Filter({
			header: "Condition Immunity",
			items: this._CONDS,
			displayFnMini: str => `Imm. ${str.toTitleCase()}`,
			displayFnTitle: str => `Condition Immunity: ${str.toTitleCase()}`,
			displayFn: StrUtil.uppercaseFirst,
		});
	}

	static mutateForFilters_damageVulnResImmune_player (ent) {
		this.mutateForFilters_damageVuln_player(ent);
		this.mutateForFilters_damageRes_player(ent);
		this.mutateForFilters_damageImm_player(ent);
	}

	static mutateForFilters_damageVuln_player (ent) {
		if (!ent.vulnerable) return;

		const out = new Set();
		ent.vulnerable.forEach(it => this._recurseResVulnImm(out, it));
		ent._fVuln = [...out];
	}

	static mutateForFilters_damageRes_player (ent) {
		if (!ent.resist) return;

		const out = new Set();
		ent.resist.forEach(it => this._recurseResVulnImm(out, it));
		ent._fRes = [...out];
	}

	static mutateForFilters_damageImm_player (ent) {
		if (!ent.immune) return;

		const out = new Set();
		ent.immune.forEach(iti => this._recurseResVulnImm(out, iti));
		ent._fImm = [...out];
	}

	static mutateForFilters_conditionImmune_player (ent) {
		if (!ent.conditionImmune) return;

		const out = new Set();
		ent.conditionImmune.forEach(it => this._recurseResVulnImm(out, it));
		ent._fCondImm = [...out];
	}

	static _recurseResVulnImm (allSet, it) {
		if (typeof it === "string") return allSet.add(it);
		if (it.choose?.from) it.choose?.from.forEach(itSub => this._recurseResVulnImm(allSet, itSub));
	}
};

globalThis.FilterCommon = FilterCommon$1;

"use strict";

let PageFilterConditionsDiseases$1 = class PageFilterConditionsDiseases extends PageFilter {
		static getDisplayProp (prop) {
		return prop === "status" ? "Other" : Parser.getPropDisplayName(prop);
	}
	
	constructor () {
		super();

		this._typeFilter = new Filter({
			header: "Type",
			items: ["condition", "disease", "status"],
			displayFn: PageFilterConditionsDiseases$1.getDisplayProp,
			deselFn: (it) => it === "disease" || it === "status",
		});
		this._miscFilter = new Filter({header: "Miscellaneous", items: ["SRD", "Basic Rules", "Has Images", "Has Info"], isMiscFilter: true});
	}

	static mutateForFilters (it) {
		it._fMisc = [];
		if (it.srd) it._fMisc.push("SRD");
		if (it.basicRules) it._fMisc.push("Basic Rules");
		if (it.hasFluff || it.fluff?.entries) it._fMisc.push("Has Info");
		if (it.hasFluffImages || it.fluff?.images) it._fMisc.push("Has Images");
	}

	addToFilters (it, isExcluded) {
		if (isExcluded) return;

		this._sourceFilter.addItem(it.source);
	}

	async _pPopulateBoxOptions (opts) {
		opts.filters = [
			this._sourceFilter,
			this._typeFilter,
			this._miscFilter,
		];
	}

	toDisplay (values, it) {
		return this._filterBox.toDisplay(
			values,
			it.source,
			it.__prop,
			it._fMisc,
		);
	}
};

globalThis.PageFilterConditionsDiseases = PageFilterConditionsDiseases$1;

"use strict";

let PageFilterCultsBoons$1 = class PageFilterCultsBoons extends PageFilter {
	constructor () {
		super();

		this._typeFilter = new Filter({
			header: "Type",
			items: ["Boon, Demonic", "Cult"],
		});
		this._subtypeFilter = new Filter({
			header: "Subtype",
			items: [],
		});
		this._miscFilter = new Filter({
			header: "Miscellaneous",
			items: ["Reprinted"],
			deselFn: (it) => it === "Reprinted",
			isMiscFilter: true,
		});
	}

	static mutateForFilters (it) {
		it._fType = it.__prop === "cult" ? "Cult" : it.type ? `Boon, ${it.type}` : "Boon";
		it._fMisc = [];
		if (this._isReprinted({reprintedAs: it.reprintedAs, tag: it.__prop, prop: it.__prop, page: UrlUtil.PG_CULTS_BOONS})) it._fMisc.push("Reprinted");
	}

	addToFilters (it, isExcluded) {
		if (isExcluded) return;

		this._sourceFilter.addItem(it.source);
		this._typeFilter.addItem(it._fType);
		this._subtypeFilter.addItem(it.type);
		this._miscFilter.addItem(it._fMisc);
	}

	async _pPopulateBoxOptions (opts) {
		opts.filters = [
			this._sourceFilter,
			this._typeFilter,
			this._subtypeFilter,
			this._miscFilter,
		];
	}

	toDisplay (values, cb) {
		return this._filterBox.toDisplay(
			values,
			cb.source,
			cb._fType,
			cb.type,
			cb._fMisc,
		);
	}
};

globalThis.PageFilterCultsBoons = PageFilterCultsBoons$1;

"use strict";

let PageFilterDecks$1 = class PageFilterDecks extends PageFilter {
	constructor () {
		super();

		this._miscFilter = new Filter({
			header: "Miscellaneous",
			items: ["Has Card Art", "SRD"],
			isMiscFilter: true,
			selFn: it => it === "Has Card Art",
		});
	}

	static mutateForFilters (ent) {
		ent._fMisc = [];
		if (ent.srd) ent._fMisc.push("SRD");
		if (ent.hasCardArt) ent._fMisc.push("Has Card Art");
	}

	addToFilters (ent, isExcluded) {
		if (isExcluded) return;

		this._sourceFilter.addItem(ent.source);
	}

	async _pPopulateBoxOptions (opts) {
		opts.filters = [
			this._sourceFilter,
			this._miscFilter,
		];
	}

	toDisplay (values, ent) {
		return this._filterBox.toDisplay(
			values,
			ent.source,
			ent._fMisc,
		);
	}

	static getListAliases (ent) {
		return (ent.alias || []).map(it => `"${it}"`).join(",");
	}
};

globalThis.PageFilterDecks = PageFilterDecks$1;

class ListSyntaxDecks extends ListUiUtil.ListSyntax {
	static _INDEXABLE_PROPS_ENTRIES = [
		"entries",
		"cards",
	];
}

globalThis.ListSyntaxDecks = ListSyntaxDecks;

"use strict";

let PageFilterDeities$1 = class PageFilterDeities extends PageFilter {
	static unpackAlignment (g) {
		g.alignment.sort(SortUtil.alignmentSort);
		if (g.alignment.length === 2 && g.alignment.includes("N")) {
			const out = [...g.alignment];
			if (out[0] === "N") out[0] = "NX";
			else out[1] = "NY";
			return out;
		}
		return MiscUtil.copy(g.alignment);
	}

	constructor () {
		super();
		this._pantheonFilter = new Filter({header: "Pantheon", items: []});
		this._categoryFilter = new Filter({header: "Category", items: [VeCt.STR_NONE]});
		this._alignmentFilter = new Filter({
			header: "Alignment",
			items: ["L", "NX", "C", "G", "NY", "E", "N"],
			displayFn: it => Parser.alignmentAbvToFull(it).toTitleCase(),
			itemSortFn: null,
		});
		this._domainFilter = new Filter({
			header: "Domain",
			items: ["Death", "Knowledge", "Life", "Light", "Nature", VeCt.STR_NONE, "Tempest", "Trickery", "War"],
		});
		this._miscFilter = new Filter({
			header: "Miscellaneous",
			items: ["Grants Piety Features", "Has Info", "Reprinted", "SRD", "Basic Rules"],
			displayFn: StrUtil.uppercaseFirst,
			deselFn: (it) => it === "Reprinted",
			isMiscFilter: true,
		});
	}

	static mutateForFilters (g) {
		g._fAlign = g.alignment ? PageFilterDeities$1.unpackAlignment(g) : [];
		if (!g.category) g.category = VeCt.STR_NONE;
		if (!g.domains) g.domains = [VeCt.STR_NONE];
		g.domains.sort(SortUtil.ascSort);

		g._fMisc = [];
		if (g.reprinted) g._fMisc.push("Reprinted");
		if (g.srd) g._fMisc.push("SRD");
		if (g.basicRules) g._fMisc.push("Basic Rules");
		if (g.entries || g.symbolImg) g._fMisc.push("Has Info");
		if (g.piety) g._fMisc.push("Grants Piety Features");
	}

	addToFilters (g, isExcluded) {
		if (isExcluded) return;

		this._sourceFilter.addItem(g.source);
		this._domainFilter.addItem(g.domains);
		this._pantheonFilter.addItem(g.pantheon);
		this._categoryFilter.addItem(g.category);
	}

	async _pPopulateBoxOptions (opts) {
		opts.filters = [
			this._sourceFilter,
			this._alignmentFilter,
			this._pantheonFilter,
			this._categoryFilter,
			this._domainFilter,
			this._miscFilter,
		];
	}

	toDisplay (values, g) {
		return this._filterBox.toDisplay(
			values,
			g.source,
			g._fAlign,
			g.pantheon,
			g.category,
			g.domains,
			g._fMisc,
		);
	}
};

globalThis.PageFilterDeities = PageFilterDeities$1;

"use strict";

let PageFilterFeats$1 = class PageFilterFeats extends PageFilter {
		
	constructor () {
		super();

		this._asiFilter = new Filter({
			header: "Ability Bonus",
			items: [
				"str",
				"dex",
				"con",
				"int",
				"wis",
				"cha",
			],
			displayFn: Parser.attAbvToFull,
			itemSortFn: null,
		});
		this._otherPrereqFilter = new Filter({
			header: "Other",
			items: ["Ability", "Race", "Psionics", "Proficiency", "Special", "Spellcasting"],
		});
		this._levelFilter = new Filter({
			header: "Level",
			itemSortFn: SortUtil.ascSortNumericalSuffix,
		});
		this._prerequisiteFilter = new MultiFilter({header: "Prerequisite", filters: [this._otherPrereqFilter, this._levelFilter]});
		this._benefitsFilter = new Filter({
			header: "Benefits",
			items: [
				"Armor Proficiency",
				"Language Proficiency",
				"Skill Proficiency",
				"Spellcasting",
				"Tool Proficiency",
				"Weapon Proficiency",
			],
		});
		this._vulnerableFilter = FilterCommon.getDamageVulnerableFilter();
		this._resistFilter = FilterCommon.getDamageResistFilter();
		this._immuneFilter = FilterCommon.getDamageImmuneFilter();
		this._defenceFilter = new MultiFilter({header: "Damage", filters: [this._vulnerableFilter, this._resistFilter, this._immuneFilter]});
		this._conditionImmuneFilter = FilterCommon.getConditionImmuneFilter();
		this._miscFilter = new Filter({header: "Miscellaneous", items: ["Has Info", "Has Images", "SRD", "Basic Rules"], isMiscFilter: true});
	}

	static mutateForFilters (feat) {
		const ability = Renderer.getAbilityData(feat.ability);
		feat._fAbility = ability.asCollection.filter(a => !ability.areNegative.includes(a)); 
		const prereqText = Renderer.utils.prerequisite.getHtml(feat.prerequisite, {isListMode: true}) || VeCt.STR_NONE;

		const preSet = new Set();
		(feat.prerequisite || []).forEach(it => preSet.add(...Object.keys(it)));
		feat._fPrereqOther = [...preSet].map(it => (it === "other" ? "special" : it === "spellcasting2020" ? "spellcasting" : it).uppercaseFirst());
		if (feat.prerequisite) feat._fPrereqLevel = feat.prerequisite.filter(it => it.level != null).map(it => `Level ${it.level.level ?? it.level}`);
		feat._fBenifits = [
			feat.resist ? "Damage Resistance" : null,
			feat.immune ? "Damage Immunity" : null,
			feat.conditionImmune ? "Condition Immunity" : null,
			feat.skillProficiencies ? "Skill Proficiency" : null,
			feat.additionalSpells ? "Spellcasting" : null,
			feat.armorProficiencies ? "Armor Proficiency" : null,
			feat.weaponProficiencies ? "Weapon Proficiency" : null,
			feat.toolProficiencies ? "Tool Proficiency" : null,
			feat.languageProficiencies ? "Language Proficiency" : null,
		].filter(it => it);
		if (feat.skillToolLanguageProficiencies?.length) {
			if (feat.skillToolLanguageProficiencies.some(it => (it.choose || []).some(x => x.from || [].includes("anySkill")))) feat._fBenifits.push("Skill Proficiency");
			if (feat.skillToolLanguageProficiencies.some(it => (it.choose || []).some(x => x.from || [].includes("anyTool")))) feat._fBenifits.push("Tool Proficiency");
			if (feat.skillToolLanguageProficiencies.some(it => (it.choose || []).some(x => x.from || [].includes("anyLanguage")))) feat._fBenifits.push("Language Proficiency");
		}
		feat._fMisc = feat.srd ? ["SRD"] : [];
		if (feat.basicRules) feat._fMisc.push("Basic Rules");
		if (feat.hasFluff || feat.fluff?.entries) feat._fMisc.push("Has Info");
		if (feat.hasFluffImages || feat.fluff?.images) feat._fMisc.push("Has Images");
		if (feat.repeatable != null) feat._fMisc.push(feat.repeatable ? "Repeatable" : "Not Repeatable");

		feat._slAbility = ability.asText || VeCt.STR_NONE;
		feat._slPrereq = prereqText;

		FilterCommon.mutateForFilters_damageVulnResImmune_player(feat);
		FilterCommon.mutateForFilters_conditionImmune_player(feat);
	}

	addToFilters (feat, isExcluded) {
		if (isExcluded) return;

		this._sourceFilter.addItem(feat.source);
		if (feat.prerequisite) this._levelFilter.addItem(feat._fPrereqLevel);
		this._vulnerableFilter.addItem(feat._fVuln);
		this._resistFilter.addItem(feat._fRes);
		this._immuneFilter.addItem(feat._fImm);
		this._conditionImmuneFilter.addItem(feat._fCondImm);
		this._benefitsFilter.addItem(feat._fBenifits);
		this._miscFilter.addItem(feat._fMisc);
	}

	async _pPopulateBoxOptions (opts) {
		opts.filters = [
			this._sourceFilter,
			this._asiFilter,
			this._prerequisiteFilter,
			this._benefitsFilter,
			this._defenceFilter,
			this._conditionImmuneFilter,
			this._miscFilter,
		];
	}

	toDisplay (values, ft) {
		return this._filterBox.toDisplay(
			values,
			ft.source,
			ft._fAbility,
			[
				ft._fPrereqOther,
				ft._fPrereqLevel,
			],
			ft._fBenifits,
			[
				ft._fVuln,
				ft._fRes,
				ft._fImm,
			],
			ft._fCondImm,
			ft._fMisc,
		);
	}
};

globalThis.PageFilterFeats = PageFilterFeats$1;

let ModalFilterFeats$1 = class ModalFilterFeats extends ModalFilter {
		constructor (opts) {
		opts = opts || {};
		super({
			...opts,
			modalTitle: `Feat${opts.isRadio ? "" : "s"}`,
			pageFilter: new PageFilterFeats$1(),
		});
	}

	_$getColumnHeaders () {
		const btnMeta = [
			{sort: "name", text: "Name", width: "4"},
			{sort: "ability", text: "Ability", width: "3"},
			{sort: "prerequisite", text: "Prerequisite", width: "3"},
			{sort: "source", text: "Source", width: "1"},
		];
		return ModalFilter._$getFilterColumnHeaders(btnMeta);
	}

	async _pLoadAllData () {
		return [
			...(await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/feats.json`)).feat,
			...((await PrereleaseUtil.pGetBrewProcessed()).feat || []),
			...((await BrewUtil2.pGetBrewProcessed()).feat || []),
		];
	}

	_getListItem (pageFilter, feat, ftI) {
		const eleRow = document.createElement("div");
		eleRow.className = "px-0 w-100 ve-flex-col no-shrink";

		const hash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_FEATS](feat);
		const source = Parser.sourceJsonToAbv(feat.source);

		eleRow.innerHTML = `<div class="w-100 ve-flex-vh-center lst--border veapp__list-row no-select lst__wrp-cells">
			<div class="col-0-5 pl-0 ve-flex-vh-center">${this._isRadio ? `<input type="radio" name="radio" class="no-events">` : `<input type="checkbox" class="no-events">`}</div>

			<div class="col-0-5 px-1 ve-flex-vh-center">
				<div class="ui-list__btn-inline px-2" title="Toggle Preview (SHIFT to Toggle Info Preview)">[+]</div>
			</div>

			<div class="col-4 ${feat._versionBase_isVersion ? "italic" : ""} ${this._getNameStyle()}">${feat._versionBase_isVersion ? `<span class="px-3"></span>` : ""}${feat.name}</div>
			<span class="col-3 ${feat._slAbility === VeCt.STR_NONE ? "italic" : ""}">${feat._slAbility}</span>
				<span class="col-3 ${feat._slPrereq === VeCt.STR_NONE ? "italic" : ""}">${feat._slPrereq}</span>
			<div class="col-1 pr-0 text-center ${Parser.sourceJsonToColor(feat.source)}" title="${Parser.sourceJsonToFull(feat.source)}" ${Parser.sourceJsonToStyle(feat.source)}>${source}</div>
		</div>`;

		const btnShowHidePreview = eleRow.firstElementChild.children[1].firstElementChild;

		const listItem = new ListItem(
			ftI,
			eleRow,
			feat.name,
			{
				hash,
				source,
				sourceJson: feat.source,
				ability: feat._slAbility,
				prerequisite: feat._slPrereq,
			},
			{
				cbSel: eleRow.firstElementChild.firstElementChild.firstElementChild,
				btnShowHidePreview,
			},
		);

		ListUiUtil.bindPreviewButton(UrlUtil.PG_FEATS, this._allData, listItem, btnShowHidePreview);

		return listItem;
	}
};

globalThis.ModalFilterFeats = ModalFilterFeats$1;

"use strict";

let PageFilterEquipment$1 = class PageFilterEquipment extends PageFilter {
	static _RE_FOUNDRY_ATTR = /(?:[-+*/]\s*)?@[a-z0-9.]+/gi;
	static _RE_DAMAGE_DICE_JUNK = /[^-+*/0-9d]/gi;
	static _RE_DAMAGE_DICE_D = /d/gi;

	static _getSortableDamageTerm (t) {
		try {
						return eval(
				`${t}`
					.replace(this._RE_FOUNDRY_ATTR, "")
					.replace(this._RE_DAMAGE_DICE_JUNK, "")
					.replace(this._RE_DAMAGE_DICE_D, "*"),
			);
					} catch (ignored) {
			return Number.MAX_SAFE_INTEGER;
		}
	}

	static _sortDamageDice (a, b) {
		return this._getSortableDamageTerm(a.item) - this._getSortableDamageTerm(b.item);
	}

	static _getMasteryDisplay (mastery) {
		const {name, source} = DataUtil.proxy.unpackUid("itemMastery", mastery, "itemMastery");
		if (SourceUtil.isSiteSource(source)) return name.toTitleCase();
		return `${name.toTitleCase()} (${Parser.sourceJsonToAbv(source)})`;
	}

	constructor ({filterOpts = null} = {}) {
		super();

		this._typeFilter = new Filter({
			header: "Type",
			deselFn: (it) => PageFilterItems$1._DEFAULT_HIDDEN_TYPES.has(it),
			displayFn: StrUtil.toTitleCase,
		});
		this._propertyFilter = new Filter({header: "Property", displayFn: StrUtil.uppercaseFirst});
		this._categoryFilter = new Filter({
			header: "Category",
			items: ["Basic", "Generic Variant", "Specific Variant", "Other"],
			deselFn: (it) => it === "Specific Variant",
			itemSortFn: null,
			...(filterOpts?.["Category"] || {}),
		});
		this._costFilter = new RangeFilter({
			header: "Cost",
			isLabelled: true,
			isAllowGreater: true,
			labelSortFn: null,
			labels: [
				0,
				...[...new Array(9)].map((_, i) => i + 1),
				...[...new Array(9)].map((_, i) => 10 * (i + 1)),
				...[...new Array(100)].map((_, i) => 100 * (i + 1)),
			],
			labelDisplayFn: it => !it ? "None" : Parser.getDisplayCurrency(CurrencyUtil.doSimplifyCoins({cp: it})),
		});
		this._weightFilter = new RangeFilter({header: "Weight", min: 0, max: 100, isAllowGreater: true, suffix: " lb."});
		this._focusFilter = new Filter({header: "Spellcasting Focus", items: [...Parser.ITEM_SPELLCASTING_FOCUS_CLASSES]});
		this._damageTypeFilter = new Filter({header: "Weapon Damage Type", displayFn: it => Parser.dmgTypeToFull(it).uppercaseFirst(), itemSortFn: (a, b) => SortUtil.ascSortLower(Parser.dmgTypeToFull(a), Parser.dmgTypeToFull(b))});
		this._damageDiceFilter = new Filter({header: "Weapon Damage Dice", items: ["1", "1d4", "1d6", "1d8", "1d10", "1d12", "2d6"], itemSortFn: (a, b) => PageFilterEquipment$1._sortDamageDice(a, b)});
		this._miscFilter = new Filter({header: "Miscellaneous", items: ["Item Group", "Bundle", "SRD", "Basic Rules", "Has Images", "Has Info"], isMiscFilter: true});
		this._poisonTypeFilter = new Filter({header: "Poison Type", items: ["ingested", "injury", "inhaled", "contact"], displayFn: StrUtil.toTitleCase});
		this._masteryFilter = new Filter({header: "Mastery", displayFn: this.constructor._getMasteryDisplay.bind(this)});
	}

	static mutateForFilters (item) {
		item._fSources = SourceFilter.getCompleteFilterSources(item);

		item._fProperties = item.property ? item.property.map(p => Renderer.item.propertyMap[p].name).filter(n => n) : [];

		item._fMisc = [];
		if (item._isItemGroup) item._fMisc.push("Item Group");
		if (item.packContents) item._fMisc.push("Bundle");
		if (item.srd) item._fMisc.push("SRD");
		if (item.basicRules) item._fMisc.push("Basic Rules");
		if (item.hasFluff || item.fluff?.entries) item._fMisc.push("Has Info");
		if (item.hasFluffImages || item.fluff?.images) item._fMisc.push("Has Images");
		if (item.miscTags) item._fMisc.push(...item.miscTags.map(Parser.itemMiscTagToFull));

		if (item.focus || item.name === "Thieves' Tools" || item.type === "INS" || item.type === "SCF" || item.type === "AT") {
			item._fFocus = item.focus ? item.focus === true ? [...Parser.ITEM_SPELLCASTING_FOCUS_CLASSES] : [...item.focus] : [];
			if ((item.name === "Thieves' Tools" || item.type === "AT") && !item._fFocus.includes("Artificer")) item._fFocus.push("Artificer");
			if (item.type === "INS" && !item._fFocus.includes("Bard")) item._fFocus.push("Bard");
			if (item.type === "SCF") {
				switch (item.scfType) {
					case "arcane": {
						if (!item._fFocus.includes("Sorcerer")) item._fFocus.push("Sorcerer");
						if (!item._fFocus.includes("Warlock")) item._fFocus.push("Warlock");
						if (!item._fFocus.includes("Wizard")) item._fFocus.push("Wizard");
						break;
					}
					case "druid": {
						if (!item._fFocus.includes("Druid")) item._fFocus.push("Druid");
						break;
					}
					case "holy":
						if (!item._fFocus.includes("Cleric")) item._fFocus.push("Cleric");
						if (!item._fFocus.includes("Paladin")) item._fFocus.push("Paladin");
						break;
				}
			}
		}

		item._fValue = Math.round(item.value || 0);

		item._fDamageDice = [];
		if (item.dmg1) item._fDamageDice.push(item.dmg1);
		if (item.dmg2) item._fDamageDice.push(item.dmg2);

		item._fMastery = item.mastery
			? item.mastery.map(it => {
				const {name, source} = DataUtil.proxy.unpackUid("itemMastery", it, "itemMastery", {isLower: true});
				return [name, source].join("|");
			})
			: null;
	}

	addToFilters (item, isExcluded) {
		if (isExcluded) return;

		this._sourceFilter.addItem(item._fSources);
		this._typeFilter.addItem(item._typeListText);
		this._propertyFilter.addItem(item._fProperties);
		this._damageTypeFilter.addItem(item.dmgType);
		this._damageDiceFilter.addItem(item._fDamageDice);
		this._poisonTypeFilter.addItem(item.poisonTypes);
		this._miscFilter.addItem(item._fMisc);
		this._masteryFilter.addItem(item._fMastery);
	}

	async _pPopulateBoxOptions (opts) {
		opts.filters = [
			this._sourceFilter,
			this._typeFilter,
			this._propertyFilter,
			this._categoryFilter,
			this._costFilter,
			this._weightFilter,
			this._focusFilter,
			this._damageTypeFilter,
			this._damageDiceFilter,
			this._miscFilter,
			this._poisonTypeFilter,
			this._masteryFilter,
		];
	}

	toDisplay (values, it) {
		return this._filterBox.toDisplay(
			values,
			it._fSources,
			it._typeListText,
			it._fProperties,
			it._category,
			it._fValue,
			it.weight,
			it._fFocus,
			it.dmgType,
			it._fDamageDice,
			it._fMisc,
			it.poisonTypes,
			it._fMastery,
		);
	}
};

globalThis.PageFilterEquipment = PageFilterEquipment$1;

let PageFilterItems$1 = class PageFilterItems extends PageFilterEquipment$1 {
	static _DEFAULT_HIDDEN_TYPES = new Set(["treasure", "futuristic", "modern", "renaissance"]);
	static _FILTER_BASE_ITEMS_ATTUNEMENT = ["Requires Attunement", "Requires Attunement By...", "Attunement Optional", VeCt.STR_NO_ATTUNEMENT];

		static sortItems (a, b, o) {
		if (o.sortBy === "name") return SortUtil.compareListNames(a, b);
		else if (o.sortBy === "type") return SortUtil.ascSortLower(a.values.type, b.values.type) || SortUtil.compareListNames(a, b);
		else if (o.sortBy === "source") return SortUtil.ascSortLower(a.values.source, b.values.source) || SortUtil.compareListNames(a, b);
		else if (o.sortBy === "rarity") return SortUtil.ascSortItemRarity(a.values.rarity, b.values.rarity) || SortUtil.compareListNames(a, b);
		else if (o.sortBy === "attunement") return SortUtil.ascSort(a.values.attunement, b.values.attunement) || SortUtil.compareListNames(a, b);
		else if (o.sortBy === "count") return SortUtil.ascSort(a.data.count, b.data.count) || SortUtil.compareListNames(a, b);
		else if (o.sortBy === "weight") return SortUtil.ascSort(a.values.weight, b.values.weight) || SortUtil.compareListNames(a, b);
		else if (o.sortBy === "cost") return SortUtil.ascSort(a.values.cost, b.values.cost) || SortUtil.compareListNames(a, b);
		else return 0;
	}

	static _getBaseItemDisplay (baseItem) {
		if (!baseItem) return null;
		let [name, source] = baseItem.split("__");
		name = name.toTitleCase();
		source = source || Parser.SRC_DMG;
		if (source.toLowerCase() === Parser.SRC_PHB.toLowerCase()) return name;
		return `${name} (${Parser.sourceJsonToAbv(source)})`;
	}

	static _sortAttunementFilter (a, b) {
		const ixA = PageFilterItems$1._FILTER_BASE_ITEMS_ATTUNEMENT.indexOf(a.item);
		const ixB = PageFilterItems$1._FILTER_BASE_ITEMS_ATTUNEMENT.indexOf(b.item);

		if (~ixA && ~ixB) return ixA - ixB;
		if (~ixA) return -1;
		if (~ixB) return 1;
		return SortUtil.ascSortLower(a, b);
	}

	static _getAttunementFilterItems (item) {
		const out = item._attunementCategory ? [item._attunementCategory] : [];

		if (!item.reqAttuneTags && !item.reqAttuneAltTags) return out;

		[...item.reqAttuneTags || [], ...item.reqAttuneAltTags || []].forEach(tagSet => {
			Object.entries(tagSet)
				.forEach(([prop, val]) => {
					switch (prop) {
						case "background": out.push(`Background: ${val.split("|")[0].toTitleCase()}`); break;
						case "languageProficiency": out.push(`Language Proficiency: ${val.toTitleCase()}`); break;
						case "skillProficiency": out.push(`Skill Proficiency: ${val.toTitleCase()}`); break;
						case "race": out.push(`Race: ${val.split("|")[0].toTitleCase()}`); break;
						case "creatureType": out.push(`Creature Type: ${val.toTitleCase()}`); break;
						case "size": out.push(`Size: ${Parser.sizeAbvToFull(val)}`.toTitleCase()); break;
						case "class": out.push(`Class: ${val.split("|")[0].toTitleCase()}`); break;
						case "alignment": out.push(`Alignment: ${Parser.alignmentListToFull(val).toTitleCase()}`); break;

						case "str":
						case "dex":
						case "con":
						case "int":
						case "wis":
						case "cha": out.push(`${Parser.attAbvToFull(prop)}: ${val} or Higher`); break;

						case "spellcasting": out.push("Spellcaster"); break;
						case "psionics": out.push("Psionics"); break;
					}
				});
		});

		return out;
	}

		constructor (opts) {
		super(opts);

		this._tierFilter = new Filter({header: "Tier", items: ["none", "minor", "major"], itemSortFn: null, displayFn: StrUtil.toTitleCase});
		this._attachedSpellsFilter = new SearchableFilter({header: "Attached Spells", displayFn: (it) => it.split("|")[0].toTitleCase(), itemSortFn: SortUtil.ascSortLower});
		this._lootTableFilter = new Filter({
			header: "Found On",
			items: ["Magic Item Table A", "Magic Item Table B", "Magic Item Table C", "Magic Item Table D", "Magic Item Table E", "Magic Item Table F", "Magic Item Table G", "Magic Item Table H", "Magic Item Table I"],
			displayFn: it => {
				const [name, sourceJson] = it.split("|");
				return `${name}${sourceJson ? ` (${Parser.sourceJsonToAbv(sourceJson)})` : ""}`;
			},
		});
		this._rarityFilter = new Filter({
			header: "Rarity",
			items: [...Parser.ITEM_RARITIES],
			itemSortFn: null,
			displayFn: StrUtil.toTitleCase,
		});
		this._attunementFilter = new Filter({header: "Attunement", items: [...PageFilterItems$1._FILTER_BASE_ITEMS_ATTUNEMENT], itemSortFn: PageFilterItems$1._sortAttunementFilter});
		this._bonusFilter = new Filter({
			header: "Bonus",
			items: [
				"Armor Class", "Proficiency Bonus", "Spell Attacks", "Spell Save DC", "Saving Throws",
				...([...new Array(4)]).map((_, i) => `Weapon Attack and Damage Rolls${i ? ` (+${i})` : ""}`),
				...([...new Array(4)]).map((_, i) => `Weapon Attack Rolls${i ? ` (+${i})` : ""}`),
				...([...new Array(4)]).map((_, i) => `Weapon Damage Rolls${i ? ` (+${i})` : ""}`),
			],
			itemSortFn: null,
		});
		this._rechargeTypeFilter = new Filter({header: "Recharge Type", displayFn: Parser.itemRechargeToFull});
		this._miscFilter = new Filter({header: "Miscellaneous", items: ["Ability Score Adjustment", "Charges", "Cursed", "Grants Proficiency", "Has Images", "Has Info", "Item Group", "Bundle", "Magic", "Mundane", "Sentient", "Speed Adjustment", "SRD", "Basic Rules"], isMiscFilter: true});
		this._baseSourceFilter = new SourceFilter({header: "Base Source", selFn: null});
		this._baseItemFilter = new Filter({header: "Base Item", displayFn: this.constructor._getBaseItemDisplay.bind(this.constructor)});
		this._optionalfeaturesFilter = new Filter({
			header: "Feature",
			displayFn: (it) => {
				const [name, source] = it.split("|");
				if (!source) return name.toTitleCase();
				const sourceJson = Parser.sourceJsonToJson(source);
				if (!SourceUtil.isNonstandardSourceWotc(sourceJson)) return name.toTitleCase();
				return `${name.toTitleCase()} (${Parser.sourceJsonToAbv(sourceJson)})`;
			},
			itemSortFn: SortUtil.ascSortLower,
		});
	}

	static mutateForFilters (item) {
		super.mutateForFilters(item);

		item._fTier = [item.tier ? item.tier : "none"];

		if (item.curse) item._fMisc.push("Cursed");
		const isMundane = Renderer.item.isMundane(item);
		item._fMisc.push(isMundane ? "Mundane" : "Magic");
		item._fIsMundane = isMundane;
		if (item.ability) item._fMisc.push("Ability Score Adjustment");
		if (item.modifySpeed) item._fMisc.push("Speed Adjustment");
		if (item.charges) item._fMisc.push("Charges");
		if (item.sentient) item._fMisc.push("Sentient");
		if (item.grantsProficiency) item._fMisc.push("Grants Proficiency");
		if (item.critThreshold) item._fMisc.push("Expanded Critical Range");

		const fBaseItemSelf = item._isBaseItem ? `${item.name}__${item.source}`.toLowerCase() : null;
		item._fBaseItem = [
			item.baseItem ? (item.baseItem.includes("|") ? item.baseItem.replace("|", "__") : `${item.baseItem}__${Parser.SRC_DMG}`).toLowerCase() : null,
			item._baseName ? `${item._baseName}__${item._baseSource || item.source}`.toLowerCase() : null,
		].filter(Boolean);
		item._fBaseItemAll = fBaseItemSelf ? [fBaseItemSelf, ...item._fBaseItem] : item._fBaseItem;

		item._fBonus = [];
		if (item.bonusAc) item._fBonus.push("Armor Class");
		this._mutateForFilters_bonusWeapon({prop: "bonusWeapon", item, text: "Weapon Attack and Damage Rolls"});
		this._mutateForFilters_bonusWeapon({prop: "bonusWeaponAttack", item, text: "Weapon Attack Rolls"});
		this._mutateForFilters_bonusWeapon({prop: "bonusWeaponDamage", item, text: "Weapon Damage Rolls"});
		if (item.bonusWeaponCritDamage) item._fBonus.push("Weapon Critical Damage");
		if (item.bonusSpellAttack) item._fBonus.push("Spell Attacks");
		if (item.bonusSpellSaveDc) item._fBonus.push("Spell Save DC");
		if (item.bonusSavingThrow) item._fBonus.push("Saving Throws");
		if (item.bonusProficiencyBonus) item._fBonus.push("Proficiency Bonus");

		item._fAttunement = this._getAttunementFilterItems(item);
	}

	static _mutateForFilters_bonusWeapon ({prop, item, text}) {
		if (!item[prop]) return;
		item._fBonus.push(text);
		switch (item[prop]) {
			case "+1":
			case "+2":
			case "+3": item._fBonus.push(`${text} (${item[prop]})`); break;
		}
	}

	addToFilters (item, isExcluded) {
		if (isExcluded) return;

		super.addToFilters(item, isExcluded);

		this._sourceFilter.addItem(item.source);
		this._tierFilter.addItem(item._fTier);
		this._attachedSpellsFilter.addItem(item.attachedSpells);
		this._lootTableFilter.addItem(item.lootTables);
		this._baseItemFilter.addItem(item._fBaseItem);
		this._baseSourceFilter.addItem(item._baseSource);
		this._attunementFilter.addItem(item._fAttunement);
		this._rechargeTypeFilter.addItem(item.recharge);
		this._optionalfeaturesFilter.addItem(item.optionalfeatures);
	}

	async _pPopulateBoxOptions (opts) {
		await super._pPopulateBoxOptions(opts);

		opts.filters = [
			this._sourceFilter,
			this._typeFilter,
			this._tierFilter,
			this._rarityFilter,
			this._propertyFilter,
			this._attunementFilter,
			this._categoryFilter,
			this._costFilter,
			this._weightFilter,
			this._focusFilter,
			this._damageTypeFilter,
			this._damageDiceFilter,
			this._bonusFilter,
			this._miscFilter,
			this._rechargeTypeFilter,
			this._poisonTypeFilter,
			this._masteryFilter,
			this._lootTableFilter,
			this._baseItemFilter,
			this._baseSourceFilter,
			this._optionalfeaturesFilter,
			this._attachedSpellsFilter,
		];
	}

	toDisplay (values, it) {
		return this._filterBox.toDisplay(
			values,
			it._fSources,
			it._typeListText,
			it._fTier,
			it.rarity,
			it._fProperties,
			it._fAttunement,
			it._category,
			it._fValue,
			it.weight,
			it._fFocus,
			it.dmgType,
			it._fDamageDice,
			it._fBonus,
			it._fMisc,
			it.recharge,
			it.poisonTypes,
			it._fMastery,
			it.lootTables,
			it._fBaseItemAll,
			it._baseSource,
			it.optionalfeatures,
			it.attachedSpells,
		);
	}
};

globalThis.PageFilterItems = PageFilterItems$1;

let ModalFilterItems$1 = class ModalFilterItems extends ModalFilter {
		constructor (opts) {
		opts = opts || {};
		super({
			...opts,
			modalTitle: `Item${opts.isRadio ? "" : "s"}`,
			pageFilter: new PageFilterItems$1(opts?.pageFilterOpts),
		});
	}

	_$getColumnHeaders () {
		const btnMeta = [
			{sort: "name", text: "Name", width: "4"},
			{sort: "type", text: "Type", width: "6"},
			{sort: "source", text: "Source", width: "1"},
		];
		return ModalFilter._$getFilterColumnHeaders(btnMeta);
	}

	async _pInit () {
		await Renderer.item.pPopulatePropertyAndTypeReference();
	}

	async _pLoadAllData () {
		return [
			...(await Renderer.item.pBuildList()),
			...(await Renderer.item.pGetItemsFromPrerelease()),
			...(await Renderer.item.pGetItemsFromBrew()),
		];
	}

	_getListItem (pageFilter, item, itI) {
		if (item.noDisplay) return null;

		Renderer.item.enhanceItem(item);
		pageFilter.mutateAndAddToFilters(item);

		const eleRow = document.createElement("div");
		eleRow.className = "px-0 w-100 ve-flex-col no-shrink";

		const hash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS](item);
		const source = Parser.sourceJsonToAbv(item.source);
		const type = item._typeListText.join(", ");

		eleRow.innerHTML = `<div class="w-100 ve-flex-vh-center lst--border veapp__list-row no-select lst__wrp-cells">
			<div class="col-0-5 pl-0 ve-flex-vh-center">${this._isRadio ? `<input type="radio" name="radio" class="no-events">` : `<input type="checkbox" class="no-events">`}</div>

			<div class="col-0-5 px-1 ve-flex-vh-center">
				<div class="ui-list__btn-inline px-2" title="Toggle Preview (SHIFT to Toggle Info Preview)">[+]</div>
			</div>

			<div class="col-5 ${item._versionBase_isVersion ? "italic" : ""} ${this._getNameStyle()}">${item._versionBase_isVersion ? `<span class="px-3"></span>` : ""}${item.name}</div>
			<div class="col-5">${type.uppercaseFirst()}</div>
			<div class="col-1 text-center ${Parser.sourceJsonToColor(item.source)} pr-0" title="${Parser.sourceJsonToFull(item.source)}" ${Parser.sourceJsonToStyle(item.source)}>${source}</div>
		</div>`;

		const btnShowHidePreview = eleRow.firstElementChild.children[1].firstElementChild;

		const listItem = new ListItem(
			itI,
			eleRow,
			item.name,
			{
				hash,
				source,
				sourceJson: item.source,
				type,
			},
			{
				cbSel: eleRow.firstElementChild.firstElementChild.firstElementChild,
				btnShowHidePreview,
			},
		);

		ListUiUtil.bindPreviewButton(UrlUtil.PG_ITEMS, this._allData, listItem, btnShowHidePreview);

		return listItem;
	}
};

globalThis.ModalFilterItems = ModalFilterItems$1;

class ListSyntaxItems extends ListUiUtil.ListSyntax {
	static _INDEXABLE_PROPS_ENTRIES = [
		"_fullEntries",
		"entries",
	];
}

globalThis.ListSyntaxItems = ListSyntaxItems;

"use strict";

let PageFilterLanguages$1 = class PageFilterLanguages extends PageFilter {
	constructor () {
		super();

		this._typeFilter = new Filter({header: "Type", items: ["standard", "exotic", "rare", "secret"], itemSortFn: null, displayFn: StrUtil.uppercaseFirst});
		this._scriptFilter = new Filter({header: "Script", displayFn: StrUtil.uppercaseFirst});
		this._miscFilter = new Filter({header: "Miscellaneous", items: ["Has Fonts", "SRD", "Basic Rules", "Has Images", "Has Info"], isMiscFilter: true});
	}

	static mutateForFilters (it) {
		it._fMisc = [];
		if (it.fonts || it._fonts) it._fMisc.push("Has Fonts");
		if (it.srd) it._fMisc.push("SRD");
		if (it.basicRules) it._fMisc.push("Basic Rules");
		if (it.hasFluff || it.fluff?.entries) it._fMisc.push("Has Info");
		if (it.hasFluffImages || it.fluff?.images) it._fMisc.push("Has Images");
	}

	addToFilters (it, isExcluded) {
		if (isExcluded) return;

		this._sourceFilter.addItem(it.source);
		this._scriptFilter.addItem(it.script);
	}

	async _pPopulateBoxOptions (opts) {
		opts.filters = [
			this._sourceFilter,
			this._typeFilter,
			this._scriptFilter,
			this._miscFilter,
		];
	}

	toDisplay (values, it) {
		return this._filterBox.toDisplay(
			values,
			it.source,
			it.type,
			it.script,
			it._fMisc,
		);
	}
};

globalThis.PageFilterLanguages = PageFilterLanguages$1;

"use strict";

let PageFilterObjects$1 = class PageFilterObjects extends PageFilter {
	constructor () {
		super();

		this._miscFilter = new Filter({header: "Miscellaneous", items: ["SRD", "Has Images", "Has Info", "Has Token"], isMiscFilter: true});
	}

	static mutateForFilters (obj) {
		obj._fMisc = obj.srd ? ["SRD"] : [];
		if (obj.tokenUrl || obj.hasToken) obj._fMisc.push("Has Token");
		if (obj.hasFluff || obj.fluff?.entries) obj._fMisc.push("Has Info");
		if (obj.hasFluffImages || obj.fluff?.images) obj._fMisc.push("Has Images");
	}

	addToFilters (obj, isExcluded) {
		if (isExcluded) return;

		this._sourceFilter.addItem(obj.source);
	}

	async _pPopulateBoxOptions (opts) {
		opts.filters = [
			this._sourceFilter,
			this._miscFilter,
		];
	}

	toDisplay (values, obj) {
		return this._filterBox.toDisplay(
			values,
			obj.source,
			obj._fMisc,
		);
	}
};

globalThis.PageFilterObjects = PageFilterObjects$1;

let ListSyntaxObjects$1 = class ListSyntaxObjects extends ListUiUtil.ListSyntax {
	static _INDEXABLE_PROPS_ENTRIES = [
		"entries",
		"actionEntries",
	];
};

globalThis.ListSyntaxObjects = ListSyntaxObjects$1;

"use strict";

let PageFilterOptionalFeatures$1 = class PageFilterOptionalFeatures extends PageFilter {
		static _filterFeatureTypeSort (a, b) {
		return SortUtil.ascSort(Parser.optFeatureTypeToFull(a.item), Parser.optFeatureTypeToFull(b.item));
	}

	static sortOptionalFeatures (itemA, itemB, options) {
		if (options.sortBy === "level") {
			const aValue = Number(itemA.values.level) || 0;
			const bValue = Number(itemB.values.level) || 0;
			return SortUtil.ascSort(aValue, bValue) || SortUtil.listSort(itemA, itemB, options);
		}
		return SortUtil.listSort(itemA, itemB, options);
	}
	
	constructor () {
		super();

		this._typeFilter = new Filter({
			header: "Feature Type",
			items: [],
			displayFn: Parser.optFeatureTypeToFull,
			itemSortFn: PageFilterOptionalFeatures$1._filterFeatureTypeSort,
		});
		this._pactFilter = new Filter({
			header: "Pact Boon",
			items: [],
			displayFn: Parser.prereqPactToFull,
		});
		this._patronFilter = new Filter({
			header: "Otherworldly Patron",
			items: [],
			displayFn: Parser.prereqPatronToShort,
		});
		this._spellFilter = new Filter({
			header: "Spell",
			items: [],
			displayFn: StrUtil.toTitleCase,
		});
		this._featureFilter = new Filter({
			header: "Feature",
			displayFn: StrUtil.toTitleCase,
		});
		this._levelFilter = new Filter({
			header: "Level",
			itemSortFn: SortUtil.ascSortNumericalSuffix,
			nests: [],
		});
		this._prerequisiteFilter = new MultiFilter({
			header: "Prerequisite",
			filters: [
				this._pactFilter,
				this._patronFilter,
				this._spellFilter,
				this._levelFilter,
				this._featureFilter,
			],
		});
		this._miscFilter = new Filter({header: "Miscellaneous", items: ["SRD", "Grants Additional Spells"], isMiscFilter: true});
	}

	static mutateForFilters (it) {
		it._fSources = SourceFilter.getCompleteFilterSources(it);

				it.featureType = it.featureType && it.featureType instanceof Array ? it.featureType : it.featureType ? [it.featureType] : ["OTH"];
		if (it.prerequisite) {
			it._sPrereq = true;
			it._fPrereqPact = it.prerequisite.filter(it => it.pact).map(it => it.pact);
			it._fPrereqPatron = it.prerequisite.filter(it => it.patron).map(it => it.patron);
			it._fprereqSpell = it.prerequisite.filter(it => it.spell).map(it => {
				return (it.spell || []).map(it => it.split("#")[0].split("|")[0]);
			});
			it._fprereqFeature = it.prerequisite.filter(it => it.feature).map(it => it.feature);
			it._fPrereqLevel = it.prerequisite.filter(it => it.level).map(it => {
				const lvlMeta = it.level;

				let item;
				let className;
				if (typeof lvlMeta === "number") {
					className = `(No Class)`;
					item = new FilterItem({
						item: `Level ${lvlMeta}`,
						nest: className,
					});
				} else {
					className = lvlMeta.class ? lvlMeta.class.name : `(No Class)`;
					item = new FilterItem({
						item: `${lvlMeta.class ? className : ""}${lvlMeta.subclass ? ` (${lvlMeta.subclass.name})` : ""} Level ${lvlMeta.level}`,
						nest: className,
					});
				}

				return item;
			});
		}

		it._dFeatureType = it.featureType.map(ft => Parser.optFeatureTypeToFull(ft));
		it._lFeatureType = it.featureType.join(", ");
		it.featureType.sort((a, b) => SortUtil.ascSortLower(Parser.optFeatureTypeToFull(a), Parser.optFeatureTypeToFull(b)));

		it._fMisc = it.srd ? ["SRD"] : [];
		if (it.additionalSpells) it._fMisc.push("Grants Additional Spells");
	}

	addToFilters (it, isExcluded) {
		if (isExcluded) return;

		this._sourceFilter.addItem(it._fSources);
		this._typeFilter.addItem(it.featureType);
		this._pactFilter.addItem(it._fPrereqPact);
		this._patronFilter.addItem(it._fPrereqPatron);
		this._spellFilter.addItem(it._fprereqSpell);
		this._featureFilter.addItem(it._fprereqFeature);

		(it._fPrereqLevel || []).forEach(it => {
			this._levelFilter.addNest(it.nest, {isHidden: true});
			this._levelFilter.addItem(it);
		});
	}

	async _pPopulateBoxOptions (opts) {
		opts.filters = [
			this._sourceFilter,
			this._typeFilter,
			this._prerequisiteFilter,
			this._miscFilter,
		];
	}

	toDisplay (values, it) {
		return this._filterBox.toDisplay(
			values,
			it._fSources,
			it.featureType,
			[
				it._fPrereqPact,
				it._fPrereqPatron,
				it._fprereqSpell,
				it._fPrereqLevel,
				it._fprereqFeature,
			],
			it._fMisc,
		);
	}
};

globalThis.PageFilterOptionalFeatures = PageFilterOptionalFeatures$1;

class ModalFilterOptionalFeatures extends ModalFilter {
		constructor (opts) {
		opts = opts || {};
		super({
			...opts,
			modalTitle: `Optional Feature${opts.isRadio ? "" : "s"}`,
			pageFilter: new PageFilterOptionalFeatures$1(),
		});
	}

	_$getColumnHeaders () {
		const btnMeta = [
			{sort: "name", text: "Name", width: "3"},
			{sort: "type", text: "Type", width: "2"},
			{sort: "prerequisite", text: "Prerequisite", width: "4"},
			{sort: "level", text: "Level", width: "1"},
			{sort: "source", text: "Source", width: "1"},
		];
		return ModalFilter._$getFilterColumnHeaders(btnMeta);
	}

	async _pLoadAllData () {
		return [
			...(await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/optionalfeatures.json`)).optionalfeature,
			...((await PrereleaseUtil.pGetBrewProcessed()).optionalfeature || []),
			...((await BrewUtil2.pGetBrewProcessed()).optionalfeature || []),
		];
	}

	_getListItem (pageFilter, optfeat, ftI) {
		const eleRow = document.createElement("div");
		eleRow.className = "px-0 w-100 ve-flex-col no-shrink";

		const hash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_OPT_FEATURES](optfeat);
		const source = Parser.sourceJsonToAbv(optfeat.source);
		const prerequisite = Renderer.utils.prerequisite.getHtml(optfeat.prerequisite, {isListMode: true, blocklistKeys: new Set(["level"])});
		const level = Renderer.optionalfeature.getListPrerequisiteLevelText(optfeat.prerequisite);

		eleRow.innerHTML = `<div class="w-100 ve-flex-vh-center lst--border veapp__list-row no-select lst__wrp-cells">
			<div class="col-0-5 pl-0 ve-flex-vh-center">${this._isRadio ? `<input type="radio" name="radio" class="no-events">` : `<input type="checkbox" class="no-events">`}</div>

			<div class="col-0-5 px-1 ve-flex-vh-center">
				<div class="ui-list__btn-inline px-2" title="Toggle Preview (SHIFT to Toggle Info Preview)">[+]</div>
			</div>

			<div class="col-3 ${optfeat._versionBase_isVersion ? "italic" : ""} ${this._getNameStyle()}">${optfeat._versionBase_isVersion ? `<span class="px-3"></span>` : ""}${optfeat.name}</div>
			<span class="col-2 text-center" title="${optfeat._dFeatureType}">${optfeat._lFeatureType}</span>
			<span class="col-4 text-center">${prerequisite}</span>
			<span class="col-1 text-center">${level}</span>
			<div class="col-1 pr-0 text-center ${Parser.sourceJsonToColor(optfeat.source)}" title="${Parser.sourceJsonToFull(optfeat.source)}" ${Parser.sourceJsonToStyle(optfeat.source)}>${source}</div>
		</div>`;

		const btnShowHidePreview = eleRow.firstElementChild.children[1].firstElementChild;

		const listItem = new ListItem(
			ftI,
			eleRow,
			optfeat.name,
			{
				hash,
				source,
				sourceJson: optfeat.source,
				prerequisite,
				level,
				type: optfeat._lFeatureType,
			},
			{
				cbSel: eleRow.firstElementChild.firstElementChild.firstElementChild,
				btnShowHidePreview,
			},
		);

		ListUiUtil.bindPreviewButton(UrlUtil.PG_FEATS, this._allData, listItem, btnShowHidePreview);

		return listItem;
	}
}

globalThis.ModalFilterOptionalFeatures = ModalFilterOptionalFeatures;

"use strict";

let PageFilterPsionics$1 = class PageFilterPsionics extends PageFilter {
		static _sortFilterTypes (a, b) {
		a = a.item; b = b.item;
		a = Parser.psiTypeToMeta(a);
		b = Parser.psiTypeToMeta(b);
		return (Number(a.hasOrder) - Number(b.hasOrder)) || SortUtil.ascSortLower(a.full, b.full);
	}
	
	constructor () {
		super({sourceFilterOpts: {deselFn: () => false}});

		this._typeFilter = new Filter({header: "Type", items: [Parser.PSI_ABV_TYPE_TALENT, Parser.PSI_ABV_TYPE_DISCIPLINE], displayFn: Parser.psiTypeToFull, itemSortFn: PageFilterPsionics$1._sortFilterTypes});
		this._orderFilter = new Filter({
			header: "Order",
			items: [Parser.PSI_ORDER_NONE],
		});
	}

	static mutateForFilters (p) {
		p._fOrder = Parser.psiOrderToFull(p.order);
	}

	addToFilters (p, isExcluded) {
		if (isExcluded) return;

		this._sourceFilter.addItem(p.source);
		this._typeFilter.addItem(p.type);
		this._orderFilter.addItem(p._fOrder);
	}

	async _pPopulateBoxOptions (opts) {
		opts.filters = [
			this._sourceFilter,
			this._typeFilter,
			this._orderFilter,
		];
	}

	toDisplay (values, p) {
		return this._filterBox.toDisplay(
			values,
			p.source,
			p.type,
			p._fOrder,
		);
	}
};

globalThis.PageFilterPsionics = PageFilterPsionics$1;

let ListSyntaxPsionics$1 = class ListSyntaxPsionics extends ListUiUtil.ListSyntax {
	static _INDEXABLE_PROPS_ENTRIES = [
		"entries",
		"modes",
		"focus",
	];
};

globalThis.ListSyntaxPsionics = ListSyntaxPsionics$1;

"use strict";

let PageFilterRaces$1 = class PageFilterRaces extends PageFilter {
		static getLanguageProficiencyTags (lProfs) {
		if (!lProfs) return [];

		const outSet = new Set();
		lProfs.forEach(lProfGroup => {
			Object.keys(lProfGroup)
				.forEach(k => {
					if (k !== "choose" && k !== "any" && k !== "anyStandard") outSet.add(k.toTitleCase());
					else outSet.add("Choose");
				});
		});

		return [...outSet];
	}

	static getSpeedRating (speed) { return speed > 30 ? "Walk (Fast)" : speed < 30 ? "Walk (Slow)" : "Walk"; }

	static filterAscSortSize (a, b) {
		a = a.item;
		b = b.item;

		return SortUtil.ascSort(toNum(a), toNum(b));

		function toNum (size) {
			switch (size) {
				case "M": return 0;
				case "S": return -1;
				case "V": return 1;
			}
		}
	}
	
	constructor () {
		super();

		this._sizeFilter = new Filter({header: "Size", displayFn: Parser.sizeAbvToFull, itemSortFn: PageFilterRaces$1.filterAscSortSize});
		this._asiFilter = new AbilityScoreFilter({header: "Ability Scores (Including Subrace)"});
		this._baseRaceFilter = new Filter({header: "Base Race"});
		this._speedFilter = new Filter({header: "Speed", items: ["Climb", "Fly", "Swim", "Walk (Fast)", "Walk", "Walk (Slow)"]});
		this._traitFilter = new Filter({
			header: "Traits",
			items: [
				"Amphibious",
				"Armor Proficiency",
				"Blindsight",
				"Darkvision", "Superior Darkvision",
				"Dragonmark",
				"Feat",
				"Improved Resting",
				"Monstrous Race",
				"Natural Armor",
				"Natural Weapon",
				"NPC Race",
				"Powerful Build",
				"Skill Proficiency",
				"Spellcasting",
				"Sunlight Sensitivity",
				"Tool Proficiency",
				"Uncommon Race",
				"Weapon Proficiency",
			],
			deselFn: (it) => {
				return it === "NPC Race";
			},
		});
		this._vulnerableFilter = FilterCommon.getDamageVulnerableFilter();
		this._resistFilter = FilterCommon.getDamageResistFilter();
		this._immuneFilter = FilterCommon.getDamageImmuneFilter();
		this._defenceFilter = new MultiFilter({header: "Damage", filters: [this._vulnerableFilter, this._resistFilter, this._immuneFilter]});
		this._conditionImmuneFilter = FilterCommon.getConditionImmuneFilter();
		this._languageFilter = new Filter({
			header: "Languages",
			items: [
				"Abyssal",
				"Celestial",
				"Choose",
				"Common",
				"Draconic",
				"Dwarvish",
				"Elvish",
				"Giant",
				"Gnomish",
				"Goblin",
				"Halfling",
				"Infernal",
				"Orc",
				"Other",
				"Primordial",
				"Sylvan",
				"Undercommon",
			],
			umbrellaItems: ["Choose"],
		});
		this._creatureTypeFilter = new Filter({
			header: "Creature Type",
			items: Parser.MON_TYPES,
			displayFn: StrUtil.toTitleCase,
			itemSortFn: SortUtil.ascSortLower,
		});
		this._ageFilter = new RangeFilter({
			header: "Adult Age",
			isRequireFullRangeMatch: true,
			isSparse: true,
			displayFn: it => `${it} y.o.`,
			displayFnTooltip: it => `${it} year${it === 1 ? "" : "s"} old`,
		});
		this._miscFilter = new Filter({
			header: "Miscellaneous",
			items: ["Base Race", "Key Race", "Lineage", "Modified Copy", "Reprinted", "SRD", "Basic Rules", "Has Images", "Has Info"],
			isMiscFilter: true,
					});
	}

	static mutateForFilters (r) {
		r._fSize = r.size ? [...r.size] : [];
		if (r._fSize.length > 1) r._fSize.push("V");
		r._fSpeed = r.speed ? r.speed.walk ? [r.speed.climb ? "Climb" : null, r.speed.fly ? "Fly" : null, r.speed.swim ? "Swim" : null, PageFilterRaces$1.getSpeedRating(r.speed.walk)].filter(it => it) : [PageFilterRaces$1.getSpeedRating(r.speed)] : [];
		r._fTraits = [
			r.darkvision === 120 ? "Superior Darkvision" : r.darkvision ? "Darkvision" : null,
			r.blindsight ? "Blindsight" : null,
			r.skillProficiencies ? "Skill Proficiency" : null,
			r.toolProficiencies ? "Tool Proficiency" : null,
			r.feats ? "Feat" : null,
			r.additionalSpells ? "Spellcasting" : null,
			r.armorProficiencies ? "Armor Proficiency" : null,
			r.weaponProficiencies ? "Weapon Proficiency" : null,
		].filter(it => it);
		r._fTraits.push(...(r.traitTags || []));
		r._fSources = SourceFilter.getCompleteFilterSources(r);
		r._fLangs = PageFilterRaces$1.getLanguageProficiencyTags(r.languageProficiencies);
		r._fCreatureTypes = r.creatureTypes ? r.creatureTypes.map(it => it.choose || it).flat() : ["humanoid"];
		r._fMisc = [];
		if (r._isBaseRace) r._fMisc.push("Base Race");
		if (r._isBaseRace || !r._isSubRace) r._fMisc.push("Key Race");
		if (r._isCopy) r._fMisc.push("Modified Copy");
		if (r.srd) r._fMisc.push("SRD");
		if (r.basicRules) r._fMisc.push("Basic Rules");
		if (r.hasFluff || r.fluff?.entries) r._fMisc.push("Has Info");
		if (r.hasFluffImages || r.fluff?.images) r._fMisc.push("Has Images");
		if (r.lineage) r._fMisc.push("Lineage");
		if (this._isReprinted({reprintedAs: r.reprintedAs, tag: "race", prop: "race", page: UrlUtil.PG_RACES})) r._fMisc.push("Reprinted");

		const ability = r.ability ? Renderer.getAbilityData(r.ability, {isOnlyShort: true, isCurrentLineage: r.lineage === "VRGR"}) : {asTextShort: "None"};
		r._slAbility = ability.asTextShort;

		if (r.age?.mature != null && r.age?.max != null) r._fAge = [r.age.mature, r.age.max];
		else if (r.age?.mature != null) r._fAge = r.age.mature;
		else if (r.age?.max != null) r._fAge = r.age.max;

		FilterCommon.mutateForFilters_damageVulnResImmune_player(r);
		FilterCommon.mutateForFilters_conditionImmune_player(r);
	}

	addToFilters (r, isExcluded) {
		if (isExcluded) return;

		this._sourceFilter.addItem(r._fSources);
		this._sizeFilter.addItem(r._fSize);
		this._asiFilter.addItem(r.ability);
		this._baseRaceFilter.addItem(r._baseName);
		this._creatureTypeFilter.addItem(r._fCreatureTypes);
		this._traitFilter.addItem(r._fTraits);
		this._vulnerableFilter.addItem(r._fVuln);
		this._resistFilter.addItem(r._fRes);
		this._immuneFilter.addItem(r._fImm);
		this._conditionImmuneFilter.addItem(r._fCondImm);
		this._ageFilter.addItem(r._fAge);
		this._languageFilter.addItem(r._fLangs);
	}

	async _pPopulateBoxOptions (opts) {
		opts.filters = [
			this._sourceFilter,
			this._asiFilter,
			this._sizeFilter,
			this._speedFilter,
			this._traitFilter,
			this._defenceFilter,
			this._conditionImmuneFilter,
			this._languageFilter,
			this._baseRaceFilter,
			this._creatureTypeFilter,
			this._miscFilter,
			this._ageFilter,
		];
	}

	toDisplay (values, r) {
		return this._filterBox.toDisplay(
			values,
			r._fSources,
			r.ability,
			r._fSize,
			r._fSpeed,
			r._fTraits,
			[
				r._fVuln,
				r._fRes,
				r._fImm,
			],
			r._fCondImm,
			r._fLangs,
			r._baseName,
			r._fCreatureTypes,
			r._fMisc,
			r._fAge,
		);
	}

	static getListAliases (race) {
		return (race.alias || [])
			.map(it => {
				const invertedName = PageFilterRaces$1.getInvertedName(it);
				return [`"${it}"`, invertedName ? `"${invertedName}"` : false].filter(Boolean);
			})
			.flat()
			.join(",");
	}

	static getInvertedName (name) {
				const bracketMatch = /^(.*?) \((.*?)\)$/.exec(name);
		return bracketMatch ? `${bracketMatch[2]} ${bracketMatch[1]}` : null;
	}
};

globalThis.PageFilterRaces = PageFilterRaces$1;

let ModalFilterRaces$1 = class ModalFilterRaces extends ModalFilter {
		constructor (opts) {
		opts = opts || {};
		super({
			...opts,
			modalTitle: `Race${opts.isRadio ? "" : "s"}`,
			pageFilter: new PageFilterRaces$1(),
		});
	}

	_$getColumnHeaders () {
		const btnMeta = [
			{sort: "name", text: "Name", width: "4"},
			{sort: "ability", text: "Ability", width: "4"},
			{sort: "size", text: "Size", width: "2"},
			{sort: "source", text: "Source", width: "1"},
		];
		return ModalFilter._$getFilterColumnHeaders(btnMeta);
	}

	async _pLoadAllData () {
		return [
			...await DataUtil.race.loadJSON(),
			...((await DataUtil.race.loadPrerelease({isAddBaseRaces: false})).race || []),
			...((await DataUtil.race.loadBrew({isAddBaseRaces: false})).race || []),
		];
	}

	_getListItem (pageFilter, race, rI) {
		const eleRow = document.createElement("div");
		eleRow.className = "px-0 w-100 ve-flex-col no-shrink";

		const hash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_RACES](race);
		const ability = race.ability ? Renderer.getAbilityData(race.ability) : {asTextShort: "None"};
		const size = (race.size || [Parser.SZ_VARIES]).map(sz => Parser.sizeAbvToFull(sz)).join("/");
		const source = Parser.sourceJsonToAbv(race.source);

		eleRow.innerHTML = `<div class="w-100 ve-flex-vh-center lst--border veapp__list-row no-select lst__wrp-cells">
			<div class="col-0-5 pl-0 ve-flex-vh-center">${this._isRadio ? `<input type="radio" name="radio" class="no-events">` : `<input type="checkbox" class="no-events">`}</div>

			<div class="col-0-5 px-1 ve-flex-vh-center">
				<div class="ui-list__btn-inline px-2" title="Toggle Preview (SHIFT to Toggle Info Preview)">[+]</div>
			</div>

			<div class="col-4 ${race._versionBase_isVersion ? "italic" : ""} ${this._getNameStyle()}">${race._versionBase_isVersion ? `<span class="px-3"></span>` : ""}${race.name}</div>
			<div class="col-4">${ability.asTextShort}</div>
			<div class="col-2 text-center">${size}</div>
			<div class="col-1 pr-0 text-center ${Parser.sourceJsonToColor(race.source)}" title="${Parser.sourceJsonToFull(race.source)}" ${Parser.sourceJsonToStyle(race.source)}>${source}</div>
		</div>`;

		const btnShowHidePreview = eleRow.firstElementChild.children[1].firstElementChild;

		const listItem = new ListItem(
			rI,
			eleRow,
			race.name,
			{
				hash,
				source,
				sourceJson: race.source,
				ability: ability.asTextShort,
				size,
				cleanName: PageFilterRaces$1.getInvertedName(race.name) || "",
				alias: PageFilterRaces$1.getListAliases(race),
			},
			{
				cbSel: eleRow.firstElementChild.firstElementChild.firstElementChild,
				btnShowHidePreview,
			},
		);

		ListUiUtil.bindPreviewButton(UrlUtil.PG_RACES, this._allData, listItem, btnShowHidePreview);

		return listItem;
	}
};

globalThis.ModalFilterRaces = ModalFilterRaces$1;

"use strict";

let PageFilterRecipes$1 = class PageFilterRecipes extends PageFilter {
	static _DIET_TO_FULL = {
		"V": "Vegan",
		"C": "Vegetarian",
		"X": "Omni",
	};
	static _MISC_TAG_TO_FULL = {
		"alcohol": "Contains Alcohol",
	};

	constructor () {
		super();

		this._typeFilter = new Filter({
			header: "Type",
			displayFn: StrUtil.toTitleCase,
			itemSortFn: SortUtil.ascSortLower,
		});
		this._dishTypeFilter = new Filter({
			header: "Dish Type",
			displayFn: StrUtil.toTitleCase,
			itemSortFn: SortUtil.ascSortLower,
		});
		this._servesFilter = new RangeFilter({header: "Serves", min: 1, max: 1});
		this._dietFilter = new Filter({
			header: "Diet",
			displayFn: PageFilterRecipes$1._dietToFull,
			itemSortFn: SortUtil.ascSortLower,
		});
		this._allergensFilter = new Filter({
			header: "Allergens",
			displayFn: StrUtil.toTitleCase,
			itemSortFn: SortUtil.ascSortLower,
		});
		this._miscFilter = new Filter({
			header: "Miscellaneous",
			items: ["SRD"],
			isMiscFilter: true,
			displayFn: PageFilterRecipes$1._miscTagToFull,
		});
	}

	static mutateForFilters (it) {
		it._fMisc = it.srd ? ["SRD"] : [];
		if (it.miscTags) it._fMisc.push(...it.miscTags);
		it._fServes = (it.serves?.min != null && it.serves?.max != null) ? [it.serves.min, it.serves.max] : (it.serves?.exact ?? null);
		it._fDiet = it.diet ? PageFilterRecipes$1._DIET_TO_FULL[it.diet] || it.diet : null;
	}

	addToFilters (it, isExcluded) {
		if (isExcluded) return;

		this._sourceFilter.addItem(it.source);
		this._typeFilter.addItem(it.type);
		this._dishTypeFilter.addItem(it.dishTypes);
		this._servesFilter.addItem(it._fServes);
		this._dietFilter.addItem(it._fDiet);
		this._allergensFilter.addItem(it.allergenGroups);
		this._miscFilter.addItem(it._fMisc);
	}

	async _pPopulateBoxOptions (opts) {
		opts.filters = [
			this._sourceFilter,
			this._typeFilter,
			this._dishTypeFilter,
			this._servesFilter,
			this._dietFilter,
			this._allergensFilter,
			this._miscFilter,
		];
	}

	toDisplay (values, it) {
		return this._filterBox.toDisplay(
			values,
			it.source,
			it.type,
			it.dishTypes,
			it._fServes,
			it._fDiet,
			it.allergenGroups,
			it._fMisc,
		);
	}

	static _dietToFull (diet) { return PageFilterRecipes$1._DIET_TO_FULL[diet] || diet; }
	static _miscTagToFull (tag) { return PageFilterRecipes$1._MISC_TAG_TO_FULL[tag] || tag; }
};

globalThis.PageFilterRecipes = PageFilterRecipes$1;

let ListSyntaxRecipes$1 = class ListSyntaxRecipes extends ListUiUtil.ListSyntax {
	static _INDEXABLE_PROPS_ENTRIES = [
		"ingredients",
		"instructions",
	];
};

globalThis.ListSyntaxRecipes = ListSyntaxRecipes$1;

"use strict";

let PageFilterRewards$1 = class PageFilterRewards extends PageFilter {
	constructor () {
		super();

		this._typeFilter = new Filter({
			header: "Type",
			items: [
				"Blessing",
				"Boon",
				"Charm",
			],
		});
		this._rarityFilter = new Filter({
			header: "Rarity",
			items: ["unknown", ...Parser.RARITIES],
			itemSortFn: null,
			displayFn: StrUtil.toTitleCase,
		});
	}

	static mutateForFilters (it) {
		it._fRarity = it.rarity || "unknown";
	}

	addToFilters (reward, isExcluded) {
		if (isExcluded) return;

		this._sourceFilter.addItem(reward.source);
		this._typeFilter.addItem(reward.type);
		this._rarityFilter.addItem(reward._fRarity);
	}

	async _pPopulateBoxOptions (opts) {
		opts.filters = [
			this._sourceFilter,
			this._typeFilter,
			this._rarityFilter,
		];
	}

	toDisplay (values, r) {
		return this._filterBox.toDisplay(
			values,
			r.source,
			r.type,
			r._fRarity,
		);
	}
};

globalThis.PageFilterRewards = PageFilterRewards$1;

"use strict";

class VariantClassFilter extends Filter {
	constructor (opts) {
		super({
			header: "Optional/Variant Class",
			nests: {},
			groupFn: it => it.userData.group,
			...opts,
		});

		this._parent = null;
	}

	set parent (multiFilterClasses) { this._parent = multiFilterClasses; }

	handleVariantSplit (isVariantSplit) {
		this.__$wrpFilter.toggleVe(isVariantSplit);
	}
}

class MultiFilterClasses extends MultiFilter {
	constructor (opts) {
		super({header: "Classes", mode: "or", filters: [opts.classFilter, opts.subclassFilter, opts.variantClassFilter], ...opts});

		this._classFilter = opts.classFilter;
		this._subclassFilter = opts.subclassFilter;
		this._variantClassFilter = opts.variantClassFilter;

		this._variantClassFilter.parent = this;
	}

	get classFilter_ () { return this._classFilter; }
	get isVariantSplit () { return this._meta.isVariantSplit; }

	$render (opts) {
		const $out = super.$render(opts);

		const hkVariantSplit = () => this._variantClassFilter.handleVariantSplit(this._meta.isVariantSplit);
		this._addHook("meta", "isVariantSplit", hkVariantSplit);
		hkVariantSplit();

		return $out;
	}

	_getHeaderControls_addExtraStateBtns (opts, wrpStateBtnsOuter) {
		const btnToggleVariantSplit = ComponentUiUtil.getBtnBool(
			this,
			"isVariantSplit",
			{
				ele: e_({tag: "button", clazz: "btn btn-default btn-xs", text: "Include Variants"}),
				isInverted: true,
				stateName: "meta",
				stateProp: "_meta",
				title: `If "Optional/Variant Class" spell lists should be treated as part of the "Class" filter.`,
			},
		);

		e_({
			tag: "div",
			clazz: `btn-group w-100 ve-flex-v-center mobile__m-1 mobile__mb-2`,
			children: [
				btnToggleVariantSplit,
			],
		}).prependTo(wrpStateBtnsOuter);
	}

	getDefaultMeta () {
		return {...MultiFilterClasses._DEFAULT_META, ...super.getDefaultMeta()};
	}
}
MultiFilterClasses._DEFAULT_META = {
	isVariantSplit: false,
};

let PageFilterSpells$1 = class PageFilterSpells extends PageFilter {
		static _META_ADD_CONC = "Concentration";
	static _META_ADD_V = "Verbal";
	static _META_ADD_S = "Somatic";
	static _META_ADD_M = "Material";
	static _META_ADD_R = "Royalty";
	static _META_ADD_M_COST = "Material with Cost";
	static _META_ADD_M_CONSUMED = "Material is Consumed";
	static _META_ADD_M_CONSUMED_OPTIONAL = "Material is Optionally Consumed";

	static F_RNG_POINT = "Point";
	static F_RNG_SELF_AREA = "Self (Area)";
	static F_RNG_SELF = "Self";
	static F_RNG_TOUCH = "Touch";
	static F_RNG_SPECIAL = "Special";

	static _META_FILTER_BASE_ITEMS = [
		this._META_ADD_CONC,
		this._META_ADD_V,
		this._META_ADD_S,
		this._META_ADD_M,
		this._META_ADD_R,
		this._META_ADD_M_COST,
		this._META_ADD_M_CONSUMED,
		this._META_ADD_M_CONSUMED_OPTIONAL,
		...Object.keys(Parser.SP_MISC_TAG_TO_FULL),
	];

	static INCHES_PER_FOOT = 12;
	static FEET_PER_YARD = 3;
	static FEET_PER_MILE = 5280;

		static sortSpells (a, b, o) {
		switch (o.sortBy) {
			case "name": return SortUtil.compareListNames(a, b);
			case "source":
			case "level":
			case "school":
			case "concentration":
			case "ritual": return SortUtil.ascSort(a.values[o.sortBy], b.values[o.sortBy]) || SortUtil.compareListNames(a, b);
			case "time": return SortUtil.ascSort(a.values.normalisedTime, b.values.normalisedTime) || SortUtil.compareListNames(a, b);
			case "range": return SortUtil.ascSort(a.values.normalisedRange, b.values.normalisedRange) || SortUtil.compareListNames(a, b);
		}
	}

	static sortMetaFilter (a, b) {
		const ixA = PageFilterSpells$1._META_FILTER_BASE_ITEMS.indexOf(a.item);
		const ixB = PageFilterSpells$1._META_FILTER_BASE_ITEMS.indexOf(b.item);

		if (~ixA && ~ixB) return ixA - ixB;
		if (~ixA) return -1;
		if (~ixB) return 1;
		return SortUtil.ascSortLower(a, b);
	}

	static getFilterAbilitySave (ability) {
		return `${ability.uppercaseFirst().substring(0, 3)}. Save`;
	}

	static getFilterAbilityCheck (ability) {
		return `${ability.uppercaseFirst().substring(0, 3)}. Check`;
	}

	static getMetaFilterObj (s) {
		const out = [];
		if (s.meta) {
			Object.entries(s.meta)
				.filter(([_, v]) => v)
				.sort(SortUtil.ascSort)
				.forEach(([k]) => out.push(k.toTitleCase()));
		}
		if (s.duration.filter(d => d.concentration).length) {
			out.push(PageFilterSpells$1._META_ADD_CONC);
			s._isConc = true;
		} else s._isConc = false;
		if (s.components && s.components.v) out.push(PageFilterSpells$1._META_ADD_V);
		if (s.components && s.components.s) out.push(PageFilterSpells$1._META_ADD_S);
		if (s.components && s.components.m) out.push(PageFilterSpells$1._META_ADD_M);
		if (s.components && s.components.r) out.push(PageFilterSpells$1._META_ADD_R);
		if (s.components && s.components.m && s.components.m.cost) out.push(PageFilterSpells$1._META_ADD_M_COST);
		if (s.components && s.components.m && s.components.m.consume) {
			if (s.components.m.consume === "optional") out.push(PageFilterSpells$1._META_ADD_M_CONSUMED_OPTIONAL);
			else out.push(PageFilterSpells$1._META_ADD_M_CONSUMED);
		}
		if (s.miscTags) out.push(...s.miscTags);
		if ((!s.miscTags || (s.miscTags && !s.miscTags.includes("PRM"))) && s.duration.filter(it => it.type === "permanent").length) out.push("PRM");
		if ((!s.miscTags || (s.miscTags && !s.miscTags.includes("SCL"))) && s.entriesHigherLevel) out.push("SCL");
		if (s.srd) out.push("SRD");
		if (s.basicRules) out.push("Basic Rules");
		if (s.hasFluff || s.fluff?.entries) out.push("Has Info");
		if (s.hasFluffImages || s.fluff?.images) out.push("Has Images");
		return out;
	}

	static getFilterDuration (spell) {
		const fDur = spell.duration[0] || {type: "special"};
		switch (fDur.type) {
			case "instant": return "Instant";
			case "timed": {
				if (!fDur.duration) return "Special";
				switch (fDur.duration.type) {
					case "turn":
					case "round": return "1 Round";

					case "minute": {
						const amt = fDur.duration.amount || 0;
						if (amt <= 1) return "1 Minute";
						if (amt <= 10) return "10 Minutes";
						if (amt <= 60) return "1 Hour";
						if (amt <= 8 * 60) return "8 Hours";
						return "24+ Hours";
					}

					case "hour": {
						const amt = fDur.duration.amount || 0;
						if (amt <= 1) return "1 Hour";
						if (amt <= 8) return "8 Hours";
						return "24+ Hours";
					}

					case "week":
					case "day":
					case "year": return "24+ Hours";
					default: return "Special";
				}
			}
			case "permanent": return "Permanent";
			case "special":
			default: return "Special";
		}
	}

	static getNormalisedTime (time) {
		const firstTime = time[0];
		let multiplier = 1;
		let offset = 0;
		switch (firstTime.unit) {
			case Parser.SP_TM_B_ACTION: offset = 1; break;
			case Parser.SP_TM_REACTION: offset = 2; break;
			case Parser.SP_TM_ROUND: multiplier = 6; break;
			case Parser.SP_TM_MINS: multiplier = 60; break;
			case Parser.SP_TM_HRS: multiplier = 3600; break;
		}
		if (time.length > 1) offset += 0.5;
		return (multiplier * firstTime.number) + offset;
	}

	static getNormalisedRange (range) {
		const state = {
			multiplier: 1,
			distance: 0,
			offset: 0,
		};

		switch (range.type) {
			case Parser.RNG_SPECIAL: return 1000000000;
			case Parser.RNG_POINT: this._getNormalisedRange_getAdjustedForDistance({range, state}); break;
			case Parser.RNG_LINE: state.offset = 1; this._getNormalisedRange_getAdjustedForDistance({range, state}); break;
			case Parser.RNG_CONE: state.offset = 2; this._getNormalisedRange_getAdjustedForDistance({range, state}); break;
			case Parser.RNG_RADIUS: state.offset = 3; this._getNormalisedRange_getAdjustedForDistance({range, state}); break;
			case Parser.RNG_HEMISPHERE: state.offset = 4; this._getNormalisedRange_getAdjustedForDistance({range, state}); break;
			case Parser.RNG_SPHERE: state.offset = 5; this._getNormalisedRange_getAdjustedForDistance({range, state}); break;
			case Parser.RNG_CYLINDER: state.offset = 6; this._getNormalisedRange_getAdjustedForDistance({range, state}); break;
			case Parser.RNG_CUBE: state.offset = 7; this._getNormalisedRange_getAdjustedForDistance({range, state}); break;
		}

				return (state.multiplier * state.distance) + state.offset;
	}

	static _getNormalisedRange_getAdjustedForDistance ({range, state}) {
		const dist = range.distance;
		switch (dist.type) {
			case Parser.UNT_FEET: state.multiplier = PageFilterSpells$1.INCHES_PER_FOOT; state.distance = dist.amount; break;
			case Parser.UNT_YARDS: state.multiplier = PageFilterSpells$1.INCHES_PER_FOOT * PageFilterSpells$1.FEET_PER_YARD; state.distance = dist.amount; break;
			case Parser.UNT_MILES: state.multiplier = PageFilterSpells$1.INCHES_PER_FOOT * PageFilterSpells$1.FEET_PER_MILE; state.distance = dist.amount; break;
			case Parser.RNG_SELF: state.distance = 0; break;
			case Parser.RNG_TOUCH: state.distance = 1; break;
			case Parser.RNG_SIGHT: state.multiplier = PageFilterSpells$1.INCHES_PER_FOOT * PageFilterSpells$1.FEET_PER_MILE; state.distance = 12; break; 			case Parser.RNG_UNLIMITED_SAME_PLANE: state.distance = 900000000; break; 			case Parser.RNG_UNLIMITED: state.distance = 900000001; break;
			default: {
								this._getNormalisedRange_getAdjustedForDistance_prereleaseBrew({range, state, brewUtil: PrereleaseUtil})
					|| this._getNormalisedRange_getAdjustedForDistance_prereleaseBrew({range, state, brewUtil: BrewUtil2});
			}
		}
	}

	static _getNormalisedRange_getAdjustedForDistance_prereleaseBrew ({range, state, brewUtil}) {
		const dist = range.distance;
		const fromBrew = brewUtil.getMetaLookup("spellDistanceUnits")?.[dist.type];
		if (!fromBrew) return false;

		const ftPerUnit = fromBrew.feetPerUnit;
		if (ftPerUnit != null) {
			state.multiplier = PageFilterSpells$1.INCHES_PER_FOOT * ftPerUnit;
			state.distance = dist.amount;
		} else {
			state.distance = 910000000; 		}

		return true;
	}

	static getFltrSpellLevelStr (level) {
		return level === 0 ? Parser.spLevelToFull(level) : `${Parser.spLevelToFull(level)} level`;
	}

	static getRangeType (range) {
		switch (range.type) {
			case Parser.RNG_SPECIAL: return PageFilterSpells$1.F_RNG_SPECIAL;
			case Parser.RNG_POINT:
				switch (range.distance.type) {
					case Parser.RNG_SELF: return PageFilterSpells$1.F_RNG_SELF;
					case Parser.RNG_TOUCH: return PageFilterSpells$1.F_RNG_TOUCH;
					default: return PageFilterSpells$1.F_RNG_POINT;
				}
			case Parser.RNG_LINE:
			case Parser.RNG_CONE:
			case Parser.RNG_RADIUS:
			case Parser.RNG_HEMISPHERE:
			case Parser.RNG_SPHERE:
			case Parser.RNG_CYLINDER:
			case Parser.RNG_CUBE:
				return PageFilterSpells$1.F_RNG_SELF_AREA;
		}
	}

	static getTblTimeStr (time) {
		return (time.number === 1 && Parser.SP_TIME_SINGLETONS.includes(time.unit))
			? `${time.unit.uppercaseFirst()}`
			: `${time.number ? `${time.number} ` : ""}${Parser.spTimeUnitToShort(time.unit).uppercaseFirst()}`;
	}

	static getTblLevelStr (spell) { return `${Parser.spLevelToFull(spell.level)}${spell.meta && spell.meta.ritual ? " (rit.)" : ""}${spell.meta && spell.meta.technomagic ? " (tec.)" : ""}`; }

	static getRaceFilterItem (r) {
		const addSuffix = (
			r.source === Parser.SRC_DMG
			|| SourceUtil.isNonstandardSource(r.source || Parser.SRC_PHB)
			|| (typeof PrereleaseUtil !== "undefined" && PrereleaseUtil.hasSourceJson(r.source || Parser.SRC_PHB))
			|| (typeof BrewUtil2 !== "undefined" && BrewUtil2.hasSourceJson(r.source || Parser.SRC_PHB))
		) && !r.name.includes(Parser.sourceJsonToAbv(r.source));
		const name = `${r.name}${addSuffix ? ` (${Parser.sourceJsonToAbv(r.source)})` : ""}`;
		const opts = {
			item: name,
			userData: {
				group: SourceUtil.getFilterGroup(r.source || Parser.SRC_PHB),
			},
		};
		if (r.baseName) opts.nest = r.baseName;
		else opts.nest = "(No Subraces)";
		return new FilterItem(opts);
	}
	
	constructor () {
		super();

		this._classFilter = new Filter({
			header: "Class",
			groupFn: it => it.userData.group,
		});
		this._subclassFilter = new Filter({
			header: "Subclass",
			nests: {},
			groupFn: it => it.userData.group,
		});
		this._levelFilter = new Filter({
			header: "Level",
			items: [
				0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
			],
			displayFn: PageFilterSpells$1.getFltrSpellLevelStr,
		});
		this._variantClassFilter = new VariantClassFilter();
		this._classAndSubclassFilter = new MultiFilterClasses({
			classFilter: this._classFilter,
			subclassFilter: this._subclassFilter,
			variantClassFilter: this._variantClassFilter,
		});
		this._raceFilter = new Filter({
			header: "Race",
			nests: {},
			groupFn: it => it.userData.group,
		});
		this._backgroundFilter = new SearchableFilter({header: "Background"});
		this._featFilter = new SearchableFilter({header: "Feat"});
		this._optionalfeaturesFilter = new SearchableFilter({header: "Other Option/Feature"});
		this._metaFilter = new Filter({
			header: "Components & Miscellaneous",
			items: [...PageFilterSpells$1._META_FILTER_BASE_ITEMS, "Ritual", "SRD", "Basic Rules", "Has Images", "Has Token"],
			itemSortFn: PageFilterSpells$1.sortMetaFilter,
			isMiscFilter: true,
			displayFn: it => Parser.spMiscTagToFull(it),
		});
		this._groupFilter = new Filter({header: "Group"});
		this._schoolFilter = new Filter({
			header: "School",
			items: [...Parser.SKL_ABVS],
			displayFn: Parser.spSchoolAbvToFull,
			itemSortFn: (a, b) => SortUtil.ascSortLower(Parser.spSchoolAbvToFull(a.item), Parser.spSchoolAbvToFull(b.item)),
		});
		this._subSchoolFilter = new Filter({
			header: "Subschool",
			items: [],
			displayFn: Parser.spSchoolAbvToFull,
		});
		this._damageFilter = new Filter({
			header: "Damage Type",
			items: MiscUtil.copy(Parser.DMG_TYPES),
			displayFn: StrUtil.uppercaseFirst,
		});
		this._conditionFilter = new Filter({
			header: "Conditions Inflicted",
			items: [...Parser.CONDITIONS],
			displayFn: uid => uid.split("|")[0].toTitleCase(),
		});
		this._spellAttackFilter = new Filter({
			header: "Spell Attack",
			items: ["M", "R", "O"],
			displayFn: Parser.spAttackTypeToFull,
			itemSortFn: null,
		});
		this._saveFilter = new Filter({
			header: "Saving Throw",
			items: ["strength", "dexterity", "constitution", "intelligence", "wisdom", "charisma"],
			displayFn: PageFilterSpells$1.getFilterAbilitySave,
			itemSortFn: null,
		});
		this._checkFilter = new Filter({
			header: "Ability Check",
			items: ["strength", "dexterity", "constitution", "intelligence", "wisdom", "charisma"],
			displayFn: PageFilterSpells$1.getFilterAbilityCheck,
			itemSortFn: null,
		});
		this._timeFilter = new Filter({
			header: "Cast Time",
			items: [
				Parser.SP_TM_ACTION,
				Parser.SP_TM_B_ACTION,
				Parser.SP_TM_REACTION,
				Parser.SP_TM_ROUND,
				Parser.SP_TM_MINS,
				Parser.SP_TM_HRS,
			],
			displayFn: Parser.spTimeUnitToFull,
			itemSortFn: null,
		});
		this._durationFilter = new RangeFilter({
			header: "Duration",
			isLabelled: true,
			labelSortFn: null,
			labels: ["Instant", "1 Round", "1 Minute", "10 Minutes", "1 Hour", "8 Hours", "24+ Hours", "Permanent", "Special"],
		});
		this._rangeFilter = new Filter({
			header: "Range",
			items: [
				PageFilterSpells$1.F_RNG_SELF,
				PageFilterSpells$1.F_RNG_TOUCH,
				PageFilterSpells$1.F_RNG_POINT,
				PageFilterSpells$1.F_RNG_SELF_AREA,
				PageFilterSpells$1.F_RNG_SPECIAL,
			],
			itemSortFn: null,
		});
		this._areaTypeFilter = new Filter({
			header: "Area Style",
			items: ["ST", "MT", "R", "N", "C", "Y", "H", "L", "S", "Q", "W"],
			displayFn: Parser.spAreaTypeToFull,
			itemSortFn: null,
		});
		this._affectsCreatureTypeFilter = new Filter({
			header: "Affects Creature Types",
			items: [...Parser.MON_TYPES],
			displayFn: StrUtil.toTitleCase,
		});
	}

	static mutateForFilters (s) {
		Renderer.spell.initBrewSources(s);

				s._normalisedTime = PageFilterSpells$1.getNormalisedTime(s.time);
		s._normalisedRange = PageFilterSpells$1.getNormalisedRange(s.range);

				s._fSources = SourceFilter.getCompleteFilterSources(s);
		s._fMeta = PageFilterSpells$1.getMetaFilterObj(s);
		s._fClasses = Renderer.spell.getCombinedClasses(s, "fromClassList").map(c => {
			return this._getClassFilterItem({
				className: c.name,
				definedInSource: c.definedInSource,
				classSource: c.source,
				isVariantClass: false,
			});
		});
		s._fSubclasses = Renderer.spell.getCombinedClasses(s, "fromSubclass")
			.map(c => {
				return this._getSubclassFilterItem({
					className: c.class.name,
					classSource: c.class.source,
					subclassName: c.subclass.name,
					subclassShortName: c.subclass.shortName,
					subclassSource: c.subclass.source,
					subSubclassName: c.subclass.subSubclass,
				});
			});
		s._fVariantClasses = Renderer.spell.getCombinedClasses(s, "fromClassListVariant").map(c => {
			return this._getClassFilterItem({
				className: c.name,
				definedInSource: c.definedInSource,
				classSource: c.source,
				isVariantClass: true,
			});
		});
		s._fClassesAndVariantClasses = [
			...s._fClasses,
			...s._fVariantClasses
				.map(it => (it.userData.definedInSource && !SourceUtil.isNonstandardSource(it.userData.definedInSource)) ? new FilterItem({item: it.userData.equivalentClassName}) : null)
				.filter(Boolean)
				.filter(it => !s._fClasses.some(itCls => itCls.item === it.item)),
		];
		s._fRaces = Renderer.spell.getCombinedGeneric(s, {propSpell: "races", prop: "race"}).map(PageFilterSpells$1.getRaceFilterItem);
		s._fBackgrounds = Renderer.spell.getCombinedGeneric(s, {propSpell: "backgrounds", prop: "background"}).map(it => it.name);
		s._fFeats = Renderer.spell.getCombinedGeneric(s, {propSpell: "feats", prop: "feat"}).map(it => it.name);
		s._fOptionalfeatures = Renderer.spell.getCombinedGeneric(s, {propSpell: "optionalfeatures", prop: "optionalfeature"}).map(it => it.name);
		s._fGroups = Renderer.spell.getCombinedGeneric(s, {propSpell: "groups"}).map(it => it.name);
		s._fTimeType = s.time.map(t => t.unit);
		s._fDurationType = PageFilterSpells$1.getFilterDuration(s);
		s._fRangeType = PageFilterSpells$1.getRangeType(s.range);

		s._fAreaTags = [...(s.areaTags || [])];
		if (s.range.type === "line" && !s._fAreaTags.includes("L")) s._fAreaTags.push("L");

		s._fAffectsCreatureType = s.affectsCreatureType || [...Parser.MON_TYPES];
	}

	static unmutateForFilters (s) {
		Renderer.spell.uninitBrewSources(s);

		delete s._normalisedTime;
		delete s._normalisedRange;

		Object.keys(s)
			.filter(it => it.startsWith("_f"))
			.forEach(it => delete s[it]);
	}

	addToFilters (s, isExcluded) {
		if (isExcluded) return;

		if (s.level > 9) this._levelFilter.addItem(s.level);
		this._groupFilter.addItem(s._fGroups);
		this._schoolFilter.addItem(s.school);
		this._sourceFilter.addItem(s._fSources);
		this._metaFilter.addItem(s._fMeta);
		this._backgroundFilter.addItem(s._fBackgrounds);
		this._featFilter.addItem(s._fFeats);
		this._optionalfeaturesFilter.addItem(s._fOptionalfeatures);
		s._fClasses.forEach(c => this._classFilter.addItem(c));
		s._fSubclasses.forEach(sc => {
			this._subclassFilter.addNest(sc.nest, {isHidden: true});
			this._subclassFilter.addItem(sc);
		});
		s._fRaces.forEach(r => {
			if (r.nest) this._raceFilter.addNest(r.nest, {isHidden: true});
			this._raceFilter.addItem(r);
		});
		s._fVariantClasses.forEach(c => {
			this._variantClassFilter.addNest(c.nest, {isHidden: true});
			this._variantClassFilter.addItem(c);
		});
		this._subSchoolFilter.addItem(s.subschools);
		this._conditionFilter.addItem(s.conditionInflict);
		this._affectsCreatureTypeFilter.addItem(s.affectsCreatureType);
	}

	async _pPopulateBoxOptions (opts) {
		await SourceUtil.pInitSubclassReprintLookup();

		opts.filters = [
			this._sourceFilter,
			this._levelFilter,
			this._classAndSubclassFilter,
			this._raceFilter,
			this._backgroundFilter,
			this._featFilter,
			this._optionalfeaturesFilter,
			this._metaFilter,
			this._groupFilter,
			this._schoolFilter,
			this._subSchoolFilter,
			this._damageFilter,
			this._conditionFilter,
			this._spellAttackFilter,
			this._saveFilter,
			this._checkFilter,
			this._timeFilter,
			this._durationFilter,
			this._rangeFilter,
			this._areaTypeFilter,
			this._affectsCreatureTypeFilter,
		];
	}

	toDisplay (values, s) {
		return this._filterBox.toDisplay(
			values,
			s._fSources,
			s.level,
			[
				this._classAndSubclassFilter.isVariantSplit ? s._fClasses : s._fClassesAndVariantClasses,
				s._fSubclasses,
				this._classAndSubclassFilter.isVariantSplit ? s._fVariantClasses : null,
			],
			s._fRaces,
			s._fBackgrounds,
			s._fFeats,
			s._fOptionalfeatures,
			s._fMeta,
			s._fGroups,
			s.school,
			s.subschools,
			s.damageInflict,
			s.conditionInflict,
			s.spellAttack,
			s.savingThrow,
			s.abilityCheck,
			s._fTimeType,
			s._fDurationType,
			s._fRangeType,
			s._fAreaTags,
			s._fAffectsCreatureType,
		);
	}
};

globalThis.PageFilterSpells = PageFilterSpells$1;

let ModalFilterSpells$1 = class ModalFilterSpells extends ModalFilter {
		constructor (opts) {
		opts = opts || {};
		super({
			...opts,
			modalTitle: `Spell${opts.isRadio ? "" : "s"}`,
			pageFilter: new PageFilterSpells$1(),
			fnSort: PageFilterSpells$1.sortSpells,
		});
	}

	_$getColumnHeaders () {
		const btnMeta = [
			{sort: "name", text: "Name", width: "3"},
			{sort: "level", text: "Level", width: "1-5"},
			{sort: "time", text: "Time", width: "2"},
			{sort: "school", text: "School", width: "1"},
			{sort: "concentration", text: "C.", title: "Concentration", width: "0-5"},
			{sort: "range", text: "Range", width: "2"},
			{sort: "source", text: "Source", width: "1"},
		];
		return ModalFilter._$getFilterColumnHeaders(btnMeta);
	}

	async _pInit () {
		if (typeof PrereleaseUtil !== "undefined") Renderer.spell.populatePrereleaseLookup(await PrereleaseUtil.pGetBrewProcessed());
		if (typeof BrewUtil2 !== "undefined") Renderer.spell.populateBrewLookup(await BrewUtil2.pGetBrewProcessed());
	}

	async _pLoadAllData () {
		return [
			...(await DataUtil.spell.pLoadAll()),
			...((await PrereleaseUtil.pGetBrewProcessed()).spell || []),
			...((await BrewUtil2.pGetBrewProcessed()).spell || []),
		];
	}

	_getListItem (pageFilter, spell, spI) {
		const eleRow = document.createElement("div");
		eleRow.className = "px-0 w-100 ve-flex-col no-shrink";

		const hash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_SPELLS](spell);
		const source = Parser.sourceJsonToAbv(spell.source);
		const levelText = PageFilterSpells$1.getTblLevelStr(spell);
		const time = PageFilterSpells$1.getTblTimeStr(spell.time[0]);
		const school = Parser.spSchoolAndSubschoolsAbvsShort(spell.school, spell.subschools);
		const concentration = spell._isConc ? "×" : "";
		const range = Parser.spRangeToFull(spell.range);

		eleRow.innerHTML = `<div class="w-100 ve-flex-vh-center lst--border veapp__list-row no-select lst__wrp-cells">
			<div class="col-0-5 pl-0 ve-flex-vh-center">${this._isRadio ? `<input type="radio" name="radio" class="no-events">` : `<input type="checkbox" class="no-events">`}</div>

			<div class="col-0-5 px-1 ve-flex-vh-center">
				<div class="ui-list__btn-inline px-2" title="Toggle Preview (SHIFT to Toggle Info Preview)">[+]</div>
			</div>

			<div class="col-3 ${spell._versionBase_isVersion ? "italic" : ""} ${this._getNameStyle()}">${spell._versionBase_isVersion ? `<span class="px-3"></span>` : ""}${spell.name}</div>
			<div class="col-1-5 text-center">${levelText}</div>
			<div class="col-2 text-center">${time}</div>
			<div class="col-1 sp__school-${spell.school} text-center" title="${Parser.spSchoolAndSubschoolsAbvsToFull(spell.school, spell.subschools)}" ${Parser.spSchoolAbvToStyle(spell.school)}>${school}</div>
			<div class="col-0-5 text-center" title="Concentration">${concentration}</div>
			<div class="col-2 text-right">${range}</div>
			<div class="col-1 pr-0 text-center ${Parser.sourceJsonToColor(spell.source)}" title="${Parser.sourceJsonToFull(spell.source)}" ${Parser.sourceJsonToStyle(spell.source)}>${source}</div>
		</div>`;

		const btnShowHidePreview = eleRow.firstElementChild.children[1].firstElementChild;

		const listItem = new ListItem(
			spI,
			eleRow,
			spell.name,
			{
				hash,
				source,
				sourceJson: spell.source,
				level: spell.level,
				time,
				school: Parser.spSchoolAbvToFull(spell.school),
				classes: Parser.spClassesToFull(spell, {isTextOnly: true}),
				concentration,
				normalisedTime: spell._normalisedTime,
				normalisedRange: spell._normalisedRange,
			},
			{
				cbSel: eleRow.firstElementChild.firstElementChild.firstElementChild,
				btnShowHidePreview,
			},
		);

		ListUiUtil.bindPreviewButton(UrlUtil.PG_SPELLS, this._allData, listItem, btnShowHidePreview);

		return listItem;
	}
};

globalThis.ModalFilterSpells = ModalFilterSpells$1;

let ListSyntaxSpells$1 = class ListSyntaxSpells extends ListUiUtil.ListSyntax {
	static _INDEXABLE_PROPS_ENTRIES = [
		"entries",
		"entriesHigherLevel",
	];
};

globalThis.ListSyntaxSpells = ListSyntaxSpells$1;

globalThis.PageFilterSpells = PageFilterSpells$1;

"use strict";

let PageFilterTables$1 = class PageFilterTables extends PageFilter {
		static _sourceSelFn (val) {
		return !SourceUtil.isNonstandardSource(val) && !SourceUtil.isAdventure(val);
	}
	
	constructor () {
		super({sourceFilterOpts: {selFn: PageFilterTables$1._sourceSelFn}});

		this._miscFilter = new Filter({header: "Miscellaneous", items: ["SRD", "Basic Rules"], isMiscFilter: true});
	}

	static mutateForFilters (it) {
		it._fMisc = it.srd ? ["SRD"] : [];
		if (it.basicRules) it._fMisc.push("Basic Rules");
	}

	addToFilters (it, isExcluded) {
		if (isExcluded) return;

		this._sourceFilter.addItem(it.source);
	}

	async _pPopulateBoxOptions (opts) {
		opts.filters = [
			this._sourceFilter,
			this._miscFilter,
		];
	}

	toDisplay (values, it) {
		return this._filterBox.toDisplay(
			values,
			it.source,
			it._fMisc,
		);
	}
};

globalThis.PageFilterTables = PageFilterTables$1;

let ListSyntaxTables$1 = class ListSyntaxTables extends ListUiUtil.ListSyntax {
	static _INDEXABLE_PROPS_ENTRIES = [
		"rows",
		"tables",
	];
};

globalThis.ListSyntaxTables = ListSyntaxTables$1;

"use strict";

let PageFilterTrapsHazards$1 = class PageFilterTrapsHazards extends PageFilter {
		static sortFilterType (a, b) {
		return SortUtil.ascSortLower(Parser.trapHazTypeToFull(a.item), Parser.trapHazTypeToFull(b.item));
	}
	
	constructor () {
		super();

		this._typeFilter = new Filter({
			header: "Type",
			items: [
				"MECH",
				"MAG",
				"SMPL",
				"CMPX",
				"HAZ",
				"WTH",
				"ENV",
				"WLD",
				"GEN",
			],
			displayFn: Parser.trapHazTypeToFull,
			itemSortFn: PageFilterTrapsHazards$1.sortFilterType.bind(PageFilterTrapsHazards$1),
		});
	}

	static mutateForFilters (it) {
		it.trapHazType = it.trapHazType || "HAZ";
	}

	addToFilters (it, isExcluded) {
		if (isExcluded) return;

		this._sourceFilter.addItem(it.source);
		this._typeFilter.addItem(it.trapHazType);
	}

	async _pPopulateBoxOptions (opts) {
		opts.filters = [
			this._sourceFilter,
			this._typeFilter,
		];
	}

	toDisplay (values, it) {
		return this._filterBox.toDisplay(
			values,
			it.source,
			it.trapHazType,
		);
	}
};

globalThis.PageFilterTrapsHazards = PageFilterTrapsHazards$1;

let ListSyntaxTrapsHazards$1 = class ListSyntaxTrapsHazards extends ListUiUtil.ListSyntax {
	static _INDEXABLE_PROPS_ENTRIES = [
		"effect",
		"trigger",
		"countermeasures",
		"entries",
	];
};

globalThis.ListSyntaxTrapsHazards = ListSyntaxTrapsHazards$1;

"use strict";

let PageFilterVariantRules$1 = class PageFilterVariantRules extends PageFilter {
		
	constructor () {
		super();

		this._ruleTypeFilter = new Filter({header: "Rule Type", items: ["O", "V", "VO", "VV", "U"], displayFn: Parser.ruleTypeToFull});
		this._miscFilter = new Filter({header: "Miscellaneous", items: ["SRD"], isMiscFilter: true});
	}

	static mutateForFilters (rule) {
		rule._fMisc = rule.srd ? ["SRD"] : [];
		rule._fRuleType = rule.ruleType || "U";
	}

	addToFilters (rule, isExcluded) {
		if (isExcluded) return;

		this._sourceFilter.addItem(rule.source);
		this._ruleTypeFilter.addItem(rule._fRuleType);
	}

	async _pPopulateBoxOptions (opts) {
		opts.filters = [
			this._sourceFilter,
			this._ruleTypeFilter,
			this._miscFilter,
		];
	}

	toDisplay (values, r) {
		return this._filterBox.toDisplay(
			values,
			r.source,
			r._fRuleType,
			r._fMisc,
		);
	}
};

globalThis.PageFilterVariantRules = PageFilterVariantRules$1;

"use strict";

let PageFilterVehicles$1 = class PageFilterVehicles extends PageFilter {
	constructor () {
		super();

		this._vehicleTypeFilter = new Filter({
			header: "Vehicle Type",
			items: [],
			displayFn: Parser.vehicleTypeToFull,
			isSortByDisplayItems: true,
		});
		this._upgradeTypeFilter = new Filter({
			header: "Upgrade Type",
			items: [],
			displayFn: Parser.vehicleTypeToFull,
			isSortByDisplayItems: true,
		});
		this._terrainFilter = new Filter({header: "Terrain", items: ["land", "sea", "air"], displayFn: StrUtil.uppercaseFirst});
		this._speedFilter = new RangeFilter({header: "Speed"});
		this._acFilter = new RangeFilter({header: "Armor Class"});
		this._hpFilter = new RangeFilter({header: "Hit Points"});
		this._hpFilter = new RangeFilter({header: "Hit Points"});
		this._creatureCapacityFilter = new RangeFilter({header: "Creature Capacity"});
		this._miscFilter = new Filter({header: "Miscellaneous", items: ["SRD", "Has Images", "Has Info", "Has Token"], isMiscFilter: true});
	}

	static mutateForFilters (it) {
		it._fSpeed = 0;
		if (typeof it.speed === "number" && it.speed > 0) {
			it._fSpeed = it.speed;
		} else if (it.speed) {
			const maxSpeed = Math.max(...Object.values(it.speed));
			if (maxSpeed > 0) it._fSpeed = maxSpeed;
		} else if (it.pace && typeof it.pace === "number") {
			it._fSpeed = it.pace * 10; 		}

		it._fHp = 0;
		if (it.hp && it.hp.hp != null) {
			it._fHp = it.hp.hp;
		} else if (it.hull && it.hull.hp != null) {
			it._fHp = it.hull.hp;
		} else if (it.hp && it.hp.average != null) {
			it._fHp = it.hp.average;
		}

		it._fAc = 0;
		if (it.hull && it.hull.ac != null) {
			it._fAc = it.hull.ac;
		} else if (it.vehicleType === "INFWAR") {
			it._fAc = 19 + Parser.getAbilityModNumber(it.dex == null ? 10 : it.dex);
		} else if (it.ac instanceof Array) {
			it._fAc = it.ac.map(it => it.special ? null : (it.ac || it)).filter(it => it !== null);
		} else if (it.ac) {
			it._fAc = it.ac;
		}

		it._fCreatureCapacity = (it.capCrew || 0) + (it.capPassenger || 0) + (it.capCreature || 0);

		it._fMisc = it.srd ? ["SRD"] : [];
		if (it.tokenUrl || it.hasToken) it._fMisc.push("Has Token");
		if (it.hasFluff || it.fluff?.entries) it._fMisc.push("Has Info");
		if (it.hasFluffImages || it.fluff?.images) it._fMisc.push("Has Images");
	}

	addToFilters (it, isExcluded) {
		if (isExcluded) return;

		this._sourceFilter.addItem(it.source);
		this._vehicleTypeFilter.addItem(it.vehicleType);
		this._upgradeTypeFilter.addItem(it.upgradeType);
		this._speedFilter.addItem(it._fSpeed);
		this._terrainFilter.addItem(it.terrain);
		this._acFilter.addItem(it._fAc);
		this._hpFilter.addItem(it._fHp);
		this._creatureCapacityFilter.addItem(it._fCreatureCapacity);
	}

	async _pPopulateBoxOptions (opts) {
		opts.filters = [
			this._sourceFilter,
			this._vehicleTypeFilter,
			this._upgradeTypeFilter,
			this._terrainFilter,
			this._speedFilter,
			this._acFilter,
			this._hpFilter,
			this._creatureCapacityFilter,
			this._miscFilter,
		];
	}

	toDisplay (values, it) {
		return this._filterBox.toDisplay(
			values,
			it.source,
			it.vehicleType,
			it.upgradeType,
			it.terrain,
			it._fSpeed,
			it._fAc,
			it._fHp,
			it._fCreatureCapacity,
			it._fMisc,
		);
	}
};

globalThis.PageFilterVehicles = PageFilterVehicles$1;

let ListSyntaxVehicles$1 = class ListSyntaxVehicles extends ListUiUtil.ListSyntax {
	static _INDEXABLE_PROPS_ENTRIES = [
		"control",
		"movement",
		"weapon",
		"other",
		"entries",

		"actionStation",

		"action",
		"trait",
		"reaction",
	];
};

globalThis.ListSyntaxVehicles = ListSyntaxVehicles$1;

"use strict";

let ListItem$1 = class ListItem {
		constructor (ix, ele, name, values, data) {
		this.ix = ix;
		this.ele = ele;
		this.name = name;
		this.values = values || {};
		this.data = data || {};

		this.searchText = null;
		this.mutRegenSearchText();

		this._isSelected = false;
	}

	mutRegenSearchText () {
		let searchText = `${this.name} - `;
		for (const k in this.values) {
			const v = this.values[k]; 			if (!v) continue;
			searchText += `${v} - `;
		}
		this.searchText = searchText.toAscii().toLowerCase();
	}

	set isSelected (val) {
		if (this._isSelected === val) return;
		this._isSelected = val;

		if (this.ele instanceof $) {
			if (this._isSelected) this.ele.addClass("list-multi-selected");
			else this.ele.removeClass("list-multi-selected");
		} else {
			if (this._isSelected) this.ele.classList.add("list-multi-selected");
			else this.ele.classList.remove("list-multi-selected");
		}
	}

	get isSelected () { return this._isSelected; }
};

class _ListSearch {
	#isInterrupted = false;

	#term = null;
	#fn = null;
	#items = null;

	constructor ({term, fn, items}) {
		this.#term = term;
		this.#fn = fn;
		this.#items = [...items];
	}

	interrupt () { this.#isInterrupted = true; }

	async pRun () {
		const out = [];
		for (const item of this.#items) {
			if (this.#isInterrupted) break;
			if (await this.#fn(item, this.#term)) out.push(item);
		}
		return {isInterrupted: this.#isInterrupted, searchedItems: out};
	}
}

let List$1 = class List {
	#activeSearch = null;

		constructor (opts) {
		if (opts.fnSearch && opts.isFuzzy) throw new Error(`The options "fnSearch" and "isFuzzy" are mutually incompatible!`);

		this._$iptSearch = opts.$iptSearch;
		this._$wrpList = opts.$wrpList;
		this._fnSort = opts.fnSort === undefined ? SortUtil.listSort : opts.fnSort;
		this._fnSearch = opts.fnSearch;
		this._syntax = opts.syntax;
		this._isFuzzy = !!opts.isFuzzy;
		this._isSkipSearchKeybindingEnter = !!opts.isSkipSearchKeybindingEnter;
		this._helpText = opts.helpText;

		this._items = [];
		this._eventHandlers = {};

		this._searchTerm = List$1._DEFAULTS.searchTerm;
		this._sortBy = opts.sortByInitial || List$1._DEFAULTS.sortBy;
		this._sortDir = opts.sortDirInitial || List$1._DEFAULTS.sortDir;
		this._sortByInitial = this._sortBy;
		this._sortDirInitial = this._sortDir;
		this._fnFilter = null;
		this._isUseJquery = opts.isUseJquery;

		if (this._isFuzzy) this._initFuzzySearch();

		this._searchedItems = [];
		this._filteredItems = [];
		this._sortedItems = [];

		this._isInit = false;
		this._isDirty = false;

				this._prevList = null;
		this._nextList = null;
		this._lastSelection = null;
		this._isMultiSelection = false;
			}

	get items () { return this._items; }
	get visibleItems () { return this._sortedItems; }
	get sortBy () { return this._sortBy; }
	get sortDir () { return this._sortDir; }
	set nextList (list) { this._nextList = list; }
	set prevList (list) { this._prevList = list; }

	setFnSearch (fn) {
		this._fnSearch = fn;
		this._isDirty = true;
	}

	init () {
		if (this._isInit) return;

				if (this._$iptSearch) {
			UiUtil.bindTypingEnd({$ipt: this._$iptSearch, fnKeyup: () => this.search(this._$iptSearch.val())});
			this._searchTerm = List$1.getCleanSearchTerm(this._$iptSearch.val());
			this._init_bindKeydowns();

						const helpText = [
				...(this._helpText || []),
				...Object.values(this._syntax || {})
					.filter(({help}) => help)
					.map(({help}) => help),
			];

			if (helpText.length) this._$iptSearch.title(helpText.join(" "));
					}

		this._doSearch();
		this._isInit = true;
	}

	_init_bindKeydowns () {
		this._$iptSearch
			.on("keydown", evt => {
								if (evt._List__isHandled) return;

				switch (evt.key) {
					case "Escape": return this._handleKeydown_escape(evt);
					case "Enter": return this._handleKeydown_enter(evt);
				}
			});
	}

	_handleKeydown_escape (evt) {
		evt._List__isHandled = true;

		if (!this._$iptSearch.val()) {
			$(document.activeElement).blur();
			return;
		}

		this._$iptSearch.val("");
		this.search("");
	}

	_handleKeydown_enter (evt) {
		if (this._isSkipSearchKeybindingEnter) return;

		if (IS_VTT) return;
		if (!EventUtil.noModifierKeys(evt)) return;

		const firstVisibleItem = this.visibleItems[0];
		if (!firstVisibleItem) return;

		evt._List__isHandled = true;

		$(firstVisibleItem.ele).click();
		if (firstVisibleItem.values.hash) window.location.hash = firstVisibleItem.values.hash;
	}

	_initFuzzySearch () {
		elasticlunr.clearStopWords();
		this._fuzzySearch = elasticlunr(function () {
			this.addField("s");
			this.setRef("ix");
		});
		SearchUtil.removeStemmer(this._fuzzySearch);
	}

	update ({isForce = false} = {}) {
		if (!this._isInit || !this._isDirty || isForce) return;
		return this._doSearch();
	}

	_doSearch () {
		this._doSearch_doInterruptExistingSearch();
		this._doSearch_doSearchTerm();
		this._doSearch_doPostSearchTerm();
	}

	_doSearch_doInterruptExistingSearch () {
		if (!this.#activeSearch) return;
		this.#activeSearch.interrupt();
		this.#activeSearch = null;
	}

	_doSearch_doSearchTerm () {
		if (this._doSearch_doSearchTerm_preSyntax()) return;

		const matchingSyntax = this._doSearch_getMatchingSyntax();
		if (matchingSyntax) {
			if (this._doSearch_doSearchTerm_syntax(matchingSyntax)) return;

						this._searchedItems = [];
			this._doSearch_doSearchTerm_pSyntax(matchingSyntax)
				.then(isContinue => {
					if (!isContinue) return;
					this._doSearch_doPostSearchTerm();
				});

			return;
		}

		if (this._isFuzzy) return this._searchedItems = this._doSearch_doSearchTerm_fuzzy();

		if (this._fnSearch) return this._searchedItems = this._items.filter(it => this._fnSearch(it, this._searchTerm));

		this._searchedItems = this._items.filter(it => this.constructor.isVisibleDefaultSearch(it, this._searchTerm));
	}

	_doSearch_doSearchTerm_preSyntax () {
		if (!this._searchTerm && !this._fnSearch) {
			this._searchedItems = [...this._items];
			return true;
		}
	}

	_doSearch_getMatchingSyntax () {
		const [command, term] = this._searchTerm.split(/^([a-z]+):/).filter(Boolean);
		if (!command || !term || !this._syntax?.[command]) return null;
		return {term: this._doSearch_getSyntaxSearchTerm(term), syntax: this._syntax[command]};
	}

	_doSearch_getSyntaxSearchTerm (term) {
		if (!term.startsWith("/") || !term.endsWith("/")) return term;
		try {
			return new RegExp(term.slice(1, -1));
		} catch (ignored) {
			return term;
		}
	}

	_doSearch_doSearchTerm_syntax ({term, syntax: {fn, isAsync}}) {
		if (isAsync) return false;

		this._searchedItems = this._items.filter(it => fn(it, term));
		return true;
	}

	async _doSearch_doSearchTerm_pSyntax ({term, syntax: {fn, isAsync}}) {
		if (!isAsync) return false;

		this.#activeSearch = new _ListSearch({
			term,
			fn,
			items: this._items,
		});
		const {isInterrupted, searchedItems} = await this.#activeSearch.pRun();

		if (isInterrupted) return false;
		this._searchedItems = searchedItems;
		return true;
	}

	static isVisibleDefaultSearch (li, searchTerm) { return li.searchText.includes(searchTerm); }

	_doSearch_doSearchTerm_fuzzy () {
		const results = this._fuzzySearch
			.search(
				this._searchTerm,
				{
					fields: {
						s: {expand: true},
					},
					bool: "AND",
					expand: true,
				},
			);

		return results.map(res => this._items[res.doc.ix]);
	}

	_doSearch_doPostSearchTerm () {
				this._searchedItems = this._searchedItems.filter(it => !it.data.isExcluded);

		this._doFilter();
	}

	getFilteredItems ({items = null, fnFilter} = {}) {
		items = items || this._searchedItems;
		fnFilter = fnFilter || this._fnFilter;

		if (!fnFilter) return items;

		return items.filter(it => fnFilter(it));
	}

	_doFilter () {
		this._filteredItems = this.getFilteredItems();
		this._doSort();
	}

	getSortedItems ({items = null} = {}) {
		items = items || [...this._filteredItems];

		const opts = {
			sortBy: this._sortBy,
									sortDir: this._sortDir,
		};
		if (this._fnSort) items.sort((a, b) => this._fnSort(a, b, opts));
		if (this._sortDir === "desc") items.reverse();

		return items;
	}

	_doSort () {
		this._sortedItems = this.getSortedItems();
		this._doRender();
	}

	_doRender () {
		const len = this._sortedItems.length;

		if (this._isUseJquery) {
			this._$wrpList.children().detach();
			for (let i = 0; i < len; ++i) this._$wrpList.append(this._sortedItems[i].ele);
		} else {
			this._$wrpList[0].innerHTML = "";
			const frag = document.createDocumentFragment();
			for (let i = 0; i < len; ++i) frag.appendChild(this._sortedItems[i].ele);
			this._$wrpList[0].appendChild(frag);
		}

		this._isDirty = false;
		this._trigger("updated");
	}

	search (searchTerm) {
		const nextTerm = List$1.getCleanSearchTerm(searchTerm);
		if (nextTerm === this._searchTerm) return;
		this._searchTerm = nextTerm;
		return this._doSearch();
	}

	filter (fnFilter) {
		if (this._fnFilter === fnFilter) return;
		this._fnFilter = fnFilter;
		this._doFilter();
	}

	sort (sortBy, sortDir) {
		if (this._sortBy !== sortBy || this._sortDir !== sortDir) {
			this._sortBy = sortBy;
			this._sortDir = sortDir;
			this._doSort();
		}
	}

	reset () {
		if (this._searchTerm !== List$1._DEFAULTS.searchTerm) {
			this._searchTerm = List$1._DEFAULTS.searchTerm;
			return this._doSearch();
		} else if (this._sortBy !== this._sortByInitial || this._sortDir !== this._sortDirInitial) {
			this._sortBy = this._sortByInitial;
			this._sortDir = this._sortDirInitial;
		}
	}

	addItem (listItem) {
		this._isDirty = true;
		this._items.push(listItem);

		if (this._isFuzzy) this._fuzzySearch.addDoc({ix: listItem.ix, s: listItem.searchText});
	}

	removeItem (listItem) {
		const ixItem = this._items.indexOf(listItem);
		return this.removeItemByIndex(listItem.ix, ixItem);
	}

	removeItemByIndex (ix, ixItem) {
		ixItem = ixItem ?? this._items.findIndex(it => it.ix === ix);
		if (!~ixItem) return;

		this._isDirty = true;
		const removed = this._items.splice(ixItem, 1);

		if (this._isFuzzy) this._fuzzySearch.removeDocByRef(ix);

		return removed[0];
	}

	removeItemBy (valueName, value) {
		const ixItem = this._items.findIndex(it => it.values[valueName] === value);
		return this.removeItemByIndex(ixItem, ixItem);
	}

	removeItemByData (dataName, value) {
		const ixItem = this._items.findIndex(it => it.data[dataName] === value);
		return this.removeItemByIndex(ixItem, ixItem);
	}

	removeAllItems () {
		this._isDirty = true;
		this._items = [];
		if (this._isFuzzy) this._initFuzzySearch();
	}

	on (eventName, handler) { (this._eventHandlers[eventName] = this._eventHandlers[eventName] || []).push(handler); }
	_trigger (eventName) { (this._eventHandlers[eventName] || []).forEach(fn => fn()); }

			doAbsorbItems (dataArr, opts) {
		const children = [...this._$wrpList[0].children];

		const len = children.length;
		if (len !== dataArr.length) throw new Error(`Data source length and list element length did not match!`);

		for (let i = 0; i < len; ++i) {
			const node = children[i];
			const dataItem = dataArr[i];
			const listItem = new ListItem$1(
				i,
				node,
				opts.fnGetName(dataItem),
				opts.fnGetValues ? opts.fnGetValues(dataItem) : {},
				{},
			);
			if (opts.fnGetData) listItem.data = opts.fnGetData(listItem, dataItem);
			if (opts.fnBindListeners) opts.fnBindListeners(listItem, dataItem);
			this.addItem(listItem);
		}
	}
	
		doSelect (item, evt) {
		if (evt && evt.shiftKey) {
			evt.preventDefault(); 						if (this._prevList && this._prevList._lastSelection) {
				this._prevList._selectFromItemToEnd(this._prevList._lastSelection, true);
				this._selectToItemFromStart(item);
			} else if (this._nextList && this._nextList._lastSelection) {
				this._nextList._selectToItemFromStart(this._nextList._lastSelection, true);
				this._selectFromItemToEnd(item);
			} else if (this._lastSelection && this.visibleItems.includes(item)) {
				this._doSelect_doMulti(item);
			} else {
				this._doSelect_doSingle(item);
			}
		} else this._doSelect_doSingle(item);
	}

	_doSelect_doSingle (item) {
		if (this._isMultiSelection) {
			this.deselectAll();
			if (this._prevList) this._prevList.deselectAll();
			if (this._nextList) this._nextList.deselectAll();
		} else if (this._lastSelection) this._lastSelection.isSelected = false;

		item.isSelected = true;
		this._lastSelection = item;
	}

	_doSelect_doMulti (item) {
		this._selectFromItemToItem(this._lastSelection, item);

		if (this._prevList && this._prevList._isMultiSelection) {
			this._prevList.deselectAll();
		}

		if (this._nextList && this._nextList._isMultiSelection) {
			this._nextList.deselectAll();
		}
	}

	_selectFromItemToEnd (item, isKeepLastSelection = false) {
		this.deselectAll(isKeepLastSelection);
		this._isMultiSelection = true;
		const ixStart = this.visibleItems.indexOf(item);
		const len = this.visibleItems.length;
		for (let i = ixStart; i < len; ++i) {
			this.visibleItems[i].isSelected = true;
		}
	}

	_selectToItemFromStart (item, isKeepLastSelection = false) {
		this.deselectAll(isKeepLastSelection);
		this._isMultiSelection = true;
		const ixEnd = this.visibleItems.indexOf(item);
		for (let i = 0; i <= ixEnd; ++i) {
			this.visibleItems[i].isSelected = true;
		}
	}

	_selectFromItemToItem (item1, item2) {
		this.deselectAll(true);

		if (item1 === item2) {
			if (this._lastSelection) this._lastSelection.isSelected = false;
			item1.isSelected = true;
			this._lastSelection = item1;
			return;
		}

		const ix1 = this.visibleItems.indexOf(item1);
		const ix2 = this.visibleItems.indexOf(item2);

		this._isMultiSelection = true;
		const [ixStart, ixEnd] = [ix1, ix2].sort(SortUtil.ascSort);
		for (let i = ixStart; i <= ixEnd; ++i) {
			this.visibleItems[i].isSelected = true;
		}
	}

	deselectAll (isKeepLastSelection = false) {
		if (!isKeepLastSelection) this._lastSelection = null;
		this._isMultiSelection = false;
		this._items.forEach(it => it.isSelected = false);
	}

	updateSelected (item) {
		if (this.visibleItems.includes(item)) {
			if (this._isMultiSelection) this.deselectAll(true);

			if (this._lastSelection && this._lastSelection !== item) this._lastSelection.isSelected = false;

			item.isSelected = true;
			this._lastSelection = item;
		} else this.deselectAll();
	}

	getSelected () {
		return this.visibleItems.filter(it => it.isSelected);
	}
	
	static getCleanSearchTerm (str) {
		return (str || "").toAscii().trim().toLowerCase().split(/\s+/g).join(" ");
	}
};
List$1._DEFAULTS = {
	searchTerm: "",
	sortBy: "name",
	sortDir: "asc",
	fnFilter: null,
};

globalThis.List = List$1;
globalThis.ListItem = ListItem$1;

"use strict";

let LootGenUi$1 = class LootGenUi extends BaseComponent {
	static _CHALLENGE_RATING_RANGES = {
		0: "0\u20134",
		5: "5\u201310",
		11: "11\u201316",
		17: "17+",
	};
	static _PARTY_LOOT_LEVEL_RANGES = {
		4: "1\u20134",
		10: "5\u201310",
		16: "11\u201316",
		20: "17+",
	};
	static _PARTY_LOOT_ITEMS_PER_LEVEL = {
		1: {
			"major": {
				"uncommon": 0,
				"rare": 0,
				"very rare": 0,
				"legendary": 0,
			},
			"minor": {
				"common": 0,
				"uncommon": 0,
				"rare": 0,
				"very rare": 0,
				"legendary": 0,
			},
		},
		4: {
			"major": {
				"uncommon": 2,
				"rare": 0,
				"very rare": 0,
				"legendary": 0,
			},
			"minor": {
				"common": 6,
				"uncommon": 2,
				"rare": 1,
				"very rare": 0,
				"legendary": 0,
			},
		},
		10: {
			"major": {
				"uncommon": 5,
				"rare": 1,
				"very rare": 0,
				"legendary": 0,
			},
			"minor": {
				"common": 10,
				"uncommon": 12,
				"rare": 5,
				"very rare": 1,
				"legendary": 0,
			},
		},
		16: {
			"major": {
				"uncommon": 1,
				"rare": 2,
				"very rare": 2,
				"legendary": 1,
			},
			"minor": {
				"common": 3,
				"uncommon": 6,
				"rare": 9,
				"very rare": 5,
				"legendary": 1,
			},
		},
		20: {
			"major": {
				"uncommon": 0,
				"rare": 1,
				"very rare": 2,
				"legendary": 3,
			},
			"minor": {
				"common": 0,
				"uncommon": 0,
				"rare": 4,
				"very rare": 9,
				"legendary": 6,
			},
		},
	};
	static _DRAGON_AGES = [
		"Wyrmling",
		"Young",
		"Adult",
		"Ancient",
	];

	constructor ({spells, items, ClsLootGenOutput}) {
		super();

		TabUiUtil.decorate(this, {isInitMeta: true});

		this._ClsLootGenOutput = ClsLootGenOutput || LootGenOutput$1;

		this._modalFilterSpells = new ModalFilterSpells({namespace: "LootGenUi.spells", allData: spells});
		this._modalFilterItems = new ModalFilterItems({
			namespace: "LootGenUi.items",
			allData: items,
		});

		this._data = null;
		this._dataSpells = spells;
		this._dataItems = items;

		this._dataSpellsFiltered = [...spells];
		this._dataItemsFiltered = [...items];

		this._lt_tableMetas = null;

		this._pl_xgeTableLookup = null;

		this._$wrpOutputRows = null;
		this._lootOutputs = [];
	}

	static _er (...args) { return Renderer.get().setFirstSection(true).render(...args); }

	getSaveableState () {
		return {
			...super.getSaveableState(),
			meta: this.__meta,
		};
	}

	setStateFrom (toLoad, isOverwrite = false) {
		super.setStateFrom(toLoad, isOverwrite);
		toLoad.meta && this._proxyAssignSimple("meta", toLoad.meta, isOverwrite);
	}

	addHookAll (hookProp, hook) { return this._addHookAll(hookProp, hook); }

	async pInit () {
		await this._modalFilterSpells.pPreloadHidden();
		await this._modalFilterItems.pPreloadHidden();

		await this._modalFilterSpells.pPopulateHiddenWrapper();
		await this._modalFilterItems.pPopulateHiddenWrapper();

		this._data = await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/loot.json`);

		await this._pInit_pBindFilterHooks();
	}

	async _pInit_pBindFilterHooks () {
		const tablesMagicItems = await ["A", "B", "C", "D", "E", "F", "G", "H", "I"]
			.pMap(async letter => {
				return {
					letter,
					tableEntry: await DataLoader.pCacheAndGet(UrlUtil.PG_TABLES, Parser.SRC_DMG, UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_TABLES]({name: `Magic Item Table ${letter}`, source: Parser.SRC_DMG})),
				};
			});

		const hkFilterChangeSpells = () => this._handleFilterChangeSpells();
		this._modalFilterSpells.pageFilter.filterBox.on(FilterBox.EVNT_VALCHANGE, hkFilterChangeSpells);
		hkFilterChangeSpells();

		const hkFilterChangeItems = () => this._handleFilterChangeItems({tablesMagicItems});
		this._modalFilterItems.pageFilter.filterBox.on(FilterBox.EVNT_VALCHANGE, hkFilterChangeItems);
		hkFilterChangeItems();
	}

	_handleFilterChangeSpells () {
		const f = this._modalFilterSpells.pageFilter.filterBox.getValues();
		this._dataSpellsFiltered = this._dataSpells.filter(it => this._modalFilterSpells.pageFilter.toDisplay(f, it));

		this._state.pulseSpellsFiltered = !this._state.pulseSpellsFiltered;
	}

	_handleFilterChangeItems ({tablesMagicItems}) {
		const f = this._modalFilterItems.pageFilter.filterBox.getValues();
		this._dataItemsFiltered = this._dataItems.filter(it => this._modalFilterItems.pageFilter.toDisplay(f, it));

		const xgeTables = this._getXgeFauxTables();

		this._lt_tableMetas = [
			null,
			...tablesMagicItems.map(({letter, tableEntry}) => {
				tableEntry = MiscUtil.copy(tableEntry);
				tableEntry.type = "table";
				delete tableEntry.chapter;
				return {
					type: "DMG",
					dmgTableType: letter,
					tableEntry,
					table: this._data.magicItems.find(it => it.type === letter),
				};
			}),
			...xgeTables,
		];

		this._pl_xgeTableLookup = {};
		xgeTables.forEach(({tier, rarity, table}) => MiscUtil.set(this._pl_xgeTableLookup, tier, rarity, table));

		this._state.pulseItemsFiltered = !this._state.pulseItemsFiltered;
	}

		_getXgeFauxTables () {
		const byTier = {};

		this._dataItemsFiltered
			.forEach(item => {
				const tier = item.tier || "other";
				const rarity = item.rarity || (Renderer.item.isMundane(item) ? "unknown" : "unknown (magic)");
				const tgt = MiscUtil.getOrSet(byTier, tier, rarity, []);
				tgt.push(item);
			});

		return Object.entries(byTier)
			.map(([tier, byRarity]) => {
				return Object.entries(byRarity)
					.sort(([rarityA], [rarityB]) => SortUtil.ascSortItemRarity(rarityA, rarityB))
					.map(([rarity, items]) => {
						const isMundane = Renderer.item.isMundane({rarity});

						const caption = tier === "other"
							? `Other ${isMundane ? "mundane" : "magic"} items of ${rarity} rarity`
							: `${tier.toTitleCase()}-tier ${isMundane ? "mundane" : "magic"} items of ${rarity} rarity`;

						return {
							type: "XGE",
							tier,
							rarity,

							tableEntry: {
								type: "table",
								caption,
								colLabels: [
									`d${items.length}`,
									"Item",
								],
								colStyles: [
									"col-2 text-center",
									"col-10",
								],
								rows: items.map((it, i) => ([i + 1, `{@item ${it.name}|${it.source}}`])),
							},

							table: {
								name: caption,
								source: Parser.SRC_XGE,
								page: 135,
								diceType: items.length,
								table: items.map((it, i) => ({min: i + 1, max: i + 1, item: `{@item ${it.name}|${it.source}}`})),
							},
						};
					});
			})
			.flat();
	}

	render ({$stg, $stgLhs, $stgRhs}) {
		if ($stg && ($stgLhs || $stgRhs)) throw new Error(`Only one of "parent stage" and "LHS/RHS stages" may be specified!`);

		const {$stgLhs: $stgLhs_, $stgRhs: $stgRhs_} = this._render_$getStages({$stg, $stgLhs, $stgRhs});

		const iptTabMetas = [
			new TabUiUtil.TabMeta({name: "Random Treasure by CR", hasBorder: true, hasBackground: true}),
			new TabUiUtil.TabMeta({name: "Loot Tables", hasBorder: true, hasBackground: true}),
			new TabUiUtil.TabMeta({name: "Party Loot", hasBorder: true, hasBackground: true}),
			new TabUiUtil.TabMeta({name: "Dragon Hoard", hasBorder: true, hasBackground: true}),
			new TabUiUtil.TabMeta({name: "Gems/Art Objects Generator", isHeadHidden: true, hasBackground: true}),
			new TabUiUtil.TabMeta({
				type: "buttons",
				buttons: [
					{
						html: `<span class="glyphicon glyphicon-option-vertical"></span>`,
						title: "Other Generators",
						type: "default",
						pFnClick: null, 					},
				],
			}),
		];

		const tabMetas = this._renderTabs(iptTabMetas, {$parent: $stgLhs_});
		const [tabMetaFindTreasure, tabMetaLootTables, tabMetaPartyLoot, tabMetaDragonHoard, tabMetaGemsArtObjects, tabMetaOptions] = tabMetas;

		this._render_tabFindTreasure({tabMeta: tabMetaFindTreasure});
		this._render_tabLootTables({tabMeta: tabMetaLootTables});
		this._render_tabPartyLoot({tabMeta: tabMetaPartyLoot});
		this._render_tabDragonHoard({tabMeta: tabMetaDragonHoard});
		this._render_tabGemsArtObjects({tabMeta: tabMetaGemsArtObjects});
		this._render_tabOptions({tabMeta: tabMetaOptions, tabMetaGemsArtObjects});

		this._render_output({$wrp: $stgRhs_});
	}

		_render_$getStages ({$stg, $stgLhs, $stgRhs}) {
		if (!$stg) return {$stgLhs, $stgRhs};

		$stgLhs = $(`<div class="ve-flex w-50 h-100"></div>`);
		$stgRhs = $(`<div class="ve-flex-col w-50 h-100"></div>`);

		$$`<div class="ve-flex w-100 h-100">
			${$stgLhs}
			<div class="vr-2 h-100"></div>
			${$stgRhs}
		</div>`.appendTo($stg.empty());

		return {$stgLhs, $stgRhs};
	}

	_render_tabFindTreasure ({tabMeta}) {
		const $selChallenge = ComponentUiUtil.$getSelEnum(
			this,
			"ft_challenge",
			{
				values: Object.keys(LootGenUi$1._CHALLENGE_RATING_RANGES).map(it => Number(it)),
				fnDisplay: it => LootGenUi$1._CHALLENGE_RATING_RANGES[it],
			},
		);

		const $cbIsHoard = ComponentUiUtil.$getCbBool(this, "ft_isHoard");

		const $btnRoll = $(`<button class="btn btn-default btn-xs mr-2">Roll Loot</button>`)
			.click(() => this._ft_pDoHandleClickRollLoot());

		const $btnClear = $(`<button class="btn btn-danger btn-xs">Clear Output</button>`)
			.click(() => this._doClearOutput());

		$$`<div class="ve-flex-col py-2 px-3">
			<label class="split-v-center mb-2">
				<div class="mr-2 w-66 no-shrink">Challenge Rating</div>
				${$selChallenge}
			</label>

			<label class="split-v-center mb-3">
				<div class="mr-2 w-66 no-shrink">Is Treasure Hoard?</div>
				${$cbIsHoard}
			</label>

			<div class="ve-flex-v-center mb-2">
				${$btnRoll}
				${$btnClear}
			</div>

			<hr class="hr-3">

			<div class="ve-small italic">${this.constructor._er(`Based on the tables and rules in the {@book Dungeon Master's Guide|DMG|7|Treasure Tables}`)}, pages 133-149.</div>
		</div>`.appendTo(tabMeta.$wrpTab);
	}

	_ft_pDoHandleClickRollLoot () {
		if (this._state.ft_isHoard) return this._ft_doHandleClickRollLoot_pHoard();
		return this._ft_doHandleClickRollLoot_single();
	}

	_ft_doHandleClickRollLoot_single () {
		const tableMeta = this._data.individual.find(it => it.crMin === this._state.ft_challenge);

		const rowRoll = RollerUtil.randomise(100);
		const row = tableMeta.table.find(it => rowRoll >= it.min && rowRoll <= it.max);

		const coins = this._getConvertedCoins(
			Object.entries(row.coins)
				.mergeMap(([type, formula]) => ({[type]: Renderer.dice.parseRandomise2(formula)})),
		);

		const lootOutput = new this._ClsLootGenOutput({
			type: `Individual Treasure: ${LootGenUi$1._CHALLENGE_RATING_RANGES[this._state.ft_challenge]}`,
			name: `{@b Individual Treasure} for challenge rating {@b ${LootGenUi$1._CHALLENGE_RATING_RANGES[this._state.ft_challenge]}}`,
			coins,
		});
		this._doAddOutput({lootOutput});
	}

	async _ft_doHandleClickRollLoot_pHoard () {
		const tableMeta = this._data.hoard.find(it => it.crMin === this._state.ft_challenge);

		const rowRoll = RollerUtil.randomise(100);
		const row = tableMeta.table.find(it => rowRoll >= it.min && rowRoll <= it.max);

		const coins = this._getConvertedCoins(
			Object.entries(tableMeta.coins || {})
				.mergeMap(([type, formula]) => ({[type]: Renderer.dice.parseRandomise2(formula)})),
		);

		const gems = this._doHandleClickRollLoot_hoard_gemsArtObjects({row, prop: "gems"});
		const artObjects = this._doHandleClickRollLoot_hoard_gemsArtObjects({row, prop: "artObjects"});
		const magicItemsByTable = await this._doHandleClickRollLoot_hoard_pMagicItems({row});

		const lootOutput = new this._ClsLootGenOutput({
			type: `Treasure Hoard: ${LootGenUi$1._CHALLENGE_RATING_RANGES[this._state.ft_challenge]}`,
			name: `{@b Hoard} for challenge rating {@b ${LootGenUi$1._CHALLENGE_RATING_RANGES[this._state.ft_challenge]}}`,
			coins,
			gems,
			artObjects,
			magicItemsByTable,
		});
		this._doAddOutput({lootOutput});
	}

	_doHandleClickRollLoot_hoard_gemsArtObjects ({row, prop}) {
		if (!row[prop]) return null;

		const lootMeta = row[prop];

		const {type, typeRoll} = this._doHandleClickRollLoot_hoard_gemsArtObjects_getTypeInfo({lootMeta});

		const specificTable = this._data[prop].find(it => it.type === type);
		const count = Renderer.dice.parseRandomise2(lootMeta.amount);

		const breakdown = {};
		[...new Array(count)]
			.forEach(() => {
				const type = RollerUtil.rollOnArray(specificTable.table);
				breakdown[type] = (breakdown[type] || 0) + 1;
			});

		return [
			new LootGenOutputGemsArtObjects({
				type,
				typeRoll,
				typeTable: lootMeta.typeTable,
				count,
				breakdown,
			}),
		];
	}

		_doHandleClickRollLoot_hoard_gemsArtObjectsMulti ({row, prop}) {
		if (!row[prop]) return null;

		const lootMeta = row[prop];

		const count = Renderer.dice.parseRandomise2(lootMeta.amount);

		const byType = {};

		[...new Array(count)]
			.forEach(() => {
				const {type} = this._doHandleClickRollLoot_hoard_gemsArtObjects_getTypeInfo({lootMeta});

				if (!byType[type]) {
					byType[type] = {
						breakdown: {},
						count: 0,
					};
				}

				const meta = byType[type];

				meta.count++;

				const specificTable = this._data[prop].find(it => it.type === type);

				const type2 = RollerUtil.rollOnArray(specificTable.table);
				meta.breakdown[type2] = (meta.breakdown[type2] || 0) + 1;
			});

		return Object.entries(byType)
			.map(([type, meta]) => {
				return new LootGenOutputGemsArtObjects({
					type,
					typeRoll: null,
					typeTable: lootMeta.typeTable,
					count: meta.count,
					breakdown: meta.breakdown,
				});
			});
	}

	_doHandleClickRollLoot_hoard_gemsArtObjects_getTypeInfo ({lootMeta}) {
		if (lootMeta.type) return {type: lootMeta.type};

		const typeRoll = RollerUtil.randomise(100);
		const typeMeta = lootMeta.typeTable.find(it => typeRoll >= it.min && typeRoll <= it.max);
		return {type: typeMeta.type, typeRoll};
	}

	async _doHandleClickRollLoot_hoard_pMagicItems ({row, fnGetIsPreferAltChoose = null}) {
		if (!row.magicItems) return null;

		return row.magicItems.pMap(async magicItemsObj => {
			const {type, typeRoll, typeAltChoose} = this._doHandleClickRollLoot_hoard_pMagicItems_getTypeInfo({magicItemsObj});

			const magicItemTable = this._data.magicItems.find(it => it.type === type);
			const count = Renderer.dice.parseRandomise2(magicItemsObj.amount);
			const itemsAltChoose = this._doHandleClickRollLoot_hoard_getAltChooseList({typeAltChoose});
			const itemsAltChooseDisplayText = this._doHandleClickRollLoot_hoard_getAltChooseDisplayText({typeAltChoose});

			const breakdown = [];

			await ([...new Array(count)].pSerialAwaitMap(async () => {
				const lootItem = await LootGenMagicItem.pGetMagicItemRoll({
					lootGenMagicItems: breakdown,
					spells: this._dataSpellsFiltered,
					magicItemTable,
					itemsAltChoose,
					itemsAltChooseDisplayText,
					isItemsAltChooseRoll: fnGetIsPreferAltChoose ? fnGetIsPreferAltChoose() : false,
					fnGetIsPreferAltChoose,
				});
				breakdown.push(lootItem);
			}));

			return new LootGenOutputMagicItems({
				type,
				count,
				typeRoll,
				typeTable: magicItemsObj.typeTable,
				breakdown,
			});
		});
	}

	async _doHandleClickRollLoot_hoard_pMagicItemsMulti ({row, fnGetIsPreferAltChoose = null}) {
		if (!row.magicItems) return null;

		const byType = {};

		await row.magicItems.pMap(async magicItemsObj => {
			const count = Renderer.dice.parseRandomise2(magicItemsObj.amount);

			await [...new Array(count)]
				.pSerialAwaitMap(async () => {
					const {type, typeAltChoose} = this._doHandleClickRollLoot_hoard_pMagicItems_getTypeInfo({magicItemsObj});

					if (!byType[type]) {
						byType[type] = {
							breakdown: [],
							count: 0,
							typeTable: magicItemsObj.typeTable,
						};
					}

					const meta = byType[type];

					const magicItemTable = this._data.magicItems.find(it => it.type === type);
					const itemsAltChoose = this._doHandleClickRollLoot_hoard_getAltChooseList({typeAltChoose});
					const itemsAltChooseDisplayText = this._doHandleClickRollLoot_hoard_getAltChooseDisplayText({typeAltChoose});

					const lootItem = await LootGenMagicItem.pGetMagicItemRoll({
						lootGenMagicItems: meta.breakdown,
						spells: this._dataSpellsFiltered,
						magicItemTable,
						itemsAltChoose,
						itemsAltChooseDisplayText,
						isItemsAltChooseRoll: fnGetIsPreferAltChoose ? fnGetIsPreferAltChoose() : false,
						fnGetIsPreferAltChoose,
					});
					meta.breakdown.push(lootItem);
				});
		});

		return Object.entries(byType)
			.map(([type, meta]) => {
				return new LootGenOutputMagicItems({
					type,
					count: meta.count,
					typeRoll: null,
					typeTable: meta.typeTable,
					breakdown: meta.breakdown,
				});
			});
	}

	_doHandleClickRollLoot_hoard_pMagicItems_getTypeInfo ({magicItemsObj}) {
		if (magicItemsObj.type) return {type: magicItemsObj.type, typeAltChoose: magicItemsObj.typeAltChoose};

		const typeRoll = RollerUtil.randomise(100);
		const typeMeta = magicItemsObj.typeTable.find(it => typeRoll >= it.min && typeRoll <= it.max);
		return {type: typeMeta.type, typeRoll, typeAltChoose: typeMeta.typeAltChoose};
	}

	_doHandleClickRollLoot_hoard_getAltChooseList ({typeAltChoose}) {
		if (!typeAltChoose) return null;
		return this._dataItemsFiltered.filter(it => it.type !== "GV" && Object.entries(typeAltChoose).every(([k, v]) => it[k] === v));
	}

	_doHandleClickRollLoot_hoard_getAltChooseDisplayText ({typeAltChoose}) {
		if (!typeAltChoose) return null;
		return [
			typeAltChoose.rarity,
			typeAltChoose.tier,
		].filter(Boolean).join(" ");
	}

	_render_tabLootTables ({tabMeta}) {
		let cacheTableMetas = [...this._lt_tableMetas];

		const getSelTableValues = () => this._lt_tableMetas.map((_, i) => i);

		const {$sel: $selTable, setValues: setSelTableValues} = ComponentUiUtil.$getSelEnum(
			this,
			"lt_ixTable",
			{
				asMeta: true,
				values: getSelTableValues(),
				fnDisplay: ix => this._lt_tableMetas[ix] == null
					? `\u2014`
					: this._lt_tableMetas[ix].tier
						? `Tier: ${this._lt_tableMetas[ix].tier}; Rarity: ${this._lt_tableMetas[ix].rarity}`
						: this._lt_tableMetas[ix].tableEntry.caption,
			},
		);

		const hkPulseItem = () => {
			const curVal = cacheTableMetas[this._state.lt_ixTable];
			cacheTableMetas = [...this._lt_tableMetas];

			const values = getSelTableValues();
			setSelTableValues(values);

			if (
				!values.includes(this._state.lt_ixTable)
				|| !curVal
				|| !curVal.tier || !curVal.rarity
			) return this._state.lt_ixTable = 0;

						const ix = this._lt_tableMetas.findIndex(it => it && it.tier === curVal.tier && it.rarity === curVal.rarity);
			if (~ix) this._state.lt_ixTable = ix;
			else this._state.lt_ixTable = 0;
		};
		this._addHookBase("pulseItemsFiltered", hkPulseItem);

		const $btnRoll = $(`<button class="btn btn-default btn-xs mr-2">Roll Loot</button>`)
			.click(() => this._lt_pDoHandleClickRollLoot());

		const $btnClear = $(`<button class="btn btn-danger btn-xs">Clear Output</button>`)
			.click(() => this._doClearOutput());

		const $hrHelp = $(`<hr class="hr-3">`);
		const $dispHelp = $(`<div class="ve-small italic"></div>`);
		const $hrTable = $(`<hr class="hr-3">`);
		const $dispTable = $(`<div class="ve-flex-col w-100"></div>`);

		const hkTable = () => {
			const tableMeta = this._lt_tableMetas[this._state.lt_ixTable];

			$dispHelp.toggleVe(tableMeta != null);
			$dispTable.toggleVe(tableMeta != null);
			$hrHelp.toggleVe(tableMeta != null);
			$hrTable.toggleVe(tableMeta != null);

			if (tableMeta == null) return;

			$dispHelp
				.html(tableMeta.type === "DMG" ? this.constructor._er(`Based on the tables and rules in the {@book Dungeon Master's Guide|DMG|7|Treasure Tables}, pages 133-149.`) : this.constructor._er(`Tables auto-generated based on the rules in {@book Xanathar's Guide to Everything (Choosing Items Piecemeal)|XGE|2|choosing items piecemeal}, pages 135-136.`));

			$dispTable.html(this.constructor._er(tableMeta.tableEntry));
		};
		this._addHookBase("lt_ixTable", hkTable);
		hkTable();

		$$`<div class="ve-flex-col py-2 px-3">
			<label class="split-v-center mb-3">
				<div class="mr-2 w-66 no-shrink">Table</div>
				${$selTable}
			</label>

			<div class="ve-flex-v-center mb-2">
				${$btnRoll}
				${$btnClear}
			</div>

			${$hrHelp}
			${$dispHelp}
			${$hrTable}
			${$dispTable}
		</div>`.appendTo(tabMeta.$wrpTab);
	}

	async _lt_pDoHandleClickRollLoot () {
		const tableMeta = this._lt_tableMetas[this._state.lt_ixTable];
		if (!tableMeta) return JqueryUtil.doToast({type: "warning", content: `Please select a table first!`});

		const lootOutput = new this._ClsLootGenOutput({
			type: `Treasure Table Roll: ${tableMeta.type === "DMG" ? tableMeta.tableEntry.caption : `${tableMeta.tier} ${tableMeta.rarity}`}`,
			name: tableMeta.type === "DMG"
				? `Rolled against {@b {@table ${tableMeta.tableEntry.caption}|${Parser.SRC_DMG}}}`
				: `Rolled on the table for {@b ${tableMeta.tier} ${tableMeta.rarity}} items`,
			magicItemsByTable: await this._lt_pDoHandleClickRollLoot_pGetMagicItemMetas({tableMeta}),
		});
		this._doAddOutput({lootOutput});
	}

	async _lt_pDoHandleClickRollLoot_pGetMagicItemMetas ({tableMeta}) {
		const breakdown = [];
		const lootItem = await LootGenMagicItem.pGetMagicItemRoll({
			lootGenMagicItems: breakdown,
			spells: this._dataSpellsFiltered,
			magicItemTable: tableMeta.table,
		});
		breakdown.push(lootItem);

		return [
			new LootGenOutputMagicItems({
				type: tableMeta.dmgTableType,
				count: 1,
				breakdown,
			}),
		];
	}

	_render_tabPartyLoot ({tabMeta}) {
		const $cbIsExactLevel = ComponentUiUtil.$getCbBool(this, "pl_isExactLevel");

		const $cbIsCumulative = ComponentUiUtil.$getCbBool(this, "pl_isCumulative");

				const $selCharLevel = ComponentUiUtil.$getSelEnum(
			this,
			"pl_charLevel",
			{
				values: Object.keys(LootGenUi$1._PARTY_LOOT_LEVEL_RANGES).map(it => Number(it)),
				fnDisplay: it => LootGenUi$1._PARTY_LOOT_LEVEL_RANGES[it],
			},
		);

		const $stgDefault = $$`<div class="ve-flex-col w-100">
			<label class="split-v-center mb-2">
				<div class="mr-2 w-66 no-shrink">Character Level</div>
				${$selCharLevel}
			</label>
		</div>`;
		
				const $sliderLevel = ComponentUiUtil.$getSliderRange(
			this,
			{
				propMin: "pl_exactLevelMin",
				propMax: "pl_exactLevelMax",
				propCurMin: "pl_exactLevel",
			},
		);

		const $stgExactLevel = $$`<div class="ve-flex-col w-100">
			<div class="ve-flex-col mb-2">
				<div class="mb-2">Character Level</div>
				${$sliderLevel}
			</div>
		</div>`;
		
				const $btnRoll = $(`<button class="btn btn-default btn-xs mr-2">Roll Loot</button>`)
			.click(() => this._pl_pDoHandleClickRollLoot());

		const $btnClear = $(`<button class="btn btn-danger btn-xs">Clear Output</button>`)
			.click(() => this._doClearOutput());
		
		const hkIsExactLevel = () => {
			$stgDefault.toggleVe(!this._state.pl_isExactLevel);
			$stgExactLevel.toggleVe(this._state.pl_isExactLevel);
		};
		this._addHookBase("pl_isExactLevel", hkIsExactLevel);
		hkIsExactLevel();

		$$`<div class="ve-flex-col py-2 px-3">
			<p>
				Generates a set of magical items for a party, based on the tables and rules in ${this.constructor._er(`{@book Xanathar's Guide to Everything|XGE|2|awarding magic items}`)}, pages 135-136.
			</p>
			<p><i>If &quot;Exact Level&quot; is selected, the output will include a proportional number of items for any partially-completed tier.</i></p>

			<hr class="hr-3">

			${$stgDefault}
			${$stgExactLevel}

			<label class="split-v-center mb-2">
				<div class="mr-2 w-66 no-shrink">Cumulative with Previous Tiers</div>
				${$cbIsCumulative}
			</label>

			<label class="split-v-center mb-3">
				<div class="mr-2 w-66 no-shrink">Is Exact Level</div>
				${$cbIsExactLevel}
			</label>

			<div class="ve-flex-v-center mb-2">
				${$btnRoll}
				${$btnClear}
			</div>
		</div>`.appendTo(tabMeta.$wrpTab);
	}

	async _pl_pDoHandleClickRollLoot () {
		const template = this._pl_getLootTemplate();
		const magicItemsByTable = [];

		for (const [tier, byRarity] of Object.entries(template)) {
			const breakdown = [];
			for (const [rarity, cntItems] of Object.entries(byRarity)) {
				const tableMeta = this._pl_xgeTableLookup[tier]?.[rarity];

				for (let i = 0; i < cntItems; ++i) {
					const lootItem = await LootGenMagicItem.pGetMagicItemRoll({
						lootGenMagicItems: breakdown,
						spells: this._dataSpellsFiltered,
						magicItemTable: tableMeta,
					});
					breakdown.push(lootItem);
				}
			}

			magicItemsByTable.push(
				new LootGenOutputMagicItems({
					count: breakdown.length,
					breakdown,
					tier,
				}),
			);
		}

		const ptLevel = this._state.pl_isExactLevel
			? this._state.pl_exactLevel
			: LootGenUi$1._PARTY_LOOT_LEVEL_RANGES[this._state.pl_charLevel];
		const lootOutput = new this._ClsLootGenOutput({
			type: `Party Loot: Level ${ptLevel}`,
			name: `Magic items for a {@b Level ${ptLevel}} Party`,
			magicItemsByTable,
		});
		this._doAddOutput({lootOutput});
	}

	_pl_getLootTemplate () {
		const {template, levelLow} = this._state.pl_isExactLevel
			? this._pl_getLootTemplate_exactLevel()
			: {template: MiscUtil.copy(LootGenUi$1._PARTY_LOOT_ITEMS_PER_LEVEL[this._state.pl_charLevel]), levelLow: this._state.pl_charLevel};

		if (this._state.pl_isCumulative) this._pl_mutAccumulateLootTemplate({template, levelLow});

		return template;
	}

	_pl_getLootTemplate_exactLevel () {
		if (LootGenUi$1._PARTY_LOOT_ITEMS_PER_LEVEL[this._state.pl_exactLevel]) {
			return {
				template: MiscUtil.copy(LootGenUi$1._PARTY_LOOT_ITEMS_PER_LEVEL[this._state.pl_exactLevel]),
				levelLow: this._state.pl_exactLevel,
			};
		}

		let levelLow = 1;
		let levelHigh = 20;

		Object.keys(LootGenUi$1._PARTY_LOOT_ITEMS_PER_LEVEL)
			.forEach(level => {
				level = Number(level);

				if (level < this._state.pl_exactLevel && (this._state.pl_exactLevel - level) < (this._state.pl_exactLevel - levelLow)) {
					levelLow = level;
				}

				if (level > this._state.pl_exactLevel && (level - this._state.pl_exactLevel) < (levelHigh - this._state.pl_exactLevel)) {
					levelHigh = level;
				}
			});

		const templateLow = MiscUtil.copy(LootGenUi$1._PARTY_LOOT_ITEMS_PER_LEVEL[levelLow]);
		const templateHigh = MiscUtil.copy(LootGenUi$1._PARTY_LOOT_ITEMS_PER_LEVEL[levelHigh]);

		const ratio = (this._state.pl_exactLevel - levelLow) / (levelHigh - levelLow);

		const out = {major: {}, minor: {}};
		Object.entries(out)
			.forEach(([tier, byTier]) => {
				Object.keys(templateLow[tier])
					.forEach(rarity => {
						byTier[rarity] = Math.floor(
							((templateLow[tier]?.[rarity] || 0) * (1 - ratio))
							+ ((templateHigh[tier]?.[rarity] || 0) * ratio),
						);
					});
			});
		return {template: out, levelLow};
	}

	_pl_mutAccumulateLootTemplate ({template, levelLow}) {
		const toAccumulate = Object.keys(LootGenUi$1._PARTY_LOOT_ITEMS_PER_LEVEL)
			.filter(it => Number(it) < levelLow);
		if (!toAccumulate.length) return;

		toAccumulate.forEach(level => {
			Object.entries(LootGenUi$1._PARTY_LOOT_ITEMS_PER_LEVEL[level])
				.forEach(([tier, byRarity]) => {
					Object.entries(byRarity)
						.forEach(([rarity, cntItems]) => {
							const existing = MiscUtil.get(template, tier, rarity) || 0;
							MiscUtil.set(template, tier, rarity, existing + (cntItems || 0));
						});
				});
		});
	}

	_render_tabDragonHoard ({tabMeta}) {
		const $selDragonAge = ComponentUiUtil.$getSelEnum(
			this,
			"dh_dragonAge",
			{
				values: LootGenUi$1._DRAGON_AGES,
			},
		);

		const $cbIsPreferRandomMagicItems = ComponentUiUtil.$getCbBool(this, "dh_isPreferRandomMagicItems");

		const $btnRoll = $(`<button class="btn btn-default btn-xs mr-2">Roll Loot</button>`)
			.click(() => this._dh_pDoHandleClickRollLoot());

		const $btnClear = $(`<button class="btn btn-danger btn-xs">Clear Output</button>`)
			.click(() => this._doClearOutput());

		$$`<div class="ve-flex-col py-2 px-3">
			<label class="split-v-center mb-2">
				<div class="mr-2 w-66 no-shrink">Dragon Age</div>
				${$selDragonAge}
			</label>

			<label class="split-v-center mb-3">
				<div class="mr-2 w-66 no-shrink" title="If selected, random magic items will be preferred over rolling on the standard DMG &quot;Magic Items Table [A-I]&quot; when generating magic items.">Prefer Random Magic Items</div>
				${$cbIsPreferRandomMagicItems}
			</label>

			<div class="ve-flex-v-center mb-2">
				${$btnRoll}
				${$btnClear}
			</div>

			<hr class="hr-3">

			<div class="ve-small italic">${this.constructor._er(`Based on the tables and rules in {@book Fizban's Treasury of Dragons|FTD|4|Creating a Hoard}`)}, pages 72.</div>
		</div>`.appendTo(tabMeta.$wrpTab);
	}

	async _dh_pDoHandleClickRollLoot () {
		const tableMeta = this._data.dragon.find(it => it.name === this._state.dh_dragonAge);

		const coins = this._getConvertedCoins(
			Object.entries(tableMeta.coins || {})
				.mergeMap(([type, formula]) => ({[type]: Renderer.dice.parseRandomise2(formula)})),
		);

		const dragonMundaneItems = this._dh_doHandleClickRollLoot_mundaneItems({dragonMundaneItems: tableMeta.dragonMundaneItems});

		const gems = this._doHandleClickRollLoot_hoard_gemsArtObjectsMulti({row: tableMeta, prop: "gems"});
		const artObjects = this._doHandleClickRollLoot_hoard_gemsArtObjectsMulti({row: tableMeta, prop: "artObjects"});

		const magicItemsByTable = await this._doHandleClickRollLoot_hoard_pMagicItemsMulti({
			row: tableMeta,
			fnGetIsPreferAltChoose: () => !!this._state.dh_isPreferRandomMagicItems,
		});

		const lootOutput = new this._ClsLootGenOutput({
			type: `Dragon Hoard: ${LootGenUi$1._CHALLENGE_RATING_RANGES[this._state.ft_challenge]}`,
			name: `${this._state.dh_dragonAge} Dragon's Hoard`,
			coins,
			gems,
			artObjects,
			dragonMundaneItems,
			magicItemsByTable,
		});
		this._doAddOutput({lootOutput});
	}

	_dh_doHandleClickRollLoot_mundaneItems ({dragonMundaneItems}) {
		if (!dragonMundaneItems) return null;

		const count = Renderer.dice.parseRandomise2(dragonMundaneItems.amount);

		const breakdown = [];
		[...new Array(count)]
			.forEach(() => {
				const roll = RollerUtil.randomise(100);
				const result = this._data.dragonMundaneItems.find(it => roll >= it.min && roll <= it.max);
				breakdown.push(result.item);
			});

		return new LootGenOutputDragonMundaneItems({
			count: count,
			breakdown,
		});
	}

	_render_tabGemsArtObjects ({tabMeta}) {
		const $cbIsUseGems = ComponentUiUtil.$getCbBool(this, "gao_isUseGems");
		const $cbIsUseArtObjects = ComponentUiUtil.$getCbBool(this, "gao_isUseArtObjects");

		const $iptTargetGoldAmount = ComponentUiUtil.$getIptInt(this, "gao_targetGoldAmount", 0, {min: 0})
			.keydown(evt => {
				if (evt.key !== "Enter") return;
				$iptTargetGoldAmount.change();
				$btnRoll.click();
			});

		const $btnRoll = $(`<button class="btn btn-default btn-xs mr-2">Roll Loot</button>`)
			.click(() => this._goa_pDoHandleClickRollLoot());

		const $btnClear = $(`<button class="btn btn-danger btn-xs">Clear Output</button>`)
			.click(() => this._doClearOutput());

		$$`<div class="ve-flex-col py-2 px-3">
			<h4 class="mt-1 mb-3">Gem/Art Object Generator</h4>

			<label class="split-v-center mb-3">
				<div class="mr-2 w-66 no-shrink">Include Gems</div>
				${$cbIsUseGems}
			</label>

			<label class="split-v-center mb-3">
				<div class="mr-2 w-66 no-shrink">Include Art Objects</div>
				${$cbIsUseArtObjects}
			</label>

			<label class="split-v-center mb-3">
				<div class="mr-2 w-66 no-shrink">Target Gold Amount</div>
				${$iptTargetGoldAmount}
			</label>

			<div class="ve-flex-v-center mb-2">
				${$btnRoll}
				${$btnClear}
			</div>

			<hr class="hr-3">

			<div class="ve-small italic">${this.constructor._er(`This custom generator randomly selects gems/art objects up to the target gold amount.`)}</div>
		</div>`.appendTo(tabMeta.$wrpTab);
	}

	async _goa_pDoHandleClickRollLoot () {
		if (this._state.gao_targetGoldAmount <= 0) return JqueryUtil.doToast({content: "Please enter a target gold amount!", type: "warning"});

		if (!this._state.gao_isUseGems && !this._state.gao_isUseArtObjects) return JqueryUtil.doToast({content: `Please select at least one of "Include Gems" and/or "Include Art Objects"`, type: "warning"});

		const typeMap = {};
		[{prop: "gems", stateProp: "gao_isUseGems"}, {prop: "artObjects", stateProp: "gao_isUseArtObjects"}]
			.forEach(({prop, stateProp}) => {
				if (!this._state[stateProp]) return;
				this._data[prop]
					.forEach(({type, table}) => {
						(typeMap[type] = typeMap[type] || []).push({prop, table});
					});
			});

		const types = Object.keys(typeMap).map(it => Number(it)).sort(SortUtil.ascSort).reverse();
		if (this._state.gao_targetGoldAmount < types.last()) return JqueryUtil.doToast({content: `Could not generate any gems/art objects for a gold amount of ${this._state.gao_targetGoldAmount}! Please increase the target gold amount.`, type: "warning"});

				const generated = {};

		let budget = this._state.gao_targetGoldAmount;
		while (budget >= types.last()) {
			const validTypes = types.filter(it => it <= budget);
			const type = RollerUtil.rollOnArray(validTypes);
			const typeMetas = typeMap[type];
			const {prop, table} = RollerUtil.rollOnArray(typeMetas);
			const rolled = RollerUtil.rollOnArray(table);

			const genMeta = MiscUtil.getOrSet(generated, prop, type, {});
			genMeta.count = (genMeta.count || 0) + 1;
			genMeta.breakdown = genMeta.breakdown || {};
			genMeta.breakdown[rolled] = (genMeta.breakdown[rolled] || 0) + 1;

			budget -= type;
		}

		const [gems, artObjects] = ["gems", "artObjects"]
			.map(prop => {
				return generated[prop]
					? Object.entries(generated[prop])
						.sort(([typeA], [typeB]) => SortUtil.ascSort(Number(typeB), Number(typeA)))
						.map(([type, {count, breakdown}]) => {
							type = Number(type);

							return new LootGenOutputGemsArtObjects({
								type,
								count,
								breakdown,
							});
						})
					: null;
			});

		const lootOutput = new this._ClsLootGenOutput({
			type: `Gems/Art Objects`,
			name: `Gems/Art Objects: Roughly ${this._state.gao_targetGoldAmount.toLocaleString()} gp`,
			gems,
			artObjects,
		});
		this._doAddOutput({lootOutput});
	}

	_render_tabOptions ({tabMeta, tabMetaGemsArtObjects}) {
		const menuOthers = ContextUtil.getMenu([
			new ContextUtil.Action(
				"Gems/Art Objects Generator",
				() => {
					this._setActiveTab({tab: tabMetaGemsArtObjects});
				},
			),
			null,
			new ContextUtil.Action(
				"Set Random Item Filters",
				() => {
					this._modalFilterItems.handleHiddenOpenButtonClick();
				},
				{
					title: `Set the filtering parameters used to determine which items can be randomly rolled for some results. Note that this does not, for example, remove these items from standard loot tables.`,
					fnActionAlt: async (evt) => {
						this._modalFilterItems.handleHiddenResetButtonClick(evt);
						JqueryUtil.doToast(`Reset${evt.shiftKey ? " all" : ""}!`);
					},
					textAlt: `<span class="glyphicon glyphicon-refresh"></span>`,
					titleAlt: FilterBox.TITLE_BTN_RESET,
				},
			),
			new ContextUtil.Action(
				"Set Random Spell Filters",
				() => {
					this._modalFilterSpells.handleHiddenOpenButtonClick();
				},
				{
					title: `Set the filtering parameters used to determine which spells can be randomly rolled for some results.`,
					fnActionAlt: async (evt) => {
						this._modalFilterSpells.handleHiddenResetButtonClick(evt);
						JqueryUtil.doToast(`Reset${evt.shiftKey ? " all" : ""}!`);
					},
					textAlt: `<span class="glyphicon glyphicon-refresh"></span>`,
					titleAlt: FilterBox.TITLE_BTN_RESET,
				},
			),
			null,
			new ContextUtil.Action(
				"Settings",
				() => {
					this._opts_pDoOpenSettings();
				},
			),
		]);

				tabMeta.buttons[0].pFnClick = evt => ContextUtil.pOpenMenu(evt, menuOthers);

		const hkIsActive = () => {
			const tab = this._getActiveTab();
			tabMeta.$btns[0].toggleClass("active", !!tab.isHeadHidden);
		};
		this._addHookActiveTab(hkIsActive);
		hkIsActive();
	}

	async _opts_pDoOpenSettings () {
		const {$modalInner} = await UiUtil.pGetShowModal({title: "Settings"});

		const $rowsCurrency = Parser.COIN_ABVS
			.map(it => {
				const {propIsAllowed} = this._getPropsCoins(it);

				const $cb = ComponentUiUtil.$getCbBool(this, propIsAllowed);

				return $$`<label class="split-v-center stripe-odd--faint">
					<div class="no-wrap mr-2">${Parser.coinAbvToFull(it).toTitleCase()}</div>
					${$cb}
				</label>`;
			});

		$$($modalInner)`
			<div class="mb-1" title="Disabled currencies will be converted to equivalent amounts of another currency.">Allowed Currencies:</div>
			<div class="pl-4 ve-flex-col">
				${$rowsCurrency}
			</div>
		`;
	}

	_render_output ({$wrp}) {
		this._$wrpOutputRows = $(`<div class="w-100 h-100 ve-flex-col overflow-y-auto smooth-scroll"></div>`);

		$$`<div class="ve-flex-col w-100 h-100">
			<h4 class="my-0"><i>Output</i></h4>
			${this._$wrpOutputRows}
		</div>`
			.appendTo($wrp);
	}

	_getPropsCoins (coin) {
		return {
			propIsAllowed: `isAllowCurrency${coin.uppercaseFirst()}`,
		};
	}

	_getConvertedCoins (coins) {
		if (!coins) return coins;

		if (Parser.COIN_ABVS.every(it => this._state[this._getPropsCoins(it).propIsAllowed])) return coins;

		if (Parser.COIN_ABVS.every(it => !this._state[this._getPropsCoins(it).propIsAllowed])) {
			JqueryUtil.doToast({content: "All currencies are disabled! Generated currency has been discarded.", type: "warning"});
			return {};
		}

		coins = MiscUtil.copy(coins);
		let coinsRemoved = {};

		Parser.COIN_ABVS
			.forEach(it => {
				const {propIsAllowed} = this._getPropsCoins(it);
				if (this._state[propIsAllowed]) return;
				if (!coins[it]) return;

				coinsRemoved[it] = coins[it];
				delete coins[it];
			});

		if (!Object.keys(coinsRemoved).length) return coins;

		coinsRemoved = {cp: CurrencyUtil.getAsCopper(coinsRemoved)};

		const conversionTableFiltered = MiscUtil.copy(Parser.FULL_CURRENCY_CONVERSION_TABLE)
			.filter(({coin}) => this._state[this._getPropsCoins(coin).propIsAllowed]);
		if (!conversionTableFiltered.some(it => it.isFallback)) conversionTableFiltered[0].isFallback = true;

				if (!conversionTableFiltered.some(it => it.coin === "cp")) {
			const conv = conversionTableFiltered[0];
			coinsRemoved = {[conv.coin]: coinsRemoved.cp * conv.mult};
		}

		const coinsRemovedSimplified = CurrencyUtil.doSimplifyCoins(coinsRemoved, {currencyConversionTable: conversionTableFiltered});

		Object.entries(coinsRemovedSimplified).forEach(([coin, count]) => {
			if (!count) return;
			coins[coin] = (coins[coin] || 0) + count;
		});

		return coins;
	}

	_doAddOutput ({lootOutput}) {
		this._lootOutputs.push(lootOutput);
		lootOutput.render(this._$wrpOutputRows);
	}

	_doClearOutput () {
		this._lootOutputs.forEach(it => it.doRemove());
		this._lootOutputs = [];
	}

	_getDefaultState () {
		return {
			...super._getDefaultState(),

						pulseSpellsFiltered: false,
			pulseItemsFiltered: false,

			isAllowCurrencyCp: true,
			isAllowCurrencySp: true,
			isAllowCurrencyEp: true,
			isAllowCurrencyGp: true,
			isAllowCurrencyPp: true,
			
						ft_challenge: 0,
			ft_isHoard: false,
			
						lt_ixTable: null,
			
						pl_isExactLevel: false,
			pl_isCumulative: false,

			pl_charLevel: 4,

			pl_exactLevelMin: 1,
			pl_exactLevelMax: 20,
			pl_exactLevel: 1,
			
						dh_dragonAge: "Wyrmling",
			dh_isPreferRandomMagicItems: false,
			
						gao_isUseGems: true,
			gao_isUseArtObjects: true,
			gao_targetGoldAmount: 100,
					};
	}
};

globalThis.LootGenUi = LootGenUi$1;

let LootGenOutput$1 = class LootGenOutput {
	static _TIERS = ["other", "minor", "major"];

	constructor (
		{
			type,
			name,
			coins,
			gems,
			artObjects,
			magicItemsByTable,
			dragonMundaneItems,
		},
	) {
		this._type = type;
		this._name = name;
		this._coins = coins;
		this._gems = gems;
		this._artObjects = artObjects;
		this._magicItemsByTable = magicItemsByTable;
		this._dragonMundaneItems = dragonMundaneItems;

		this._datetimeGenerated = Date.now();
	}

	_$getEleTitleSplit () {
		const $btnRivet = !IS_VTT && ExtensionUtil.ACTIVE
			? $(`<button title="Send to Foundry (SHIFT for Temporary Import)" class="btn btn-xs btn-default"><span class="glyphicon glyphicon-send"></span></button>`)
				.click(evt => this._pDoSendToFoundry({isTemp: !!evt.shiftKey}))
			: null;

		const $btnDownload = $(`<button title="Download JSON" class="btn btn-xs btn-default"><span class="glyphicon glyphicon-download glyphicon--top-2p"></span></button>`)
			.click(() => this._pDoSaveAsJson());

		return $$`<div class="btn-group">
			${$btnRivet}
			${$btnDownload}
		</div>`;
	}

	render ($parent) {
		const $eleTitleSplit = this._$getEleTitleSplit();

		const $dispTitle = $$`<h4 class="mt-1 mb-2 split-v-center ve-draggable">
			<div>${Renderer.get().render(this._name)}</div>
			${$eleTitleSplit}
		</h4>`;

		const $parts = [
			this._render_$getPtValueSummary(),
			this._render_$getPtCoins(),
			...this._render_$getPtGemsArtObjects({loot: this._gems, name: "gemstones"}),
			...this._render_$getPtGemsArtObjects({loot: this._artObjects, name: "art objects"}),
			this._render_$getPtDragonMundaneItems(),
			...this._render_$getPtMagicItems(),
		].filter(Boolean);

		this._$wrp = $$`<div class="ve-flex-col lootg__wrp-output py-3 px-2 my-2 mr-1">
			${$dispTitle}
			${$parts.length ? $$`<ul>${$parts}</ul>` : null}
			${!$parts.length ? `<div class="ve-muted help-subtle italic" title="${LootGenMagicItemNull.TOOLTIP_NOTHING.qq()}">(No loot!)</div>` : null}
		</div>`
			.prependTo($parent);

		(IS_VTT ? this._$wrp : $dispTitle)
			.attr("draggable", true)
			.on("dragstart", evt => {
				const meta = {
					type: VeCt.DRAG_TYPE_LOOT,
					data: dropData,
				};
				evt.originalEvent.dataTransfer.setData("application/json", JSON.stringify(meta));
			});

						let dropData;
		this._pGetFoundryForm().then(it => dropData = it);
	}

	async _pDoSendToFoundry ({isTemp} = {}) {
		const toSend = await this._pGetFoundryForm();
		if (isTemp) toSend.isTemp = isTemp;
		if (toSend.currency || toSend.entityInfos) return ExtensionUtil.pDoSend({type: "5etools.lootgen.loot", data: toSend});
		JqueryUtil.doToast({content: `Nothing to send!`, type: "warning"});
	}

	async _pDoSaveAsJson () {
		const serialized = await this._pGetFoundryForm();
		await DataUtil.userDownload("loot", serialized);
	}

	async _pGetFoundryForm () {
		const toSend = {name: this._name, type: this._type, dateTimeGenerated: this._datetimeGenerated};

		if (this._coins) toSend.currency = this._coins;

		const entityInfos = [];
		if (this._gems?.length) entityInfos.push(...await this._pDoSendToFoundry_getGemsArtObjectsMetas({loot: this._gems}));
		if (this._artObjects?.length) entityInfos.push(...await this._pDoSendToFoundry_getGemsArtObjectsMetas({loot: this._artObjects}));

		if (this._magicItemsByTable?.length) {
			for (const magicItemsByTable of this._magicItemsByTable) {
				for (const lootItem of magicItemsByTable.breakdown) {
					const exportMeta = lootItem.getExtensionExportMeta();
					if (!exportMeta) continue;
					const {page, entity, options} = exportMeta;
					entityInfos.push({
						page,
						entity,
						options,
					});
				}
			}
		}

		if (this._dragonMundaneItems?.breakdown?.length) {
			for (const str of this._dragonMundaneItems.breakdown) {
				entityInfos.push({
					page: UrlUtil.PG_ITEMS,
					entity: {
						name: Renderer.stripTags(str).uppercaseFirst(),
						source: Parser.SRC_FTD,
						type: "OTH",
						rarity: "unknown",
					},
				});
			}
		}

		if (entityInfos.length) toSend.entityInfos = entityInfos;

		return toSend;
	}

	async _pDoSendToFoundry_getGemsArtObjectsMetas ({loot}) {
		const uidToCount = {};
		const specialItemMetas = {}; 
		loot.forEach(lt => {
			Object.entries(lt.breakdown)
				.forEach(([entry, count]) => {
					let cntFound = 0;
					entry.replace(/{@item ([^}]+)}/g, (...m) => {
						cntFound++;
						const [name, source] = m[1].toLowerCase().split("|").map(it => it.trim()).filter(Boolean);
						const uid = `${name}|${source || Parser.SRC_DMG}`.toLowerCase();
						uidToCount[uid] = (uidToCount[uid] || 0) + count;
						return "";
					});

					if (cntFound) return;

										const uidFaux = entry.toLowerCase().trim();

					specialItemMetas[uidFaux] = specialItemMetas[uidFaux] || {
						count: 0,
						item: {
							name: Renderer.stripTags(entry).uppercaseFirst(),
							source: Parser.SRC_DMG,
							type: "OTH",
							rarity: "unknown",
						},
					};

					specialItemMetas[uidFaux].count += count;
				});
		});

		const out = [];
		for (const [uid, count] of Object.entries(uidToCount)) {
			const [name, source] = uid.split("|");
			const item = await DataLoader.pCacheAndGet(UrlUtil.PG_ITEMS, source, UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS]({name, source}));
			out.push({
				page: UrlUtil.PG_ITEMS,
				entity: item,
				options: {
					quantity: count,
				},
			});
		}

		for (const {count, item} of Object.values(specialItemMetas)) {
			out.push({
				page: UrlUtil.PG_ITEMS,
				entity: item,
				options: {
					quantity: count,
				},
			});
		}

		return out;
	}

	_render_$getPtValueSummary () {
		if ([this._coins, this._gems, this._artObjects].filter(Boolean).length <= 1) return null;

		const totalValue = [
			this._coins ? CurrencyUtil.getAsCopper(this._coins) : 0,
			this._gems?.length ? this._gems.map(it => it.type * it.count * 100).sum() : 0,
			this._artObjects?.length ? this._artObjects.map(it => it.type * it.count * 100).sum() : 0,
		].sum();

		return $(`<li class="italic ve-muted">A total of ${(totalValue / 100).toLocaleString()} gp worth of coins, art objects, and/or gems, as follows:</li>`);
	}

	_render_$getPtCoins () {
		if (!this._coins) return null;

		const total = CurrencyUtil.getAsCopper(this._coins);
		const breakdown = [...Parser.COIN_ABVS]
			.reverse()
			.filter(it => this._coins[it])
			.map(it => `${this._coins[it].toLocaleString()} ${it}`);

		return $$`
			<li>${(total / 100).toLocaleString()} gp in coinage:</li>
			<ul>
				${breakdown.map(it => `<li>${it}</li>`).join("")}
			</ul>
		`;
	}

	_render_$getPtDragonMundaneItems () {
		if (!this._dragonMundaneItems) return null;

		return $$`
			<li>${this._dragonMundaneItems.count} mundane item${this._dragonMundaneItems.count !== 1 ? "s" : ""}:</li>
			<ul>
				${this._dragonMundaneItems.breakdown.map(it => `<li>${it}</li>`).join("")}
			</ul>
		`;
	}

	_render_$getPtGemsArtObjects ({loot, name}) {
		if (!loot?.length) return [];

		return loot.map(lt => {
			return $$`
			<li>${(lt.type).toLocaleString()} gp ${name} (×${lt.count}; worth ${((lt.type * lt.count)).toLocaleString()} gp total):</li>
			<ul>
				${Object.entries(lt.breakdown).map(([result, count]) => `<li>${Renderer.get().render(result)}${count > 1 ? `, ×${count}` : ""}</li>`).join("")}
			</ul>
		`;
		});
	}

	_render_$getPtMagicItems () {
		if (!this._magicItemsByTable?.length) return [];

		return [...this._magicItemsByTable]
			.sort(({tier: tierA, type: typeA}, {tier: tierB, type: typeB}) => this.constructor._ascSortTier(tierB, tierA) || SortUtil.ascSortLower(typeA || "", typeB || ""))
			.map(magicItems => {
								if (magicItems.tier) {
					const byRarity = {};

					magicItems.breakdown
						.forEach(lootItem => {
							if (!lootItem.item) return;

							const tgt = MiscUtil.getOrSet(byRarity, lootItem.item.rarity, []);
							tgt.push(lootItem);
						});

					const $ulsByRarity = Object.entries(byRarity)
						.sort(([rarityA], [rarityB]) => SortUtil.ascSortItemRarity(rarityB, rarityA))
						.map(([rarity, lootItems]) => {
							return $$`
								<li>${rarity.toTitleCase()} items (×${lootItems.length}):</li>
								<ul>${lootItems.map(it => it.$getRender())}</ul>
							`;
						});

					if (!$ulsByRarity.length) return null;

					return $$`
						<li>${magicItems.tier.toTitleCase()} items:</li>
						<ul>
							${$ulsByRarity}
						</ul>
					`;
				}

				return $$`
					<li>Magic Items${magicItems.type ? ` (${Renderer.get().render(`{@table Magic Item Table ${magicItems.type}||Table ${magicItems.type}}`)})` : ""}${(magicItems.count || 0) > 1 ? ` (×${magicItems.count})` : ""}</li>
					<ul>${magicItems.breakdown.map(it => it.$getRender())}</ul>
				`;
			});
	}

	doRemove () {
		if (this._$wrp) this._$wrp.remove();
	}

	static _ascSortTier (a, b) { return LootGenOutput$1._TIERS.indexOf(a) - LootGenOutput$1._TIERS.indexOf(b); }
};

globalThis.LootGenOutput = LootGenOutput$1;

class LootGenOutputGemsArtObjects {
	constructor (
		{
			type,
			typeRoll,
			typeTable,
			count,
			breakdown,
		},
	) {
		this.type = type;
		this.count = count;
				this.typeRoll = typeRoll;
		this.typeTable = typeTable;
				this.breakdown = breakdown;
	}
}

class LootGenOutputDragonMundaneItems {
	constructor (
		{
			count,
			breakdown,
		},
	) {
		this.count = count;
		this.breakdown = breakdown;
	}
}

class LootGenOutputMagicItems {
	constructor (
		{
			type,
			count,
			typeRoll,
			typeTable,
			breakdown,
			tier,
		},
	) {
		this.type = type;
		this.count = count;
				this.typeRoll = typeRoll;
		this.typeTable = typeTable;
				this.breakdown = breakdown;
		this.tier = tier;
	}
}

class LootGenMagicItem extends BaseComponent {
	static async pGetMagicItemRoll (
		{
			lootGenMagicItems,
			spells,
			magicItemTable,
			itemsAltChoose,
			itemsAltChooseDisplayText,
			isItemsAltChooseRoll = false,
			fnGetIsPreferAltChoose = null,
		},
	) {
		isItemsAltChooseRoll = isItemsAltChooseRoll && !!itemsAltChoose;
		if (isItemsAltChooseRoll) {
			const item = RollerUtil.rollOnArray(itemsAltChoose);

			return this._pGetMagicItemRoll_singleItem({
				item,
				lootGenMagicItems,
				spells,
				magicItemTable,
				itemsAltChoose,
				itemsAltChooseDisplayText,
				isItemsAltChooseRoll,
				fnGetIsPreferAltChoose,
			});
		}

		if (!magicItemTable?.table) {
			return new LootGenMagicItemNull({
				lootGenMagicItems,
				spells,
				magicItemTable,
				itemsAltChoose,
				itemsAltChooseDisplayText,
				isItemsAltChooseRoll,
				fnGetIsPreferAltChoose,
			});
		}

		const rowRoll = RollerUtil.randomise(magicItemTable.diceType ?? 100);
		const row = magicItemTable.table.find(it => rowRoll >= it.min && rowRoll <= (it.max ?? it.min));

		if (row.spellLevel != null) {
			return new LootGenMagicItemSpellScroll({
				lootGenMagicItems,
				spells,
				magicItemTable,
				itemsAltChoose,
				itemsAltChooseDisplayText,
				isItemsAltChooseRoll,
				fnGetIsPreferAltChoose,
				baseEntry: row.item,
				item: await this._pGetMagicItemRoll_pGetItem({nameOrUid: row.item}),
				roll: rowRoll,
				spellLevel: row.spellLevel,
				spell: RollerUtil.rollOnArray(spells.filter(it => it.level === row.spellLevel)),
			});
		}

		if (row.choose?.fromGeneric) {
			const subItems = (await row.choose.fromGeneric.pMap(nameOrUid => this._pGetMagicItemRoll_pGetItem({nameOrUid})))
				.map(it => it.variants.map(({specificVariant}) => specificVariant))
				.flat();

			return new LootGenMagicItemSubItems({
				lootGenMagicItems,
				spells,
				magicItemTable,
				itemsAltChoose,
				itemsAltChooseDisplayText,
				isItemsAltChooseRoll,
				fnGetIsPreferAltChoose,
				baseEntry: row.item ?? `{@item ${row.choose.fromGeneric[0]}}`,
				item: RollerUtil.rollOnArray(subItems),
				roll: rowRoll,
				subItems,
			});
		}

		if (row.choose?.fromGroup) {
			const subItems = (await ((await row.choose.fromGroup.pMap(nameOrUid => this._pGetMagicItemRoll_pGetItem({nameOrUid})))
				.pMap(it => it.items.pMap(x => this._pGetMagicItemRoll_pGetItem({nameOrUid: x})))))
				.flat();

			return new LootGenMagicItemSubItems({
				lootGenMagicItems,
				spells,
				magicItemTable,
				itemsAltChoose,
				itemsAltChooseDisplayText,
				isItemsAltChooseRoll,
				fnGetIsPreferAltChoose,
				baseEntry: row.item ?? `{@item ${row.choose.fromGroup[0]}}`,
				item: RollerUtil.rollOnArray(subItems),
				roll: rowRoll,
				subItems,
			});
		}

		if (row.choose?.fromItems) {
			const subItems = await row.choose?.fromItems.pMap(nameOrUid => this._pGetMagicItemRoll_pGetItem({nameOrUid}));

			return new LootGenMagicItemSubItems({
				lootGenMagicItems,
				spells,
				magicItemTable,
				itemsAltChoose,
				itemsAltChooseDisplayText,
				isItemsAltChooseRoll,
				fnGetIsPreferAltChoose,
				baseEntry: row.item,
				item: RollerUtil.rollOnArray(subItems),
				roll: rowRoll,
				subItems,
			});
		}

		if (row.table) {
			const min = Math.min(...row.table.map(it => it.min));
			const max = Math.max(...row.table.map(it => it.max ?? min));

			const {subRowRoll, subRow, subItem} = await LootGenMagicItemTable.pGetSubRollMeta({
				min,
				max,
				subTable: row.table,
			});

			return new LootGenMagicItemTable({
				lootGenMagicItems,
				spells,
				magicItemTable,
				itemsAltChoose,
				itemsAltChooseDisplayText,
				isItemsAltChooseRoll,
				fnGetIsPreferAltChoose,
				baseEntry: row.item,
				item: subItem,
				roll: rowRoll,
				table: row.table,
				tableMinRoll: min,
				tableMaxRoll: max,
				tableEntry: subRow.item,
				tableRoll: subRowRoll,
			});
		}

		return this._pGetMagicItemRoll_singleItem({
			item: await this._pGetMagicItemRoll_pGetItem({nameOrUid: row.item}),
			lootGenMagicItems,
			spells,
			magicItemTable,
			itemsAltChoose,
			itemsAltChooseDisplayText,
			isItemsAltChooseRoll,
			fnGetIsPreferAltChoose,
			baseEntry: row.item,
			roll: rowRoll,
		});
	}

	static async _pGetMagicItemRoll_singleItem (
		{
			item,
			lootGenMagicItems,
			spells,
			magicItemTable,
			itemsAltChoose,
			itemsAltChooseDisplayText,
			isItemsAltChooseRoll = false,
			fnGetIsPreferAltChoose = null,
			baseEntry,
			roll,
		},
	) {
		baseEntry = baseEntry || item
			? `{@item ${item.name}|${item.source}}`
			: `<span class="help-subtle" title="${LootGenMagicItemNull.TOOLTIP_NOTHING.qq()}">(no item)</span>`;

		if (item?.spellScrollLevel != null) {
			return new LootGenMagicItemSpellScroll({
				lootGenMagicItems,
				spells,
				magicItemTable,
				itemsAltChoose,
				itemsAltChooseDisplayText,
				isItemsAltChooseRoll,
				fnGetIsPreferAltChoose,
				baseEntry,
				item,
				spellLevel: item.spellScrollLevel,
				spell: RollerUtil.rollOnArray(spells.filter(it => it.level === item.spellScrollLevel)),
				roll,
			});
		}

		if (item?.variants?.length) {
			const subItems = item.variants.map(({specificVariant}) => specificVariant);

			return new LootGenMagicItemSubItems({
				lootGenMagicItems,
				spells,
				magicItemTable,
				itemsAltChoose,
				itemsAltChooseDisplayText,
				isItemsAltChooseRoll,
				fnGetIsPreferAltChoose,
				baseEntry: baseEntry,
				item: RollerUtil.rollOnArray(subItems),
				roll,
				subItems,
			});
		}

		return new LootGenMagicItem({
			lootGenMagicItems,
			spells,
			magicItemTable,
			itemsAltChoose,
			itemsAltChooseDisplayText,
			isItemsAltChooseRoll,
			fnGetIsPreferAltChoose,
			baseEntry,
			item,
			roll,
		});
	}

	static async _pGetMagicItemRoll_pGetItem ({nameOrUid}) {
		nameOrUid = nameOrUid.replace(/{@item ([^}]+)}/g, (...m) => m[1]);
		const uid = (nameOrUid.includes("|") ? nameOrUid : `${nameOrUid}|${Parser.SRC_DMG}`).toLowerCase();
		const [name, source] = uid.split("|");
		return DataLoader.pCacheAndGet(UrlUtil.PG_ITEMS, source, UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS]({name, source}));
	}

		constructor (
		{
			lootGenMagicItems,
			spells,
			magicItemTable,
			itemsAltChoose,
			itemsAltChooseDisplayText,
			isItemsAltChooseRoll,
			fnGetIsPreferAltChoose,
			baseEntry,
			item,
			roll,
		},
	) {
		super();
		this._lootGenMagicItems = lootGenMagicItems;
		this._spells = spells;
		this._magicItemTable = magicItemTable;
		this._itemsAltChoose = itemsAltChoose;
		this._itemsAltChooseDisplayText = itemsAltChooseDisplayText;
		this._fnGetIsPreferAltChoose = fnGetIsPreferAltChoose;

		this._state.baseEntry = baseEntry;
		this._state.item = item;
		this._state.roll = roll;
		this._state.isItemsAltChooseRoll = isItemsAltChooseRoll;

		this._$render = null;
	}

	get item () { return this._state.item; }

	getExtensionExportMeta () {
		return {
			page: UrlUtil.PG_ITEMS,
			entity: this._state.item,
		};
	}

	async _pDoReroll ({isAltRoll = false} = {}) {
		const nxt = await this.constructor.pGetMagicItemRoll({
			lootGenMagicItems: this._lootGenMagicItems,
			spells: this._spells,
			magicItemTable: this._magicItemTable,
			itemsAltChoose: this._itemsAltChoose,
			itemsAltChooseDisplayText: this._itemsAltChooseDisplayText,
			isItemsAltChooseRoll: isAltRoll,
			fnGetIsPreferAltChoose: this._fnGetIsPreferAltChoose,
		});

		this._lootGenMagicItems.splice(this._lootGenMagicItems.indexOf(this), 1, nxt);

		if (!this._$render) return;
		this._$render.replaceWith(nxt.$getRender());
	}

	_$getBtnReroll () {
		if (!this._magicItemTable && !this._itemsAltChoose) return null;

		const isAltModeDefault = this._fnGetIsPreferAltChoose && this._fnGetIsPreferAltChoose();
		const title = this._itemsAltChoose
			? isAltModeDefault ? `SHIFT to roll on Magic Item Table ${this._magicItemTable.type}` : `SHIFT to roll ${Parser.getArticle(this._itemsAltChooseDisplayText)} ${this._itemsAltChooseDisplayText} item`
			: null;
		return $(`<span class="roller render-roller" ${title ? `title="${title}"` : ""}>[reroll]</span>`)
			.mousedown(evt => evt.preventDefault())
			.click(evt => this._pDoReroll({isAltRoll: isAltModeDefault ? !evt.shiftKey : evt.shiftKey}));
	}

	$getRender () {
		if (this._$render) return this._$render;
		return this._$render = this._$getRender();
	}

	_$getRender () {
		const $dispBaseEntry = this._$getRender_$getDispBaseEntry();
		const $dispRoll = this._$getRender_$getDispRoll();

		const $btnReroll = this._$getBtnReroll();

		return $$`<li class="split-v-center">
			<div class="ve-flex-v-center ve-flex-wrap pr-3">
				${$dispBaseEntry}
				${$dispRoll}
			</div>
			${$btnReroll}
		</li>`;
	}

	_$getRender_$getDispBaseEntry ({prop = "baseEntry"} = {}) {
		const $dispBaseEntry = $(`<div class="mr-2"></div>`);
		const hkBaseEntry = () => $dispBaseEntry.html(Renderer.get().render(this._state.isItemsAltChooseRoll ? `{@i ${this._state[prop]}}` : this._state[prop]));
		this._addHookBase(prop, hkBaseEntry);
		hkBaseEntry();
		return $dispBaseEntry;
	}

	_$getRender_$getDispRoll ({prop = "roll"} = {}) {
		const $dispRoll = $(`<div class="ve-muted"></div>`);
		const hkRoll = () => $dispRoll.text(this._state.isItemsAltChooseRoll ? `(${this._itemsAltChooseDisplayText} item)` : `(Rolled ${this._state[prop]})`);
		this._addHookBase(prop, hkRoll);
		hkRoll();
		return $dispRoll;
	}

	_getDefaultState () {
		return {
			...super._getDefaultState(),
			baseEntry: null,
			item: null,
			roll: null,
			isItemsAltChooseRoll: false,
		};
	}
}

class LootGenMagicItemNull extends LootGenMagicItem {
	static TOOLTIP_NOTHING = `Failed to generate a result! This is normally due to all potential matches being filtered out. You may want to adjust your filters to be more permissive.`;

	getExtensionExportMeta () { return null; }

	_$getRender () {
		return $$`<li class="split-v-center">
			<div class="ve-flex-v-center ve-flex-wrap ve-muted help-subtle" title="${this.constructor.TOOLTIP_NOTHING.qq()}">&mdash;</div>
		</li>`;
	}
}

class LootGenMagicItemSpellScroll extends LootGenMagicItem {
	constructor (
		{
			spellLevel,
			spell,
			...others
		},
	) {
		super(others);

		this._state.spellLevel = spellLevel;
		this._state.spell = spell;
	}

	getExtensionExportMeta () {
		if (this._state.spell == null) return null;

		return {
			page: UrlUtil.PG_SPELLS,
			entity: this._state.spell,
			options: {
				isSpellScroll: true,
			},
		};
	}

	_$getRender () {
		const $dispBaseEntry = this._$getRender_$getDispBaseEntry();
		const $dispRoll = this._$getRender_$getDispRoll();

		const $btnRerollSpell = $(`<span class="roller render-roller mr-2">[reroll]</span>`)
			.mousedown(evt => evt.preventDefault())
			.click(() => {
				this._state.spell = RollerUtil.rollOnArray(this._spells.filter(it => it.level === this._state.spellLevel));
			});

		const $dispSpell = $(`<div class="no-wrap"></div>`);
		const hkSpell = () => {
			if (!this._state.spell) return $dispSpell.html(`<span class="help-subtle" title="${LootGenMagicItemNull.TOOLTIP_NOTHING.qq()}">(no spell)</span>`);
			$dispSpell.html(Renderer.get().render(`{@spell ${this._state.spell.name}|${this._state.spell.source}}`));
		};
		this._addHookBase("spell", hkSpell);
		hkSpell();

		const $btnReroll = this._$getBtnReroll();

		return $$`<li class="split-v-center">
			<div class="ve-flex-v-center ve-flex-wrap pr-3">
				${$dispBaseEntry}
				<div class="ve-flex-v-center italic mr-2">
					<span>(</span>
					${$btnRerollSpell}
					${$dispSpell}
					<span class="ve-muted mx-2 no-wrap">-or-</span>
					<div class="no-wrap">${Renderer.get().render(`{@filter see all ${Parser.spLevelToFullLevelText(this._state.spellLevel, true)} spells|spells|level=${this._state.spellLevel}}`)}</div>
					<span>)</span>
				</div>
				${$dispRoll}
			</div>
			${$btnReroll}
		</li>`;
	}

	_getDefaultState () {
		return {
			...super._getDefaultState(),
			spellLevel: null,
			spell: null,
		};
	}
}

class LootGenMagicItemSubItems extends LootGenMagicItem {
	constructor (
		{
			subItems,
			...others
		},
	) {
		super(others);
		this._subItems = subItems;
	}

	_$getRender () {
		const $dispBaseEntry = this._$getRender_$getDispBaseEntry();
		const $dispRoll = this._$getRender_$getDispRoll();

		const $btnRerollSubItem = $(`<span class="roller render-roller mr-2">[reroll]</span>`)
			.mousedown(evt => evt.preventDefault())
			.click(() => {
				this._state.item = RollerUtil.rollOnArray(this._subItems);
			});

		const $dispSubItem = $(`<div></div>`);
		const hkItem = () => $dispSubItem.html(Renderer.get().render(`{@item ${this._state.item.name}|${this._state.item.source}}`));
		this._addHookBase("item", hkItem);
		hkItem();

		const $btnReroll = this._$getBtnReroll();

		return $$`<li class="split-v-center">
			<div class="ve-flex-v-center ve-flex-wrap pr-3">
				${$dispBaseEntry}
				<div class="ve-flex-v-center italic mr-2">
					<span>(</span>
					${$btnRerollSubItem}
					${$dispSubItem}
					<span>)</span>
				</div>
				${$dispRoll}
			</div>
			${$btnReroll}
		</li>`;
	}
}

class LootGenMagicItemTable extends LootGenMagicItem {
	static async pGetSubRollMeta ({min, max, subTable}) {
		const subRowRoll = RollerUtil.randomise(max, min);
		const subRow = subTable.find(it => subRowRoll >= it.min && subRowRoll <= (it.max ?? it.min));

		return {
			subRowRoll,
			subRow,
			subItem: await this._pGetMagicItemRoll_pGetItem({nameOrUid: subRow.item}),
		};
	}

	constructor (
		{
			table,
			tableMinRoll,
			tableMaxRoll,
			tableEntry,
			tableRoll,
			...others
		},
	) {
		super(others);
		this._table = table;
		this._tableMinRoll = tableMinRoll;
		this._tableMaxRoll = tableMaxRoll;
		this._state.tableEntry = tableEntry;
		this._state.tableRoll = tableRoll;
	}

	_$getRender () {
		const $dispBaseEntry = this._$getRender_$getDispBaseEntry();
		const $dispRoll = this._$getRender_$getDispRoll();

		const $dispTableEntry = this._$getRender_$getDispBaseEntry({prop: "tableEntry"});
		const $dispTableRoll = this._$getRender_$getDispRoll({prop: "tableRoll"});

		const $btnReroll = this._$getBtnReroll();

		const $btnRerollSub = $(`<span class="roller render-roller ve-small ve-self-flex-end">[reroll]</span>`)
			.mousedown(evt => evt.preventDefault())
			.click(async () => {
				const {subRowRoll, subRow, subItem} = await LootGenMagicItemTable.pGetSubRollMeta({
					min: this._tableMinRoll,
					max: this._tableMaxRoll,
					subTable: this._table,
				});

				this._state.item = subItem;
				this._state.tableEntry = subRow.item;
				this._state.tableRoll = subRowRoll;
			});

		return $$`<li class="ve-flex-col">
			<div class="split-v-center">
				<div class="ve-flex-v-center ve-flex-wrap pr-3">
					${$dispBaseEntry}
					${$dispRoll}
				</div>
				${$btnReroll}
			</div>
			<div class="split-v-center pl-2">
				<div class="ve-flex-v-center ve-flex-wrap pr-3">
					<span class="ml-1 mr-2">&rarr;</span>
					${$dispTableEntry}
					${$dispTableRoll}
				</div>
				${$btnRerollSub}
			</div>
		</li>`;
	}
}

"use strict";

let Omnidexer$1 = class Omnidexer {
	constructor (id = 0) {
				this._index = [];
		this.id = id;
		this._metaMap = {};
		this._metaIndices = {};
	}

	getIndex () {
		return {
			x: this._index,
			m: this._metaMap,
		};
	}

	static decompressIndex (indexGroup) {
		const {x: index, m: metadata} = indexGroup;

		const props = new Set();

				const lookup = {};
		Object.keys(metadata).forEach(k => {
			props.add(k);
			Object.entries(metadata[k]).forEach(([kk, vv]) => (lookup[k] = lookup[k] || {})[vv] = kk);
		});

		index.forEach(it => Object.keys(it).filter(k => props.has(k))
			.forEach(k => it[k] = lookup[k][it[k]] ?? it[k]));
		return index;
	}

	static getProperty (obj, withDots) {
		return withDots.split(".").reduce((o, i) => o[i], obj);
	}

		async pAddToIndex (arbiter, json, options) {
		options = options || {};
		const index = this._index;

		if (arbiter.postLoad) json = arbiter.postLoad(json);

		const dataArr = Omnidexer$1.getProperty(json, arbiter.listProp);
		if (!dataArr) return;

		const state = {arbiter, index, options};

		let ixOffset = 0;
		for (let ix = 0; ix < dataArr.length; ++ix) {
			const it = dataArr[ix];

			const name = Omnidexer$1.getProperty(it, arbiter.primary || "name");
			await this._pAddToIndex_pHandleItem(state, it, ix + ixOffset, name);

			if (it.alias?.length) {
				for (const a of it.alias) {
					ixOffset++;
					await this._pAddToIndex_pHandleItem(state, it, ix + ixOffset, a);
				}
			}
		}
	}

	async _pAddToIndex_pHandleItem (state, ent, ix, name) {
		if (ent.noDisplay) return;

		const {arbiter, index, options} = state;

		if (name) name = name.toAscii();

		const toAdd = await this._pAddToIndex_pGetToAdd(state, ent, {n: name}, ix);

		if ((options.isNoFilter || (!arbiter.include && !(arbiter.filter && arbiter.filter(ent))) || (!arbiter.filter && (!arbiter.include || arbiter.include(ent)))) && !arbiter.isOnlyDeep) index.push(toAdd);

		const primary = {it: ent, ix: ix, parentName: name};
		const deepItems = await arbiter.pGetDeepIndex(this, primary, ent);
		for (const item of deepItems) {
			const toAdd = await this._pAddToIndex_pGetToAdd(state, ent, item);
			if (!arbiter.filter || !arbiter.filter(ent)) index.push(toAdd);
		}
	}

	async _pAddToIndex_pGetToAdd (state, ent, toMerge, i) {
		const {arbiter, options} = state;

		const src = Omnidexer$1.getProperty(ent, arbiter.source || "source");

		const hash = arbiter.hashBuilder
			? arbiter.hashBuilder(ent, i)
			: (UrlUtil.URL_TO_HASH_BUILDER[arbiter.listProp])(ent);

		const id = this.id++;

		const indexDoc = {
			id,
			c: arbiter.category,
			u: hash,
			p: Omnidexer$1.getProperty(ent, arbiter.page || "page"),
		};
		if (src != null) indexDoc.s = this.getMetaId("s", src);
		if (arbiter.isHover) indexDoc.h = 1;
		if (arbiter.isFauxPage) indexDoc.hx = 1;
		if (ent.srd) indexDoc.r = 1;

		if (src) {
			if (options.isIncludeTag) {
				indexDoc.t = this.getMetaId("t", Parser.getPropTag(arbiter.listProp));
			}

			if (options.isIncludeUid) {
				const tag = Parser.getPropTag(arbiter.listProp);
				const uid = DataUtil.proxy.getUid(arbiter.listProp, ent);
				indexDoc.uu = DataUtil.proxy.getNormalizedUid(arbiter.listProp, uid, tag);
			}

			if (options.isIncludeImg) {
								if (arbiter.fnGetToken) {
					indexDoc.m = arbiter.fnGetToken(ent);
				}

				if (!indexDoc.m) {
					const fluff = await Renderer.hover.pGetHoverableFluff(arbiter.fluffBaseListProp || arbiter.listProp, src, hash, {isSilent: true});
					if (fluff?.images?.length) {
						indexDoc.m = Renderer.utils.getMediaUrl(fluff.images[0], "href", "img");
					}
				}

				if (indexDoc.m) {
					indexDoc.m = indexDoc.m.replace(/^img\//, "");
				}
			}
		}

		if (options.alt) {
			if (options.alt.additionalProperties) Object.entries(options.alt.additionalProperties).forEach(([k, getV]) => indexDoc[k] = getV(ent));
		}

		Object.assign(indexDoc, toMerge);

		return indexDoc;
	}

		pushToIndex (item) {
		item.id = this.id++;
		this._index.push(item);
	}

	getMetaId (k, v) {
		this._metaMap[k] = this._metaMap[k] || {};
				if (this._metaMap[k][v] != null) return this._metaMap[k][v];
		else {
			this._metaIndices[k] = this._metaIndices[k] || 0;
			this._metaMap[k][v] = this._metaIndices[k];
			const out = this._metaIndices[k];
			this._metaIndices[k]++;
			return out;
		}
	}
};

class IndexableDirectory {
		constructor (opts) {
		this.category = opts.category;
		this.dir = opts.dir;
		this.primary = opts.primary;
		this.source = opts.source;
		this.listProp = opts.listProp;
		this.brewProp = opts.brewProp;
		this.baseUrl = opts.baseUrl;
		this.isHover = opts.isHover;
		this.alternateIndexes = opts.alternateIndexes;
		this.isOnlyDeep = opts.isOnlyDeep;
		this.pFnPreProcBrew = opts.pFnPreProcBrew;
		this.fnGetToken = opts.fnGetToken;
	}

	pGetDeepIndex () { return []; }
}

class IndexableDirectoryBestiary extends IndexableDirectory {
	constructor () {
		super({
			category: Parser.CAT_ID_CREATURE,
			dir: "bestiary",
			primary: "name",
			source: "source",
			listProp: "monster",
			baseUrl: "bestiary.html",
			isHover: true,
			fnGetToken: (ent) => {
				if (!ent.tokenUrl && !ent.hasToken) return null;
				return Renderer.monster.getTokenUrl(ent);
			},
		});
	}
}

class IndexableDirectorySpells extends IndexableDirectory {
	constructor () {
		super({
			category: Parser.CAT_ID_SPELL,
			dir: "spells",
			primary: "name",
			source: "source",
			listProp: "spell",
			baseUrl: "spells.html",
			isHover: true,
			alternateIndexes: {
				spell: {
					additionalProperties: {
						lvl: spell => spell.level,
					},
				},
			},
		});
	}
}

class IndexableDirectoryClass extends IndexableDirectory {
	constructor () {
		super({
			category: Parser.CAT_ID_CLASS,
			dir: "class",
			primary: "name",
			source: "source",
			listProp: "class",
			baseUrl: "classes.html",
			isHover: true,
		});
	}
}

class IndexableDirectorySubclass extends IndexableDirectory {
	constructor () {
		super({
			category: Parser.CAT_ID_SUBCLASS,
			dir: "class",
			primary: "name",
			source: "source",
			listProp: "subclass",
			brewProp: "subclass",
			baseUrl: "classes.html",
			isHover: true,
			isOnlyDeep: true,
		});
	}

	pGetDeepIndex (indexer, primary, sc) {
		return [
			{
				b: sc.name,
				n: `${sc.name} (${sc.className})`,
				s: indexer.getMetaId("s", sc.source),
				u: `${UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES]({name: sc.className, source: sc.classSource})}${HASH_PART_SEP}${UrlUtil.getClassesPageStatePart({subclass: sc})}`,
				p: sc.page,
			},
		];
	}
}

class IndexableDirectoryClassFeature extends IndexableDirectory {
	constructor () {
		super({
			category: Parser.CAT_ID_CLASS_FEATURE,
			dir: "class",
			primary: "name",
			source: "source",
			listProp: "classFeature",
			baseUrl: "classes.html",
			isOnlyDeep: true,
			isHover: true,
		});
	}

	async pGetDeepIndex (indexer, primary, it) {
				const ixFeature = 0;
		const classPageHash = `${UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES]({name: it.className, source: it.classSource})}${HASH_PART_SEP}${UrlUtil.getClassesPageStatePart({feature: {ixLevel: it.level - 1, ixFeature}})}`;
		return [
			{
				n: `${it.className} ${it.level}; ${it.name}`,
				s: it.source,
				u: UrlUtil.URL_TO_HASH_BUILDER["classFeature"](it),
				uh: classPageHash,
				p: it.page,
			},
		];
	}
}

class IndexableDirectorySubclassFeature extends IndexableDirectory {
	constructor () {
		super({
			category: Parser.CAT_ID_SUBCLASS_FEATURE,
			dir: "class",
			primary: "name",
			source: "source",
			listProp: "subclassFeature",
			baseUrl: "classes.html",
			isOnlyDeep: true,
			isHover: true,
		});
	}

	async pGetDeepIndex (indexer, primary, it) {
		const ixFeature = 0;
		const pageStateOpts = {
			subclass: {shortName: it.subclassShortName, source: it.source},
			feature: {ixLevel: it.level - 1, ixFeature},
		};
		const classPageHash = `${UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES]({name: it.className, source: it.classSource})}${HASH_PART_SEP}${UrlUtil.getClassesPageStatePart(pageStateOpts)}`;
		return [
			{
				n: `${it.subclassShortName} ${it.className} ${it.level}; ${it.name}`,
				s: it.source,
				u: UrlUtil.URL_TO_HASH_BUILDER["subclassFeature"](it),
				uh: classPageHash,
				p: it.page,
			},
		];
	}
}

Omnidexer$1.TO_INDEX__FROM_INDEX_JSON = [
	new IndexableDirectoryBestiary(),
	new IndexableDirectorySpells(),
	new IndexableDirectoryClass(),
	new IndexableDirectorySubclass(),
	new IndexableDirectoryClassFeature(),
	new IndexableDirectorySubclassFeature(),
];

class IndexableFile {
		constructor (opts) {
		this.category = opts.category;
		this.file = opts.file;
		this.primary = opts.primary;
		this.source = opts.source;
		this.page = opts.page;
		this.listProp = opts.listProp;
		this.fluffBaseListProp = opts.fluffBaseListProp;
		this.baseUrl = opts.baseUrl;
		this.hashBuilder = opts.hashBuilder;
		this.test_extraIndex = opts.test_extraIndex;
		this.isHover = opts.isHover;
		this.filter = opts.filter;
		this.include = opts.include;
		this.postLoad = opts.postLoad;
		this.isOnlyDeep = opts.isOnlyDeep;
		this.additionalIndexes = opts.additionalIndexes;
		this.isSkipBrew = opts.isSkipBrew;
		this.pFnPreProcBrew = opts.pFnPreProcBrew;
		this.fnGetToken = opts.fnGetToken;
		this.isFauxPage = !!opts.isFauxPage;
	}

		pGetDeepIndex () { return []; }
}

class IndexableFileBackgrounds extends IndexableFile {
	constructor () {
		super({
			category: Parser.CAT_ID_BACKGROUND,
			file: "backgrounds.json",
			listProp: "background",
			baseUrl: "backgrounds.html",
			isHover: true,
		});
	}
}

class IndexableFileItemsBase extends IndexableFile {
	constructor () {
		super({
			category: Parser.CAT_ID_ITEM,
			file: "items-base.json",
			listProp: "baseitem",
			fluffBaseListProp: "item",
			baseUrl: "items.html",
			isHover: true,
		});
	}
}

class IndexableFileItems extends IndexableFile {
	constructor () {
		super({
			category: Parser.CAT_ID_ITEM,
			file: "items.json",
			listProp: "item",
			baseUrl: "items.html",
			isHover: true,
		});
	}
}

class IndexableFileItemGroups extends IndexableFile {
	constructor () {
		super({
			category: Parser.CAT_ID_ITEM,
			file: "items.json",
			listProp: "itemGroup",
			fluffBaseListProp: "item",
			baseUrl: "items.html",
			isHover: true,
		});
	}
}

class IndexableFileMagicVariants extends IndexableFile {
	constructor () {
		super({
			category: Parser.CAT_ID_ITEM,
			file: "magicvariants.json",
			source: "inherits.source",
			page: "inherits.page",
			listProp: "magicvariant",
			fluffBaseListProp: "item",
			baseUrl: "items.html",
			hashBuilder: (it) => {
				return UrlUtil.encodeForHash([it.name, it.inherits.source]);
			},
			additionalIndexes: {
				item: async (indexer, rawVariants) => {
					const specVars = await (async () => {
						const baseItemJson = await DataUtil.loadJSON(`data/items-base.json`);
						const rawBaseItems = {...baseItemJson, baseitem: [...baseItemJson.baseitem]};

						const prerelease = typeof PrereleaseUtil !== "undefined" ? await PrereleaseUtil.pGetBrewProcessed() : {};
						if (prerelease.baseitem) rawBaseItems.baseitem.push(...prerelease.baseitem);

						const brew = typeof BrewUtil2 !== "undefined" ? await BrewUtil2.pGetBrewProcessed() : {};
						if (brew.baseitem) rawBaseItems.baseitem.push(...brew.baseitem);

						return Renderer.item.getAllIndexableItems(rawVariants, rawBaseItems);
					})();
					return specVars.map(sv => {
						const out = {
							c: Parser.CAT_ID_ITEM,
							u: UrlUtil.encodeForHash([sv.name, sv.source]),
							s: indexer.getMetaId("s", sv.source),
							n: sv.name,
							h: 1,
							p: sv.page,
						};
						if (sv.genericVariant) {
														out.zg = {
								n: indexer.getMetaId("n", sv.genericVariant.name),
								s: indexer.getMetaId("s", sv.genericVariant.source),
							};
						}
						return out;
					});
				},
			},
			isHover: true,
		});
	}
}

class IndexableFileConditions extends IndexableFile {
	constructor () {
		super({
			category: Parser.CAT_ID_CONDITION,
			file: "conditionsdiseases.json",
			listProp: "condition",
			baseUrl: "conditionsdiseases.html",
			isHover: true,
		});
	}
}

class IndexableFileDiseases extends IndexableFile {
	constructor () {
		super({
			category: Parser.CAT_ID_DISEASE,
			file: "conditionsdiseases.json",
			listProp: "disease",
			baseUrl: "conditionsdiseases.html",
			isHover: true,
		});
	}
}

class IndexableFileStatuses extends IndexableFile {
	constructor () {
		super({
			category: Parser.CAT_ID_STATUS,
			file: "conditionsdiseases.json",
			listProp: "status",
			baseUrl: "conditionsdiseases.html",
			isHover: true,
		});
	}
}

class IndexableFileFeats extends IndexableFile {
	constructor () {
		super({
			category: Parser.CAT_ID_FEAT,
			file: "feats.json",
			listProp: "feat",
			baseUrl: "feats.html",
			isHover: true,
		});
	}
}

class IndexableFileOptFeatures_EldritchInvocations extends IndexableFile {
	constructor () {
		super({
			category: Parser.CAT_ID_ELDRITCH_INVOCATION,
			file: "optionalfeatures.json",
			listProp: "optionalfeature",
			baseUrl: "optionalfeatures.html",
			isHover: true,
			include: (it) => it.featureType.includes("EI"),
		});
	}
}

class IndexableFileOptFeatures_Metamagic extends IndexableFile {
	constructor () {
		super({
			category: Parser.CAT_ID_METAMAGIC,
			file: "optionalfeatures.json",
			listProp: "optionalfeature",
			baseUrl: "optionalfeatures.html",
			isHover: true,
			include: (it) => it.featureType.includes("MM"),
		});
	}
}

class IndexableFileOptFeatures_ManeuverBattlemaster extends IndexableFile {
	constructor () {
		super({
			category: Parser.CAT_ID_MANEUVER_BATTLEMASTER,
			file: "optionalfeatures.json",
			listProp: "optionalfeature",
			baseUrl: "optionalfeatures.html",
			isHover: true,
			include: (it) => it.featureType.includes("MV:B"),
		});
	}
}

class IndexableFileOptFeatures_ManeuverCavalier extends IndexableFile {
	constructor () {
		super({
			category: Parser.CAT_ID_MANEUVER_CAVALIER,
			file: "optionalfeatures.json",
			listProp: "optionalfeature",
			baseUrl: "optionalfeatures.html",
			isHover: true,
			include: (it) => it.featureType.includes("MV:C2-UA"),
		});
	}
}

class IndexableFileOptFeatures_ArcaneShot extends IndexableFile {
	constructor () {
		super({
			category: Parser.CAT_ID_ARCANE_SHOT,
			file: "optionalfeatures.json",
			listProp: "optionalfeature",
			baseUrl: "optionalfeatures.html",
			isHover: true,
			include: (it) => it.featureType.includes("AS:V1-UA") || it.featureType.includes("AS:V2-UA") || it.featureType.includes("AS"),
		});
	}
}

class IndexableFileOptFeatures_Other extends IndexableFile {
	constructor () {
		super({
			category: Parser.CAT_ID_OPTIONAL_FEATURE_OTHER,
			file: "optionalfeatures.json",
			listProp: "optionalfeature",
			baseUrl: "optionalfeatures.html",
			isHover: true,
			include: (it) => {
								return it.featureType.includes("OTH") || it.featureType.some(it => !Parser.OPT_FEATURE_TYPE_TO_FULL[it]);
			},
		});
	}
}

class IndexableFileOptFeatures_FightingStyle extends IndexableFile {
	constructor () {
		super({
			category: Parser.CAT_ID_FIGHTING_STYLE,
			file: "optionalfeatures.json",
			listProp: "optionalfeature",
			baseUrl: "optionalfeatures.html",
			isHover: true,
			include: (it) => it.featureType.includes("FS:F") || it.featureType.includes("FS:B") || it.featureType.includes("FS:R") || it.featureType.includes("FS:P"),
		});
	}
}

class IndexableFileOptFeatures_PactBoon extends IndexableFile {
	constructor () {
		super({
			category: Parser.CAT_ID_PACT_BOON,
			file: "optionalfeatures.json",
			listProp: "optionalfeature",
			baseUrl: "optionalfeatures.html",
			isHover: true,
			include: (it) => it.featureType.includes("PB"),
		});
	}
}

class IndexableFileOptFeatures_ElementalDiscipline extends IndexableFile {
	constructor () {
		super({
			category: Parser.CAT_ID_ELEMENTAL_DISCIPLINE,
			file: "optionalfeatures.json",
			listProp: "optionalfeature",
			baseUrl: "optionalfeatures.html",
			isHover: true,
			include: (it) => it.featureType.includes("ED"),
		});
	}
}

class IndexableFileOptFeatures_ArtificerInfusion extends IndexableFile {
	constructor () {
		super({
			category: Parser.CAT_ID_ARTIFICER_INFUSION,
			file: "optionalfeatures.json",
			listProp: "optionalfeature",
			baseUrl: "optionalfeatures.html",
			isHover: true,
			include: (it) => it.featureType.includes("AI"),
		});
	}
}

class IndexableFileOptFeatures_OnomancyResonant extends IndexableFile {
	constructor () {
		super({
			category: Parser.CAT_ID_ONOMANCY_RESONANT,
			file: "optionalfeatures.json",
			listProp: "optionalfeature",
			baseUrl: "optionalfeatures.html",
			isHover: true,
			include: (it) => it.featureType.includes("OR"),
		});
	}
}

class IndexableFileOptFeatures_RuneKnightRune extends IndexableFile {
	constructor () {
		super({
			category: Parser.CAT_ID_RUNE_KNIGHT_RUNE,
			file: "optionalfeatures.json",
			listProp: "optionalfeature",
			baseUrl: "optionalfeatures.html",
			isHover: true,
			include: (it) => it.featureType.includes("RN"),
		});
	}
}

class IndexableFileOptFeatures_AlchemicalFormula extends IndexableFile {
	constructor () {
		super({
			category: Parser.CAT_ID_ALCHEMICAL_FORMULA,
			file: "optionalfeatures.json",
			listProp: "optionalfeature",
			baseUrl: "optionalfeatures.html",
			isHover: true,
			include: (it) => it.featureType.includes("AF"),
		});
	}
}

class IndexableFileOptFeatures_Maneuver extends IndexableFile {
	constructor () {
		super({
			category: Parser.CAT_ID_MANEUVER,
			file: "optionalfeatures.json",
			listProp: "optionalfeature",
			baseUrl: "optionalfeatures.html",
			isHover: true,
			include: (it) => it.featureType.includes("MV"),
		});
	}
}

class IndexableFilePsionics extends IndexableFile {
	constructor () {
		super({
			category: Parser.CAT_ID_PSIONIC,
			file: "psionics.json",
			listProp: "psionic",
			baseUrl: "psionics.html",
			isHover: true,
		});
	}

	pGetDeepIndex (indexer, primary, it) {
		if (!it.modes) return [];
		return it.modes.map(m => ({d: 1, n: `${primary.parentName}; ${m.name}`}));
	}
}

class IndexableFileRaces extends IndexableFile {
	constructor () {
		super({
			category: Parser.CAT_ID_RACE,
			file: "races.json",
			listProp: "race",
			baseUrl: "races.html",
			isHover: true,
			postLoad: data => {
				return DataUtil.race.getPostProcessedSiteJson(data, {isAddBaseRaces: true});
			},
			pFnPreProcBrew: async prereleaseBrew => {
				if (!prereleaseBrew.race?.length && !prereleaseBrew.subrace?.length) return prereleaseBrew;

				const site = await DataUtil.race.loadRawJSON();

				return DataUtil.race.getPostProcessedPrereleaseBrewJson(site, prereleaseBrew, {isAddBaseRaces: true});
			},
		});
	}
}

class IndexableFileRewards extends IndexableFile {
	constructor () {
		super({
			category: Parser.CAT_ID_OTHER_REWARD,
			file: "rewards.json",
			listProp: "reward",
			baseUrl: "rewards.html",
			isHover: true,
		});
	}
}

class IndexableFileVariantRules extends IndexableFile {
	constructor () {
		super({
			category: Parser.CAT_ID_VARIANT_OPTIONAL_RULE,
			file: "variantrules.json",
			listProp: "variantrule",
			baseUrl: "variantrules.html",
			isHover: true,
		});
	}
}
class IndexableFileVariantRulesGenerated extends IndexableFile {
	constructor () {
		super({
			category: Parser.CAT_ID_VARIANT_OPTIONAL_RULE,
			file: "generated/gendata-variantrules.json",
			listProp: "variantrule",
			baseUrl: "variantrules.html",
			isHover: true,
			isSkipBrew: true,
		});
	}
}

class IndexableFileAdventures extends IndexableFile {
	constructor () {
		super({
			category: Parser.CAT_ID_ADVENTURE,
			file: "adventures.json",
			source: "id",
			listProp: "adventure",
			baseUrl: "adventure.html",
		});
	}
}

class IndexableFileBooks extends IndexableFile {
	constructor () {
		super({
			category: Parser.CAT_ID_BOOK,
			file: "books.json",
			source: "id",
			listProp: "book",
			baseUrl: "book.html",
		});
	}
}

let IndexableFileQuickReference$1 = class IndexableFileQuickReference extends IndexableFile {
	constructor () {
		super({
			category: Parser.CAT_ID_QUICKREF,
			file: "generated/bookref-quick.json",
			listProp: "data.bookref-quick",
			baseUrl: "quickreference.html",
			hashBuilder: (it, ix) => `bookref-quick,${ix}`,
			isOnlyDeep: true,
			isHover: true,
		});

		this._walker = MiscUtil.getWalker();
	}

	static getChapterNameMetas (it, {isRequireQuickrefFlag = true} = {}) {
		const trackedNames = [];
		const renderer = Renderer.get().setDepthTracker(trackedNames);
		renderer.render(it);

		const nameCounts = {};
		trackedNames.forEach(meta => {
			const lowName = meta.name.toLowerCase();
			nameCounts[lowName] = nameCounts[lowName] || 0;
			nameCounts[lowName]++;
			meta.ixBook = nameCounts[lowName] - 1;
		});

		return trackedNames
			.filter(it => {
				if (!isRequireQuickrefFlag) return true;

				if (!it.data) return false;
				return it.data.quickref != null || it.data.quickrefIndex;
			});
	}

	pGetDeepIndex (indexer, primary, it) {
		const out = it.entries
			.map(it => {
				return IndexableFileQuickReference$1.getChapterNameMetas(it).map(nameMeta => {
					return [
						IndexableFileQuickReference$1._getDeepDoc(indexer, primary, nameMeta),
						...(nameMeta.alias || []).map(alias => IndexableFileQuickReference$1._getDeepDoc(indexer, primary, nameMeta, alias)),
					];
				}).flat();
			})
			.flat();

		const seen = new Set();
		return out.filter(it => {
			if (!seen.has(it.u)) {
				seen.add(it.u);
				return true;
			}
			return false;
		});
	}

	static _getDeepDoc (indexer, primary, nameMeta, alias) {
		const hash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_QUICKREF]({
			name: nameMeta.name,
			ixChapter: primary.ix,
			ixHeader: nameMeta.ixBook,
		});

		return {
			n: alias || nameMeta.name,
			u: hash,
			s: indexer.getMetaId("s", nameMeta.source),
			p: nameMeta.page,
		};
	}
};

class IndexableFileDeities extends IndexableFile {
	constructor () {
		super({
			category: Parser.CAT_ID_DEITY,
			file: "deities.json",
			postLoad: DataUtil.deity.doPostLoad,
			listProp: "deity",
			baseUrl: "deities.html",
			isHover: true,
			filter: (it) => it.reprinted,
		});
	}
}

class IndexableFileObjects extends IndexableFile {
	constructor () {
		super({
			category: Parser.CAT_ID_OBJECT,
			file: "objects.json",
			listProp: "object",
			baseUrl: "objects.html",
			isHover: true,
			fnGetToken: (ent) => {
				if (!ent.tokenUrl && !ent.hasToken) return null;
				return Renderer.object.getTokenUrl(ent);
			},
		});
	}
}

class IndexableFileTraps extends IndexableFile {
	constructor () {
		super({
			category: Parser.CAT_ID_TRAP,
			file: "trapshazards.json",
			listProp: "trap",
			baseUrl: "trapshazards.html",
			isHover: true,
		});
	}
}

class IndexableFileHazards extends IndexableFile {
	constructor () {
		super({
			category: Parser.CAT_ID_HAZARD,
			file: "trapshazards.json",
			listProp: "hazard",
			baseUrl: "trapshazards.html",
			isHover: true,
		});
	}
}

class IndexableFileCults extends IndexableFile {
	constructor () {
		super({
			category: Parser.CAT_ID_CULT,
			file: "cultsboons.json",
			listProp: "cult",
			baseUrl: "cultsboons.html",
			isHover: true,
		});
	}
}

class IndexableFileBoons extends IndexableFile {
	constructor () {
		super({
			category: Parser.CAT_ID_BOON,
			file: "cultsboons.json",
			listProp: "boon",
			baseUrl: "cultsboons.html",
			isHover: true,
		});
	}
}

class IndexableFileTables extends IndexableFile {
	constructor () {
		super({
			category: Parser.CAT_ID_TABLE,
			file: "tables.json",
			listProp: "table",
			baseUrl: "tables.html",
			isHover: true,
		});
	}
}

class IndexableFileTablesGenerated extends IndexableFile {
	constructor () {
		super({
			category: Parser.CAT_ID_TABLE,
			file: "generated/gendata-tables.json",
			listProp: "table",
			baseUrl: "tables.html",
			isHover: true,
			isSkipBrew: true,
		});
	}
}

class IndexableFileTableGroups extends IndexableFile {
	constructor () {
		super({
			category: Parser.CAT_ID_TABLE_GROUP,
			file: "generated/gendata-tables.json",
			listProp: "tableGroup",
			baseUrl: "tables.html",
			isHover: true,
		});
	}
}

class IndexableFileVehicles extends IndexableFile {
	constructor () {
		super({
			category: Parser.CAT_ID_VEHICLE,
			file: "vehicles.json",
			listProp: "vehicle",
			baseUrl: "vehicles.html",
			isHover: true,
			fnGetToken: (ent) => {
				if (!ent.tokenUrl && !ent.hasToken) return null;
				return Renderer.vehicle.getTokenUrl(ent);
			},
		});
	}
}

class IndexableFileVehicles_ShipUpgrade extends IndexableFile {
	constructor () {
		super({
			category: Parser.CAT_ID_SHIP_UPGRADE,
			file: "vehicles.json",
			listProp: "vehicleUpgrade",
			baseUrl: "vehicles.html",
			isHover: true,
			include: (it) => it.upgradeType.includes("SHP:H") || it.upgradeType.includes("SHP:M") || it.upgradeType.includes("SHP:W") || it.upgradeType.includes("SHP:F"),
		});
	}
}

class IndexableFileVehicles_InfernalWarMachineUpgrade extends IndexableFile {
	constructor () {
		super({
			category: Parser.CAT_ID_INFERNAL_WAR_MACHINE_UPGRADE,
			file: "vehicles.json",
			listProp: "vehicleUpgrade",
			baseUrl: "vehicles.html",
			isHover: true,
			include: (it) => it.upgradeType.includes("IWM:W") || it.upgradeType.includes("IWM:A") || it.upgradeType.includes("IWM:G"),
		});
	}
}

class IndexableFileActions extends IndexableFile {
	constructor () {
		super({
			category: Parser.CAT_ID_ACTION,
			file: "actions.json",
			listProp: "action",
			baseUrl: "actions.html",
			isHover: true,
		});
	}
}

class IndexableFileLanguages extends IndexableFile {
	constructor () {
		super({
			category: Parser.CAT_ID_LANGUAGE,
			file: "languages.json",
			listProp: "language",
			baseUrl: "languages.html",
			isHover: true,
		});
	}

	pGetDeepIndex (indexer, primary, it) {
		return (it.dialects || []).map(d => ({
			n: d,
		}));
	}
}

class IndexableFileCharCreationOptions extends IndexableFile {
	constructor () {
		super({
			category: Parser.CAT_ID_CHAR_CREATION_OPTIONS,
			file: "charcreationoptions.json",
			listProp: "charoption",
			baseUrl: "charcreationoptions.html",
			isHover: true,
		});
	}
}

class IndexableFileRecipes extends IndexableFile {
	constructor () {
		super({
			category: Parser.CAT_ID_RECIPES,
			file: "recipes.json",
			listProp: "recipe",
			baseUrl: "recipes.html",
			isHover: true,
		});
	}
}

class IndexableFileSkills extends IndexableFile {
	constructor () {
		super({
			category: Parser.CAT_ID_SKILLS,
			file: "skills.json",
			listProp: "skill",
			baseUrl: "skill",
			isHover: true,
			isFauxPage: true,
		});
	}
}

class IndexableFileSenses extends IndexableFile {
	constructor () {
		super({
			category: Parser.CAT_ID_SENSES,
			file: "senses.json",
			listProp: "sense",
			baseUrl: "sense",
			isHover: true,
			isFauxPage: true,
		});
	}
}

class IndexableFileCards extends IndexableFile {
	constructor () {
		super({
			category: Parser.CAT_ID_CARD,
			file: "decks.json",
			listProp: "card",
			baseUrl: "card",
			isHover: true,
			isFauxPage: true,
		});
	}
}

class IndexableFileDecks extends IndexableFile {
	constructor () {
		super({
			category: Parser.CAT_ID_DECK,
			file: "decks.json",
			listProp: "deck",
			baseUrl: UrlUtil.PG_DECKS,
			isHover: true,
		});
	}
}

class IndexableLegendaryGroups extends IndexableFile {
	constructor () {
		super({
			category: Parser.CAT_ID_LEGENDARY_GROUP,
			file: "bestiary/legendarygroups.json",
			listProp: "legendaryGroup",
			baseUrl: "legendaryGroup",
			isHover: true,
			isFauxPage: true,
		});
	}
}

Omnidexer$1.TO_INDEX = [
	new IndexableFileBackgrounds(),
	new IndexableFileConditions(),
	new IndexableFileDiseases(),
	new IndexableFileStatuses(),
	new IndexableFileFeats(),

	new IndexableFileOptFeatures_EldritchInvocations(),
	new IndexableFileOptFeatures_Metamagic(),
	new IndexableFileOptFeatures_ManeuverBattlemaster(),
	new IndexableFileOptFeatures_ManeuverCavalier(),
	new IndexableFileOptFeatures_ArcaneShot(),
	new IndexableFileOptFeatures_Other(),
	new IndexableFileOptFeatures_FightingStyle(),
	new IndexableFileOptFeatures_PactBoon(),
	new IndexableFileOptFeatures_ElementalDiscipline(),
	new IndexableFileOptFeatures_ArtificerInfusion(),
	new IndexableFileOptFeatures_OnomancyResonant(),
	new IndexableFileOptFeatures_RuneKnightRune(),
	new IndexableFileOptFeatures_AlchemicalFormula(),
	new IndexableFileOptFeatures_Maneuver(),
	new IndexableFileItemsBase(),

	new IndexableFileItems(),
	new IndexableFileItemGroups(),
	new IndexableFileMagicVariants(),

	new IndexableFilePsionics(),
	new IndexableFileRaces(),
	new IndexableFileRewards(),
	new IndexableFileVariantRules(),
	new IndexableFileVariantRulesGenerated(),
	new IndexableFileAdventures(),
	new IndexableFileBooks(),
	new IndexableFileQuickReference$1(),
	new IndexableFileDeities(),
	new IndexableFileObjects(),
	new IndexableFileTraps(),
	new IndexableFileHazards(),
	new IndexableFileCults(),
	new IndexableFileBoons(),
	new IndexableFileTables(),
	new IndexableFileTablesGenerated(),
	new IndexableFileTableGroups(),
	new IndexableFileCards(),
	new IndexableFileDecks(),
	new IndexableLegendaryGroups(),

	new IndexableFileVehicles(),
	new IndexableFileVehicles_ShipUpgrade(),
	new IndexableFileVehicles_InfernalWarMachineUpgrade(),

	new IndexableFileActions(),
	new IndexableFileLanguages(),
	new IndexableFileCharCreationOptions(),
	new IndexableFileRecipes(),
	new IndexableFileSkills(),
	new IndexableFileSenses(),
];

class IndexableSpecial {
	pGetIndex () { throw new Error(`Unimplemented!`); }
}

class IndexableSpecialPages extends IndexableSpecial {
	pGetIndex () {
		return Object.entries(UrlUtil.PG_TO_NAME)
			.filter(([page]) => ![UrlUtil.PG_CLASS_SUBCLASS_FEATURES].includes(page))
			.map(([page, name]) => ({
				n: name,
				c: Parser.CAT_ID_PAGE,
				u: page,
				r: 1, 			}));
	}
}

Omnidexer$1.TO_INDEX__SPECIAL = [
	new IndexableSpecialPages(),
];

globalThis.Omnidexer = Omnidexer$1;

"use strict";

globalThis.ScaleCreature = {
	isCrInScaleRange (mon) {
		if ([VeCt.CR_UNKNOWN, VeCt.CR_CUSTOM].includes(Parser.crToNumber(mon.cr))) return false;
				const xpVal = Parser.XP_CHART_ALT[mon.cr?.cr ?? mon.cr];
		return xpVal != null;
	},

	_crRangeToVal (cr, ranges) {
		return Object.keys(ranges).find(k => {
			const [a, b] = ranges[k];
			return cr >= a && cr <= b;
		});
	},

	_acCrRanges: {
		"13": [-1, 3],
		"14": [4, 4],
		"15": [5, 7],
		"16": [8, 9],
		"17": [10, 12],
		"18": [13, 16],
		"19": [17, 30],
	},

	_crToAc (cr) {
		return Number(this._crRangeToVal(cr, this._acCrRanges));
	},

	_crHpRanges: {
		"0": [1, 6],
		"0.125": [7, 35],
		"0.25": [36, 49],
		"0.5": [50, 70],
		"1": [71, 85],
		"2": [86, 100],
		"3": [101, 115],
		"4": [116, 130],
		"5": [131, 145],
		"6": [146, 160],
		"7": [161, 175],
		"8": [176, 190],
		"9": [191, 205],
		"10": [206, 220],
		"11": [221, 235],
		"12": [236, 250],
		"13": [251, 265],
		"14": [266, 280],
		"15": [281, 295],
		"16": [296, 310],
		"17": [311, 325],
		"18": [326, 340],
		"19": [341, 355],
		"20": [356, 400],
		"21": [401, 445],
		"22": [446, 490],
		"23": [491, 535],
		"24": [536, 580],
		"25": [581, 625],
		"26": [626, 670],
		"27": [671, 715],
		"28": [716, 760],
		"29": [761, 805],
		"30": [806, 850],
	},

				_crToEstimatedConModRange: {
		"0": [-1, 2],
		"0.125": [-1, 1],
		"0.25": [0, 2],
		"0.5": [0, 2],
		"1": [0, 2],
		"2": [0, 3],
		"3": [1, 3],
		"4": [1, 4],
		"5": [2, 4],
		"6": [2, 5],
		"7": [1, 5],
		"8": [1, 5],
		"9": [2, 5],
		"10": [2, 5],
		"11": [2, 6],
		"12": [1, 5],
		"13": [3, 6],
		"14": [3, 6],
		"15": [3, 6],
		"16": [4, 7],
		"17": [3, 7],
		"18": [1, 7],
		"19": [4, 6],
		"20": [5, 9],
		"21": [3, 8],
		"22": [4, 9],
		"23": [5, 9],
		"24": [5, 9],
		"25": [7, 9],
		"26": [7, 9],
				"27": [7, 9],
		"28": [7, 9],
		"29": [7, 9],
				"30": [10, 10],
	},

	_atkCrRanges: {
		"3": [-1, 2],
		"4": [3, 3],
		"5": [4, 4],
		"6": [5, 7],
		"7": [8, 10],
		"8": [11, 15],
		"9": [16, 16],
		"10": [17, 20],
		"11": [21, 23],
		"12": [24, 26],
		"13": [27, 29],
		"14": [30, 30],
	},

	_crToAtk (cr) {
		return this._crRangeToVal(cr, this._atkCrRanges);
	},

	_crDprRanges: {
		"0": [0, 1],
		"0.125": [2, 3],
		"0.25": [4, 5],
		"0.5": [6, 8],
		"1": [9, 14],
		"2": [15, 20],
		"3": [21, 26],
		"4": [27, 32],
		"5": [33, 38],
		"6": [39, 44],
		"7": [45, 50],
		"8": [51, 56],
		"9": [57, 62],
		"10": [63, 68],
		"11": [69, 74],
		"12": [75, 80],
		"13": [81, 86],
		"14": [87, 92],
		"15": [93, 98],
		"16": [99, 104],
		"17": [105, 110],
		"18": [111, 116],
		"19": [117, 122],
		"20": [123, 140],
		"21": [141, 158],
		"22": [159, 176],
		"23": [177, 194],
		"24": [195, 212],
		"25": [213, 230],
		"26": [231, 248],
		"27": [249, 266],
		"28": [267, 284],
		"29": [285, 302],
		"30": [303, 320],
	},

		_crToEstimatedDamageMod: {
		"0": [-1, 2],
		"0.125": [0, 2],
		"0.25": [0, 3],
		"0.5": [0, 3],
		"1": [0, 3],
		"2": [1, 4],
		"3": [1, 4],
		"4": [2, 4],
		"5": [2, 5],
		"6": [2, 5],
		"7": [2, 5],
		"8": [2, 5],
		"9": [2, 6],
		"10": [3, 6],
		"11": [3, 6],
		"12": [3, 6],
		"13": [3, 7],
		"14": [3, 7],
		"15": [3, 7],
		"16": [4, 8],
		"17": [4, 8],
		"18": [4, 8],
		"19": [5, 8],
		"20": [6, 9],
		"21": [6, 9],
		"22": [6, 10],
		"23": [6, 10],
		"24": [6, 11],
		"25": [7, 11],
		"26": [7, 11],
				"27": [7, 11],
		"28": [8, 11],
		"29": [8, 11],
				"30": [9, 11],
	},

	_dcRanges: {
		"13": [-1, 3],
		"14": [4, 4],
		"15": [5, 7],
		"16": [8, 10],
		"17": [11, 12],
		"18": [13, 16],
		"19": [17, 20],
		"20": [21, 23],
		"21": [24, 26],
		"22": [27, 29],
		"23": [30, 30],
	},

	_crToDc (cr) {
		return this._crRangeToVal(cr, this._dcRanges);
	},

	_casterLevelAndClassCantrips: {
		artificer: [2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4],
		bard: [2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
		cleric: [3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
		druid: [2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
		sorcerer: [4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6],
		warlock: [2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
		wizard: [3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
	},

	_casterLevelAndClassToCantrips (level, clazz) {
		clazz = (clazz || "cleric").toLowerCase(); 		return this._casterLevelAndClassCantrips[clazz][level];
	},

		_protectedCantrips: ["acid splash", "chill touch", "eldritch blast", "fire bolt", "poison spray", "produce flame", "ray of frost", "sacred flame", "shocking grasp", "thorn whip", "vicious mockery"],

		_crToCasterLevelAvg: {
		"0": 2,
		"0.125": 2,
		"0.25": 2,
		"0.5": 2,
		"1": 3.5,
		"2": 4.25,
		"3": 5.75,
		"4": 6.75,
		"5": 8,
		"6": 9.75,
		"7": 10.5,
		"8": 10.75,
		"9": 11.5,
		"10": 11.75,
		"11": 12,
		"12": 13,
		"13": 14,
		"14": 15,
		"15": 16,
		"16": 17,
		"17": 18,
		"18": 19,
		"19": 20, 	},

	_crToCasterLevel (cr) {
		if (cr === 0) return 2;
		if (cr >= 19) return 20;
		return this._crToCasterLevelAvg[cr];
	},

	_calcNewAbility (mon, prop, modifier) {
				const out = Math.max(1,
			((modifier + 5) * 2)
			+ (mon[prop] % 2), 		);
				return out === 31 ? 30 : out;
	},

	_rng: null,
	_initRng (mon, toCr) {
		let h = CryptUtil.hashCode(toCr);
		h = 31 * h + CryptUtil.hashCode(mon.source);
		h = 31 * h + CryptUtil.hashCode(mon.name);
		this._rng = Math.seed(h);
	},

		async scale (mon, toCr) {
		await this._pInitSpellCache();

		if (toCr == null || toCr === "Unknown") throw new Error("Attempting to scale unknown CR!");

		this._initRng(mon, toCr);
		mon = MiscUtil.copyFast(mon);

		const crIn = mon.cr.cr || mon.cr;
		const crInNumber = Parser.crToNumber(crIn);
		if (crInNumber === toCr) throw new Error("Attempting to scale creature to own CR!");
		if (crInNumber > 30) throw new Error("Attempting to scale a creature beyond 30 CR!");
		if (crInNumber < 0) throw new Error("Attempting to scale a creature below 0 CR!");

		const pbIn = Parser.crToPb(crIn);
		const pbOut = Parser.crToPb(String(toCr));

		if (pbIn !== pbOut) this._applyPb(mon, pbIn, pbOut);

		this._adjustHp(mon, crInNumber, toCr);
		this._adjustAtkBonusAndSaveDc(mon, crInNumber, toCr, pbIn, pbOut);
		this._adjustDpr(mon, crInNumber, toCr);
		this._adjustSpellcasting(mon, crInNumber, toCr);

				this._armorClass.adjustAc(mon, crInNumber, toCr);

		
		this._handleUpdateAbilityScoresSkillsSaves(mon, pbOut);

				[`strOld`, `dexOld`, `conOld`, `intOld`, `wisOld`, `chaOld`].forEach(a => delete mon[a]);

		const crOutStr = Parser.numberToCr(toCr);
		if (mon.cr.cr) mon.cr.cr = crOutStr;
		else mon.cr = crOutStr;

		Renderer.monster.updateParsed(mon);

		mon._displayName = `${mon.name} (CR ${crOutStr})`;
		mon._scaledCr = toCr;
		mon._isScaledCr = true;
		mon._originalCr = mon._originalCr || crIn;

		return mon;
	},

	_applyPb (mon, pbIn, pbOut) {
		if (mon.save) {
			Object.keys(mon.save).forEach(k => {
				const bonus = mon.save[k];

				const fromAbility = Parser.getAbilityModNumber(mon[k]);
				if (fromAbility === Number(bonus)) return; 
				const actualPb = bonus - fromAbility;
				const expert = actualPb === pbIn * 2;

				mon.save[k] = this._applyPb_getNewSkillSaveMod(pbIn, pbOut, bonus, expert);
			});
		}

		this._applyPb_skills(mon, pbIn, pbOut, mon.skill);

		const pbDelta = pbOut - pbIn;
		const handleHit = (str) => {
			return str.replace(/{@hit ([-+]?\d+)}/g, (m0, m1) => {
				const curToHit = Number(m1);
				const outToHit = curToHit + pbDelta;
				return `{@hit ${outToHit}}`;
			});
		};

		const handleDc = (str) => {
			return str
				.replace(/DC (\d+)/g, (m0, m1) => `{@dc ${m1}}`)
				.replace(/{@dc (\d+)(?:\|[^}]+)?}/g, (m0, m1) => {
					const curDc = Number(m1);
					const outDc = curDc + pbDelta;
					return `DC ${outDc}`;
				});
		};

		if (mon.spellcasting) {
			mon.spellcasting.forEach(sc => {
				if (sc.headerEntries) {
					const toUpdate = JSON.stringify(sc.headerEntries);
					const out = handleDc(handleHit(toUpdate));
					sc.headerEntries = JSON.parse(out);
				}
			});
		}

		const handleGenericEntries = (prop) => {
			if (mon[prop]) {
				mon[prop].forEach(it => {
					const toUpdate = JSON.stringify(it.entries);
					const out = handleDc(handleHit(toUpdate));
					it.entries = JSON.parse(out);
				});
			}
		};

		handleGenericEntries("trait");
		handleGenericEntries("action");
		handleGenericEntries("bonus");
		handleGenericEntries("reaction");
		handleGenericEntries("legendary");
		handleGenericEntries("mythic");
		handleGenericEntries("variant");
	},

	_applyPb_getNewSkillSaveMod (pbIn, pbOut, oldMod, expert) {
		const mod = Number(oldMod) - (expert ? 2 * pbIn : pbIn) + (expert ? 2 * pbOut : pbOut);
		return UiUtil.intToBonus(mod);
	},

	_applyPb_skills (mon, pbIn, pbOut, monSkill) {
		if (!monSkill) return;

		Object.keys(monSkill).forEach(skill => {
			if (skill === "other") {
				monSkill[skill].forEach(block => {
					if (block.oneOf) {
						this._applyPb_skills(mon, pbIn, pbOut, block.oneOf);
					} else throw new Error(`Unhandled "other" skill keys: ${Object.keys(block)}`);
				});
				return;
			}

			const bonus = monSkill[skill];

			const fromAbility = Parser.getAbilityModNumber(mon[Parser.skillToAbilityAbv(skill)]);
			if (fromAbility === Number(bonus)) return; 
			const actualPb = bonus - fromAbility;
			const expert = actualPb === pbIn * 2;

			monSkill[skill] = this._applyPb_getNewSkillSaveMod(pbIn, pbOut, bonus, expert);

			if (skill === "perception" && mon.passive != null) mon.passive = 10 + Number(monSkill[skill]);
		});
	},

	_armorClass: {
		_getEnchanted (item, baseMod) {
			const out = [];
			for (let i = 0; i < 3; ++i) {
				out.push({
					tag: `${item} +${i + 1}|dmg`,
					mod: baseMod + i + 1,
				});
				out.push({
					tag: `+${i + 1} ${item}|dmg`,
					mod: baseMod + i + 1,
				});
			}
			return out;
		},

		_getAllVariants (obj) {
			return Object.keys(obj).map(armor => {
				const mod = obj[armor];
				return [{
					tag: `${armor}|phb`,
					mod,
				}].concat(this._getEnchanted(armor, mod));
			}).reduce((a, b) => a.concat(b), []);
		},

		_getAcBaseAndMod (all, tag) {
			const tagBaseType = tag.replace(/( \+\d)?\|.*$/, "");
			const tagBase = all[tagBaseType];
			const tagModM = /^.*? (\+\d)\|.*$/.exec(tag);
			const tagMod = tagModM ? Number(tagModM[1]) : 0;
			return [tagBase, tagMod];
		},

		_isStringContainsTag (tagSet, str) {
			return tagSet.find(it => str.includes(`@item ${it}`));
		},

		_replaceTag (str, oldTag, nuTag) {
			const out = str.replace(`@item ${oldTag}`, `@item ${nuTag}`);
			const spl = out.split("|");
			if (spl.length > 2) {
				return `${spl.slice(0, 2).join("|")}}`;
			}
			return out;
		},

		_canDropShield (mon) {
			return mon._shieldRequired === false && mon._shieldDropped === false;
		},

		_dropShield (acItem) {
			const idxShield = acItem.from.findIndex(f => this._ALL_SHIELD_VARIANTS.find(s => f._.includes(s.tag)));
			if (idxShield === -1) throw new Error("Should never occur!");
			acItem.from.splice(idxShield, 1);
		},

				_getAcVal (name) {
			name = name.trim().toLowerCase();
			const toCheck = [this._HEAVY, this._MEDIUM, this._LIGHT, {shield: 2}];
			for (const tc of toCheck) {
				const armorKey = Object.keys(tc).find(k => name === k);
				if (armorKey) {
					const acBonus = tc[armorKey];
					if (acBonus > 10) return acBonus - 10;
				}
			}
		},

		_getDexCapVal (name) {
			name = name.trim().toLowerCase();
			const ix = [this._HEAVY, this._MEDIUM, this._LIGHT].findIndex(tc => !!Object.keys(tc).find(k => name === k));
			return ix === 0 ? 0 : ix === 1 ? 2 : ix === 3 ? 999 : null;
		},

		_HEAVY: {
			"ring mail": 14,
			"chain mail": 16,
			"splint armor": 17,
			"plate armor": 18,
		},
		_MEDIUM: {
			"hide armor": 12,
			"chain shirt": 13,
			"scale mail": 14,
			"breastplate": 14,
			"half plate armor": 15,
		},
		_LIGHT: {
			"padded armor": 11,
			"leather armor": 11,
			"studded leather armor": 12,
		},
		_MAGE_ARMOR: "@spell mage armor",

		_ALL_SHIELD_VARIANTS: null,
		_ALL_HEAVY_VARIANTS: null,
		_ALL_MEDIUM_VARIANTS: null,
		_ALL_LIGHT_VARIANTS: null,
		_initAllVariants () {
			this._ALL_SHIELD_VARIANTS = this._ALL_SHIELD_VARIANTS || [
				{
					tag: "shield|phb",
					mod: 2,
				},
				...this._getEnchanted("shield", 2),
			];

			this._ALL_HEAVY_VARIANTS = this._ALL_HEAVY_VARIANTS || this._getAllVariants(this._HEAVY);
			this._ALL_MEDIUM_VARIANTS = this._ALL_MEDIUM_VARIANTS || this._getAllVariants(this._MEDIUM);
			this._ALL_LIGHT_VARIANTS = this._ALL_LIGHT_VARIANTS || this._getAllVariants(this._LIGHT);
		},

		adjustAc (mon, crIn, crOut) {
			this._initAllVariants();

									mon.ac = mon.ac.map(acItem => this._getAdjustedAcItem(mon, crIn, crOut, acItem));
		},

				_doPreAdjustAcs (mon, acItem) {
			if (mon.dexOld == null || mon.dex === mon.dexOld) return;
			if (!acItem.from) return;

			const originalDexMod = Parser.getAbilityModNumber(mon.dexOld);
			const currentDexMod = Parser.getAbilityModNumber(mon.dex);

			if (originalDexMod === currentDexMod) return;

						
			if (this._isMageArmor(acItem)) {
				acItem._acBeforePreAdjustment = acItem.ac;
				acItem.ac = 13 + Parser.getAbilityModNumber(mon.dex);
				return;
			}

			const lightTags = this._ALL_LIGHT_VARIANTS.map(it => it.tag);
			const mediumTags = this._ALL_MEDIUM_VARIANTS.map(it => it.tag);

			for (let i = 0; i < acItem.from.length; ++i) {
				const from = acItem.from[i];

				const lightTag = this._isStringContainsTag(lightTags, from);
				if (lightTag) {
					acItem._acBeforePreAdjustment = acItem.ac;

					acItem.ac = acItem.ac - originalDexMod + currentDexMod;

					return;
				}

				const mediumTag = this._isStringContainsTag(mediumTags, from);
				if (mediumTag) {
					const originalDexModMedium = Math.min(2, originalDexMod);
					const currentDexModMedium = Math.min(2, currentDexMod);

					const curAc = acItem.ac;
					acItem.ac = acItem.ac - originalDexModMedium + currentDexModMedium;
					if (curAc !== acItem.ac) acItem._acBeforePreAdjustment = curAc;

					return;
				}
			}
		},

		_getAdjustedAcItem (mon, crIn, crOut, acItem) {
						this._doPreAdjustAcs(mon, acItem);

						let iter = 0;
			let out = null;
			while (out == null) {
				if (iter > 100) throw new Error(`Failed to calculate new AC! Input was:\n${JSON.stringify(acItem, null, "\t")}`);
				out = this._getAdjustedAcItem_getAdjusted(mon, crIn, crOut, acItem, iter);
				iter++;
			}
			
									let handledEnchBonus = !acItem._enchTotal;
			if (acItem.from) {
				if (acItem._enchTotal) {
					acItem.from.forEach(f => {
						if (handledEnchBonus) return;

						if (f.ench && f.ench < 3) {
							const enchToGive = Math.min(3 - f.ench, acItem._enchTotal);
							acItem._enchTotal -= enchToGive;
							f.ench += enchToGive;
							acItem.ac += enchToGive;
							f._ = `{@item +${f.ench} ${f.name}}`;
							if (acItem._enchTotal <= 0) handledEnchBonus = true;
						} else if (out._gearBonus) {
							const enchToGive = Math.min(3, acItem._enchTotal);
							acItem._enchTotal -= enchToGive;
							f._ = `{@item +${enchToGive} ${f.name}}`;
							if (acItem._enchTotal <= 0) handledEnchBonus = true;
						}
					});
				}
				acItem.from = acItem.from.map(it => it._);
			}

						if (!handledEnchBonus) {
				const enchToGive = Math.min(3, acItem._enchTotal);
				acItem._enchTotal -= enchToGive;
				acItem.ac += enchToGive + 1;
				(acItem.from = acItem.from || []).unshift(`{@item +${enchToGive} leather armor}`);

				if (acItem._enchTotal > 0) acItem.ac += acItem._enchTotal; 			}

			if (acItem._miscOffset != null) acItem.ac += acItem._miscOffset;

						["_enchTotal", "_gearBonus", "_dexCap", "_miscOffset"].forEach(it => delete acItem[it]);
			
			return out;
		},

		_isMageArmor (acItem) {
			return acItem.condition && acItem.condition.toLowerCase().includes(this._MAGE_ARMOR);
		},

		_getAdjustedAcItem_getAdjusted (mon, crIn, crOut, acItem, iter) {
			const getEnchTotal = () => acItem._enchTotal || 0;
			const getBaseGearBonus = () => acItem._gearBonus || 0;
			const getDexCap = () => acItem._dexCap || 999;

						if (typeof acItem !== "number") {
				acItem._enchTotal = acItem._enchTotal || 0; 				acItem._gearBonus = 0; 				acItem._dexCap = 999; 			}

			if (acItem.from) {
				acItem.from = acItem.from.map(f => {
					if (f._) f = f._; 
					const m = /@item (\+\d+) ([^+\d]+)\|([^|}]+)/gi.exec(f); 					if (m) {
						const [_, name, bonus, source] = m;

						const acVal = this._getAcVal(name);
						if (acVal) acItem._gearBonus += acVal;

						const dexCap = this._getDexCapVal(name);
						if (dexCap != null) acItem._dexCap = Math.min(acItem._dexCap, dexCap);

						const ench = Number(bonus);
						acItem._enchTotal += ench;
						return {
							_: f,
							name: name.trim(),
							ench: ench,
							source: source,
						};
					} else {
						const m = /@item ([^|}]+)(\|[^|}]+)?(\|[^|}]+)?/gi.exec(f);
						if (m) {
							const [_, name, source, display] = m;
							const out = {_: f, name};
							if (source) out.source = source;
							if (display) out.display = display;

							const acVal = this._getAcVal(name);
							if (acVal) {
								acItem._gearBonus += acVal;
								out._gearBonus = acVal;
							}

							const dexCap = this._getDexCapVal(name);
							if (dexCap != null) acItem._dexCap = Math.min(acItem._dexCap, dexCap);

							return out;
						} else return {_: f, name: f};
					}
				});
			}

						const expectedBaseScore = mon.dexOld != null
				? (getBaseGearBonus() + Math.min(Parser.getAbilityModNumber(mon.dexOld), getDexCap()) + (this._isMageArmor(acItem) ? 13 : 10))
				: null;

			let canAdjustDex = mon.dexOld == null;
			const dexGain = Parser.getAbilityModNumber(mon.dex) - Parser.getAbilityModNumber((mon.dexOld || mon.dex));

			const curr = acItem._acBeforePreAdjustment != null
				? acItem._acBeforePreAdjustment
				: (acItem.ac || acItem);
						const currWithoutEnchants = curr - (iter === 0 ? getEnchTotal() : 0); 
						if (typeof acItem !== "number") {
								acItem._miscOffset = acItem._miscOffset != null
					? acItem._miscOffset
					: (expectedBaseScore != null ? currWithoutEnchants - expectedBaseScore : null);
			}

			const idealAcIn = ScaleCreature._crToAc(crIn);
			const idealAcOut = ScaleCreature._crToAc(crOut);
			const effectiveCurrent = expectedBaseScore == null ? currWithoutEnchants : expectedBaseScore;
			const target = ScaleCreature._getScaledToRatio(effectiveCurrent, idealAcIn, idealAcOut);
			let targetNoShield = target;
			const acGain = target - effectiveCurrent;

			const dexMismatch = acGain - dexGain;

			const adjustDex = () => {
				if (mon.dexOld == null) mon.dexOld = mon.dex;
				mon.dex = ScaleCreature._calcNewAbility(mon, "dex", Parser.getAbilityModNumber(mon.dex) + dexMismatch);
				canAdjustDex = false;
				return true;
			};

			const handleNoArmor = () => {
				if (dexMismatch > 0) {
					if (canAdjustDex) {
						adjustDex();
						return target;
					} else {
						return { 							ac: target,
							from: ["natural armor"],
						};
					}
				} else if (dexMismatch < 0 && canAdjustDex) { 					adjustDex();
					return target;
				} else return target; 			};

			
			const handleMageArmor = () => {
								if (this._isMageArmor(acItem)) {
					if (canAdjustDex) {
						acItem.ac = target;
						delete acItem._acBeforePreAdjustment;
						return adjustDex();
					} else {
																		return true;
					}
				}
				return false;
			};

			const handleShield = () => {
								const DUAL_SHIELD_AC = 3; 
				if (acItem.from) {
					const fromShields = acItem.from.filter(f => this._ALL_SHIELD_VARIANTS.find(s => f._.includes(`@item ${s.tag}`)));
					if (fromShields.length) {
						if (fromShields.length > 1) throw new Error("AC contained multiple shields!"); 
																		const shieldRequired = mon._shieldRequired != null ? mon._shieldRequired : (() => {
							const checkShields = (prop) => {
								if (!mon[prop]) return false;
								for (const it of mon[prop]) {
									if (it.name && it.name.toLowerCase().includes("shield")) return true;
									if (it.entries && JSON.stringify(it.entries).match(/shield/i)) return true;
								}
							};
							return mon._shieldRequired = checkShields("trait")
								|| checkShields("action")
								|| checkShields("bonus")
								|| checkShields("reaction")
								|| checkShields("legendary")
								|| checkShields("mythic");
						})();
						mon._shieldDropped = false;

						const fromShield = fromShields[0]._;
						const idx = acItem.from.findIndex(it => it === fromShield);

						if (fromShield.endsWith("|shields}")) {
							targetNoShield -= DUAL_SHIELD_AC;

							if (!shieldRequired && (acGain <= -DUAL_SHIELD_AC)) {
								acItem.from.splice(idx, 1);
								acItem.ac -= DUAL_SHIELD_AC;
								mon._shieldDropped = true;
								if (acItem.ac === target) return true;
							}
						} else {
							const shieldVal = this._ALL_SHIELD_VARIANTS.find(s => fromShield.includes(s.tag));
							targetNoShield -= shieldVal.mod;

							if (!shieldRequired && (acGain <= -shieldVal.mod)) {
								acItem.from.splice(idx, 1);
								acItem.ac -= shieldVal.mod;
								mon._shieldDropped = true;
								if (acItem.ac === target) return true;
							}
						}
					}
				}
				return false;
			};

						const handleHeavyArmor = () => {
								const PL3_PLATE = 21;

				const heavyTags = this._ALL_HEAVY_VARIANTS.map(it => it.tag);

				const isHeavy = (ac) => {
					return ac >= 14 && ac <= PL3_PLATE; 				};

				const isBeyondHeavy = (ac) => {
					return ac > PL3_PLATE; 				};

				const getHeavy = (ac) => {
					const nonEnch = Object.keys(this._HEAVY).find(armor => this._HEAVY[armor] === ac);
					if (nonEnch) return `${nonEnch}|phb`;
					switch (ac) {
						case 19:
							return [`+1 plate armor|dmg`, `+2 splint armor|dmg`][RollerUtil.roll(1, ScaleCreature._rng)];
						case 20:
							return `+2 plate armor|dmg`;
						case PL3_PLATE:
							return `+3 plate armor|dmg`;
					}
				};

				if (acItem.from) {
					for (let i = 0; i < acItem.from.length; ++i) {
						const heavyTag = this._isStringContainsTag(heavyTags, acItem.from[i]._);
						if (heavyTag) {
							if (isHeavy(targetNoShield)) {
								const bumpOne = targetNoShield === 15; 								if (bumpOne) targetNoShield++;
								acItem.from[i]._ = this._replaceTag(acItem.from[i]._, heavyTag, getHeavy(targetNoShield));
								acItem.ac = target + (bumpOne ? 1 : 0);
								delete acItem._acBeforePreAdjustment;
								return true;
							} else if (this._canDropShield(mon) && isHeavy(target)) {
								const targetWithBump = target + (target === 15 ? 1 : 0); 								acItem.from[i]._ = this._replaceTag(acItem.from[i]._, heavyTag, getHeavy(targetWithBump));
								acItem.ac = targetWithBump;
								delete acItem._acBeforePreAdjustment;
								this._dropShield(acItem);
								return true;
							} else if (isBeyondHeavy(targetNoShield)) { 								const max = PL3_PLATE;
								acItem.from[i]._ = this._replaceTag(acItem.from[i]._, heavyTag, getHeavy(max));
								acItem.ac = max;
								delete acItem._acBeforePreAdjustment;
								return true;
							} else { 								const [tagBase, tagMod] = this._getAcBaseAndMod(this._LIGHT, heavyTag);
								const tagAc = tagBase + tagMod;
								acItem.from[i]._ = this._replaceTag(acItem.from[i]._, heavyTag, `half plate armor|phb`);
								acItem.ac = (acItem.ac - tagAc) + 15 + Math.min(2, Parser.getAbilityModNumber(mon.dex));
								delete acItem._acBeforePreAdjustment;
								return false;
							}
						}
					}
				}
				return false;
			};

			const handleMediumArmor = () => {
								const mediumTags = this._ALL_MEDIUM_VARIANTS.map(it => it.tag);

				const isMedium = (ac, asPos) => {
					const min = 12 + (canAdjustDex ? -5 : Parser.getAbilityModNumber(mon.dex)); 					const max = 18 + (canAdjustDex ? 2 : Math.min(2, Parser.getAbilityModNumber(mon.dex))); 					if (asPos) return ac < min ? -1 : ac > max ? 1 : 0;
					return ac >= min && ac <= max;
				};

				const getMedium = (ac, curArmor) => {
					const getByBase = (base) => {
						switch (base) {
							case 14:
								return [`scale mail|phb`, `breastplate|phb`][RollerUtil.roll(1, ScaleCreature._rng)];
							case 16:
								return [`+1 half plate armor|dmg`, `+2 breastplate|dmg`, `+2 scale mail|dmg`][RollerUtil.roll(2, ScaleCreature._rng)];
							case 17:
								return `+2 half plate armor|dmg`;
							case 18:
								return `+3 half plate armor|dmg`;
							default: {
								const nonEnch = Object.keys(this._MEDIUM).find(it => this._MEDIUM[it] === base);
								return `${nonEnch}|phb`;
							}
						}
					};

					if (canAdjustDex) {
						let fromArmor = curArmor.ac;
						let maxFromArmor = fromArmor + 2;
						let minFromArmor = fromArmor - 5;

						const withinDexRange = () => {
							return ac >= minFromArmor && ac <= maxFromArmor;
						};

						const getTotalAc = () => {
							return fromArmor + Math.min(2, Parser.getAbilityModNumber(mon.dex));
						};

						let loops = 0;
						while (1) {
							if (loops > 1000) throw new Error(`Failed to find valid light armor!`);

							if (withinDexRange()) {
								canAdjustDex = false;
								if (mon.dexOld == null) mon.dexOld = mon.dex;

								if (ac > getTotalAc()) mon.dex += 2;
								else mon.dex -= 2;
							} else {
								if (ac < minFromArmor) fromArmor -= 1;
								else fromArmor += 1;
								if (fromArmor < 12 || fromArmor > 18) throw Error("Should never occur!"); 								maxFromArmor = fromArmor + 2;
								minFromArmor = fromArmor - 5;
							}

							if (getTotalAc() === ac) break;
							loops++;
						}

						return getByBase(fromArmor);
					} else {
						const dexOffset = Math.min(Parser.getAbilityModNumber(mon.dex), 2);
						return getByBase(ac - dexOffset);
					}
				};

				if (acItem.from) {
					for (let i = 0; i < acItem.from.length; ++i) {
						const mediumTag = this._isStringContainsTag(mediumTags, acItem.from[i]._);
						if (mediumTag) {
							const [tagBase, tagMod] = this._getAcBaseAndMod(this._MEDIUM, mediumTag);
							const tagAc = tagBase + tagMod;
							if (isMedium(targetNoShield)) {
								acItem.from[i]._ = this._replaceTag(acItem.from[i]._, mediumTag, getMedium(targetNoShield, {tag: mediumTag, ac: tagAc}));
								acItem.ac = target;
								delete acItem._acBeforePreAdjustment;
								return true;
							} else if (this._canDropShield(mon) && isMedium(target)) {
								acItem.from[i]._ = this._replaceTag(acItem.from[i]._, mediumTag, getMedium(target, {tag: mediumTag, ac: tagAc}));
								acItem.ac = target;
								delete acItem._acBeforePreAdjustment;
								this._dropShield(acItem);
								return true;
							} else if (canAdjustDex && isMedium(targetNoShield, true) === -1) { 								acItem.from[i]._ = this._replaceTag(acItem.from[i]._, mediumTag, `studded leather armor|phb`);
								acItem.ac = (acItem.ac - tagAc - Math.min(2, Parser.getAbilityModNumber(mon.dex))) + 12 + Parser.getAbilityModNumber(mon.dex);
								delete acItem._acBeforePreAdjustment;
								return false;
							} else {
																acItem.from[i]._ = this._replaceTag(acItem.from[i]._, mediumTag, `ring mail|phb`);
								acItem.ac = 14;
								delete acItem._acBeforePreAdjustment;
								return -1;
							}
						}
					}
				}
				return false;
			};

			const handleLightArmor = () => {
								const lightTags = this._ALL_LIGHT_VARIANTS.map(it => it.tag);

				const isLight = (ac, asPos) => {
					const min = 11 + (canAdjustDex ? -5 : Parser.getAbilityModNumber(mon.dex)); 					const max = 15 + (canAdjustDex ? 100 : Parser.getAbilityModNumber(mon.dex)); 					if (asPos) return ac < min ? -1 : ac > max ? 1 : 0;
					return ac >= min && ac <= max;
				};

				const getLight = (ac, curArmor) => {
					const getByBase = (base) => {
						switch (base) {
							case 11:
								return [`padded armor|phb`, `leather armor|phb`][RollerUtil.roll(1, ScaleCreature._rng)];
							case 12:
								return `studded leather armor|phb`;
							case 13:
								return [`+1 padded armor|dmg`, `+1 leather armor|dmg`][RollerUtil.roll(1, ScaleCreature._rng)];
							case 14:
								return [`+2 padded armor|dmg`, `+2 leather armor|dmg`, `+1 studded leather armor|dmg`][RollerUtil.roll(2, ScaleCreature._rng)];
							case 15:
								return `+2 studded leather armor|dmg`;
						}
					};

					if (canAdjustDex) {
						let fromArmor = curArmor.ac;
						let minFromArmor = fromArmor - 5;

						const withinDexRange = () => {
							return ac >= minFromArmor;
						};

						const getTotalAc = () => {
							return fromArmor + Parser.getAbilityModNumber(mon.dex);
						};

						let loops = 0;
						while (1) {
							if (loops > 1000) throw new Error(`Failed to find valid light armor!`);

							if (withinDexRange()) {
								canAdjustDex = false;
								if (mon.dexOld == null) mon.dexOld = mon.dex;

								if (ac > getTotalAc()) mon.dex += 2;
								else mon.dex -= 2;
							} else {
								if (ac < minFromArmor) fromArmor -= 1;
								else fromArmor += 1;
								if (fromArmor < 11 || fromArmor > 15) throw Error("Should never occur!"); 								minFromArmor = fromArmor - 5;
							}

							if (getTotalAc() === ac) break;
							loops++;
						}

						return getByBase(fromArmor);
					} else {
						const dexOffset = Parser.getAbilityModNumber(mon.dex);
						return getByBase(ac - dexOffset);
					}
				};

				if (acItem.from) {
					for (let i = 0; i < acItem.from.length; ++i) {
						const lightTag = this._isStringContainsTag(lightTags, acItem.from[i]._);
						if (lightTag) {
							const [tagBase, tagMod] = this._getAcBaseAndMod(this._LIGHT, lightTag);
							const tagAc = tagBase + tagMod;
							if (isLight(targetNoShield)) {
								acItem.from[i]._ = this._replaceTag(acItem.from[i]._, lightTag, getLight(targetNoShield, {tag: lightTag, ac: tagAc}));
								acItem.ac = target;
								delete acItem._acBeforePreAdjustment;
								return true;
							} else if (this._canDropShield(mon) && isLight(target)) {
								acItem.from[i]._ = this._replaceTag(acItem.from[i]._, lightTag, getLight(target, {tag: lightTag, ac: tagAc}));
								acItem.ac = target;
								delete acItem._acBeforePreAdjustment;
								this._dropShield(acItem);
								return true;
							} else if (!canAdjustDex && isLight(targetNoShield, true) === -1) { 								if (acItem.from.length === 1) { 									acItem._droppedArmor = true;
									return -1;
								} else { 									acItem.from.splice(i, 1);
									acItem.ac = (acItem.ac - tagAc) + 10;
									delete acItem._acBeforePreAdjustment;
									return -1;
								}
							} else {
																acItem.from[i]._ = this._replaceTag(acItem.from[i]._, lightTag, `chain shirt|phb`);
								acItem.ac = (acItem.ac - tagAc - Parser.getAbilityModNumber(mon.dex)) + 13 + Math.min(2, Parser.getAbilityModNumber(mon.dex));
								delete acItem._acBeforePreAdjustment;
								return -1;
							}
						}
					}
				}
				return false;
			};

			const handleNaturalArmor = () => {
				
				if (acItem.from && acItem.from.map(it => it._).includes("natural armor")) {
					if (canAdjustDex) {
						acItem.ac = target;
						delete acItem._acBeforePreAdjustment;
						return adjustDex();
					} else {
						acItem.ac = target; 						delete acItem._acBeforePreAdjustment;
						return true;
					}
				}
				return false;
			};

			if (acItem.ac && !acItem._droppedArmor) {
				const toRun = [
					handleMageArmor,
					handleShield,
					handleHeavyArmor,
					handleMediumArmor,
					handleLightArmor,
					handleNaturalArmor,
				];
				let lastVal = 0;
				for (let i = 0; i < toRun.length; ++i) {
					lastVal = toRun[i]();
					if (lastVal === -1) return null;
					else if (lastVal) break;
				}

								if (!lastVal) {
					acItem.ac = target;
					delete acItem._acBeforePreAdjustment;
				}
				return acItem;
			} else {
				return handleNoArmor();
			}
		},
	},

		_interpAndTranslateToSpace (x, lh, mi) {
		let [l, h] = lh;
		let [m, i] = mi;
				const OFFSET = 0.1;
		l -= OFFSET; h += OFFSET;
		m -= OFFSET; i += OFFSET;
		const delta = (x - l) / (h - l);
		return Math.round((delta * (i - m)) + m); 	},

		_getScaledToRatio (inVal, inTotal, outTotal) {
		return Math.round(inVal * (outTotal / inTotal));
	},

	_adjustHp (mon, crIn, crOut) {
		if (mon.hp.special) return; 
		const hpInAvg = this._crHpRanges[crIn].mean();
		const hpOutRange = this._crHpRanges[crOut];
		const hpOutAvg = hpOutRange.mean();
		const targetHpOut = this._getScaledToRatio(mon.hp.average, hpInAvg, hpOutAvg);
		const targetHpDeviation = (hpOutRange[1] - hpOutRange[0]) / 2;
		const targetHpRange = [Math.floor(targetHpOut - targetHpDeviation), Math.ceil(targetHpOut + targetHpDeviation)];

		const origFormula = mon.hp.formula.replace(/\s*/g, "");
		mon.hp.average = Math.floor(Math.max(1, targetHpOut));

		const fSplit = origFormula.split(/([-+])/);
		const mDice = /(\d+)d(\d+)/i.exec(fSplit[0]);
		const hdFaces = Number(mDice[2]);
		const hdAvg = (hdFaces + 1) / 2;
		const numHd = Number(mDice[1]);
		const modTotal = fSplit.length === 3 ? Number(`${fSplit[1]}${fSplit[2]}`) : 0;
		const modPerHd = Math.floor(modTotal / numHd);

		const getAdjustedConMod = () => {
			const outRange = this._crToEstimatedConModRange[crOut];
			if (outRange[0] === outRange[1]) return outRange[0]; 			return this._interpAndTranslateToSpace(modPerHd, this._crToEstimatedConModRange[crIn], outRange);
		};

		let numHdOut = numHd;
		let hpModOut = getAdjustedConMod();

		const getAvg = (numHd = numHdOut, hpMod = hpModOut) => {
			return (numHd * hdAvg) + (numHd * hpMod);
		};

		const inRange = (num) => {
			return num >= targetHpRange[0] && num <= targetHpRange[1];
		};

		let loops = 0;
		while (1) {
			if (inRange(getAvg(numHdOut))) break;
			if (loops > 100) throw new Error(`Failed to find new HP! Current formula is: ${numHd}d${hpModOut}`);

			const tryAdjustNumDice = () => {
				let numDiceTemp = numHdOut;
				let tempTotalHp = getAvg();
				let found = false;

				if (tempTotalHp > targetHpRange[1]) { 					while (numDiceTemp > 1) {
						numDiceTemp -= 1;
						tempTotalHp -= hdAvg;

						if (inRange(getAvg(numDiceTemp))) {
							found = true;
							break;
						}
					}
				} else { 					while (tempTotalHp <= targetHpRange[1]) {
						numDiceTemp += 1;
						tempTotalHp += hdAvg;

						if (inRange(getAvg(numDiceTemp))) {
							found = true;
							break;
						}
					}
				}

				if (found) {
					numHdOut = numDiceTemp;
					return true;
				}
				return false;
			};

			const tryAdjustMod = () => {
												hpModOut += (1 - ((loops % 2) * 2)) * (loops + 1);
			};

												if (tryAdjustNumDice()) break;
			tryAdjustMod();

			loops++;
		}

		mon.hp.average = Math.floor(getAvg(numHdOut));
		const outModTotal = numHdOut * hpModOut;
		mon.hp.formula = `${numHdOut}d${hdFaces}${outModTotal === 0 ? "" : `${outModTotal >= 0 ? "+" : ""}${outModTotal}`}`
			.replace(/([-+])\s*(\d+)$/g, " $1 $2"); 
		if (hpModOut !== modPerHd) {
			const conOut = this._calcNewAbility(mon, "con", hpModOut);
			if (conOut !== mon.con && mon.save && mon.save.con) {
				const conDelta = Parser.getAbilityModifier(conOut) - Parser.getAbilityModifier(mon.con);
				const conSaveOut = Number(mon.save.con) + conDelta;
				mon.save.con = `${conSaveOut >= 0 ? "+" : ""}${conSaveOut}`;
			}
			mon.con = conOut;
		}
	},

	_getEnchantmentBonus (str) {
		const m = /\+(\d+)/.exec(str);
		if (m) return Number(m[1]);
		else return 0;
	},

	_wepThrownFinesse: ["dagger", "dart"],
	_wepFinesse: ["dagger", "dart", "rapier", "scimitar", "shortsword", "whip"],
	_wepThrown: ["handaxe", "javelin", "light hammer", "spear", "trident", "net"],
	_getAbilBeingScaled ({strMod, dexMod, modFromAbil, name, content}) {
		if (modFromAbil == null) return null;

		const guessMod = () => {
			name = name.toLowerCase();
			content = content.replace(/{@atk ([A-Za-z,]+)}/gi, (_, p1) => Renderer.attackTagToFull(p1)).toLowerCase();

			const isMeleeOrRangedWep = content.includes("melee or ranged weapon attack:");
			if (isMeleeOrRangedWep) {
				const wtf = this._wepThrownFinesse.find(it => content.includes(it));
				if (wtf) return "dex";

				const wf = this._wepFinesse.find(it => content.includes(it));
				if (wf) return "dex";

				const wt = this._wepThrown.find(it => content.includes(it));
				if (wt) return "str";

				return null;
			}

			const isMeleeWep = content.includes("melee weapon attack:");
			if (isMeleeWep) {
				const wf = this._wepFinesse.find(it => content.includes(it));
				if (wf) return "dex";
				return "str";
			}

			const isRangedWep = content.includes("ranged weapon attack:");
			if (isRangedWep) {
				const wt = this._wepThrown.find(it => content.includes(it));
				if (wt) return "str"; 				return "dex";
			}
		};

		if (strMod === dexMod && strMod === modFromAbil) return guessMod();
		return strMod === modFromAbil ? "str" : dexMod === modFromAbil ? "dex" : null;
	},

	_adjustAtkBonusAndSaveDc (mon, crIn, crOut, pbIn, pbOut) {
		const idealHitIn = Number(this._crToAtk(crIn));
		const idealHitOut = Number(this._crToAtk(crOut));

		const strMod = Parser.getAbilityModNumber(mon.str);
		const dexMod = Parser.getAbilityModNumber(mon.dex);

		const getAdjustedHitFlat = toHitIn => {
												if (crIn < crOut) return toHitIn + (idealHitOut - idealHitIn);

						return this._getScaledToRatio(toHitIn, idealHitIn, idealHitOut);
		};

		const handleHit = (str, name) => {
			const offsetEnchant = name != null ? this._getEnchantmentBonus(name) : 0;

			return str.replace(/{@hit ([-+]?\d+)}/g, (m0, m1) => {
				const curToHit = Number(m1);

				const modFromAbil = curToHit - (offsetEnchant + pbOut);
								const modFromAbilExpertise = curToHit - (offsetEnchant + (pbOut * 2));
								const modFromAbilNoProf = curToHit - offsetEnchant;

								const abilBeingScaled = name != null
					? this._getAbilBeingScaled({strMod, dexMod, modFromAbil, name, content: str})
					: null;
				const abilBeingScaledExpertise = name != null
					? this._getAbilBeingScaled({strMod, dexMod, modFromAbil: modFromAbilExpertise, name, content: str})
					: null;
				const abilBeingScaledNoProf = name != null
					? this._getAbilBeingScaled({strMod, dexMod, modFromAbil: modFromAbilNoProf, name, content: str})
					: null;

				const {abil, profMult} = [
					abilBeingScaled ? {abil: abilBeingScaled, profMult: 1} : null,
					abilBeingScaledExpertise ? {abil: abilBeingScaledExpertise, profMult: 2} : null,
					abilBeingScaledNoProf ? {abil: abilBeingScaledNoProf, profMult: 0} : null,
				].filter(Boolean)[0] || {abil: null, profMult: 1};

				const pbInMult = profMult * pbIn;
				const pbOutMult = profMult * pbOut;

				const origToHitNoEnch = curToHit + (pbInMult - pbOutMult) - offsetEnchant;
				const targetToHitNoEnch = getAdjustedHitFlat(origToHitNoEnch);

				if (origToHitNoEnch === targetToHitNoEnch) return m0; 
				if (abil != null) {
					const modDiff = (targetToHitNoEnch - pbOutMult) - (origToHitNoEnch - pbInMult);
					const modFromAbilOut = modFromAbil + modDiff;

										const tmpModListProp = {
						"str": `_strTmpMods`,
						"dex": `_dexTmpMods`,
					}[abil];

					mon[tmpModListProp] = mon[tmpModListProp] || [];
					mon[tmpModListProp].push(modFromAbilOut);
				}

				return `{@hit ${targetToHitNoEnch + offsetEnchant}}`;
			});
		};

		const idealDcIn = this._crToDc(crIn);
		const idealDcOut = this._crToDc(crOut);

		const getAdjustedDcFlat = (dcIn) => dcIn + (idealDcOut - idealDcIn);

		const handleDc = (str, castingAbility) => {
			return str
				.replace(/DC (\d+)/g, (m0, m1) => `{@dc ${m1}}`)
				.replace(/{@dc (\d+)(?:\|[^}]+)?}/g, (m0, m1) => {
					const curDc = Number(m1);
					const origDc = curDc + pbIn - pbOut;
					const outDc = Math.max(10, getAdjustedDcFlat(origDc));
					if (curDc === outDc) return m0;

					if (["int", "wis", "cha"].includes(castingAbility)) {
												const oldKey = (() => {
							switch (castingAbility) {
								case "int": return "intOld";
								case "wis": return "wisOld";
								case "cha": return "chaOld";
								default: throw new Error(`Unimplemented!`);
							}
						})();
						if (mon[oldKey] == null) {
							mon[oldKey] = mon[castingAbility];
							const dcDiff = outDc - origDc;
							const curMod = Parser.getAbilityModNumber(mon[castingAbility]);
							mon[castingAbility] = this._calcNewAbility(mon, castingAbility, curMod + dcDiff + pbIn - pbOut);
						}
					}
					return `DC ${outDc}`;
				});
		};

		if (mon.spellcasting) {
			mon.spellcasting.forEach(sc => {
				if (sc.headerEntries) {
					const toUpdate = JSON.stringify(sc.headerEntries);
					const out = handleHit(handleDc(toUpdate, sc.ability));
					sc.headerEntries = JSON.parse(out);
				}
			});
		}

		const handleGenericEntries = (prop) => {
			if (mon[prop]) {
				mon[prop].forEach(it => {
					const toUpdate = JSON.stringify(it.entries);
					const out = handleDc(handleHit(toUpdate, it.name));
					it.entries = JSON.parse(out);
				});
			}
		};

		handleGenericEntries("trait");
		handleGenericEntries("action");
		handleGenericEntries("bonus");
		handleGenericEntries("reaction");
		handleGenericEntries("legendary");
		handleGenericEntries("mythic");
		handleGenericEntries("variant");

				const checkSetTempMod = (abil) => {
						const tmpModListProp = {
				"str": `_strTmpMods`,
				"dex": `_dexTmpMods`,
			}[abil];

			if (!mon[tmpModListProp]) return;

			const nxtK = `_${abil}TmpMod`;
			if (mon[tmpModListProp].length === 0) throw new Error("Should never occur!");
			else if (mon[tmpModListProp].length > 1) {
				const cntEachMod = {};
				mon[tmpModListProp].forEach(mod => cntEachMod[mod] = (cntEachMod[mod] || 0) + 1);

								if (Object.keys(cntEachMod).length === 1) mon[nxtK] = mon[tmpModListProp][0];
								else {
					const maxCount = Math.max(...Object.values(cntEachMod));
					const mostPopularMods = Object.entries(cntEachMod)
						.filter(([, cnt]) => cnt === maxCount)
						.map(([mod]) => Number(mod));
					mon[nxtK] = mostPopularMods[0];
				}
			} else {
				mon[nxtK] = mon[tmpModListProp][0];
			}

			delete mon[tmpModListProp];
		};

		checkSetTempMod("str");
		checkSetTempMod("dex");
	},

	_adjustDpr (mon, crIn, crOut) {
		const idealDprRangeIn = this._crDprRanges[crIn];
		const idealDprRangeOut = this._crDprRanges[crOut];
		const dprTotalIn = idealDprRangeIn.mean();
		const dprTotalOut = idealDprRangeOut.mean();

		const getAdjustedDpr = (dprIn) => {
			if (crIn === 0) dprIn = Math.min(dprIn, 0.63); 			return this._getScaledToRatio(dprIn, dprTotalIn, dprTotalOut);
		};

		const getAvgDpr = (diceExp) => {
			diceExp = diceExp.replace(/\s*/g, "");
			const asAverages = diceExp.replace(/d(\d+)/gi, (...m) => {
				return ` * ${(Number(m[1]) + 1) / 2}`;
			});
			return MiscUtil.expEval(asAverages);
		};

		const crOutDprVariance = (idealDprRangeOut[1] - idealDprRangeOut[0]) / 2;

		let dprAdjustmentComplete = false;
		let scaledEntries = [];
		while (!dprAdjustmentComplete) {
			scaledEntries = []; 
			const originalStrMod = Parser.getAbilityModNumber(mon.str);
			const originalDexMod = Parser.getAbilityModNumber(mon.dex);
			const strMod = mon._strTmpMod || originalStrMod;
			const dexMod = mon._dexTmpMod || originalDexMod;

			const handleDpr = (prop) => {
				if (!mon[prop]) return true; 
				let allSucceeded = true;

				mon[prop].forEach((it, idxProp) => {
					const toUpdate = JSON.stringify(it.entries);

										let out = toUpdate.replace(RollerUtil.REGEX_DAMAGE_FLAT, (m0, prefix, flatVal, suffix) => {
						const adjDpr = getAdjustedDpr(flatVal);
						return `${prefix}${adjDpr}${suffix}`;
					});

										const reqAbilAdjust = [];

										const offsetEnchant = this._getEnchantmentBonus(it.name);

					out = out.replace(RollerUtil.REGEX_DAMAGE_DICE, (m0, average, prefix, diceExp, suffix) => {
						diceExp = diceExp.replace(/\s+/g, "");
						const avgDpr = getAvgDpr(diceExp);
						const adjustedDpr = getAdjustedDpr(avgDpr);

						const targetDprRange = [ 							Math.max(0, Math.floor(adjustedDpr - crOutDprVariance)),
							Math.ceil(Math.max(1, adjustedDpr + crOutDprVariance)),
						];

						const inRange = (num) => {
							return num >= targetDprRange[0] && num <= targetDprRange[1];
						};

												const [dice, modifier] = diceExp.split(/[-+]/);
						const [numDice, diceFaces] = dice.split("d").map(it => Number(it));
						const modFromAbil = modifier ? Number(modifier) - offsetEnchant : null;

												const abilBeingScaled = this._getAbilBeingScaled({
							strMod: originalStrMod,
							dexMod: originalDexMod,
							modFromAbil,
							name: it.name,
							content: toUpdate,
						});
						const originalAbilMod = abilBeingScaled === "str" ? strMod : abilBeingScaled === "dex" ? dexMod : null;

						const getAdjustedDamMod = () => {
							if (abilBeingScaled === "str" && mon._strTmpMod != null) return mon._strTmpMod;
							if (abilBeingScaled === "dex" && mon._dexTmpMod != null) return mon._dexTmpMod;

							if (modFromAbil == null) return 0 - offsetEnchant; 
														return this._interpAndTranslateToSpace(modFromAbil, this._crToEstimatedDamageMod[crIn], this._crToEstimatedDamageMod[crOut]);
						};

						let numDiceOut = numDice;
						let diceFacesOut = diceFaces;
						let modOut = getAdjustedDamMod();

						const doPostCalc = () => {
																																																	if (modOut < -5) throw new Error(`Ability modifier ${abilBeingScaled != null ? `(${abilBeingScaled})` : ""} was below -5 (${modOut})! Original dice expression was ${diceExp}.`);

							if (abilBeingScaled == null) return;

														const [tmpModProp, maxDprKey] = {
								"str": [`_strTmpMod`, `_maxDprStr`],
								"dex": [`_dexTmpMod`, `_maxDprDex`],
							}[abilBeingScaled];

							if (originalAbilMod != null) {
								if (mon[tmpModProp] != null && mon[tmpModProp] !== modOut) {
									if (mon[maxDprKey] < adjustedDpr) {
																																																																																mon[tmpModProp] = modOut;
										mon[maxDprKey] = adjustedDpr;
										allSucceeded = false;
										return;
									}
								}

																																mon[maxDprKey] = Math.max((mon[maxDprKey] || 0), adjustedDpr);
								mon[tmpModProp] = modOut;
							}

														reqAbilAdjust.push({
								ability: abilBeingScaled,
								mod: modOut,
								adjustedDpr,
							});
						};

						const getDiceExp = (a = numDiceOut, b = diceFacesOut, c = modOut) => {
							const ptDice = b === 1
								? ((a || 1) * b)
								: `${a}d${b}`;
							const ptMod = `${c !== 0 ? ` ${c > 0 ? "+" : ""} ${c}` : ""}`;
							return `${ptDice}${ptMod}`;
						};
						let loops = 0;
						while (1) {
							if (inRange(getAvgDpr(getDiceExp()))) break;
							if (loops > 100) throw new Error(`Failed to find new DPR! Current formula is: ${getDiceExp()}`);

							const tryAdjustNumDice = (diceFacesTemp = diceFacesOut, modTemp = modOut) => {
								let numDiceTemp = numDice;
								let tempAvgDpr = getAvgDpr(getDiceExp(numDiceTemp, diceFacesTemp, modTemp));

								let found = false;

								if (adjustedDpr < tempAvgDpr) {
									while (numDiceTemp > 1 && tempAvgDpr >= targetDprRange[0]) {
										numDiceTemp -= 1;
										tempAvgDpr -= (diceFacesTemp + 1) / 2;

										if (inRange(getAvgDpr(getDiceExp(numDiceTemp, diceFacesTemp, modTemp)))) {
											found = true;
											break;
										}
									}
								} else {
									while (tempAvgDpr <= targetDprRange[1]) {
										numDiceTemp += 1;
										tempAvgDpr += (diceFacesTemp + 1) / 2;

										if (inRange(getAvgDpr(getDiceExp(numDiceTemp, diceFacesTemp, modTemp)))) {
											found = true;
											break;
										}
									}
								}

								if (found) {
									numDiceOut = numDiceTemp;
									return true;
								}
								return false;
							};

							const tryAdjustDiceFaces = () => {
								if (diceFaces === 1 || diceFaces === 20) return; 								let diceFacesTemp = diceFaces;
								let tempAvgDpr = getAvgDpr(getDiceExp(undefined, diceFacesTemp));
								let found = false;

								if (adjustedDpr < tempAvgDpr) {
									while (diceFacesTemp > 1 && tempAvgDpr >= targetDprRange[0]) {
										diceFacesTemp = diceFacesTemp === 4
											? 1
											: Renderer.dice.getPreviousDice(diceFacesTemp);
										tempAvgDpr = getAvgDpr(getDiceExp(undefined, diceFacesTemp));

										if (inRange(getAvgDpr(getDiceExp(numDice, diceFacesTemp, modOut)))) {
											found = true;
											break;
										} else {
											found = tryAdjustNumDice(diceFacesTemp);
											if (found) break;
										}
									}
								} else {
									while (diceFacesTemp < 20 && tempAvgDpr <= targetDprRange[1]) {
										diceFacesTemp = Renderer.dice.getNextDice(diceFacesTemp);
										tempAvgDpr = getAvgDpr(getDiceExp(undefined, diceFacesTemp));

										if (inRange(getAvgDpr(getDiceExp(numDice, diceFacesTemp, modOut)))) {
											found = true;
											break;
										} else {
											found = tryAdjustNumDice(diceFacesTemp);
											if (found) break;
										}
									}
								}

								if (found) {
									diceFacesOut = diceFacesTemp;
									return true;
								}
								return false;
							};

							const tryAdjustMod = () => {
								if (modFromAbil == null) return;

																								modOut += (1 - ((loops % 2) * 2)) * (loops + 1);
							};

														const tryAdjustMod_alt = () => {
								if (modFromAbil == null) return;

								modOut += Math.sign(crOut - crIn);
								modOut = Math.max(-5, Math.min(modOut, 10)); 							};

																																			if (tryAdjustNumDice()) break;
							if (tryAdjustDiceFaces()) break;
							tryAdjustMod();

							loops++;
						}

						doPostCalc();
						const diceExpOut = getDiceExp(undefined, undefined, modOut + offsetEnchant);
						const avgDamOut = Math.floor(getAvgDpr(diceExpOut));
						if (avgDamOut <= 0 || diceExpOut === "1") return `1 ${suffix.replace(/^[^\w]+/, " ").replace(/ +/, " ")}`;
						return `${Math.floor(getAvgDpr(diceExpOut))}${prefix}${diceExpOut}${suffix}`;
					});

										if (!allSucceeded) return false;

					if (toUpdate !== out) {
						scaledEntries.push({
							prop,
							idxProp,
							entriesStrOriginal: toUpdate, 							entriesStr: out,
							reqAbilAdjust, 						});
					}
				});

				return allSucceeded;
			};

			if (!handleDpr("trait")) continue;
			if (!handleDpr("action")) continue;
			if (!handleDpr("bonus")) continue;
			if (!handleDpr("reaction")) continue;
			if (!handleDpr("legendary")) continue;
			if (!handleDpr("mythic")) continue;
			if (!handleDpr("variant")) continue;
			dprAdjustmentComplete = true;
		}

				scaledEntries.forEach(it => {
			mon[it.prop][it.idxProp].entries = JSON.parse(it.entriesStr);
		});

				const updateAbility = (prop) => {
						const [tmpModProp, oldScoreProp] = {
				"str": [`_strTmpMod`, `strOld`],
				"dex": [`_dexTmpMod`, `dexOld`],
			}[prop];

			if (mon[tmpModProp] != null) {
				mon[oldScoreProp] = mon[prop];
				mon[prop] = this._calcNewAbility(mon, prop, mon[tmpModProp]);
			}
			delete mon[tmpModProp];
		};
		updateAbility("str");
		updateAbility("dex");
	},

	_handleUpdateAbilityScoresSkillsSaves (mon) {
		const TO_HANDLE = ["str", "dex", "int", "wis", "con"];

		const getModString = (mod) => {
			return `${mod >= 0 ? "+" : ""}${mod}`;
		};

		TO_HANDLE.forEach(abil => {
			const abilOld = (() => {
								switch (abil) {
					case "str": return `strOld`;
					case "dex": return `dexOld`;
					case "int": return `intOld`;
					case "wis": return `wisOld`;
					case "con": return `conOld`;
					default: throw new Error(`Unimplemented!`);
				}
			})();
			if (mon[abilOld] != null) {
				const diff = Parser.getAbilityModNumber(mon[abil]) - Parser.getAbilityModNumber(mon[abilOld]);

				if (mon.save && mon.save[abil] != null) {
					const out = Number(mon.save[abil]) + diff;
					mon.save[abil] = UiUtil.intToBonus(out);
				}

				this._handleUpdateAbilityScoresSkillsSaves_handleSkills(mon.skill, abil, diff);

				if (abil === "wis" && mon.passive != null) {
					if (typeof mon.passive === "number") {
						mon.passive = mon.passive + diff;
					} else {
												delete mon.passive;
					}
				}
			}
		});
	},

	_handleUpdateAbilityScoresSkillsSaves_handleSkills (monSkill, abil, diff) {
		if (!monSkill) return;

		Object.keys(monSkill).forEach(skill => {
			if (skill === "other") {
				monSkill[skill].forEach(block => {
					if (block.oneOf) {
						this._handleUpdateAbilityScoresSkillsSaves_handleSkills(block.oneOf.oneOf, abil, diff);
					} else throw new Error(`Unhandled "other" skill keys: ${Object.keys(block)}`);
				});
				return;
			}

			const skillAbil = Parser.skillToAbilityAbv(skill);
			if (skillAbil !== abil) return;
			const out = Number(monSkill[skill]) + diff;
			monSkill[skill] = UiUtil.intToBonus(out);
		});
	},

	_spells: null,
	async _pInitSpellCache () {
		if (this._spells) return Promise.resolve();

		this._spells = {};

		this.__initSpellCache({
			spell: (await DataUtil.spell.loadJSON()).spell.filter(sp => sp.source === Parser.SRC_PHB),
		});
	},

	__initSpellCache (data) {
		data.spell.forEach(s => {
			Renderer.spell.getCombinedClasses(s, "fromClassList")
				.forEach(c => {
					let it = (this._spells[c.source] = this._spells[c.source] || {});
					const lowName = c.name.toLowerCase();
					it = (it[lowName] = it[lowName] || {});
					it = (it[s.level] = it[s.level] || {});
					it[s.name] = 1;
				});
		});
	},

	_adjustSpellcasting (mon, crIn, crOut) {
		const getSlotsAtLevel = (casterLvl, slotLvl) => {
						if (casterLvl < (slotLvl * 2) - 1) return 0;
			switch (slotLvl) {
				case 1: return casterLvl === 1 ? 2 : casterLvl === 2 ? 3 : 4;
				case 2: return casterLvl === 3 ? 2 : 3;
				case 3: return casterLvl === 5 ? 2 : 3;
				case 4: return casterLvl === 7 ? 1 : casterLvl === 8 ? 2 : 3;
				case 5: return casterLvl === 9 ? 1 : casterLvl < 18 ? 2 : 3;
				case 6: return casterLvl >= 19 ? 2 : 1;
				case 7: return casterLvl === 20 ? 2 : 1;
				case 8: return 1;
				case 9: return 1;
			}
		};

		if (!mon.spellcasting) return;

		const idealClvlIn = this._crToCasterLevel(crIn);
		const idealClvlOut = this._crToCasterLevel(crOut);

		const isWarlock = this._adjustSpellcasting_isWarlock(mon);
				let primaryInLevel = null;
		let primaryOutLevel = null;

		mon.spellcasting.forEach(sc => {
						let spellsFromClass = null;

			if (sc.headerEntries) {
				const inStr = JSON.stringify(sc.headerEntries);

				let anyChange = false;
				const outStr = inStr.replace(/(an?) (\d+)[A-Za-z]+-level/i, (...m) => {
					const level = Number(m[2]);
					const outLevel = Math.max(1, Math.min(20, this._getScaledToRatio(level, idealClvlIn, idealClvlOut)));
					anyChange = level !== outLevel;
					if (anyChange) {
						if (primaryInLevel == null) primaryInLevel = level;
						if (primaryOutLevel == null) primaryOutLevel = outLevel;
						return `${Parser.getArticle(outLevel)} ${Parser.spLevelToFull(outLevel)}-level`;
					} else return m[0];
				});

				const mClasses = /(artificer|bard|cleric|druid|paladin|ranger|sorcerer|warlock|wizard) spell(?:s)?/i.exec(outStr);
				if (mClasses) spellsFromClass = mClasses[1];
				else {
					const mClasses2 = /(artificer|bard|cleric|druid|paladin|ranger|sorcerer|warlock|wizard)(?:'s)? spell list/i.exec(outStr);
					if (mClasses2) spellsFromClass = mClasses2[1];
				}

				if (anyChange) sc.headerEntries = JSON.parse(outStr);
			}

						let maxSpellLevel = null;
			if (primaryOutLevel) {
				maxSpellLevel = Math.min(9, Math.ceil(primaryOutLevel / 2));

								if (/paladin|ranger|warlock/i.exec(spellsFromClass)) {
					maxSpellLevel = Math.min(5, primaryOutLevel);
				}
			}

			if (sc.spells && primaryOutLevel != null) {
				const spells = sc.spells;

								const isWarlockCasting = /warlock/i.exec(spellsFromClass) && Object.values(spells).filter(it => it.slots && it.lower).length === 1;

								if (spells[0]) {
					const curCantrips = spells[0].spells.length;
					const idealCantripsIn = this._casterLevelAndClassToCantrips(primaryInLevel, spellsFromClass);
					const idealCantripsOut = this._casterLevelAndClassToCantrips(primaryOutLevel, spellsFromClass);
					const targetCantripCount = this._getScaledToRatio(curCantrips, idealCantripsIn, idealCantripsOut);

					if (curCantrips < targetCantripCount) {
						const cantrips = Object.keys((this._spells[Parser.SRC_PHB][spellsFromClass.toLowerCase()] || {})[0]).map(it => it.toLowerCase());
						if (cantrips.length) {
							const extraCantrips = [];
							const numNew = Math.min(targetCantripCount - curCantrips, cantrips.length);
							for (let n = 0; n < numNew; ++n) {
								const ix = RollerUtil.roll(cantrips.length, this._rng);
								extraCantrips.push(cantrips[ix]);
								cantrips.splice(ix, 1);
							}
							spells[0].spells = spells[0].spells.concat(extraCantrips.map(it => `{@spell ${it}}`));
						}
					} else {
						const keepThese = this._protectedCantrips.map(it => `@spell ${it}`);
						while (spells[0].spells.length > targetCantripCount) {
							const ixs = spells[0].spells.filterIndex(it => !~keepThese.findIndex(x => it.includes(x)));
							if (ixs.length) {
								const ix = RollerUtil.roll(ixs.length, this._rng);
								spells[0].spells.splice(ix, 1);
							} else spells[0].spells.pop();
						}
					}
				}

								if (isWarlockCasting) {
					const curCastingLevel = Object.keys(spells).find(k => spells[k].lower);
					if (maxSpellLevel === Number(curCastingLevel)) return;
					if (maxSpellLevel === 0) {
						Object.keys(spells).filter(lvl => lvl !== "0").forEach(lvl => delete spells[lvl]);
						return;
					}

					const numSpellsKnown = this._adjustSpellcasting_getWarlockNumSpellsKnown(primaryOutLevel);
					const warlockSpells = this._spells[Parser.SRC_PHB].warlock;
					let spellList = [];
					for (let i = 1; i < maxSpellLevel + 1; ++i) {
						spellList = spellList.concat(Object.keys(warlockSpells[i]).map(sp => sp.toSpellCase()));
					}
					const spellsKnown = []; 					for (let i = 0; i < numSpellsKnown; ++i) {
						const ix = RollerUtil.roll(spellList.length, this._rng);
						spellsKnown.push(spellList[ix]);
						spellList.splice(ix, 1);
					}
					Object.keys(spells).filter(lvl => lvl !== "0").forEach(lvl => delete spells[lvl]);
					const slots = this._adjustSpellcasting_getWarlockNumSpellSlots(maxSpellLevel);
					spells[maxSpellLevel] = {
						slots,
						lower: 1,
						spells: [
							`A selection of ${maxSpellLevel === 1 ? `{@filter 1st-level warlock spells|spells|level=${1}|class=warlock}.` : `{@filter 1st- to ${Parser.spLevelToFull(maxSpellLevel)}-level warlock spells|spells|level=${[...new Array(maxSpellLevel)].map((_, i) => i + 1).join(";")}|class=warlock}.`}  Examples include: ${spellsKnown.sort(SortUtil.ascSortLower).map(it => `{@spell ${it}}`).joinConjunct(", ", " and ")}`,
						],
					};
				} else {
					let lastRatio = 1; 					for (let i = 1; i < 10; ++i) {
						const atLevel = spells[i];
						const idealSlotsIn = getSlotsAtLevel(primaryInLevel, i);
						const idealSlotsOut = getSlotsAtLevel(primaryOutLevel, i);

						if (atLevel) {
														if (atLevel.slots) { 								const adjustedSlotsOut = this._getScaledToRatio(atLevel.slots, idealSlotsIn, idealSlotsOut);
								lastRatio = adjustedSlotsOut / idealSlotsOut;

								atLevel.slots = adjustedSlotsOut;
								if (adjustedSlotsOut <= 0) {
									delete spells[i];
								}
							}
						} else if (i <= maxSpellLevel) {
							const slots = Math.max(1, Math.round(idealSlotsOut * lastRatio));
							if (spellsFromClass && (this._spells[Parser.SRC_PHB][spellsFromClass.toLowerCase()] || {})[i]) {
								const examples = [];
								const levelSpells = Object.keys(this._spells[Parser.SRC_PHB][spellsFromClass.toLowerCase()][i]).map(it => it.toSpellCase());
								const numExamples = Math.min(5, levelSpells.length);
								for (let n = 0; n < numExamples; ++n) {
									const ix = RollerUtil.roll(levelSpells.length, this._rng);
									examples.push(levelSpells[ix]);
									levelSpells.splice(ix, 1);
								}
								spells[i] = {
									slots,
									spells: [
										`A selection of {@filter ${Parser.spLevelToFull(i)}-level ${spellsFromClass} spells|spells|level=${i}|class=${spellsFromClass}}. Examples include: ${examples.sort(SortUtil.ascSortLower).map(it => `{@spell ${it}}`).joinConjunct(", ", " and ")}`,
									],
								};
							} else {
								spells[i] = {
									slots,
									spells: [
										`A selection of {@filter ${Parser.spLevelToFull(i)}-level spells|spells|level=${i}}`,
									],
								};
							}
						} else {
							delete spells[i];
						}
					}
				}
			}
		});

		mon.spellcasting.forEach(sc => {
						if (isWarlock && sc.daily && sc.daily["1e"]) {
				const numArcanum = this._adjustSpellcasting_getWarlockNumArcanum(primaryOutLevel);

				const curNumSpells = sc.daily["1e"].length;

				if (sc.daily["1e"].length === numArcanum) return;
				if (numArcanum === 0) return delete sc.daily["1e"];

				if (curNumSpells > numArcanum) {
										const curSpells = sc.daily["1e"].map(it => {
						const m = /{@spell ([^|}]+)(?:\|([^|}]+))?[|}]/.exec(it);
						if (m) {
							const nameTag = m[1].toLowerCase();
							const srcTag = (m[2] || Parser.SRC_PHB).toLowerCase();

							const src = Object.keys(this._spells).find(it => it.toLowerCase() === srcTag);
							if (src) {
								const levelStr = Object.keys(this._spells[src].warlock || {}).find(lvl => Object.keys((this._spells[src].warlock || {})[lvl]).some(nm => nm.toLowerCase() === nameTag));

								if (levelStr) return {original: it, level: Number(levelStr)};
							}
						}
						return {original: it, level: null};
					});

					for (let i = 9; i > 5; --i) {
						const ixToRemove = curSpells.map(it => it.level === i ? curSpells.indexOf(it) : -1).filter(it => ~it);
						while (ixToRemove.length && curSpells.length > numArcanum) {
							curSpells.splice(ixToRemove.pop(), 1);
						}
						if (curSpells.length === numArcanum) break;
					}

					sc.daily["1e"] = curSpells.map(it => it.original);
				} else {
					for (let i = 5 + curNumSpells; i < 5 + numArcanum; ++i) {
						const rollOn = Object.keys(this._spells[Parser.SRC_PHB].warlock[i]);
						const ix = RollerUtil.roll(rollOn.length, this._rng);
						sc.daily["1e"].push(`{@spell ${rollOn[ix].toSpellCase()}}`);
					}

					sc.daily["1e"].sort(SortUtil.ascSortLower);
				}
			}
		});
	},

	_adjustSpellcasting_isWarlock (mon) {
		if (mon.spellcasting) {
			return mon.spellcasting.some(sc => sc.headerEntries && /warlock spells?|warlock('s)? spell list/i.test(JSON.stringify(sc.headerEntries)));
		}
	},

	_adjustSpellcasting_getWarlockNumSpellsKnown (level) {
		return level <= 9 ? level + 1 : 10 + Math.ceil((level - 10) / 2);
	},

	_adjustSpellcasting_getWarlockNumSpellSlots (level) {
		return level === 1 ? 1 : level < 11 ? 2 : level < 17 ? 3 : 4;
	},

	_adjustSpellcasting_getWarlockNumArcanum (level) {
		return level < 11 ? 0 : level < 13 ? 1 : level < 15 ? 2 : level < 17 ? 3 : 4;
	},
};

globalThis.ScaleSummonedCreature = {
	_mutSimpleSpecialAcItem (acItem) {
				const mSimpleNatural = /^(\d+) \(natural armor\)$/i.exec(acItem.special);
		if (mSimpleNatural) {
			delete acItem.special;
			acItem.ac = Number(mSimpleNatural[1]);
			acItem.from = ["natural armor"];
		}
	},

		_mutSimpleSpecialHp (mon) {
		if (!mon.hp?.special) return;

		const cleanHp = mon.hp.special.toLowerCase().replace(/ /g, "");
		const mHp = /^(?<averagePart>\d+)(?<hdPart>\((?<dicePart>\d+d\d+)(?<bonusPart>[-+]\d+)?\))?$/.exec(cleanHp);

		if (!mHp) return;

		if (!mHp.groups.hdPart) return {average: Number(mHp.groups.averagePart)};

		mon.hp = {
			average: Number(mHp.groups.averagePart),
			formula: `${mHp.groups.dicePart}${mHp.groups.bonusPart ? mHp.groups.bonusPart.replace(/[-+]/g, " $0 ") : ""}`,
		};
	},
};

globalThis.ScaleSpellSummonedCreature = {
	async scale (mon, toSpellLevel) {
		mon = MiscUtil.copyFast(mon);

		if (!mon.summonedBySpell || mon.summonedBySpellLevel == null) return mon;

		ScaleSpellSummonedCreature._WALKER = ScaleSpellSummonedCreature._WALKER || MiscUtil.getWalker({keyBlocklist: MiscUtil.GENERIC_WALKER_ENTRIES_KEY_BLOCKLIST});

		const state = new ScaleSpellSummonedCreature.State({});

		mon._displayName = `${mon.name} (${Parser.getOrdinalForm(toSpellLevel)}-Level Spell)`;

		this._scale_ac(mon, toSpellLevel, state);
		this._scale_hp(mon, toSpellLevel, state);

		this._scale_traits(mon, toSpellLevel, state);
		this._scale_actions(mon, toSpellLevel, state);
		this._scale_bonusActions(mon, toSpellLevel, state);
		this._scale_reactions(mon, toSpellLevel, state);

		mon._summonedBySpell_level = toSpellLevel;
		mon._scaledSpellSummonLevel = toSpellLevel;
		mon._isScaledSpellSummon = true;

		return mon;
	},

	_scale_ac (mon, toSpellLevel, state) {
		if (!mon.ac) return;

		mon.ac = mon.ac.map(it => {
			if (!it.special) return it;

			it.special = it.special
								.replace(/(\d+)\s*\+\s*the level of the spell/g, (...m) => Number(m[1]) + toSpellLevel)
			;

			ScaleSummonedCreature._mutSimpleSpecialAcItem(it);

			return it;
		});
	},

	_scale_hp (mon, toSpellLevel, state) {
		if (!mon.hp?.special) return;

		mon.hp.special = mon.hp.special
						.replace(/(\d+)\s*\+\s*(\d+) for each spell level above (\d+)(?:st|nd|rd|th)/g, (...m) => {
				const [, hpBase, hpPlus, spLevelMin] = m;
				return Number(hpBase) + (Number(hpPlus) * (toSpellLevel - Number(spLevelMin)));
			})
						.replace(/(ten) times the spell's level/g, (...m) => {
				const [, numMult] = m;
				return Parser.textToNumber(numMult) * toSpellLevel;
			})
		;

		ScaleSummonedCreature._mutSimpleSpecialHp(mon);
	},

	_scale_genericEntries (mon, toSpellLevel, state, prop) {
		if (!mon[prop]) return;
		mon[prop] = ScaleSpellSummonedCreature._WALKER.walk(
			mon[prop],
			{
				string: (str) => {
					str = str
												.replace(/a number of attacks equal to half this spell's level \(rounded down\)/g, (...m) => {
							const count = Math.floor(toSpellLevel / 2);
							return `${Parser.numberToText(count)} attack${count === 1 ? "" : "s"}`;
						})
												.replace(/{@(?:dice|damage|hit|d20) [^}]+}/g, (...m) => {
							return m[0]
								.replace(/\bsummonSpellLevel\b/g, (...n) => toSpellLevel)
							;
						})
					;

					return str;
				},
			},
		);
	},

	_scale_traits (mon, toSpellLevel, state) { this._scale_genericEntries(mon, toSpellLevel, state, "trait"); },
	_scale_actions (mon, toSpellLevel, state) { this._scale_genericEntries(mon, toSpellLevel, state, "action"); },
	_scale_bonusActions (mon, toSpellLevel, state) { this._scale_genericEntries(mon, toSpellLevel, state, "bonus"); },
	_scale_reactions (mon, toSpellLevel, state) { this._scale_genericEntries(mon, toSpellLevel, state, "reaction"); },

	State: function () {
					},

	_WALKER: null,
};

globalThis.ScaleClassSummonedCreature = {
	async scale (mon, toClassLevel) {
		mon = MiscUtil.copyFast(mon);

		if (!mon.summonedByClass || toClassLevel < 1) return mon;

		ScaleClassSummonedCreature._WALKER = ScaleClassSummonedCreature._WALKER || MiscUtil.getWalker({keyBlocklist: MiscUtil.GENERIC_WALKER_ENTRIES_KEY_BLOCKLIST});

		const className = mon.summonedByClass.split("|")[0].toTitleCase();
		const state = new ScaleClassSummonedCreature.State({
			className,
			proficiencyBonus: Parser.levelToPb(toClassLevel),
		});

		mon._displayName = `${mon.name} (Level ${toClassLevel} ${className})`;

		this._scale_ac(mon, toClassLevel, state);
		this._scale_hp(mon, toClassLevel, state);

		this._scale_saves(mon, toClassLevel, state);
		this._scale_skills(mon, toClassLevel, state);

		this._scale_pbNote(mon, toClassLevel, state);

		this._scale_traits(mon, toClassLevel, state);
		this._scale_actions(mon, toClassLevel, state);
		this._scale_bonusActions(mon, toClassLevel, state);
		this._scale_reactions(mon, toClassLevel, state);

		mon._summonedByClass_level = toClassLevel;
		mon._scaledClassSummonLevel = toClassLevel;
		mon._isScaledClassSummon = true;

		return mon;
	},

	_scale_ac (mon, toClassLevel, state) {
		if (!mon.ac) return;

		mon.ac = mon.ac.map(it => {
			if (!it.special) return it;

			it.special = it.special
								.replace(/(\d+)\s*\+\s*PB\b/g, (...m) => Number(m[1]) + state.proficiencyBonus)
			;

			ScaleSummonedCreature._mutSimpleSpecialAcItem(it);

			return it;
		});
	},

	_scale_getConvertedPbString (state, str, {isBonus = false} = {}) {
		let out = str
			.replace(/\bplus\b/gi, "+")
			.replace(/(\b|[-+])PB\b/g, `$1${state.proficiencyBonus}`)
						.replace(/[-+]\s*\d+\s*[-+]\s*\d+\b/g, (...n) => eval(n[0]))
		;

		const reDice = /(\b(?:\d+)?d\d+\b)/g;
		let ix = 0;
		const outSimplified = out.split(reDice)
			.map(pt => {
								if (!pt.trim()) return pt;

				if (reDice.test(pt)) {
					ix++;
					return pt;
				}

				const simplified = Renderer.dice.parseRandomise2(pt);
				if (simplified != null) {
					if (ix) {
						ix++;
						return UiUtil.intToBonus(simplified);
					}
					ix++;
					return simplified;
				}

				ix++;
				return pt;
			})
			.join("")
			.replace(/\s*[-+]\s*/g, (...m) => ` ${m[0].trim()} `);

		if (!isNaN(outSimplified) && isBonus) return UiUtil.intToBonus(outSimplified);
		return outSimplified;
	},

	_scale_savesSkills (mon, toClassLevel, state, prop) {
		mon[prop] = Object.entries(mon[prop])
			.mergeMap(([k, v]) => {
				if (typeof v !== "string") return {[k]: v};
				return {[k]: this._scale_getConvertedPbString(state, v, {isBonus: true})};
			});
	},

	_scale_saves (mon, toClassLevel, state) {
		if (!mon.save) return;
		this._scale_savesSkills(mon, toClassLevel, state, "save");
	},

	_scale_skills (mon, toClassLevel, state) {
		if (mon.passive != null) mon.passive = this._scale_getConvertedPbString(state, `${mon.passive}`);

		if (!mon.skill) return;
		this._scale_savesSkills(mon, toClassLevel, state, "skill");
	},

	_scale_hp (mon, toClassLevel, state) {
		if (!mon.hp?.special) return;

		let basePart = mon.hp.special; let hdPart = ""; let yourAbilModPart = "";
		if (mon.hp.special.includes("(")) {
			let [start, ...rest] = mon.hp.special.split("(");
			rest = rest.join("(");
			if (rest.toLowerCase().includes("hit dice")) {
				basePart = start.trim();
				hdPart = rest.trimAnyChar("() ");
			}
		}

		basePart = basePart
			.replace(/\+\s*your (?:Strength|Dexterity|Constitution|Intelligence|Wisdom|Charisma) modifier/i, (...m) => {
				yourAbilModPart = m[0];
				return "";
			})
			.replace(/ +/g, " ")
			.trim();

		basePart = basePart
						.replace(/(?<base>\d+)\s*\+\s*(?<perLevel>\d+|[a-z]+) times your (?:(?<className>[^(]*) )?level/g, (...m) => {
				const numTimes = isNaN(m.last().perLevel) ? Parser.textToNumber(m.last().perLevel) : Number(m.last().perLevel);
				return `${Number(m.last().base) + (numTimes * toClassLevel)}`;
			})
						.replace(/(?<base>\d+)\s*\+\s*your (?:(?<className>[^(]*) )?level/g, (...m) => {
				return `${Number(m.last().base) + toClassLevel}`;
			})
						.replace(/equal .*? Constitution modifier\s*\+\s*(?<perLevel>\d+|[a-z]+) times your (?:(?<className>[^(]*) )?level/g, (...m) => {
				const numTimes = isNaN(m.last().perLevel) ? Parser.textToNumber(m.last().perLevel) : Number(m.last().perLevel);
				return `${Parser.getAbilityModNumber(mon.con) + (numTimes * toClassLevel)}`;
			})
		;

		basePart = this._scale_getConvertedPbString(state, basePart);

				if (hdPart) {
			hdPart = hdPart.replace(/(?<intro>.*) a number of hit dice \[d(?<hdSides>\d+)s?] equal to your (?:(?<className>[^(]*) )?level/i, (...m) => {
				const hdFormula = `${toClassLevel}d${m.last().hdSides}`;
				if (!yourAbilModPart) return hdFormula;

				return `${m.last().intro} {@dice ${hdFormula}} Hit Dice`;
			});
		}

				if (yourAbilModPart) {
			mon.hp.special = `${basePart} ${yourAbilModPart}${hdPart ? ` (${hdPart})` : ""}`.trim();
		} else {
			mon.hp.special = `${basePart}${hdPart ? ` (${hdPart})` : ""}`.trim();
		}

		ScaleSummonedCreature._mutSimpleSpecialHp(mon);
	},

	_scale_genericEntries (mon, toClassLevel, state, prop) {
		if (!mon[prop]) return;
		mon[prop] = ScaleClassSummonedCreature._WALKER.walk(
			mon[prop],
			{
				string: (str) => {
					str = str
												.replace(/add your proficiency bonus/gi, (...m) => {
							return `${m[0]} (${UiUtil.intToBonus(state.proficiencyBonus)})`;
						})
												.replace(/{@(?<tag>dice|damage|hit|d20|dc) (?<text>[^}]+)}/g, (...m) => {
							const {tag, text} = m.last();
							const [ptNumber, ...ptsRest] = text.split("|");

							const ptNumberOut = this._scale_getConvertedPbString(state, ptNumber);

							return `{@${tag} ${[ptNumberOut, ...ptsRest].join("|")}}`;
						})
					;

					return str;
				},
			},
		);
	},

	_scale_traits (mon, toClassLevel, state) { this._scale_genericEntries(mon, toClassLevel, state, "trait"); },
	_scale_actions (mon, toClassLevel, state) { this._scale_genericEntries(mon, toClassLevel, state, "action"); },
	_scale_bonusActions (mon, toClassLevel, state) { this._scale_genericEntries(mon, toClassLevel, state, "bonus"); },
	_scale_reactions (mon, toClassLevel, state) { this._scale_genericEntries(mon, toClassLevel, state, "reaction"); },

	_scale_pbNote (mon, toClassLevel, state) {
		if (!mon.pbNote) return;

		mon.pbNote = mon.pbNote.replace(/equals your bonus\b/, (...m) => `${m[0]} (${UiUtil.intToBonus(state.proficiencyBonus, {isPretty: true})})`);
	},

	State: function ({className, proficiencyBonus}) {
		this.className = className;
		this.proficiencyBonus = proficiencyBonus;
	},

	_WALKER: null,
};

"use strict";

class StatGenUi extends BaseComponent {
	static _PROPS_POINT_BUY_CUSTOM = [
		"pb_rules",
		"pb_budget",
		"pb_isCustom",
	];

		constructor (opts) {
		super();
		opts = opts || {};

		TabUiUtilSide.decorate(this, {isInitMeta: true});

		this._races = opts.races;
		this._backgrounds = opts.backgrounds;
		this._feats = opts.feats;
		this._tabMetasAdditional = opts.tabMetasAdditional;
		this._isCharacterMode = opts.isCharacterMode;
		this._isFvttMode = opts.isFvttMode;

		this._MODES = this._isFvttMode ? StatGenUi.MODES_FVTT : StatGenUi.MODES;
		if (this._isFvttMode) {
			let cnt = 0;
			this._IX_TAB_NONE = cnt++;
			this._IX_TAB_ROLLED = cnt++;
			this._IX_TAB_ARRAY = cnt++;
			this._IX_TAB_PB = cnt++;
			this._IX_TAB_MANUAL = cnt;
		} else {
			this._IX_TAB_NONE = -1;
			let cnt = 0;
			this._IX_TAB_ROLLED = cnt++;
			this._IX_TAB_ARRAY = cnt++;
			this._IX_TAB_PB = cnt++;
			this._IX_TAB_MANUAL = cnt;
		}

		this._modalFilterRaces = opts.modalFilterRaces || new ModalFilterRaces({namespace: "statgen.races", isRadio: true, allData: this._races});
		this._modalFilterBackgrounds = opts.modalFilterBackgrounds || new ModalFilterBackgrounds({namespace: "statgen.backgrounds", isRadio: true, allData: this._backgrounds});
		this._modalFilterFeats = opts.modalFilterFeats || new ModalFilterFeats({namespace: "statgen.feats", isRadio: true, allData: this._feats});

		this._isLevelUp = !!opts.existingScores;
		this._existingScores = opts.existingScores;

				this._$rollIptFormula = null;
		
				this._compAsi = new StatGenUi.CompAsi({parent: this});
			}

	get MODES () { return this._MODES; }

	get ixActiveTab () { return this._getIxActiveTab(); }
	set ixActiveTab (ix) { this._setIxActiveTab({ixActiveTab: ix}); }

		addHookPointBuyCustom (hook) { this.constructor._PROPS_POINT_BUY_CUSTOM.forEach(prop => this._addHookBase(prop, hook)); }

	addHookAbilityScores (hook) { Parser.ABIL_ABVS.forEach(ab => this._addHookBase(`common_export_${ab}`, hook)); }
	addHookPulseAsi (hook) { this._addHookBase("common_pulseAsi", hook); }
	getFormDataAsi () { return this._compAsi.getFormData(); }

	getMode (ix, namespace) {
		const {propMode} = this.getPropsAsi(ix, namespace);
		return this._state[propMode];
	}

	setIxFeat (ix, namespace, ixFeat) {
		const {propMode, propIxFeat} = this.getPropsAsi(ix, namespace);

		if (ixFeat == null && (this._state[propMode] === "asi" || this._state[propMode] == null)) {
			this._state[propIxFeat] = null;
			return;
		}

		this._state[propMode] = "feat";
		this._state[propIxFeat] = ixFeat;
	}

	setIxFeatSet (namespace, ixSet) {
		const {propIxSel} = this.getPropsAdditionalFeats_(namespace);
		this._state[propIxSel] = ixSet;
	}

	setIxFeatSetIxFeats (namespace, metaFeats) {
		const nxtState = {};
		metaFeats.forEach(({ix, ixFeat}) => {
			const {propIxFeat} = this.getPropsAdditionalFeatsFeatSet_(namespace, "fromFilter", ix);
			nxtState[propIxFeat] = ixFeat;
		});
		this._proxyAssignSimple("state", nxtState);
	}

	set common_cntAsi (val) { this._state.common_cntAsi = val; }

	addHookIxRace (hook) { this._addHookBase("common_ixRace", hook); }
	get ixRace () { return this._state.common_ixRace; }
	set ixRace (ixRace) { this._state.common_ixRace = ixRace; }

	addHookIxBackground (hook) { this._addHookBase("common_ixBackground", hook); }
	get ixBackground () { return this._state.common_ixBackground; }
	set ixBackground (ixBackground) { this._state.common_ixBackground = ixBackground; }

	addCustomFeat () { this._state.common_cntFeatsCustom = Math.min(StatGenUi._MAX_CUSTOM_FEATS, (this._state.common_cntFeatsCustom || 0) + 1); }
	setCntCustomFeats (val) { this._state.common_cntFeatsCustom = Math.min(StatGenUi._MAX_CUSTOM_FEATS, val || 0); }
	
		get isCharacterMode () { return this._isCharacterMode; }
	get state () { return this._state; }
	get modalFilterFeats () { return this._modalFilterFeats; }
	get feats () { return this._feats; }
	addHookBase (prop, hook) { return this._addHookBase(prop, hook); }
	removeHookBase (prop, hook) { return this._removeHookBase(prop, hook); }
	proxyAssignSimple (hookProp, toObj, isOverwrite) { return this._proxyAssignSimple(hookProp, toObj, isOverwrite); }
	get race () { return this._races[this._state.common_ixRace]; }
	get background () { return this._backgrounds[this._state.common_ixBackground]; }
	get isLevelUp () { return this._isLevelUp; }
	
	getTotals () {
		if (this._isLevelUp) {
			return {
				mode: "levelUp",
				totals: {
					levelUp: this._getTotals_levelUp(),
				},
			};
		}

		return {
			mode: this._MODES[this.ixActiveTab || 0],
			totals: {
				rolled: this._getTotals_rolled(),
				array: this._getTotals_array(),
				pointbuy: this._getTotals_pb(),
				manual: this._getTotals_manual(),
			},
		};
	}

	_getTotals_rolled () { return Parser.ABIL_ABVS.mergeMap(ab => ({[ab]: this._rolled_getTotalScore(ab)})); }
	_getTotals_array () { return Parser.ABIL_ABVS.mergeMap(ab => ({[ab]: this._array_getTotalScore(ab)})); }
	_getTotals_pb () { return Parser.ABIL_ABVS.mergeMap(ab => ({[ab]: this._pb_getTotalScore(ab)})); }
	_getTotals_manual () { return Parser.ABIL_ABVS.mergeMap(ab => ({[ab]: this._manual_getTotalScore(ab)})); }
	_getTotals_levelUp () { return Parser.ABIL_ABVS.mergeMap(ab => ({[ab]: this._levelUp_getTotalScore(ab)})); }

	addHook (hookProp, prop, hook) { return this._addHook(hookProp, prop, hook); }
	addHookAll (hookProp, hook) {
		this._addHookAll(hookProp, hook);
		this._compAsi._addHookAll(hookProp, hook);
	}

	addHookActiveTag (hook) { this._addHookActiveTab(hook); }

	async pInit () {
		await this._modalFilterRaces.pPreloadHidden();
		await this._modalFilterBackgrounds.pPreloadHidden();
		await this._modalFilterFeats.pPreloadHidden();
	}

	getPropsAsi (ix, namespace) {
		return {
			prefix: `common_asi_${namespace}_${ix}_`,
			propMode: `common_asi_${namespace}_${ix}_mode`,
			propIxAsiPointOne: `common_asi_${namespace}_${ix}_asiPointOne`,
			propIxAsiPointTwo: `common_asi_${namespace}_${ix}_asiPointTwo`,
			propIxFeat: `common_asi_${namespace}_${ix}_ixFeat`,
			propIxFeatAbility: `common_asi_${namespace}_${ix}_ixFeatAbility`,
			propFeatAbilityChooseFrom: `common_asi_${namespace}_${ix}_featAbilityChooseFrom`,
		};
	}

	getPropsAdditionalFeats_ (namespace) {
		return {
			propPrefix: `common_additionalFeats_${namespace}_`,
			propIxSel: `common_additionalFeats_${namespace}_ixSel`,
		};
	}

	getPropsAdditionalFeatsFeatSet_ (namespace, type, ix) {
		return {
			propIxFeat: `common_additionalFeats_${namespace}_${type}_${ix}_ixFeat`,
			propIxFeatAbility: `common_additionalFeats_${namespace}_${type}_${ix}_ixFeatAbility`,
			propFeatAbilityChooseFrom: `common_additionalFeats_${namespace}_${type}_${ix}_featAbilityChooseFrom`,
		};
	}

	_roll_getRolledStats () {
		const wrpTree = Renderer.dice.lang.getTree3(this._state.rolled_formula);
		if (!wrpTree) return this._$rollIptFormula.addClass("form-control--error");

		const rolls = [];
		for (let i = 0; i < this._state.rolled_rollCount; i++) {
			const meta = {};
			meta.total = wrpTree.tree.evl(meta);
			rolls.push(meta);
		}
		rolls.sort((a, b) => SortUtil.ascSort(b.total, a.total));

		return rolls.map(r => ({total: r.total, text: (r.text || []).join("")}));
	}

	render ($parent) {
		$parent.empty().addClass("statgen");

		const iptTabMetas = this._isLevelUp
			? [
				new TabUiUtil.TabMeta({name: "Existing", icon: this._isFvttMode ? `fas fa-fw fa-user` : `far fa-fw fa-user`, hasBorder: true}),
				...this._tabMetasAdditional || [],
			]
			: [
				this._isFvttMode ? new TabUiUtil.TabMeta({name: "Select...", icon: this._isFvttMode ? `fas fa-fw fa-square` : `far fa-fw fa-square`, hasBorder: true, isNoPadding: this._isFvttMode}) : null,
				new TabUiUtil.TabMeta({name: "Roll", icon: this._isFvttMode ? `fas fa-fw fa-dice` : `far fa-fw fa-dice`, hasBorder: true, isNoPadding: this._isFvttMode}),
				new TabUiUtil.TabMeta({name: "Standard Array", icon: this._isFvttMode ? `fas fa-fw fa-signal` : `far fa-fw fa-signal-alt`, hasBorder: true, isNoPadding: this._isFvttMode}),
				new TabUiUtil.TabMeta({name: "Point Buy", icon: this._isFvttMode ? `fas fa-fw fa-chart-bar` : `far fa-fw fa-chart-bar`, hasBorder: true, isNoPadding: this._isFvttMode}),
				new TabUiUtil.TabMeta({name: "Manual", icon: this._isFvttMode ? `fas fa-fw fa-tools` : `far fa-fw fa-tools`, hasBorder: true, isNoPadding: this._isFvttMode}),
				...this._tabMetasAdditional || [],
			].filter(Boolean);

		const tabMetas = this._renderTabs(iptTabMetas, {$parent: this._isFvttMode ? null : $parent});
		if (this._isFvttMode) {
			if (!this._isLevelUp) {
				const {propActive: propActiveTab, propProxy: propProxyTabs} = this._getTabProps();
				const $selMode = ComponentUiUtil.$getSelEnum(
					this,
					propActiveTab,
					{
						values: iptTabMetas.map((_, ix) => ix),
						fnDisplay: ix => iptTabMetas[ix].name,
						propProxy: propProxyTabs,
					},
				)
					.addClass("max-w-200p");
				$$`<div class="ve-flex-v-center statgen-shared__wrp-header">
					<div class="mr-2"><b>Mode</b></div>
					${$selMode}
				</div>
				<hr class="hr-2">`.appendTo($parent);
			}

			tabMetas.forEach(it => it.$wrpTab.appendTo($parent));
		}

		const $wrpAll = $(`<div class="ve-flex-col w-100 h-100"></div>`);
		this._render_all($wrpAll);

		const hkTab = () => {
			tabMetas[this.ixActiveTab || 0].$wrpTab.append($wrpAll);
		};
		this._addHookActiveTab(hkTab);
		hkTab();

		this._addHookBase("common_cntAsi", () => this._state.common_pulseAsi = !this._state.common_pulseAsi);
		this._addHookBase("common_cntFeatsCustom", () => this._state.common_pulseAsi = !this._state.common_pulseAsi);
	}

	_render_$getStgRolledHeader () {
		this._$rollIptFormula = ComponentUiUtil.$getIptStr(this, "rolled_formula")
			.addClass("text-center max-w-100p")
			.keydown(evt => {
				if (evt.key === "Enter") setTimeout(() => $btnRoll.click()); 			})
			.change(() => this._$rollIptFormula.removeClass("form-control--error"));

		const $iptRollCount = this._isCharacterMode ? null : ComponentUiUtil.$getIptInt(this, "rolled_rollCount", 1, {min: 1, fallbackOnNaN: 1, html: `<input type="text" class="form-control input-xs form-control--minimal text-center max-w-100p">`})
			.keydown(evt => {
				if (evt.key === "Enter") setTimeout(() => $btnRoll.click()); 			})
			.change(() => this._$rollIptFormula.removeClass("form-control--error"));

		const $btnRoll = $(`<button class="btn btn-primary bold">Roll</button>`)
			.click(() => {
				this._state.rolled_rolls = this._roll_getRolledStats();
			});

		const $btnRandom = $(`<button class="btn btn-xs btn-default mt-2">Randomly Assign</button>`)
			.hideVe()
			.click(() => {
				const abs = [...Parser.ABIL_ABVS].shuffle();
				abs.forEach((ab, i) => {
					const {propAbilSelectedRollIx} = this.constructor._rolled_getProps(ab);
					this._state[propAbilSelectedRollIx] = i;
				});
			});

		const $wrpRolled = $(`<div class="ve-flex-v-center mr-auto statgen-rolled__wrp-results py-1"></div>`);
		const $wrpRolledOuter = $$`<div class="ve-flex-v-center"><div class="mr-2">=</div>${$wrpRolled}</div>`;

		const hkRolled = () => {
			$wrpRolledOuter.toggleVe(this._state.rolled_rolls.length);
			$btnRandom.toggleVe(this._state.rolled_rolls.length);

			$wrpRolled.html(this._state.rolled_rolls.map((it, i) => {
				const cntPrevRolls = this._state.rolled_rolls.slice(0, i).filter(r => r.total === it.total).length;
				return `<div class="px-3 py-1 help-subtle ve-flex-vh-center" title="${it.text}"><div class="ve-muted">[</div><div class="ve-flex-vh-center statgen-rolled__disp-result">${it.total}${cntPrevRolls ? Parser.numberToSubscript(cntPrevRolls) : ""}</div><div class="ve-muted">]</div></div>`;
			}));
		};
		this._addHookBase("rolled_rolls", hkRolled);
		hkRolled();

		return $$`<div class="ve-flex-col mb-3 mr-auto">
			<div class="ve-flex mb-2">
				<div class="ve-flex-col ve-flex-h-center mr-3">
					<label class="ve-flex-v-center"><div class="mr-2 no-shrink w-100p">Formula:</div>${this._$rollIptFormula}</label>

					${this._isCharacterMode ? null : $$`<label class="ve-flex-v-center mt-2"><div class="mr-2 no-shrink w-100p">Number of rolls:</div>${$iptRollCount}</label>`}
				</div>
				${$btnRoll}
			</div>

			${$wrpRolledOuter}

			<div class="ve-flex-v-center">${$btnRandom}</div>
		</div>`;
	}

	_render_$getStgArrayHeader () {
		const $btnRandom = $(`<button class="btn btn-xs btn-default">Randomly Assign</button>`)
			.click(() => {
				const abs = [...Parser.ABIL_ABVS].shuffle();
				abs.forEach((ab, i) => {
					const {propAbilSelectedScoreIx} = this.constructor._array_getProps(ab);
					this._state[propAbilSelectedScoreIx] = i;
				});
			});

		return $$`<div class="ve-flex-col mb-3 mr-auto">
			<div class="mb-2">Assign these numbers to your abilities as desired:</div>
			<div class="bold mb-2">${StatGenUi._STANDARD_ARRAY.join(", ")}</div>
			<div class="ve-flex">${$btnRandom}</div>
		</div>`;
	}

	_render_$getStgManualHeader () {
		return $$`<div class="ve-flex-col mb-3 mr-auto">
			<div>Enter your desired ability scores in the &quot;Base&quot; column below.</div>
		</div>`;
	}

	_doReset () {
		if (this._isLevelUp) return; 
		const nxtState = this._getDefaultStateCommonResettable();

		switch (this.ixActiveTab) {
			case this._IX_TAB_NONE: Object.assign(nxtState, this._getDefaultStateNoneResettable()); break;
			case this._IX_TAB_ROLLED: Object.assign(nxtState, this._getDefaultStateRolledResettable()); break;
			case this._IX_TAB_ARRAY: Object.assign(nxtState, this._getDefaultStateArrayResettable()); break;
			case this._IX_TAB_PB: Object.assign(nxtState, this._getDefaultStatePointBuyResettable()); break;
			case this._IX_TAB_MANUAL: Object.assign(nxtState, this._getDefaultStateManualResettable()); break;
		}

		this._proxyAssignSimple("state", nxtState);
	}

	doResetAll () {
		this._proxyAssignSimple("state", this._getDefaultState(), true);
	}

	_render_$getStgPbHeader () {
		const $iptBudget = ComponentUiUtil.$getIptInt(
			this,
			"pb_budget",
			0,
			{
				html: `<input type="text" class="form-control statgen-pb__ipt-budget text-center statgen-shared__ipt">`,
				min: 0,
				fallbackOnNaN: 0,
			},
		);
		const hkIsCustom = () => {
			$iptBudget.attr("readonly", !this._state.pb_isCustom);
		};
		this._addHookBase("pb_isCustom", hkIsCustom);
		hkIsCustom();

		const $iptRemaining = ComponentUiUtil.$getIptInt(
			this,
			"pb_points",
			0,
			{
				html: `<input type="text" class="form-control statgen-pb__ipt-budget text-center statgen-shared__ipt">`,
				min: 0,
				fallbackOnNaN: 0,
			},
		).attr("readonly", true);

		const hkPoints = () => {
			this._state.pb_points = this._pb_getPointsRemaining(this._state);
			$iptRemaining.toggleClass(`statgen-pb__ipt-budget--error`, this._state.pb_points < 0);
		};
		this._addHookAll("state", hkPoints);
		hkPoints();

		const $btnReset = $(`<button class="btn btn-default">Reset</button>`)
			.click(() => this._doReset());

		const $btnRandom = $(`<button class="btn btn-default">Random</button>`)
			.click(() => {
				this._doReset();

				let canIncrease = Parser.ABIL_ABVS.map(it => `pb_${it}`);
				const cpyBaseState = canIncrease.mergeMap(it => ({[it]: this._state[it]}));
				const cntRemaining = this._pb_getPointsRemaining(cpyBaseState);
				if (cntRemaining <= 0) return;

				for (let step = 0; step < 10000; ++step) {
					if (!canIncrease.length) break;

					const prop = RollerUtil.rollOnArray(canIncrease);
					if (!this._state.pb_rules.some(rule => rule.entity.score === cpyBaseState[prop] + 1)) {
						canIncrease = canIncrease.filter(it => it !== prop);
						continue;
					}

					const draftCpyBaseState = MiscUtil.copy(cpyBaseState);
					draftCpyBaseState[prop]++;

					const cntRemaining = this._pb_getPointsRemaining(draftCpyBaseState);

					if (cntRemaining > 0) {
						Object.assign(cpyBaseState, draftCpyBaseState);
					} else if (cntRemaining === 0) {
						this._proxyAssignSimple("state", draftCpyBaseState);
						break;
					} else {
						canIncrease = canIncrease.filter(it => it !== prop);
					}
				}
			});

		return $$`<div class="ve-flex mobile__ve-flex-col mb-2">
			<div class="ve-flex-v-center">
				<div class="statgen-pb__cell mr-4 mobile__hidden"></div>

				<label class="ve-flex-col mr-2">
					<div class="mb-1 text-center">Budget</div>
					${$iptBudget}
				</label>

				<label class="ve-flex-col mr-2">
					<div class="mb-1 text-center">Remain</div>
					${$iptRemaining}
				</label>
			</div>

			<div class="ve-flex-v-center mobile__mt-2">
				<div class="ve-flex-col mr-2">
					<div class="mb-1 text-center mobile__hidden">&nbsp;</div>
					${$btnReset}
				</div>

				<div class="ve-flex-col">
					<div class="mb-1 text-center mobile__hidden">&nbsp;</div>
					${$btnRandom}
				</div>
			</div>
		</div>`;
	}

	_render_$getStgPbCustom () {
		const $btnAddLower = $(`<button class="btn btn-default btn-xs">Add Lower Score</button>`)
			.click(() => {
				const prevLowest = this._state.pb_rules[0];
				const score = prevLowest.entity.score - 1;
				const cost = prevLowest.entity.cost;
				this._state.pb_rules = [this._getDefaultState_pb_rule(score, cost), ...this._state.pb_rules];
			});

		const $btnAddHigher = $(`<button class="btn btn-default btn-xs">Add Higher Score</button>`)
			.click(() => {
				const prevHighest = this._state.pb_rules.last();
				const score = prevHighest.entity.score + 1;
				const cost = prevHighest.entity.cost;
				this._state.pb_rules = [...this._state.pb_rules, this._getDefaultState_pb_rule(score, cost)];
			});

		const $btnResetRules = $(`<button class="btn btn-danger btn-xs mr-2">Reset</button>`)
			.click(() => {
				this._state.pb_rules = this._getDefaultStatePointBuyCosts().pb_rules;
			});

		const menuCustom = ContextUtil.getMenu([
			new ContextUtil.Action(
				"Export as Code",
				async () => {
					await MiscUtil.pCopyTextToClipboard(this._serialize_pb_rules());
					JqueryUtil.showCopiedEffect($btnContext);
				},
			),
			new ContextUtil.Action(
				"Import from Code",
				async () => {
					const raw = await InputUiUtil.pGetUserString({title: "Enter Code", isCode: true});
					if (raw == null) return;
					const parsed = this._deserialize_pb_rules(raw);
					if (parsed == null) return;

					const {pb_rules, pb_budget} = parsed;
					this._proxyAssignSimple(
						"state",
						{
							pb_rules,
							pb_budget,
							pb_isCustom: true,
						},
					);
					JqueryUtil.doToast("Imported!");
				},
			),
		]);

		const $btnContext = $(`<button class="btn btn-default btn-xs" title="Menu"><span class="glyphicon glyphicon-option-vertical"></span></button>`)
			.click(evt => ContextUtil.pOpenMenu(evt, menuCustom));

		const $stgCustomCostControls = $$`<div class="ve-flex-col mb-auto ml-2 mobile__ml-0 mobile__mt-3">
			<div class="btn-group-vertical ve-flex-col mb-2">${$btnAddLower}${$btnAddHigher}</div>
			<div class="ve-flex-v-center">
				${$btnResetRules}
				${$btnContext}
			</div>
		</div>`;

		const $stgCostRows = $$`<div class="ve-flex-col"></div>`;

		const renderableCollectionRules = new StatGenUi.RenderableCollectionPbRules(
			this,
			$stgCostRows,
		);
		const hkRules = () => {
			renderableCollectionRules.render();

						const {min: minScore, max: maxScore} = this._pb_getMinMaxScores();
			Parser.ABIL_ABVS.forEach(it => {
				const prop = `pb_${it}`;
				this._state[prop] = Math.min(maxScore, Math.max(minScore, this._state[prop]));
			});
					};
		this._addHookBase("pb_rules", hkRules);
		hkRules();

		let lastIsCustom = this._state.pb_isCustom;
		const hkIsCustomReset = () => {
			$stgCustomCostControls.toggleVe(this._state.pb_isCustom);

			if (lastIsCustom === this._state.pb_isCustom) return;
			lastIsCustom = this._state.pb_isCustom;

						if (!this._state.pb_isCustom) this._state.pb_rules = this._getDefaultStatePointBuyCosts().pb_rules;
		};
		this._addHookBase("pb_isCustom", hkIsCustomReset);
		hkIsCustomReset();

		return $$`<div class="ve-flex-col">
			<h4>Ability Score Point Cost</h4>

			<div class="ve-flex-col">
				<div class="ve-flex mobile__ve-flex-col">
					<div class="ve-flex-col mr-3mobile__mr-0">
						<div class="ve-flex-v-center mb-1">
							<div class="statgen-pb__col-cost ve-flex-vh-center bold">Score</div>
							<div class="statgen-pb__col-cost ve-flex-vh-center bold">Modifier</div>
							<div class="statgen-pb__col-cost ve-flex-vh-center bold">Point Cost</div>
							<div class="statgen-pb__col-cost-delete"></div>
						</div>

						${$stgCostRows}
					</div>

					${$stgCustomCostControls}
				</div>
			</div>

			<hr class="hr-4 mb-2">

			<label class="ve-flex-v-center">
				<div class="mr-2">Custom Rules</div>
				${ComponentUiUtil.$getCbBool(this, "pb_isCustom")}
			</label>
		</div>`;
	}

	_serialize_pb_rules () {
		const out = [
			this._state.pb_budget,
			...MiscUtil.copyFast(this._state.pb_rules).map(it => [it.entity.score, it.entity.cost]),
		];
		return JSON.stringify(out);
	}

	static _DESERIALIZE_MSG_INVALID = "Code was not valid!";

	_deserialize_pb_rules (raw) {
		let json;
		try {
			json = JSON.parse(raw);
		} catch (e) {
			JqueryUtil.doToast({type: "danger", content: `Failed to decode JSON! ${e.message}`});
			return null;
		}

		if (!(json instanceof Array)) return void JqueryUtil.doToast({type: "danger", content: this.constructor._DESERIALIZE_MSG_INVALID});

		const [budget, ...rules] = json;

		if (isNaN(budget)) return void JqueryUtil.doToast({type: "danger", content: this.constructor._DESERIALIZE_MSG_INVALID});

		if (
			!rules
				.every(it => it instanceof Array && it[0] != null && !isNaN(it[0]) && it[1] != null && !isNaN(it[1]))
		) return void JqueryUtil.doToast({type: "danger", content: this.constructor._DESERIALIZE_MSG_INVALID});

		return {
			pb_budget: budget,
			pb_rules: rules.map(it => this._getDefaultState_pb_rule(it[0], it[1])),
		};
	}

	_render_all ($wrpTab) {
		if (this._isLevelUp) return this._render_isLevelUp($wrpTab);
		this._render_isLevelOne($wrpTab);
	}

	_render_isLevelOne ($wrpTab) {
		let $stgNone;
		let $stgMain;
		const $elesRolled = [];
		const $elesArray = [];
		const $elesPb = [];
		const $elesManual = [];

				const $stgRolledHeader = this._render_$getStgRolledHeader();
		const hkStgRolled = () => $stgRolledHeader.toggleVe(this.ixActiveTab === this._IX_TAB_ROLLED);
		this._addHookActiveTab(hkStgRolled);
		hkStgRolled();
		
				const $stgPbHeader = this._render_$getStgPbHeader();
		const $stgPbCustom = this._render_$getStgPbCustom();
		const $vrPbCustom = $(`<div class="vr-5 mobile-ish__hidden"></div>`);
		const $hrPbCustom = $(`<hr class="hr-5 mobile-ish__visible">`);
		const hkStgPb = () => {
			$stgPbHeader.toggleVe(this.ixActiveTab === this._IX_TAB_PB);
			$stgPbCustom.toggleVe(this.ixActiveTab === this._IX_TAB_PB);
			$vrPbCustom.toggleVe(this.ixActiveTab === this._IX_TAB_PB);
			$hrPbCustom.toggleVe(this.ixActiveTab === this._IX_TAB_PB);
		};
		this._addHookActiveTab(hkStgPb);
		hkStgPb();
		
				const $stgArrayHeader = this._render_$getStgArrayHeader();
		const hkStgArray = () => $stgArrayHeader.toggleVe(this.ixActiveTab === this._IX_TAB_ARRAY);
		this._addHookActiveTab(hkStgArray);
		hkStgArray();
		
				const $stgManualHeader = this._render_$getStgManualHeader();
		const hkStgManual = () => $stgManualHeader.toggleVe(this.ixActiveTab === this._IX_TAB_MANUAL);
		this._addHookActiveTab(hkStgManual);
		hkStgManual();
		
				const hkElesMode = () => {
			$stgNone.toggleVe(this.ixActiveTab === this._IX_TAB_NONE);
			$stgMain.toggleVe(this.ixActiveTab !== this._IX_TAB_NONE);

			$elesRolled.forEach($ele => $ele.toggleVe(this.ixActiveTab === this._IX_TAB_ROLLED));
			$elesArray.forEach($ele => $ele.toggleVe(this.ixActiveTab === this._IX_TAB_ARRAY));
			$elesPb.forEach($ele => $ele.toggleVe(this.ixActiveTab === this._IX_TAB_PB));
			$elesManual.forEach($ele => $ele.toggleVe(this.ixActiveTab === this._IX_TAB_MANUAL));
		};
		this._addHookActiveTab(hkElesMode);
		
		const $btnResetRolledOrArrayOrManual = $(`<button class="btn btn-default btn-xxs relative statgen-shared__btn-reset" title="Reset"><span class="glyphicon glyphicon-refresh"></span></button>`)
			.click(() => this._doReset());
		const hkRolledOrArray = () => $btnResetRolledOrArrayOrManual.toggleVe(this.ixActiveTab === this._IX_TAB_ROLLED || this.ixActiveTab === this._IX_TAB_ARRAY || this.ixActiveTab === this._IX_TAB_MANUAL);
		this._addHookActiveTab(hkRolledOrArray);
		hkRolledOrArray();

		const $wrpsBase = Parser.ABIL_ABVS.map(ab => {
						const {propAbilSelectedRollIx} = this.constructor._rolled_getProps(ab);

			const $selRolled = $(`<select class="form-control input-xs form-control--minimal statgen-shared__ipt statgen-shared__ipt--sel"></select>`)
				.change(() => {
					const ix = Number($selRolled.val());

					const nxtState = {
						...Parser.ABIL_ABVS
							.map(ab => this.constructor._rolled_getProps(ab).propAbilSelectedRollIx)
							.filter(prop => ix != null && this._state[prop] === ix)
							.mergeMap(prop => ({[prop]: null})),
						[propAbilSelectedRollIx]: ~ix ? ix : null,
					};
					this._proxyAssignSimple("state", nxtState);
				});
			$(`<option/>`, {value: -1, text: "\u2014"}).appendTo($selRolled);

			let $optionsRolled = [];
			const hkRolls = () => {
				$optionsRolled.forEach($opt => $opt.remove());

				this._state.rolled_rolls.forEach((it, i) => {
					const cntPrevRolls = this._state.rolled_rolls.slice(0, i).filter(r => r.total === it.total).length;
					const $opt = $(`<option/>`, {value: i, text: `${it.total}${cntPrevRolls ? Parser.numberToSubscript(cntPrevRolls) : ""}`}).appendTo($selRolled);
					$optionsRolled.push($opt);
				});

				let nxtSelIx = this._state[propAbilSelectedRollIx];
				if (nxtSelIx >= this._state.rolled_rolls.length) nxtSelIx = null;
				$selRolled.val(`${nxtSelIx == null ? -1 : nxtSelIx}`);
				if ((nxtSelIx) !== this._state[propAbilSelectedRollIx]) this._state[propAbilSelectedRollIx] = nxtSelIx;
			};
			this._addHookBase("rolled_rolls", hkRolls);
			hkRolls();

			const hookIxRolled = () => {
				const ix = this._state[propAbilSelectedRollIx] == null ? -1 : this._state[propAbilSelectedRollIx];
				$selRolled.val(`${ix}`);
			};
			this._addHookBase(propAbilSelectedRollIx, hookIxRolled);
			hookIxRolled();

			$elesRolled.push($selRolled);
			
						const {propAbilSelectedScoreIx} = this.constructor._array_getProps(ab);

			const $selArray = $(`<select class="form-control input-xs form-control--minimal statgen-shared__ipt statgen-shared__ipt--sel"></select>`)
				.change(() => {
					const ix = Number($selArray.val());

					const nxtState = {
						...Parser.ABIL_ABVS
							.map(ab => this.constructor._array_getProps(ab).propAbilSelectedScoreIx)
							.filter(prop => ix != null && this._state[prop] === ix)
							.mergeMap(prop => ({[prop]: null})),
						[propAbilSelectedScoreIx]: ~ix ? ix : null,
					};
					this._proxyAssignSimple("state", nxtState);
				});
			$(`<option/>`, {value: -1, text: "\u2014"}).appendTo($selArray);

			StatGenUi._STANDARD_ARRAY.forEach((it, i) => $(`<option/>`, {value: i, text: it}).appendTo($selArray));

			const hookIxArray = () => {
				const ix = this._state[propAbilSelectedScoreIx] == null ? -1 : this._state[propAbilSelectedScoreIx];
				$selArray.val(`${ix}`);
			};
			this._addHookBase(propAbilSelectedScoreIx, hookIxArray);
			hookIxArray();

			$elesArray.push($selArray);
			
						const propPb = `pb_${ab}`;
			const $iptPb = ComponentUiUtil.$getIptInt(
				this,
				propPb,
				0,
				{
					fallbackOnNaN: 0,
					min: 0,
					html: `<input class="form-control form-control--minimal statgen-shared__ipt text-right" type="number">`,
				},
			);

			const hkPb = () => {
				const {min: minScore, max: maxScore} = this._pb_getMinMaxScores();
				this._state[propPb] = Math.min(maxScore, Math.max(minScore, this._state[propPb]));
			};
			this._addHookBase(propPb, hkPb);
			hkPb();

			$elesPb.push($iptPb);
			
						const {propAbilValue} = this.constructor._manual_getProps(ab);
			const $iptManual = ComponentUiUtil.$getIptInt(
				this,
				propAbilValue,
				0,
				{
					fallbackOnNaN: 0,
					html: `<input class="form-control form-control--minimal statgen-shared__ipt text-right" type="number">`,
				},
			);

			$elesManual.push($iptManual);
			
			return $$`<label class="my-1 statgen-pb__cell">
				${$selRolled}
				${$selArray}
				${$iptPb}
				${$iptManual}
			</label>`;
		});

		const $wrpsUser = this._render_$getWrpsUser();

		const metasTotalAndMod = this._render_getMetasTotalAndMod();

		const {
			$wrpOuter: $wrpRaceOuter,
			$stgSel: $stgRaceSel,
			$dispPreview: $dispPreviewRace,
			$hrPreview: $hrPreviewRaceTashas,
			$dispTashas,
		} = this._renderLevelOneRace.render();

		const {
			$wrpOuter: $wrpBackgroundOuter,
			$stgSel: $stgBackgroundSel,
			$dispPreview: $dispPreviewBackground,
			$hrPreview: $hrPreviewBackground,
		} = this._renderLevelOneBackground.render();

		const $wrpAsi = this._render_$getWrpAsi();

		$stgNone = $$`<div class="ve-flex-col w-100 h-100">
			<div class="ve-flex-v-center"><i>Please select a mode.</i></div>
		</div>`;

		$stgMain = $$`<div class="ve-flex-col w-100 h-100">
			${$stgRolledHeader}
			${$stgArrayHeader}
			${$stgManualHeader}

			<div class="ve-flex mobile-ish__ve-flex-col w-100 px-3">
				<div class="ve-flex-col">
					${$stgPbHeader}

					<div class="ve-flex">
						<div class="ve-flex-col mr-3">
							<div class="my-1 statgen-pb__header"></div>
							<div class="my-1 statgen-pb__header ve-flex-h-right">${$btnResetRolledOrArrayOrManual}</div>

							${Parser.ABIL_ABVS.map(it => `<div class="my-1 bold statgen-pb__cell ve-flex-v-center ve-flex-h-right" title="${Parser.attAbvToFull(it)}">${it.toUpperCase()}</div>`)}
						</div>

						<div class="ve-flex-col mr-3">
							<div class="my-1 statgen-pb__header"></div>
							<div class="my-1 bold statgen-pb__header ve-flex-vh-center">Base</div>
							${$wrpsBase}
						</div>

						${$wrpRaceOuter}

						${$wrpBackgroundOuter}

						<div class="ve-flex-col mr-3">
							<div class="my-1 statgen-pb__header"></div>
							<div class="my-1 statgen-pb__header ve-flex-vh-center help text-muted" title="Input any additional/custom bonuses here">User</div>
							${$wrpsUser}
						</div>

						<div class="ve-flex-col mr-3">
							<div class="my-1 statgen-pb__header"></div>
							<div class="my-1 statgen-pb__header ve-flex-vh-center">Total</div>
							${metasTotalAndMod.map(it => it.$wrpIptTotal)}
						</div>

						<div class="ve-flex-col mr-3">
							<div class="my-1 statgen-pb__header"></div>
							<div class="my-1 statgen-pb__header ve-flex-vh-center" title="Modifier">Mod.</div>
							${metasTotalAndMod.map(it => it.$wrpIptMod)}
						</div>
					</div>

					${$stgRaceSel}
					${$stgBackgroundSel}
				</div>

				${$vrPbCustom}
				${$hrPbCustom}

				${$stgPbCustom}
			</div>

			<hr class="hr-3">

			${$dispPreviewRace}
			${$hrPreviewRaceTashas}
			${$dispTashas}

			${$dispPreviewBackground}
			${$hrPreviewBackground}

			${$wrpAsi}
		</div>`;

		hkElesMode();

		$wrpTab
			.append($stgMain)
			.append($stgNone);
	}

	static _RenderLevelOneEntity = class {
		_title;
		_titleShort;
		_propIxEntity;
		_propIxAbilityScoreSet;
		_propData;
		_propModalFilter;
		_propIsPreview;
		_propEntity;
		_page;
		_propChoiceMetasFrom;
		_propChoiceWeighted;

		constructor ({parent}) {
			this._parent = parent;

			this._pbHookMetas = [];
		}

		render () {
			const $wrp = $(`<div class="ve-flex"></div>`);
			const $wrpOuter = $$`<div class="ve-flex-col">
				<div class="my-1 statgen-pb__header statgen-pb__header--group mr-3 text-center italic ve-small help-subtle" title="Ability Score Changes from ${this._title}">${this._titleShort}</div>

				${$wrp}
			</div>`;

						this._parent._addHookBase(this._propIxEntity, () => this._parent.__state[this._propIxAbilityScoreSet] = 0);

			const hkIxEntity = (prop) => {
				this._pb_unhookRender();
				const isInitialLoad = prop == null;
				if (!isInitialLoad) this._parent._state[this._propChoiceMetasFrom] = [];
				if (!isInitialLoad) this._parent._state[this._propChoiceWeighted] = [];
				const isAnyFromEntity = this._render_pointBuy($wrp);
				$wrpOuter.toggleVe(isAnyFromEntity);
			};
			this._parent._addHookBase(this._propIxEntity, hkIxEntity);
			this._bindAdditionalHooks_hkIxEntity(hkIxEntity);
			this._parent._addHookBase(this._propIxAbilityScoreSet, hkIxEntity);
			hkIxEntity();

			const {$wrp: $selEntity, fnUpdateHidden: fnUpdateSelEntityHidden} = ComponentUiUtil.$getSelSearchable(
				this._parent,
				this._propIxEntity,
				{
					values: this._parent[this._propData].map((_, i) => i),
					isAllowNull: true,
					fnDisplay: ix => {
						const r = this._parent[this._propData][ix];
						if (!r) return "(Unknown)";
						return `${r.name} ${r.source !== Parser.SRC_PHB ? `[${Parser.sourceJsonToAbv(r.source)}]` : ""}`;
					},
					asMeta: true,
				},
			);

			const doApplyFilterToSelEntity = () => {
				const f = this._parent[this._propModalFilter].pageFilter.filterBox.getValues();
				const isHiddenPerEntity = this._parent[this._propData].map(it => !this._parent[this._propModalFilter].pageFilter.toDisplay(f, it));
				fnUpdateSelEntityHidden(isHiddenPerEntity, false);
			};

			this._parent[this._propModalFilter].pageFilter.filterBox.on(FilterBox.EVNT_VALCHANGE, () => doApplyFilterToSelEntity());
			doApplyFilterToSelEntity();

			const $btnFilterForEntity = $(`<button class="btn btn-xs btn-default br-0 pr-2" title="Filter for ${this._title}"><span class="glyphicon glyphicon-filter"></span> Filter</button>`)
				.click(async () => {
					const selected = await this._parent[this._propModalFilter].pGetUserSelection();
					if (selected == null || !selected.length) return;

					const selectedEntity = selected[0];
					const ixEntity = this._parent[this._propData].findIndex(it => it.name === selectedEntity.name && it.source === selectedEntity.values.sourceJson);
					if (!~ixEntity) throw new Error(`Could not find selected ${this._title.toLowerCase()}: ${JSON.stringify(selectedEntity)}`); 					this._parent._state[this._propIxEntity] = ixEntity;
				});

			const $btnPreview = ComponentUiUtil.$getBtnBool(
				this._parent,
				this._propIsPreview,
				{
					html: `<button class="btn btn-xs btn-default" title="Toggle ${this._title} Preview"><span class="glyphicon glyphicon-eye-open"></span></button>`,
				},
			);
			const hkBtnPreviewEntity = () => $btnPreview.toggleVe(this._parent._state[this._propIxEntity] != null && ~this._parent._state[this._propIxEntity]);
			this._parent._addHookBase(this._propIxEntity, hkBtnPreviewEntity);
			hkBtnPreviewEntity();

						const {$sel: $selAbilitySet, setValues: setValuesSelAbilitySet} = ComponentUiUtil.$getSelEnum(
				this._parent,
				this._propIxAbilityScoreSet,
				{
					values: [],
					asMeta: true,
					fnDisplay: ixAbSet => {
						const lst = this._pb_getAbilityList();
						if (!lst?.[ixAbSet]) return "(Unknown)";
						return Renderer.getAbilityData([lst[ixAbSet]]).asText;
					},
				},
			);

			const $stgAbilityScoreSet = $$`<div class="ve-flex-v-center mb-2">
				<div class="mr-2">Ability Score Increase</div>
				<div>${$selAbilitySet}</div>
			</div>`;

			const hkSetValuesSelAbilitySet = () => {
				const entity = this._parent[this._propEntity];
				$stgAbilityScoreSet.toggleVe(!!entity && entity.ability?.length > 1);
				setValuesSelAbilitySet(
					[...new Array(entity?.ability?.length || 0)].map((_, ix) => ix),
					{isForce: true},
				);
			};
			this._parent._addHookBase(this._propIxEntity, hkSetValuesSelAbilitySet);
			this._bindAdditionalHooks_hkSetValuesSelAbilitySet(hkSetValuesSelAbilitySet);
			hkSetValuesSelAbilitySet();
			
			const $dispPreview = $(`<div class="ve-flex-col mb-2"></div>`);
			const hkPreviewEntity = () => {
				if (!this._parent._state[this._propIsPreview]) return $dispPreview.hideVe();

				const entity = this._parent._state[this._propIxEntity] != null ? this._parent[this._propData][this._parent._state[this._propIxEntity]] : null;
				if (!entity) return $dispPreview.hideVe();

				$dispPreview.empty().showVe().append(Renderer.hover.$getHoverContent_stats(this._page, entity));
			};
			this._parent._addHookBase(this._propIxEntity, hkPreviewEntity);
			this._parent._addHookBase(this._propIsPreview, hkPreviewEntity);
			hkPreviewEntity();

			const {$hrPreview} = this._getHrPreviewMeta();

			const $stgSel = $$`<div class="ve-flex-col mt-3">
				<div class="mb-1">Select a ${this._title}</div>
				<div class="ve-flex-v-center mb-2">
					<div class="ve-flex-v-center btn-group w-100 mr-2">${$btnFilterForEntity}${$selEntity}</div>
					<div>${$btnPreview}</div>
				</div>
				${$stgAbilityScoreSet}
			</div>`;

			return {
				$wrpOuter,

				$stgSel,

				$dispPreview,
				$hrPreview,
			};
		}

		_pb_unhookRender () {
			this._pbHookMetas.forEach(it => it.unhook());
			this._pbHookMetas = [];
		}

		_render_pointBuy ($wrp) {
			$wrp.empty();

			const fromEntity = this._pb_getAbility();
			if (fromEntity == null) return false;

			let $ptBase = null;
			if (Parser.ABIL_ABVS.some(it => fromEntity[it])) {
				const $wrpsEntity = Parser.ABIL_ABVS.map(ab => {
					return $$`<div class="my-1 statgen-pb__cell">
						<input class="form-control form-control--minimal statgen-shared__ipt text-right" type="number" readonly value="${fromEntity[ab] || 0}">
					</div>`;
				});

				$ptBase = $$`<div class="ve-flex-col mr-3">
					<div class="my-1 statgen-pb__header ve-flex-vh-center">Static</div>
					${$wrpsEntity}
				</div>`;
			}

			let $ptChooseFrom = null;
			if (fromEntity.choose && fromEntity.choose.from) {
				const amount = fromEntity.choose.amount || 1;
				const count = fromEntity.choose.count || 1;

				const $wrpsChoose = Parser.ABIL_ABVS.map(ab => {
					if (!fromEntity.choose.from.includes(ab)) return `<div class="my-1 statgen-pb__cell"></div>`;

					const $cb = $(`<input type="checkbox">`)
						.change(() => {
							const existing = this._parent._state[this._propChoiceMetasFrom].find(it => it.ability === ab);
							if (existing) {
								this._parent._state[this._propChoiceMetasFrom] = this._parent._state[this._propChoiceMetasFrom].filter(it => it !== existing);
								return;
							}

														if (this._parent._state[this._propChoiceMetasFrom].length >= count) {
								while (this._parent._state[this._propChoiceMetasFrom].length >= count) this._parent._state[this._propChoiceMetasFrom].shift();
								this._parent._state[this._propChoiceMetasFrom] = [...this._parent._state[this._propChoiceMetasFrom]];
							}

							this._parent._state[this._propChoiceMetasFrom] = [
								...this._parent._state[this._propChoiceMetasFrom],
								{ability: ab, amount},
							];
						});

					const hk = () => $cb.prop("checked", this._parent._state[this._propChoiceMetasFrom].some(it => it.ability === ab));
					this._parent._addHookBase(this._propChoiceMetasFrom, hk);
					this._pbHookMetas.push({unhook: () => this._parent._removeHookBase(this._propChoiceMetasFrom, hk)});
					hk();

					return $$`<label class="my-1 statgen-pb__cell ve-flex-vh-center">${$cb}</label>`;
				});

				$ptChooseFrom = $$`<div class="ve-flex-col mr-3">
					<div class="my-1 statgen-pb__header statgen-pb__header--choose-from ve-flex-vh-center">
						<div class="${count !== 1 ? `mr-1` : ""}">${UiUtil.intToBonus(amount, {isPretty: true})}</div>${count !== 1 ? `<div class="ve-small ve-muted">(x${count})</div>` : ""}
					</div>
					${$wrpsChoose}
				</div>`;
			}

			let $ptsChooseWeighted = null;
			if (fromEntity.choose && fromEntity.choose.weighted && fromEntity.choose.weighted.weights) {
				$ptsChooseWeighted = fromEntity.choose.weighted.weights.map((weight, ixWeight) => {
					const $wrpsChoose = Parser.ABIL_ABVS.map(ab => {
						if (!fromEntity.choose.weighted.from.includes(ab)) return `<div class="my-1 statgen-pb__cell"></div>`;

						const $cb = $(`<input type="checkbox">`)
							.change(() => {
								const existing = this._parent._state[this._propChoiceWeighted].find(it => it.ability === ab && it.ix === ixWeight);
								if (existing) {
									this._parent._state[this._propChoiceWeighted] = this._parent._state[this._propChoiceWeighted].filter(it => it !== existing);
									return;
								}

																const withSameAbil = this._parent._state[this._propChoiceWeighted].filter(it => it.ability === ab || it.ix === ixWeight);
								if (withSameAbil.length) {
									this._parent._state[this._propChoiceWeighted] = this._parent._state[this._propChoiceWeighted].filter(it => it.ability !== ab && it.ix !== ixWeight);
								}

								this._parent._state[this._propChoiceWeighted] = [
									...this._parent._state[this._propChoiceWeighted],
									{ability: ab, amount: weight, ix: ixWeight},
								];
							});

						const hk = () => {
							$cb.prop("checked", this._parent._state[this._propChoiceWeighted].some(it => it.ability === ab && it.ix === ixWeight));
						};
						this._parent._addHookBase(this._propChoiceWeighted, hk);
						this._pbHookMetas.push({unhook: () => this._parent._removeHookBase(this._propChoiceWeighted, hk)});
						hk();

						return $$`<label class="my-1 statgen-pb__cell ve-flex-vh-center">${$cb}</label>`;
					});

					return $$`<div class="ve-flex-col mr-3">
						<div class="my-1 statgen-pb__header statgen-pb__header--choose-from ve-flex-vh-center">${UiUtil.intToBonus(weight, {isPretty: true})}</div>
						${$wrpsChoose}
					</div>`;
				});
			}

			$$($wrp)`
				${$ptBase}
				${$ptChooseFrom}
				${$ptsChooseWeighted}
			`;

			return $ptBase || $ptChooseFrom || $ptsChooseWeighted;
		}

				_pb_getAbilityList () { throw new Error("Unimplemented!"); }

				_pb_getAbility () { throw new Error("Unimplemented!"); }

		_bindAdditionalHooks_hkIxEntity (hkIxEntity) {  }
		_bindAdditionalHooks_hkSetValuesSelAbilitySet (hkSetValuesSelAbilitySet) {  }

		_getHrPreviewMeta () {
			const $hrPreview = $(`<hr class="hr-3">`);
			const hkPreview = this._getHkPreview({$hrPreview});
			this._parent._addHookBase(this._propIsPreview, hkPreview);
			hkPreview();

			return {
				$hrPreview,
				hkPreview,
			};
		}

		_getHkPreview ({$hrPreview}) {
			return () => $hrPreview.toggleVe(this._parent._state[this._propIsPreview]);
		}
	};

	static _RenderLevelOneRace = class extends this._RenderLevelOneEntity {
		_title = "Race";
		_titleShort = "Race";
		_propIxEntity = "common_ixRace";
		_propIxAbilityScoreSet = "common_ixAbilityScoreSetRace";
		_propData = "_races";
		_propModalFilter = "_modalFilterRaces";
		_propIsPreview = "common_isPreviewRace";
		_propEntity = "race";
		_page = UrlUtil.PG_RACES;
		_propChoiceMetasFrom = "common_raceChoiceMetasFrom";
		_propChoiceWeighted = "common_raceChoiceMetasWeighted";

		render () {
			const out = super.render();

			const {$btnToggleTashasPin, $dispTashas} = this._$getPtsTashas();

			out.$stgSel.append($$`<label class="ve-flex-v-center mb-1">
				<div class="mr-2">Allow Origin Customization</div>
				${ComponentUiUtil.$getCbBool(this._parent, "common_isTashas")}
			</label>`);

			out.$stgSel.append($$`<div class="ve-flex">
				<div class="ve-small ve-muted italic mr-1">${Renderer.get().render(`An {@variantrule Customizing Your Origin|TCE|optional rule}`)}</div>
				${$btnToggleTashasPin}
				<div class="ve-small ve-muted italic ml-1">${Renderer.get().render(`from Tasha's Cauldron of Everything, page 8.`)}</div>
			</div>`);

			out.$dispTashas = $dispTashas;

			return out;
		}

		_pb_getAbilityList () {
			return this._parent._pb_getRaceAbilityList();
		}

		_pb_getAbility () {
			return this._parent._pb_getRaceAbility();
		}

		_bindAdditionalHooks_hkIxEntity (hkIxEntity) {
			this._parent._addHookBase("common_isTashas", hkIxEntity);
		}

		_bindAdditionalHooks_hkSetValuesSelAbilitySet (hkSetValuesSelAbilitySet) {
			this._parent._addHookBase("common_isTashas", hkSetValuesSelAbilitySet);
		}

		_getHrPreviewMeta () {
			const out = super._getHrPreviewMeta();
			const {hkPreview} = out;
			this._parent._addHookBase("common_isShowTashasRules", hkPreview);
			return out;
		}

		_getHkPreview ({$hrPreview}) {
			return () => $hrPreview.toggleVe(this._parent._state[this._propIsPreview] && this._parent._state.common_isShowTashasRules);
		}

		_$getPtsTashas () {
			const $btnToggleTashasPin = ComponentUiUtil.$getBtnBool(
				this._parent,
				"common_isShowTashasRules",
				{
					html: `<button class="btn btn-xxs btn-default ve-small p-0 statgen-shared__btn-toggle-tashas-rules ve-flex-vh-center" title="Toggle &quot;Customizing Your Origin&quot; Section"><span class="glyphicon glyphicon-eye-open"></span></button>`,
				},
			);

			const $dispTashas = $(`<div class="ve-flex-col"><div class="italic ve-muted">Loading...</div></div>`);
			DataLoader.pCacheAndGet(UrlUtil.PG_VARIANTRULES, Parser.SRC_TCE, UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_VARIANTRULES]({name: "Customizing Your Origin", source: Parser.SRC_TCE}))
				.then(rule => {
					$$($dispTashas.empty())`${Renderer.hover.$getHoverContent_stats(UrlUtil.PG_VARIANTRULES, rule)}<hr class="hr-3">`;
				});
			const hkIsShowTashas = () => {
				$dispTashas.toggleVe(this._parent._state.common_isShowTashasRules);
			};
			this._parent._addHookBase("common_isShowTashasRules", hkIsShowTashas);
			hkIsShowTashas();

			return {
				$btnToggleTashasPin,
				$dispTashas,
			};
		}
	};

	_renderLevelOneRace = new this.constructor._RenderLevelOneRace({parent: this});

	static _RenderLevelOneBackground = class extends this._RenderLevelOneEntity {
		_title = "Background";
		_titleShort = "Backg.";
		_propIxEntity = "common_ixBackground";
		_propIxAbilityScoreSet = "common_ixAbilityScoreSetBackground";
		_propData = "_backgrounds";
		_propModalFilter = "_modalFilterBackgrounds";
		_propIsPreview = "common_isPreviewBackground";
		_propEntity = "background";
		_page = UrlUtil.PG_BACKGROUNDS;
		_propChoiceMetasFrom = "common_backgroundChoiceMetasFrom";
		_propChoiceWeighted = "common_backgroundChoiceMetasWeighted";

		_pb_getAbilityList () {
			return this._parent._pb_getBackgroundAbilityList();
		}

		_pb_getAbility () {
			return this._parent._pb_getBackgroundAbility();
		}
	};

	_renderLevelOneBackground = new this.constructor._RenderLevelOneBackground({parent: this});

	_render_isLevelUp ($wrpTab) {
		const $wrpsExisting = Parser.ABIL_ABVS.map(ab => {
			const $iptExisting = $(`<input class="form-control form-control--minimal statgen-shared__ipt text-right" type="number" readonly>`)
				.val(this._existingScores[ab]);

			return $$`<label class="my-1 statgen-pb__cell">
				${$iptExisting}
			</label>`;
		});

		const $wrpsUser = this._render_$getWrpsUser();

		const metasTotalAndMod = this._render_getMetasTotalAndMod();

		const $wrpAsi = this._render_$getWrpAsi();

		$$($wrpTab)`
			<div class="ve-flex mobile-ish__ve-flex-col w-100 px-3">
				<div class="ve-flex-col">
					<div class="ve-flex">
						<div class="ve-flex-col mr-3">
							<div class="my-1 statgen-pb__header"></div>

							${Parser.ABIL_ABVS.map(it => `<div class="my-1 bold statgen-pb__cell ve-flex-v-center ve-flex-h-right" title="${Parser.attAbvToFull(it)}">${it.toUpperCase()}</div>`)}
						</div>

						<div class="ve-flex-col mr-3">
							<div class="my-1 bold statgen-pb__header ve-flex-vh-center" title="Current">Curr.</div>
							${$wrpsExisting}
						</div>

						<div class="ve-flex-col mr-3">
							<div class="my-1 statgen-pb__header ve-flex-vh-center help text-muted" title="Input any additional/custom bonuses here">User</div>
							${$wrpsUser}
						</div>

						<div class="ve-flex-col mr-3">
							<div class="my-1 statgen-pb__header ve-flex-vh-center">Total</div>
							${metasTotalAndMod.map(it => it.$wrpIptTotal)}
						</div>

						<div class="ve-flex-col mr-3">
							<div class="my-1 statgen-pb__header ve-flex-vh-center" title="Modifier">Mod.</div>
							${metasTotalAndMod.map(it => it.$wrpIptMod)}
						</div>
					</div>
				</div>
			</div>

			<hr class="hr-3">

			${$wrpAsi}
		`;
	}

	_render_$getWrpsUser () {
		return Parser.ABIL_ABVS.map(ab => {
			const {propUserBonus} = this.constructor._common_getProps(ab);
			const $ipt = ComponentUiUtil.$getIptInt(
				this,
				propUserBonus,
				0,
				{
					fallbackOnNaN: 0,
					html: `<input class="form-control form-control--minimal statgen-shared__ipt text-right" type="number">`,
				},
			);
			return $$`<label class="my-1 statgen-pb__cell">${$ipt}</label>`;
		});
	}

	_render_getMetasTotalAndMod () {
		return Parser.ABIL_ABVS.map(ab => {
			const $iptTotal = $(`<input class="form-control form-control--minimal statgen-shared__ipt text-center" type="text" readonly>`);
			const $iptMod = $(`<input class="form-control form-control--minimal statgen-shared__ipt text-center" type="text" readonly>`);

			const $wrpIptTotal = $$`<label class="my-1 statgen-pb__cell">${$iptTotal}</label>`;
			const $wrpIptMod = $$`<label class="my-1 statgen-pb__cell">${$iptMod}</label>`;

			const exportedStateProp = `common_export_${ab}`;

			const getTotalScore = () => {
				if (this._isLevelUp) return this._levelUp_getTotalScore(ab);
				switch (this.ixActiveTab) {
					case this._IX_TAB_ROLLED: return this._rolled_getTotalScore(ab);
					case this._IX_TAB_ARRAY: return this._array_getTotalScore(ab);
					case this._IX_TAB_PB: return this._pb_getTotalScore(ab);
					case this._IX_TAB_MANUAL: return this._manual_getTotalScore(ab);
					default: return 0;
				}
			};

			const hk = () => {
				const totalScore = getTotalScore();

				const isOverLimit = totalScore > 20;
				$iptTotal
					.val(totalScore)
					.toggleClass("form-control--error", isOverLimit)
					.title(isOverLimit ? `In general, you can't increase an ability score above 20.` : "");
				$iptMod.val(Parser.getAbilityModifier(totalScore));

				this._state[exportedStateProp] = totalScore;
			};
			this._addHookAll("state", hk);
			this._addHookActiveTab(hk);
			hk();

			return {
				$wrpIptTotal,
				$wrpIptMod,
			};
		});
	}

	_render_$getWrpAsi () {
		const $wrpAsi = $(`<div class="ve-flex-col w-100"></div>`);
		this._compAsi.render($wrpAsi);
		return $wrpAsi;
	}

	static _common_getProps (ab) {
		return {
			propUserBonus: `${StatGenUi._PROP_PREFIX_COMMON}${ab}_user`,
		};
	}

	static _rolled_getProps (ab) {
		return {
			propAbilSelectedRollIx: `${StatGenUi._PROP_PREFIX_ROLLED}${ab}_abilSelectedRollIx`,
		};
	}

	static _array_getProps (ab) {
		return {
			propAbilSelectedScoreIx: `${StatGenUi._PROP_PREFIX_ARRAY}${ab}_abilSelectedScoreIx`,
		};
	}

	static _manual_getProps (ab) {
		return {
			propAbilValue: `${StatGenUi._PROP_PREFIX_MANUAL}${ab}_abilValue`,
		};
	}

	_pb_getRaceAbilityList () {
		const race = this.race;
		if (!race?.ability?.length) return null;

		return race.ability
			.map(fromRace => {
				if (this._state.common_isTashas) {
					const weights = [];

					if (fromRace.choose && fromRace.choose.weighted && fromRace.choose.weighted.weights) {
						weights.push(...fromRace.choose.weighted.weights);
					}

					Parser.ABIL_ABVS.forEach(it => {
						if (fromRace[it]) weights.push(fromRace[it]);
					});

					if (fromRace.choose && fromRace.choose.from) {
						const count = fromRace.choose.count || 1;
						const amount = fromRace.choose.amount || 1;
						for (let i = 0; i < count; ++i) weights.push(amount);
					}

					weights.sort((a, b) => SortUtil.ascSort(b, a));

					fromRace = {
						choose: {
							weighted: {
								from: [...Parser.ABIL_ABVS],
								weights,
							},
						},
					};
				}

				return fromRace;
			});
	}

	_pb_getBackgroundAbilityList () {
		const background = this.background;
		if (!background?.ability?.length) return null;
		return background.ability;
	}

	_pb_getRaceAbility () {
		return this._pb_getRaceAbilityList()?.[this._state.common_ixAbilityScoreSetRace || 0];
	}

	_pb_getBackgroundAbility () {
		return this._pb_getBackgroundAbilityList()?.[this._state.common_ixAbilityScoreSetBackground || 0];
	}

	_pb_getPointsRemaining (baseState) {
		const spent = Parser.ABIL_ABVS.map(it => {
			const prop = `pb_${it}`;
			const score = baseState[prop];
			const rule = this._state.pb_rules.find(it => it.entity.score === score);
			if (!rule) return 0;
			return rule.entity.cost;
		}).reduce((a, b) => a + b, 0);

		return this._state.pb_budget - spent;
	}

	_rolled_getTotalScore (ab) {
		const {propAbilSelectedRollIx} = this.constructor._rolled_getProps(ab);
		const {propUserBonus} = this.constructor._common_getProps(ab);
		return (this._state.rolled_rolls[this._state[propAbilSelectedRollIx]] || {total: 0}).total + this._state[propUserBonus] + this._getTotalScore_getBonuses(ab);
	}

	_array_getTotalScore (ab) {
		const {propAbilSelectedScoreIx} = this.constructor._array_getProps(ab);
		const {propUserBonus} = this.constructor._common_getProps(ab);
		return (StatGenUi._STANDARD_ARRAY[this._state[propAbilSelectedScoreIx]] || 0) + this._state[propUserBonus] + this._getTotalScore_getBonuses(ab);
	}

	_pb_getTotalScore (ab) {
		const prop = `pb_${ab}`;
		const {propUserBonus} = this.constructor._common_getProps(ab);
		return this._state[prop] + this._state[propUserBonus] + this._getTotalScore_getBonuses(ab);
	}

	_manual_getTotalScore (ab) {
		const {propAbilValue} = this.constructor._manual_getProps(ab);
		const {propUserBonus} = this.constructor._common_getProps(ab);
		return (this._state[propAbilValue] || 0) + this._state[propUserBonus] + this._getTotalScore_getBonuses(ab);
	}

	_levelUp_getTotalScore (ab) {
		const {propUserBonus} = this.constructor._common_getProps(ab);
		return (this._existingScores[ab] || 0) + this._state[propUserBonus] + this._getTotalScore_getBonuses(ab);
	}

	_getTotalScore_getBonuses (ab) {
		let total = 0;

		if (!this._isLevelUp) {
			const handleEntityAbility = ({fromEntity, propChoiceMetasFrom, propChoiceWeighted}) => {
				if (fromEntity) {
					if (fromEntity[ab]) total += fromEntity[ab];

					if (fromEntity.choose && fromEntity.choose.from) {
						total += this._state[propChoiceMetasFrom]
							.filter(it => it.ability === ab)
							.map(it => it.amount)
							.reduce((a, b) => a + b, 0);
					}

					if (fromEntity.choose && fromEntity.choose.weighted && fromEntity.choose.weighted.weights) {
						total += this._state[propChoiceWeighted]
							.filter(it => it.ability === ab)
							.map(it => it.amount)
							.reduce((a, b) => a + b, 0);
					}
				}
			};

			handleEntityAbility({
				fromEntity: this._pb_getRaceAbility(),
				propChoiceMetasFrom: "common_raceChoiceMetasFrom",
				propChoiceWeighted: "common_raceChoiceMetasWeighted",
			});

			handleEntityAbility({
				fromEntity: this._pb_getBackgroundAbility(),
				propChoiceMetasFrom: "common_backgroundChoiceMetasFrom",
				propChoiceWeighted: "common_backgroundChoiceMetasWeighted",
			});
		}

		const formDataAsi = this._compAsi.getFormData();
		if (formDataAsi) total += formDataAsi.data[ab] || 0;

		return total;
	}

	getSaveableState () {
		const out = super.getSaveableState();

		const handleEntity = ({propIxEntity, page, propData, propHash}) => {
			if (out[propIxEntity] != null && !~this._state[propIxEntity]) {
				out[propHash] = UrlUtil.URL_TO_HASH_BUILDER[page](this[propData][out[propIxEntity]]);
				delete out[propIxEntity];
			}
		};

		handleEntity({
			propIxEntity: "common_ixRace",
			page: UrlUtil.PG_RACES,
			propData: "_races",
			propHash: "_pb_raceHash",
		});

		handleEntity({
			propIxEntity: "common_ixBackground",
			page: UrlUtil.PG_BACKGROUNDS,
			propData: "_backgrounds",
			propHash: "_pb_backgroundHash",
		});

		return out;
	}

		getSaveableStatePointBuyCustom () {
		const base = this.getSaveableState();
		return {
			state: this.constructor._PROPS_POINT_BUY_CUSTOM.mergeMap(k => ({[k]: base.state[k]})),
		};
	}
	
	setStateFrom (saved, isOverwrite = false) {
		saved = MiscUtil.copy(saved);

		MiscUtil.getOrSet(saved, "state", {});

		const handleEntityHash = ({propHash, page, propData, propIxEntity}) => {
			if (!saved[propHash]) return;

			const ixEntity = this[propData].findIndex(it => {
				const hash = UrlUtil.URL_TO_HASH_BUILDER[page](it);
				return hash === saved[propHash];
			});
			if (~ixEntity) saved[propIxEntity] = ixEntity;
		};

		handleEntityHash({
			propHash: "_pb_raceHash",
			page: UrlUtil.PG_RACES,
			propData: "_races",
			propIxEntity: "common_ixRace",
		});

		handleEntityHash({
			propHash: "_pb_backgroundHash",
			page: UrlUtil.PG_BACKGROUNDS,
			propData: "_backgrounds",
			propIxEntity: "common_ixBackground",
		});

		const validKeys = new Set(Object.keys(this._getDefaultState()));
		const validKeyPrefixes = [
			StatGenUi._PROP_PREFIX_COMMON,
			StatGenUi._PROP_PREFIX_ROLLED,
			StatGenUi._PROP_PREFIX_ARRAY,
			StatGenUi._PROP_PREFIX_MANUAL,
		];

		Object.keys(saved.state).filter(k => !validKeys.has(k) && !validKeyPrefixes.some(it => k.startsWith(it))).forEach(k => delete saved.state[k]);

				for (let i = saved.state.common_cntAsi || 0; i < 1000; ++i) {
			const {propMode, prefix} = this.getPropsAsi(i, "ability");
			if (saved.state[propMode]) Object.keys(saved.state).filter(k => k.startsWith(prefix)).forEach(k => delete saved.state[k]);
		}

		for (let i = saved.state.common_cntFeatsCustom || 0; i < 1000; ++i) {
			const {propMode, prefix} = this.getPropsAsi(i, "custom");
			if (saved.state[propMode]) Object.keys(saved.state).filter(k => k.startsWith(prefix)).forEach(k => delete saved.state[k]);
		}
		
		super.setStateFrom(saved, isOverwrite);
	}

	_pb_getMinMaxScores () {
		return {
			min: Math.min(...this._state.pb_rules.map(it => it.entity.score)),
			max: Math.max(...this._state.pb_rules.map(it => it.entity.score)),
		};
	}

	_getDefaultStateCommonResettable () {
		return {
			...Parser.ABIL_ABVS.mergeMap(ab => ({[this.constructor._common_getProps(ab).propUserBonus]: 0})),

			common_raceChoiceMetasFrom: [],
			common_raceChoiceMetasWeighted: [],

			common_backgroundChoiceMetasFrom: [],
			common_backgroundChoiceMetasWeighted: [],
		};
	}

	_getDefaultStateNoneResettable () { return {}; }

	_getDefaultStateRolledResettable () {
		return {
			...Parser.ABIL_ABVS.mergeMap(ab => ({[this.constructor._rolled_getProps(ab).propAbilSelectedRollIx]: null})),
		};
	}

	_getDefaultStateArrayResettable () {
		return {
			...Parser.ABIL_ABVS.mergeMap(ab => ({[this.constructor._array_getProps(ab).propAbilSelectedScoreIx]: null})),
		};
	}

	_getDefaultStatePointBuyResettable () {
		return {
			pb_str: 8,
			pb_dex: 8,
			pb_con: 8,
			pb_int: 8,
			pb_wis: 8,
			pb_cha: 8,
		};
	}

	_getDefaultStatePointBuyCosts () {
		return {
			pb_rules: [
				{score: 8, cost: 0},
				{score: 9, cost: 1},
				{score: 10, cost: 2},
				{score: 11, cost: 3},
				{score: 12, cost: 4},
				{score: 13, cost: 5},
				{score: 14, cost: 7},
				{score: 15, cost: 9},
			].map(({score, cost}) => this._getDefaultState_pb_rule(score, cost)),
		};
	}

	_getDefaultState_pb_rule (score, cost) {
		return {
			id: CryptUtil.uid(),
			entity: {
				score,
				cost,
			},
		};
	}

	_getDefaultStateManualResettable () {
		return {
			...Parser.ABIL_ABVS.mergeMap(ab => ({[this.constructor._manual_getProps(ab).propAbilValue]: null})),
		};
	}

	_getDefaultState () {
		return {
						common_isPreviewRace: false,
			common_isTashas: false,
			common_isShowTashasRules: false,
			common_ixRace: null,
			common_ixAbilityScoreSet: 0,

			common_isPreviewBackground: false,
			common_ixBackground: null,
			common_ixAbilityScoreSetBackground: 0,

			common_pulseAsi: false, 			common_cntAsi: 0,
			common_cntFeatsCustom: 0,

						common_export_str: null,
			common_export_dex: null,
			common_export_con: null,
			common_export_int: null,
			common_export_wis: null,
			common_export_cha: null,
			
			...this._getDefaultStateCommonResettable(),
			
						rolled_formula: "4d6dl1",
			rolled_rollCount: 6,
			rolled_rolls: [],
			...this._getDefaultStateRolledResettable(),
			
						...this._getDefaultStateArrayResettable(),
			
						...this._getDefaultStatePointBuyResettable(),
			...this._getDefaultStatePointBuyCosts(),

			pb_points: 27,
			pb_budget: 27,

			pb_isCustom: false,
			
						...this._getDefaultStateManualResettable(),
					};
	}
}

StatGenUi._STANDARD_ARRAY = [15, 14, 13, 12, 10, 8];
StatGenUi._PROP_PREFIX_COMMON = "common_";
StatGenUi._PROP_PREFIX_ROLLED = "rolled_";
StatGenUi._PROP_PREFIX_ARRAY = "array_";
StatGenUi._PROP_PREFIX_MANUAL = "manual_";
StatGenUi.MODE_NONE = "none";
StatGenUi.MODES = [
	"rolled",
	"array",
	"pointbuy",
	"manual",
];
StatGenUi.MODES_FVTT = [
	StatGenUi.MODE_NONE,
	...StatGenUi.MODES,
];
StatGenUi._MAX_CUSTOM_FEATS = 20;

globalThis.StatGenUi = StatGenUi;

let UtilAdditionalFeats$1 = class UtilAdditionalFeats {
	static isNoChoice (available) {
		if (!available?.length) return true;
		if (available.length > 1) return false;
		return !available[0].any;
	}

	static getUidsStatic (availableSet) {
		return Object.entries(availableSet || {})
			.filter(([k, v]) => k !== "any" && v)
			.sort(([kA], [kB]) => SortUtil.ascSortLower(kA, kB))
			.map(([k]) => k);
	}

	static getSelIxSetMeta ({comp, prop, available}) {
		return ComponentUiUtil.$getSelEnum(
			comp,
			prop,
			{
				values: available.map((_, i) => i),
				fnDisplay: ix => {
					const featSet = available[ix];

					const out = [];

					if (featSet.any) {
						out.push(`Choose any${featSet.any > 1 ? ` ${Parser.numberToText(featSet.any)}` : ""}`);
					}

					this.getUidsStatic(featSet)
						.forEach(uid => {
							const {name} = DataUtil.proxy.unpackUid("feat", uid, "feat", {isLower: true});
							out.push(name.toTitleCase());
						});

					return out.filter(Boolean).join("; ");
				},
				asMeta: true,
			},
		);
	}
};

globalThis.UtilAdditionalFeats = UtilAdditionalFeats$1;

StatGenUi.CompAsi = class extends BaseComponent {
	constructor ({parent}) {
		super();
		this._parent = parent;

		this._metasAsi = {ability: [], race: [], background: [], custom: []};

		this._doPulseThrottled = MiscUtil.throttle(this._doPulse_.bind(this), 50);
	}

		_doPulse_ () { this._parent.state.common_pulseAsi = !this._parent.state.common_pulseAsi; }

	_render_renderAsiFeatSection (propCnt, namespace, $wrpRows) {
		const hk = () => {
			let ix = 0;

			for (; ix < this._parent.state[propCnt]; ++ix) {
				const ix_ = ix;
				const {propMode, propIxFeat, propIxAsiPointOne, propIxAsiPointTwo, propIxFeatAbility, propFeatAbilityChooseFrom} = this._parent.getPropsAsi(ix_, namespace);

				if (!this._metasAsi[namespace][ix_]) {
					this._parent.state[propMode] = this._parent.state[propMode] || (namespace === "ability" ? "asi" : "feat");

					const $btnAsi = namespace !== "ability" ? null : $(`<button class="btn btn-xs btn-default w-50p">ASI</button>`)
						.click(() => {
							this._parent.state[propMode] = "asi";
							this._doPulseThrottled();
						});

					const $btnFeat = namespace !== "ability" ? $(`<div class="w-100p text-center">Feat</div>`) : $(`<button class="btn btn-xs btn-default w-50p">Feat</button>`)
						.click(() => {
							this._parent.state[propMode] = "feat";
							this._doPulseThrottled();
						});

										let $stgAsi;
					if (namespace === "ability") {
						const $colsAsi = Parser.ABIL_ABVS.map((it, ixAsi) => {
							const updateDisplay = () => $ipt.val(Number(this._parent.state[propIxAsiPointOne] === ixAsi) + Number(this._parent.state[propIxAsiPointTwo] === ixAsi));

							const $ipt = $(`<input class="form-control form-control--minimal text-right input-xs statgen-shared__ipt" type="number" style="width: 42px;">`)
								.disableSpellcheck()
								.keydown(evt => { if (evt.key === "Escape") $ipt.blur(); })
								.change(() => {
									const raw = $ipt.val().trim();
									const asNum = Number(raw);

									const activeProps = [propIxAsiPointOne, propIxAsiPointTwo].filter(prop => this._parent.state[prop] === ixAsi);

									if (isNaN(asNum) || asNum <= 0) {
										this._parent.proxyAssignSimple(
											"state",
											{
												...activeProps.mergeMap(prop => ({[prop]: null})),
											},
										);
										updateDisplay();
										return this._doPulseThrottled();
									}

									if (asNum >= 2) {
										this._parent.proxyAssignSimple(
											"state",
											{
												[propIxAsiPointOne]: ixAsi,
												[propIxAsiPointTwo]: ixAsi,
											},
										);
										updateDisplay();
										return this._doPulseThrottled();
									}

									if (activeProps.length === 2) {
										this._parent.state[propIxAsiPointTwo] = null;
										updateDisplay();
										return this._doPulseThrottled();
									}

									if (this._parent.state[propIxAsiPointOne] == null) {
										this._parent.state[propIxAsiPointOne] = ixAsi;
										updateDisplay();
										return this._doPulseThrottled();
									}

									this._parent.state[propIxAsiPointTwo] = ixAsi;
									updateDisplay();
									this._doPulseThrottled();
								});

							const hkSelected = () => updateDisplay();
							this._parent.addHookBase(propIxAsiPointOne, hkSelected);
							this._parent.addHookBase(propIxAsiPointTwo, hkSelected);
							hkSelected();

							return $$`<div class="ve-flex-col h-100 mr-2">
							<div class="statgen-asi__cell text-center pb-1" title="${Parser.attAbvToFull(it)}">${it.toUpperCase()}</div>
							<div class="ve-flex-vh-center statgen-asi__cell relative">
								<div class="absolute no-events statgen-asi__disp-plus">+</div>
								${$ipt}
							</div>
						</div>`;
						});

						$stgAsi = $$`<div class="ve-flex-v-center">
							${$colsAsi}
						</div>`;
					}
					
										const {$stgFeat, $btnChooseFeat, hkIxFeat} = this._render_getMetaFeat({propIxFeat, propIxFeatAbility, propFeatAbilityChooseFrom});
					
					const hkMode = () => {
						if (namespace === "ability") {
							$btnAsi.toggleClass("active", this._parent.state[propMode] === "asi");
							$btnFeat.toggleClass("active", this._parent.state[propMode] === "feat");
						}

						$btnChooseFeat.toggleVe(this._parent.state[propMode] === "feat");

						if (namespace === "ability") $stgAsi.toggleVe(this._parent.state[propMode] === "asi");
						$stgFeat.toggleVe(this._parent.state[propMode] === "feat");

						hkIxFeat();
					};
					this._parent.addHookBase(propMode, hkMode);
					hkMode();

					const $row = $$`<div class="ve-flex-v-end py-3 px-1">
						<div class="btn-group">${$btnAsi}${$btnFeat}</div>
						<div class="vr-4"></div>
						${$stgAsi}
						${$stgFeat}
					</div>`.appendTo($wrpRows);

					this._metasAsi[namespace][ix_] = {
						$row,
					};
				}

				this._metasAsi[namespace][ix_].$row.showVe().addClass("statgen-asi__row");
			}

						if (this._metasAsi[namespace][ix - 1]) this._metasAsi[namespace][ix - 1].$row.removeClass("statgen-asi__row");

			for (; ix < this._metasAsi[namespace].length; ++ix) {
				if (!this._metasAsi[namespace][ix]) continue;
				this._metasAsi[namespace][ix].$row.hideVe().removeClass("statgen-asi__row");
			}
		};
		this._parent.addHookBase(propCnt, hk);
		hk();
	}

	_render_renderAdditionalFeatSection ({namespace, $wrpRows, propEntity}) {
		const fnsCleanupEnt = [];
		const fnsCleanupGroup = [];

		const {propIxSel, propPrefix} = this._parent.getPropsAdditionalFeats_(namespace);

		const resetGroupState = () => {
			const nxtState = Object.keys(this._parent.state)
				.filter(k => k.startsWith(propPrefix) && k !== propIxSel)
				.mergeMap(k => ({[k]: null}));
			this._parent.proxyAssignSimple("state", nxtState);
		};

		const hkEnt = (isNotFirstRun) => {
			fnsCleanupEnt.splice(0, fnsCleanupEnt.length).forEach(fn => fn());
			fnsCleanupGroup.splice(0, fnsCleanupGroup.length).forEach(fn => fn());
			$wrpRows.empty();

			if (isNotFirstRun) resetGroupState();

			const ent = this._parent[namespace]; 
			if ((ent?.feats?.length || 0) > 1) {
				const {$sel: $selGroup, unhook: unhookIxGroup} = UtilAdditionalFeats$1.getSelIxSetMeta({comp: this._parent, prop: propIxSel, available: ent.feats});
				fnsCleanupEnt.push(unhookIxGroup);
				$$`<div class="ve-flex-col mb-2">
					<div class="ve-flex-v-center mb-2">
						<div class="mr-2">Feat Set:</div>
						${$selGroup.addClass("max-w-200p")}
					</div>
				</div>`.appendTo($wrpRows);
			} else {
				this._parent.state[propIxSel] = 0;
			}

			const $wrpRowsInner = $(`<div class="w-100 ve-flex-col min-h-0"></div>`).appendTo($wrpRows);

			const hkIxSel = (isNotFirstRun) => {
				fnsCleanupGroup.splice(0, fnsCleanupGroup.length).forEach(fn => fn());
				$wrpRowsInner.empty();

				if (isNotFirstRun) resetGroupState();

				const featSet = ent?.feats?.[this._parent.state[propIxSel]];

				const uidsStatic = UtilAdditionalFeats$1.getUidsStatic(featSet);

				const $rows = [];

				uidsStatic.map((uid, ix) => {
					const {propIxFeatAbility, propFeatAbilityChooseFrom} = this._parent.getPropsAdditionalFeatsFeatSet_(namespace, "static", ix);
					const {name, source} = DataUtil.proxy.unpackUid("feat", uid, "feat", {isLower: true});
					const feat = this._parent.feats.find(it => it.name.toLowerCase() === name && it.source.toLowerCase() === source);
					const {$stgFeat, hkIxFeat, cleanup} = this._render_getMetaFeat({featStatic: feat, propIxFeatAbility, propFeatAbilityChooseFrom});
					fnsCleanupGroup.push(cleanup);
					hkIxFeat();

					const $row = $$`<div class="ve-flex-v-end py-3 px-1 statgen-asi__row">
						<div class="btn-group"><div class="w-100p text-center">Feat</div></div>
						<div class="vr-4"></div>
						${$stgFeat}
					</div>`.appendTo($wrpRowsInner);
					$rows.push($row);
				});

				[...new Array(featSet?.any || 0)].map((_, ix) => {
					const {propIxFeat, propIxFeatAbility, propFeatAbilityChooseFrom} = this._parent.getPropsAdditionalFeatsFeatSet_(namespace, "fromFilter", ix);
					const {$stgFeat, hkIxFeat, cleanup} = this._render_getMetaFeat({propIxFeat, propIxFeatAbility, propFeatAbilityChooseFrom});
					fnsCleanupGroup.push(cleanup);
					hkIxFeat();

					const $row = $$`<div class="ve-flex-v-end py-3 px-1 statgen-asi__row">
						<div class="btn-group"><div class="w-100p text-center">Feat</div></div>
						<div class="vr-4"></div>
						${$stgFeat}
					</div>`.appendTo($wrpRowsInner);
					$rows.push($row);
				});

								if ($rows.last()) $rows.last().removeClass("statgen-asi__row");

				this._doPulseThrottled();
			};
			this._parent.addHookBase(propIxSel, hkIxSel);
			fnsCleanupEnt.push(() => this._parent.removeHookBase(propIxSel, hkIxSel));
			hkIxSel();
			this._doPulseThrottled();
		};
		this._parent.addHookBase(propEntity, hkEnt);
		hkEnt();
	}

	_render_getMetaFeat ({featStatic = null, propIxFeat = null, propIxFeatAbility, propFeatAbilityChooseFrom}) {
		if (featStatic && propIxFeat) throw new Error(`Cannot combine static feat and feat property!`);
		if (featStatic == null && propIxFeat == null) throw new Error(`Either a static feat or a feat property must be specified!`);

		const $btnChooseFeat = featStatic ? null : $(`<button class="btn btn-xxs btn-default mr-2" title="Choose a Feat"><span class="glyphicon glyphicon-search"></span></button>`)
			.click(async () => {
				const selecteds = await this._parent.modalFilterFeats.pGetUserSelection();
				if (selecteds == null || !selecteds.length) return;

				const selected = selecteds[0];
				const ix = this._parent.feats.findIndex(it => it.name === selected.name && it.source === selected.values.sourceJson);
				if (!~ix) throw new Error(`Could not find selected entity: ${JSON.stringify(selected)}`); 				this._parent.state[propIxFeat] = ix;

				this._doPulseThrottled();
			});

				const $dispFeat = $(`<div class="ve-flex-v-center mr-2"></div>`);
		const $stgSelectAbilitySet = $$`<div class="ve-flex-v-center mr-2"></div>`;
		const $stgFeatNoChoice = $$`<div class="ve-flex-v-center mr-2"></div>`;
		const $stgFeatChooseAsiFrom = $$`<div class="ve-flex-v-end"></div>`;
		const $stgFeatChooseAsiWeighted = $$`<div class="ve-flex-v-center"></div>`;

		const $stgFeat = $$`<div class="ve-flex-v-center">
			${$btnChooseFeat}
			${$dispFeat}
			${$stgSelectAbilitySet}
			${$stgFeatNoChoice}
			${$stgFeatChooseAsiFrom}
			${$stgFeatChooseAsiWeighted}
		</div>`;

		const fnsCleanup = [];
		const fnsCleanupFeat = [];
		const fnsCleanupFeatAbility = [];

		const hkIxFeat = (isNotFirstRun) => {
			fnsCleanupFeat.splice(0, fnsCleanupFeat.length).forEach(fn => fn());
			fnsCleanupFeatAbility.splice(0, fnsCleanupFeatAbility.length).forEach(fn => fn());

			if (isNotFirstRun) {
				const nxtState = Object.keys(this._parent.state).filter(it => it.startsWith(propFeatAbilityChooseFrom)).mergeMap(it => ({[it]: null}));
				this._parent.proxyAssignSimple("state", nxtState);
			}

			const feat = featStatic || this._parent.feats[this._parent.state[propIxFeat]];

			$stgFeat.removeClass("ve-flex-v-end").addClass("ve-flex-v-center");
			$dispFeat.toggleClass("italic ve-muted", !feat);
			$dispFeat.html(feat ? Renderer.get().render(`{@feat ${feat.name.toLowerCase()}|${feat.source}}`) : `(Choose a feat)`);

			this._parent.state[propIxFeatAbility] = 0;

			$stgSelectAbilitySet.hideVe();
			if (feat) {
				if (feat.ability && feat.ability.length > 1) {
					const metaChooseAbilitySet = ComponentUiUtil.$getSelEnum(
						this._parent,
						propIxFeatAbility,
						{
							values: feat.ability.map((_, i) => i),
							fnDisplay: ix => Renderer.getAbilityData([feat.ability[ix]]).asText,
							asMeta: true,
						},
					);

					$stgSelectAbilitySet.showVe().append(metaChooseAbilitySet.$sel);
					metaChooseAbilitySet.$sel.change(() => this._doPulseThrottled());
					fnsCleanupFeat.push(() => metaChooseAbilitySet.unhook());
				}

				const hkAbilitySet = () => {
					fnsCleanupFeatAbility.splice(0, fnsCleanupFeatAbility.length).forEach(fn => fn());

					if (!feat.ability) {
						$stgFeatNoChoice.empty().hideVe();
						$stgFeatChooseAsiFrom.empty().hideVe();
						return;
					}

					const abilitySet = feat.ability[this._parent.state[propIxFeatAbility]];

										const ptsNoChoose = Parser.ABIL_ABVS.filter(ab => abilitySet[ab]).map(ab => `${Parser.attAbvToFull(ab)} ${UiUtil.intToBonus(abilitySet[ab], {isPretty: true})}`);
					$stgFeatNoChoice.empty().toggleVe(ptsNoChoose.length).html(`<div><span class="mr-2">\u2014</span>${ptsNoChoose.join(", ")}</div>`);
					
										if (abilitySet.choose && abilitySet.choose.from) {
						$stgFeat.removeClass("ve-flex-v-center").addClass("ve-flex-v-end");
						$stgFeatChooseAsiFrom.showVe().empty();
						$stgFeatChooseAsiWeighted.empty().hideVe();

						const count = abilitySet.choose.count || 1;
						const amount = abilitySet.choose.amount || 1;

						const {rowMetas, cleanup: cleanupAsiPicker} = ComponentUiUtil.getMetaWrpMultipleChoice(
							this._parent,
							propFeatAbilityChooseFrom,
							{
								values: abilitySet.choose.from,
								fnDisplay: v => `${Parser.attAbvToFull(v)} ${UiUtil.intToBonus(amount, {isPretty: true})}`,
								count,
							},
						);
						fnsCleanupFeatAbility.push(() => cleanupAsiPicker());

						$stgFeatChooseAsiFrom.append(`<div><span class="mr-2">\u2014</span>choose ${count > 1 ? `${count} ` : ""}${UiUtil.intToBonus(amount, {isPretty: true})}</div>`);

						rowMetas.forEach(meta => {
							meta.$cb.change(() => this._doPulseThrottled());

							$$`<label class="ve-flex-col no-select">
								<div class="ve-flex-vh-center statgen-asi__cell-feat" title="${Parser.attAbvToFull(meta.value)}">${meta.value.toUpperCase()}</div>
								<div class="ve-flex-vh-center statgen-asi__cell-feat">${meta.$cb}</div>
							</label>`.appendTo($stgFeatChooseAsiFrom);
						});
					} else if (abilitySet.choose && abilitySet.choose.weighted) {
												$stgFeatChooseAsiFrom.empty().hideVe();
						$stgFeatChooseAsiWeighted.showVe().html(`<i class="ve-muted">The selected ability score format is currently unsupported. Please check back later!</i>`);
					} else {
						$stgFeatChooseAsiFrom.empty().hideVe();
						$stgFeatChooseAsiWeighted.empty().hideVe();
					}
					
					this._doPulseThrottled();
				};
				this._parent.addHookBase(propIxFeatAbility, hkAbilitySet);
				fnsCleanupFeat.push(() => this._parent.removeHookBase(propIxFeatAbility, hkAbilitySet));
				hkAbilitySet();
			} else {
				$stgFeatNoChoice.empty().hideVe();
				$stgFeatChooseAsiFrom.empty().hideVe();
				$stgFeatChooseAsiWeighted.empty().hideVe();
			}

			this._doPulseThrottled();
		};

		if (!featStatic) {
			this._parent.addHookBase(propIxFeat, hkIxFeat);
			fnsCleanup.push(() => this._parent.removeHookBase(propIxFeat, hkIxFeat));
		}

		const cleanup = () => {
			fnsCleanup.splice(0, fnsCleanup.length).forEach(fn => fn());
			fnsCleanupFeat.splice(0, fnsCleanupFeat.length).forEach(fn => fn());
			fnsCleanupFeatAbility.splice(0, fnsCleanupFeatAbility.length).forEach(fn => fn());
		};

		return {$btnChooseFeat, $stgFeat, hkIxFeat, cleanup};
	}

	render ($wrpAsi) {
		const $wrpRowsAsi = $(`<div class="ve-flex-col w-100 overflow-y-auto"></div>`);
		const $wrpRowsRace = $(`<div class="ve-flex-col w-100 overflow-y-auto"></div>`);
		const $wrpRowsBackground = $(`<div class="ve-flex-col w-100 overflow-y-auto"></div>`);
		const $wrpRowsCustom = $(`<div class="ve-flex-col w-100 overflow-y-auto"></div>`);

		this._render_renderAsiFeatSection("common_cntAsi", "ability", $wrpRowsAsi);
		this._render_renderAsiFeatSection("common_cntFeatsCustom", "custom", $wrpRowsCustom);
		this._render_renderAdditionalFeatSection({propEntity: "common_ixRace", namespace: "race", $wrpRows: $wrpRowsRace});
		this._render_renderAdditionalFeatSection({propEntity: "common_ixBackground", namespace: "background", $wrpRows: $wrpRowsBackground});

		const $getStgEntity = ({title, $wrpRows, propEntity, propIxEntity}) => {
			const $stg = $$`<div class="ve-flex-col">
				<hr class="hr-3 hr--dotted">
				<h4 class="my-2 bold">${title} Feats</h4>
				${$wrpRows}
			</div>`;

			const hkIxEntity = () => {
				const entity = this._parent[propEntity];
				$stg.toggleVe(!this._parent.isLevelUp && !!entity?.feats);
			};
			this._parent.addHookBase(propIxEntity, hkIxEntity);
			hkIxEntity();

			return $stg;
		};

		const $stgRace = $getStgEntity({title: "Race", $wrpRows: $wrpRowsRace, propEntity: "race", propIxEntity: "common_ixRace"});

		const $stgBackground = $getStgEntity({title: "Background", $wrpRows: $wrpRowsBackground, propEntity: "background", propIxEntity: "common_ixBackground"});

		const $iptCountFeatsCustom = ComponentUiUtil.$getIptInt(this._parent, "common_cntFeatsCustom", 0, {min: 0, max: StatGenUi._MAX_CUSTOM_FEATS})
			.addClass("w-100p text-center");

		$$($wrpAsi)`
			<h4 class="my-2 bold">Ability Score Increases</h4>
			${this._render_$getStageCntAsi()}
			${$wrpRowsAsi}

			${$stgRace}

			${$stgBackground}

			<hr class="hr-3 hr--dotted">
			<h4 class="my-2 bold">Additional Feats</h4>
			<label class="w-100 ve-flex-v-center mb-2">
				<div class="mr-2 no-shrink">Number of additional feats:</div>${$iptCountFeatsCustom}
			</label>
			${$wrpRowsCustom}
		`;
	}

	_render_$getStageCntAsi () {
		if (!this._parent.isCharacterMode) {
			const $iptCountAsi = ComponentUiUtil.$getIptInt(this._parent, "common_cntAsi", 0, {min: 0, max: 20})
				.addClass("w-100p text-center");
			return $$`<label class="w-100 ve-flex-v-center mb-2"><div class="mr-2 no-shrink">Number of Ability Score Increases to apply:</div>${$iptCountAsi}</label>`;
		}

		const $out = $$`<div class="w-100 ve-flex-v-center mb-2 italic ve-muted">No ability score increases available.</div>`;
		const hkCntAsis = () => $out.toggleVe(this._parent.state.common_cntAsi === 0);
		this._parent.addHookBase("common_cntAsi", hkCntAsis);
		hkCntAsis();
		return $out;
	}

	_getFormData_getForNamespace_basic (outs, outIsFormCompletes, outFeats, propCnt, namespace) {
		for (let i = 0; i < this._parent.state[propCnt]; ++i) {
			const {propMode, propIxFeat, propIxAsiPointOne, propIxAsiPointTwo, propIxFeatAbility, propFeatAbilityChooseFrom} = this._parent.getPropsAsi(i, namespace);

			if (this._parent.state[propMode] === "asi") {
				const out = {};

				let ttlChosen = 0;

				Parser.ABIL_ABVS.forEach((ab, abI) => {
					const increase = [this._parent.state[propIxAsiPointOne] === abI, this._parent.state[propIxAsiPointTwo] === abI].filter(Boolean).length;
					if (increase) out[ab] = increase;
					ttlChosen += increase;
				});

				const isFormComplete = ttlChosen === 2;

				outFeats[namespace].push(null); 
				outs.push(out);
				outIsFormCompletes.push(isFormComplete);
			} else if (this._parent.state[propMode] === "feat") {
				const {isFormComplete, out} = this._getFormData_doAddFeatMeta({
					namespace,
					outFeats,
					propIxFeat,
					propIxFeatAbility,
					propFeatAbilityChooseFrom,
					type: "choose",
				});
				outs.push(out);
				outIsFormCompletes.push(isFormComplete);
			}
		}
	}

	_getFormData_getForNamespace_additional (outs, outIsFormCompletes, outFeats, namespace) {
		const ent = this._parent[namespace]; 		if (!ent?.feats?.length) return;

		const {propIxSel} = this._parent.getPropsAdditionalFeats_(namespace);

		const featSet = ent.feats[this._parent.state[propIxSel]];
		if (!featSet) {
			outIsFormCompletes.push(false);
			return;
		}

		const uidsStatic = UtilAdditionalFeats$1.getUidsStatic(featSet);

		uidsStatic.map((uid, ix) => {
			const {propIxFeatAbility, propFeatAbilityChooseFrom} = this._parent.getPropsAdditionalFeatsFeatSet_(namespace, "static", ix);
			const {name, source} = DataUtil.proxy.unpackUid("feat", uid, "feat", {isLower: true});
			const feat = this._parent.feats.find(it => it.name.toLowerCase() === name && it.source.toLowerCase() === source);

			const {isFormComplete, out} = this._getFormData_doAddFeatMeta({
				namespace,
				outFeats,
				featStatic: feat,
				propIxFeatAbility,
				propFeatAbilityChooseFrom,
				type: "static",
			});

			outs.push(out);
			outIsFormCompletes.push(isFormComplete);
		});

		[...new Array(featSet.any || 0)].map((_, ix) => {
			const {propIxFeat, propIxFeatAbility, propFeatAbilityChooseFrom} = this._parent.getPropsAdditionalFeatsFeatSet_(namespace, "fromFilter", ix);

			const {isFormComplete, out} = this._getFormData_doAddFeatMeta({
				namespace,
				outFeats,
				propIxFeat,
				propIxFeatAbility,
				propFeatAbilityChooseFrom,
				type: "choose",
			});

			outs.push(out);
			outIsFormCompletes.push(isFormComplete);
		});
	}

	_getFormData_doAddFeatMeta ({namespace, outFeats, propIxFeat = null, featStatic = null, propIxFeatAbility, propFeatAbilityChooseFrom, type}) {
		if (featStatic && propIxFeat) throw new Error(`Cannot combine static feat and feat property!`);
		if (featStatic == null && propIxFeat == null) throw new Error(`Either a static feat or a feat property must be specified!`);

		const out = {};

		const feat = featStatic || this._parent.feats[this._parent.state[propIxFeat]];

		const featMeta = feat
			? {ix: this._parent.state[propIxFeat], uid: `${feat.name}|${feat.source}`, type}
			: {ix: -1, uid: null, type};
		outFeats[namespace].push(featMeta);

		if (!~featMeta.ix) return {isFormComplete: false, out};
		if (!feat.ability) return {isFormComplete: true, out};

		const abilitySet = feat.ability[this._parent.state[propIxFeatAbility] || 0];

				Parser.ABIL_ABVS.forEach(ab => { if (abilitySet[ab]) out[ab] = abilitySet[ab]; });

		if (!abilitySet.choose) return {isFormComplete: true, out};

		let isFormComplete = true;

				featMeta.abilityChosen = {};

		if (abilitySet.choose.from) {
			if (isFormComplete) isFormComplete = !!this._parent.state[ComponentUiUtil.getMetaWrpMultipleChoice_getPropIsAcceptable(propFeatAbilityChooseFrom)];

			const ixs = ComponentUiUtil.getMetaWrpMultipleChoice_getSelectedIxs(this._parent, propFeatAbilityChooseFrom);
			ixs.map(it => abilitySet.choose.from[it]).forEach(ab => {
				const amount = abilitySet.choose.amount || 1;
				out[ab] = (out[ab] || 0) + amount;
				featMeta.abilityChosen[ab] = amount;
			});
		}

		return {isFormComplete, out};
	}

	getFormData () {
		const outs = [];
		const isFormCompletes = [];
		const feats = {ability: [], race: [], background: [], custom: []};

		this._getFormData_getForNamespace_basic(outs, isFormCompletes, feats, "common_cntAsi", "ability");
		this._getFormData_getForNamespace_basic(outs, isFormCompletes, feats, "common_cntFeatsCustom", "custom");
		this._getFormData_getForNamespace_additional(outs, isFormCompletes, feats, "race");
		this._getFormData_getForNamespace_additional(outs, isFormCompletes, feats, "background");

		const data = {};
		outs.filter(Boolean).forEach(abilBonuses => Object.entries(abilBonuses).forEach(([ab, bonus]) => data[ab] = (data[ab] || 0) + bonus));

		return {
			isFormComplete: isFormCompletes.every(Boolean),
			dataPerAsi: outs,
			data,
			feats,
		};
	}
};

StatGenUi.RenderableCollectionPbRules = class extends RenderableCollectionBase {
	constructor (statGenUi, $wrp) {
		super(statGenUi, "pb_rules");

		this._$wrp = $wrp;
	}

	getNewRender (rule) {
		const parentComp = this._comp;

		const comp = BaseComponent.fromObject(rule.entity);
		comp._addHookAll("state", () => {
			rule.entity = comp.toObject();
			parentComp._triggerCollectionUpdate("pb_rules");
		});

		const $dispCost = $(`<div class="ve-flex-vh-center"></div>`);
		const hkCost = () => $dispCost.text(comp._state.cost);
		comp._addHookBase("cost", hkCost);
		hkCost();

		const $iptCost = ComponentUiUtil.$getIptInt(comp, "cost", 0, {html: `<input class="form-control input-xs form-control--minimal text-center">`, fallbackOnNaN: 0});

		const hkIsCustom = () => {
			$dispCost.toggleVe(!parentComp.state.pb_isCustom);
			$iptCost.toggleVe(parentComp.state.pb_isCustom);
		};
		parentComp._addHookBase("pb_isCustom", hkIsCustom);
		hkIsCustom();

		const $btnDelete = $(`<button class="btn btn-xxs btn-danger" title="Delete"><span class="glyphicon glyphicon-trash"></span></button>`)
			.click(() => {
				if (parentComp.state.pb_rules.length === 1) return; 				parentComp.state.pb_rules = parentComp.state.pb_rules.filter(it => it !== rule);
			});

		const $wrpRow = $$`<div class="ve-flex py-1 stripe-even statgen-pb__row-cost">
			<div class="statgen-pb__col-cost ve-flex-vh-center">${comp._state.score}</div>
			<div class="statgen-pb__col-cost ve-flex-vh-center">${Parser.getAbilityModifier(comp._state.score)}</div>
			<div class="statgen-pb__col-cost ve-flex-vh-center px-3">
				${$dispCost}
				${$iptCost}
			</div>
			<div class="statgen-pb__col-cost-delete">${$btnDelete}</div>
		</div>`.appendTo(this._$wrp);

		const hkRules = () => {
			$btnDelete.toggleVe((parentComp.state.pb_rules[0] === rule || parentComp.state.pb_rules.last() === rule) && parentComp.state.pb_isCustom);
		};
		parentComp._addHookBase("pb_rules", hkRules);
		parentComp._addHookBase("pb_isCustom", hkRules);
		hkRules();

		return {
			comp,
			$wrpRow,
			fnCleanup: () => {
				parentComp._removeHookBase("pb_isCustom", hkIsCustom);
				parentComp._removeHookBase("pb_isCustom", hkRules);
				parentComp._removeHookBase("pb_rules", hkRules);
			},
		};
	}

	doUpdateExistingRender (renderedMeta, rule) {
		renderedMeta.comp._proxyAssignSimple("state", rule.entity, true);
	}

	doDeleteExistingRender (renderedMeta) {
		renderedMeta.fnCleanup();
	}

	doReorderExistingComponent (renderedMeta, rule) {
		const parent = this._comp;

		const ix = parent.state.pb_rules.map(it => it.id).indexOf(rule.id);
		const curIx = this._$wrp.find(`.statgen-pb__row-cost`).index(renderedMeta.$wrpRow);

		const isMove = !this._$wrp.length || curIx !== ix;
		if (isMove) renderedMeta.$wrpRow.detach().appendTo(this._$wrp);
	}
};

"use strict";

class _BrewInternalUtil {
	static SOURCE_UNKNOWN_FULL = "(Unknown)";
	static SOURCE_UNKNOWN_ABBREVIATION = "(UNK)";
}

class BrewDoc {
	constructor (opts) {
		opts = opts || {};
		this.head = opts.head;
		this.body = opts.body;
	}

	toObject () { return MiscUtil.copyFast({...this}); }

	static fromValues ({head, body}) {
		return new this({
			head: BrewDocHead.fromValues(head),
			body,
		});
	}

	static fromObject (obj, opts = {}) {
		const {isCopy = false} = opts;
		return new this({
			head: BrewDocHead.fromObject(obj.head, opts),
			body: isCopy ? MiscUtil.copyFast(obj.body) : obj.body,
		});
	}

	mutUpdate ({json}) {
		this.body = json;
		this.head.mutUpdate({json, body: this.body});
		return this;
	}

		static isOperationPermitted_moveToEditable ({brew, isAllowLocal = false} = {}) {
		return !brew.head.isEditable
			&& (isAllowLocal || !brew.head.isLocal);
	}
	
		mutMerge ({json, isLazy = false}) {
		this.body = this.constructor.mergeObjects({isCopy: !isLazy, isMutMakeCompatible: false}, this.body, json);
		this.head.mutMerge({json, body: this.body, isLazy});
		return this;
	}

	static mergeObjects ({isCopy = true, isMutMakeCompatible = true} = {}, ...jsons) {
		const out = {};

		jsons.forEach(json => {
			json = isCopy ? MiscUtil.copyFast(json) : json;

			if (isMutMakeCompatible) this._mergeObjects_mutMakeCompatible(json);

			Object.entries(json)
				.forEach(([prop, val]) => {
					switch (prop) {
						case "_meta": return this._mergeObjects_key__meta({out, prop, val});
						default: return this._mergeObjects_default({out, prop, val});
					}
				});
		});

		return out;
	}

	static _META_KEYS_MERGEABLE_OBJECTS = [
		"skills",
		"senses",
		"spellSchools",
		"spellDistanceUnits",
		"optionalFeatureTypes",
		"psionicTypes",
		"currencyConversions",
	];

	static _META_KEYS_MERGEABLE_SPECIAL = {
		"dateAdded": (a, b) => a != null && b != null ? Math.min(a, b) : a ?? b,
		"dateLastModified": (a, b) => a != null && b != null ? Math.max(a, b) : a ?? b,

		"dependencies": (a, b) => this._metaMerge_dependenciesIncludes(a, b),
		"includes": (a, b) => this._metaMerge_dependenciesIncludes(a, b),
		"internalCopies": (a, b) => [...(a || []), ...(b || [])].unique(),

		"otherSources": (a, b) => this._metaMerge_otherSources(a, b),

		"status": (a, b) => this._metaMerge_status(a, b),
	};

	static _metaMerge_dependenciesIncludes (a, b) {
		if (a != null && b != null) {
			Object.entries(b)
				.forEach(([prop, arr]) => a[prop] = [...(a[prop] || []), ...arr].unique());
			return a;
		}

		return a ?? b;
	}

	static _metaMerge_otherSources (a, b) {
		if (a != null && b != null) {
						Object.entries(b)
				.forEach(([prop, obj]) => a[prop] = Object.assign(a[prop] || {}, obj));
			return a;
		}

		return a ?? b;
	}

	static _META_MERGE__STATUS_PRECEDENCE = [
		"invalid",
		"deprecated",
		"wip",
		"ready",
	];

	static _metaMerge_status (a, b) {
		return [a || "ready", b || "ready"]
			.sort((a, b) => this._META_MERGE__STATUS_PRECEDENCE.indexOf(a) - this._META_MERGE__STATUS_PRECEDENCE.indexOf(b))[0];
	}

	static _mergeObjects_key__meta ({out, val}) {
		out._meta = out._meta || {};

		out._meta.sources = [...(out._meta.sources || []), ...(val.sources || [])];

		Object.entries(val)
			.forEach(([metaProp, metaVal]) => {
				if (this._META_KEYS_MERGEABLE_SPECIAL[metaProp]) {
					out._meta[metaProp] = this._META_KEYS_MERGEABLE_SPECIAL[metaProp](out._meta[metaProp], metaVal);
					return;
				}
				if (!this._META_KEYS_MERGEABLE_OBJECTS.includes(metaProp)) return;
				Object.assign(out._meta[metaProp] = out._meta[metaProp] || {}, metaVal);
			});
	}

	static _mergeObjects_default ({out, prop, val}) {
				if (!(val instanceof Array)) return out[prop] === undefined ? out[prop] = val : null;

		out[prop] = [...out[prop] || [], ...val];
	}

	static _mergeObjects_mutMakeCompatible (json) {
				if (json.variant) {
						json.magicvariant = json.variant;
			delete json.variant;
		}
		
				if (json.subrace) {
			json.subrace.forEach(sr => {
				if (!sr.race) return;
				sr.raceName = sr.race.name;
				sr.raceSource = sr.race.source || sr.source || Parser.SRC_PHB;
			});
		}
		
				if (json.monster) {
			json.monster.forEach(mon => {
								if (typeof mon.size === "string") mon.size = [mon.size];

								if (mon.summonedBySpell && !mon.summonedBySpellLevel) mon.summonedBySpellLevel = 1;
			});
		}
			}
	}

class BrewDocHead {
	constructor (opts) {
		opts = opts || {};

		this.docIdLocal = opts.docIdLocal;
		this.timeAdded = opts.timeAdded;
		this.checksum = opts.checksum;
		this.url = opts.url;
		this.filename = opts.filename;
		this.isLocal = opts.isLocal;
		this.isEditable = opts.isEditable;
	}

	toObject () { return MiscUtil.copyFast({...this}); }

	static fromValues (
		{
			json,
			url = null,
			filename = null,
			isLocal = false,
			isEditable = false,
		},
	) {
		return new this({
			docIdLocal: CryptUtil.uid(),
			timeAdded: Date.now(),
			checksum: CryptUtil.md5(JSON.stringify(json)),
			url: url,
			filename: filename,
			isLocal: isLocal,
			isEditable: isEditable,
		});
	}

	static fromObject (obj, {isCopy = false} = {}) {
		return new this(isCopy ? MiscUtil.copyFast(obj) : obj);
	}

	mutUpdate ({json}) {
		this.checksum = CryptUtil.md5(JSON.stringify(json));
		return this;
	}

	mutMerge ({json, body, isLazy}) {
		if (!isLazy) this.checksum = CryptUtil.md5(JSON.stringify(body ?? json));
		return this;
	}
}

let BrewUtilShared$1 = class BrewUtilShared {
		static getValidColor (color, {isExtended = false} = {}) {
		if (isExtended) return color.replace(/[^-a-zA-Z\d]/g, "");
		return color.replace(/[^a-fA-F\d]/g, "").slice(0, 8);
	}
};

globalThis.BrewUtilShared = BrewUtilShared$1;

class _BrewUtil2Base {
	_STORAGE_KEY_LEGACY;
	_STORAGE_KEY_LEGACY_META;

		_STORAGE_KEY;
	_STORAGE_KEY_META;

	_STORAGE_KEY_CUSTOM_URL;
	_STORAGE_KEY_MIGRATION_VERSION;

	_VERSION;

	_PATH_LOCAL_DIR;
	_PATH_LOCAL_INDEX;

	IS_EDITABLE;
	PAGE_MANAGE;
	URL_REPO_DEFAULT;
	DISPLAY_NAME;
	DISPLAY_NAME_PLURAL;
	DEFAULT_AUTHOR;
	STYLE_BTN;

	_LOCK = new VeLock();

	_cache_iteration = 0;
	_cache_brewsProc = null;
	_cache_metas = null;
	_cache_brewsLocal = null;

	_isDirty = false;

	_brewsTemp = [];
	_addLazy_brewsTemp = [];

	_storage = StorageUtil;

	
	_isInit = false;

	async pInit () {
		if (this._isInit) return;
		this._isInit = true;

						await this._pGetBrew_pGetLocalBrew();
		
		this._pInit_doBindDragDrop();
		this._pInit_pDoLoadFonts().then(null);
	}

		_pInit_doBindDragDrop () { throw new Error("Unimplemented!"); }

	async _pInit_pDoLoadFonts () {
		const fontFaces = Object.entries(
			(this._getBrewMetas() || [])
				.map(({_meta}) => _meta?.fonts || {})
				.mergeMap(it => it),
		)
			.map(([family, fontUrl]) => new FontFace(family, `url("${fontUrl}")`));

		const results = await Promise.allSettled(
			fontFaces.map(async fontFace => {
				await fontFace.load();
				return document.fonts.add(fontFace);
			}),
		);

		const errors = results
			.filter(({status}) => status === "rejected")
			.map(({reason}, i) => ({message: `Font "${fontFaces[i].family}" failed to load!`, reason}));
		if (errors.length) {
			errors.forEach(({message}) => JqueryUtil.doToast({type: "danger", content: message}));
			setTimeout(() => { throw new Error(errors.map(({message, reason}) => [message, reason].join("\n")).join("\n\n")); });
		}

		return document.fonts.ready;
	}

	
	async pGetCustomUrl () { return this._storage.pGet(this._STORAGE_KEY_CUSTOM_URL); }

	async pSetCustomUrl (val) {
		return !val
			? this._storage.pRemove(this._STORAGE_KEY_CUSTOM_URL)
			: this._storage.pSet(this._STORAGE_KEY_CUSTOM_URL, val);
	}

	
	isReloadRequired () { return this._isDirty; }

	_getBrewMetas () {
		return [
			...(this._storage.syncGet(this._STORAGE_KEY_META) || []),
			...(this._cache_brewsLocal || []).map(brew => this._getBrewDocReduced(brew)),
		];
	}

	_setBrewMetas (val) {
		this._cache_metas = null;
		return this._storage.syncSet(this._STORAGE_KEY_META, val);
	}

		async pGetBrewProcessed () {
		if (this._cache_brewsProc) return this._cache_brewsProc; 
		try {
			const lockToken = await this._LOCK.pLock();
			await this._pGetBrewProcessed_({lockToken});
		} catch (e) {
			setTimeout(() => { throw e; });
		} finally {
			this._LOCK.unlock();
		}
		return this._cache_brewsProc;
	}

	async _pGetBrewProcessed_ ({lockToken}) {
		const cpyBrews = MiscUtil.copyFast([
			...await this.pGetBrew({lockToken}),
			...this._brewsTemp,
		]);
		if (!cpyBrews.length) return this._cache_brewsProc = {};

		await this._pGetBrewProcessed_pDoBlocklistExtension({cpyBrews});

				const cpyBrewsLoaded = await cpyBrews.pSerialAwaitMap(async ({head, body}) => {
			const cpyBrew = await DataUtil.pDoMetaMerge(head.url || head.docIdLocal, body, {isSkipMetaMergeCache: true});
			this._pGetBrewProcessed_mutDiagnostics({head, cpyBrew});
			return cpyBrew;
		});

		this._cache_brewsProc = this._pGetBrewProcessed_getMergedOutput({cpyBrewsLoaded});
		return this._cache_brewsProc;
	}

		async _pGetBrewProcessed_pDoBlocklistExtension ({cpyBrews}) {
		for (const {body} of cpyBrews) {
			if (!body?.blocklist?.length || !(body.blocklist instanceof Array)) continue;
			await ExcludeUtil.pExtendList(body.blocklist);
		}
	}

	_pGetBrewProcessed_mutDiagnostics ({head, cpyBrew}) {
		if (!head.filename) return;

		for (const arr of Object.values(cpyBrew)) {
			if (!(arr instanceof Array)) continue;
			for (const ent of arr) {
				if (!("__prop" in ent)) break;
				ent.__diagnostic = {filename: head.filename};
			}
		}
	}

	_pGetBrewProcessed_getMergedOutput ({cpyBrewsLoaded}) {
		return BrewDoc.mergeObjects(undefined, ...cpyBrewsLoaded);
	}

		getBrewProcessedFromCache (prop) {
		return this._cache_brewsProc?.[prop] || [];
	}

	
		async pGetBrew ({lockToken} = {}) {
		try {
			lockToken = await this._LOCK.pLock({token: lockToken});

			const out = [
				...(await this._pGetBrewRaw({lockToken})),
				...(await this._pGetBrew_pGetLocalBrew({lockToken})),
			];

			return out
								.filter(brew => brew?.body?._meta?.sources?.length);
		} finally {
			this._LOCK.unlock();
		}
	}

	
	async _pGetBrew_pGetLocalBrew ({lockToken} = {}) {
		if (this._cache_brewsLocal) return this._cache_brewsLocal;
		if (IS_VTT || IS_DEPLOYED || typeof window === "undefined") return this._cache_brewsLocal = [];

		try {
			await this._LOCK.pLock({token: lockToken});
			return (await this._pGetBrew_pGetLocalBrew_());
		} finally {
			this._LOCK.unlock();
		}
	}

	async _pGetBrew_pGetLocalBrew_ () {
				const indexLocal = await DataUtil.loadJSON(`${Renderer.get().baseUrl}${this._PATH_LOCAL_INDEX}`);
		if (!indexLocal?.toImport?.length) return this._cache_brewsLocal = [];

		const out = await indexLocal.toImport.pMap(async name => {
			name = `${name}`.trim();
			const url = /^https?:\/\//.test(name) ? name : `${Renderer.get().baseUrl}${this._PATH_LOCAL_DIR}/${name}`;
			const filename = UrlUtil.getFilename(url);
			try {
				const json = await DataUtil.loadRawJSON(url);
				return this._getBrewDoc({json, url, filename, isLocal: true});
			} catch (e) {
				JqueryUtil.doToast({type: "danger", content: `Failed to load local homebrew from URL "${url}"! ${VeCt.STR_SEE_CONSOLE}`});
				setTimeout(() => { throw e; });
				return null;
			}
		});

		return this._cache_brewsLocal = out.filter(Boolean);
	}

	
	async _pGetBrewRaw ({lockToken} = {}) {
		try {
			await this._LOCK.pLock({token: lockToken});
			return (await this._pGetBrewRaw_());
		} finally {
			this._LOCK.unlock();
		}
	}

	async _pGetBrewRaw_ () {
		const brewRaw = (await this._storage.pGet(this._STORAGE_KEY)) || [];

				if (brewRaw.length) return brewRaw;

		const {version, existingMeta, existingBrew} = await this._pGetMigrationInfo();

		if (version === this._VERSION) return brewRaw;

		if (!existingMeta || !existingBrew) {
			await this._storage.pSet(this._STORAGE_KEY_MIGRATION_VERSION, this._VERSION);
			return brewRaw;
		}

								const brewEditable = this._getNewEditableBrewDoc();

		const cpyBrewEditableDoc = BrewDoc.fromObject(brewEditable, {isCopy: true})
			.mutMerge({
				json: {
					_meta: existingMeta || {},
					...existingBrew,
				},
			});

		await this._pSetBrew_({val: [cpyBrewEditableDoc], isInitialMigration: true});

						await this._storage.pSet(this._STORAGE_KEY_MIGRATION_VERSION, this._VERSION);

		JqueryUtil.doToast(`Migrated ${this.DISPLAY_NAME} from version ${version} to version ${this._VERSION}!`);

		return this._storage.pGet(this._STORAGE_KEY);
	}

	_getNewEditableBrewDoc () {
		const json = {_meta: {sources: []}};
		return this._getBrewDoc({json, isEditable: true});
	}

	
	async _pGetMigrationInfo () {
				if (!this._STORAGE_KEY_LEGACY && !this._STORAGE_KEY_LEGACY_META) return {version: this._VERSION, existingBrew: null, existingMeta: null};

		const version = await this._storage.pGet(this._STORAGE_KEY_MIGRATION_VERSION);

				if (version === this._VERSION) return {version};

		const existingBrew = await this._storage.pGet(this._STORAGE_KEY_LEGACY);
		const existingMeta = await this._storage.syncGet(this._STORAGE_KEY_LEGACY_META);

		return {
			version: version ?? 1,
			existingBrew,
			existingMeta,
		};
	}

	getCacheIteration () { return this._cache_iteration; }

	async pSetBrew (val, {lockToken} = {}) {
		try {
			await this._LOCK.pLock({token: lockToken});
			await this._pSetBrew_({val});
		} finally {
			this._LOCK.unlock();
		}
	}

	async _pSetBrew_ ({val, isInitialMigration}) {
		this._mutBrewsForSet(val);

		if (!isInitialMigration) {
			if (this._cache_brewsProc) this._cache_iteration++;
			this._cache_brewsProc = null;
		}
		await this._storage.pSet(this._STORAGE_KEY, val);

		if (!isInitialMigration) this._isDirty = true;
	}

	_mutBrewsForSet (val) {
		if (!(val instanceof Array)) throw new Error(`${this.DISPLAY_NAME.uppercaseFirst()} array must be an array!`);

		this._setBrewMetas(val.map(brew => this._getBrewDocReduced(brew)));
	}

	_getBrewId (brew) {
		if (brew.head.url) return brew.head.url;
		if (brew.body._meta?.sources?.length) return brew.body._meta.sources.map(src => (src.json || "").toLowerCase()).sort(SortUtil.ascSortLower).join(" :: ");
		return null;
	}

	_getNextBrews (brews, brewsToAdd) {
		const idsToAdd = new Set(brewsToAdd.map(brews => this._getBrewId(brews)).filter(Boolean));
		brews = brews.filter(brew => {
			const id = this._getBrewId(brew);
			if (id == null) return true;
			return !idsToAdd.has(id);
		});
		return [...brews, ...brewsToAdd];
	}

	async _pAddBrewDependencies ({brewDocs, brewsRaw = null, brewsRawLocal = null, lockToken}) {
		try {
			lockToken = await this._LOCK.pLock({token: lockToken});
			return (await this._pAddBrewDependencies_({brewDocs, brewsRaw, brewsRawLocal, lockToken}));
		} finally {
			this._LOCK.unlock();
		}
	}

	async _pAddBrewDependencies_ ({brewDocs, brewsRaw = null, brewsRawLocal = null, lockToken}) {
		const urlRoot = await this.pGetCustomUrl();
		const brewIndex = await this._pGetSourceIndex(urlRoot);

		const toLoadSources = [];
		const loadedSources = new Set();
		const out = [];

		brewsRaw = brewsRaw || await this._pGetBrewRaw({lockToken});
		brewsRawLocal = brewsRawLocal || await this._pGetBrew_pGetLocalBrew({lockToken});

		const trackLoaded = brew => (brew.body._meta?.sources || [])
			.filter(src => src.json)
			.forEach(src => loadedSources.add(src.json));
		brewsRaw.forEach(brew => trackLoaded(brew));
		brewsRawLocal.forEach(brew => trackLoaded(brew));

		brewDocs.forEach(brewDoc => toLoadSources.push(...this._getBrewDependencySources({brewDoc, brewIndex})));

		while (toLoadSources.length) {
			const src = toLoadSources.pop();
			if (loadedSources.has(src)) continue;
			loadedSources.add(src);

			const url = this.getFileUrl(brewIndex[src], urlRoot);
			const brewDocDep = await this._pGetBrewDocFromUrl({url});
			out.push(brewDocDep);
			trackLoaded(brewDocDep);

			toLoadSources.push(...this._getBrewDependencySources({brewDoc: brewDocDep, brewIndex}));
		}

		return out;
	}

	async pGetSourceUrl (source) {
		const urlRoot = await this.pGetCustomUrl();
		const brewIndex = await this._pGetSourceIndex(urlRoot);

		if (brewIndex[source]) return this.getFileUrl(brewIndex[source], urlRoot);

		const sourceLower = source.toLowerCase();
		if (brewIndex[sourceLower]) return this.getFileUrl(brewIndex[sourceLower], urlRoot);

		const sourceOriginal = Object.keys(brewIndex).find(k => k.toLowerCase() === sourceLower);
		if (!brewIndex[sourceOriginal]) return null;
		return this.getFileUrl(brewIndex[sourceOriginal], urlRoot);
	}

		async _pGetSourceIndex (urlRoot) { throw new Error("Unimplemented!"); }
		getFileUrl (path, urlRoot) { throw new Error("Unimplemented!"); }
		pLoadTimestamps (urlRoot) { throw new Error("Unimplemented!"); }
		pLoadPropIndex (urlRoot) { throw new Error("Unimplemented!"); }
		pLoadMetaIndex (urlRoot) { throw new Error("Unimplemented!"); }

	_PROPS_DEPS = ["dependencies", "includes"];
	_PROPS_DEPS_DEEP = ["otherSources"];

	_getBrewDependencySources ({brewDoc, brewIndex}) {
		const out = new Set();

		this._PROPS_DEPS.forEach(prop => {
			const obj = brewDoc.body._meta?.[prop];
			if (!obj || !Object.keys(obj).length) return;
			Object.values(obj)
				.flat()
				.filter(src => brewIndex[src])
				.forEach(src => out.add(src));
		});

		this._PROPS_DEPS_DEEP.forEach(prop => {
			const obj = brewDoc.body._meta?.[prop];
			if (!obj || !Object.keys(obj).length) return;
			return Object.values(obj)
				.map(objSub => Object.keys(objSub))
				.flat()
				.filter(src => brewIndex[src])
				.forEach(src => out.add(src));
		});

		return out;
	}

	async pAddBrewFromUrl (url, {lockToken, isLazy} = {}) {
		try {
			return (await this._pAddBrewFromUrl({url, lockToken, isLazy}));
		} catch (e) {
			JqueryUtil.doToast({type: "danger", content: `Failed to load ${this.DISPLAY_NAME} from URL "${url}"! ${VeCt.STR_SEE_CONSOLE}`});
			setTimeout(() => { throw e; });
		}
		return [];
	}

	async _pGetBrewDocFromUrl ({url}) {
		const json = await DataUtil.loadRawJSON(url);
		return this._getBrewDoc({json, url, filename: UrlUtil.getFilename(url)});
	}

	async _pAddBrewFromUrl ({url, lockToken, isLazy}) {
		const brewDoc = await this._pGetBrewDocFromUrl({url});

		if (isLazy) {
			try {
				await this._LOCK.pLock({token: lockToken});
				this._addLazy_brewsTemp.push(brewDoc);
			} finally {
				this._LOCK.unlock();
			}

			return [brewDoc];
		}

		const brewDocs = [brewDoc];
		try {
			lockToken = await this._LOCK.pLock({token: lockToken});
			const brews = MiscUtil.copyFast(await this._pGetBrewRaw({lockToken}));

			const brewDocsDependencies = await this._pAddBrewDependencies({brewDocs: [brewDoc], brewsRaw: brews, lockToken});
			brewDocs.push(...brewDocsDependencies);

			const brewsNxt = this._getNextBrews(brews, brewDocs);
			await this.pSetBrew(brewsNxt, {lockToken});
		} finally {
			this._LOCK.unlock();
		}

		return brewDocs;
	}

	async pAddBrewsFromFiles (files) {
		try {
			const lockToken = await this._LOCK.pLock();
			return (await this._pAddBrewsFromFiles({files, lockToken}));
		} catch (e) {
			JqueryUtil.doToast({type: "danger", content: `Failed to load ${this.DISPLAY_NAME} from file(s)! ${VeCt.STR_SEE_CONSOLE}`});
			setTimeout(() => { throw e; });
		} finally {
			this._LOCK.unlock();
		}
		return [];
	}

	async _pAddBrewsFromFiles ({files, lockToken}) {
		const brewDocs = files.map(file => this._getBrewDoc({json: file.json, filename: file.name}));

		const brews = MiscUtil.copyFast(await this._pGetBrewRaw({lockToken}));

		const brewDocsDependencies = await this._pAddBrewDependencies({brewDocs, brewsRaw: brews, lockToken});
		brewDocs.push(...brewDocsDependencies);

		const brewsNxt = this._getNextBrews(brews, brewDocs);
		await this.pSetBrew(brewsNxt, {lockToken});

		return brewDocs;
	}

	async pAddBrewsLazyFinalize ({lockToken} = {}) {
		try {
			lockToken = await this._LOCK.pLock({token: lockToken});
			return (await this._pAddBrewsLazyFinalize_({lockToken}));
		} finally {
			this._LOCK.unlock();
		}
	}

	async _pAddBrewsLazyFinalize_ ({lockToken}) {
		const brews = MiscUtil.copyFast(await this._pGetBrewRaw({lockToken}));
		const brewsNxt = this._getNextBrews(brews, this._addLazy_brewsTemp);
		await this.pSetBrew(brewsNxt, {lockToken});
		this._addLazy_brewsTemp = [];
	}

	async pPullAllBrews ({brews} = {}) {
		try {
			const lockToken = await this._LOCK.pLock();
			return (await this._pPullAllBrews_({lockToken, brews}));
		} finally {
			this._LOCK.unlock();
		}
	}

	async _pPullAllBrews_ ({lockToken, brews}) {
		let cntPulls = 0;

		brews = brews || MiscUtil.copyFast(await this._pGetBrewRaw({lockToken}));
		const brewsNxt = await brews.pMap(async brew => {
			if (!this.isPullable(brew)) return brew;

			const json = await DataUtil.loadRawJSON(brew.head.url, {isBustCache: true});

			const localLastModified = brew.body._meta?.dateLastModified ?? 0;
			const sourceLastModified = json._meta?.dateLastModified ?? 0;

			if (sourceLastModified <= localLastModified) return brew;

			cntPulls++;
			return BrewDoc.fromObject(brew).mutUpdate({json}).toObject();
		});

		if (!cntPulls) return cntPulls;

		await this.pSetBrew(brewsNxt, {lockToken});
		return cntPulls;
	}

	isPullable (brew) { return !brew.head.isEditable && !!brew.head.url; }

	async pPullBrew (brew) {
		try {
			const lockToken = await this._LOCK.pLock();
			return (await this._pPullBrew_({brew, lockToken}));
		} finally {
			this._LOCK.unlock();
		}
	}

	async _pPullBrew_ ({brew, lockToken}) {
		const brews = await this._pGetBrewRaw({lockToken});
		if (!brews?.length) return;

		let isPull = false;
		const brewsNxt = await brews.pMap(async it => {
			if (it.head.docIdLocal !== brew.head.docIdLocal || !this.isPullable(it)) return it;

			const json = await DataUtil.loadRawJSON(it.head.url, {isBustCache: true});

			const localLastModified = it.body._meta?.dateLastModified ?? 0;
			const sourceLastModified = json._meta?.dateLastModified ?? 0;

			if (sourceLastModified <= localLastModified) return it;

			isPull = true;
			return BrewDoc.fromObject(it).mutUpdate({json}).toObject();
		});

		if (!isPull) return isPull;

		await this.pSetBrew(brewsNxt, {lockToken});
		return isPull;
	}

	async pAddBrewFromLoaderTag (ele) {
		const $ele = $(ele);
		if (!$ele.hasClass("rd__wrp-loadbrew--ready")) return; 		let jsonPath = ele.dataset.rdLoaderPath;
		const name = ele.dataset.rdLoaderName;
		const cached = $ele.html();
		const cachedTitle = $ele.title();
		$ele.title("");
		$ele.removeClass("rd__wrp-loadbrew--ready").html(`${name.qq()}<span class="glyphicon glyphicon-refresh rd__loadbrew-icon rd__loadbrew-icon--active"></span>`);

		jsonPath = jsonPath.unescapeQuotes();
		if (!UrlUtil.isFullUrl(jsonPath)) {
			const brewUrl = await this.pGetCustomUrl();
			jsonPath = this.getFileUrl(jsonPath, brewUrl);
		}

		await this.pAddBrewFromUrl(jsonPath);
		$ele.html(`${name.qq()}<span class="glyphicon glyphicon-saved rd__loadbrew-icon"></span>`);
		setTimeout(() => $ele.html(cached).addClass("rd__wrp-loadbrew--ready").title(cachedTitle), 500);
	}

	_getBrewDoc ({json, url = null, filename = null, isLocal = false, isEditable = false}) {
		return BrewDoc.fromValues({
			head: {
				json,
				url,
				filename,
				isLocal,
				isEditable,
			},
			body: json,
		}).toObject();
	}

	_getBrewDocReduced (brewDoc) { return {docIdLocal: brewDoc.head.docIdLocal, _meta: brewDoc.body._meta}; }

	async pDeleteBrews (brews) {
		try {
			const lockToken = await this._LOCK.pLock();
			await this._pDeleteBrews_({brews, lockToken});
		} finally {
			this._LOCK.unlock();
		}
	}

	async _pDeleteBrews_ ({brews, lockToken}) {
		const brewsStored = await this._pGetBrewRaw({lockToken});
		if (!brewsStored?.length) return;

		const idsToDelete = new Set(brews.map(brew => brew.head.docIdLocal));

		const nxtBrews = brewsStored.filter(brew => !idsToDelete.has(brew.head.docIdLocal));
		await this.pSetBrew(nxtBrews, {lockToken});
	}

	async pUpdateBrew (brew) {
		try {
			const lockToken = await this._LOCK.pLock();
			await this._pUpdateBrew_({brew, lockToken});
		} finally {
			this._LOCK.unlock();
		}
	}

	async _pUpdateBrew_ ({brew, lockToken}) {
		const brews = await this._pGetBrewRaw({lockToken});
		if (!brews?.length) return;

		const nxtBrews = brews.map(it => it.head.docIdLocal !== brew.head.docIdLocal ? it : brew);
		await this.pSetBrew(nxtBrews, {lockToken});
	}

			pGetEditableBrewDoc (brew) { throw new Error("Unimplemented"); }
		pGetOrCreateEditableBrewDoc () { throw new Error("Unimplemented"); }
		pSetEditableBrewDoc () { throw new Error("Unimplemented"); }
		pGetEditableBrewEntity (prop, uniqueId, {isDuplicate = false} = {}) { throw new Error("Unimplemented"); }
		pPersistEditableBrewEntity (prop, ent) { throw new Error("Unimplemented"); }
		pRemoveEditableBrewEntity (prop, uniqueId) { throw new Error("Unimplemented"); }
		pAddSource (sourceObj) { throw new Error("Unimplemented"); }
		pEditSource (sourceObj) { throw new Error("Unimplemented"); }
		pIsEditableSourceJson (sourceJson) { throw new Error("Unimplemented"); }
		pMoveOrCopyToEditableBySourceJson (sourceJson) { throw new Error("Unimplemented"); }
		pMoveToEditable ({brews}) { throw new Error("Unimplemented"); }
		pCopyToEditable ({brews}) { throw new Error("Unimplemented"); }
	
		_PAGE_TO_PROPS__SPELLS = [...UrlUtil.PAGE_TO_PROPS[UrlUtil.PG_SPELLS], "spellFluff"];
	_PAGE_TO_PROPS__BESTIARY = ["monster", "legendaryGroup", "monsterFluff"];

	_PAGE_TO_PROPS = {
		[UrlUtil.PG_SPELLS]: this._PAGE_TO_PROPS__SPELLS,
		[UrlUtil.PG_CLASSES]: ["class", "subclass", "classFeature", "subclassFeature"],
		[UrlUtil.PG_BESTIARY]: this._PAGE_TO_PROPS__BESTIARY,
		[UrlUtil.PG_BACKGROUNDS]: ["background"],
		[UrlUtil.PG_FEATS]: ["feat"],
		[UrlUtil.PG_OPT_FEATURES]: ["optionalfeature"],
		[UrlUtil.PG_RACES]: ["race", "raceFluff", "subrace"],
		[UrlUtil.PG_OBJECTS]: ["object"],
		[UrlUtil.PG_TRAPS_HAZARDS]: ["trap", "hazard"],
		[UrlUtil.PG_DEITIES]: ["deity"],
		[UrlUtil.PG_ITEMS]: [...UrlUtil.PAGE_TO_PROPS[UrlUtil.PG_ITEMS], "itemFluff"],
		[UrlUtil.PG_REWARDS]: ["reward"],
		[UrlUtil.PG_PSIONICS]: ["psionic"],
		[UrlUtil.PG_VARIANTRULES]: ["variantrule"],
		[UrlUtil.PG_CONDITIONS_DISEASES]: ["condition", "disease", "status"],
		[UrlUtil.PG_ADVENTURES]: ["adventure", "adventureData"],
		[UrlUtil.PG_BOOKS]: ["book", "bookData"],
		[UrlUtil.PG_TABLES]: ["table", "tableGroup"],
		[UrlUtil.PG_MAKE_BREW]: [
			...this._PAGE_TO_PROPS__SPELLS,
			...this._PAGE_TO_PROPS__BESTIARY,
			"makebrewCreatureTrait",
		],
		[UrlUtil.PG_MANAGE_BREW]: ["*"],
		[UrlUtil.PG_MANAGE_PRERELEASE]: ["*"],
		[UrlUtil.PG_DEMO_RENDER]: ["*"],
		[UrlUtil.PG_VEHICLES]: ["vehicle", "vehicleUpgrade"],
		[UrlUtil.PG_ACTIONS]: ["action"],
		[UrlUtil.PG_CULTS_BOONS]: ["cult", "boon"],
		[UrlUtil.PG_LANGUAGES]: ["language", "languageScript"],
		[UrlUtil.PG_CHAR_CREATION_OPTIONS]: ["charoption"],
		[UrlUtil.PG_RECIPES]: ["recipe"],
		[UrlUtil.PG_CLASS_SUBCLASS_FEATURES]: ["classFeature", "subclassFeature"],
		[UrlUtil.PG_DECKS]: ["card", "deck"],
	};

	getPageProps ({page, isStrict = false, fallback = null} = {}) {
		page = this._getBrewPage(page);

		const out = this._PAGE_TO_PROPS[page];
		if (out) return out;
		if (fallback) return fallback;

		if (isStrict) throw new Error(`No ${this.DISPLAY_NAME} properties defined for category ${page}`);

		return null;
	}

	getPropPages () {
		return Object.entries(this._PAGE_TO_PROPS)
			.map(([page, props]) => [page, props.filter(it => it !== "*")])
			.filter(([, props]) => props.length)
			.map(([page]) => page);
	}

	_getBrewPage (page) {
		return page || (IS_VTT ? this.PAGE_MANAGE : UrlUtil.getCurrentPage());
	}

	getDirProp (dir) {
		switch (dir) {
			case "creature": return "monster";
			case "makebrew": return "makebrewCreatureTrait";
		}
		return dir;
	}

	getPropDisplayName (prop) {
		switch (prop) {
			case "adventure": return "Adventure Contents/Info";
			case "book": return "Book Contents/Info";
		}
		return Parser.getPropDisplayName(prop);
	}
	
		_doCacheMetas () {
		if (this._cache_metas) return;

		this._cache_metas = {};

		(this._getBrewMetas() || [])
			.forEach(({_meta}) => {
				Object.entries(_meta || {})
					.forEach(([prop, val]) => {
						if (!val) return;
						if (typeof val !== "object") return;

						if (val instanceof Array) {
							(this._cache_metas[prop] = this._cache_metas[prop] || []).push(...MiscUtil.copyFast(val));
							return;
						}

						this._cache_metas[prop] = this._cache_metas[prop] || {};
						Object.assign(this._cache_metas[prop], MiscUtil.copyFast(val));
					});
			});

				this._cache_metas["_sources"] = (this._getBrewMetas() || [])
			.mergeMap(({_meta}) => {
				return (_meta?.sources || [])
					.mergeMap(src => ({[(src.json || "").toLowerCase()]: MiscUtil.copyFast(src)}));
			});
	}

	hasSourceJson (source) {
		if (!source) return false;
		source = source.toLowerCase();
		return !!this.getMetaLookup("_sources")[source];
	}

	sourceJsonToFull (source) {
		if (!source) return "";
		source = source.toLowerCase();
		return this.getMetaLookup("_sources")[source]?.full || source;
	}

	sourceJsonToAbv (source) {
		if (!source) return "";
		source = source.toLowerCase();
		return this.getMetaLookup("_sources")[source]?.abbreviation || source;
	}

	sourceJsonToDate (source) {
		if (!source) return "";
		source = source.toLowerCase();
		return this.getMetaLookup("_sources")[source]?.dateReleased || "1970-01-01";
	}

	sourceJsonToSource (source) {
		if (!source) return null;
		source = source.toLowerCase();
		return this.getMetaLookup("_sources")[source];
	}

	sourceJsonToStyle (source) {
		const stylePart = this.sourceJsonToStylePart(source);
		if (!stylePart) return stylePart;
		return `style="${stylePart}"`;
	}

	sourceToStyle (source) {
		const stylePart = this.sourceToStylePart(source);
		if (!stylePart) return stylePart;
		return `style="${stylePart}"`;
	}

	sourceJsonToStylePart (source) {
		if (!source) return "";
		const color = this.sourceJsonToColor(source);
		if (color) return this._getColorStylePart(color);
		return "";
	}

	sourceToStylePart (source) {
		if (!source) return "";
		const color = this.sourceToColor(source);
		if (color) return this._getColorStylePart(color);
		return "";
	}

	_getColorStylePart (color) { return `color: #${color} !important; border-color: #${color} !important; text-decoration-color: #${color} !important;`; }

	sourceJsonToColor (source) {
		if (!source) return "";
		source = source.toLowerCase();
		if (!this.getMetaLookup("_sources")[source]?.color) return "";
		return BrewUtilShared$1.getValidColor(this.getMetaLookup("_sources")[source].color);
	}

	sourceToColor (source) {
		if (!source?.color) return "";
		return BrewUtilShared$1.getValidColor(source.color);
	}

	getSources () {
		this._doCacheMetas();
		return Object.values(this._cache_metas["_sources"]);
	}
	
		getMetaLookup (type) {
		if (!type) return null;
		this._doCacheMetas();
		return this._cache_metas[type];
	}
	
		getMergedData (data, homebrew) {
		const out = {};
		Object.entries(data)
			.forEach(([prop, val]) => {
				if (!homebrew[prop]) {
					out[prop] = [...val];
					return;
				}

				if (!(homebrew[prop] instanceof Array)) throw new Error(`${this.DISPLAY_NAME.uppercaseFirst()} was not array!`);
				if (!(val instanceof Array)) throw new Error(`Data was not array!`);
				out[prop] = [...val, ...homebrew[prop]];
			});

		return out;
	}

			async pGetSearchIndex ({id = 0} = {}) {
		const indexer = new Omnidexer(id);

		const brew = await this.pGetBrewProcessed();

				await [...Omnidexer.TO_INDEX__FROM_INDEX_JSON, ...Omnidexer.TO_INDEX]
			.pSerialAwaitMap(async arbiter => {
				if (arbiter.isSkipBrew) return;
				if (!brew[arbiter.brewProp || arbiter.listProp]?.length) return;

				if (arbiter.pFnPreProcBrew) {
					const toProc = await arbiter.pFnPreProcBrew.bind(arbiter)(brew);
					await indexer.pAddToIndex(arbiter, toProc);
					return;
				}

				await indexer.pAddToIndex(arbiter, brew);
			});

		return Omnidexer.decompressIndex(indexer.getIndex());
	}

	async pGetAdditionalSearchIndices (highestId, addiProp) {
		const indexer = new Omnidexer(highestId + 1);

		const brew = await this.pGetBrewProcessed();

		await [...Omnidexer.TO_INDEX__FROM_INDEX_JSON, ...Omnidexer.TO_INDEX]
			.filter(it => it.additionalIndexes && (brew[it.listProp] || []).length)
			.pMap(it => {
				Object.entries(it.additionalIndexes)
					.filter(([prop]) => prop === addiProp)
					.pMap(async ([, pGetIndex]) => {
						const toIndex = await pGetIndex(indexer, {[it.listProp]: brew[it.listProp]});
						toIndex.forEach(add => indexer.pushToIndex(add));
					});
			});

		return Omnidexer.decompressIndex(indexer.getIndex());
	}

	async pGetAlternateSearchIndices (highestId, altProp) {
		const indexer = new Omnidexer(highestId + 1);

		const brew = await this.pGetBrewProcessed();

		await [...Omnidexer.TO_INDEX__FROM_INDEX_JSON, ...Omnidexer.TO_INDEX]
			.filter(ti => ti.alternateIndexes && (brew[ti.listProp] || []).length)
			.pSerialAwaitMap(async arbiter => {
				await Object.keys(arbiter.alternateIndexes)
					.filter(prop => prop === altProp)
					.pSerialAwaitMap(async prop => {
						await indexer.pAddToIndex(arbiter, brew, {alt: arbiter.alternateIndexes[prop]});
					});
			});

		return Omnidexer.decompressIndex(indexer.getIndex());
	}
	}

class _BrewUtil2 extends _BrewUtil2Base {
	_STORAGE_KEY_LEGACY = "HOMEBREW_STORAGE";
	_STORAGE_KEY_LEGACY_META = "HOMEBREW_META_STORAGE";

		_STORAGE_KEY = "HOMEBREW_2_STORAGE";
	_STORAGE_KEY_META = "HOMEBREW_2_STORAGE_METAS";

	_STORAGE_KEY_CUSTOM_URL = "HOMEBREW_CUSTOM_REPO_URL";
	_STORAGE_KEY_MIGRATION_VERSION = "HOMEBREW_2_STORAGE_MIGRATION";

	_VERSION = 2;

	_PATH_LOCAL_DIR = "homebrew";
	_PATH_LOCAL_INDEX = VeCt.JSON_BREW_INDEX;

	IS_EDITABLE = true;
	PAGE_MANAGE = UrlUtil.PG_MANAGE_BREW;
	URL_REPO_DEFAULT = VeCt.URL_BREW;
	DISPLAY_NAME = "homebrew";
	DISPLAY_NAME_PLURAL = "homebrews";
	DEFAULT_AUTHOR = "";
	STYLE_BTN = "btn-info";

	
	_pInit_doBindDragDrop () {
		document.body.addEventListener("drop", async evt => {
			if (EventUtil.isInInput(evt)) return;

			evt.stopPropagation();
			evt.preventDefault();

			const files = evt.dataTransfer?.files;
			if (!files?.length) return;

			const pFiles = [...files].map((file, i) => {
				if (!/\.json$/i.test(file.name)) return null;

				return new Promise(resolve => {
					const reader = new FileReader();
					reader.onload = () => {
						let json;
						try {
							json = JSON.parse(reader.result);
						} catch (ignored) {
							return resolve(null);
						}

						resolve({name: file.name, json});
					};

					reader.readAsText(files[i]);
				});
			});

			const fileMetas = (await Promise.allSettled(pFiles))
				.filter(({status}) => status === "fulfilled")
				.map(({value}) => value)
				.filter(Boolean);

			await this.pAddBrewsFromFiles(fileMetas);

			if (this.isReloadRequired()) location.reload();
		});

		document.body.addEventListener("dragover", evt => {
			if (EventUtil.isInInput(evt)) return;

			evt.stopPropagation();
			evt.preventDefault();
		});
	}

	
	async _pGetSourceIndex (urlRoot) { return DataUtil.brew.pLoadSourceIndex(urlRoot); }

	getFileUrl (path, urlRoot) { return DataUtil.brew.getFileUrl(path, urlRoot); }

	pLoadTimestamps (brewIndex, src, urlRoot) { return DataUtil.brew.pLoadTimestamps(urlRoot); }

	pLoadPropIndex (brewIndex, src, urlRoot) { return DataUtil.brew.pLoadPropIndex(urlRoot); }

	pLoadMetaIndex (brewIndex, src, urlRoot) { return DataUtil.brew.pLoadMetaIndex(urlRoot); }

	
		async pGetEditableBrewDoc () {
		return this._findEditableBrewDoc({brewRaw: await this._pGetBrewRaw()});
	}

	_findEditableBrewDoc ({brewRaw}) {
		return brewRaw.find(it => it.head.isEditable);
	}

	async pGetOrCreateEditableBrewDoc () {
		const existing = await this.pGetEditableBrewDoc();
		if (existing) return existing;

		const brew = this._getNewEditableBrewDoc();
		const brews = [...MiscUtil.copyFast(await this._pGetBrewRaw()), brew];
		await this.pSetBrew(brews);

		return brew;
	}

	async pSetEditableBrewDoc (brew) {
		if (!brew?.head?.docIdLocal || !brew?.body) throw new Error(`Invalid editable brew document!`); 		await this.pUpdateBrew(brew);
	}

		async pGetEditableBrewEntity (prop, uniqueId, {isDuplicate = false} = {}) {
		if (!uniqueId) throw new Error(`A "uniqueId" must be provided!`);

		const brew = await this.pGetOrCreateEditableBrewDoc();

		const out = (brew.body?.[prop] || []).find(it => it.uniqueId === uniqueId);
		if (!out || !isDuplicate) return out;

		if (isDuplicate) out.uniqueId = CryptUtil.uid();

		return out;
	}

	async pPersistEditableBrewEntity (prop, ent) {
		if (!ent.uniqueId) throw new Error(`Entity did not have a "uniqueId"!`);

		const brew = await this.pGetOrCreateEditableBrewDoc();

		const ixExisting = (brew.body?.[prop] || []).findIndex(it => it.uniqueId === ent.uniqueId);
		if (!~ixExisting) {
			const nxt = MiscUtil.copyFast(brew);
			MiscUtil.getOrSet(nxt.body, prop, []).push(ent);

			await this.pUpdateBrew(nxt);

			return;
		}

		const nxt = MiscUtil.copyFast(brew);
		nxt.body[prop][ixExisting] = ent;

		await this.pUpdateBrew(nxt);
	}

	async pRemoveEditableBrewEntity (prop, uniqueId) {
		if (!uniqueId) throw new Error(`A "uniqueId" must be provided!`);

		const brew = await this.pGetOrCreateEditableBrewDoc();

		if (!brew.body?.[prop]?.length) return;

		const nxt = MiscUtil.copyFast(brew);
		nxt.body[prop] = nxt.body[prop].filter(it => it.uniqueId !== uniqueId);

		if (nxt.body[prop].length === brew.body[prop]) return; 
		await this.pUpdateBrew(nxt);
	}

	async pAddSource (sourceObj) {
		const existing = await this.pGetEditableBrewDoc();

		if (existing) {
			const nxt = MiscUtil.copyFast(existing);
			const sources = MiscUtil.getOrSet(nxt.body, "_meta", "sources", []);
			sources.push(sourceObj);

			await this.pUpdateBrew(nxt);

			return;
		}

		const json = {_meta: {sources: [sourceObj]}};
		const brew = this._getBrewDoc({json, isEditable: true});
		const brews = [...MiscUtil.copyFast(await this._pGetBrewRaw()), brew];
		await this.pSetBrew(brews);
	}

	async pEditSource (sourceObj) {
		const existing = await this.pGetEditableBrewDoc();
		if (!existing) throw new Error(`Editable brew document does not exist!`);

		const nxt = MiscUtil.copyFast(existing);
		const sources = MiscUtil.get(nxt.body, "_meta", "sources");
		if (!sources) throw new Error(`Source "${sourceObj.json}" does not exist in editable brew document!`);

		const existingSourceObj = sources.find(it => it.json === sourceObj.json);
		if (!existingSourceObj) throw new Error(`Source "${sourceObj.json}" does not exist in editable brew document!`);
		Object.assign(existingSourceObj, sourceObj);

		await this.pUpdateBrew(nxt);
	}

	async pIsEditableSourceJson (sourceJson) {
		const brew = await this.pGetEditableBrewDoc();
		if (!brew) return false;

		const sources = MiscUtil.get(brew.body, "_meta", "sources") || [];
		return sources.some(it => it.json === sourceJson);
	}

		async pMoveOrCopyToEditableBySourceJson (sourceJson) {
		if (await this.pIsEditableSourceJson(sourceJson)) return;

				const brews = (await this._pGetBrewRaw()).filter(brew => (brew.body._meta?.sources || []).some(src => src.json === sourceJson));
		const brewsLocal = (await this._pGetBrew_pGetLocalBrew()).filter(brew => (brew.body._meta?.sources || []).some(src => src.json === sourceJson));

				let brew = brews.find(brew => BrewDoc.isOperationPermitted_moveToEditable({brew}));
		if (!brew) brew = brewsLocal.find(brew => BrewDoc.isOperationPermitted_moveToEditable({brew, isAllowLocal: true}));

		if (!brew) return;

		if (brew.head.isLocal) return this.pCopyToEditable({brews: [brew]});

		return this.pMoveToEditable({brews: [brew]});
	}

	async pMoveToEditable ({brews}) {
		const out = await this.pCopyToEditable({brews});
		await this.pDeleteBrews(brews);
		return out;
	}

	async pCopyToEditable ({brews}) {
		const brewEditable = await this.pGetOrCreateEditableBrewDoc();

		const cpyBrewEditableDoc = BrewDoc.fromObject(brewEditable, {isCopy: true});
		brews.forEach((brew, i) => cpyBrewEditableDoc.mutMerge({json: brew.body, isLazy: i !== brews.length - 1}));

		await this.pSetEditableBrewDoc(cpyBrewEditableDoc.toObject());

		return cpyBrewEditableDoc;
	}
	}

class _PrereleaseUtil extends _BrewUtil2Base {
	_STORAGE_KEY_LEGACY = null;
	_STORAGE_KEY_LEGACY_META = null;

	_STORAGE_KEY = "PRERELEASE_STORAGE";
	_STORAGE_KEY_META = "PRERELEASE_META_STORAGE";

	_STORAGE_KEY_CUSTOM_URL = "PRERELEASE_CUSTOM_REPO_URL";
	_STORAGE_KEY_MIGRATION_VERSION = "PRERELEASE_STORAGE_MIGRATION";

	_PATH_LOCAL_DIR = "prerelease";
	_PATH_LOCAL_INDEX = VeCt.JSON_PRERELEASE_INDEX;

	_VERSION = 1;

	IS_EDITABLE = false;
	PAGE_MANAGE = UrlUtil.PG_MANAGE_PRERELEASE;
	URL_REPO_DEFAULT = VeCt.URL_PRERELEASE;
	DISPLAY_NAME = "prerelease content";
	DISPLAY_NAME_PLURAL = "prereleases";
	DEFAULT_AUTHOR = "Wizards of the Coast";
	STYLE_BTN = "btn-primary";

	
	_pInit_doBindDragDrop () {  }

	
	async _pGetSourceIndex (urlRoot) { return DataUtil.prerelease.pLoadSourceIndex(urlRoot); }

	getFileUrl (path, urlRoot) { return DataUtil.prerelease.getFileUrl(path, urlRoot); }

	pLoadTimestamps (brewIndex, src, urlRoot) { return DataUtil.prerelease.pLoadTimestamps(urlRoot); }

	pLoadPropIndex (brewIndex, src, urlRoot) { return DataUtil.prerelease.pLoadPropIndex(urlRoot); }

	pLoadMetaIndex (brewIndex, src, urlRoot) { return DataUtil.prerelease.pLoadMetaIndex(urlRoot); }

	
	
	pGetEditableBrewDoc (brew) { return super.pGetEditableBrewDoc(brew); }
	pGetOrCreateEditableBrewDoc () { return super.pGetOrCreateEditableBrewDoc(); }
	pSetEditableBrewDoc () { return super.pSetEditableBrewDoc(); }
	pGetEditableBrewEntity (prop, uniqueId, {isDuplicate = false} = {}) { return super.pGetEditableBrewEntity(prop, uniqueId, {isDuplicate}); }
	pPersistEditableBrewEntity (prop, ent) { return super.pPersistEditableBrewEntity(prop, ent); }
	pRemoveEditableBrewEntity (prop, uniqueId) { return super.pRemoveEditableBrewEntity(prop, uniqueId); }
	pAddSource (sourceObj) { return super.pAddSource(sourceObj); }
	pEditSource (sourceObj) { return super.pEditSource(sourceObj); }
	pIsEditableSourceJson (sourceJson) { return super.pIsEditableSourceJson(sourceJson); }
	pMoveOrCopyToEditableBySourceJson (sourceJson) { return super.pMoveOrCopyToEditableBySourceJson(sourceJson); }
	pMoveToEditable ({brews}) { return super.pMoveToEditable({brews}); }
	pCopyToEditable ({brews}) { return super.pCopyToEditable({brews}); }

	}

globalThis.BrewUtil2 = new _BrewUtil2();
globalThis.PrereleaseUtil = new _PrereleaseUtil();

class ManageBrewUi {
	static _RenderState = class {
		constructor () {
			this.$stgBrewList = null;
			this.list = null;
			this.listSelectClickHandler = null;
			this.brews = [];
			this.menuListMass = null;
			this.rowMetas = [];
		}
	};

	constructor ({brewUtil, isModal = false} = {}) {
		this._brewUtil = brewUtil;
		this._isModal = isModal;
	}

	static bindBtnOpen ($btn, {brewUtil = null} = {}) {
		brewUtil = brewUtil || BrewUtil2;

		$btn.click(evt => {
			if (evt.shiftKey) return window.location = brewUtil.PAGE_MANAGE;
			return this.pDoManageBrew({brewUtil});
		});
	}

	static async pDoManageBrew ({brewUtil = null} = {}) {
		brewUtil = brewUtil || BrewUtil2;

		const ui = new this({isModal: true, brewUtil});
		const rdState = new this._RenderState();
		const {$modalInner} = UiUtil.getShowModal({
			isHeight100: true,
			isWidth100: true,
			title: `Manage ${brewUtil.DISPLAY_NAME.toTitleCase()}`,
			isUncappedHeight: true,
			$titleSplit: $$`<div class="ve-flex-v-center btn-group">
				${ui._$getBtnPullAll(rdState)}
				${ui._$getBtnDeleteAll(rdState)}
			</div>`,
			isHeaderBorder: true,
			cbClose: () => {
				if (!brewUtil.isReloadRequired()) return;

				window.location.hash = "";
				location.reload();
			},
		});
		await ui.pRender($modalInner, {rdState});
	}

	_$getBtnDeleteAll (rdState) {
		return $(`<button class="btn btn-danger">Delete All</button>`)
			.addClass(this._isModal ? "btn-xs" : "btn-sm")
			.click(async () => {
				if (!await InputUiUtil.pGetUserBoolean({title: `Delete All ${this._brewUtil.DISPLAY_NAME.toTitleCase()}`, htmlDescription: "Are you sure?", textYes: "Yes", textNo: "Cancel"})) return;

				await this._pDoDeleteAll(rdState);
			});
	}

	_$getBtnPullAll (rdState) {
		const $btn = $(`<button class="btn btn-default">Update All</button>`)
			.addClass(this._isModal ? "btn-xs w-70p" : "btn-sm w-80p")
			.click(async () => {
				const cachedHtml = $btn.html();

				try {
					$btn.text(`Updating...`).prop("disabled", true);
					await this._pDoPullAll({rdState});
				} catch (e) {
					$btn.text(`Failed!`);
					setTimeout(() => $btn.html(cachedHtml).prop("disabled", false), VeCt.DUR_INLINE_NOTIFY);
					throw e;
				}

				$btn.text(`Done!`);
				setTimeout(() => $btn.html(cachedHtml).prop("disabled", false), VeCt.DUR_INLINE_NOTIFY);
			});
		return $btn;
	}

	async _pDoDeleteAll (rdState) {
		await this._brewUtil.pSetBrew([]);

		rdState.list.removeAllItems();
		rdState.list.update();
	}

	async _pDoPullAll ({rdState, brews = null}) {
		if (brews && !brews.length) return;

		let cntPulls;
		try {
			cntPulls = await this._brewUtil.pPullAllBrews({brews});
		} catch (e) {
			JqueryUtil.doToast({content: `Update failed! ${VeCt.STR_SEE_CONSOLE}`, type: "danger"});
			throw e;
		}
		if (!cntPulls) return JqueryUtil.doToast(`Update complete! No ${this._brewUtil.DISPLAY_NAME} was updated.`);

		await this._pRender_pBrewList(rdState);
		JqueryUtil.doToast(`Update complete! ${cntPulls} ${cntPulls === 1 ? `${this._brewUtil.DISPLAY_NAME} was` : `${this._brewUtil.DISPLAY_NAME_PLURAL} were`} updated.`);
	}

	async pRender ($wrp, {rdState = null} = {}) {
		rdState = rdState || new this.constructor._RenderState();

		rdState.$stgBrewList = $(`<div class="manbrew__current_brew ve-flex-col h-100 mt-1"></div>`);

		await this._pRender_pBrewList(rdState);

		const $btnLoadFromFile = $(`<button class="btn btn-default btn-sm">Load from File</button>`)
			.click(() => this._pHandleClick_btnLoadFromFile(rdState));

		const $btnLoadFromUrl = $(`<button class="btn btn-default btn-sm">Load from URL</button>`)
			.click(() => this._pHandleClick_btnLoadFromUrl(rdState));

		const $btnGet = $(`<button class="btn ${this._brewUtil.STYLE_BTN} btn-sm">Get ${this._brewUtil.DISPLAY_NAME.toTitleCase()}</button>`)
			.click(() => this._pHandleClick_btnGetBrew(rdState));

		const $btnCustomUrl = $(`<button class="btn ${this._brewUtil.STYLE_BTN} btn-sm px-2" title="Set Custom Repository URL"><span class="glyphicon glyphicon-cog"></span></button>`)
			.click(() => this._pHandleClick_btnSetCustomRepo());

		const $btnPullAll = this._isModal ? null : this._$getBtnPullAll(rdState);
		const $btnDeleteAll = this._isModal ? null : this._$getBtnDeleteAll(rdState);

		const $wrpBtns = $$`<div class="ve-flex-v-center no-shrink mobile__ve-flex-col">
			<div class="ve-flex-v-center mobile__mb-2">
				<div class="ve-flex-v-center btn-group mr-2">
					${$btnGet}
					${$btnCustomUrl}
				</div>
				<div class="ve-flex-v-center btn-group mr-2">
					${$btnLoadFromFile}
					${$btnLoadFromUrl}
				</div>
			</div>
			<div class="ve-flex-v-center">
				<a href="${this._brewUtil.URL_REPO_DEFAULT}" class="ve-flex-v-center" target="_blank" rel="noopener noreferrer"><button class="btn btn-default btn-sm mr-2">Browse Source Repository</button></a>

				<div class="ve-flex-v-center btn-group">
					${$btnPullAll}
					${$btnDeleteAll}
				</div>
			</div>
		</div>`;

		if (this._isModal) {
			$$($wrp)`
			${rdState.$stgBrewList}
			${$wrpBtns.addClass("mb-2")}`;
		} else {
			$$($wrp)`
			${$wrpBtns.addClass("mb-3")}
			${rdState.$stgBrewList}`;
		}
	}

	async _pHandleClick_btnLoadFromFile (rdState) {
		const {files, errors} = await DataUtil.pUserUpload({isMultiple: true});

		DataUtil.doHandleFileLoadErrorsGeneric(errors);

		await this._brewUtil.pAddBrewsFromFiles(files);
		await this._pRender_pBrewList(rdState);
	}

	async _pHandleClick_btnLoadFromUrl (rdState) {
		const enteredUrl = await InputUiUtil.pGetUserString({title: `${this._brewUtil.DISPLAY_NAME.toTitleCase()} URL`});
		if (!enteredUrl || !enteredUrl.trim()) return;

		const parsedUrl = this.constructor._getParsedCustomUrl(enteredUrl);
		if (!parsedUrl) {
			return JqueryUtil.doToast({
				content: `The URL was not valid!`,
				type: "danger",
			});
		}

		await this._brewUtil.pAddBrewFromUrl(parsedUrl.href);
		await this._pRender_pBrewList(rdState);
	}

	static _getParsedCustomUrl (enteredUrl) {
		try {
			return new URL(enteredUrl);
		} catch (e) {
			return null;
		}
	}

	async _pHandleClick_btnGetBrew (rdState) {
		await GetBrewUi.pDoGetBrew({brewUtil: this._brewUtil, isModal: this._isModal});
		await this._pRender_pBrewList(rdState);
	}

	async _pHandleClick_btnSetCustomRepo () {
		const customBrewUtl = await this._brewUtil.pGetCustomUrl();

		const nxtUrl = await InputUiUtil.pGetUserString({
			title: `${this._brewUtil.DISPLAY_NAME.toTitleCase()} Repository URL`,
			$elePre: $(`<div>
				<p>Leave blank to use the <a href="${this._brewUtil.URL_REPO_DEFAULT}" rel="noopener noreferrer" target="_blank">default ${this._brewUtil.DISPLAY_NAME} repo</a>.</p>
				<div>Note that for GitHub URLs, the <code>raw.</code> URL must be used. For example, <code>${this._brewUtil.URL_REPO_DEFAULT.replace(/TheGiddyLimit/g, "YourUsernameHere")}</code></div>
				<hr class="hr-3">
			</div>`),
			default: customBrewUtl,
		});
		if (nxtUrl == null) return;

		await this._brewUtil.pSetCustomUrl(nxtUrl);
	}

	async _pRender_pBrewList (rdState) {
		rdState.$stgBrewList.empty();
		rdState.rowMetas.splice(0, rdState.rowMetas.length)
			.forEach(({menu}) => ContextUtil.deleteMenu(menu));

		const $btnMass = $(`<button class="btn btn-default">Mass...</button>`)
			.click(evt => this._pHandleClick_btnListMass({evt, rdState}));
		const $iptSearch = $(`<input type="search" class="search manbrew__search form-control" placeholder="Search ${this._brewUtil.DISPLAY_NAME}...">`);
		const $cbAll = $(`<input type="checkbox">`);
		const $wrpList = $(`<div class="list-display-only max-h-unset smooth-scroll overflow-y-auto h-100 brew-list brew-list--target manbrew__list relative ve-flex-col w-100 mb-3"></div>`);

		rdState.list = new List({
			$iptSearch,
			$wrpList,
			isUseJquery: true,
			isFuzzy: true,
			sortByInitial: rdState.list ? rdState.list.sortBy : undefined,
			sortDirInitial: rdState.list ? rdState.list.sortDir : undefined,
		});

		const $wrpBtnsSort = $$`<div class="filtertools manbrew__filtertools btn-group input-group input-group--bottom ve-flex no-shrink">
			<label class="col-0-5 pr-0 btn btn-default btn-xs ve-flex-vh-center">${$cbAll}</label>
			<button class="col-1 btn btn-default btn-xs" disabled>Type</button>
			<button class="col-3 btn btn-default btn-xs" data-sort="source">Source</button>
			<button class="col-3 btn btn-default btn-xs" data-sort="authors">Authors</button>
			<button class="col-3 btn btn-default btn-xs" disabled>Origin</button>
			<button class="col-1-5 btn btn-default btn-xs ve-grow" disabled>&nbsp;</button>
		</div>`;

		$$(rdState.$stgBrewList)`
		<div class="ve-flex-col h-100">
			<div class="input-group ve-flex-vh-center">
				${$btnMass}
				${$iptSearch}
			</div>
			${$wrpBtnsSort}
			<div class="ve-flex w-100 h-100 overflow-y-auto relative">${$wrpList}</div>
		</div>`;

		rdState.listSelectClickHandler = new ListSelectClickHandler({list: rdState.list});
		rdState.listSelectClickHandler.bindSelectAllCheckbox($cbAll);
		SortUtil.initBtnSortHandlers($wrpBtnsSort, rdState.list);

		rdState.brews = (await this._brewUtil.pGetBrew()).map(brew => this._pRender_getProcBrew(brew));

		rdState.brews.forEach((brew, ix) => {
			const meta = this._pRender_getLoadedRowMeta(rdState, brew, ix);
			rdState.rowMetas.push(meta);
			rdState.list.addItem(meta.listItem);
		});

		rdState.list.init();
		$iptSearch.focus();
	}

	get _LBL_LIST_UPDATE () { return "Update"; }
	get _LBL_LIST_MANAGE_CONTENTS () { return "Manage Contents"; }
	get _LBL_LIST_EXPORT () { return "Export"; }
	get _LBL_LIST_VIEW_JSON () { return "View JSON"; }
	get _LBL_LIST_DELETE () { return "Delete"; }
	get _LBL_LIST_MOVE_TO_EDITABLE () { return `Move to Editable ${this._brewUtil.DISPLAY_NAME.toTitleCase()} Document`; }

	_initListMassMenu ({rdState}) {
		if (rdState.menuListMass) return;

		const getSelBrews = ({fnFilter = null} = {}) => {
			const brews = rdState.list.items
				.filter(li => li.data.cbSel.checked)
				.map(li => rdState.brews[li.ix])
				.filter(brew => fnFilter ? fnFilter(brew) : true);

			if (!brews.length) JqueryUtil.doToast({content: `Please select some suitable ${this._brewUtil.DISPLAY_NAME_PLURAL} first!`, type: "warning"});

			return brews;
		};

		rdState.menuListMass = ContextUtil.getMenu([
			new ContextUtil.Action(
				this._LBL_LIST_UPDATE,
				async () => this._pDoPullAll({
					rdState,
					brews: getSelBrews({
						fnFilter: brew => this._isBrewOperationPermitted_update(brew),
					}),
				}),
			),
			new ContextUtil.Action(
				this._LBL_LIST_EXPORT,
				async () => {
					for (const brew of getSelBrews()) await this._pRender_pDoDownloadBrew({brew});
				},
			),
			this._brewUtil.IS_EDITABLE
				? new ContextUtil.Action(
					this._LBL_LIST_MOVE_TO_EDITABLE,
					async () => this._pRender_pDoMoveToEditable({
						rdState,
						brews: getSelBrews({
							fnFilter: brew => this._isBrewOperationPermitted_moveToEditable(brew),
						}),
					}),
				)
				: null,
			new ContextUtil.Action(
				this._LBL_LIST_DELETE,
				async () => this._pRender_pDoDelete({
					rdState,
					brews: getSelBrews({
						fnFilter: brew => this._isBrewOperationPermitted_delete(brew),
					}),
				}),
			),
		].filter(Boolean));
	}

	_isBrewOperationPermitted_update (brew) { return !brew.head.isEditable && this._brewUtil.isPullable(brew); }
	_isBrewOperationPermitted_moveToEditable (brew) { return BrewDoc.isOperationPermitted_moveToEditable({brew}); }
	_isBrewOperationPermitted_delete (brew) { return !brew.head.isLocal; }

	async _pHandleClick_btnListMass ({evt, rdState}) {
		this._initListMassMenu({rdState});
		await ContextUtil.pOpenMenu(evt, rdState.menuListMass);
	}

	static _getBrewName (brew) {
		const sources = brew.body._meta?.sources || [];

		return sources
			.map(brewSource => brewSource.full || _BrewInternalUtil.SOURCE_UNKNOWN_FULL)
			.sort(SortUtil.ascSortLower)
			.join(", ");
	}

	_pRender_getLoadedRowMeta (rdState, brew, ix) {
		const sources = brew.body._meta?.sources || [];

		const rowsSubMetas = sources
			.map(brewSource => {
				const hasConverters = !!brewSource.convertedBy?.length;
				const btnConvertedBy = e_({
					tag: "button",
					clazz: `btn btn-xxs btn-default ${!hasConverters ? "disabled" : ""}`,
					title: hasConverters ? `Converted by: ${brewSource.convertedBy.join(", ").qq()}` : "(No conversion credit given)",
					children: [
						e_({tag: "span", clazz: "mobile__hidden", text: "View Converters"}),
						e_({tag: "span", clazz: "mobile__visible", text: "Convs.", title: "View Converters"}),
					],
					click: () => {
						if (!hasConverters) return;
						const {$modalInner} = UiUtil.getShowModal({
							title: `Converted By:${brewSource.convertedBy.length === 1 ? ` ${brewSource.convertedBy.join("")}` : ""}`,
							isMinHeight0: true,
						});

						if (brewSource.convertedBy.length === 1) return;
						$modalInner.append(`<ul>${brewSource.convertedBy.map(it => `<li>${it.qq()}</li>`).join("")}</ul>`);
					},
				});

				const authorsFull = [(brewSource.authors || [])].flat(2).join(", ");

				const lnkUrl = brewSource.url
					? e_({
						tag: "a",
						clazz: "col-2 text-center",
						href: brewSource.url,
						attrs: {
							target: "_blank",
							rel: "noopener noreferrer",
						},
						text: "View Source",
					})
					: e_({
						tag: "span",
						clazz: "col-2 text-center",
					});

				const eleRow = e_({
					tag: "div",
					clazz: `w-100 ve-flex-v-center`,
					children: [
						e_({
							tag: "span",
							clazz: `col-4 manbrew__source px-1`,
							text: brewSource.full,
						}),
						e_({
							tag: "span",
							clazz: `col-4 px-1`,
							text: authorsFull,
						}),
						lnkUrl,
						e_({
							tag: "div",
							clazz: `ve-flex-vh-center ve-grow`,
							children: [
								btnConvertedBy,
							],
						}),
					],
				});

				return {
					eleRow,
					authorsFull,
					name: brewSource.full || _BrewInternalUtil.SOURCE_UNKNOWN_FULL,
					abbreviation: brewSource.abbreviation || _BrewInternalUtil.SOURCE_UNKNOWN_ABBREVIATION,
				};
			})
			.sort((a, b) => SortUtil.ascSortLower(a.name, b.name));

		const brewName = this.constructor._getBrewName(brew);

				const btnPull = this._pRender_getBtnPull({rdState, brew});
		const btnEdit = this._pRender_getBtnEdit({rdState, brew});
		const btnPullEditPlaceholder = (btnPull || btnEdit) ? null : this.constructor._pRender_getBtnPlaceholder();
		
		const btnDownload = e_({
			tag: "button",
			clazz: `btn btn-default btn-xs mobile__hidden w-24p`,
			title: this._LBL_LIST_EXPORT,
			children: [
				e_({
					tag: "span",
					clazz: "glyphicon glyphicon-download manbrew-row__icn-btn",
				}),
			],
			click: () => this._pRender_pDoDownloadBrew({brew, brewName}),
		});

		const btnViewJson = e_({
			tag: "button",
			clazz: `btn btn-default btn-xs mobile-ish__hidden w-24p`,
			title: `${this._LBL_LIST_VIEW_JSON}: ${this.constructor._getBrewJsonTitle({brew, brewName})}`,
			children: [
				e_({
					tag: "span",
					clazz: "ve-bolder code relative manbrew-row__icn-btn--text",
					text: "{}",
				}),
			],
			click: evt => this._pRender_doViewBrew({evt, brew, brewName}),
		});

		const btnOpenMenu = e_({
			tag: "button",
			clazz: `btn btn-default btn-xs w-24p`,
			title: "Menu",
			children: [
				e_({
					tag: "span",
					clazz: "glyphicon glyphicon-option-vertical manbrew-row__icn-btn",
				}),
			],
			click: evt => this._pRender_pDoOpenBrewMenu({evt, rdState, brew, brewName, rowMeta}),
		});

		const btnDelete = this._isBrewOperationPermitted_delete(brew) ? e_({
			tag: "button",
			clazz: `btn btn-danger btn-xs mobile__hidden w-24p`,
			title: this._LBL_LIST_DELETE,
			children: [
				e_({
					tag: "span",
					clazz: "glyphicon glyphicon-trash manbrew-row__icn-btn",
				}),
			],
			click: () => this._pRender_pDoDelete({rdState, brews: [brew]}),
		}) : this.constructor._pRender_getBtnPlaceholder();

				const elesSub = rowsSubMetas.map(it => it.eleRow);
		for (let i = rowsSubMetas.length - 1; i > 0; --i) elesSub.splice(i, 0, e_({tag: "hr", clazz: `hr-1 hr--dotted`}));

		const cbSel = e_({
			tag: "input",
			clazz: "no-events",
			type: "checkbox",
		});

		const ptCategory = brew.head.isLocal
			? {short: `Local`, title: `Local Document`}
			: brew.head.isEditable
				? {short: `Editable`, title: `Editable Document`}
				: {short: `Standard`, title: `Standard Document`};

		const eleLi = e_({
			tag: "div",
			clazz: `manbrew__row ve-flex-v-center lst__row lst--border lst__row-inner no-shrink py-1 no-select`,
			children: [
				e_({
					tag: "label",
					clazz: `col-0-5 ve-flex-vh-center ve-self-flex-stretch`,
					children: [cbSel],
				}),
				e_({
					tag: "div",
					clazz: `col-1 text-center italic mobile__text-clip-ellipsis`,
					title: ptCategory.title,
					text: ptCategory.short,
				}),
				e_({
					tag: "div",
					clazz: `col-9 ve-flex-col`,
					children: elesSub,
				}),
				e_({
					tag: "div",
					clazz: `col-1-5 btn-group ve-flex-vh-center`,
					children: [
						btnPull,
						btnEdit,
						btnPullEditPlaceholder,
						btnDownload,
						btnViewJson,
						btnOpenMenu,
						btnDelete,
					],
				}),
			],
		});

		const listItem = new ListItem(
			ix,
			eleLi,
			brewName,
			{
				authors: rowsSubMetas.map(it => it.authorsFull).join(", "),
				abbreviation: rowsSubMetas.map(it => it.abbreviation).join(", "),
			},
			{
				cbSel,
			},
		);

		eleLi.addEventListener("click", evt => rdState.listSelectClickHandler.handleSelectClick(listItem, evt, {isPassThroughEvents: true}));

		const rowMeta = {
			listItem,
			menu: null,
		};
		return rowMeta;
	}

	static _pRender_getBtnPlaceholder () {
		return e_({
			tag: "button",
			clazz: `btn btn-default btn-xs mobile__hidden w-24p`,
			html: "&nbsp;",
		})
			.attr("disabled", true);
	}

	_pRender_getBtnPull ({rdState, brew}) {
		if (!this._isBrewOperationPermitted_update(brew)) return null;

		const btnPull = e_({
			tag: "button",
			clazz: `btn btn-default btn-xs mobile__hidden w-24p`,
			title: this._LBL_LIST_UPDATE,
			children: [
				e_({
					tag: "span",
					clazz: "glyphicon glyphicon-refresh manbrew-row__icn-btn",
				}),
			],
			click: () => this._pRender_pDoPullBrew({rdState, brew}),
		});
		if (!this._brewUtil.isPullable(brew)) btnPull.attr("disabled", true).attr("title", `(Update disabled\u2014no URL available)`);
		return btnPull;
	}

	_pRender_getBtnEdit ({rdState, brew}) {
		if (!brew.head.isEditable) return null;

		return e_({
			tag: "button",
			clazz: `btn btn-default btn-xs mobile__hidden w-24p`,
			title: this._LBL_LIST_MANAGE_CONTENTS,
			children: [
				e_({
					tag: "span",
					clazz: "glyphicon glyphicon-pencil manbrew-row__icn-btn",
				}),
			],
			click: () => this._pRender_pDoEditBrew({rdState, brew}),
		});
	}

	async _pRender_pDoPullBrew ({rdState, brew}) {
		const isPull = await this._brewUtil.pPullBrew(brew);

		JqueryUtil.doToast(
			isPull
				? `${this._brewUtil.DISPLAY_NAME.uppercaseFirst()} updated!`
				: `${this._brewUtil.DISPLAY_NAME.uppercaseFirst()} is already up-to-date.`,
		);

		if (!isPull) return;

		await this._pRender_pBrewList(rdState);
	}

	async _pRender_pDoEditBrew ({rdState, brew}) {
		const {isDirty, brew: nxtBrew} = await ManageEditableBrewContentsUi.pDoOpen({brewUtil: this._brewUtil, brew, isModal: this._isModal});
		if (!isDirty) return;

		await this._brewUtil.pUpdateBrew(nxtBrew);
		await this._pRender_pBrewList(rdState);
	}

	async _pRender_pDoDownloadBrew ({brew, brewName = null}) {
		const filename = (brew.head.filename || "").split(".").slice(0, -1).join(".");

						const isChooseSources = brew.head.isEditable && (brew.body._meta?.sources || []).length > 1;

		if (!isChooseSources) {
			const outFilename = filename || brewName || this.constructor._getBrewName(brew);
			const json = brew.head.isEditable ? MiscUtil.copyFast(brew.body) : brew.body;
			this.constructor._mutExportableEditableData({json: json});
			return DataUtil.userDownload(outFilename, json, {isSkipAdditionalMetadata: true});
		}

				const getSourceAsText = source => `[${(source.abbreviation || "").qq()}] ${(source.full || "").qq()}`;

		const choices = await InputUiUtil.pGetUserMultipleChoice({
			title: `Choose Sources`,
			values: brew.body._meta.sources,
			fnDisplay: getSourceAsText,
			isResolveItems: true,
			max: Number.MAX_SAFE_INTEGER,
			isSearchable: true,
			fnGetSearchText: getSourceAsText,
		});
		if (choices == null || choices.length === 0) return;
		
				const cpyBrew = MiscUtil.copyFast(brew.body);
		const sourceAllowlist = new Set(choices.map(it => it.json));

		cpyBrew._meta.sources = cpyBrew._meta.sources.filter(it => sourceAllowlist.has(it.json));

		Object.entries(cpyBrew)
			.forEach(([k, v]) => {
				if (!v || !(v instanceof Array)) return;
				if (k.startsWith("_")) return;
				cpyBrew[k] = v.filter(it => {
					const source = SourceUtil.getEntitySource(it);
					if (!source) return true;
					return sourceAllowlist.has(source);
				});
			});
		
		const reducedFilename = filename || this.constructor._getBrewName({body: cpyBrew});

		this.constructor._mutExportableEditableData({json: cpyBrew});

		return DataUtil.userDownload(reducedFilename, cpyBrew, {isSkipAdditionalMetadata: true});
	}

		static _mutExportableEditableData ({json}) {
		Object.values(json)
			.forEach(arr => {
				if (arr == null || !(arr instanceof Array)) return;
				arr.forEach(ent => delete ent.uniqueId);
			});
		return json;
	}

	static _getBrewJsonTitle ({brew, brewName}) {
		brewName = brewName || this._getBrewName(brew);
		return brew.head.filename || brewName;
	}

	_pRender_doViewBrew ({evt, brew, brewName}) {
		const title = this.constructor._getBrewJsonTitle({brew, brewName});
		const $content = Renderer.hover.$getHoverContent_statsCode(brew.body, {isSkipClean: true, title});
		Renderer.hover.getShowWindow(
			$content,
			Renderer.hover.getWindowPositionFromEvent(evt),
			{
				title,
				isPermanent: true,
				isBookContent: true,
			},
		);
	}

	async _pRender_pDoOpenBrewMenu ({evt, rdState, brew, brewName, rowMeta}) {
		rowMeta.menu = rowMeta.menu || this._pRender_getBrewMenu({rdState, brew, brewName});

		await ContextUtil.pOpenMenu(evt, rowMeta.menu);
	}

	_pRender_getBrewMenu ({rdState, brew, brewName}) {
		const menuItems = [];

		if (this._isBrewOperationPermitted_update(brew)) {
			menuItems.push(
				new ContextUtil.Action(
					this._LBL_LIST_UPDATE,
					async () => this._pRender_pDoPullBrew({rdState, brew}),
				),
			);
		} else if (brew.head.isEditable) {
			menuItems.push(
				new ContextUtil.Action(
					this._LBL_LIST_MANAGE_CONTENTS,
					async () => this._pRender_pDoEditBrew({rdState, brew}),
				),
			);
		}

		menuItems.push(
			new ContextUtil.Action(
				this._LBL_LIST_EXPORT,
				async () => this._pRender_pDoDownloadBrew({brew, brewName}),
			),
			new ContextUtil.Action(
				this._LBL_LIST_VIEW_JSON,
				async evt => this._pRender_doViewBrew({evt, brew, brewName}),
			),
		);

		if (this._brewUtil.IS_EDITABLE && this._isBrewOperationPermitted_moveToEditable(brew)) {
			menuItems.push(
				new ContextUtil.Action(
					this._LBL_LIST_MOVE_TO_EDITABLE,
					async () => this._pRender_pDoMoveToEditable({rdState, brews: [brew]}),
				),
			);
		}

		if (this._isBrewOperationPermitted_delete(brew)) {
			menuItems.push(
				new ContextUtil.Action(
					this._LBL_LIST_DELETE,
					async () => this._pRender_pDoDelete({rdState, brews: [brew]}),
				),
			);
		}

		return ContextUtil.getMenu(menuItems);
	}

	_pGetUserBoolean_isMoveBrewsToEditable ({brews}) {
		return InputUiUtil.pGetUserBoolean({
			title: `Move to Editable ${this._brewUtil.DISPLAY_NAME.toTitleCase()} Document`,
			htmlDescription: `Moving ${brews.length === 1 ? `this ${this._brewUtil.DISPLAY_NAME}` : `these
			${this._brewUtil.DISPLAY_NAME_PLURAL}`} to the editable document will prevent ${brews.length === 1 ? "it" : "them"} from being automatically updated in future.<br>Are you sure you want to move ${brews.length === 1 ? "it" : "them"}?`,
			textYes: "Yes",
			textNo: "Cancel",
		});
	}

	async _pRender_pDoMoveToEditable ({rdState, brews}) {
		if (!brews?.length) return;

		if (!await this._pGetUserBoolean_isMoveBrewsToEditable({brews})) return;

		await this._brewUtil.pMoveToEditable({brews});

		await this._pRender_pBrewList(rdState);

		JqueryUtil.doToast(`${`${brews.length === 1 ? this._brewUtil.DISPLAY_NAME : this._brewUtil.DISPLAY_NAME_PLURAL}`.uppercaseFirst()} moved to editable document!`);
	}

	_pGetUserBoolean_isDeleteBrews ({brews}) {
		if (!brews.some(brew => brew.head.isEditable)) return true;

		const htmlDescription = brews.length === 1
			? `This document contains all your locally-created or edited ${this._brewUtil.DISPLAY_NAME_PLURAL}.<br>Are you sure you want to delete it?`
			: `One of the documents you are about to delete contains all your locally-created or edited ${this._brewUtil.DISPLAY_NAME_PLURAL}.<br>Are you sure you want to delete these documents?`;

		return InputUiUtil.pGetUserBoolean({
			title: `Delete ${this._brewUtil.DISPLAY_NAME}`,
			htmlDescription,
			textYes: "Yes",
			textNo: "Cancel",
		});
	}

	async _pRender_pDoDelete ({rdState, brews}) {
		if (!brews?.length) return;

		if (!await this._pGetUserBoolean_isDeleteBrews({brews})) return;

		await this._brewUtil.pDeleteBrews(brews);

		await this._pRender_pBrewList(rdState);
	}

	_pRender_getProcBrew (brew) {
		brew = MiscUtil.copyFast(brew);
		brew.body._meta.sources.sort((a, b) => SortUtil.ascSortLower(a.full || "", b.full || ""));
		return brew;
	}
}

class GetBrewUi {
	static _RenderState = class {
		constructor () {
			this.pageFilter = null;
			this.list = null;
			this.listSelectClickHandler = null;
			this.cbAll = null;
		}
	};

	static _TypeFilter = class extends Filter {
		constructor ({brewUtil}) {
			const pageProps = brewUtil.getPageProps({fallback: ["*"]});
			super({
				header: "Category",
				items: [],
				displayFn: brewUtil.getPropDisplayName.bind(brewUtil),
				selFn: prop => pageProps.includes("*") || pageProps.includes(prop),
				isSortByDisplayItems: true,
			});
			this._brewUtil = brewUtil;
		}

		_getHeaderControls_addExtraStateBtns (opts, wrpStateBtnsOuter) {
			const menu = ContextUtil.getMenu(
				this._brewUtil.getPropPages()
					.map(page => ({page, displayPage: UrlUtil.pageToDisplayPage(page)}))
					.sort(SortUtil.ascSortProp.bind(SortUtil, "displayPage"))
					.map(({page, displayPage}) => {
						return new ContextUtil.Action(
							displayPage,
							() => {
								const propsActive = new Set(this._brewUtil.getPageProps({page, fallback: []}));
								Object.keys(this._state).forEach(prop => this._state[prop] = propsActive.has(prop) ? 1 : 0);
							},
						);
					}),
			);

			const btnPage = e_({
				tag: "button",
				clazz: `btn btn-default w-100 btn-xs`,
				text: `Select for Page...`,
				click: evt => ContextUtil.pOpenMenu(evt, menu),
			});

			e_({
				tag: "div",
				clazz: `btn-group mr-2 w-100 ve-flex-v-center`,
				children: [
					btnPage,
				],
			}).prependTo(wrpStateBtnsOuter);
		}
	};

	static _PageFilterGetBrew = class extends PageFilter {
		static _STATUS_FILTER_DEFAULT_DESELECTED = new Set(["wip", "deprecated", "invalid"]);

		constructor ({brewUtil}) {
			super();

			this._brewUtil = brewUtil;

			this._typeFilter = new GetBrewUi._TypeFilter({brewUtil});
			this._statusFilter = new Filter({
				header: "Status",
				items: [
					"ready",
					"wip",
					"deprecated",
					"invalid",
				],
				displayFn: StrUtil.toTitleCase,
				itemSortFn: null,
				deselFn: it => this.constructor._STATUS_FILTER_DEFAULT_DESELECTED.has(it),
			});
			this._miscFilter = new Filter({
				header: "Miscellaneous",
				items: ["Sample"],
				deselFn: it => it === "Sample",
			});
		}

		static mutateForFilters (brewInfo) {
			if (brewInfo._brewAuthor && brewInfo._brewAuthor.toLowerCase().startsWith("sample -")) brewInfo._fMisc = ["Sample"];
		}

		addToFilters (it, isExcluded) {
			if (isExcluded) return;

			this._typeFilter.addItem(it.props);
		}

		async _pPopulateBoxOptions (opts) {
			opts.filters = [
				this._typeFilter,
				this._statusFilter,
				this._miscFilter,
			];
		}

		toDisplay (values, it) {
			return this._filterBox.toDisplay(
				values,
				it.props,
				it._brewStatus,
				it._fMisc,
			);
		}
	};

	static async pDoGetBrew ({brewUtil, isModal: isParentModal = false} = {}) {
		return new Promise((resolve, reject) => {
			const ui = new this({brewUtil, isModal: true});
			const rdState = new this._RenderState();
			const {$modalInner} = UiUtil.getShowModal({
				isHeight100: true,
				title: `Get ${brewUtil.DISPLAY_NAME.toTitleCase()}`,
				isUncappedHeight: true,
				isWidth100: true,
				overlayColor: isParentModal ? "transparent" : undefined,
				isHeaderBorder: true,
				cbClose: async () => {
					await ui.pHandlePreCloseModal({rdState});
					resolve([...ui._brewsLoaded]);
				},
			});
			ui.pInit()
				.then(() => ui.pRender($modalInner, {rdState}))
				.catch(e => reject(e));
		});
	}

	_sortUrlList (a, b, o) {
		a = this._dataList[a.ix];
		b = this._dataList[b.ix];

		switch (o.sortBy) {
			case "name": return this.constructor._sortUrlList_byName(a, b);
			case "author": return this.constructor._sortUrlList_orFallback(a, b, SortUtil.ascSortLower, "_brewAuthor");
			case "category": return this.constructor._sortUrlList_orFallback(a, b, SortUtil.ascSortLower, "_brewPropDisplayName");
			case "added": return this.constructor._sortUrlList_orFallback(a, b, SortUtil.ascSort, "_brewAdded");
			case "modified": return this.constructor._sortUrlList_orFallback(a, b, SortUtil.ascSort, "_brewModified");
			default: throw new Error(`No sort order defined for property "${o.sortBy}"`);
		}
	}

	static _sortUrlList_byName (a, b) { return SortUtil.ascSortLower(a._brewName, b._brewName); }
	static _sortUrlList_orFallback (a, b, fn, prop) { return fn(a[prop], b[prop]) || this._sortUrlList_byName(a, b); }

	constructor ({brewUtil, isModal} = {}) {
		this._brewUtil = brewUtil;
		this._isModal = isModal;

		this._dataList = null;

		this._brewsLoaded = []; 	}

	async pInit () {
		const urlRoot = await this._brewUtil.pGetCustomUrl();
		const [timestamps, propIndex, metaIndex] = await Promise.all([
			this._brewUtil.pLoadTimestamps(urlRoot),
			this._brewUtil.pLoadPropIndex(urlRoot),
			this._brewUtil.pLoadMetaIndex(urlRoot),
		]);

		const pathToMeta = {};
		Object.entries(propIndex)
			.forEach(([prop, pathToDir]) => {
				Object.entries(pathToDir)
					.forEach(([path, dir]) => {
						pathToMeta[path] = pathToMeta[path] || {dir, props: []};
						pathToMeta[path].props.push(prop);
					});
			});

		this._dataList = Object.entries(pathToMeta)
			.map(([path, meta]) => {
				const out = {
					download_url: this._brewUtil.getFileUrl(path, urlRoot),
					path,
					name: UrlUtil.getFilename(path),
					dirProp: this._brewUtil.getDirProp(meta.dir),
					props: meta.props,
				};

				const spl = out.name.trim().replace(/\.json$/, "").split(";").map(it => it.trim());
				if (spl.length > 1) {
					out._brewName = spl[1];
					out._brewAuthor = spl[0];
				} else {
					out._brewName = spl[0];
					out._brewAuthor = this._brewUtil.DEFAULT_AUTHOR;
				}

				out._brewAdded = timestamps[out.path]?.a ?? 0;
				out._brewModified = timestamps[out.path]?.m ?? 0;
				out._brewInternalSources = metaIndex[out.name]?.n || [];
				out._brewStatus = metaIndex[out.name]?.s || "ready";
				out._brewPropDisplayName = this._brewUtil.getPropDisplayName(out.dirProp);

				return out;
			})
			.sort((a, b) => SortUtil.ascSortLower(a._brewName, b._brewName));
	}

	async pHandlePreCloseModal ({rdState}) {
				const cntSel = rdState.list.items.filter(it => it.data.cbSel.checked).length;
		if (!cntSel) return;

		const isSave = await InputUiUtil.pGetUserBoolean({
			title: `Selected ${this._brewUtil.DISPLAY_NAME}`,
			htmlDescription: `You have ${cntSel} ${cntSel === 1 ? this._brewUtil.DISPLAY_NAME : this._brewUtil.DISPLAY_NAME_PLURAL} selected which ${cntSel === 1 ? "is" : "are"} not yet loaded. Would you like to load ${cntSel === 1 ? "it" : "them"}?`,
			textYes: "Load",
			textNo: "Discard",
		});
		if (!isSave) return;

		await this._pHandleClick_btnAddSelected({rdState});
			}

	async pRender ($wrp, {rdState} = {}) {
		rdState = rdState || new this.constructor._RenderState();

		rdState.pageFilter = new this.constructor._PageFilterGetBrew({brewUtil: this._brewUtil});

		const $btnAddSelected = $(`<button class="btn ${this._brewUtil.STYLE_BTN} btn-sm col-0-5 text-center" disabled title="Add Selected"><span class="glyphicon glyphicon-save"></button>`);

		const $wrpRows = $$`<div class="list smooth-scroll max-h-unset"><div class="lst__row ve-flex-col"><div class="lst__wrp-cells lst--border lst__row-inner ve-flex w-100"><i>Loading...</i></div></div></div>`;

		const $btnFilter = $(`<button class="btn btn-default btn-sm">Filter</button>`);

		const $btnToggleSummaryHidden = $(`<button class="btn btn-default" title="Toggle Filter Summary Display"><span class="glyphicon glyphicon-resize-small"></span></button>`);

		const $iptSearch = $(`<input type="search" class="search manbrew__search form-control w-100 lst__search lst__search--no-border-h" placeholder="Find ${this._brewUtil.DISPLAY_NAME}...">`)
			.keydown(evt => this._pHandleKeydown_iptSearch(evt, rdState));
		const $dispCntVisible = $(`<div class="lst__wrp-search-visible no-events ve-flex-vh-center"></div>`);

		rdState.cbAll = e_({
			tag: "input",
			type: "checkbox",
		});

		const $btnReset = $(`<button class="btn btn-default btn-sm">Reset</button>`);

		const $wrpMiniPills = $(`<div class="fltr__mini-view btn-group"></div>`);

		const $wrpSort = $$`<div class="filtertools manbrew__filtertools btn-group input-group input-group--bottom ve-flex no-shrink">
			<label class="col-0-5 pr-0 btn btn-default btn-xs ve-flex-vh-center">${rdState.cbAll}</label>
			<button class="col-3-5 sort btn btn-default btn-xs" data-sort="name">Name</button>
			<button class="col-3 sort btn btn-default btn-xs" data-sort="author">Author</button>
			<button class="col-1-2 sort btn btn-default btn-xs" data-sort="category">Category</button>
			<button class="col-1-4 sort btn btn-default btn-xs" data-sort="modified">Modified</button>
			<button class="col-1-4 sort btn btn-default btn-xs" data-sort="added">Added</button>
			<button class="sort btn btn-default btn-xs ve-grow" disabled>Source</button>
		</div>`;

		$$($wrp)`
		<div class="mt-1"><i>A list of ${this._brewUtil.DISPLAY_NAME} available in the public repository. Click a name to load the ${this._brewUtil.DISPLAY_NAME}, or view the source directly.${this._brewUtil.IS_EDITABLE ? `<br>
		Contributions are welcome; see the <a href="${this._brewUtil.URL_REPO_DEFAULT}/blob/master/README.md" target="_blank" rel="noopener noreferrer">README</a>, or stop by our <a href="https://discord.gg/5etools" target="_blank" rel="noopener noreferrer">Discord</a>.` : ""}</i></div>
		<hr class="hr-3">
		<div class="lst__form-top">
			${$btnAddSelected}
			${$btnFilter}
			${$btnToggleSummaryHidden}
			<div class="w-100 relative">
				${$iptSearch}
				<div id="lst__search-glass" class="lst__wrp-search-glass no-events ve-flex-vh-center"><span class="glyphicon glyphicon-search"></span></div>
				${$dispCntVisible}
			</div>
			${$btnReset}
		</div>
		${$wrpMiniPills}
		${$wrpSort}
		${$wrpRows}`;

		rdState.list = new List({
			$iptSearch,
			$wrpList: $wrpRows,
			fnSort: this._sortUrlList.bind(this),
			isUseJquery: true,
			isFuzzy: true,
			isSkipSearchKeybindingEnter: true,
		});

		rdState.list.on("updated", () => $dispCntVisible.html(`${rdState.list.visibleItems.length}/${rdState.list.items.length}`));

		rdState.listSelectClickHandler = new ListSelectClickHandler({list: rdState.list});
		rdState.listSelectClickHandler.bindSelectAllCheckbox($(rdState.cbAll));
		SortUtil.initBtnSortHandlers($wrpSort, rdState.list);

		this._dataList.forEach((brewInfo, ix) => {
			const {listItem} = this._pRender_getUrlRowMeta(rdState, brewInfo, ix);
			rdState.list.addItem(listItem);
		});

		await rdState.pageFilter.pInitFilterBox({
			$iptSearch: $iptSearch,
			$btnReset: $btnReset,
			$btnOpen: $btnFilter,
			$btnToggleSummaryHidden,
			$wrpMiniPills,
			namespace: `get-homebrew-${UrlUtil.getCurrentPage()}`,
		});

		this._dataList.forEach(it => rdState.pageFilter.mutateAndAddToFilters(it));

		rdState.list.init();

		rdState.pageFilter.trimState();
		rdState.pageFilter.filterBox.render();

		rdState.pageFilter.filterBox.on(
			FilterBox.EVNT_VALCHANGE,
			this._handleFilterChange.bind(this, rdState),
		);

		this._handleFilterChange(rdState);

		$btnAddSelected
			.prop("disabled", false)
			.click(() => this._pHandleClick_btnAddSelected({rdState}));

		$iptSearch.focus();
	}

	_handleFilterChange (rdState) {
		const f = rdState.pageFilter.filterBox.getValues();
		rdState.list.filter(li => rdState.pageFilter.toDisplay(f, this._dataList[li.ix]));
	}

	_pRender_getUrlRowMeta (rdState, brewInfo, ix) {
		const timestampAdded = brewInfo._brewAdded
			? DatetimeUtil.getDateStr({date: new Date(brewInfo._brewAdded * 1000), isShort: true, isPad: true})
			: "";
		const timestampModified = brewInfo._brewModified
			? DatetimeUtil.getDateStr({date: new Date(brewInfo._brewModified * 1000), isShort: true, isPad: true})
			: "";

		const cbSel = e_({
			tag: "input",
			clazz: "no-events",
			type: "checkbox",
		});

		const btnAdd = e_({
			tag: "span",
			clazz: `col-3-5 bold manbrew__load_from_url pl-0 clickable`,
			text: brewInfo._brewName,
			click: evt => this._pHandleClick_btnGetRemote({evt, btn: btnAdd, url: brewInfo.download_url}),
		});

		const eleLi = e_({
			tag: "div",
			clazz: `lst__row lst__row-inner not-clickable lst--border lst__row--focusable no-select`,
			children: [
				e_({
					tag: "div",
					clazz: `lst__wrp-cells ve-flex w-100`,
					children: [
						e_({
							tag: "label",
							clazz: `col-0-5 ve-flex-vh-center ve-self-flex-stretch`,
							children: [cbSel],
						}),
						btnAdd,
						e_({tag: "span", clazz: "col-3", text: brewInfo._brewAuthor}),
						e_({tag: "span", clazz: "col-1-2 text-center mobile__text-clip-ellipsis", text: brewInfo._brewPropDisplayName, title: brewInfo._brewPropDisplayName}),
						e_({tag: "span", clazz: "col-1-4 text-center code", text: timestampModified}),
						e_({tag: "span", clazz: "col-1-4 text-center code", text: timestampAdded}),
						e_({
							tag: "span",
							clazz: "col-1 manbrew__source text-center pr-0",
							children: [
								e_({
									tag: "a",
									text: `View Raw`,
								})
									.attr("href", brewInfo.download_url)
									.attr("target", "_blank")
									.attr("rel", "noopener noreferrer"),
							],
						}),
					],
				}),
			],
			keydown: evt => this._pHandleKeydown_row(evt, {rdState, btnAdd, url: brewInfo.download_url, listItem}),
		})
			.attr("tabindex", ix);

		const listItem = new ListItem(
			ix,
			eleLi,
			brewInfo._brewName,
			{
				author: brewInfo._brewAuthor,
								internalSources: brewInfo._brewInternalSources, 			},
			{
				btnAdd,
				cbSel,
				pFnDoDownload: ({isLazy = false} = {}) => this._pHandleClick_btnGetRemote({btn: btnAdd, url: brewInfo.download_url, isLazy}),
			},
		);

		eleLi.addEventListener("click", evt => rdState.listSelectClickHandler.handleSelectClick(listItem, evt, {isPassThroughEvents: true}));

		return {
			listItem,
		};
	}

	async _pHandleKeydown_iptSearch (evt, rdState) {
		switch (evt.key) {
			case "Enter": {
				const firstItem = rdState.list.visibleItems[0];
				if (!firstItem) return;
				await firstItem.data.pFnDoDownload();
				return;
			}

			case "ArrowDown": {
				const firstItem = rdState.list.visibleItems[0];
				if (firstItem) {
					evt.stopPropagation();
					evt.preventDefault();
					firstItem.ele.focus();
				}
			}
		}
	}

	async _pHandleClick_btnAddSelected ({rdState}) {
		const listItems = rdState.list.items.filter(it => it.data.cbSel.checked);

		if (!listItems.length) return JqueryUtil.doToast({type: "warning", content: `Please select some ${this._brewUtil.DISPLAY_NAME_PLURAL} first!`});

		if (listItems.length > 25 && !await InputUiUtil.pGetUserBoolean({title: "Are you sure?", htmlDescription: `<div>You area about to load ${listItems.length} ${this._brewUtil.DISPLAY_NAME} files.<br>Loading large quantities of ${this._brewUtil.DISPLAY_NAME_PLURAL} can lead to performance and stability issues.</div>`, textYes: "Continue"})) return;

		rdState.cbAll.checked = false;
		rdState.list.items.forEach(item => {
			item.data.cbSel.checked = false;
			item.ele.classList.remove("list-multi-selected");
		});

		await Promise.allSettled(listItems.map(it => it.data.pFnDoDownload({isLazy: true})));
		await this._brewUtil.pAddBrewsLazyFinalize();
		JqueryUtil.doToast(`Finished loading selected ${this._brewUtil.DISPLAY_NAME}!`);
	}

	async _pHandleClick_btnGetRemote ({evt, btn, url, isLazy}) {
		if (!(url || "").trim()) return JqueryUtil.doToast({type: "danger", content: `${this._brewUtil.DISPLAY_NAME.uppercaseFirst()} had no download URL!`});

		if (evt) {
			evt.stopPropagation();
			evt.preventDefault();
		}

		const cachedHtml = btn.html();
		btn.txt("Loading...").attr("disabled", true);
		const brewsAdded = await this._brewUtil.pAddBrewFromUrl(url, {isLazy});
		this._brewsLoaded.push(...brewsAdded);
		btn.txt("Done!");
		setTimeout(() => btn.html(cachedHtml).attr("disabled", false), VeCt.DUR_INLINE_NOTIFY);
	}

	async _pHandleKeydown_row (evt, {rdState, btnAdd, url, listItem}) {
		switch (evt.key) {
			case "Enter": return this._pHandleClick_btnGetRemote({evt, btn: btnAdd, url});

			case "ArrowUp": {
				const ixCur = rdState.list.visibleItems.indexOf(listItem);

				if (~ixCur) {
					const prevItem = rdState.list.visibleItems[ixCur - 1];
					if (prevItem) {
						evt.stopPropagation();
						evt.preventDefault();
						prevItem.ele.focus();
					}
					return;
				}

				const firstItem = rdState.list.visibleItems[0];
				if (firstItem) {
					evt.stopPropagation();
					evt.preventDefault();
					firstItem.ele.focus();
				}
				return;
			}

			case "ArrowDown": {
				const ixCur = rdState.list.visibleItems.indexOf(listItem);

				if (~ixCur) {
					const nxtItem = rdState.list.visibleItems[ixCur + 1];
					if (nxtItem) {
						evt.stopPropagation();
						evt.preventDefault();
						nxtItem.ele.focus();
					}
					return;
				}

				const lastItem = rdState.list.visibleItems.last();
				if (lastItem) {
					evt.stopPropagation();
					evt.preventDefault();
					lastItem.ele.focus();
				}
			}
		}
	}
}

class ManageEditableBrewContentsUi extends BaseComponent {
	static _RenderState = class {
		constructor () {
			this.tabMetaEntities = null;
			this.tabMetaSources = null;

			this.listEntities = null;
			this.listEntitiesSelectClickHandler = null;
			this.listSources = null;
			this.listSourcesSelectClickHandler = null;

			this.contentEntities = null;
			this.pageFilterEntities = new ManageEditableBrewContentsUi._PageFilter();
		}
	};

	static _PageFilter = class extends PageFilter {
		constructor () {
			super();
			this._categoryFilter = new Filter({header: "Category"});
		}

		static mutateForFilters (meta) {
			const {ent, prop} = meta;
			meta._fSource = SourceUtil.getEntitySource(ent);
			meta._fCategory = ManageEditableBrewContentsUi._getDisplayProp({ent, prop});
		}

		addToFilters (meta) {
			this._sourceFilter.addItem(meta._fSource);
			this._categoryFilter.addItem(meta._fCategory);
		}

		async _pPopulateBoxOptions (opts) {
			opts.filters = [
				this._sourceFilter,
				this._categoryFilter,
			];
		}

		toDisplay (values, meta) {
			return this._filterBox.toDisplay(
				values,
				meta._fSource,
				meta._fCategory,
			);
		}
	};

	static async pDoOpen ({brewUtil, brew, isModal: isParentModal = false}) {
		return new Promise((resolve, reject) => {
			const ui = new this({brewUtil, brew, isModal: true});
			const rdState = new this._RenderState();
			const {$modalInner} = UiUtil.getShowModal({
				isHeight100: true,
				title: `Manage Document Contents`,
				isUncappedHeight: true,
				isWidth100: true,
				$titleSplit: $$`<div class="ve-flex-v-center btn-group">
					${ui._$getBtnDeleteSelected({rdState})}
				</div>`,
				overlayColor: isParentModal ? "transparent" : undefined,
				cbClose: () => {
					resolve(ui._getFormData());
					rdState.pageFilterEntities.filterBox.teardown();
				},
			});
			ui.pRender($modalInner, {rdState})
				.catch(e => reject(e));
		});
	}

	constructor ({brewUtil, brew, isModal}) {
		super();

		TabUiUtil.decorate(this, {isInitMeta: true});

		this._brewUtil = brewUtil;
		this._brew = MiscUtil.copyFast(brew);
		this._isModal = isModal;

		this._isDirty = false;
	}

	_getFormData () {
		return {
			isDirty: this._isDirty,
			brew: this._brew,
		};
	}

	_$getBtnDeleteSelected ({rdState}) {
		return $(`<button class="btn btn-danger btn-xs">Delete Selected</button>`)
			.click(() => this._handleClick_pButtonDeleteSelected({rdState}));
	}

	async _handleClick_pButtonDeleteSelected ({rdState}) {
		if (this._getActiveTab() === rdState.tabMetaEntities) return this._handleClick_pButtonDeleteSelected_entities({rdState});
		if (this._getActiveTab() === rdState.tabMetaSources) return this._handleClick_pButtonDeleteSelected_sources({rdState});
			}

	async _handleClick_pButtonDeleteSelected_entities ({rdState}) {
		const listItemsSel = rdState.listEntities.items
			.filter(it => it.data.cbSel.checked);

		if (!listItemsSel.length) return;

		if (!await InputUiUtil.pGetUserBoolean({title: "Delete Entities", htmlDescription: `Are you sure you want to delete the ${listItemsSel.length === 1 ? "selected entity" : `${listItemsSel.length} selected entities`}?`, textYes: "Yes", textNo: "Cancel"})) return;

		this._isDirty = true;

				listItemsSel
			.forEach(li => this._doEntityListDelete({rdState, li}));
		rdState.listEntities.update();
	}

	_doEntityListDelete ({rdState, li}) {
		const ix = this._brew.body[li.data.prop].indexOf(li.data.ent);
		if (!~ix) return;
		this._brew.body[li.data.prop].splice(ix, 1);
		if (!this._brew.body[li.data.prop].length) delete this._brew.body[li.data.prop];
		rdState.listEntities.removeItem(li);
	}

	async _handleClick_pButtonDeleteSelected_sources ({rdState}) {
		const listItemsSel = rdState.listSources.items
			.filter(it => it.data.cbSel.checked);

		if (!listItemsSel.length) return;

		if (
			!await InputUiUtil.pGetUserBoolean({
				title: "Delete Sources",
				htmlDescription: `<div>Are you sure you want to delete the ${listItemsSel.length === 1 ? "selected source" : `${listItemsSel.length} selected sources`}?<br><b>This will delete all entities with ${listItemsSel.length === 1 ? "that source" : `these sources`}</b>.</div>`,
				textYes: "Yes",
				textNo: "Cancel",
			})
		) return;

		this._isDirty = true;

				listItemsSel
			.forEach(li => {
				const ix = this._brew.body._meta.sources.indexOf(li.data.source);
				if (!~ix) return;
				this._brew.body._meta.sources.splice(ix, 1);
				rdState.listSources.removeItem(li);
			});
		rdState.listSources.update();

				const sourceSetRemoved = new Set(listItemsSel.map(li => li.data.source.json));
		rdState.listEntities.visibleItems
			.forEach(li => {
				const source = SourceUtil.getEntitySource(li.data.ent);
				if (!sourceSetRemoved.has(source)) return;

				this._doEntityListDelete({rdState, li});
			});
		rdState.listEntities.update();
	}

	async pRender ($wrp, {rdState = null} = {}) {
		rdState = rdState || new this.constructor._RenderState();

		const iptTabMetas = [
			new TabUiUtil.TabMeta({name: "Entities", hasBorder: true}),
			new TabUiUtil.TabMeta({name: "Metadata", hasBorder: true}),
			new TabUiUtil.TabMeta({name: "Sources", hasBorder: true}),
		];

		const tabMetas = this._renderTabs(iptTabMetas, {$parent: $wrp});
		const [tabMetaEntities, tabMetaMetadata, tabMetaSources] = tabMetas;

		rdState.tabMetaEntities = tabMetaEntities;
		rdState.tabMetaSources = tabMetaSources;

		this._pRender_tabEntities({tabMeta: tabMetaEntities, rdState});
		this._pRender_tabMetadata({tabMeta: tabMetaMetadata, rdState});
		this._pRender_tabSources({tabMeta: tabMetaSources, rdState});
	}

	_pRender_tabEntities ({tabMeta, rdState}) {
		const $btnFilter = $(`<button class="btn btn-default">Filter</button>`);

		const $btnToggleSummaryHidden = $(`<button class="btn btn-default" title="Toggle Filter Summary Display"><span class="glyphicon glyphicon-resize-small"></span></button>`);

		const $btnReset = $(`<button class="btn btn-default">Reset</button>`);

		const $wrpMiniPills = $(`<div class="fltr__mini-view btn-group"></div>`);

		const $cbAll = $(`<input type="checkbox">`);
		const $wrpRows = $$`<div class="list ve-flex-col w-100 max-h-unset"></div>`;
		const $iptSearch = $(`<input type="search" class="search manbrew__search form-control w-100 lst__search lst__search--no-border-h" placeholder="Search entries...">`);
		const $dispCntVisible = $(`<div class="lst__wrp-search-visible no-events ve-flex-vh-center"></div>`);
		const $wrpBtnsSort = $$`<div class="filtertools manbrew__filtertools input-group input-group--bottom ve-flex no-shrink">
			<label class="btn btn-default btn-xs col-1 pr-0 ve-flex-vh-center">${$cbAll}</label>
			<button class="col-5 sort btn btn-default btn-xs" data-sort="name">Name</button>
			<button class="col-1 sort btn btn-default btn-xs" data-sort="source">Source</button>
			<button class="col-5 sort btn btn-default btn-xs" data-sort="category">Category</button>
		</div>`;

		$$(tabMeta.$wrpTab)`
		<div class="ve-flex-v-stretch input-group input-group--top no-shrink mt-1">
			${$btnFilter}
			${$btnToggleSummaryHidden}
			<div class="w-100 relative">
				${$iptSearch}
				<div id="lst__search-glass" class="lst__wrp-search-glass no-events ve-flex-vh-center"><span class="glyphicon glyphicon-search"></span></div>
				${$dispCntVisible}
			</div>
			${$btnReset}
		</div>

		${$wrpMiniPills}

		${$wrpBtnsSort}
		${$wrpRows}`;

		rdState.listEntities = new List({
			$iptSearch,
			$wrpList: $wrpRows,
			fnSort: SortUtil.listSort,
		});

		rdState.listEntities.on("updated", () => $dispCntVisible.html(`${rdState.listEntities.visibleItems.length}/${rdState.listEntities.items.length}`));

		rdState.listEntitiesSelectClickHandler = new ListSelectClickHandler({list: rdState.listEntities});
		rdState.listEntitiesSelectClickHandler.bindSelectAllCheckbox($cbAll);
		SortUtil.initBtnSortHandlers($wrpBtnsSort, rdState.listEntities);

		let ixParent = 0;
		rdState.contentEntities = Object.entries(this._brew.body)
			.filter(([, v]) => v instanceof Array && v.length)
			.map(([prop, arr]) => arr.map(ent => ({ent, prop, ixParent: ixParent++})))
			.flat();

		rdState.contentEntities.forEach(({ent, prop, ixParent}) => {
			const {listItem} = this._pRender_getEntityRowMeta({rdState, prop, ent, ixParent});
			rdState.listEntities.addItem(listItem);
		});

		rdState.pageFilterEntities.pInitFilterBox({
			$iptSearch: $iptSearch,
			$btnReset: $btnReset,
			$btnOpen: $btnFilter,
			$btnToggleSummaryHidden: $btnToggleSummaryHidden,
			$wrpMiniPills: $wrpMiniPills,
			namespace: `${this.constructor.name}__tabEntities`,
		}).then(async () => {
			rdState.contentEntities.forEach(meta => rdState.pageFilterEntities.mutateAndAddToFilters(meta));

			rdState.listEntities.init();

			rdState.pageFilterEntities.trimState();
			rdState.pageFilterEntities.filterBox.render();

			rdState.pageFilterEntities.filterBox.on(
				FilterBox.EVNT_VALCHANGE,
				this._handleFilterChange_entities.bind(this, {rdState}),
			);

			this._handleFilterChange_entities({rdState});

			$iptSearch.focus();
		});
	}

	_handleFilterChange_entities ({rdState}) {
		const f = rdState.pageFilterEntities.filterBox.getValues();
		rdState.listEntities.filter(li => rdState.pageFilterEntities.toDisplay(f, rdState.contentEntities[li.ix]));
	}

	_pRender_getEntityRowMeta ({rdState, prop, ent, ixParent}) {
		const eleLi = document.createElement("div");
		eleLi.className = "lst__row ve-flex-col px-0";

		const dispName = this.constructor._getDisplayName({brew: this._brew, ent, prop});
		const sourceMeta = this.constructor._getSourceMeta({brew: this._brew, ent});
		const dispProp = this.constructor._getDisplayProp({ent, prop});

		eleLi.innerHTML = `<label class="lst--border lst__row-inner no-select mb-0 ve-flex-v-center">
			<div class="pl-0 col-1 ve-flex-vh-center"><input type="checkbox" class="no-events"></div>
			<div class="col-5 bold">${dispName}</div>
			<div class="col-1 text-center" title="${(sourceMeta.full || "").qq()}" ${this._brewUtil.sourceToStyle(sourceMeta)}>${sourceMeta.abbreviation}</div>
			<div class="col-5 ve-flex-vh-center pr-0">${dispProp}</div>
		</label>`;

		const listItem = new ListItem(
			ixParent, 			eleLi,
			dispName,
			{
				source: sourceMeta.abbreviation,
				category: dispProp,
			},
			{
				cbSel: eleLi.firstElementChild.firstElementChild.firstElementChild,
				prop,
				ent,
			},
		);

		eleLi.addEventListener("click", evt => rdState.listEntitiesSelectClickHandler.handleSelectClick(listItem, evt));

		return {
			listItem,
		};
	}

	_pRender_tabMetadata ({tabMeta, rdState}) {
		const infoTuples = Object.entries(this.constructor._PROP_INFOS_META).filter(([k]) => Object.keys(this._brew.body?._meta?.[k] || {}).length);

		if (!infoTuples.length) {
			$$(tabMeta.$wrpTab)`
				<h4>Metadata</h4>
				<p><i>No metadata found.</i></p>
			`;
			return;
		}

		const metasSections = infoTuples
			.map(([prop, info]) => this._pRender_getMetaRowMeta({prop, info}));

		$$(tabMeta.$wrpTab)`
			<div class="pt-2"><i>Warning: deleting metadata may invalidate or otherwise corrupt homebrew which depends on it. Use with caution.</i></div>
			<hr class="hr-3">
			${metasSections.map(({$wrp}) => $wrp)}
		`;
	}

	_pRender_getMetaRowMeta ({prop, info}) {
		const displayName = info.displayName || prop.toTitleCase();
		const displayFn = info.displayFn || ((...args) => args.last().toTitleCase());

		const $rows = Object.keys(this._brew.body._meta[prop])
			.map(k => {
				const $btnDelete = $(`<button class="btn btn-danger btn-xs" title="Delete"><span class="glyphicon glyphicon-trash"></span></button>`)
					.click(() => {
						this._isDirty = true;
						MiscUtil.deleteObjectPath(this._brew.body._meta, prop, k);
						$row.remove();

												if (this._brew.body._meta[prop]) return;

						$wrp.remove();
					});

				const $row = $$`<div class="lst__row ve-flex-col px-0">
					<div class="split-v-center lst--border lst__row-inner no-select mb-0 ve-flex-v-center">
						<div class="col-10">${displayFn(this._brew, prop, k)}</div>
						<div class="col-2 btn-group ve-flex-v-center ve-flex-h-right">
							${$btnDelete}
						</div>
					</div>
				</div>`;

				return $row;
			});

		const $wrp = $$`<div class="ve-flex-col mb-4">
			<div class="bold mb-2">${displayName}:</div>
			<div class="ve-flex-col list-display-only">${$rows}</div>
		</div>`;

		return {
			$wrp,
		};
	}

	_pRender_tabSources ({tabMeta, rdState}) {
		const $cbAll = $(`<input type="checkbox">`);
		const $wrpRows = $$`<div class="list ve-flex-col w-100 max-h-unset"></div>`;
		const $iptSearch = $(`<input type="search" class="search manbrew__search form-control w-100 mt-1" placeholder="Search source...">`);
		const $wrpBtnsSort = $$`<div class="filtertools manbrew__filtertools input-group input-group--bottom ve-flex no-shrink">
			<label class="btn btn-default btn-xs col-1 pr-0 ve-flex-vh-center">${$cbAll}</label>
			<button class="col-5 sort btn btn-default btn-xs" data-sort="name">Name</button>
			<button class="col-2 sort btn btn-default btn-xs" data-sort="abbreviation">Abbreviation</button>
			<button class="col-4 sort btn btn-default btn-xs" data-sort="json">JSON</button>
		</div>`;

		$$(tabMeta.$wrpTab)`
		${$iptSearch}
		${$wrpBtnsSort}
		${$wrpRows}`;

		rdState.listSources = new List({
			$iptSearch,
			$wrpList: $wrpRows,
			fnSort: SortUtil.listSort,
		});

		rdState.listSourcesSelectClickHandler = new ListSelectClickHandler({list: rdState.listSources});
		rdState.listSourcesSelectClickHandler.bindSelectAllCheckbox($cbAll);
		SortUtil.initBtnSortHandlers($wrpBtnsSort, rdState.listSources);

		(this._brew.body?._meta?.sources || [])
			.forEach((source, ix) => {
				const {listItem} = this._pRender_getSourceRowMeta({rdState, source, ix});
				rdState.listSources.addItem(listItem);
			});

		rdState.listSources.init();
		$iptSearch.focus();
	}

	_pRender_getSourceRowMeta ({rdState, source, ix}) {
		const eleLi = document.createElement("div");
		eleLi.className = "lst__row ve-flex-col px-0";

		const name = source.full || _BrewInternalUtil.SOURCE_UNKNOWN_FULL;
		const abv = source.abbreviation || _BrewInternalUtil.SOURCE_UNKNOWN_ABBREVIATION;

		eleLi.innerHTML = `<label class="lst--border lst__row-inner no-select mb-0 ve-flex-v-center">
			<div class="pl-0 col-1 ve-flex-vh-center"><input type="checkbox" class="no-events"></div>
			<div class="col-5 bold">${name}</div>
			<div class="col-2 text-center">${abv}</div>
			<div class="col-4 ve-flex-vh-center pr-0">${source.json}</div>
		</label>`;

		const listItem = new ListItem(
			ix,
			eleLi,
			name,
			{
				abbreviation: abv,
				json: source.json,
			},
			{
				cbSel: eleLi.firstElementChild.firstElementChild.firstElementChild,
				source,
			},
		);

		eleLi.addEventListener("click", evt => rdState.listSourcesSelectClickHandler.handleSelectClick(listItem, evt));

		return {
			listItem,
		};
	}

	static _NAME_UNKNOWN = "(Unknown)";

	static _getDisplayName ({brew, ent, prop}) {
		switch (prop) {
			case "itemProperty": {
				if (ent.name) return ent.name || this._NAME_UNKNOWN;
				if (ent.entries) {
					const name = Renderer.findName(ent.entries);
					if (name) return name;
				}
				if (ent.entriesTemplate) {
					const name = Renderer.findName(ent.entriesTemplate);
					if (name) return name;
				}
				return ent.abbreviation || this._NAME_UNKNOWN;
			}

			case "adventureData":
			case "bookData": {
				const propContents = prop === "adventureData" ? "adventure" : "book";

				if (!brew[propContents]) return ent.id || this._NAME_UNKNOWN;

				return brew[propContents].find(it => it.id === ent.id)?.name || ent.id || this._NAME_UNKNOWN;
			}

			default: return ent.name || this._NAME_UNKNOWN;
		}
	}

	static _getSourceMeta ({brew, ent}) {
		const entSource = SourceUtil.getEntitySource(ent);
		if (!entSource) return {abbreviation: _BrewInternalUtil.SOURCE_UNKNOWN_ABBREVIATION, full: _BrewInternalUtil.SOURCE_UNKNOWN_FULL};
		const source = (brew.body?._meta?.sources || []).find(src => src.json === entSource);
		if (!source) return {abbreviation: _BrewInternalUtil.SOURCE_UNKNOWN_ABBREVIATION, full: _BrewInternalUtil.SOURCE_UNKNOWN_FULL};
		return source;
	}

	static _getDisplayProp ({ent, prop}) {
		const out = [Parser.getPropDisplayName(prop)];

		switch (prop) {
			case "subclass": out.push(` (${ent.className})`); break;
			case "subrace": out.push(` (${ent.raceName})`); break;
			case "psionic": out.push(` (${Parser.psiTypeToMeta(ent.type).short})`); break;
		}

		return out.filter(Boolean).join(" ");
	}

		static _PROP_INFOS_META = {
		"spellDistanceUnits": {
			displayName: "Spell Distance Units",
		},
		"spellSchools": {
			displayName: "Spell Schools",
			displayFn: (brew, propMeta, k) => brew.body._meta[propMeta][k].full || k,
		},
		"currencyConversions": {
			displayName: "Currency Conversion Tables",
			displayFn: (brew, propMeta, k) => `${k}: ${brew.body._meta[propMeta][k].map(it => `${it.coin}=${it.mult}`).join(", ")}`,
		},
		"skills": {
			displayName: "Skills",
		},
		"senses": {
			displayName: "Senses",
		},
		"optionalFeatureTypes": {
			displayName: "Optional Feature Types",
			displayFn: (brew, propMeta, k) => brew.body._meta[propMeta][k] || k,
		},
		"charOption": {
			displayName: "Character Creation Option Types",
			displayFn: (brew, propMeta, k) => brew.body._meta[propMeta][k] || k,
		},
		"psionicTypes": {
			displayName: "Psionic Types",
			displayFn: (brew, propMeta, k) => brew.body._meta[propMeta][k].full || k,
		},
	};
}

"use strict";



class _DataLoaderConst {
	static SOURCE_SITE_ALL = Symbol("SOURCE_SITE_ALL");
	static SOURCE_PRERELEASE_ALL_CURRENT = Symbol("SOURCE_PRERELEASE_ALL_CURRENT");
	static SOURCE_BREW_ALL_CURRENT = Symbol("SOURCE_BREW_ALL_CURRENT");

	static ENTITY_NULL = Symbol("ENTITY_NULL");
}

class _DataLoaderInternalUtil {
	static getCleanPageSourceHash ({page, source, hash}) {
		return {
			page: this.getCleanPage({page}),
			source: this.getCleanSource({source}),
			hash: this.getCleanHash({hash}),
		};
	}

	static getCleanPage ({page}) { return page.toLowerCase(); }
	static getCleanSource ({source}) { return source.toLowerCase(); }
	static getCleanHash ({hash}) { return hash.toLowerCase(); }

	
	static getCleanPageFluff ({page}) { return `${this.getCleanPage({page})}fluff`; }

	
	static _NOTIFIED_FAILED_DEREFERENCES = new Set();

	static doNotifyFailedDereferences ({missingRefSets, diagnostics}) {
				const missingRefSetsUnseen = Object.entries(missingRefSets)
			.mergeMap(([prop, set]) => ({
				[prop]: new Set(
					[...set]
						.filter(ref => {
							const refLower = ref.toLowerCase();
							const out = !this._NOTIFIED_FAILED_DEREFERENCES.has(refLower);
							this._NOTIFIED_FAILED_DEREFERENCES.add(refLower);
							return out;
						}),
				),
			}));
		
		const cntMissingRefs = Object.values(missingRefSetsUnseen).map(({size}) => size).sum();
		if (!cntMissingRefs) return;

		const notificationRefs = Object.entries(missingRefSetsUnseen)
			.map(([k, v]) => `${k}: ${[...v].sort(SortUtil.ascSortLower).join(", ")}`)
			.join("; ");

		const ptDiagnostics = DataLoader$1.getDiagnosticsSummary(diagnostics);
		const msgStart = `Failed to load references for ${cntMissingRefs} entr${cntMissingRefs === 1 ? "y" : "ies"}!`;

		JqueryUtil.doToast({
			type: "danger",
			content: `${msgStart} Reference types and values were: ${[notificationRefs, ptDiagnostics].join(" ")}`,
			isAutoHide: false,
		});

		const cnslRefs = [
			...Object.entries(missingRefSetsUnseen)
				.map(([k, v]) => `${k}:\n\t${[...v].sort(SortUtil.ascSortLower).join("\n\t")}`),
			ptDiagnostics,
		]
			.filter(Boolean)
			.join("\n");

		setTimeout(() => { throw new Error(`${msgStart}\nReference types and values were:\n${cnslRefs}`); });
	}
}




class _DataLoaderDereferencerBase {
	static _DereferenceMeta = class {
		constructor ({cntReplaces = 0, offsetIx = 0}) {
			this.cntReplaces = cntReplaces;
			this.offsetIx = offsetIx;
		}
	};

	static _WALKER_MOD = MiscUtil.getWalker({
		keyBlocklist: MiscUtil.GENERIC_WALKER_ENTRIES_KEY_BLOCKLIST,
	});

	
	_pPreloadingRefContentSite = null;
	_pPreloadingRefContentPrerelease = null;
	_pPreloadingRefContentBrew = null;

	_preloadingPrereleaseLastIdent = null;
	_preloadingBrewLastIdent = null;

	async pPreloadRefContent () {
		await (this._pPreloadingRefContentSite = this._pPreloadingRefContentSite || this._pPreloadRefContentSite());

		if (typeof PrereleaseUtil !== "undefined") {
			const identPrerelease = PrereleaseUtil.getCacheIteration();
			if (identPrerelease !== this._preloadingPrereleaseLastIdent) this._pPreloadingRefContentPrerelease = null;
			this._preloadingPrereleaseLastIdent = identPrerelease;
			await (this._pPreloadingRefContentPrerelease = this._pPreloadingRefContentPrerelease || this._pPreloadRefContentPrerelease());
		}

		if (typeof BrewUtil2 !== "undefined") {
			const identBrew = BrewUtil2.getCacheIteration();
			if (identBrew !== this._preloadingBrewLastIdent) this._pPreloadingRefContentBrew = null;
			this._preloadingBrewLastIdent = identBrew;
			await (this._pPreloadingRefContentBrew = this._pPreloadingRefContentBrew || this._pPreloadRefContentBrew());
		}
	}

	async _pPreloadRefContentSite () {  }
	async _pPreloadRefContentPrerelease () {  }
	async _pPreloadRefContentBrew () {  }

	
	dereference ({ent, entriesWithoutRefs, toReplaceMeta, ixReplace}) { throw new Error("Unimplemented!"); }

	_getCopyFromCache ({page, entriesWithoutRefs, refUnpacked, refHash}) {
		if (page.toLowerCase().endsWith(".html")) throw new Error(`Could not dereference "${page}" content. Dereferencing is only supported for props!`);

				return entriesWithoutRefs[page]?.[refHash]
			? MiscUtil.copyFast(entriesWithoutRefs[page]?.[refHash])
			: DataLoader$1.getFromCache(page, refUnpacked.source, refHash, {isCopy: true});
	}
}

class _DataLoaderDereferencerClassSubclassFeatures extends _DataLoaderDereferencerBase {
	dereference ({ent, entriesWithoutRefs, toReplaceMeta, ixReplace}) {
		const prop = toReplaceMeta.type === "refClassFeature" ? "classFeature" : "subclassFeature";
		const refUnpacked = toReplaceMeta.type === "refClassFeature"
			? DataUtil.class.unpackUidClassFeature(toReplaceMeta.classFeature)
			: DataUtil.class.unpackUidSubclassFeature(toReplaceMeta.subclassFeature);
		const refHash = UrlUtil.URL_TO_HASH_BUILDER[prop](refUnpacked);

				if (ExcludeUtil.isInitialised && ExcludeUtil.isExcluded(refHash, prop, refUnpacked.source, {isNoCount: true})) {
			toReplaceMeta.array[toReplaceMeta.ix] = {};
			return new this.constructor._DereferenceMeta({cntReplaces: 1});
		}

		const cpy = this._getCopyFromCache({page: prop, entriesWithoutRefs, refUnpacked, refHash});
		if (!cpy) return new this.constructor._DereferenceMeta({cntReplaces: 0});

		delete cpy.level;
		delete cpy.header;
		if (toReplaceMeta.name) cpy.name = toReplaceMeta.name;
		toReplaceMeta.array[toReplaceMeta.ix] = cpy;
		return new this.constructor._DereferenceMeta({cntReplaces: 1});
	}
}

class _DataLoaderDereferencerOptionalfeatures extends _DataLoaderDereferencerBase {
	async _pPreloadRefContentSite () { await DataLoader$1.pCacheAndGetAllSite(UrlUtil.PG_OPT_FEATURES); }
	async _pPreloadRefContentPrerelease () { await DataLoader$1.pCacheAndGetAllPrerelease(UrlUtil.PG_OPT_FEATURES); }
	async _pPreloadRefContentBrew () { await DataLoader$1.pCacheAndGetAllBrew(UrlUtil.PG_OPT_FEATURES); }

	dereference ({ent, entriesWithoutRefs, toReplaceMeta, ixReplace}) {
		const refUnpacked = DataUtil.generic.unpackUid(toReplaceMeta.optionalfeature, "optfeature");
		const refHash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_OPT_FEATURES](refUnpacked);

				if (ExcludeUtil.isInitialised && ExcludeUtil.isExcluded(refHash, "optionalfeature", refUnpacked.source, {isNoCount: true})) {
			toReplaceMeta.array[toReplaceMeta.ix] = {};
			return new this.constructor._DereferenceMeta({cntReplaces: 1});
		}

		const cpy = this._getCopyFromCache({page: "optionalfeature", entriesWithoutRefs, refUnpacked, refHash});
		if (!cpy) return new this.constructor._DereferenceMeta({cntReplaces: 0});

		delete cpy.featureType;
		delete cpy.prerequisite;
		if (toReplaceMeta.name) cpy.name = toReplaceMeta.name;
		toReplaceMeta.array[toReplaceMeta.ix] = cpy;

		return new this.constructor._DereferenceMeta({cntReplaces: 1});
	}
}

class _DataLoaderDereferencerItemEntries extends _DataLoaderDereferencerBase {
	async _pPreloadRefContentSite () { await DataLoader$1.pCacheAndGetAllSite(UrlUtil.PG_ITEMS); }
	async _pPreloadRefContentPrerelease () { await DataLoader$1.pCacheAndGetAllPrerelease(UrlUtil.PG_ITEMS); }
	async _pPreloadRefContentBrew () { await DataLoader$1.pCacheAndGetAllBrew(UrlUtil.PG_ITEMS); }

	dereference ({ent, entriesWithoutRefs, toReplaceMeta, ixReplace}) {
		const refUnpacked = DataUtil.generic.unpackUid(toReplaceMeta.itemEntry, "itemEntry");
		const refHash = UrlUtil.URL_TO_HASH_BUILDER["itemEntry"](refUnpacked);

		const cpy = this._getCopyFromCache({page: "itemEntry", entriesWithoutRefs, refUnpacked, refHash});
		if (!cpy) return new this.constructor._DereferenceMeta({cntReplaces: 0});

		cpy.entriesTemplate = this.constructor._WALKER_MOD.walk(
			cpy.entriesTemplate,
			{
				string: (str) => {
					return Renderer.utils.applyTemplate(
						ent,
						str,
					);
				},
			},
		);

		toReplaceMeta.array.splice(toReplaceMeta.ix, 1, ...cpy.entriesTemplate);

		return new this.constructor._DereferenceMeta({
			cntReplaces: 1,
									offsetIx: cpy.entriesTemplate.length - 1,
		});
	}
}

class _DataLoaderDereferencer {
	static _REF_TYPE_TO_DEREFERENCER = {};

	static _init () {
		this._REF_TYPE_TO_DEREFERENCER["refClassFeature"] =
		this._REF_TYPE_TO_DEREFERENCER["refSubclassFeature"] =
			new _DataLoaderDereferencerClassSubclassFeatures();

		this._REF_TYPE_TO_DEREFERENCER["refOptionalfeature"] =
			new _DataLoaderDereferencerOptionalfeatures();

		this._REF_TYPE_TO_DEREFERENCER["refItemEntry"] =
			new _DataLoaderDereferencerItemEntries();

		return null;
	}

	static _ = this._init();

	static _WALKER_READ = MiscUtil.getWalker({
		keyBlocklist: MiscUtil.GENERIC_WALKER_ENTRIES_KEY_BLOCKLIST,
		isNoModification: true,
		isBreakOnReturn: true,
	});

		static async pGetDereferenced (
		entities,
		page,
		{
			propEntries = "entries",
			propIsRef = null,
		} = {},
	) {
		if (page.toLowerCase().endsWith(".html")) throw new Error(`Could not dereference "${page}" content. Dereferencing is only supported for props!`);

		if (!entities || !entities.length) return {};

		const out = {};
		const entriesWithRefs = {};
		const entriesWithoutRefs = {};

		this._pGetDereferenced_doSegregateWithWithoutRefs({
			entities,
			page,
			propEntries,
			propIsRef,
			entriesWithRefs,
			entriesWithoutRefs,
		});

		await this._pGetDereferenced_pDoDereference({propEntries, entriesWithRefs, entriesWithoutRefs});
		this._pGetDereferenced_doNotifyFailed({entriesWithRefs, entities});
		this._pGetDereferenced_doPopulateOutput({page, out, entriesWithoutRefs, entriesWithRefs});

		return out;
	}

	
	static _pGetDereferenced_doSegregateWithWithoutRefs ({entities, page, propEntries, propIsRef, entriesWithRefs, entriesWithoutRefs}) {
		const hashBuilder = UrlUtil.URL_TO_HASH_BUILDER[page];
		entities
			.forEach(ent => {
				const hash = hashBuilder(ent);
				const hasRefs = this._pGetDereferenced_hasRefs({ent, propEntries, propIsRef});

				(
					(hasRefs ? entriesWithRefs : entriesWithoutRefs)[page] = (hasRefs ? entriesWithRefs : entriesWithoutRefs)[page] || {}
				)[hash] = hasRefs ? MiscUtil.copyFast(ent) : ent;
			});
	}

	static _pGetDereferenced_hasRefs ({ent, propEntries, propIsRef}) {
		if (propIsRef != null) return !!ent[propIsRef];

		const ptrHasRef = {_: false};
		this._WALKER_READ.walk(ent[propEntries], this._pGetDereferenced_doPopulateRaw_getHandlers({ptrHasRef}));
		return ptrHasRef._;
	}

	static _pGetDereferenced_doPopulateRaw_getHandlers ({ptrHasRef}) {
		return {
			object: (obj) => {
				if (this._REF_TYPE_TO_DEREFERENCER[obj.type]) return ptrHasRef._ = true;
			},
			string: (str) => {
				if (str.startsWith("{#") && str.endsWith("}")) return ptrHasRef._ = true;
			},
		};
	}

	
	static _MAX_DEREFERENCE_LOOPS = 25; 
	static async _pGetDereferenced_pDoDereference ({propEntries, entriesWithRefs, entriesWithoutRefs}) {
		for (let i = 0; i < this._MAX_DEREFERENCE_LOOPS; ++i) {
			if (!Object.keys(entriesWithRefs).length) break;

			for (const [page, pageEntries] of Object.entries(entriesWithRefs)) {
				for (const [hash, ent] of Object.entries(pageEntries)) {
					const toReplaceMetas = [];
					this._WALKER_READ.walk(
						ent[propEntries],
						this._pGetDereferenced_doDereference_getHandlers({toReplaceMetas}),
					);

					for (const {type} of toReplaceMetas) {
						if (!this._REF_TYPE_TO_DEREFERENCER[type]) continue;
						await this._REF_TYPE_TO_DEREFERENCER[type].pPreloadRefContent();
					}

					let cntReplaces = 0;
					for (let ixReplace = 0; ixReplace < toReplaceMetas.length; ++ixReplace) {
						const toReplaceMeta = this._pGetDereferenced_doDereference_getToReplaceMeta(toReplaceMetas[ixReplace]);

						const derefMeta = this._REF_TYPE_TO_DEREFERENCER[toReplaceMeta.type].dereference({
							ent,
							entriesWithoutRefs,
							toReplaceMeta,
							ixReplace,
						});
						cntReplaces += derefMeta.cntReplaces;

						if (!derefMeta.offsetIx) continue;

						toReplaceMetas.slice(ixReplace + 1).forEach(it => it.ix += derefMeta.offsetIx);
					}

					if (cntReplaces === toReplaceMetas.length) {
						delete pageEntries[hash];
						(entriesWithoutRefs[page] = entriesWithoutRefs[page] || {})[hash] = ent;
					}
				}

				if (!Object.keys(pageEntries).length) delete entriesWithRefs[page];
			}
		}
	}

	static _pGetDereferenced_doDereference_getHandlers ({toReplaceMetas}) {
		return {
			array: (arr) => {
				arr.forEach((it, i) => {
					if (this._REF_TYPE_TO_DEREFERENCER[it.type]) {
						toReplaceMetas.push({
							...it,
							array: arr,
							ix: i,
						});
						return;
					}

					if (typeof it === "string" && it.startsWith("{#") && it.endsWith("}")) {
						toReplaceMetas.push({
							string: it,
							array: arr,
							ix: i,
						});
					}
				});
			},
		};
	}

	static _pGetDereferenced_doDereference_getToReplaceMeta (toReplaceMetaRaw) {
		if (toReplaceMetaRaw.string == null) return toReplaceMetaRaw;

		const str = toReplaceMetaRaw.string;
		delete toReplaceMetaRaw.string;
		return {...toReplaceMetaRaw, ...Renderer.hover.getRefMetaFromTag(str)};
	}

	
	static _pGetDereferenced_doNotifyFailed ({entriesWithRefs, entities}) {
		const entriesWithRefsVals = Object.values(entriesWithRefs)
			.map(hashToEntry => Object.values(hashToEntry))
			.flat();

		if (!entriesWithRefsVals.length) return;

		const missingRefSets = {};
		this._WALKER_READ.walk(
			entriesWithRefsVals,
			{
				object: (obj) => {
					switch (obj.type) {
						case "refClassFeature": (missingRefSets["classFeature"] = missingRefSets["classFeature"] || new Set()).add(obj.classFeature); break;
						case "refSubclassFeature": (missingRefSets["subclassFeature"] = missingRefSets["subclassFeature"] || new Set()).add(obj.subclassFeature); break;
						case "refOptionalfeature": (missingRefSets["optionalfeature"] = missingRefSets["optionalfeature"] || new Set()).add(obj.optionalfeature); break;
						case "refItemEntry": (missingRefSets["itemEntry"] = missingRefSets["itemEntry"] || new Set()).add(obj.itemEntry); break;
					}
				},
			},
		);

		_DataLoaderInternalUtil.doNotifyFailedDereferences({
			missingRefSets,
			diagnostics: entities
				.map(ent => ent.__diagnostic)
				.filter(Boolean),
		});
	}

	
	static _pGetDereferenced_doPopulateOutput ({isOverwrite, out, entriesWithoutRefs, entriesWithRefs}) {
		[
			...Object.entries(entriesWithoutRefs),
						...Object.entries(entriesWithRefs),
		]
			.forEach(([page, hashToEnt]) => {
				Object.entries(hashToEnt)
					.forEach(([hash, ent]) => {
						if (!isOverwrite && DataLoader$1.getFromCache(page, ent.source, hash)) return;
						(out[page] = out[page] || []).push(ent);
					});
			});
	}
}




class _DataLoaderCache {
	_cache = {};
	_cacheSiteLists = {};
	_cachePrereleaseLists = {};
	_cacheBrewLists = {};

	get (pageClean, sourceClean, hashClean) {
		return this._cache[pageClean]?.[sourceClean]?.[hashClean];
	}

	getAllSite (pageClean) {
		return Object.values(this._cacheSiteLists[pageClean] || {});
	}

	getAllPrerelease (pageClean) {
		return Object.values(this._cachePrereleaseLists[pageClean] || {});
	}

	getAllBrew (pageClean) {
		return Object.values(this._cacheBrewLists[pageClean] || {});
	}

	set (pageClean, sourceClean, hashClean, ent) {
				let pageCache = this._cache[pageClean];
		if (!pageCache) {
			pageCache = {};
			this._cache[pageClean] = pageCache;
		}

		let sourceCache = pageCache[sourceClean];
		if (!sourceCache) {
			sourceCache = {};
			pageCache[sourceClean] = sourceCache;
		}

		sourceCache[hashClean] = ent;
		
		if (ent === _DataLoaderConst.ENTITY_NULL) return;

				const sourceJson = Parser.sourceJsonToJson(sourceClean);
		if (SourceUtil.isSiteSource(sourceJson)) {
			this._set_addToPartition({
				cache: this._cacheSiteLists,
				pageClean,
				hashClean,
				ent,
			});
			return;
		}

		if (PrereleaseUtil.hasSourceJson(sourceJson)) {
			this._set_addToPartition({
				cache: this._cachePrereleaseLists,
				pageClean,
				hashClean,
				ent,
			});
			return;
		}

		if (BrewUtil2.hasSourceJson(sourceJson)) {
			this._set_addToPartition({
				cache: this._cacheBrewLists,
				pageClean,
				hashClean,
				ent,
			});
		}
			}

	_set_addToPartition ({cache, pageClean, hashClean, ent}) {
		let siteListCache = cache[pageClean];
		if (!siteListCache) {
			siteListCache = {};
			cache[pageClean] = siteListCache;
		}
		siteListCache[hashClean] = ent;
	}
}




class _DataTypeLoader {
	static PROPS = [];
	static PAGE = null;
	static IS_FLUFF = false;

	static register ({fnRegister}) {
		fnRegister({
			loader: new this(),
			props: this.PROPS,
			page: this.PAGE,
			isFluff: this.IS_FLUFF,
		});
	}

	static _getAsRawPrefixed (json, {propsRaw}) {
		return {
			...propsRaw.mergeMap(prop => ({[`raw_${prop}`]: json[prop]})),
		};
	}

	
		phase1CachePropAllowlist;

		phase2CachePropAllowlist;

	hasPhase2Cache = false;

	_cache_pSiteData = {};
	_cache_pPostCaches = {};

		_getSiteIdent ({pageClean, sourceClean}) { throw new Error("Unimplemented!"); }

	_isPrereleaseAvailable () { return typeof PrereleaseUtil !== "undefined"; }

	_isBrewAvailable () { return typeof BrewUtil2 !== "undefined"; }

	async _pPrePopulate ({data, isPrerelease, isBrew}) {  }

	async pGetSiteData ({pageClean, sourceClean}) {
		const propCache = this._getSiteIdent({pageClean, sourceClean});
		this._cache_pSiteData[propCache] = this._cache_pSiteData[propCache] || this._pGetSiteData({pageClean, sourceClean});
		return this._cache_pSiteData[propCache];
	}

	async _pGetSiteData ({pageClean, sourceClean}) { throw new Error("Unimplemented!"); }

	async pGetStoredPrereleaseData () {
		if (!this._isPrereleaseAvailable()) return {};
		return this._pGetStoredPrereleaseData();
	}

	async pGetStoredBrewData () {
		if (!this._isBrewAvailable()) return {};
		return this._pGetStoredBrewData();
	}

	async _pGetStoredPrereleaseData () {
		return this._pGetStoredPrereleaseBrewData({brewUtil: PrereleaseUtil, isPrerelease: true});
	}

	async _pGetStoredBrewData () {
		return this._pGetStoredPrereleaseBrewData({brewUtil: BrewUtil2, isBrew: true});
	}

	async _pGetStoredPrereleaseBrewData ({brewUtil, isPrerelease, isBrew}) {
		const prereleaseBrewData = await brewUtil.pGetBrewProcessed();
		await this._pPrePopulate({data: prereleaseBrewData, isPrerelease, isBrew});
		return prereleaseBrewData;
	}

	async pGetPostCacheData ({siteData = null, prereleaseData = null, brewData = null, lockToken2}) {  }

	async _pGetPostCacheData_obj_withCache ({obj, propCache, lockToken2}) {
		this._cache_pPostCaches[propCache] = this._cache_pPostCaches[propCache] || this._pGetPostCacheData_obj({obj, lockToken2});
		return this._cache_pPostCaches[propCache];
	}

	async _pGetPostCacheData_obj ({obj, lockToken2}) { throw new Error("Unimplemented!"); }

	hasCustomCacheStrategy ({obj}) { return false; }

	addToCacheCustom ({cache, obj}) {  }
}

class _DataTypeLoaderSingleSource extends _DataTypeLoader {
	_filename;

	_getSiteIdent ({pageClean, sourceClean}) { return this._filename; }

	async _pGetSiteData ({pageClean, sourceClean}) {
		return DataUtil.loadJSON(`${Renderer.get().baseUrl}data/${this._filename}`);
	}
}

class _DataTypeLoaderBackground extends _DataTypeLoaderSingleSource {
	static PROPS = ["background"];
	static PAGE = UrlUtil.PG_BACKGROUNDS;

	_filename = "backgrounds.json";
}

class _DataTypeLoaderPsionic extends _DataTypeLoaderSingleSource {
	static PROPS = ["psionic"];
	static PAGE = UrlUtil.PG_PSIONICS;

	_filename = "psionics.json";
}

class _DataTypeLoaderObject extends _DataTypeLoaderSingleSource {
	static PROPS = ["object"];
	static PAGE = UrlUtil.PG_OBJECTS;

	_filename = "objects.json";
}

class _DataTypeLoaderAction extends _DataTypeLoaderSingleSource {
	static PROPS = ["action"];
	static PAGE = UrlUtil.PG_ACTIONS;

	_filename = "actions.json";
}

class _DataTypeLoaderFeat extends _DataTypeLoaderSingleSource {
	static PROPS = ["feat"];
	static PAGE = UrlUtil.PG_FEATS;

	_filename = "feats.json";
}

class _DataTypeLoaderOptionalfeature extends _DataTypeLoaderSingleSource {
	static PROPS = ["optionalfeature"];
	static PAGE = UrlUtil.PG_OPT_FEATURES;

	_filename = "optionalfeatures.json";
}

class _DataTypeLoaderReward extends _DataTypeLoaderSingleSource {
	static PROPS = ["reward"];
	static PAGE = UrlUtil.PG_REWARDS;

	_filename = "rewards.json";
}

class _DataTypeLoaderCharoption extends _DataTypeLoaderSingleSource {
	static PROPS = ["charoption"];
	static PAGE = UrlUtil.PG_CHAR_CREATION_OPTIONS;

	_filename = "charcreationoptions.json";
}

class _DataTypeLoaderTrapHazard extends _DataTypeLoaderSingleSource {
	static PROPS = ["trap", "hazard"];
	static PAGE = UrlUtil.PG_TRAPS_HAZARDS;

	_filename = "trapshazards.json";
}

class _DataTypeLoaderCultBoon extends _DataTypeLoaderSingleSource {
	static PROPS = ["cult", "boon"];
	static PAGE = UrlUtil.PG_CULTS_BOONS;

	_filename = "cultsboons.json";
}

class _DataTypeLoaderVehicle extends _DataTypeLoaderSingleSource {
	static PROPS = ["vehicle", "vehicleUpgrade"];
	static PAGE = UrlUtil.PG_VEHICLES;

	_filename = "vehicles.json";
}

class _DataTypeLoaderConditionDisease extends _DataTypeLoaderSingleSource {
	static PROPS = ["condition", "disease", "status"];
	static PAGE = UrlUtil.PG_CONDITIONS_DISEASES;

	_filename = "conditionsdiseases.json";
}

class _DataTypeLoaderSkill extends _DataTypeLoaderSingleSource {
	static PROPS = ["skill"];

	_filename = "skills.json";
}

class _DataTypeLoaderSense extends _DataTypeLoaderSingleSource {
	static PROPS = ["sense"];

	_filename = "senses.json";
}

class _DataTypeLoaderLegendaryGroup extends _DataTypeLoaderSingleSource {
	static PROPS = ["legendaryGroup"];

	_filename = "bestiary/legendarygroups.json";
}

class _DataTypeLoaderItemEntry extends _DataTypeLoaderSingleSource {
	static PROPS = ["itemEntry"];

	_filename = "items-base.json";
}

class _DataTypeLoaderItemMastery extends _DataTypeLoaderSingleSource {
	static PROPS = ["itemMastery"];

	_filename = "items-base.json";
}

class _DataTypeLoaderBackgroundFluff extends _DataTypeLoaderSingleSource {
	static PROPS = ["backgroundFluff"];
	static PAGE = UrlUtil.PG_BACKGROUNDS;
	static IS_FLUFF = true;

	_filename = "fluff-backgrounds.json";
}

class _DataTypeLoaderFeatFluff extends _DataTypeLoaderSingleSource {
	static PROPS = ["featFluff"];
	static PAGE = UrlUtil.PG_FEATS;
	static IS_FLUFF = true;

	_filename = "fluff-feats.json";
}

class _DataTypeLoaderItemFluff extends _DataTypeLoaderSingleSource {
	static PROPS = ["itemFluff"];
	static PAGE = UrlUtil.PG_ITEMS;
	static IS_FLUFF = true;

	_filename = "fluff-items.json";
}

class _DataTypeLoaderRaceFluff extends _DataTypeLoaderSingleSource {
	static PROPS = ["raceFluff"];
	static PAGE = UrlUtil.PG_RACES;
	static IS_FLUFF = true;

	_filename = "fluff-races.json";
}

class _DataTypeLoaderLanguageFluff extends _DataTypeLoaderSingleSource {
	static PROPS = ["languageFluff"];
	static PAGE = UrlUtil.PG_LANGUAGES;
	static IS_FLUFF = true;

	_filename = "fluff-languages.json";
}

class _DataTypeLoaderVehicleFluff extends _DataTypeLoaderSingleSource {
	static PROPS = ["vehicleFluff"];
	static PAGE = UrlUtil.PG_VEHICLES;
	static IS_FLUFF = true;

	_filename = "fluff-vehicles.json";
}

class _DataTypeLoaderObjectFluff extends _DataTypeLoaderSingleSource {
	static PROPS = ["objectFluff"];
	static PAGE = UrlUtil.PG_OBJECTS;
	static IS_FLUFF = true;

	_filename = "fluff-objects.json";
}

class _DataTypeLoaderCharoptionFluff extends _DataTypeLoaderSingleSource {
	static PROPS = ["charoptionFluff"];
	static PAGE = UrlUtil.PG_CHAR_CREATION_OPTIONS;
	static IS_FLUFF = true;

	_filename = "fluff-charcreationoptions.json";
}

class _DataTypeLoaderRecipeFluff extends _DataTypeLoaderSingleSource {
	static PROPS = ["recipeFluff"];
	static PAGE = UrlUtil.PG_RECIPES;
	static IS_FLUFF = true;

	_filename = "fluff-recipes.json";
}

class _DataTypeLoaderConditionDiseaseFluff extends _DataTypeLoaderSingleSource {
	static PROPS = ["conditionFluff", "diseaseFluff", "statusFluff"];
	static PAGE = UrlUtil.PG_CONDITIONS_DISEASES;
	static IS_FLUFF = true;

	_filename = "fluff-conditionsdiseases.json";
}

class _DataTypeLoaderPredefined extends _DataTypeLoader {
	_loader;
	_loadJsonArgs = null;
	_loadPrereleaseArgs = null;
	_loadBrewArgs = null;

	_getSiteIdent ({pageClean, sourceClean}) { return this._loader; }

	async _pGetSiteData ({pageClean, sourceClean}) {
		return DataUtil[this._loader].loadJSON(this._loadJsonArgs);
	}

	async _pGetStoredPrereleaseData () {
		if (!DataUtil[this._loader].loadPrerelease) return super._pGetStoredPrereleaseData();
		return DataUtil[this._loader].loadPrerelease(this._loadPrereleaseArgs);
	}

	async _pGetStoredBrewData () {
		if (!DataUtil[this._loader].loadBrew) return super._pGetStoredBrewData();
		return DataUtil[this._loader].loadBrew(this._loadBrewArgs);
	}
}

class _DataTypeLoaderRace extends _DataTypeLoaderPredefined {
	static PROPS = ["race", "subrace"];
	static PAGE = UrlUtil.PG_RACES;

	_loader = "race";
	_loadJsonArgs = {isAddBaseRaces: true};
	_loadPrereleaseArgs = {isAddBaseRaces: true};
	_loadBrewArgs = {isAddBaseRaces: true};
}

class _DataTypeLoaderDeity extends _DataTypeLoaderPredefined {
	static PROPS = ["deity"];
	static PAGE = UrlUtil.PG_DEITIES;

	_loader = "deity";
}

class _DataTypeLoaderVariantrule extends _DataTypeLoaderPredefined {
	static PROPS = ["variantrule"];
	static PAGE = UrlUtil.PG_VARIANTRULES;

	_loader = "variantrule";
}

class _DataTypeLoaderTable extends _DataTypeLoaderPredefined {
	static PROPS = ["table", "tableGroup"];
	static PAGE = UrlUtil.PG_TABLES;

	_loader = "table";
}

class _DataTypeLoaderLanguage extends _DataTypeLoaderPredefined {
	static PROPS = ["language"];
	static PAGE = UrlUtil.PG_LANGUAGES;

	_loader = "language";
}

class _DataTypeLoaderRecipe extends _DataTypeLoaderPredefined {
	static PROPS = ["recipe"];
	static PAGE = UrlUtil.PG_RECIPES;

	_loader = "recipe";
}

class _DataTypeLoaderMultiSource extends _DataTypeLoader {
	_prop;

	_getSiteIdent ({pageClean, sourceClean}) { return `${this._prop}__${sourceClean}`; }

	async _pGetSiteData ({pageClean, sourceClean}) {
		const source = Parser.sourceJsonToJson(sourceClean);
		const data = await DataUtil[this._prop].pLoadSingleSource(source);

		if (data == null) return {};

		await this._pPrePopulate({data});

		return data;
	}
}

class _DataTypeLoaderCustomMonster extends _DataTypeLoaderMultiSource {
	static PROPS = ["monster"];
	static PAGE = UrlUtil.PG_BESTIARY;

	_prop = "monster";

	async _pGetSiteData ({pageClean, sourceClean}) {
		await DataUtil.monster.pPreloadMeta();
		return super._pGetSiteData({pageClean, sourceClean});
	}

	async _pPrePopulate ({data, isPrerelease, isBrew}) {
		DataUtil.monster.populateMetaReference(data);
	}
}

class _DataTypeLoaderCustomMonsterFluff extends _DataTypeLoaderMultiSource {
	static PROPS = ["monsterFluff"];
	static PAGE = UrlUtil.PG_BESTIARY;
	static IS_FLUFF = true;

	_prop = "monsterFluff";
}

class _DataTypeLoaderCustomSpell extends _DataTypeLoaderMultiSource {
	static PROPS = [...UrlUtil.PAGE_TO_PROPS[UrlUtil.PG_SPELLS]];
	static PAGE = UrlUtil.PG_SPELLS;

	_prop = "spell";

	async _pPrePopulate ({data, isPrerelease, isBrew}) {
		Renderer.spell.prePopulateHover(data);
		if (isPrerelease) Renderer.spell.prePopulateHoverPrerelease(data);
		if (isBrew) Renderer.spell.prePopulateHoverBrew(data);
	}
}

class _DataTypeLoaderCustomSpellFluff extends _DataTypeLoaderMultiSource {
	static PROPS = ["spellFluff"];
	static PAGE = UrlUtil.PG_SPELLS;
	static IS_FLUFF = true;

	_prop = "spellFluff";
}

class _DataTypeLoaderCustomRawable extends _DataTypeLoader {
	static _PROPS_RAWABLE;

	hasPhase2Cache = true;

	_getSiteIdent ({pageClean, sourceClean}) { return `${pageClean}__${this.constructor.name}`; }

	async _pGetSiteData ({pageClean, sourceClean}) {
		const json = await this._pGetRawSiteData();
		return this.constructor._getAsRawPrefixed(json, {propsRaw: this.constructor._PROPS_RAWABLE});
	}

		async _pGetRawSiteData () { throw new Error("Unimplemented!"); }

	async _pGetStoredPrereleaseBrewData ({brewUtil, isPrerelease, isBrew}) {
		const prereleaseBrew = await brewUtil.pGetBrewProcessed();
		return this.constructor._getAsRawPrefixed(prereleaseBrew, {propsRaw: this.constructor._PROPS_RAWABLE});
	}

	static _pGetDereferencedData_doNotifyFailed ({ent, uids, prop}) {
		const missingRefSets = {
			[prop]: new Set(uids),
		};

		_DataLoaderInternalUtil.doNotifyFailedDereferences({
			missingRefSets,
			diagnostics: [ent.__diagnostic].filter(Boolean),
		});
	}
}

class _DataTypeLoaderCustomClassesSubclass extends _DataTypeLoaderCustomRawable {
	static PROPS = ["raw_class", "raw_subclass", "class", "subclass"];
	static PAGE = UrlUtil.PG_CLASSES;

		static _PROPS_RAWABLE = ["class", "subclass"];

	async _pGetRawSiteData () { return DataUtil.class.loadRawJSON(); }

	async _pGetPostCacheData_obj ({obj, lockToken2}) {
		if (!obj) return null;

		const out = {};

		if (obj.raw_class?.length) out.class = await obj.raw_class.pSerialAwaitMap(cls => this.constructor._pGetDereferencedClassData(cls, {lockToken2}));
		if (obj.raw_subclass?.length) out.subclass = await obj.raw_subclass.pSerialAwaitMap(sc => this.constructor._pGetDereferencedSubclassData(sc, {lockToken2}));

		return out;
	}

	static _mutEntryNestLevel (feature) {
		const depth = (feature.header == null ? 1 : feature.header) - 1;
		for (let i = 0; i < depth; ++i) {
			const nxt = MiscUtil.copyFast(feature);
			feature.entries = [nxt];
			delete feature.name;
			delete feature.page;
			delete feature.source;
		}
	}

	static async _pGetDereferencedClassData (cls, {lockToken2}) {
				if (cls.classFeatures && cls.classFeatures.every(it => typeof it !== "string" && !it.classFeature)) return cls;

		cls = MiscUtil.copyFast(cls);

		const byLevel = await this._pGetDereferencedClassSubclassData(
			cls,
			{
				lockToken2,
				propFeatures: "classFeatures",
				propFeature: "classFeature",
				fnUnpackUid: DataUtil.class.unpackUidClassFeature.bind(DataUtil.class),
				fnIsInvalidUnpackedUid: ({name, className, level}) => !name || !className || !level || isNaN(level),
			},
		);

		cls.classFeatures = [...new Array(Math.max(0, ...Object.keys(byLevel).map(Number)))]
			.map((_, i) => byLevel[i + 1] || []);

		return cls;
	}

	static async _pGetDereferencedSubclassData (sc, {lockToken2}) {
				if (sc.subclassFeatures && sc.subclassFeatures.every(it => typeof it !== "string" && !it.subclassFeature)) return sc;

		sc = MiscUtil.copyFast(sc);

		const byLevel = await this._pGetDereferencedClassSubclassData(
			sc,
			{
				lockToken2,
				propFeatures: "subclassFeatures",
				propFeature: "subclassFeature",
				fnUnpackUid: DataUtil.class.unpackUidSubclassFeature.bind(DataUtil.class),
				fnIsInvalidUnpackedUid: ({name, className, subclassShortName, level}) => !name || !className || !subclassShortName || !level || isNaN(level),
			},
		);

		sc.subclassFeatures = Object.keys(byLevel)
			.map(Number)
			.sort(SortUtil.ascSort)
			.map(k => byLevel[k]);

		return sc;
	}

	static async _pGetDereferencedClassSubclassData (
		clsOrSc,
		{
			lockToken2,
			propFeatures,
			propFeature,
			fnUnpackUid,
			fnIsInvalidUnpackedUid,
		},
	) {
				if (clsOrSc[propFeatures] && clsOrSc[propFeatures].every(it => typeof it !== "string" && !it[propFeature])) return clsOrSc;

		clsOrSc = MiscUtil.copyFast(clsOrSc);

		const byLevel = {}; 		const notFoundUids = [];

		await (clsOrSc[propFeatures] || [])
			.pSerialAwaitMap(async featureRef => {
				const uid = featureRef[propFeature] ? featureRef[propFeature] : featureRef;
				const unpackedUid = fnUnpackUid(uid);
				const {source, displayText} = unpackedUid;

								if (fnIsInvalidUnpackedUid(unpackedUid)) return;

								if (source === Parser.SRC_5ETOOLS_TMP) return;

				const hash = UrlUtil.URL_TO_HASH_BUILDER[propFeature](unpackedUid);

								if (ExcludeUtil.isInitialised && ExcludeUtil.isExcluded(hash, propFeature, source, {isNoCount: true})) return;

				const feature = await DataLoader$1.pCacheAndGet(propFeature, source, hash, {isCopy: true, lockToken2});
								if (!feature) return notFoundUids.push(uid);

				if (displayText) feature._displayName = displayText;
				if (featureRef.tableDisplayName) feature._displayNameTable = featureRef.tableDisplayName;

				if (featureRef.gainSubclassFeature) feature.gainSubclassFeature = true;
				if (featureRef.gainSubclassFeatureHasContent) feature.gainSubclassFeatureHasContent = true;

				if (clsOrSc.otherSources && clsOrSc.source === feature.source) feature.otherSources = MiscUtil.copyFast(clsOrSc.otherSources);

				this._mutEntryNestLevel(feature);

				(byLevel[feature.level || 1] = byLevel[feature.level || 1] || []).push(feature);
			});

		this._pGetDereferencedData_doNotifyFailed({ent: clsOrSc, uids: notFoundUids, prop: propFeature});

		return byLevel;
	}

	async pGetPostCacheData ({siteData = null, prereleaseData = null, brewData = null, lockToken2}) {
		return {
			siteDataPostCache: await this._pGetPostCacheData_obj_withCache({obj: siteData, lockToken2, propCache: "site"}),
			prereleaseDataPostCache: await this._pGetPostCacheData_obj({obj: prereleaseData, lockToken2}),
			brewDataPostCache: await this._pGetPostCacheData_obj({obj: brewData, lockToken2}),
		};
	}
}

class _DataTypeLoaderCustomClassSubclassFeature extends _DataTypeLoader {
	static PROPS = ["raw_classFeature", "raw_subclassFeature", "classFeature", "subclassFeature"];
	static PAGE = UrlUtil.PG_CLASS_SUBCLASS_FEATURES;

	static _PROPS_RAWABLE = ["classFeature", "subclassFeature"];

	hasPhase2Cache = true;

	_getSiteIdent ({pageClean, sourceClean}) { return `${pageClean}__${this.constructor.name}`; }

	async _pGetSiteData ({pageClean, sourceClean}) {
		const json = await DataUtil.class.loadRawJSON();
		return this.constructor._getAsRawPrefixed(json, {propsRaw: this.constructor._PROPS_RAWABLE});
	}

	async _pGetStoredPrereleaseBrewData ({brewUtil, isPrerelease, isBrew}) {
		const prereleaseBrew = await brewUtil.pGetBrewProcessed();
		return this.constructor._getAsRawPrefixed(prereleaseBrew, {propsRaw: this.constructor._PROPS_RAWABLE});
	}

	async _pGetPostCacheData_obj ({obj, lockToken2}) {
		if (!obj) return null;

		const out = {};

		if (obj.raw_classFeature?.length) out.classFeature = (await _DataLoaderDereferencer.pGetDereferenced(obj.raw_classFeature, "classFeature"))?.classFeature || [];
		if (obj.raw_subclassFeature?.length) out.subclassFeature = (await _DataLoaderDereferencer.pGetDereferenced(obj.raw_subclassFeature, "subclassFeature"))?.subclassFeature || [];

		return out;
	}

	async pGetPostCacheData ({siteData = null, prereleaseData = null, brewData = null, lockToken2}) {
		return {
			siteDataPostCache: await this._pGetPostCacheData_obj_withCache({obj: siteData, lockToken2, propCache: "site"}),
			prereleaseDataPostCache: await this._pGetPostCacheData_obj({obj: prereleaseData, lockToken2}),
			brewDataPostCache: await this._pGetPostCacheData_obj({obj: brewData, lockToken2}),
		};
	}
}

class _DataTypeLoaderCustomItem extends _DataTypeLoader {
	static PROPS = [...UrlUtil.PAGE_TO_PROPS[UrlUtil.PG_ITEMS]];
	static PAGE = UrlUtil.PG_ITEMS;

		phase1CachePropAllowlist = new Set(["itemEntry"]);

	hasPhase2Cache = true;

	_getSiteIdent ({pageClean, sourceClean}) { return this.constructor.name; }

	async _pGetSiteData ({pageClean, sourceClean}) {
		return Renderer.item.pGetSiteUnresolvedRefItems();
	}

	async _pGetStoredPrereleaseBrewData ({brewUtil, isPrerelease, isBrew}) {
		const prereleaseBrewData = await brewUtil.pGetBrewProcessed();
		await this._pPrePopulate({data: prereleaseBrewData, isPrerelease, isBrew});
		return {
			item: await Renderer.item.pGetSiteUnresolvedRefItemsFromPrereleaseBrew({brewUtil, brew: prereleaseBrewData}),
			itemEntry: prereleaseBrewData.itemEntry || [],
		};
	}

	async _pPrePopulate ({data, isPrerelease, isBrew}) {
		Renderer.item.addPrereleaseBrewPropertiesAndTypesFrom({data});
	}

	async _pGetPostCacheData_obj ({siteData, obj, lockToken2}) {
		if (!obj) return null;

		const out = {};

		if (obj.item?.length) {
			out.item = (await _DataLoaderDereferencer.pGetDereferenced(obj.item, "item", {propEntries: "entries", propIsRef: "hasRefs"}))?.item || [];
			out.item = (await _DataLoaderDereferencer.pGetDereferenced(out.item, "item", {propEntries: "_fullEntries", propIsRef: "hasRefs"}))?.item || [];
		}

		return out;
	}

	async pGetPostCacheData ({siteData = null, prereleaseData = null, brewData = null, lockToken2}) {
		return {
			siteDataPostCache: await this._pGetPostCacheData_obj_withCache({obj: siteData, lockToken2, propCache: "site"}),
			prereleaseDataPostCache: await this._pGetPostCacheData_obj({obj: prereleaseData, lockToken2}),
			brewDataPostCache: await this._pGetPostCacheData_obj({obj: brewData, lockToken2}),
		};
	}
}

class _DataTypeLoaderCustomCard extends _DataTypeLoader {
	static PROPS = ["card"];
	static PAGE = UrlUtil.PG_DECKS;

	_getSiteIdent ({pageClean, sourceClean}) { return `${pageClean}__${this.constructor.name}`; }

	async _pGetSiteData ({pageClean, sourceClean}) {
		const json = await DataUtil.deck.loadRawJSON();
		return {card: json.card};
	}
}

class _DataTypeLoaderCustomDeck extends _DataTypeLoaderCustomRawable {
	static PROPS = ["raw_deck", "deck"];
	static PAGE = UrlUtil.PG_DECKS;

	static _PROPS_RAWABLE = ["deck"];

	async _pGetRawSiteData () { return DataUtil.deck.loadRawJSON(); }

	async _pGetPostCacheData_obj ({obj, lockToken2}) {
		if (!obj) return null;

		const out = {};

		if (obj.raw_deck?.length) out.deck = await obj.raw_deck.pSerialAwaitMap(ent => this.constructor._pGetDereferencedDeckData(ent, {lockToken2}));

		return out;
	}

	static async _pGetDereferencedDeckData (deck, {lockToken2}) {
		deck = MiscUtil.copyFast(deck);

		deck.cards = await this._pGetDereferencedCardData(deck, {lockToken2});

		return deck;
	}

	static async _pGetDereferencedCardData (deck, {lockToken2}) {
		const notFoundUids = [];

		const out = (await (deck.cards || [])
			.pSerialAwaitMap(async cardMeta => {
				const uid = typeof cardMeta === "string" ? cardMeta : cardMeta.uid;
				const count = typeof cardMeta === "string" ? 1 : cardMeta.count ?? 1;
				const isReplacement = typeof cardMeta === "string" ? false : cardMeta.replacement ?? false;

				const unpackedUid = DataUtil.deck.unpackUidCard(uid);
				const {source} = unpackedUid;

								if (unpackedUid.name == null || unpackedUid.set == null || unpackedUid.source == null) return;

				const hash = UrlUtil.URL_TO_HASH_BUILDER["card"](unpackedUid);

								if (ExcludeUtil.isInitialised && ExcludeUtil.isExcluded(hash, "card", source, {isNoCount: true})) return;

				const card = await DataLoader$1.pCacheAndGet("card", source, hash, {isCopy: true, lockToken2});
								if (!card) return notFoundUids.push(uid);

				if (deck.otherSources && deck.source === card.source) card.otherSources = MiscUtil.copyFast(deck.otherSources);
				if (isReplacement) card._isReplacement = true;

				return [...new Array(count)].map(() => MiscUtil.copyFast(card));
			}))
			.flat()
			.filter(Boolean);

		this._pGetDereferencedData_doNotifyFailed({ent: deck, uids: notFoundUids, prop: "card"});

		return out;
	}

	async pGetPostCacheData ({siteData = null, prereleaseData = null, brewData = null, lockToken2}) {
		return {
			siteDataPostCache: await this._pGetPostCacheData_obj_withCache({obj: siteData, lockToken2, propCache: "site"}),
			prereleaseDataPostCache: await this._pGetPostCacheData_obj({obj: prereleaseData, lockToken2}),
			brewDataPostCache: await this._pGetPostCacheData_obj({obj: brewData, lockToken2}),
		};
	}
}

class _DataTypeLoaderCustomQuickref extends _DataTypeLoader {
	static PROPS = ["reference", "referenceData"];
	static PAGE = UrlUtil.PG_QUICKREF;

	_getSiteIdent ({pageClean, sourceClean}) { return this.constructor.name; }

	_isPrereleaseAvailable () { return false; }

	_isBrewAvailable () { return false; }

	async _pGetSiteData ({pageClean, sourceClean}) {
		const json = await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/generated/bookref-quick.json`);
		return {
			reference: json.reference["bookref-quick"],
			referenceData: json.data["bookref-quick"],
		};
	}

	hasCustomCacheStrategy ({obj}) { return this.constructor.PROPS.some(prop => obj[prop]?.length); }

	addToCacheCustom ({cache, obj}) {
		obj.referenceData.forEach((chapter, ixChapter) => this._addToCacheCustom_chapter({cache, chapter, ixChapter}));
		return [...this.constructor.PROPS];
	}

	_addToCacheCustom_chapter ({cache, chapter, ixChapter}) {
		const metas = IndexableFileQuickReference.getChapterNameMetas(chapter, {isRequireQuickrefFlag: false});

		metas.forEach(nameMeta => {
			const hashParts = [
				"bookref-quick",
				ixChapter,
				UrlUtil.encodeForHash(nameMeta.name.toLowerCase()),
			];
			if (nameMeta.ixBook) hashParts.push(nameMeta.ixBook);

			const hash = hashParts.join(HASH_PART_SEP);

			const {page: pageClean, source: sourceClean, hash: hashClean} = _DataLoaderInternalUtil.getCleanPageSourceHash({
				page: UrlUtil.PG_QUICKREF,
				source: nameMeta.source,
				hash,
			});
			cache.set(pageClean, sourceClean, hashClean, nameMeta.entry);

			if (nameMeta.ixBook) return;

						hashParts.push(nameMeta.ixBook);
			const hashAlt = hashParts.join(HASH_PART_SEP);
			const hashAltClean = _DataLoaderInternalUtil.getCleanHash({hash: hashAlt});
			cache.set(pageClean, sourceClean, hashAltClean, nameMeta.entry);
					});
	}
}

class _DataTypeLoaderCustomAdventureBook extends _DataTypeLoader {
	_filename;

	_getSiteIdent ({pageClean, sourceClean}) { return `${pageClean}__${sourceClean}`; }

	hasCustomCacheStrategy ({obj}) { return this.constructor.PROPS.some(prop => obj[prop]?.length); }

	addToCacheCustom ({cache, obj}) {
		const [prop, propData] = this.constructor.PROPS;

				const dataIds = (obj[propData] || []).filter(it => it.id).map(it => it.id);
		const contentsIds = new Set((obj[prop] || []).filter(it => it.id).map(it => it.id));
		const matchingIds = dataIds.filter(id => contentsIds.has(id));

		matchingIds.forEach(id => {
			const data = (obj[propData] || []).find(it => it.id === id);
			const contents = (obj[prop] || []).find(it => it.id === id);

			const hash = UrlUtil.URL_TO_HASH_BUILDER[this.constructor.PAGE](contents);
			this._addImageBackReferences(data, this.constructor.PAGE, contents.source, hash);

			const {page: pageClean, source: sourceClean, hash: hashClean} = _DataLoaderInternalUtil.getCleanPageSourceHash({
				page: this.constructor.PAGE,
				source: contents.source,
				hash,
			});

			const pack = {
				[prop]: contents,
				[propData]: data,
			};

			cache.set(pageClean, sourceClean, hashClean, pack);
		});

		return [prop, propData];
	}

	async _pGetSiteData ({pageClean, sourceClean}) {
		const [prop, propData] = this.constructor.PROPS;

		const index = await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/${this._filename}`);
		const contents = index[prop].find(contents => _DataLoaderInternalUtil.getCleanSource({source: contents.source}) === sourceClean);

		if (!contents) return {};

		const json = await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/${prop}/${prop}-${UrlUtil.encodeForHash(contents.id.toLowerCase())}.json`);

		return {
			[prop]: [contents],
			[propData]: [
				{
					source: contents.source,
					id: contents.id,
					...json,
				},
			],
		};
	}

	_addImageBackReferences (json, page, source, hash) {
		if (!json) return;

		const walker = MiscUtil.getWalker({keyBlocklist: MiscUtil.GENERIC_WALKER_ENTRIES_KEY_BLOCKLIST, isNoModification: true});
		walker.walk(
			json,
			{
				object: (obj) => {
					if (obj.type === "image" && obj.mapRegions) {
						obj.page = obj.page || page;
						obj.source = obj.source || source;
						obj.hash = obj.hash || hash;
					}
				},
			},
		);
	}
}

class _DataTypeLoaderCustomAdventure extends _DataTypeLoaderCustomAdventureBook {
	static PROPS = ["adventure", "adventureData"];
	static PAGE = UrlUtil.PG_ADVENTURE;

	_filename = "adventures.json";
}

class _DataTypeLoaderCustomBook extends _DataTypeLoaderCustomAdventureBook {
	static PROPS = ["book", "bookData"];
	static PAGE = UrlUtil.PG_BOOK;

	_filename = "books.json";
}




let DataLoader$1 = class DataLoader {
	static _PROP_TO_HASH_PAGE = {
		"monster": UrlUtil.PG_BESTIARY,
		"spell": UrlUtil.PG_SPELLS,
		"class": UrlUtil.PG_CLASSES,
		"subclass": UrlUtil.PG_CLASSES,
		"item": UrlUtil.PG_ITEMS,
		"background": UrlUtil.PG_BACKGROUNDS,
		"psionic": UrlUtil.PG_PSIONICS,
		"object": UrlUtil.PG_OBJECTS,
		"action": UrlUtil.PG_ACTIONS,
		"trap": UrlUtil.PG_TRAPS_HAZARDS,
		"hazard": UrlUtil.PG_TRAPS_HAZARDS,
		"cult": UrlUtil.PG_CULTS_BOONS,
		"boon": UrlUtil.PG_CULTS_BOONS,
		"condition": UrlUtil.PG_CONDITIONS_DISEASES,
		"deck": UrlUtil.PG_DECKS,
		"disease": UrlUtil.PG_CONDITIONS_DISEASES,
		"status": UrlUtil.PG_CONDITIONS_DISEASES,
		"vehicle": UrlUtil.PG_VEHICLES,
		"vehicleUpgrade": UrlUtil.PG_VEHICLES,
		"feat": UrlUtil.PG_FEATS,
		"optionalfeature": UrlUtil.PG_OPT_FEATURES,
		"reward": UrlUtil.PG_REWARDS,
		"charoption": UrlUtil.PG_CHAR_CREATION_OPTIONS,
		"race": UrlUtil.PG_RACES,
		"subrace": UrlUtil.PG_RACES,
		"deity": UrlUtil.PG_DEITIES,
		"variantrule": UrlUtil.PG_VARIANTRULES,
		"table": UrlUtil.PG_TABLES,
		"tableGroup": UrlUtil.PG_TABLES,
		"language": UrlUtil.PG_LANGUAGES,
		"recipe": UrlUtil.PG_RECIPES,
		"classFeature": UrlUtil.PG_CLASS_SUBCLASS_FEATURES,
		"subclassFeature": UrlUtil.PG_CLASS_SUBCLASS_FEATURES,
		"reference": UrlUtil.PG_QUICKREF,
		"referenceData": UrlUtil.PG_QUICKREF,
		"adventure": UrlUtil.PG_ADVENTURE,
		"adventureData": UrlUtil.PG_ADVENTURE,
		"book": UrlUtil.PG_BOOK,
		"bookData": UrlUtil.PG_BOOK,
	};

	static _DATA_TYPE_LOADERS = {};
	static _DATA_TYPE_LOADER_LIST = [];

	static _init () {
		this._registerPropToHashPages();
		this._registerDataTypeLoaders();
		return null;
	}

	static _registerPropToHashPages () {
		Object.entries(this._PROP_TO_HASH_PAGE)
			.forEach(([k, v]) => this._PROP_TO_HASH_PAGE[`${k}Fluff`] = _DataLoaderInternalUtil.getCleanPageFluff({page: v}));
	}

	static _registerDataTypeLoader ({loader, props, page, isFluff}) {
		this._DATA_TYPE_LOADER_LIST.push(loader);

		if (!props?.length) throw new Error(`No "props" specified for loader "${loader.constructor.name}"!`);

		props.forEach(prop => this._DATA_TYPE_LOADERS[_DataLoaderInternalUtil.getCleanPage({page: prop})] = loader);

		if (!page) return;

		this._DATA_TYPE_LOADERS[
			isFluff
				? _DataLoaderInternalUtil.getCleanPageFluff({page})
				: _DataLoaderInternalUtil.getCleanPage({page})
		] = loader;
	}

	static _registerDataTypeLoaders () {
		const fnRegister = this._registerDataTypeLoader.bind(this);

				_DataTypeLoaderCustomMonster.register({fnRegister});
		_DataTypeLoaderCustomMonsterFluff.register({fnRegister});
		_DataTypeLoaderCustomSpell.register({fnRegister});
		_DataTypeLoaderCustomSpellFluff.register({fnRegister});
		
				_DataTypeLoaderRace.register({fnRegister});
		_DataTypeLoaderDeity.register({fnRegister});
		_DataTypeLoaderVariantrule.register({fnRegister});
		_DataTypeLoaderTable.register({fnRegister});
		_DataTypeLoaderLanguage.register({fnRegister});
		_DataTypeLoaderRecipe.register({fnRegister});
		
				_DataTypeLoaderCustomClassesSubclass.register({fnRegister});
		_DataTypeLoaderCustomClassSubclassFeature.register({fnRegister});
		_DataTypeLoaderCustomItem.register({fnRegister});
		_DataTypeLoaderCustomCard.register({fnRegister});
		_DataTypeLoaderCustomDeck.register({fnRegister});
		_DataTypeLoaderCustomQuickref.register({fnRegister});
		_DataTypeLoaderCustomAdventure.register({fnRegister});
		_DataTypeLoaderCustomBook.register({fnRegister});
		
				_DataTypeLoaderBackground.register({fnRegister});
		_DataTypeLoaderPsionic.register({fnRegister});
		_DataTypeLoaderObject.register({fnRegister});
		_DataTypeLoaderAction.register({fnRegister});
		_DataTypeLoaderFeat.register({fnRegister});
		_DataTypeLoaderOptionalfeature.register({fnRegister});
		_DataTypeLoaderReward.register({fnRegister});
		_DataTypeLoaderCharoption.register({fnRegister});

		_DataTypeLoaderTrapHazard.register({fnRegister});
		_DataTypeLoaderCultBoon.register({fnRegister});
		_DataTypeLoaderVehicle.register({fnRegister});

		_DataTypeLoaderConditionDisease.register({fnRegister});

		_DataTypeLoaderSkill.register({fnRegister});
		_DataTypeLoaderSense.register({fnRegister});
		_DataTypeLoaderLegendaryGroup.register({fnRegister});
		_DataTypeLoaderItemEntry.register({fnRegister});
		_DataTypeLoaderItemMastery.register({fnRegister});
		
				_DataTypeLoaderBackgroundFluff.register({fnRegister});
		_DataTypeLoaderFeatFluff.register({fnRegister});
		_DataTypeLoaderItemFluff.register({fnRegister});
		_DataTypeLoaderRaceFluff.register({fnRegister});
		_DataTypeLoaderLanguageFluff.register({fnRegister});
		_DataTypeLoaderVehicleFluff.register({fnRegister});
		_DataTypeLoaderObjectFluff.register({fnRegister});
		_DataTypeLoaderCharoptionFluff.register({fnRegister});
		_DataTypeLoaderRecipeFluff.register({fnRegister});

		_DataTypeLoaderConditionDiseaseFluff.register({fnRegister});
			}

	static _ = this._init();

	static _CACHE = new _DataLoaderCache();
	static _LOCK_1 = new VeLock({isDbg: false, name: "loader-lock-1"});
	static _LOCK_2 = new VeLock({isDbg: false, name: "loader-lock-2"});

	
		static getFromCache (
		page,
		source,
		hash,
		{
			isCopy = false,
			isRequired = false,
			_isReturnSentinel = false,
			_isInsertSentinelOnMiss = false,
		} = {},
	) {
		const {page: pageClean, source: sourceClean, hash: hashClean} = _DataLoaderInternalUtil.getCleanPageSourceHash({page, source, hash});
		const ent = this._getFromCache({pageClean, sourceClean, hashClean, isCopy, _isReturnSentinel, _isInsertSentinelOnMiss});
		return this._getVerifiedRequiredEntity({pageClean, sourceClean, hashClean, ent, isRequired});
	}

	static _getFromCache (
		{
			pageClean,
			sourceClean,
			hashClean,
			isCopy = false,
			_isInsertSentinelOnMiss = false,
			_isReturnSentinel = false,
		},
	) {
		const out = this._CACHE.get(pageClean, sourceClean, hashClean);

		if (out === _DataLoaderConst.ENTITY_NULL) {
			if (_isReturnSentinel) return out;
			if (!_isReturnSentinel) return null;
		}

		if (out == null && _isInsertSentinelOnMiss) {
			this._CACHE.set(pageClean, sourceClean, hashClean, _DataLoaderConst.ENTITY_NULL);
		}

		if (!isCopy || out == null) return out;
		return MiscUtil.copyFast(out);
	}

	
	static _getVerifiedRequiredEntity ({pageClean, sourceClean, hashClean, ent, isRequired}) {
		if (ent || !isRequired) return ent;
		throw new Error(`Could not find entity for page/prop "${pageClean}" with source "${sourceClean}" and hash "${hashClean}"`);
	}

	
	static async pCacheAndGetAllSite (page, {isSilent = false} = {}) {
		const pageClean = _DataLoaderInternalUtil.getCleanPage({page});

		if (this._PAGES_NO_CONTENT.has(pageClean)) return null;

		const dataLoader = this._pCache_getDataTypeLoader({pageClean, isSilent});
		if (!dataLoader) return null;

		
		const {siteData} = await this._pCacheAndGet_getCacheMeta({pageClean, sourceClean: _DataLoaderConst.SOURCE_SITE_ALL, dataLoader});
		await this._pCacheAndGet_processCacheMeta({dataLoader, siteData});

		return this._CACHE.getAllSite(pageClean);
	}

	static async pCacheAndGetAllPrerelease (page, {isSilent = false} = {}) {
		return this._CacheAndGetAllPrerelease.pCacheAndGetAll({parent: this, page, isSilent});
	}

	static async pCacheAndGetAllBrew (page, {isSilent = false} = {}) {
		return this._CacheAndGetAllBrew.pCacheAndGetAll({parent: this, page, isSilent});
	}

	static _CacheAndGetAllPrereleaseBrew = class {
		static _SOURCE_ALL;
		static _PROP_DATA;

		static async pCacheAndGetAll (
			{
				parent,
				page,
				isSilent,
			},
		) {
			const pageClean = _DataLoaderInternalUtil.getCleanPage({page});

			if (parent._PAGES_NO_CONTENT.has(pageClean)) return null;

			const dataLoader = parent._pCache_getDataTypeLoader({pageClean, isSilent});
			if (!dataLoader) return null;

			
			const cacheMeta = await parent._pCacheAndGet_getCacheMeta({pageClean, sourceClean: this._SOURCE_ALL, dataLoader});
			await parent._pCacheAndGet_processCacheMeta({dataLoader, [this._PROP_DATA]: cacheMeta[this._PROP_DATA]});

			return this._getAllCached({parent, pageClean});
		}

				static _getAllCached ({parent, pageClean}) { throw new Error("Unimplemented!"); }
	};

	static _CacheAndGetAllPrerelease = class extends this._CacheAndGetAllPrereleaseBrew {
		static _SOURCE_ALL = _DataLoaderConst.SOURCE_PRERELEASE_ALL_CURRENT;
		static _PROP_DATA = "prereleaseData";

		static _getAllCached ({parent, pageClean}) { return parent._CACHE.getAllPrerelease(pageClean); }
	};

	static _CacheAndGetAllBrew = class extends this._CacheAndGetAllPrereleaseBrew {
		static _SOURCE_ALL = _DataLoaderConst.SOURCE_BREW_ALL_CURRENT;
		static _PROP_DATA = "brewData";

		static _getAllCached ({parent, pageClean}) { return parent._CACHE.getAllBrew(pageClean); }
	};

	
	static _PAGES_NO_CONTENT = new Set([
		_DataLoaderInternalUtil.getCleanPage({page: "generic"}),
		_DataLoaderInternalUtil.getCleanPage({page: "hover"}),
	]);

		static async pCacheAndGet (page, source, hash, {isCopy = false, isRequired = false, isSilent = false, lockToken2} = {}) {
		const fromCache = this.getFromCache(page, source, hash, {isCopy, _isReturnSentinel: true});
		if (fromCache === _DataLoaderConst.ENTITY_NULL) return null;
		if (fromCache) return fromCache;

		const {page: pageClean, source: sourceClean, hash: hashClean} = _DataLoaderInternalUtil.getCleanPageSourceHash({page, source, hash});

		if (this._PAGES_NO_CONTENT.has(pageClean)) return this._getVerifiedRequiredEntity({pageClean, sourceClean, hashClean, ent: null, isRequired});

		const dataLoader = this._pCache_getDataTypeLoader({pageClean, isSilent});
		if (!dataLoader) return this._getVerifiedRequiredEntity({pageClean, sourceClean, hashClean, ent: null, isRequired});

		const isUnavailablePrerelease = await this._PrereleasePreloader._pPreloadMissing({parent: this, sourceClean});
		if (isUnavailablePrerelease) return this._getVerifiedRequiredEntity({pageClean, sourceClean, hashClean, ent: null, isRequired});

		const isUnavailableBrew = await this._BrewPreloader._pPreloadMissing({parent: this, sourceClean});
		if (isUnavailableBrew) return this._getVerifiedRequiredEntity({pageClean, sourceClean, hashClean, ent: null, isRequired});

		const {siteData = null, prereleaseData = null, brewData = null} = await this._pCacheAndGet_getCacheMeta({pageClean, sourceClean, dataLoader});
		await this._pCacheAndGet_processCacheMeta({dataLoader, siteData, prereleaseData, brewData, lockToken2});

		return this.getFromCache(page, source, hash, {isCopy, _isInsertSentinelOnMiss: true});
	}

	static async pCacheAndGetHash (page, hash, opts) {
		const source = UrlUtil.decodeHash(hash).last();
		return DataLoader$1.pCacheAndGet(page, source, hash, opts);
	}

	static _PrereleaseBrewPreloader = class {
		static _LOCK_0;
		static _SOURCES_ATTEMPTED;
				static _CACHE_SOURCE_CLEAN_TO_URL;
		static _SOURCE_ALL;

				static async pPreloadMissing ({parent, sourceClean}) {
			try {
				await this._LOCK_0.pLock();
				return (await this._pPreloadMissing({parent, sourceClean}));
			} finally {
				this._LOCK_0.unlock();
			}
		}

				static async _pPreloadMissing ({parent, sourceClean}) {
			if (this._isExistingMiss({parent, sourceClean})) return true;

			if (!this._isPossibleSource({parent, sourceClean})) return false;
			if (sourceClean === this._SOURCE_ALL) return false;

			const brewUtil = this._getBrewUtil();
			if (!brewUtil) {
				this._setExistingMiss({parent, sourceClean});
				return true;
			}

			if (brewUtil.hasSourceJson(sourceClean)) return false;

			const urlBrew = await this._pGetSourceUrl({parent, sourceClean});
			if (!urlBrew) {
				this._setExistingMiss({parent, sourceClean});
				return true;
			}

			await brewUtil.pAddBrewFromUrl(urlBrew);
			return false;
		}

		static _isExistingMiss ({sourceClean}) {
			return this._SOURCES_ATTEMPTED.has(sourceClean);
		}

		static _setExistingMiss ({sourceClean}) {
			this._SOURCES_ATTEMPTED.add(sourceClean);
		}

		
		static async _pInitCacheSourceToUrl () {
			if (this._CACHE_SOURCE_CLEAN_TO_URL) return;

			const index = await this._pGetUrlIndex();
			if (!index) return this._CACHE_SOURCE_CLEAN_TO_URL = {};

			const brewUtil = this._getBrewUtil();
			const urlRoot = await brewUtil.pGetCustomUrl();

			this._CACHE_SOURCE_CLEAN_TO_URL = Object.entries(index)
				.mergeMap(([src, url]) => ({[_DataLoaderInternalUtil.getCleanSource({source: src})]: brewUtil.getFileUrl(url, urlRoot)}));
		}

		static async _pGetUrlIndex () {
			try {
				return (await this._pGetSourceIndex());
			} catch (e) {
				setTimeout(() => { throw e; });
				return null;
			}
		}

		static async _pGetSourceUrl ({sourceClean}) {
			await this._pInitCacheSourceToUrl();
			return this._CACHE_SOURCE_CLEAN_TO_URL[sourceClean];
		}

				static _isPossibleSource ({parent, sourceClean}) { throw new Error("Unimplemented!"); }
				static _getBrewUtil () { throw new Error("Unimplemented!"); }
				static _pGetSourceIndex () { throw new Error("Unimplemented!"); }
	};

	static _PrereleasePreloader = class extends this._PrereleaseBrewPreloader {
		static _LOCK_0 = new VeLock({isDbg: false, name: "loader-lock-0--prerelease"});
		static _SOURCE_ALL = _DataLoaderConst.SOURCE_BREW_ALL_CURRENT;
		static _SOURCES_ATTEMPTED = new Set();
		static _CACHE_SOURCE_CLEAN_TO_URL = null;

		static _isPossibleSource ({parent, sourceClean}) { return parent._isPrereleaseSource({sourceClean}) && !Parser.SOURCE_JSON_TO_FULL[Parser.sourceJsonToJson(sourceClean)]; }
		static _getBrewUtil () { return typeof PrereleaseUtil !== "undefined" ? PrereleaseUtil : null; }
		static _pGetSourceIndex () { return DataUtil.prerelease.pLoadSourceIndex(); }
	};

	static _BrewPreloader = class extends this._PrereleaseBrewPreloader {
		static _LOCK_0 = new VeLock({isDbg: false, name: "loader-lock-0--brew"});
		static _SOURCE_ALL = _DataLoaderConst.SOURCE_PRERELEASE_ALL_CURRENT;
		static _SOURCES_ATTEMPTED = new Set();
		static _CACHE_SOURCE_CLEAN_TO_URL = null;

		static _isPossibleSource ({parent, sourceClean}) { return !parent._isSiteSource({sourceClean}) && !parent._isPrereleaseSource({sourceClean}); }
		static _getBrewUtil () { return typeof BrewUtil2 !== "undefined" ? BrewUtil2 : null; }
		static _pGetSourceIndex () { return DataUtil.brew.pLoadSourceIndex(); }
	};

	static async _pCacheAndGet_getCacheMeta ({pageClean, sourceClean, dataLoader}) {
		try {
			await this._LOCK_1.pLock();
			return (await this._pCache({pageClean, sourceClean, dataLoader}));
		} finally {
			this._LOCK_1.unlock();
		}
	}

	static async _pCache ({pageClean, sourceClean, dataLoader}) {
				const siteData = await dataLoader.pGetSiteData({pageClean, sourceClean});
		this._pCache_addToCache({allDataMerged: siteData, propAllowlist: dataLoader.phase1CachePropAllowlist || new Set(dataLoader.constructor.PROPS)});
				if (this._isSiteSource({sourceClean})) return {siteData};
		
		const out = {siteData};

								if (typeof PrereleaseUtil !== "undefined") {
			const prereleaseData = await dataLoader.pGetStoredPrereleaseData();
			this._pCache_addToCache({allDataMerged: prereleaseData, propAllowlist: dataLoader.phase1CachePropAllowlist || new Set(dataLoader.constructor.PROPS)});
			out.prereleaseData = prereleaseData;
		}

		if (typeof BrewUtil2 !== "undefined") {
			const brewData = await dataLoader.pGetStoredBrewData();
			this._pCache_addToCache({allDataMerged: brewData, propAllowlist: dataLoader.phase1CachePropAllowlist || new Set(dataLoader.constructor.PROPS)});
			out.brewData = brewData;
		}
		
		return out;
	}

	static async _pCacheAndGet_processCacheMeta ({dataLoader, siteData = null, prereleaseData = null, brewData = null, lockToken2 = null}) {
		if (!dataLoader.hasPhase2Cache) return;

		try {
			lockToken2 = await this._LOCK_2.pLock({token: lockToken2});
			await this._pCacheAndGet_processCacheMeta_({dataLoader, siteData, prereleaseData, brewData, lockToken2});
		} finally {
			this._LOCK_2.unlock();
		}
	}

	static async _pCacheAndGet_processCacheMeta_ ({dataLoader, siteData = null, prereleaseData = null, brewData = null, lockToken2 = null}) {
		const {siteDataPostCache, prereleaseDataPostCache, brewDataPostCache} = await dataLoader.pGetPostCacheData({siteData, prereleaseData, brewData, lockToken2});

		this._pCache_addToCache({allDataMerged: siteDataPostCache, propAllowlist: dataLoader.phase2CachePropAllowlist || new Set(dataLoader.constructor.PROPS)});
		this._pCache_addToCache({allDataMerged: prereleaseDataPostCache, propAllowlist: dataLoader.phase2CachePropAllowlist || new Set(dataLoader.constructor.PROPS)});
		this._pCache_addToCache({allDataMerged: brewDataPostCache, propAllowlist: dataLoader.phase2CachePropAllowlist || new Set(dataLoader.constructor.PROPS)});
	}

	static _pCache_getDataTypeLoader ({pageClean, isSilent}) {
		const dataLoader = this._DATA_TYPE_LOADERS[pageClean];
		if (!dataLoader && !isSilent) throw new Error(`No loading strategy found for page "${pageClean}"!`);
		return dataLoader;
	}

	static _pCache_addToCache ({allDataMerged, propAllowlist}) {
		if (!allDataMerged) return;

		allDataMerged = {...allDataMerged};

		this._DATA_TYPE_LOADER_LIST
			.filter(loader => loader.hasCustomCacheStrategy({obj: allDataMerged}))
			.forEach(loader => {
				const propsToRemove = loader.addToCacheCustom({cache: this._CACHE, obj: allDataMerged});
				propsToRemove.forEach(prop => delete allDataMerged[prop]);
			});

		Object.keys(allDataMerged)
			.forEach(prop => {
				if (!propAllowlist.has(prop)) return;

				const arr = allDataMerged[prop];
				if (!arr?.length || !(arr instanceof Array)) return;

				const hashBuilder = UrlUtil.URL_TO_HASH_BUILDER[prop];
				if (!hashBuilder) return;

				arr.forEach(ent => {
					this._pCache_addEntityToCache({prop, hashBuilder, ent});
					DataUtil.proxy.getVersions(prop, ent)
						.forEach(entVer => this._pCache_addEntityToCache({prop, hashBuilder, ent: entVer}));
				});
			});
	}

	static _pCache_addEntityToCache ({prop, hashBuilder, ent}) {
		ent.__prop = ent.__prop || prop;

		const page = this._PROP_TO_HASH_PAGE[prop];
		const source = SourceUtil.getEntitySource(ent);
		const hash = hashBuilder(ent);

		const {page: propClean, source: sourceClean, hash: hashClean} = _DataLoaderInternalUtil.getCleanPageSourceHash({page: prop, source, hash});
		const pageClean = page ? _DataLoaderInternalUtil.getCleanPage({page}) : null;

		this._CACHE.set(propClean, sourceClean, hashClean, ent);
		if (pageClean) this._CACHE.set(pageClean, sourceClean, hashClean, ent);
	}

	
	static _CACHE_SITE_SOURCE_CLEAN = null;

	static _doBuildSourceCaches () {
		this._CACHE_SITE_SOURCE_CLEAN = this._CACHE_SITE_SOURCE_CLEAN || new Set(Object.keys(Parser.SOURCE_JSON_TO_FULL)
			.map(src => _DataLoaderInternalUtil.getCleanSource({source: src})));
	}

	static _isSiteSource ({sourceClean}) {
		if (sourceClean === _DataLoaderConst.SOURCE_SITE_ALL) return true;
		if (sourceClean === _DataLoaderConst.SOURCE_BREW_ALL_CURRENT) return false;
		if (sourceClean === _DataLoaderConst.SOURCE_PRERELEASE_ALL_CURRENT) return false;

		this._doBuildSourceCaches();

		return this._CACHE_SITE_SOURCE_CLEAN.has(sourceClean);
	}

	static _isPrereleaseSource ({sourceClean}) {
		if (sourceClean === _DataLoaderConst.SOURCE_SITE_ALL) return false;
		if (sourceClean === _DataLoaderConst.SOURCE_BREW_ALL_CURRENT) return false;
		if (sourceClean === _DataLoaderConst.SOURCE_PRERELEASE_ALL_CURRENT) return true;

		this._doBuildSourceCaches();

		return sourceClean.startsWith(_DataLoaderInternalUtil.getCleanSource({source: Parser.SRC_UA_PREFIX}))
			|| sourceClean.startsWith(_DataLoaderInternalUtil.getCleanSource({source: Parser.SRC_UA_ONE_PREFIX}));
	}

	
	static getDiagnosticsSummary (diagnostics) {
		diagnostics = diagnostics.filter(Boolean);
		if (!diagnostics.length) return "";

		const filenames = diagnostics
			.map(it => it.filename)
			.filter(Boolean)
			.unique()
			.sort(SortUtil.ascSortLower);

		if (!filenames.length) return "";

		return `Filename${filenames.length === 1 ? " was" : "s were"}: ${filenames.map(it => `"${it}"`).join("; ")}.`;
	}
};




globalThis.DataLoader = DataLoader$1;

"use strict";

let UtilGenTables$1 = class UtilGenTables {
	static _getTableSectionIndex (sectionOrders, chapterName, sectionName) {
		((sectionOrders[chapterName] =
			sectionOrders[chapterName] || {})[sectionName] =
			sectionOrders[chapterName][sectionName] || 1);
		const val = sectionOrders[chapterName][sectionName];
		sectionOrders[chapterName][sectionName]++;
		return val;
	}

		static _doSearch (opts) {
		const {sectionOrders, path, tmpMeta, section, data, stacks, isRequireIncludes} = opts;

		if (data.data && data.data.tableIgnore) return;

		if (data.entries) {
			const nxtSection = data.name || section;
			if (data.name || data.page) {
				const {name, page} = data;
				path.push({name, page});
			}
			data.entries.forEach(ent => this._doSearch({...opts, section: nxtSection, data: ent}));
			if (data.name || data.page) path.pop();
		} else if (data.items) {
			if (data.name || data.page) {
				const {name, page} = data;
				path.push({name, page});
			}
			data.items.forEach(item => this._doSearch({...opts, data: item}));
			if (data.name || data.page) path.pop();
		} else if (data.type === "table" || data.type === "tableGroup") {
			if (isRequireIncludes && !(data.data && data.data[VeCt.ENTDATA_TABLE_INCLUDE])) return;

			const cpy = MiscUtil.copy(data);

			cpy._tmpMeta = MiscUtil.copy(tmpMeta);
			cpy.path = MiscUtil.copy(path);
			cpy.section = section;
			cpy.sectionIndex = this._getTableSectionIndex(sectionOrders, tmpMeta.name, section);

			stacks[data.type].push(cpy);
		}
	}

	static _getCleanSectionName (name) {
		return name.replace(/^(?:Step )?[-\d]+[:.]?\s*/, "");
	}

	static _isSectionInTitle (sections, title) {
		const lowTitle = title.toLowerCase();
		return sections.some(section => lowTitle.includes(section.toLowerCase()));
	}

	static _mutDataAddPage (table) {
		for (let i = table.path.length - 1; i >= 0; --i) {
			if (table.path[i].page) {
				table.page = table.path[i].page;
				break;
			}
		}
	}

	static _mutCleanData (table) {
		delete table.path;
		delete table.section;
		delete table.sectionIndex;

		if (table._tmpMeta.metaType === "adventure-book") {
			table.chapter = table._tmpMeta;
			delete table._tmpMeta;

						if (table.data && table.data.tableChapterIgnore) {
				delete table.chapter;
			} else {
				const chapterOut = {};
				chapterOut.name = table.chapter.name;
				chapterOut.ordinal = table.chapter.ordinal;
				chapterOut.index = table.chapter.index;
				table.chapter = chapterOut;
			}
		} else if (table._tmpMeta.metaType === "class") {
			table.parentEntity = {
				type: table._tmpMeta.metaType,
				name: table._tmpMeta.className,
				source: table._tmpMeta.classSource,
			};
			delete table._tmpMeta;
		} else if (table._tmpMeta.metaType === "subclass") {
			table.parentEntity = {
				type: table._tmpMeta.metaType,
				name: table._tmpMeta.subclassName,
				shortName: table._tmpMeta.subclassShortName,
				source: table._tmpMeta.subclassSource,
				className: table._tmpMeta.className,
				classSource: table._tmpMeta.classSource,
			};
			delete table._tmpMeta;
		} else {
			table.parentEntity = {
				type: table._tmpMeta.metaType,
				name: table._tmpMeta.name,
				source: table._tmpMeta.source,
			};
			delete table._tmpMeta;
		}

		if (table.type === "table") delete table.type;
		delete table.data;

		if (table.name) table.name = Renderer.stripTags(table.name);
	}

		static getAdventureBookTables (doc, opts) {
		const sectionOrders = {};
		const stacks = {table: [], tableGroup: []};

		if (!(doc[opts.headProp] && doc[opts.bodyProp])) return;

		doc[opts.bodyProp].data.forEach((chapter, ixChapter) => {
			const tmpMeta = MiscUtil.copy(doc[opts.headProp].contents[ixChapter]);
			tmpMeta.index = ixChapter;
			tmpMeta.metaType = "adventure-book";

			const path = [];
			this._doSearch({
				sectionOrders,
				path,
				tmpMeta: tmpMeta,
				section: doc[opts.headProp].name,
				data: chapter,
				stacks: stacks,
				isRequireIncludes: opts.isRequireIncludes,
			});
		});

		stacks.table.forEach(tbl => {
			const cleanSectionNames = tbl.path.filter(ent => ent.name).map(ent => this._getCleanSectionName(ent.name));

			if (tbl.data && tbl.data.tableNamePrefix && tbl.caption) {
				tbl.name = `${tbl.data.tableNamePrefix}; ${tbl.caption}`;
			} else if (tbl.data && tbl.data.tableName) {
				tbl.name = tbl.data.tableName;
			} else if (tbl.caption) {
				if (this._isSectionInTitle(cleanSectionNames, tbl.caption) || (tbl.data && tbl.data.skipSectionPrefix)) {
					tbl.name = tbl.caption;
				} else {
					tbl.name = `${cleanSectionNames.last()}; ${tbl.caption}`;
				}
			} else {
								if (tbl.sectionIndex === 1 && sectionOrders[tbl._tmpMeta.name][tbl.section] === 2) {
					tbl.name = cleanSectionNames.last();
				} else {
					tbl.name = `${cleanSectionNames.last()}; ${tbl.sectionIndex}`;
				}
			}

			this._mutDataAddPage(tbl);
			tbl.source = doc[opts.headProp].source || doc[opts.headProp].id;
			this._mutCleanData(tbl);
		});

		stacks.tableGroup.forEach(tg => {
			const cleanSections = tg.path.filter(ent => ent.name).map(ent => this._getCleanSectionName(ent.name));
			if (!tg.name) throw new Error("Group had no name!");

			if (!this._isSectionInTitle(cleanSections, tg.name)) {
				tg.name = `${cleanSections.last()}; ${tg.name}`;
			}

			this._mutDataAddPage(tg);
			tg.source = doc[opts.headProp].source || doc[opts.headProp].id;
			this._mutCleanData(tg);
		});

		return stacks;
	}

	static getClassTables (cls) {
		const sectionOrders = {};
		const stacks = {table: [], tableGroup: []};
		const path = [];

		cls.classFeatures.forEach((lvl, lvlI) => {
			const tmpMeta = {
				metaType: "class",
				className: cls.name,
				classSource: cls.source || Parser.SRC_PHB,
				level: lvlI + 1,
			};

			lvl.forEach(feat => this._doSearch({
				sectionOrders,
				path,
				tmpMeta,
				section: cls.name,
				data: feat,
				stacks: stacks,
				isRequireIncludes: true,

								name: cls.name,
			}));
		});

		stacks.table.forEach(it => {
			it.name = it.caption;
			it.source = it._tmpMeta.subclassSource || it._tmpMeta.classSource;
			it.srd = !!cls.srd;

			this._mutDataAddPage(it);
			this._mutCleanData(it);
		});

		return stacks;
	}

	static getSubclassTables (sc) {
		const sectionOrders = {};
		const stacks = {table: [], tableGroup: []};
		const path = [];

		sc.subclassFeatures.forEach(lvl => {
			const level = lvl[0].level;

			const tmpMeta = {
				metaType: "subclass",
				className: sc.className,
				classSource: sc.classSource || Parser.SRC_PHB,
				level,
				subclassName: sc.name,
				subclassShortName: sc.shortName,
				subclassSource: sc.source || sc.classSource || Parser.SRC_PHB,

								name: sc.name,
			};

			lvl.forEach(feat => this._doSearch({
				sectionOrders,
				path,
				tmpMeta,
				section: sc.className,
				data: feat,
				stacks: stacks,
				isRequireIncludes: true,
			}));
		});

		stacks.table.forEach(it => {
			it.name = it.caption;
			it.source = it._tmpMeta.subclassSource || it._tmpMeta.classSource;
			it.srd = !!sc.srd;

			this._mutDataAddPage(it);
			this._mutCleanData(it);
		});

		return stacks;
	}

	static getGenericTables (entity, metaType, ...props) {
		const sectionOrders = {};
		const stacks = {table: [], tableGroup: []};
		const path = [];

		props.forEach(prop => {
			if (!entity[prop]) return;
			const tmpMeta = {
				metaType: metaType,
				name: entity.name,
				source: entity.source,
			};

			entity[prop].forEach(ent => {
				this._doSearch({
					sectionOrders,
					path,
					tmpMeta,
					section: entity.name,
					data: ent,
					stacks: stacks,
					isRequireIncludes: true,

										name: entity.name,
				});
			});
		});

		stacks.table.forEach(it => {
			it.name = it.caption;
			it.source = it._tmpMeta.source;

			this._mutDataAddPage(it);
			this._mutCleanData(it);
		});

		return stacks;
	}
};

globalThis.UtilGenTables = UtilGenTables$1;

class SharedConsts {}

SharedConsts.MODULE_TITLE = "banana";
SharedConsts.MODULE_TITLE_FAKE = "SRD: Enhanced";
SharedConsts.MODULE_ID = "banana";
SharedConsts.MODULE_ID_FAKE = "srd5e";

SharedConsts.PACK_NAME_CREATURES = "creatures";
SharedConsts.PACK_NAME_SPELLS = "spells";
SharedConsts.PACK_NAME_ITEMS = "items";

SharedConsts.MODULE_LOCATION = `modules/${SharedConsts.MODULE_ID}`;

class Util {
	static _getLogTag () {
		return [
			`%cbanana`,
			`color: #337ab7; font-weight: bold;`,
			`|`,
		];
	}

	static isDebug () {
		return !!CONFIG?.debug?.module?.[SharedConsts.MODULE_ID];
	}

		static _HEIGHT_MAX_OFFSET = 160;
	static getMaxWindowHeight (desiredHeight) {
		const targetHeight = Math.min(desiredHeight || Number.MAX_SAFE_INTEGER, document.documentElement.clientHeight - this._HEIGHT_MAX_OFFSET);
		return Math.max(this._HEIGHT_MAX_OFFSET, targetHeight);
	}

	static _WIDTH_MAX_OFFSET = 250;
	static getMaxWindowWidth (desiredWidth) {
		const targetWidth = Math.min(desiredWidth || Number.MAX_SAFE_INTEGER, document.documentElement.clientWidth - this._WIDTH_MAX_OFFSET);
		return Math.max(this._WIDTH_MAX_OFFSET, targetWidth);
	}
	
		static getWithoutParens (str) { return str.replace(/\([^)]+\)/g, "").trim(); }
	static getTokens (str) { return str.split(/([ ,:;()"])/g).filter(Boolean); }
	static isPunctuation (token) { return /[,:;()"]/.test(token); }
	static isCapsFirst (word) { return /^[A-Z]/.test(word); }
	static getSentences (str) { return str.replace(/ +/g, " ").split(/[.?!]/g).map(it => it.trim()).filter(Boolean); }
	
		static getRounded (n, dp) { return Number(n.toFixed(dp)); }
	
	static trimObject (obj) {
		const walker = MiscUtil.getWalker({
			isAllowDeleteObjects: true,
			isDepthFirst: true,
		});

		return walker.walk(
			obj,
			{
				object: (it) => {
					Object.entries(it).forEach(([k, v]) => {
						if (v === undefined) delete it[k];
					});
					if (!Object.keys(it).length) return undefined;
					return it;
				},
			},
		);
	}

	static getCleanServerUrl (url) {
		return url.replace(/^(.*?)\/*$/, "$1/");
	}
}

const LGT = Util._getLogTag();

Util.Fvtt = class {
	static getOwnershipEnum ({isIncludeDefault = false} = {}) {
		return [
			isIncludeDefault ? {value: -1, name: "Default"} : null,
						...Object.entries(CONST.DOCUMENT_OWNERSHIP_LEVELS).map(([name, value]) => ({
				value,
				name: name.toTitleCase(),
			})),
		].filter(Boolean);
	}

	static getMinimumRolesEnum () {
		return [
			...Object.entries(CONST.USER_ROLES).map(([name, value]) => ({
				value,
				name: name.toTitleCase(),
			})),
			{
				value: CONST.USER_ROLES.GAMEMASTER + 1,
				name: `Cheater (Disable Feature)`,
			},
		];
	}

	static canUserCreateFolders () { return game.user.isGM; }
};

Util.Slugify = class {
	static _CHAR_MAP = JSON.parse(`{"$":"dollar","%":"percent","&":"and","<":"less",">":"greater","|":"or","¢":"cent","£":"pound","¤":"currency","¥":"yen","©":"(c)","ª":"a","®":"(r)","º":"o","À":"A","Á":"A","Â":"A","Ã":"A","Ä":"A","Å":"A","Æ":"AE","Ç":"C","È":"E","É":"E","Ê":"E","Ë":"E","Ì":"I","Í":"I","Î":"I","Ï":"I","Ð":"D","Ñ":"N","Ò":"O","Ó":"O","Ô":"O","Õ":"O","Ö":"O","Ø":"O","Ù":"U","Ú":"U","Û":"U","Ü":"U","Ý":"Y","Þ":"TH","ß":"ss","à":"a","á":"a","â":"a","ã":"a","ä":"a","å":"a","æ":"ae","ç":"c","è":"e","é":"e","ê":"e","ë":"e","ì":"i","í":"i","î":"i","ï":"i","ð":"d","ñ":"n","ò":"o","ó":"o","ô":"o","õ":"o","ö":"o","ø":"o","ù":"u","ú":"u","û":"u","ü":"u","ý":"y","þ":"th","ÿ":"y","Ā":"A","ā":"a","Ă":"A","ă":"a","Ą":"A","ą":"a","Ć":"C","ć":"c","Č":"C","č":"c","Ď":"D","ď":"d","Đ":"DJ","đ":"dj","Ē":"E","ē":"e","Ė":"E","ė":"e","Ę":"e","ę":"e","Ě":"E","ě":"e","Ğ":"G","ğ":"g","Ģ":"G","ģ":"g","Ĩ":"I","ĩ":"i","Ī":"i","ī":"i","Į":"I","į":"i","İ":"I","ı":"i","Ķ":"k","ķ":"k","Ļ":"L","ļ":"l","Ľ":"L","ľ":"l","Ł":"L","ł":"l","Ń":"N","ń":"n","Ņ":"N","ņ":"n","Ň":"N","ň":"n","Ő":"O","ő":"o","Œ":"OE","œ":"oe","Ŕ":"R","ŕ":"r","Ř":"R","ř":"r","Ś":"S","ś":"s","Ş":"S","ş":"s","Š":"S","š":"s","Ţ":"T","ţ":"t","Ť":"T","ť":"t","Ũ":"U","ũ":"u","Ū":"u","ū":"u","Ů":"U","ů":"u","Ű":"U","ű":"u","Ų":"U","ų":"u","Ŵ":"W","ŵ":"w","Ŷ":"Y","ŷ":"y","Ÿ":"Y","Ź":"Z","ź":"z","Ż":"Z","ż":"z","Ž":"Z","ž":"z","ƒ":"f","Ơ":"O","ơ":"o","Ư":"U","ư":"u","ǈ":"LJ","ǉ":"lj","ǋ":"NJ","ǌ":"nj","Ș":"S","ș":"s","Ț":"T","ț":"t","˚":"o","Ά":"A","Έ":"E","Ή":"H","Ί":"I","Ό":"O","Ύ":"Y","Ώ":"W","ΐ":"i","Α":"A","Β":"B","Γ":"G","Δ":"D","Ε":"E","Ζ":"Z","Η":"H","Θ":"8","Ι":"I","Κ":"K","Λ":"L","Μ":"M","Ν":"N","Ξ":"3","Ο":"O","Π":"P","Ρ":"R","Σ":"S","Τ":"T","Υ":"Y","Φ":"F","Χ":"X","Ψ":"PS","Ω":"W","Ϊ":"I","Ϋ":"Y","ά":"a","έ":"e","ή":"h","ί":"i","ΰ":"y","α":"a","β":"b","γ":"g","δ":"d","ε":"e","ζ":"z","η":"h","θ":"8","ι":"i","κ":"k","λ":"l","μ":"m","ν":"n","ξ":"3","ο":"o","π":"p","ρ":"r","ς":"s","σ":"s","τ":"t","υ":"y","φ":"f","χ":"x","ψ":"ps","ω":"w","ϊ":"i","ϋ":"y","ό":"o","ύ":"y","ώ":"w","Ё":"Yo","Ђ":"DJ","Є":"Ye","І":"I","Ї":"Yi","Ј":"J","Љ":"LJ","Њ":"NJ","Ћ":"C","Џ":"DZ","А":"A","Б":"B","В":"V","Г":"G","Д":"D","Е":"E","Ж":"Zh","З":"Z","И":"I","Й":"J","К":"K","Л":"L","М":"M","Н":"N","О":"O","П":"P","Р":"R","С":"S","Т":"T","У":"U","Ф":"F","Х":"H","Ц":"C","Ч":"Ch","Ш":"Sh","Щ":"Sh","Ъ":"U","Ы":"Y","Ь":"","Э":"E","Ю":"Yu","Я":"Ya","а":"a","б":"b","в":"v","г":"g","д":"d","е":"e","ж":"zh","з":"z","и":"i","й":"j","к":"k","л":"l","м":"m","н":"n","о":"o","п":"p","р":"r","с":"s","т":"t","у":"u","ф":"f","х":"h","ц":"c","ч":"ch","ш":"sh","щ":"sh","ъ":"u","ы":"y","ь":"","э":"e","ю":"yu","я":"ya","ё":"yo","ђ":"dj","є":"ye","і":"i","ї":"yi","ј":"j","љ":"lj","њ":"nj","ћ":"c","ѝ":"u","џ":"dz","Ґ":"G","ґ":"g","Ғ":"GH","ғ":"gh","Қ":"KH","қ":"kh","Ң":"NG","ң":"ng","Ү":"UE","ү":"ue","Ұ":"U","ұ":"u","Һ":"H","һ":"h","Ә":"AE","ә":"ae","Ө":"OE","ө":"oe","฿":"baht","ა":"a","ბ":"b","გ":"g","დ":"d","ე":"e","ვ":"v","ზ":"z","თ":"t","ი":"i","კ":"k","ლ":"l","მ":"m","ნ":"n","ო":"o","პ":"p","ჟ":"zh","რ":"r","ს":"s","ტ":"t","უ":"u","ფ":"f","ქ":"k","ღ":"gh","ყ":"q","შ":"sh","ჩ":"ch","ც":"ts","ძ":"dz","წ":"ts","ჭ":"ch","ხ":"kh","ჯ":"j","ჰ":"h","Ẁ":"W","ẁ":"w","Ẃ":"W","ẃ":"w","Ẅ":"W","ẅ":"w","ẞ":"SS","Ạ":"A","ạ":"a","Ả":"A","ả":"a","Ấ":"A","ấ":"a","Ầ":"A","ầ":"a","Ẩ":"A","ẩ":"a","Ẫ":"A","ẫ":"a","Ậ":"A","ậ":"a","Ắ":"A","ắ":"a","Ằ":"A","ằ":"a","Ẳ":"A","ẳ":"a","Ẵ":"A","ẵ":"a","Ặ":"A","ặ":"a","Ẹ":"E","ẹ":"e","Ẻ":"E","ẻ":"e","Ẽ":"E","ẽ":"e","Ế":"E","ế":"e","Ề":"E","ề":"e","Ể":"E","ể":"e","Ễ":"E","ễ":"e","Ệ":"E","ệ":"e","Ỉ":"I","ỉ":"i","Ị":"I","ị":"i","Ọ":"O","ọ":"o","Ỏ":"O","ỏ":"o","Ố":"O","ố":"o","Ồ":"O","ồ":"o","Ổ":"O","ổ":"o","Ỗ":"O","ỗ":"o","Ộ":"O","ộ":"o","Ớ":"O","ớ":"o","Ờ":"O","ờ":"o","Ở":"O","ở":"o","Ỡ":"O","ỡ":"o","Ợ":"O","ợ":"o","Ụ":"U","ụ":"u","Ủ":"U","ủ":"u","Ứ":"U","ứ":"u","Ừ":"U","ừ":"u","Ử":"U","ử":"u","Ữ":"U","ữ":"u","Ự":"U","ự":"u","Ỳ":"Y","ỳ":"y","Ỵ":"Y","ỵ":"y","Ỷ":"Y","ỷ":"y","Ỹ":"Y","ỹ":"y","‘":"'","’":"'","“":"\\"","”":"\\"","†":"+","•":"*","…":"...","₠":"ecu","₢":"cruzeiro","₣":"french franc","₤":"lira","₥":"mill","₦":"naira","₧":"peseta","₨":"rupee","₩":"won","₪":"new shequel","₫":"dong","€":"euro","₭":"kip","₮":"tugrik","₯":"drachma","₰":"penny","₱":"peso","₲":"guarani","₳":"austral","₴":"hryvnia","₵":"cedi","₸":"kazakhstani tenge","₹":"indian rupee","₽":"russian ruble","₿":"bitcoin","℠":"sm","™":"tm","∂":"d","∆":"delta","∑":"sum","∞":"infinity","♥":"love","元":"yuan","円":"yen","﷼":"rial"}`);

	static _RES_REPLACEMENT = {};
	static _RES_REPLACEMENT_STRICT = {};

	static slugifyFast ({replacement = "-", strict = false} = {}) {
				let accum = "";
		for (const char of this.split("")) {
			accum += Util.Slugify._CHAR_MAP[char] || char;
		}
		let slug = accum.trim().toLowerCase();

		const repl1 = (Util.Slugify._RES_REPLACEMENT[replacement] = Util.Slugify._RES_REPLACEMENT[replacement] || new RegExp(`[\\s${replacement}]+`, "g"));

				slug = slug.replace(repl1, replacement);

				if (strict) {
			const repl2 = (Util.Slugify._RES_REPLACEMENT_STRICT[replacement] = Util.Slugify._RES_REPLACEMENT_STRICT[replacement] || new RegExp(`[^a-zA-Z0-9${replacement}]`, "g"));

			slug = slug.replace(repl2, "");
		}

		return slug;
	}
};

class Consts {
	static RUN_TIME = `${Date.now()}`;
	static FLAG_IFRAME_URL = "iframe_url";

	static TERMS_COUNT = [
		{tokens: ["once"], count: 1},
		{tokens: ["twice"], count: 2},
		{tokens: ["thrice"], count: 3},
		{tokens: ["three", " ", "times"], count: 3},
		{tokens: ["four", " ", "times"], count: 4},
	];

	static Z_INDEX_MAX_FOUNDRY = 9999;

	static ACTOR_TEMP_NAME = "Importing...";

	static CHAR_MAX_LEVEL = 20;

	static RE_ID_STR = `[A-Za-z0-9]{16}`;
	static RE_ID = new RegExp(`^${this.RE_ID_STR}$`);

	static FLAG_IS_DEV_CLEANUP = "isDevCleanup";

		static USER_DATA_TRACKING_KEYS__ACTOR = [
		"system.details.biography.value",

		"system.attributes.hp.value",
		"system.attributes.death.success",
		"system.attributes.death.failure",
		"system.attributes.exhaustion",
		"system.attributes.inspiration",

		"system.details.xp.value",

		"system.resources.primary.value",
		"system.resources.secondary.value",
		"system.resources.tertiary.value",
		"system.resources.legact.value",
		"system.resources.legres.value",
		"system.resources.lair.value",

		"system.currency.cp",
		"system.currency.sp",
		"system.currency.ep",
		"system.currency.gp",
		"system.currency.pp",
	];
}

class ConstsTaskRunner {
	static TASK_EXIT_COMPLETE = Symbol("taskExitComplete");
	static TASK_EXIT_CANCELLED = Symbol("taskExitCancelled");
	static TASK_EXIT_SKIPPED_DUPLICATE = Symbol("taskExitSkippedDuplicate");
	static TASK_EXIT_SKIPPED_OTHER = Symbol("taskExitSkippedOther");
	static TASK_EXIT_COMPLETE_UPDATE_OVERWRITE = Symbol("taskExitCompleteOverwrite");
	static TASK_EXIT_COMPLETE_UPDATE_OVERWRITE_DUPLICATE = Symbol("taskExitCompleteOverwriteDuplicate");
	static TASK_EXIT_FAILED = Symbol("taskExitCompleteFailed");
	static TASK_EXIT_COMPLETE_DATA_ONLY = Symbol("taskExitCompleteDataOnly");
}

class UtilApplications {
	static async $pGetAddAppLoadingOverlay ($appHtml) {
		if (!$appHtml) return null;
		$appHtml.css("position", "relative");
		const $out = $(`<div class="veapp-loading__wrp-outer"><i>Loading...</i></div>`).focus().appendTo($appHtml);
				await MiscUtil.pDelay(5);
		return $out;
	}

		static pGetConfirmation (opts) {
		opts = opts || {};

		return new Promise(resolve => {
			new Dialog({
				title: opts.title,
				content: opts.content,
				buttons: {
					yes: {
						icon: `<i class="fas fa-fw ${opts.faIcon}"></i>`,
						label: opts.confirmText,
						callback: () => resolve(true),
					},
					no: {
						icon: `<i class="fas fa-fw fa-times"></i>`,
						label: opts.dismissText || "Cancel",
						callback: () => resolve(false),
					},
				},
				default: "yes",
			}).render(true);
		});
	}

	static getCleanEntityName (name) {
				return name || " ";
	}

		static getFolderPath (fvttEntity, opts) {
		opts = opts || {};
		const {isAddTrailingSlash, root} = opts;

		const stack = this.getFolderPathFolders(fvttEntity, {root});
		if (!stack?.length) return null;
		const out = stack.map(it => it.name).join("/");
		if (out) return isAddTrailingSlash ? `${out}/` : out;
		return null;
	}

	static getFolderPathFolders (fvttEntity, {root = null} = {}) {
		if (!fvttEntity) return [];

		const stack = [];
		if (fvttEntity.folder && root?.id !== fvttEntity.folder.id) {
			stack.push(fvttEntity.folder);
			let parent = fvttEntity.folder?.folder;
			while (parent?.id && root?.id !== parent?.id) {
				stack.push(parent);
				parent = parent.folder;
			}
		}

		return stack.reverse();
	}

	static getFolderList (folderType) {
		const sortFolders = (a, b) => SortUtil.ascSort(a.sort, b.sort);

		const raw = CONFIG.Folder.collection.instance.contents
			.filter(it => it.type === folderType)
			.sort(sortFolders);
		if (!raw.length) return raw;

		const maxDepth = Math.max(...raw.map(it => it.depth));

		const out = raw.filter(it => it.depth === 1);
		if (out.length === raw.length) return out;

		for (let i = 2; i < maxDepth + 1; ++i) {
			const atDepth = raw.filter(it => it.depth === i).sort(sortFolders).reverse();
			atDepth.forEach(it => {
				const ixParent = out.findIndex(parent => parent.id === it.folder?.id);
				if (~ixParent) out.splice(ixParent + 1, 0, it);
			});
		}

		return out;
	}

	static bringToFront (app) {
				if (!app._element) return;

				if (typeof _maxZ === "undefined") window._maxZ = 100;

				if (Object.keys(ui.windows).length === 0) _maxZ = 100;
		app._element.css({zIndex: Math.min(++_maxZ, Consts.Z_INDEX_MAX_FOUNDRY)});
	}

	
	static doShowImportedNotification (importSummary) {
		if (!importSummary) return;

		if (!importSummary.status) { 			importSummary.status = ConstsTaskRunner.TASK_EXIT_COMPLETE;
			const msg = `Could not display import notifications\u2014import status was not defined. This is a bug!`;
			ui.notifications.error(msg);
			console.error(new Error(msg));
		}

		const firstDoc = importSummary.imported?.[0]?.document
			|| importSummary.imported?.[0]?.embeddedDocument;

		const name = importSummary.name
			|| importSummary.imported?.[0]?.name
			|| firstDoc?.name
			|| "(Unnamed Entity)";

		if (importSummary.status === ConstsTaskRunner.TASK_EXIT_CANCELLED) return ui.notifications.warn(`Import of "${name}" cancelled.`);
		else if (importSummary.status === ConstsTaskRunner.TASK_EXIT_SKIPPED_DUPLICATE) return ui.notifications.warn(`Import of "${name}" was skipped (duplicate found).`);
		else if (importSummary.status === ConstsTaskRunner.TASK_EXIT_SKIPPED_OTHER) return ui.notifications.warn(`Import of "${name}" was skipped.`);
		else if (importSummary.status === ConstsTaskRunner.TASK_EXIT_FAILED) return ui.notifications.error(`Failed to import "${name}"! ${VeCt.STR_SEE_CONSOLE}`);

		if (importSummary.imported?.[0]?.actor) {
			ui.notifications.info(`Imported "${name}" to actor "${importSummary.imported?.[0]?.actor.name}".`);
			return;
		}

		const folderPath = UtilApplications.getFolderPath(firstDoc);
		if (folderPath) {
			const folderType = firstDoc?.folder?.type;
			ui.notifications.info(`Imported "${name}" to ${folderType} folder "${folderPath}".`);
			return;
		}

		if (firstDoc.pack) {
			const pack = game.packs.get(firstDoc.pack);
			ui.notifications.info(`Imported "${name}" to ${pack.metadata.type} compendium "${pack.metadata.label}".`);
			return;
		}

		ui.notifications.info(`Imported "${name}".`);
	}

	
	static setApplicationTitle (app, title) {
		app.options.title = title;
		UtilApplications.$getAppElement(app).find(`.window-title`).text(app.title);
	}

	static getDataName (data) {
		return data?.actor?.name || data?.document?.name;
	}

			static async pGetImportCompApplicationFormData (opts) {
		let resolve, reject;
		const promise = new Promise((resolve_, reject_) => {
			resolve = resolve_; reject = reject_;
		});

		const ptrPRender = {_: null};

		const app = new class TempApplication extends Application {
			constructor () {
				super({
					title: opts.comp.modalTitle,
					template: `${SharedConsts.MODULE_LOCATION}/template/_Generic.hbs`,
					width: opts.width != null ? opts.width : 480,
					height: opts.height != null ? opts.height : 640,
					resizable: true,
				});
			}

			async close (...args) {
				await super.close(...args);
				resolve(null);
			}

			activateListeners (html) {
				const $btnOk = $(`<button class="btn btn-primary mr-2">OK</button>`)
					.click(async () => {
						const formData = await opts.comp.pGetFormData();

						if (opts.fnGetInvalidMeta) {
							const invalidMeta = opts.fnGetInvalidMeta(formData);
							if (invalidMeta) return ui.notifications[invalidMeta.type](invalidMeta.message);
						}

						resolve(formData);
						return this.close();
					});
				const $btnCancel = $(`<button class="btn btn-default">Cancel</button>`)
					.click(() => {
						resolve(null); return this.close();
					});
				const $btnSkip = opts.isUnskippable ? null : $(`<button class="btn btn-default ml-3">Skip</button>`)
					.click(() => {
						resolve(VeCt.SYM_UI_SKIP); return this.close();
					});

				if (opts.comp.pRender) ptrPRender._ = opts.comp.pRender(html);
				else opts.comp.render(html);
				$$`<div class="ve-flex-v-center ve-flex-h-right no-shrink pb-1 pt-1 px-1 mt-auto mr-3">${$btnOk}${$btnCancel}${$btnSkip}</div>`.appendTo(html);
			}
		}();

		opts.comp.app = app;
		await app.render(true);

		if (opts.isAutoResize) this.autoResizeApplication(app, {ptrPRender});

		return promise;
	}
	
			static async pGetShowApplicationModal (
		{
			title,
			cbClose,

			isWidth100,
			isHeight100,

			isMaxWidth640p,
			isMinHeight0,

			isIndestructible,
			isClosed,
		},
	) {
		let hasClosed = false;

		let resolveModal;
		const pResolveModal = new Promise(resolve => { resolveModal = resolve; });

		const app = new class TempApplication extends MixinHidableApplication(Application) {
			constructor () {
				super({
					title: title || " ",
					template: `${SharedConsts.MODULE_LOCATION}/template/_Generic.hbs`,
					width: isWidth100
						? Util.getMaxWindowWidth(1170)
						: isMaxWidth640p
							? 640
							: 480,
					height: isHeight100
						? Util.getMaxWindowHeight()
						: isMinHeight0
							? 100
							: 640,
					resizable: true,
				});
			}

			async _closeNoSubmit () {
				return super.close();
			}

			async close (...args) {
				await pHandleCloseClick(false);
				return super.close(...args);
			}

			async _render (...args) {
				await super._render(...args);
				out.$modal = out.$modalInner = this.element.find(`.ve-window`);
				hasClosed = false;
			}
		}();

		if (isIndestructible) app.isClosable = false;

		const pHandleCloseClick = async (isDataEntered, ...args) => {
						if (!isIndestructible && hasClosed) return;

			hasClosed = true;

			if (cbClose) await cbClose(isDataEntered, ...args);
			if (!isIndestructible) resolveModal([isDataEntered, ...args]);

			await app._closeNoSubmit();
		};

		const out = {
			$modal: null,
			$modalInner: null,
			doClose: pHandleCloseClick,
			doAutoResize: () => this.autoResizeApplicationExisting(app),
			pGetResolved: () => pResolveModal,
			doOpen: () => app._render(true),
			doTeardown: () => app._pDoHardClose(),
		};

		await app._render(true);
		if (isClosed) app._doSoftClose();

		return out;
	}

	/**
	 * 
	 * Resize an app based on the content that is currently visible inside it.
	 * @param app The app to resize.
	 * @param ptrPRender Pointer to a promise which will resolve when the app is rendered.
	 */
	static autoResizeApplication (app, {ptrPRender} = {}) {
		Hooks.once("renderApplication", async _app => {
			if (_app !== app) return;
			if (ptrPRender?._) await ptrPRender._;

			this.autoResizeApplicationExisting(app);
		});
	}

	static autoResizeApplicationExisting (app) {
				const centerPrev = app.position.top + app.position.height / 2;

				const pos = app.setPosition({
			width: app.position.width, 			height: "auto",
		});

				const center = pos.top + pos.height / 2;
		app.setPosition({
			width: app.position.width,
			height: app.position.height,
			top: app.position.top + (centerPrev - center),
		});
	}

		static async pForceRenderApp (app, renderForce = true, renderOpts) {
		let resolve;
		const p = new Promise((resolve_) => { resolve = resolve_; });

		Hooks.once(`render${app.constructor.name}`, async (_app, $html, data) => {
			if (_app !== app) return;
			resolve({app, $html, data});
		});

		app.render(renderForce, renderOpts);

		return Promise.race([p, MiscUtil.pDelay(5000)]);
	}

	static isClosed (app) { return app._state < Application.RENDER_STATES.NONE; }

	/**
	 * 
	 * Auto-convert non-jQuery app elements, as some modules use bare DOM elements.
	 * @param app
	 */
	static $getAppElement (app) {
		if (!app?.element) return null;
		if (app.element instanceof jQuery) return app.element;
		return $(app.element);
	}

	static pAwaitAppClose (app) {
		return new Promise(resolve => {
			const fnOnClose = (closedApp) => {
				if (app.appId !== closedApp.appId) return;
				Hooks.off("closeApplication", fnOnClose);
				resolve(closedApp);
			};
			Hooks.on("closeApplication", fnOnClose);
		});
	}

	static getOpenAppsSortedByZindex ({isFilterInvalid = false} = {}) {
		return Object.entries(ui.windows)
			.map(([appId, app]) => {
				const zIndex = Number((((UtilApplications.$getAppElement(app)[0] || {}).style || {})["z-index"] || -1));

				if (isNaN(zIndex) || !~zIndex) {
					if (Util.isDebug()) console.warn(`Could not determine z-index for app ${appId}`);
					if (isFilterInvalid) return null;
				}

				return {
					appId,
					app,
					zIndex: isNaN(zIndex) ? -1 : zIndex,
				};
			})
			.filter(Boolean)
			.sort((a, b) => SortUtil.ascSort(a.zIndex, b.zIndex))
			.map(({app}) => app);
	}
}

function MixinHidableApplication (Cls) {
	class MixedHidableApplication extends Cls {
		constructor (...args) {
			super(...args);

			this._isClosable = true;
			this._isHidden = false;
			this._isRendered = false;
		}

		set isClosable (val) { this._isClosable = !!val; }

		get isEscapeable () {
			if (this._isClosable) return true;
			else return !this._isHidden;
		}

		async _close_isAlwaysHardClose () {
			return false;
		}

		async _close_doHardCloseTeardown () {
					}

		async close (...args) {
			if (this._isClosable || await this._close_isAlwaysHardClose()) {
				await this._close_doHardCloseTeardown();
				this._isRendered = false;
				return super.close(...args);
			}

			this._doSoftClose();
		}

		_doSoftClose () {
			this._isHidden = true;
			this.element.hideVe();
		}

		async _pDoHardClose () {
			this._isClosable = true;
			return this.close();
		}

		async _pPostRenderOrShow () {
					}

		async _render (...args) {
			if (!this._isHidden && this._isRendered) {
				this._doSoftOpen();
				return;
			}

			if (this._isHidden) {
				this._doSoftOpen();
				await this._pPostRenderOrShow();
				return;
			}

			await super._render(...args);
			await this._pPostRenderOrShow();

			this._isRendered = true;
		}

		_doSoftOpen () {
			this.element.showVe();
			this._isHidden = false;
			this.maximize();
			UtilApplications.bringToFront(this);
		}

		async showAndRender (renderForce, renderOpts) {
			if (this._isHidden) {
				this.element.showVe();
				this._isHidden = false;
			}

			await UtilApplications.pForceRenderApp(this, renderForce, renderOpts);
		}
	}
	return MixedHidableApplication;
}

class UtilGameSettings {
	static prePreInit () {
		game.settings.register(SharedConsts.MODULE_ID, "isDbgMode", {
			name: `Debug Mode`,
			hint: `Enable additional developer-only debugging functionality. Not recommended, as it may reduce stability.`,
			default: false,
			type: Boolean,
			scope: "world",
			config: true,
		});
	}

	static isDbg () { return !!this.getSafe(SharedConsts.MODULE_ID, "isDbgMode"); }

	static getSafe (module, key) {
		try {
			return game.settings.get(module, key);
		} catch (e) {
			return null;
		}
	}
}

class UtilVersions {
	static getCoreVersion () {
		let [major, minor] = (game.version || "").split(".");
		major = Number(major);
		minor = Number(minor);
		if (isNaN(major) || isNaN(minor)) throw new Error(`Could not parse game version "${game.version}"!`);
		return {major, minor, isVersionElevenPlus: major >= 11};
	}

	static getSystemVersion () {
		const system = game.system?.id || "";
		const version = game.system?.version || "";

		try {
			const {major, minor, patch} = this.getVersionParts(version);
			return {major, minor, patch, system, version, isVersionTwoOnePlus: major >= 2 && minor >= 1};
		} catch (e) {
			console.warn(...LGT, `Could not parse system version: "${version}"`);
			return {isUnknownVersion: true, system, version};
		}
	}

	
	static getVersionParts (version) {
		let [major, minor, patch] = version.split(".");

				patch = patch.split("-")[0];

		major = Number(major);
		minor = Number(minor);
		patch = Number(patch);
		if (isNaN(major) || isNaN(minor) || isNaN(patch)) {
			throw new Error(`Could not parse version number "${version}"!`);
		}
		return {major, minor, patch};
	}

	
	static getVersionComparison ({min, max, version}) {
		const {major, minor, patch} = this.getVersionParts(version);

		const isBelowMin = min
			? major < min.major
			|| (major === min.major && minor < min.minor)
			|| (major === min.major && minor === min.minor && patch < min.patch)
			: false;
		const isAboveMax = max
			? major > max.major
			|| (major === max.major && minor > max.minor)
			|| (major === max.major && minor === max.minor && patch > max.patch)
			: false;

		return {isBelowMin, isAboveMax, isInRange: !isBelowMin && !isAboveMax};
	}
}

class UtilCompat {
	static init () {
		this._init_doShowNotification().then(null);
	}

	static async _init_doShowNotification () {
		if (!game.user.isGM) return;

		const {system, isUnknownVersion, version} = UtilVersions.getSystemVersion();

						if (isUnknownVersion) return;

		const supportedSystemMeta = this._SYSTEMS_SUPPORTED[system];
		if (!supportedSystemMeta) return; 
		const {isBelowMin, isAboveMax, isInRange} = UtilVersions.getVersionComparison({
			...supportedSystemMeta,
			version: version,
		});
		if (isInRange) return;

		const {Config} = await Promise.resolve().then(function () { return Config$1; });

		ui.notifications.warn(`Game system "${system}" version ${version} is ${[isBelowMin ? `below the minimum required version (${this._getVersionString(supportedSystemMeta.min)})` : null, isAboveMax ? `above the maximum supported version (${this._getVersionString(supportedSystemMeta.max)})` : null].filter(Boolean).join(" and ")} for use with ${Config.get("ui", "isStreamerMode") ? SharedConsts.MODULE_TITLE_FAKE : SharedConsts.MODULE_TITLE}. Please ${isAboveMax ? "downgrade" : "upgrade"} your system version.`);
	}

	static _getVersionString (versionDict) { return `${versionDict.major}.${versionDict.minor}.${versionDict.patch}`; }

	static isModuleActive (moduleId) { return !!game.modules.get(moduleId)?.active; }

	static isLibWrapperActive () { return this.isModuleActive(UtilCompat._MODULE_LIB_WRAPPER); }
	static isDaeActive () { return this.isModuleActive(UtilCompat.MODULE_DAE); }
	static isDragUploadActive () { return this.isModuleActive(UtilCompat._MODULE_DRAG_UPLOAD); }
	static isPermissionViewerActive () { return this.isModuleActive(UtilCompat.MODULE_PERMISSION_VIEWER); }
	static isSmolFoundryActive () { return this.isModuleActive(UtilCompat.MODULE_SMOL_FOUNDRY); }
	static isTwilightUiActive () { return this.isModuleActive(UtilCompat._MODULE_TWILIGHT_UI); }
	static isTidy5eSheetActive () { return this.isModuleActive(UtilCompat.MODULE_TIDY5E_SHEET); }
	static isObsidianActive () { return this.isModuleActive(UtilCompat._MODULE_OBSIDIAN); }
	static isBabeleActive () { return this.isModuleActive(UtilCompat.MODULE_BABELE); }
	static isMonksLittleDetailsActive () { return this.isModuleActive(UtilCompat.MODULE_MONKS_LITTLE_DETAILS); }
	static isMonksBloodsplatsActive () { return this.isModuleActive(UtilCompat.MODULE_MONKS_BLOODSPLATS); }
	static isBetterRolltablesActive () { return this.isModuleActive(UtilCompat.MODULE_BETTER_ROLLTABLES); }
	static isItemPilesActive () { return this.isModuleActive(UtilCompat._MODULE_BETTER_ROLLTABLES); }
	static isPlutoniumAddonAutomationActive () { return this.isModuleActive(UtilCompat.MODULE_PLUTONIUM_ADDON_AUTOMATION); }
	static isMidiQolActive () { return this.isModuleActive(UtilCompat.MODULE_MIDI_QOL); }
	static isModuleMulticlassSpellbookFilterActive () { return this.isModuleActive(UtilCompat.MODULE_MULTICLASS_SPELLBOOK_FILTER); }
	static isQuickInsertActive () { return this.isModuleActive(UtilCompat.MODULE_QUICK_INSERT); }
	static isPf2eTokensBestiaryActive () { return this.isModuleActive(UtilCompat.MODULE_PF2E_TOKENS_BESTIARIES); }
	static isDfredsConvenientEffectsActive () { return this.isModuleActive(UtilCompat._MODULE_DFREDS_CONVENIENT_EFFECTS); }
	static isLevels3dPreviewActive () { return this.isModuleActive(UtilCompat.MODULE_LEVELS_3D_PREVIEW); }
	static _isCanvas3dCompendiumActive () { return this.isModuleActive(UtilCompat._MODULE_CANVAS_3D_COMPENDIUM); }
	static _iCanvas3dTokenCompendiumActive () { return this.isModuleActive(UtilCompat._MODULE_CANVAS_3D_TOKEN_COMPENDIUM); }

	static isThreeDiTokensActive () { return this.isLevels3dPreviewActive() && this._isCanvas3dCompendiumActive() && this._iCanvas3dTokenCompendiumActive(); }

	static getApi (moduleName) {
		if (!this.isModuleActive(moduleName)) return null;
		return game.modules.get(moduleName).api;
	}

	static getName (moduleName) {
		if (!this.isModuleActive(moduleName)) return null;
		return game.modules.get(moduleName).title;
	}

	static isDaeGeneratingArmorEffects () {
		if (!this.isDaeActive()) return false;
		return !!UtilGameSettings.getSafe(UtilCompat.MODULE_DAE, "calculateArmor");
	}

	static getFeatureFlags ({isReaction}) {
		const out = {};

		if (isReaction) {
									out.adnd5e = {itemInfo: {type: "reaction"}};
		}

		return out;
	}

	static MonksLittleDetails = class {
				static isDefeated (token) {
			return (
				(token.combatant && token.isDefeated)
								|| token.actor?.effects.some(it => it.statuses.has(CONFIG.specialStatusEffects.DEFEATED))
				|| token.document.overlayEffect === CONFIG.controlIcons.defeated
			);
		}
	};

	static DfredsConvenientEffects = class {
		static getCustomEffectsItemId () {
			return UtilGameSettings.getSafe(UtilCompat._MODULE_DFREDS_CONVENIENT_EFFECTS, "customEffectsItemId");
		}
	};
}
UtilCompat._MODULE_LIB_WRAPPER = "lib-wrapper";
UtilCompat.MODULE_DAE = "dae";
UtilCompat._MODULE_DRAG_UPLOAD = "dragupload";
UtilCompat.MODULE_MIDI_QOL = "midi-qol";
UtilCompat.MODULE_KANKA_FOUNDRY = "kanka-foundry";
UtilCompat.MODULE_SMOL_FOUNDRY = "smol-foundry";
UtilCompat.MODULE_PERMISSION_VIEWER = "permission_viewer";
UtilCompat._MODULE_TWILIGHT_UI = "twilight-ui";
UtilCompat.MODULE_TIDY5E_SHEET = "tidy5e-sheet";
UtilCompat._MODULE_OBSIDIAN = "obsidian";
UtilCompat.MODULE_BABELE = "babele";
UtilCompat.MODULE_MONKS_LITTLE_DETAILS = "monks-little-details";
UtilCompat.MODULE_MONKS_BLOODSPLATS = "monks-bloodsplats";
UtilCompat.MODULE_MONKS_ENHANCED_JOURNAL = "monks-enhanced-journal";
UtilCompat.MODULE_BETTER_ROLLTABLES = "better-rolltables";
UtilCompat._MODULE_BETTER_ROLLTABLES = "item-piles";
UtilCompat.MODULE_PLUTONIUM_ADDON_AUTOMATION = "plutonium-addon-automation";
UtilCompat.MODULE_LEVELS = "levels";
UtilCompat.MODULE_MULTICLASS_SPELLBOOK_FILTER = "spell-class-filter-for-5e";
UtilCompat.MODULE_ROLLDATA_AWARE_ACTIVE_EFFECTS = "fvtt-rolldata-aware-active-effects";
UtilCompat.MODULE_QUICK_INSERT = "quick-insert";
UtilCompat.MODULE_PF2E_TOKENS_BESTIARIES = "pf2e-tokens-bestiaries";
UtilCompat._MODULE_DFREDS_CONVENIENT_EFFECTS = "dfreds-convenient-effects";
UtilCompat.MODULE_LEVELS_3D_PREVIEW = "levels-3d-preview";
UtilCompat._MODULE_CANVAS_3D_COMPENDIUM = "canvas3dcompendium";
UtilCompat._MODULE_CANVAS_3D_TOKEN_COMPENDIUM = "canvas3dtokencompendium";

UtilCompat._SYSTEMS_SUPPORTED = {
	"dnd5e": {
		min: {
			major: 2,
			minor: 2,
			patch: 0,
		},
		max: {
			major: 2,
			minor: 2,
			patch: 999,
		},
	},
};

class ConfigConsts {
	static _flushCaches () {
		this._DEFAULT_CONFIG = null;
		this._DEFAULT_CONFIG_SORTED = null;
		this._DEFAULT_CONFIG_SORTED_FLAT = null;
	}

		static _IMPORTERS = {};
	static registerImporter ({id, name}) {
		this._IMPORTERS[id] = name;
		this._flushCaches();
	}

	static _template_getImporterToggles () {
		return {
			hiddenImporterIds: {
				name: "Hidden Importers",
				help: `Importers which should not be shown in the Import Wizard UI.`,
				default: {
					"background-features": true,
															"race-and-subrace-features": true,
				},
				type: "multipleChoice",
				choices: Object.entries(this._IMPORTERS)
					.map(([id, name]) => ({name, value: id}))
															.sort(({name: nameA}, {name: nameB}) => SortUtil.ascSortLower(nameA, nameB)),
			},
		};
	}

	static _getModelBarAttributes (actorType) {
		if (!actorType) return [];

		return Object.values(
			TokenDocument.implementation.getTrackedAttributeChoices(
				TokenDocument.implementation.getTrackedAttributes(actorType),
			),
		)
			.flat();
	}

	static _template_getEntityOwnership (help) {
		const out = MiscUtil.copy(ConfigConsts._TEMPLATE_ENTITY_OWNERSHIP);
		out.values = Util.Fvtt.getOwnershipEnum();
		out.help = help;
		return out;
	}

	static _template_getTokenSettings ({actorType}) {
		return {
			tokenNameDisplay: {
				name: "Token Name Display Mode",
				help: `The default Display Name mode for imported tokens.`,
				default: 20,
				type: "enum",
				values: [
					{
						value: ConfigConsts.C_USE_GAME_DEFAULT,
						name: "Use game setting",
					},
					...Object.entries({...CONST.TOKEN_DISPLAY_MODES})
						.sort(([, vA], [, vB]) => SortUtil.ascSort(vA, vB))
						.map(([k, v]) => ({
							value: v,
														fnGetName: () => game.i18n.localize(`TOKEN.DISPLAY_${k}`),
						})),
				],
			},
			tokenDisposition: {
				name: "Token Disposition",
				help: `The default Token Disposition mode for imported tokens.`,
				default: -1,
				type: "enum",
				values: [
					{
						value: ConfigConsts.C_USE_GAME_DEFAULT,
						name: "Use game setting",
					},
					...Object.entries(CONST.TOKEN_DISPOSITIONS)
						.sort(([, vA], [, vB]) => SortUtil.ascSort(vA, vB))
						.map(([k, v]) => ({
							value: v,
														fnGetName: () => game.i18n.localize(`TOKEN.DISPOSITION.${k}`),
						})),
				],
			},
			tokenLockRotation: {
				name: "Token Lock Rotation",
				help: `The default Lock Rotation mode for imported tokens.`,
				default: ConfigConsts.C_USE_PLUT_VALUE,
				type: "enum",
				values: [
					{
						value: ConfigConsts.C_USE_GAME_DEFAULT,
						name: "Use game setting",
					},
					{
						value: ConfigConsts.C_USE_PLUT_VALUE,
						name: "Allow importer to set",
					},
				],
			},
			tokenIsAddVision: {
				name: "Enable Token Vision",
				help: `Enable vision for tokens.`,
				default: ConfigConsts.C_BOOL_ENABLED,
				type: "enum",
				values: [
					{
						value: ConfigConsts.C_USE_GAME_DEFAULT,
						name: "Use game setting",
					},
					{
						value: ConfigConsts.C_BOOL_DISABLED,
						name: "Disabled",
					},
					{
						value: ConfigConsts.C_BOOL_ENABLED,
						name: "Enabled",
					},
				],
			},
			tokenDimSight: {
				name: "Token Dim Vision Distance",
				help: `How token Dim Vision (Distance) should be set.`,
				default: ConfigConsts.C_USE_PLUT_VALUE,
				type: "enum",
				values: [
					{
						value: ConfigConsts.C_USE_GAME_DEFAULT,
						name: "Use game setting",
					},
					{
						value: ConfigConsts.C_USE_PLUT_VALUE,
						name: "Allow importer to set",
					},
				],
			},
			tokenBrightSight: {
				name: "Token Bright Vision Distance",
				help: `How token Bright Vision (Distance) should be set.`,
				default: ConfigConsts.C_USE_PLUT_VALUE,
				type: "enum",
				values: [
					{
						value: ConfigConsts.C_USE_GAME_DEFAULT,
						name: "Use game setting",
					},
					{
						value: ConfigConsts.C_USE_PLUT_VALUE,
						name: "Allow importer to set",
					},
				],
			},
			tokenSightAngle: {
				name: "Token Sight Angle",
				help: `How token Sight Angle (Degrees) should be set.`,
				default: ConfigConsts.C_USE_PLUT_VALUE,
				type: "enum",
				values: [
					{
						value: ConfigConsts.C_USE_GAME_DEFAULT,
						name: "Use game setting",
					},
					{
						value: ConfigConsts.C_USE_PLUT_VALUE,
						name: "Allow importer to set",
					},
				],
			},
			tokenDimLight: {
				name: "Token Dim Light Radius",
				help: `How token Dim Light Radius (Distance) should be set.`,
				default: ConfigConsts.C_USE_PLUT_VALUE,
				type: "enum",
				values: [
					{
						value: ConfigConsts.C_USE_GAME_DEFAULT,
						name: "Use game setting",
					},
					{
						value: ConfigConsts.C_USE_PLUT_VALUE,
						name: "Allow importer to set",
					},
				],
			},
			tokenBrightLight: {
				name: "Token Bright Light Radius",
				help: `How token Bright Light Radius (Distance) should be set.`,
				default: ConfigConsts.C_USE_PLUT_VALUE,
				type: "enum",
				values: [
					{
						value: ConfigConsts.C_USE_GAME_DEFAULT,
						name: "Use game setting",
					},
					{
						value: ConfigConsts.C_USE_PLUT_VALUE,
						name: "Allow importer to set",
					},
				],
			},
			tokenLightAngle: {
				name: "Token Light Emission Angle",
				help: `How token Light Emission (Angle) should be set.`,
				default: ConfigConsts.C_USE_PLUT_VALUE,
				type: "enum",
				values: [
					{
						value: ConfigConsts.C_USE_GAME_DEFAULT,
						name: "Use game setting",
					},
					{
						value: ConfigConsts.C_USE_PLUT_VALUE,
						name: "Allow importer to set",
					},
				],
			},
			tokenLightColor: {
				name: "Token Light Color",
				help: `How token Light Color should be set.`,
				default: ConfigConsts.C_USE_PLUT_VALUE,
				type: "enum",
				values: [
					{
						value: ConfigConsts.C_USE_GAME_DEFAULT,
						name: "Use game setting",
					},
					{
						value: ConfigConsts.C_USE_PLUT_VALUE,
						name: "Allow importer to set",
					},
				],
			},
			tokenLightAlpha: {
				name: "Token Light Intensity",
				help: `How token Color Intensity should be set.`,
				default: ConfigConsts.C_USE_PLUT_VALUE,
				type: "enum",
				values: [
					{
						value: ConfigConsts.C_USE_GAME_DEFAULT,
						name: "Use game setting",
					},
					{
						value: ConfigConsts.C_USE_PLUT_VALUE,
						name: "Allow importer to set",
					},
				],
			},
			tokenLightAnimationType: {
				name: "Token Light Animation Type",
				help: `How token Light Animation Type should be set.`,
				default: ConfigConsts.C_USE_PLUT_VALUE,
				type: "enum",
				values: [
					{
						value: ConfigConsts.C_USE_GAME_DEFAULT,
						name: "Use game setting",
					},
					{
						value: ConfigConsts.C_USE_PLUT_VALUE,
						name: "Allow importer to set",
					},
				],
			},
			tokenLightAnimationSpeed: {
				name: "Token Light Animation Speed",
				help: `How token Light Animation Speed should be set.`,
				default: ConfigConsts.C_USE_PLUT_VALUE,
				type: "enum",
				values: [
					{
						value: ConfigConsts.C_USE_GAME_DEFAULT,
						name: "Use game setting",
					},
					{
						value: ConfigConsts.C_USE_PLUT_VALUE,
						name: "Allow importer to set",
					},
				],
			},
			tokenLightAnimationIntensity: {
				name: "Token Light Animation Intensity",
				help: `How token Light Animation Intensity should be set.`,
				default: ConfigConsts.C_USE_PLUT_VALUE,
				type: "enum",
				values: [
					{
						value: ConfigConsts.C_USE_GAME_DEFAULT,
						name: "Use game setting",
					},
					{
						value: ConfigConsts.C_USE_PLUT_VALUE,
						name: "Allow importer to set",
					},
				],
			},
			tokenBarDisplay: {
				name: "Token Bar Display Mode",
				help: `The default Display Bars mode for imported tokens.`,
				default: 40,
				type: "enum",
				values: [
					{
						value: ConfigConsts.C_USE_GAME_DEFAULT,
						name: "Use game setting",
					},
					{
						value: 0,
						name: "None",
					},
					{
						value: 10,
						name: "Control",
					},
					{
						value: 20,
						name: "Owner Hover",
					},
					{
						value: 30,
						name: "Hover",
					},
					{
						value: 40,
						name: "Owner",
					},
					{
						value: 50,
						name: "Always",
					},
				],
			},
			tokenBar1Attribute: {
				name: "Token Bar 1 Attribute",
				help: `The default token bar 1 attribute for imported tokens.`,
				default: "attributes.hp",
				type: "enum",
				values: () => [
					{value: ConfigConsts.C_USE_GAME_DEFAULT, name: "Use game setting"},
					...ConfigConsts._getModelBarAttributes(actorType),
				],
				isNullable: true,
			},
			tokenBar2Attribute: {
				name: "Token Bar 2 Attribute",
				help: `The default token bar 2 attribute for imported tokens.`,
				default: null,
				type: "enum",
				values: () => [
					{value: ConfigConsts.C_USE_GAME_DEFAULT, name: "Use game setting"},
					...ConfigConsts._getModelBarAttributes(actorType),
				],
				isNullable: true,
			},
			tokenScale: {
				name: "Token Scale",
				help: `The default token scale for imported tokens.`,
				default: null,
				type: "number",
				placeholder: "(Use default)",
				min: 0.2,
				max: 3,
				isNullable: true,
			},
			isTokenMetric: {
				name: "Convert Token Vision Ranges to Metric",
				help: "Whether or not token vision range units should be converted to an approximate metric equivalent (5 feet \u2248 1.5 metres).",
				default: false,
				type: "boolean",
			},
		};
	}

	static _template_getSceneImportSettings () {
		return {
			scenePadding: {
				name: "Scene Padding",
				help: `The amount of scene padding to apply when creating a scene.`,
				default: 0,
				type: "number",
				min: 0,
				max: 0.5,
			},
			sceneBackgroundColor: {
				name: "Scene Background Color",
				help: `The background color to apply when creating a scene.`,
				default: "#222222",
				type: "color",
			},
			isSceneTokenVision: {
				name: "Scene Token Vision",
				help: `Whether or not token vision should be enabled for a created scene.`,
				default: true,
				type: "boolean",
			},
			isSceneFogExploration: {
				name: "Scene Fog Exploration",
				help: `Whether or not fog exploration should be enabled for a created scene.`,
				default: true,
				type: "boolean",
			},
			isSceneAddToNavigation: {
				name: "Add Scenes to Navigation",
				help: `Whether or not a created scene should be added to the navigation bar.`,
				default: false,
				type: "boolean",
			},
			isSceneGenerateThumbnail: {
				name: "Generate Scene Thumbnails",
				help: `Whether or not a thumbnail should be generated for a created scene. Note that this greatly slows down the scene creation process.`,
				default: true,
				type: "boolean",
			},
			isSceneGridMetric: {
				name: "Convert Scene Grid Distances to Metric",
				help: `Whether or not scene grid distances should be converted to an approximate metric equivalent (${ConfigConsts._DISP_METRIC_FEET}; ${ConfigConsts._DISP_METRIC_MILES}).`,
				default: false,
				type: "boolean",
			},
		};
	}

	static _template_getActiveEffectsDisabledTransferSettings ({name}) {
		return {
			setEffectDisabled: {
				name: `Override Effect &quot;Disabled&quot; Value`,
				help: `If set, overrides the "Disabled" value present on any effects tied to imported ${name}.`,
				type: "enum",
				default: ConfigConsts.C_USE_PLUT_VALUE,
				compatibilityModeValues: {
					[UtilCompat.MODULE_MIDI_QOL]: {
						value: ConfigConsts.C_USE_PLUT_VALUE,
						name: "Allow importer to set",
					},
				},
				values: [
					{
						value: ConfigConsts.C_USE_PLUT_VALUE,
						name: "Allow importer to set",
					},
					{
						value: ConfigConsts.C_BOOL_DISABLED,
						name: `Set to "False"`,
					},
					{
						value: ConfigConsts.C_BOOL_ENABLED,
						name: `Set to "True"`,
					},
				],
			},
			setEffectTransfer: {
				name: `Override Effect &quot;Transfer&quot; Value`,
				help: `If set, overrides the "Transfer to Actor" value present on any effects tied to imported ${name}.`,
				type: "enum",
				default: ConfigConsts.C_USE_PLUT_VALUE,
				compatibilityModeValues: {
					[UtilCompat.MODULE_MIDI_QOL]: {
						value: ConfigConsts.C_USE_PLUT_VALUE,
						name: "Allow importer to set",
					},
				},
				values: [
					{
						value: ConfigConsts.C_USE_PLUT_VALUE,
						name: "Allow importer to set",
					},
					{
						value: ConfigConsts.C_BOOL_DISABLED,
						name: `Set to "False"`,
					},
					{
						value: ConfigConsts.C_BOOL_ENABLED,
						name: `Set to "True"`,
					},
				],
			},
		};
	}

	static _template_getMinimumRole ({name, help}) {
		const out = MiscUtil.copy(ConfigConsts._TEMPALTE_MINIMUM_ROLE);
		out.values = Util.Fvtt.getMinimumRolesEnum();
		out.name = name;
		out.help = help;
		return out;
	}

	
	static _DEFAULT_CONFIG = null;
	static getDefaultConfig_ () {
		return this._DEFAULT_CONFIG = this._DEFAULT_CONFIG || {
			ui: {
				name: "UI",
				settings: {
					isStreamerMode: {
						name: "Streamer Mode",
						help: `Remove identifiable 5etools/Plutonium references from the UI, and replaces them with "SRD Enhanced."`,
						default: false,
						type: "boolean",
						isReloadRequired: true,
						isPlayerEditable: true,
					},
					isShowPopout: {
						name: "Enable Sheet Popout Buttons",
						help: `Add a "Popout" button to sheet headers, which opens the sheet as a popup browser window.`,
						default: true,
						type: "boolean",
						isPlayerEditable: true,
					},
					isCompactWindowBar: {
						name: "Compact Header Buttons",
						help: `Combine the Plutonium-specific header buttons into a single dropdown, and re-style other header buttons to match.`,
						default: true,
						type: "boolean",
						isPlayerEditable: true,
					},
					isCompactDirectoryButtons: {
						name: "Compact Directory Buttons",
						help: `Reduce the height of "Create X"/"Create Folder" buttons in the directory, to offset the additional space requirements of Plutonium's UI.`,
						default: true,
						type: "boolean",
						isPlayerEditable: true,
					},
					isCompactChat: {
						name: "Compact Chat",
						help: "Make various tweaks to the appearance of chat, in order to fit more on-screen. Hold down SHIFT while hovering over a message to expand it, revealing its header and delete button.",
						default: true,
						type: "boolean",
						isPlayerEditable: true,
					},
					isCompactScenes: {
						name: "Compact Scenes Directory",
						help: "Reduce the height of scene thumbnails in the Scenes Directory, to fit more on-screen.",
						default: true,
						type: "boolean",
						isPlayerEditable: true,
					},
					isCompactActors: {
						name: "Compact Actors Directory",
						help: "Reduce the height of Actors Directory directory items, to fit more on-screen.",
						default: true,
						type: "boolean",
						isPlayerEditable: true,
					},
					isCompactItems: {
						name: "Compact Items Directory",
						help: "Reduce the height of Items Directory directory items, to fit more on-screen.",
						default: true,
						type: "boolean",
						isPlayerEditable: true,
					},
					isCompactJournal: {
						name: "Compact Journal Entries",
						help: "Reduce the height of Journal Entries directory items, to fit more on-screen.",
						default: true,
						type: "boolean",
						isPlayerEditable: true,
					},
					isCompactTables: {
						name: "Compact Rollable Tables",
						help: "Reduce the height of Rollable Tables directory items, to fit more on-screen.",
						default: true,
						type: "boolean",
						isPlayerEditable: true,
					},
					isCompactCards: {
						name: "Compact Card Stacks",
						help: "Reduce the height of Card Stacks directory items, to fit more on-screen.",
						default: true,
						type: "boolean",
						isPlayerEditable: true,
					},
					isCompactCompendiums: {
						name: "Compact Compendium Packs",
						help: "Reduce the height of Compendium Packs directory items, to fit more on-screen.",
						default: true,
						type: "boolean",
						isPlayerEditable: true,
					},
					isCompactMacros: {
						name: "Compact Macros",
						help: "Reduce the height of Macro directory items, to fit more on-screen.",
						default: true,
						type: "boolean",
						isPlayerEditable: true,
					},
					isHidePlutoniumDirectoryButtons: {
						name: "Hide Directory Buttons",
						help: `Hide the Plutonium directory buttons.`,
						default: false,
						type: "boolean",
					},
					isNameTabFromScene: {
						name: "Prepend Active Scene Name to Browser Tab Name",
						help: "Sets the browser tab name to be that of the currently-active scene.",
						default: true,
						type: "boolean",
					},
					tabNameSuffix: {
						name: "Tab Name Suffix",
						help: `Requires the "Name Browser Tab After Active Scene" option to be enabled. A custom name suffix to append to the scene name displayed in the tab (separated by a Foundry-style bullet character).`,
						default: null,
						isNullable: true,
						type: "string",
					},
					isDisplayBackendStatus: {
						name: "Display Detected Backend",
						help: `Adds a cool green hacker tint to the Foundry "anvil" logo in the top-left corner of the screen if Plutonium's backend is detected.`,
						default: true,
						type: "boolean",
						isPlayerEditable: true,
					},
					isExpandActiveEffectConfig: {
						name: "Enhance Active Effect Config UI",
						help: `Adds a list of potential active effect attribute keys to the Configure Active Effect window's "Effects" tab, and a field for configuring priority.`,
						default: true,
						type: "boolean",
						compatibilityModeValues: {
							[UtilCompat.MODULE_DAE]: false,
						},
					},
					isAddDeleteToSceneNavOptions: {
						name: `Add "Delete" to Navbar Scene Context Menu`,
						help: `Adds a "Delete" option to the context menu found when right-clicking a scene in the navigation bar. Note that this does not include the currently-active scene.`,
						default: true,
						type: "boolean",
					},
				},
				settingsAdvanced: {
					isHideGmOnlyConfig: {
						name: "Hide GM-Only Config",
						help: `If enabled, a player viewing the config will see only the limited subset of settings they are allowed to modify. If disabled, a player viewing the config will see all settings, regardless of whether or not they can modify those settings.`,
						default: true,
						type: "boolean",
					},
					isDisableLargeImportWarning: {
						name: "Disable Large Import Warning",
						help: `Disable the warning confirmation dialogue shown when importing a large number of entities.`,
						default: false,
						type: "boolean",
						isPlayerEditable: true,
					},
				},
				settingsHacks: {
					isFastAnimations: {
						name: "Fast Animations",
						help: "Increase the speed of various UI animations.",
																																				default: false,
						type: "boolean",
						isPlayerEditable: true,
					},
					isFastTooltips: {
						name: "Fast Tooltips",
						help: "Increase the speed of tooltip animations, and reduce the delay before tooltips appear.",
						default: false,
						type: "boolean",
						isPlayerEditable: true,
					},
					isFixEscapeKey: {
						name: "Fix ESC Key",
						help: `Bind the "Escape" key to (in this order): de-select active input fields; de-select selected canvas elements; close context menus; close individual windows in most-recently-active-first order; toggle the main menu.`,
						default: true,
						type: "boolean",
						isPlayerEditable: true,
					},
					isAddOpenMainMenuButtonToSettings: {
						name: `Add "Open Game Menu" Button if &quot;Fix ESC Key&quot; Is Enabled`,
						help: `Add an alternate "Open Game Menu" button to the Settings tab if the "Fix ESC Key" Config option is enabled. This allows you to quickly open the main menu without first having to close all open windows.`,
						default: true,
						type: "boolean",
						isPlayerEditable: true,
					},
					isFixDrawingFreehandMinDistance: {
						name: "Fix Freehand Drawing Minimum Distance",
						help: `Reduce the minimum mouse movement distance required to start a freehand drawing.`,
						default: true,
						type: "boolean",
						isPlayerEditable: true,
					},
					isEnableIncreasedFolderDepth: {
						name: "Render >3 Levels of Folder Nesting",
						help: `If enabled, Foundry's default folder nesting limit (of 3) will be bypassed, for the purpose of rendering directories. Note that this does not necessarily allow you to create additionally-nested folders without using the game API.`,
						default: true,
						type: "boolean",
						compatibilityModeValues: {
							[UtilCompat.MODULE_BETTER_ROLLTABLES]: false,
						},
					},
					isEnableFolderNameWrap: {
						name: "Wrap Long Folder Names",
						help: `Wrap long folder names over multiple lines, instead of clipping the name.`,
						default: false,
						type: "boolean",
						isPlayerEditable: true,
					},
					isEnableSubPopouts: {
						name: "Allow Popout Chaining",
						help: `Automatically pop out apps opened from within popped-out apps. If disabled, apps opened from within popped-out apps will appear in the main window, instead.`,
						default: true,
						type: "boolean",
						isPlayerEditable: true,
					},
					isSuppressMissingRollDataNotifications: {
						name: `Suppress &quot;Missing Roll Data&quot; Notifications`,
						help: `If enabled, notification warning  messages of the form "The attribute <X> was not present in the provided roll data." will be suppressed, and logged as console warnings instead.`,
						default: true,
						type: "boolean",
						isPlayerEditable: true,
					},
					isLazyActorAndItemRendering: {
						name: "Minimize Actor/Item Re-Renders",
						help: `If enabled, actor/item sheet re-rendering will be skipped where possible. This may reduce UI flickering, and may reduce unexpected input deselection when tabbing or clicking through fields. It may also horribly break your game, and is not expected to work with anything except default dnd5e sheets. Use with caution.`,
						default: false,
						type: "boolean",
						isPlayerEditable: true,
						isReloadRequired: true,
					},
					isAlwaysResizableApps: {
						name: "Default Resizeable Applications",
						help: `If enabled, applications will be resizeable by default. Note that specific applications may still override this.`,
						default: false,
						type: "boolean",
						isPlayerEditable: true,
					},
				},
			},
			tokens: {
				name: "Tokens",
				settings: {
					isDisplayDamageDealt: {
						name: "Display Missing Health",
						help: `This allows players to see "damage dealt" to a token, without revealing the token's total health. If enabled, each token's missing health is displayed as a number in the bottom-right corner of the token.`,
						default: false,
						type: "boolean",
					},
					damageDealtBloodiedThreshold: {
						name: `Display Missing Health &quot;Wounded&quot; Threshold`,
						help: `The health-loss threshold at which the Missing Health text turns red.`,
						default: 0.5,
						type: "percentage",
						min: 0.0,
						max: 1.0,
					},
					isDamageDealtBelowToken: {
						name: `Missing Health Below Token`,
						help: `If the Missing Health text should be displayed beneath a token, rather than as an overlay.`,
						default: false,
						type: "boolean",
					},
					nameplateFontSizeMultiplier: {
						name: "Font Size Multiplier",
						help: `A multiplier which is applied to token nameplate/tooltip font size, e.g. a value of "0.5" will decrease token nameplate/tooltip font size by half.`,
						default: null,
						type: "number",
						placeholder: "(Use default)",
						min: 0.1,
						max: 10,
						isNullable: true,
					},
					isAllowNameplateFontWrap: {
						name: "Allow Text Wrap",
						help: `If enabled, token nameplate/tooltip text will wrap.`,
						default: ConfigConsts.C_USE_GAME_DEFAULT,
						type: "enum",
						values: [
							{
								value: ConfigConsts.C_USE_GAME_DEFAULT,
								name: "Use Foundry default",
							},
							{
								value: false,
								name: "Disabled",
							},
							{
								value: true,
								name: "Enabled",
							},
						],
					},
					nameplateFontWrapWidthMultiplier: {
						name: "Text Wrap Max Width Multiplier",
						help: `A multiplier which is applied to token nameplate/tooltip text wrapping maximum size, e.g. a value of "0.5" will force token nameplates/tooltips to wrap at half their usual length. The base value to which this multiplier is applied is: "2.5 × token width".`,
						default: null,
						type: "number",
						placeholder: "(Use default)",
						min: 0.1,
						max: 10,
						isNullable: true,
					},
					isNameplateOnToken: {
						name: `Move Token Name Onto Token`,
						help: `If a token's name should be displayed on the token, rather than below it.`,
						default: false,
						type: "boolean",
					},
					npcHpRollMode: {
						name: "NPC HP Roll Mode",
						help: `Determines whether or not token HP, for NPC tokens which are not linked to their actor's data, should be rolled upon token creation. If a mode other than "None" is selected, and the token has a valid HP dice formula, the token will roll for HP. For example, a Goblin (7 HP; formula is 2d6) could be created with anywhere between 2 and 12 HP (inclusive).`,
						default: ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_NONE,
						type: "enum",
						values: [
							{
								value: ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_NONE,
								name: `None`,
								help: `Do not roll NPC token health.`,
							},
							{
								value: ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_STANDARD,
								name: `Standard Roll`,
							},
							{
								value: ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_GM,
								name: `GM Roll`,
							},
							{
								value: ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_BLIND,
								name: `Blind Roll`,
							},
							{
								value: ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_SELF,
								name: `Self Roll`,
							},
							{
								value: ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_HIDDEN,
								name: `Hidden Roll`,
								help: `Roll NPC token health, but do not post the result to chat.`,
							},
							{
								value: ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_MIN,
								name: `Minimum Value`,
								help: `Use the minimum possible roll value.`,
							},
							{
								value: ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_MAX,
								name: `Maximum Value`,
								help: `Use the maximum possible roll value.`,
							},
						],
					},
					isDisableAnimations: {
						name: "Disable Animations",
						help: "Disable token animations.",
						default: false,
						type: "boolean",
					},
					animationSpeedMultiplier: {
						name: "Animation Speed",
						help: "Multiplies token animation movement speed by the factor provided.",
						default: null,
						type: "number",
						isNullable: true,
						min: 0.1,
						max: 10,
					},
				},
				settingsAdvanced: {
					missingHealthAttribute: {
						name: "Health Attribute",
						help: `The sheet attribute used to fetch current/max health when the "Display Missing Health" option is enabled.`,
						default: "attributes.hp",
						type: "string",
						additionalStyleClasses: "code",
					},
				},
				settingsHacks: {
					isIgnoreDisableAnimationsForWaypointMovement: {
						name: "Avoid Disabling Animations for Ruler Movement",
						help: `Suppresses the "Disable Animations" option for a token being moved via ruler waypoints (i.e. when CTRL-dragging from a token and pressing SPACE). Note that dismissing the ruler during the move will end this suppression.`,
						default: true,
						type: "boolean",
					},
				},
			},
			import: {
				name: "Import",
				settings: {
					isAddSourceToName: {
						name: "Add Source to Names",
						help: `If the source of each imported entry (e.g. "MM" for Monster Manual) should be appended to the name of the entry.`,
						default: false,
						type: "boolean",
						isPlayerEditable: true,
					},
					isAddPageNumberToSource: {
						name: "Add Page Numbers to Sources",
						help: `If the page number (where available) of each imported entry should be appended to the "source" field of the entry.`,
						default: false,
						type: "boolean",
						isPlayerEditable: true,
					},
					isRenderLinksAsTags: {
						name: `Render Links as &quot;@tag&quot;s`,
						help: `If links found in description text should be rendered as Plutonium-specific @tag syntax, e.g. a link to "goblin" would be rendered as "@creature[goblin|mm]". (By default, a link to the 5etools page will be rendered instead.)`,
						default: true,
						type: "boolean",
					},
					isRendererLinksDisabled: {
						name: "Disable 5etools Links",
						help: `Prevents links to other 5etools content from being added to the text of imported 5etools content.`,
						default: false,
						type: "boolean",
						isPlayerEditable: true,
					},
					isRendererDiceDisabled: {
						name: "Render Dice as Plain Text",
						help: `Forces dice expressions, usually rendered as "[[/r XdY + Z ...]]", to be rendered as plain text when importing 5etools content.`,
						default: false,
						type: "boolean",
						isPlayerEditable: true,
					},
					deduplicationMode: {
						name: "Duplicate Handling Mode",
						help: `Determines what action is taken when importing duplicate content to a directory or compendium. An entity is considered a duplicate if and only if its name and source match an existing entity. Note that this does not function when importing to actor sheets.`,
						default: ConfigConsts.C_IMPORT_DEDUPE_MODE_NONE,
						type: "enum",
						values: [
							{
								value: ConfigConsts.C_IMPORT_DEDUPE_MODE_NONE,
								name: `None`,
								help: `No deduplication is done.`,
							},
							{
								value: ConfigConsts.C_IMPORT_DEDUPE_MODE_SKIP,
								name: `Skip duplicates`,
								help: `If a duplicate is found for a would-be imported entity, that entity is not imported.`,
							},
							{
								value: ConfigConsts.C_IMPORT_DEDUPE_MODE_OVERWRITE,
								name: `Update existing`,
								help: `If a duplicate is found for a would-be import entity, the existing entity is updated.`,
							},
						],
					},
					isDuplicateHandlingMaintainImage: {
						name: "Maintain Images when Overwriting Duplicates",
						help: `If enabled, sheet and token images will be maintained when overwriting an existing document in "Update Existing" Duplicate Handling Mode.`,
						default: false,
						type: "boolean",
					},
					minimumRole: ConfigConsts._template_getMinimumRole({
						name: "Minimum Permission Level for Import",
						help: `"Import" buttons will be hidden for any user with a role less than the chosen role.`,
					}),
					dragDropMode: {
						name: "Use Importer when Drag-Dropping Items to Actors",
						help: `Some Foundry items (backgrounds, races, spells, items, etc.), when imported via Plutonium and later drag-dropped to an actor sheet, have special handling allowing for greater functionality (such as populating skills and features). This allows you to control whether or not that special handling is used, rather than the baseline Foundry drag-drop. Note that if you modify an item, the changes will not be reflected in the version imported to the sheet by Plutonium.`,
						default: ConfigConsts.C_IMPORT_DRAG_DROP_MODE_PROMPT,
						type: "enum",
						values: [
							{
								value: ConfigConsts.C_IMPORT_DRAG_DROP_MODE_NEVER,
								name: `Never`,
							},
							{
								value: ConfigConsts.C_IMPORT_DRAG_DROP_MODE_PROMPT,
								name: `Prompt`,
							},
							{
								value: ConfigConsts.C_IMPORT_DRAG_DROP_MODE_ALWAYS,
								name: `Always`,
							},
						],
						isPlayerEditable: true,
					},
					isUseOtherFormulaFieldForSaveHalvesDamage: {
						name: `Treat &quot;Save Halves&quot; Additional Attack Damage as &quot;Other Formula&quot;`,
						help: `This moves extra attack damage rolls (for example, the poison damage done by a Giant Spider's bite) to the "Other Formula" dice field, which can improve compatibility with some modules.`,
						default: false,
						type: "boolean",
						compatibilityModeValues: {
							[UtilCompat.MODULE_PLUTONIUM_ADDON_AUTOMATION]: true,
						},
					},
					isUseOtherFormulaFieldForOtherDamage: {
						name: `Treat &quot;Alternate&quot; Attack Damage as &quot;Other Formula&quot;`,
						help: `This moves alternate non-versatile attack damage rolls (for example, Egg Hunter Hatchling's &quot;Egg Tooth&quot; damage when targeting an object) to the "Other Formula" dice field, which can improve compatibility with some modules.`,
						default: false,
						type: "boolean",
						compatibilityModeValues: {
							[UtilCompat.MODULE_PLUTONIUM_ADDON_AUTOMATION]: true,
						},
					},
					isGlobalMetricDistance: {
						name: "Prefer Metric Distance/Speed (Where Available)",
						help: `If enabled, metric distance/speed units will be preferred, where the importer supports them. Enabling this option effectively overrides all other metric distance/speed options, causing the importer to treat each as though it was enabled.`,
						default: false,
						type: "boolean",
					},
					isGlobalMetricWeight: {
						name: "Prefer Metric Weight (Where Available)",
						help: `If enabled, metric weight units will be preferred, where the importer supports them. Enabling this option effectively overrides all other metric weight options, causing the importer to treat each as though it was enabled.`,
						default: false,
						type: "boolean",
					},
					isShowVariantsInLists: {
						name: "Show Variants/Versions",
						help: `If variants/versions of base entries should be shown in list views (with grayed-out names).`,
						default: true,
						type: "boolean",
					},
					isSaveImagesToServer: {
						name: "Save Imported Images to Server",
						help: `If images referenced in imported content should be saved to your server files, rather than referenced from an external server.`,
						default: false,
						type: "boolean",
					},
					isSaveTokensToServer: {
						name: "Save Imported Tokens to Server",
						help: `If tokens for imported actors should be saved to your server files, rather than referenced from an external server.`,
						default: true,
						type: "boolean",
					},
					localImageDirectoryPath: {
						name: "Image/Token Directory",
						help: `The sub-directory of the "User Data" directory where imported images/tokens will be saved to when using the "Save Imported Images to Server" option or the "Save Imported Tokens to Server" option. If the "Use Local Images" option is enabled, images will be loaded from this directory by default.`,
						default: `assets/${SharedConsts.MODULE_ID_FAKE}`,
						type: "string",
						additionalStyleClasses: "code",
					},
					isPreferFoundryImages: {
						name: "Prefer Foundry/System Images",
						help: `If enabled, portraits for actors and images for items will be sourced from built-in compendiums first, then Plutonium second. If disabled, portraits/images will be sourced from Plutonium first, then built-in compendiums second.`,
						default: false,
						type: "boolean",
					},
					isPreferFoundryTokens: {
						name: "Prefer Foundry/System Tokens",
						help: `If enabled, tokens will be sourced from built-in compendiums first, then Plutonium second. If disabled, tokens will be sourced from Plutonium first, then built-in compendiums second.`,
						default: false,
						type: "boolean",
					},
					isLoadLocalPrereleaseIndex: {
						name: "Load Local Prerelease Content",
						help: `If enabled, the directory specified by the "Local Prerelease Content Directory" option will be read, and its contents added to the list of available sources.`,
						default: false,
						type: "boolean",
					},
					localPrereleaseDirectoryPath: {
						name: "Local Prerelease Content Directory",
						help: `The sub-directory of the "User Data" directory from which prerelease content should be automatically loaded if the "Load Local Prerelease" option is enabled.`,
						default: `assets/prerelease`,
						type: "string",
						additionalStyleClasses: "code",
					},
					isUseLocalPrereleaseIndexJson: {
						name: `Use <code>index.json</code> for Local Prerelease Content`,
						help: `If, rather than read the local prerelease content directory directly, an "index.json" file should be read when loading local prerelease content. This file should be of the form: {"toImport": [ ... list of filenames ... ]}. Note that this is required if players do not have "Use File Browser" permissions.`,
						default: false,
						type: "boolean",
					},
					localPrerelease: {
						name: "Additional Prerelease Files",
						help: `Prerelease files which should be automatically loaded and added to the list of available sources.`,
						default: [],
						type: "arrayStringShort",
						isCaseSensitive: true,
					},
					isLoadLocalHomebrewIndex: {
						name: "Load Local Homebrew",
						help: `If enabled, the directory specified by the "Local Homebrew Directory" option will be read, and its contents added to the list of available sources.`,
						default: false,
						type: "boolean",
					},
					localHomebrewDirectoryPath: {
						name: "Local Homebrew Directory",
						help: `The sub-directory of the "User Data" directory from which homebrew should be automatically loaded if the "Load Local Homebrew" option is enabled.`,
						default: `assets/homebrew`,
						type: "string",
						additionalStyleClasses: "code",
					},
					isUseLocalHomebrewIndexJson: {
						name: `Use <code>index.json</code> for Local Homebrew`,
						help: `If, rather than read the local homebrew directory directly, an "index.json" file should be read when loading local homebrew. This file should be of the form: {"toImport": [ ... list of filenames ... ]}. Note that this is required if players do not have "Use File Browser" permissions.`,
						default: false,
						type: "boolean",
					},
					localHomebrew: {
						name: "Additional Homebrew Files",
						help: `Homebrew files which should be automatically loaded and added to the list of available sources.`,
						default: [],
						type: "arrayStringShort",
						isCaseSensitive: true,
					},
				},
				settingsAdvanced: {
					...ConfigConsts._template_getImporterToggles(),
					isTreatJournalEntriesAsFolders: {
						name: "Treat Journal Entries as Folders",
						help: `If enabled, Journal Entries are treated as an additional folder level for the purpose of organising imports, etc.`,
						default: true,
						type: "boolean",
						isReloadRequired: true,
					},
					baseSiteUrl: {
						name: "Base Site URL",
						help: `The root server URL from which to load data and source images, and to link in rendered text. Note that, where possible, the module will use its own built-in data files, rather than call out to a remote server.`,
						type: "url",
						additionalStyleClasses: "code",
						default: null,
						isNullable: true,
						isReloadRequired: true,
					},
					isNoLocalData: {
						name: "Avoid Loading Local Data",
						help: `If enabled, any data which would normally be loaded from the module's local copies is instead loaded from the sites URL (which may be customised by editing the "Base Site Url" config option).`,
						default: false,
						type: "boolean",
					},
					isNoPrereleaseBrewIndexes: {
						name: "Avoid Loading Prerelease/Homebrew Indexes on Startup",
						help: `If enabled, prerelease/homebrew repository indexes won't be loaded during initial module load. This will effectively prevent any prerelease/homebrew sources from appearing in source listings. Note that these indexes are loaded in the background/asynchronously during normal operation, so should not negatively impact game load times, unless you have a particularly terrible internet connection.`,
						default: false,
						type: "boolean",
					},
					isUseLocalImages: {
						name: "Use Local Images",
						help: `If enabled, images will be sourced from the "Image/Token Directory" directory, defined above.`,
						default: false,
						type: "boolean",
					},
					isStrictMatching: {
						name: "Use Strict Entity Matching",
						help: `If enabled, any Plutonium feature which searches for existing data (for example, the class importer attempting to find existing class levels in a given class) will match by name and source. If disabled, only name is used.`,
						default: false,
						type: "boolean",
						isPlayerEditable: true,
					},
					basePrereleaseUrl: {
						name: "Base Prerelease Repository URL",
						help: `The root GitHub repository URL from which to load data and source images, and to link in rendered text, when importing prerelease content. URLs should be of the form "https://raw.githubusercontent.com/[username]/[repository name]/master".`,
						type: "url",
						additionalStyleClasses: "code",
						default: null,
						isNullable: true,
						isReloadRequired: true,
					},
					baseBrewUrl: {
						name: "Base Homebrew Repository URL",
						help: `The root GitHub repository URL from which to load data and source images, and to link in rendered text, when importing homebrew content. URLs should be of the form "https://raw.githubusercontent.com/[username]/[repository name]/master".`,
						type: "url",
						additionalStyleClasses: "code",
						default: null,
						isNullable: true,
						isReloadRequired: true,
					},
					tempFolderName: {
						name: "Temp Folder Name",
						help: `The name of a temporary folder created/deleted by some operations. Note that the importer will delete this folder regardless of its contents, as anything contained within it is assumed to be a temporary entity created by the importer.`,
						type: "string",
						default: "Temp",
					},
					isAutoAddAdditionalFonts: {
						name: "Automatically Add Extra Fonts",
						help: `If enabled, and you import content which requires additional fonts, these fonts will be added to your game's "Additional Fonts" setting.`,
						default: true,
						type: "boolean",
					},
				},
			},
			importCreature: {
				name: "Import (Creatures)",
				settings: {
					ownership: ConfigConsts._template_getEntityOwnership(`The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported creature.`),
					isImportBio: {
						name: "Import Fluff to Biography",
						help: `If enabled, any fluff text which is available for a creature will be imported into that creature's biography.`,
						default: true,
						type: "boolean",
					},
					isImportBioImages: {
						name: "Include Fluff Image in Biography",
						help: `If enabled, any fluff image which is available for a creature will be imported into that creature's biography.`,
						default: false,
						type: "boolean",
					},
					isImportBioVariants: {
						name: "Include Variants in Biography",
						help: `If enabled, any inset variant boxes associated with a creature will be imported into that creature's biography.`,
						default: true,
						type: "boolean",
					},
					isImportVariantsAsFeatures: {
						name: "Import Variants as Features",
						help: `If enabled, any inset variant boxes associated with a creature will be imported into that creature's features.`,
						default: false,
						type: "boolean",
					},
					isSecretWrapAttacks: {
						name: `&quot;Secret&quot; Attack Descriptions`,
						help: `If enabled, creature attack descriptions will be wrapped in "Secret" blocks, which are not shown when rolling.`,
						default: false,
						type: "boolean",
					},
					...ConfigConsts._template_getTokenSettings({actorType: "npc"}),
					itemWeightAndValueSizeScaling: {
						name: "Item Weight & Value Scaling",
						help: `The method by which to scale the weights and values of non-standard-sizes items carried by creatures.`,
						default: 1,
						type: "enum",
						values: [
							{
								value: 1,
								name: "No scaling",
							},
							{
								value: 2,
								name: `"Barding" scaling (multiplicative)`,
								help: `Based on the rules for calculating the weight and cost of barding, as presented in the Player's Handbook (p. 155).`,
							},
							{
								value: 3,
								name: `"Gurt's Greataxe" scaling (exponential)`,
								help: `Based on the giant-size greateaxe of the same name found in Storm King's Thunder (p. 234).`,
							},
						],
					},
					isMetricDistance: {
						name: "Convert Speeds to Metric",
						help: `Whether or not creature speed units should be converted to an approximate metric equivalent (${ConfigConsts._DISP_METRIC_FEET}).`,
						default: false,
						type: "boolean",
					},
					spellcastingPrimaryTraitMode: {
						name: "Spellcasting Primary Trait Selection Method",
						help: `The method by which a primary spellcasting trait (i.e., the spellcasting trait used to set spellcasting ability, spell DC, and spell attack bonus) is selected if a creature has multiple spellcasting traits with associated ability scores.`,
						default: 1,
						type: "enum",
						values: [
							{
								value: 1,
								name: "Highest spell count",
								help: `Use whichever spellcasting trait has the most spells listed.`,
							},
							{
								value: 2,
								name: `Highest ability score`,
								help: `Use whichever spellcasting trait has the highest associated ability score. Note that this may prefer innate spellcasting traits over spellcasting class levels.`,
							},
						],
					},
					nameTags: {
						name: "Add Tag Suffixes to Names",
						help: `Add tags to an imported creature's name, to allow easier searching (especially within compendiums).`,
						default: {
							[ConfigConsts.C_CREATURE_NAMETAGS_CR]: false,
							[ConfigConsts.C_CREATURE_NAMETAGS_TYPE]: false,
							[ConfigConsts.C_CREATURE_NAMETAGS_TYPE_WITH_TAGS]: false,
						},
						type: "multipleChoice",
						choices: [
							{value: ConfigConsts.C_CREATURE_NAMETAGS_CR, name: "Add [CR] tag"},
							{value: ConfigConsts.C_CREATURE_NAMETAGS_TYPE, name: "Add [type] tag"},
							{value: ConfigConsts.C_CREATURE_NAMETAGS_TYPE_WITH_TAGS, name: "Add [type (with tags)] tag"},
						],
					},
					isAddSoundEffect: {
						name: "MLD: Add Audio as Sound Effect",
						help: `If, when the Monk's Little Details module is active, an imported creature should have its sound effect set, where an audio clip is available (for official data, this will usually be an audio clip of the creature's name being pronounced).`,
						default: false,
						type: "boolean",
					},
				},
				settingsAdvanced: {
					additionalDataCompendium: {
						name: "Additional Data Compendiums",
						help: `A comma-separated list of compendiums that the Creature Importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.`,
						default: ConfigConsts.SRD_COMPENDIUMS_CREATURES.join(", "),
						type: "string",
						typeSub: "compendiums",
						additionalStyleClasses: "code",
						isNullable: true,
					},
					additionalDataCompendiumFeatures: {
						name: "Additional Data Compendiums (Features)",
						help: `A comma-separated list of compendiums that the Creature Importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.`,
						default: ConfigConsts.SRD_COMPENDIUMS_CREATURE_FEATURES.join(", "),
						type: "string",
						typeSub: "compendiums",
						additionalStyleClasses: "code",
						isNullable: true,
					},
					isUseTokenImageAsPortrait: {
						name: "Use Token Image as Portrait",
						help: `If enabled, a creature's token image will be preferred over its portrait image when populating its sheet portrait during import.`,
						default: false,
						type: "boolean",
					},
					isSplitMeleeRangedAttack: {
						name: `Split &quot;Melee or Ranged Attack&quot; Actions`,
						help: `If enabled, the importer will create two sheet items per "Melee or Ranged Attack" action, each with the appropriate range set.`,
						default: true,
						type: "boolean",
						compatibilityModeValues: {
							[UtilCompat.MODULE_PLUTONIUM_ADDON_AUTOMATION]: true,
						},
					},
					isSplitConditionalDamageAttack: {
						name: `Split Conditional Damage Actions`,
						help: `If enabled, the importer will create two sheet items ("Base" and "Full") per "... plus <x> damage if <y>" action, where the "base" item does not include the conditional damage, and the "full" item does include the conditional damage.`,
						default: true,
						type: "boolean",
						compatibilityModeValues: {
							[UtilCompat.MODULE_PLUTONIUM_ADDON_AUTOMATION]: true,
						},
					},
					isAddFakeClassToCharacter: {
						name: "Add Class to Creatures Imported as Player Characters",
						help: `If enabled, when importing a creature as a Player Character ("character"-type actor) a class item will be added to the actor's sheet, in order to set proficiency bonus and spellcasting levels.`,
						default: true,
						type: "boolean",
					},
					isUseStaticAc: {
						name: "Use Static AC Values",
						help: `If enabled, creature AC will be imported as a static number (rather than relying on the sheet's formula calculation), and creature armor will be imported as unequipped.`,
						default: false,
						type: "boolean",
					},
					isUseCustomNaturalAc: {
						name: "Use Custom Natural Armor Formula",
						help: `If enabled, creatures with natural armor will have their armor formula broken down as "@attributes.ac.armor + @attributes.ac.dex + <naturalBonus>", allowing any later Dexterity score changes to be reflected in the creatures AC.`,
						default: false,
						type: "boolean",
					},
					isPreferFlatSavingThrows: {
						name: "Prefer Flat Saving Throws",
						help: `If enabled, a saving throw for a sheet item will always have "flat" scaling, with the flat DC value set to match the number in the creature's stat block. If disabled, a sheet item's saving throw scaling may be set as an ability score, provided that doing so produces the same value for the DC as is listed in the creature's stat block.`,
						default: false,
						type: "boolean",
					},
				},
				settingsHacks: {
					isUsePathfinderTokenPackBestiariesImages: {
						name: "Use &quot;Pathfinder Token Pack: Bestiaries&quot; Tokens/Portraits",
						help: `If enabled, and the "Pathfinder Token Pack: Bestiaries" module is installed and enabled, the importer will attempt to use token and portrait art from the "Pathfinder Token Pack: Bestiaries" module.`,
						default: false,
						type: "boolean",
					},
				},
			},
			importVehicle: {
				name: "Import (Vehicles)",
				settings: {
					ownership: ConfigConsts._template_getEntityOwnership(`The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported vehicle.`),
					...ConfigConsts._template_getTokenSettings({actorType: "vehicle"}),
					isMetricDistance: {
						name: "Convert Speeds to Metric",
						help: `Whether or not vehicle speed units should be converted to an approximate metric equivalent (${ConfigConsts._DISP_METRIC_FEET}; ${ConfigConsts._DISP_METRIC_MILES}).`,
						default: false,
						type: "boolean",
					},
					isImportBio: {
						name: "Import Fluff to Description",
						help: `If enabled, any fluff text which is available for a vehicle will be imported into that vehicle's description.`,
						default: true,
						type: "boolean",
					},
					isImportBioImages: {
						name: "Include Fluff Image in Description",
						help: `If enabled, any fluff image which is available for a vehicle will be imported into that vehicle's description.`,
						default: false,
						type: "boolean",
					},
				},
				settingsAdvanced: {
					additionalDataCompendium: {
						name: "Additional Data Compendiums",
						help: `A comma-separated list of compendiums that the vehicle importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.`,
						default: "",
						type: "string",
						typeSub: "compendiums",
						additionalStyleClasses: "code",
						isNullable: true,
					},
					isUseTokenImageAsPortrait: {
						name: "Use Token Image as Portrait",
						help: `If enabled, a vehicle's token image will be preferred over its portrait image when populating its sheet portrait during import.`,
						default: false,
						type: "boolean",
					},
					...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({name: "vehicles"}),
				},
			},
			importVehicleUpgrade: {
				name: "Import (Vehicle Upgrades)",
				settings: {
					ownership: ConfigConsts._template_getEntityOwnership(`The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported vehicle upgrades.`),
					isMetricDistance: {
						name: "Convert Speeds to Metric",
						help: `Whether or not vehicle upgrade speed units should be converted to an approximate metric equivalent (${ConfigConsts._DISP_METRIC_FEET}).`,
						default: false,
						type: "boolean",
					},
				},
				settingsAdvanced: {
					...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({name: "vehicle upgrades"}),
					isImportDescription: {
						name: "Import Text as Description",
						help: `If enabled, a vehicle upgrade's text will be imported as item description.`,
						default: true,
						type: "boolean",
					},
				},
			},
			importObject: {
				name: "Import (Objects)",
				settings: {
					ownership: ConfigConsts._template_getEntityOwnership(`The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported object.`),
					...ConfigConsts._template_getTokenSettings({actorType: "vehicle"}),
					isMetricDistance: {
						name: "Convert Speeds to Metric",
						help: `Whether or not object speed units should be converted to an approximate metric equivalent (${ConfigConsts._DISP_METRIC_FEET}).`,
						default: false,
						type: "boolean",
					},
					isImportBio: {
						name: "Import Fluff to Description",
						help: `If enabled, any fluff text which is available for an object will be imported into that object's description.`,
						default: true,
						type: "boolean",
					},
					isImportBioImages: {
						name: "Include Fluff Image in Description",
						help: `If enabled, any fluff image which is available for an object will be imported into that object's description.`,
						default: false,
						type: "boolean",
					},
				},
				settingsAdvanced: {
					isUseTokenImageAsPortrait: {
						name: "Use Token Image as Portrait",
						help: `If enabled, an object's token image will be preferred over its portrait image when populating its sheet portrait during import.`,
						default: false,
						type: "boolean",
					},
				},
			},
			importFeat: {
				name: "Import (Feats)",
				settings: {
					ownership: ConfigConsts._template_getEntityOwnership(`The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported feat.`),
					isMetricDistance: {
						name: "Convert Speeds to Metric",
						help: `Whether or not feat speed units should be converted to an approximate metric equivalent (${ConfigConsts._DISP_METRIC_FEET}).`,
						default: false,
						type: "boolean",
					},
				},
				settingsAdvanced: {
					...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({name: "feats"}),
					isImportDescription: {
						name: "Import Text as Description",
						help: `If enabled, a feat's text will be imported as item description.`,
						default: true,
						type: "boolean",
					},
				},
			},
			importBackground: {
				name: "Import (Backgrounds)",
				settings: {
					ownership: ConfigConsts._template_getEntityOwnership(`The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported background.`),
				},
				settingsAdvanced: {
					additionalDataCompendium: {
						name: "Additional Data Compendiums (Backgrounds)",
						help: `A comma-separated list of compendiums that the background importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.`,
						default: ConfigConsts.SRD_COMPENDIUMS_BACKGROUNDS_AND_FEATURES.join(", "),
						type: "string",
						typeSub: "compendiums",
						additionalStyleClasses: "code",
						isNullable: true,
					},
					additionalDataCompendiumFeatures: {
						name: "Additional Data Compendiums (Features)",
						help: `A comma-separated list of compendiums that the background importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.`,
						default: ConfigConsts.SRD_COMPENDIUMS_BACKGROUNDS_AND_FEATURES.join(", "),
						type: "string",
						typeSub: "compendiums",
						additionalStyleClasses: "code",
						isNullable: true,
					},
					...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({name: "backgrounds"}),
					isImportDescription: {
						name: "Import Text as Description",
						help: `If enabled, a background's text will be imported as item description.`,
						default: true,
						type: "boolean",
					},
				},
			},
			importBackgroundFeature: {
				name: "Import (Background Features)",
				settings: {
					ownership: ConfigConsts._template_getEntityOwnership(`The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported background feature.`),
				},
			},
			importClass: {
				name: "Import (Classes & Subclasses)",
				settings: {
					ownership: ConfigConsts._template_getEntityOwnership(`The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported class or subclass.`),
					isAddUnarmedStrike: {
						name: "Add Unarmed Strike",
						help: `If enabled, importing a class to an actor will create an "Unarmed Strike" weapon, unless one already exists.`,
						default: false,
						type: "boolean",
						isPlayerEditable: true,
					},
					isImportClassTable: {
						name: "Import Class Table to Description",
						help: `If enabled, a class's table will be imported as part of the class item's description.`,
						default: true,
						type: "boolean",
						isPlayerEditable: true,
					},
					isAddLevelUpButton: {
						name: `Add &quot;Level Up&quot; Button to Character Sheets`,
						help: `If enabled, a "Level Up" button will be displayed in the top-right corner of a character's sheet (assuming the default dnd5e sheet is used).`,
						default: true,
						type: "boolean",
						isPlayerEditable: true,
					},
					isSetXp: {
						name: "Set Minimum Actor XP on Class Import",
						help: `If enabled, during class import, actor XP will be set to the minimum XP value required for the actor's new level, if the actor's current XP is insufficient for them to reach their new level.`,
						default: false,
						type: "boolean",
						isPlayerEditable: true,
					},
					hpIncreaseMode: {
						name: "Hit Points Increase Mode",
						help: `Determines how Hit Points are calculated when using the Class Importer to level up. If left unspecified, a user will be prompted to choose the mode each time their Hit Points are increased by the Class Importer.`,
						type: "enum",
						values: [
							{value: ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__TAKE_AVERAGE, name: ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE___NAMES[ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__TAKE_AVERAGE]},
							{value: ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__MIN, name: ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE___NAMES[ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__MIN]},
							{value: ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__MAX, name: ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE___NAMES[ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__MAX]},
							{value: ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL, name: ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE___NAMES[ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL]},
							{value: ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL_CUSTOM, name: ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE___NAMES[ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL_CUSTOM]},
							{value: ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__DO_NOT_INCREASE, name: ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE___NAMES[ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__DO_NOT_INCREASE]},
						],
						default: null,
						isNullable: true,
					},
					hpIncreaseModeCustomRollFormula: {
						name: "Hit Points Increase Custom Roll Formula",
						help: `A custom roll formula to be used when gaining HP on level up. Used if either the "Hit Points Increase Mode" option is set to "${ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE___NAMES[ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL_CUSTOM]}", or if a player chooses "${ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE___NAMES[ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL_CUSTOM]}" when prompted to select their Hit Points Increase Mode. Use "@hd.faces" for the type of dice (i.e., the "8" in "1d8"), and "@hd.number" for "number of dice" (i.e., the "1" in "1d8"). Note that backticks (\`) around an expression will also be replaced so "\`@hd.number\`d\`@hd.faces\`" will produce e.g. "1d8", should you need to avoid using brackets.`,
						placeholder: "(@hd.number)d(@hd.faces)",
						type: "string",
						additionalStyleClasses: "code",
						default: null,
						isNullable: true,
					},
				},
				settingsAdvanced: {
					additionalDataCompendiumClasses: {
						name: "Additional Data Compendiums (Classes)",
						help: `A comma-separated list of compendiums that the class importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.`,
						default: ConfigConsts.SRD_COMPENDIUMS_CLASSES.join(", "),
						type: "string",
						typeSub: "compendiums",
						additionalStyleClasses: "code",
						isNullable: true,
					},
					additionalDataCompendiumSubclasses: {
						name: "Additional Data Compendiums (Subclasses)",
						help: `A comma-separated list of compendiums that the class importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.`,
						default: ConfigConsts.SRD_COMPENDIUMS_SUBCLASSES.join(", "),
						type: "string",
						typeSub: "compendiums",
						additionalStyleClasses: "code",
						isNullable: true,
					},
					additionalDataCompendiumFeatures: {
						name: "Additional Data Compendiums (Features)",
						help: `A comma-separated list of compendiums that the class importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.`,
						default: ConfigConsts.SRD_COMPENDIUMS_CLASS_FEATURES.join(", "),
						type: "string",
						typeSub: "compendiums",
						additionalStyleClasses: "code",
						isNullable: true,
					},
					...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({name: "class"}),
					isImportDescription: {
						name: "Import Text as Description",
						help: `If enabled, a class's text will be imported as item description.`,
						default: true,
						type: "boolean",
					},
					isUseDefaultSubclassImage: {
						name: "Subclass Default Image Fallback",
						help: `If enabled, when importing a subclass which has no well-defined image, use a default image based on class. If disabled, a generic black and white image will be used as a fallback instead.`,
						default: true,
						type: "boolean",
						isPlayerEditable: true,
					},
					isHideSubclassRows: {
						name: "Hide Subclasses in Class Importer",
						help: `If enabled, the class/subclass list in the Class Importer will only show classes.`,
						default: false,
						type: "boolean",
						isPlayerEditable: true,
					},
				},
				settingsHacks: {
					isSuppressAdvancementsOnImportedDrop: {
						name: "Suppress Advancements During Drop Flow",
						help: `If enabled, dropping a Plutonium-imported class/subclass to a sheet will briefly disable the default advancement workflow, potentially allowing Plutonium's importer to run instead.`,
						default: true,
						type: "boolean",
					},
				},
			},
			importClassSubclassFeature: {
				name: "Import (Class & Sub. Features)",
				help: "Import (Class & Subclass Features)",
				settings: {
					ownership: ConfigConsts._template_getEntityOwnership(`The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported class/subclass feature.`),
					isMetricDistance: {
						name: "Convert Speeds to Metric",
						help: `Whether or not class/subclass feature speed units should be converted to an approximate metric equivalent (${ConfigConsts._DISP_METRIC_FEET}).`,
						default: false,
						type: "boolean",
					},
				},
				settingsAdvanced: {
					...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({name: "class features"}),
					isImportDescription: {
						name: "Import Text as Description",
						help: `If enabled, a class/subclass feature's text will be imported as item description.`,
						default: true,
						type: "boolean",
					},
				},
			},
			importItem: {
				name: "Import (Items)",
				settings: {
					ownership: ConfigConsts._template_getEntityOwnership(`The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported item.`),
					isAddActiveEffects: {
						name: "Populate Active Effects",
						help: `If items should have active effects created during import.`,
						default: true,
						type: "boolean",
											},
					isMetricDistance: {
						name: "Convert Item Ranges to Metric",
						help: `Whether or not item range units should be converted to an approximate metric equivalent (${ConfigConsts._DISP_METRIC_FEET}).`,
						default: false,
						type: "boolean",
					},
					isMetricWeight: {
						name: "Convert Item Weights to Metric",
						help: `Whether or not item weight units should be converted to an approximate metric equivalent (${ConfigConsts._DISP_METRIC_POUNDS}).`,
						default: false,
						type: "boolean",
					},
					inventoryStackingMode: {
						name: "Inventory Stacking Mode",
						help: `If imported items should "stack" with existing items when imported to an actor's inventory. If stacking is allowed, the importer will check for an existing item when importing an item to an actor's sheet. If the item already exists, the importer will increase the quantity of that item in the actor's inventory, rather than create a new copy of the item in the actor's inventory.`,
						default: ConfigConsts.C_ITEM_ATTUNEMENT_SMART,
						type: "enum",
						values: [
							{
								value: ConfigConsts.C_ITEM_ATTUNEMENT_NEVER,
								name: `Never Stack`,
							},
							{
								value: ConfigConsts.C_ITEM_ATTUNEMENT_SMART,
								name: `Sometimes Stack (e.g. consumables, throwables)`,
							},
							{
								value: ConfigConsts.C_ITEM_ATTUNEMENT_ALWAYS,
								name: `Always Stack`,
							},
						],
					},
					isSplitPacksActor: {
						name: "Import Packs to Actors as Constituent Items",
						help: `If "pack" items (explorer's pack, dungeoneer's pack) should be broken down and imported as their constituent items when importing to an actor's items.`,
						default: true,
						type: "boolean",
						isPlayerEditable: true,
					},
					isSplitAtomicPacksActor: {
						name: "Import Item Stacks to Actors as Constituent Items",
						help: `If an item which is formed of multiple constituent items of the same type, such as "Bag of Ball Bearings (1,000)", should be split up into its constituent items (a "Ball Bearing" item with its sheet quantity set to 1,000, in this example).`,
						default: false,
						type: "boolean",
						isPlayerEditable: true,
					},
					throwables: {
						name: "Throwing Items",
						help: `A list of items which are imported with their usage set to deplete their own quantity when used.`,
						default: ["Handaxe", "Javelin", "Light Hammer", "Dart", "Net"],
						type: "arrayStringShort",
						isPlayerEditable: true,
					},
					altAbilityScoreByClass: {
						name: "Alt Ability Scores by Class",
						help: `A list of <class>-<item>-<score> mappings, an entry in which, when importing an item, will change the default ability score used by an item for a member of that class.`,
						default: [
							"monk:club:dex",
							"monk:dagger:dex",
							"monk:handaxe:dex",
							"monk:javelin:dex",
							"monk:light hammer:dex",
							"monk:mace:dex",
							"monk:quarterstaff:dex",
							"monk:shortsword:dex",
							"monk:sickle:dex",
							"monk:spear:dex",
						],
						type: "arrayStringShort",
						isPlayerEditable: true,
					},
					attunementType: {
						name: "Attunement when Importing to Directory/Compendium",
						help: `The attunement type to use when importing an item which can be attuned.`,
						default: ConfigConsts.C_ITEM_ATTUNEMENT_REQUIRED,
						type: "enum",
						values: [
							{
								value: ConfigConsts.C_ITEM_ATTUNEMENT_NONE,
								name: `None`,
							},
							{
								value: ConfigConsts.C_ITEM_ATTUNEMENT_REQUIRED,
								name: `Attunement required`,
							},
							{
								value: ConfigConsts.C_ITEM_ATTUNEMENT_ATTUNED,
								name: `Attuned`,
							},
						],
					},
					attunementTypeActor: {
						name: "Attunement when Importing to Actors",
						help: `The attunement type to use when importing an item which can be attuned.`,
						default: ConfigConsts.C_ITEM_ATTUNEMENT_ATTUNED,
						type: "enum",
						values: [
							{
								value: ConfigConsts.C_ITEM_ATTUNEMENT_NONE,
								name: `None`,
							},
							{
								value: ConfigConsts.C_ITEM_ATTUNEMENT_REQUIRED,
								name: `Attunement required`,
							},
							{
								value: ConfigConsts.C_ITEM_ATTUNEMENT_ATTUNED,
								name: `Attuned`,
							},
						],
					},
					isImportDescriptionHeader: {
						name: "Include Damage, Properties, Rarity, and Attunement in Description",
						help: `If enabled, an imported item's description will include text generated from its rarity, attunement requirements, damage, and other properties.`,
						default: false,
						type: "boolean",
						isPlayerEditable: true,
					},
					isUseOtherFormulaFieldForExtraDamage: {
						name: `Treat Extra Damage as &quot;Other Formula&quot;`,
						help: `This moves extra damage rolls to the "Other Formula" dice field, which can improve compatibility with some modules.`,
						default: false,
						type: "boolean",
						compatibilityModeValues: {
							[UtilCompat.MODULE_PLUTONIUM_ADDON_AUTOMATION]: true,
						},
					},
				},
				settingsAdvanced: {
					additionalDataCompendium: {
						name: "Additional Data Compendiums",
						help: `A comma-separated list of compendiums that the Item Importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.`,
						default: ConfigConsts.SRD_COMPENDIUMS_ITEMS.join(", "),
						type: "string",
						typeSub: "compendiums",
						additionalStyleClasses: "code",
						isNullable: true,
					},
					replacementDataCompendium: {
						name: "Replacement Data Compendiums",
						help: `A comma-separated list of compendiums that the Item Importer will attempt to pull items from, rather than using the data Plutonium would otherwise generate. This is useful when the Item Importer is used by other importers, e.g. when the Creature Importer is adding items to newly-created actors.`,
						default: "",
						type: "string",
						typeSub: "compendiums",
						additionalStyleClasses: "code",
						isNullable: true,
					},
					...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({name: "items"}),
					isImportDescription: {
						name: "Import Text as Description",
						help: `If enabled, an item's text will be imported as item description.`,
						default: true,
						type: "boolean",
					},
				},
			},
			importPsionic: {
				name: "Import (Psionics)",
				settings: {
					ownership: ConfigConsts._template_getEntityOwnership(`The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported psionic.`),
					psiPointsResource: {
						name: "Psi Points Resource",
						help: `The resource consumed by psionics.`,
						default: "resources.primary.value",
						type: "enum",
						values: [
							{
								value: "resources.primary",
							},
							{
								value: "resources.secondary",
							},
							{
								value: "resources.tertiary",
							},
							{
								value: ConfigConsts.C_SPELL_POINTS_RESOURCE__SHEET_ITEM,
								name: `"Psi Points" sheet item`,
							},
							{
								value: ConfigConsts.C_SPELL_POINTS_RESOURCE__ATTRIBUTE_CUSTOM,
								name: `Custom (see below)`,
							},
						],
						isPlayerEditable: true,
					},
					psiPointsResourceCustom: {
						name: "Psi Points Custom Resource",
						help: `The name of the custom resource to use if "Custom" is selected for "Psi Points Resource", above. This supports modules that expand the number of available sheet resources, such as "5e-Sheet Resources Plus" (which adds e.g. "resources.fourth", "resources.fifth", ...).`,
						type: "string",
						additionalStyleClasses: "code",
						default: null,
						isNullable: true,
						isPlayerEditable: true,
					},
					isImportAsSpell: {
						name: "Import as Spells",
						help: `If enabled, psionics will be imported as spells, rather than features.`,
						default: false,
						type: "boolean",
					},
				},
				settingsAdvanced: {
					...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({name: "psionic"}),
					isImportDescription: {
						name: "Import Text as Description",
						help: `If enabled, a psionic's text will be imported as item description.`,
						default: true,
						type: "boolean",
					},
				},
			},
			importRace: {
				name: "Import (Races)",
				settings: {
					ownership: ConfigConsts._template_getEntityOwnership(`The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported race.`),
					isMetricDistance: {
						name: "Convert Speeds to Metric",
						help: `Whether or not race speed units should be converted to an approximate metric equivalent (${ConfigConsts._DISP_METRIC_FEET}).`,
						default: false,
						type: "boolean",
					},
				},
				settingsAdvanced: {
					additionalDataCompendium: {
						name: "Additional Data Compendiums",
						help: `A comma-separated list of compendiums that the race importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.`,
						default: ConfigConsts.SRD_COMPENDIUMS_RACES_AND_FEATURES.join(", "),
						type: "string",
						typeSub: "compendiums",
						additionalStyleClasses: "code",
						isNullable: true,
					},
					...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({name: "races"}),
					isImportDescription: {
						name: "Import Text as Description",
						help: `If enabled, a race's text will be imported as item description.`,
						default: true,
						type: "boolean",
					},
				},
			},
			importRaceFeature: {
				name: "Import (Race Features)",
				settings: {
					ownership: ConfigConsts._template_getEntityOwnership(`The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported race feature.`),
				},
				settingsAdvanced: {
					additionalDataCompendiumFeatures: {
						name: "Additional Data Compendiums",
						help: `A comma-separated list of compendiums that the race feature importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.`,
						default: ConfigConsts.SRD_COMPENDIUMS_RACES_AND_FEATURES.join(", "),
						type: "string",
						typeSub: "compendiums",
						additionalStyleClasses: "code",
						isNullable: true,
					},
					...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({name: "race features"}),
				},
			},
			importTable: {
				name: "Import (Table)",
				settings: {
					ownership: ConfigConsts._template_getEntityOwnership(`The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported table.`),
				},
				settingsAdvanced: {
					additionalDataCompendium: {
						name: "Additional Data Compendiums",
						help: `A comma-separated list of compendiums that the Table Importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.`,
						default: ConfigConsts.SRD_COMPENDIUMS_TABLES.join(", "),
						type: "string",
						typeSub: "compendiums",
						additionalStyleClasses: "code",
						isNullable: true,
					},
				},
			},
			importSpell: {
				name: "Import (Spells)",
				settings: {
					ownership: ConfigConsts._template_getEntityOwnership(`The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported spell.`),
					prepareActorSpells: {
						name: "Prepare Actor Spells",
						help: "Whether or not spells that are imported to actor sheets should be prepared by default.",
						default: true,
						type: "boolean",
						isPlayerEditable: true,
					},
					prepareSpellItems: {
						name: "Prepare Spell Items",
						help: "Whether or not spells that are imported to the items directory should be prepared by default.",
						default: false,
						type: "boolean",
					},
					actorSpellPreparationMode: {
						name: "Actor Spell Preparation Mode",
						help: `The default spell preparation mode for spells imported to actor sheets.`,
						default: "prepared",
						type: "enum",
						values: [
							{
								value: "",
								name: "(None)",
							},
							{
								value: "always",
								name: "Always Prepared",
							},
							{
								value: "prepared",
								name: "Prepared",
							},
							{
								value: "innate",
								name: "Innate Spellcasting",
							},
							{
								value: "pact",
								name: "Pact Magic",
							},
						],
						isPlayerEditable: true,
					},
					isAutoDetectActorSpellPreparationMode: {
						name: "Auto-Detect Actor Spell Preparation Mode",
						help: `If enabled, the default spell preparation mode for spells imported to actor sheets (as defined by "Actor Spell Preparation Mode") may be automatically overridden, e.g. "pact magic" is automatically used when importing to a warlock.`,
						default: true,
						type: "boolean",
						isPlayerEditable: true,
					},
					spellItemPreparationMode: {
						name: "Spell Item Preparation Mode",
						help: `The default spell preparation mode for spells imported to the items directory.`,
						default: "prepared",
						type: "enum",
						values: [
							{
								value: "",
								name: "(None)",
							},
							{
								value: "always",
								name: "Always Prepared",
							},
							{
								value: "prepared",
								name: "Prepared",
							},
							{
								value: "innate",
								name: "Innate Spellcasting",
							},
							{
								value: "pact",
								name: "Pact Magic",
							},
						],
					},
					spellPointsMode: {
						name: "Use Spell Points",
						help: `If enabled, imported spells which would use spell slots will instead be marked as "at will" and set to consume an a sheet or feature resource. (The "Spell Points" variant rule can be found in the DMG, page 288.)`,
						default: ConfigConsts.C_SPELL_POINTS_MODE__DISABLED,
						type: "enum",
						values: [
							{
								name: "Disabled",
								value: ConfigConsts.C_SPELL_POINTS_MODE__DISABLED,
							},
							{
								name: "Enabled",
								value: ConfigConsts.C_SPELL_POINTS_MODE__ENABLED,
							},
							{
								name: "Enabled, and Use 99 Slots",
								value: ConfigConsts.C_SPELL_POINTS_MODE__ENABLED_AND_UNLIMITED_SLOTS,
								help: `If enabled, an imported spells will retain its "Spell Preparation Mode" in addition to consuming a "Spell Points" sheet/feature resource. This improves compatibility with many sheets and modules. To allow "unlimited" spellcasting at each spell level, a character's spell slots for each level will be set to 99.`,
							},
						],
						isPlayerEditable: true,
					},
					spellPointsResource: {
						name: "Spell Points Resource",
						help: `The resource consumed by spells imported with "Use Spell Points" enabled.`,
						default: "resources.primary.value",
						type: "enum",
						values: [
							{
								value: "resources.primary",
							},
							{
								value: "resources.secondary",
							},
							{
								value: "resources.tertiary",
							},
							{
								value: ConfigConsts.C_SPELL_POINTS_RESOURCE__SHEET_ITEM,
								name: `"Spell Points" sheet item`,
							},
							{
								value: ConfigConsts.C_SPELL_POINTS_RESOURCE__ATTRIBUTE_CUSTOM,
								name: `Custom (see below)`,
							},
						],
						isPlayerEditable: true,
					},
					spellPointsResourceCustom: {
						name: "Spell Points Custom Resource",
						help: `The name of the custom resource to use if "Custom" is selected for "Spell Points Resource", above. This supports modules that expand the number of available sheet resources, such as "5e-Sheet Resources Plus" (which adds e.g. "resources.fourth", "resources.fifth", ...).`,
						type: "string",
						additionalStyleClasses: "code",
						default: null,
						isNullable: true,
						isPlayerEditable: true,
					},
					isIncludeClassesInDescription: {
						name: "Include Caster Classes in Spell Description",
						help: `If enabled, an imported spell's description will include the list of classes which have the spell on their spell list.`,
						default: false,
						type: "boolean",
					},
					isMetricDistance: {
						name: "Convert Spell Ranges and Areas to Metric",
						help: `Whether or not spell range/area units should be converted to an approximate metric equivalent (${ConfigConsts._DISP_METRIC_FEET}; ${ConfigConsts._DISP_METRIC_MILES}).`,
						default: false,
						type: "boolean",
					},
					isFilterOnOpen: {
						name: "Apply Class Filter when Opening on Actor",
						help: "If enabled, and the importer is opened from an actor, the spell list will be filtered according to that actor's current class(es).",
						default: true,
						type: "boolean",
						isPlayerEditable: true,
					},
				},
				settingsAdvanced: {
					additionalDataCompendium: {
						name: "Additional Data Compendiums",
						help: `A comma-separated list of compendiums that the Spell Importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.`,
						default: ConfigConsts.SRD_COMPENDIUMS_SPELLS.join(", "),
						type: "string",
						typeSub: "compendiums",
						additionalStyleClasses: "code",
						isNullable: true,
					},
					replacementDataCompendium: {
						name: "Replacement Data Compendiums",
						help: `A comma-separated list of compendiums that the Spell Importer will attempt to pull spells from, rather than using the data Plutonium would otherwise generate. This is useful when the Spell Importer is used by other importers, e.g. when the Creature Importer is adding spells to newly-created actors.`,
						default: "",
						type: "string",
						typeSub: "compendiums",
						additionalStyleClasses: "code",
						isNullable: true,
					},
					...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({name: "spells"}),
					isImportDescription: {
						name: "Import Text as Description",
						help: `If enabled, a spell's text will be imported as item description.`,
						default: true,
						type: "boolean",
					},
					isUseCustomSrdIcons: {
						name: "Use Custom Icons for SRD Spells",
						help: `If enabled, imported SRD spells will use an alternate icon set, as curated by the community.`,
						default: true,
						type: "boolean",
						isPlayerEditable: true,
					},
					isUseDefaultSchoolImage: {
						name: "School Default Image Fallback",
						help: `If enabled, when importing a spell which has no well-defined image, use a default image based on the school of the spell. If disabled, a generic black and white image will be used as a fallback instead.`,
						default: true,
						type: "boolean",
						isPlayerEditable: true,
					},
					spellPointsModeNpc: {
						name: "Use Spell Points (NPCs)",
						help: `If enabled, a spell imported to an NPC which would use spell slots will instead be marked as "at will" and set to consume an a sheet or feature resource. (The "Spell Points" variant rule can be found in the DMG, page 288.)`,
						default: ConfigConsts.C_SPELL_POINTS_MODE__DISABLED,
						type: "enum",
						values: [
							{
								name: "Disabled",
								value: ConfigConsts.C_SPELL_POINTS_MODE__DISABLED,
							},
							{
								name: "Enabled",
								value: ConfigConsts.C_SPELL_POINTS_MODE__ENABLED,
							},
							{
								name: "Enabled, but Use 99 Slots",
								value: ConfigConsts.C_SPELL_POINTS_MODE__ENABLED_AND_UNLIMITED_SLOTS,
								help: `If enabled, imported spells will retain their "prepared"/etc. types in addition to consuming a "Spell Points" sheet/feature resource. This allows easier organisation of spells, and better compatibility with many modules. To allow "unlimited" spellcasting at each spell level, a character's spell slots for each level will be set to 99.`,
							},
						],
					},
				},
			},
			importRule: {
				name: "Import (Rules)",
				settings: {
					ownership: ConfigConsts._template_getEntityOwnership(`The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported rule.`),
				},
			},
			importLanguage: {
				name: "Import (Languages)",
				settings: {
					ownership: ConfigConsts._template_getEntityOwnership(`The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported language.`),
				},
			},
			importOptionalFeature: {
				name: "Import (Options & Features)",
				settings: {
					ownership: ConfigConsts._template_getEntityOwnership(`The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported option/feature.`),
					isMetricDistance: {
						name: "Convert Speeds to Metric",
						help: `Whether or not optional feature speed units should be converted to an approximate metric equivalent (${ConfigConsts._DISP_METRIC_FEET}).`,
						default: false,
						type: "boolean",
					},
				},
				settingsAdvanced: {
					additionalDataCompendium: {
						name: "Additional Data Compendiums",
						help: `A comma-separated list of compendiums that the optional feature importer will attempt to pull additional data (including art) from rather than use the default Plutonium icons.`,
						default: ConfigConsts.SRD_COMPENDIUMS_OPTIONAL_FEATURES.join(", "),
						type: "string",
						typeSub: "compendiums",
						additionalStyleClasses: "code",
						isNullable: true,
					},
					...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({name: "optional features"}),
					isImportDescription: {
						name: "Import Text as Description",
						help: `If enabled, an optional feature's text will be imported as item description.`,
						default: true,
						type: "boolean",
					},
				},
			},
			importConditionDisease: {
				name: "Import (Conditions & Diseases)",
				settings: {
					ownership: ConfigConsts._template_getEntityOwnership(`The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported condition/diseases.`),
				},
				settingsAdvanced: {
					...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({name: "conditions/diseases"}),
					isImportDescription: {
						name: "Import Text as Description",
						help: `If enabled, a condition/disease's text will be imported as item description.`,
						default: true,
						type: "boolean",
					},
				},
			},
			importCultBoon: {
				name: "Import (Cults & Supernatural Boons)",
				settings: {
					ownership: ConfigConsts._template_getEntityOwnership(`The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported cult/boon.`),
				},
				settingsAdvanced: {
					...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({name: "cults/boons"}),
					isImportDescription: {
						name: "Import Text as Description",
						help: `If enabled, a cult/boon's text will be imported as item description.`,
						default: true,
						type: "boolean",
					},
				},
			},
			importAction: {
				name: "Import (Actions)",
				settings: {
					ownership: ConfigConsts._template_getEntityOwnership(`The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported action.`),
				},
				settingsAdvanced: {
					...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({name: "actions"}),
					isImportDescription: {
						name: "Import Text as Description",
						help: `If enabled, a action's text will be imported as item description.`,
						default: true,
						type: "boolean",
					},
				},
			},
			importReward: {
				name: "Import (Gifts & Rewards)",
				settings: {
					ownership: ConfigConsts._template_getEntityOwnership(`The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported supernatural gift/reward.`),
					isMetricDistance: {
						name: "Convert Speeds to Metric",
						help: `Whether or not gift/reward speed units should be converted to an approximate metric equivalent (${ConfigConsts._DISP_METRIC_FEET}).`,
						default: false,
						type: "boolean",
					},
				},
				settingsAdvanced: {
					...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({name: "gift/rewards"}),
					isImportDescription: {
						name: "Import Text as Description",
						help: `If enabled, a supernatural gift/reward's text will be imported as item description.`,
						default: true,
						type: "boolean",
					},
				},
			},
			importCharCreationOption: {
				name: "Import (Char. Creation Options)",
				help: "Import (Character Creation Options)",
				settings: {
					ownership: ConfigConsts._template_getEntityOwnership(`The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported character creation option.`),
					isMetricDistance: {
						name: "Convert Speeds to Metric",
						help: `Whether or not character creation option speed units should be converted to an approximate metric equivalent (${ConfigConsts._DISP_METRIC_FEET}).`,
						default: false,
						type: "boolean",
					},
				},
				settingsAdvanced: {
					...ConfigConsts._template_getActiveEffectsDisabledTransferSettings({name: "character creation options"}),
					isImportDescription: {
						name: "Import Text as Description",
						help: `If enabled, a character creation option's text will be imported as item description.`,
						default: true,
						type: "boolean",
					},
				},
			},
			importDeity: {
				name: "Import (Deities)",
				settings: {
					ownership: ConfigConsts._template_getEntityOwnership(`The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported deity.`),
				},
			},
			importRecipe: {
				name: "Import (Recipes)",
				settings: {
					ownership: ConfigConsts._template_getEntityOwnership(`The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported recipe.`),
				},
			},
			importTrap: {
				name: "Import (Traps)",
				settings: {
					ownership: ConfigConsts._template_getEntityOwnership(`The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported trap.`),
					...ConfigConsts._template_getTokenSettings({actorType: "npc"}),
				},
			},
			importHazard: {
				name: "Import (Hazards)",
				settings: {
					ownership: ConfigConsts._template_getEntityOwnership(`The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported hazard.`),
				},
			},
			importAdventure: {
				name: "Import (Adventures)",
				settings: {
					ownership: ConfigConsts._template_getEntityOwnership(`The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported adventure.`),
					isUseModdedInstaller: {
						name: "Use Modded Package Installer",
						help: `If the modded Plutonium backend is installed, adventure packages (modules/worlds) will be installed, automatically, using the mod, rather than providing you with a list of links to copy-paste into Foundry's "Setup".`,
						type: "boolean",
						default: false,
					},
					isUseLegacyImporter: {
						name: "Enable Legacy Package Importer",
						help: `If Plutonium should allow adventure packages (modules/worlds) to be imported directly, rather than providing references for the user to investigate themselves.`,
						type: "boolean",
						default: false,
						unlockCode: "unlock",
					},
					indexUrl: {
						name: "Package Index URL",
						help: `The URL of the index file from which world/module package metadata is loaded.`,
						type: "url",
						default: "https://raw.githubusercontent.com/DMsGuild201/Foundry_Resources/master/worlds/index.json",
						additionalStyleClasses: "code",
						isReloadRequired: true,
					},
				},
			},
			importBook: {
				name: "Import (Books)",
				settings: {
					ownership: ConfigConsts._template_getEntityOwnership(`The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported book.`),
				},
			},
			importMap: {
				name: "Import (Maps)",
				settings: {
					...ConfigConsts._template_getSceneImportSettings(),
				},
			},
			importDeck: {
				name: "Import (Decks)",
				settings: {
					ownership: ConfigConsts._template_getEntityOwnership(`The default (i.e. used for all players unless a player-specific ownership level is set) ownership for an imported deck.`),
				},
			},
			actor: {
				name: "Actors",
				settings: {
					isRefreshOtherOwnedSheets: {
						name: `Refresh Sheets using &quot;@${SharedConsts.MODULE_ID_FAKE}.userchar&quot; when Updating Player Character`,
						help: `Player only. If enabled, when you update your character, the sheets of other actors you control which use "@${SharedConsts.MODULE_ID_FAKE}.userchar. ..." attributes will be automatically refreshed to reflect any changes made to your character. If disabled, you may notice a "lag" between updating your character and seeing the changes reflected in other sheets (a refresh can be forced manually by editing any field on the other sheet, or refreshing your browser tab).`,
						default: true,
						type: "boolean",
						isPlayerEditable: true,
					},
				},
				settingsAdvanced: {
					isAddRollDataItemsFeat: {
						name: "Add &quot;@items&quot; to Roll Data (Features)",
						help: `If actor roll data should be modified to allow access owned items, via data paths of the form "@items.<itemName>. ..." (for example, "@items.big-sword.system.attackBonus" would be substituted with the attack bonus of the owned item "Big Sword").`,
						default: false,
						type: "boolean",
						compatibilityModeValues: {
							[UtilCompat.MODULE_PLUTONIUM_ADDON_AUTOMATION]: true,
						},
					},
					isAddRollDataItemsItem: {
						name: "Add &quot;@items&quot; to Roll Data (Inventory)",
						help: `If actor roll data should be modified to allow access owned items, via data paths of the form "@items.<itemName>. ..." (for example, "@items.big-sword.system.attackBonus" would be substituted with the attack bonus of the owned item "Big Sword").`,
						default: false,
						type: "boolean",
					},
					isAddRollDataItemsSpell: {
						name: "Add &quot;@items&quot; to Roll Data (Spells)",
						help: `If actor roll data should be modified to allow access owned items, via data paths of the form "@items.<itemName>. ..." (for example, "@items.big-sword.system.attackBonus" would be substituted with the attack bonus of the owned item "Big Sword").`,
						default: false,
						type: "boolean",
					},
					isAddRollDataItemsOther: {
						name: "Add &quot;@items&quot; to Roll Data (Other)",
						help: `If actor roll data should be modified to allow access owned items, via data paths of the form "@items.<itemName>. ..." (for example, "@items.big-sword.system.attackBonus" would be substituted with the attack bonus of the owned item "Big Sword").`,
						default: false,
						type: "boolean",
					},
				},
				settingsHacks: {
					isAutoMultiattack: {
						name: "Auto-Roll Multiattacks",
						help: `Attempt to detect and automatically roll components of a creature's "Multiattack" sheet item on activation.`,
						default: false,
						type: "boolean",
					},
					autoMultiattackDelay: {
						name: "Time Between Multiattack Rolls (ms)",
						help: `A number of milliseconds to wait between each roll of a multiattack when using the "Auto-Roll Multiattacks" option. A value of 2000-2500 is recommended when using the "Automated Animations" module.`,
						default: null,
						type: "number",
						min: 0,
						isNullable: true,
					},
					isUseExtendedActiveEffectsParser: {
						name: "Support Variables in Active Effect Values",
						help: `Allows the use of roll syntax, and notably variables (such as "@abilities.dex.mod"), in active effect values.`,
						default: true,
						type: "boolean",
						compatibilityModeValues: {
							[UtilCompat.MODULE_DAE]: false,
							[UtilCompat.MODULE_ROLLDATA_AWARE_ACTIVE_EFFECTS]: false,
						},
					},
				},
			},
			rivet: {
				name: "Rivet",
				settings: {
					targetDocumentId: {
						name: "Target Document",
						help: `The ID of an actor or compendium to which Rivet content should be imported.`,
						default: "",
						type: "string",
						additionalStyleClasses: "code",
						isPlayerEditable: true,
					},
					isDisplayStatus: {
						name: "Display Extension Detected",
						help: `Adds a "paper plane" icon to the Foundry "anvil" logo in the top-left corner of the screen if Rivet is detected.`,
						default: true,
						type: "boolean",
						isPlayerEditable: true,
					},
					minimumRole: ConfigConsts._template_getMinimumRole({
						name: "Minimum Permission Level",
						help: `Rivet will cease to function for any user user with a role less than the chosen role. Directory "Set as Rivet Target" context menu option will also be hidden for any user with a role less than the chosen role.`,
					}),
				},
			},
			artBrowser: {
				name: "Art Browser",
				settings: {
					importImagesAs: {
						name: "Drag-Drop Images As",
						help: `The type of canvas object that should be created when drag-dropping images from the art browser to the canvas.`,
						default: ConfigConsts.C_ART_IMAGE_MODE_TOKEN,
						type: "enum",
						values: [
							{
								value: ConfigConsts.C_ART_IMAGE_MODE_TOKEN,
								name: "Tokens",
							},
							{
								value: ConfigConsts.C_ART_IMAGE_MODE_TILE,
								name: "Tiles",
							},
							{
								value: ConfigConsts.C_ART_IMAGE_MODE_NOTE,
								name: "Journal notes",
							},
							{
								value: ConfigConsts.C_ART_IMAGE_MODE_SCENE,
								name: "Scenes",
							},
						],
					},
					dropAnchor: {
						name: "Drag-Drop Position Anchor",
						help: `The origin point of the image used for the purpose of dropping it to the canvas. "Center" will place the center of the image at the drop position, whereas "Top-Left Corner" will place the top-left corner of the image at the drop position.`,
						default: 0,
						type: "enum",
						values: [
							{
								value: ConfigConsts.C_ART_DROP_ANCHOR_CENTER,
								name: "Center",
							},
							{
								value: ConfigConsts.C_ART_DROP_ANCHOR_TOP_LEFT,
								name: "Top-Left Corner",
							},
						],
					},
					scale: {
						name: "Tile/Scene Scaling",
						help: `A factor by which to scale placed tiles, and by which to scale scene backgrounds.`,
						default: 1.0,
						type: "number",
						min: 0.01,
						max: 100,
					},
					...ConfigConsts._template_getSceneImportSettings(),
					tokenSize: {
						name: "Token Size",
						help: `The default size of placed tokens.`,
						default: 1,
						type: "enum",
						values: [
							{
								value: 1,
								name: "Medium or smaller",
							},
							{
								value: 2,
								name: "Large",
							},
							{
								value: 3,
								name: "Huge",
							},
							{
								value: 4,
								name: "Gargantuan or larger",
							},
						],
					},
					isSwitchToCreatedScene: {
						name: "Activate Scenes on Creation",
						help: `If enabled, a scene will be activated upon creation (by drag-dropping an image to the canvas).`,
						default: true,
						type: "boolean",
					},
					isDisplaySheetCreatedScene: {
						name: "Display Scene Sheets on Creation",
						help: `If enabled, the "sheet" (i.e., configuration UI) for a scene will be shown upon creation (by drag-dropping an image to the canvas).`,
						default: true,
						type: "boolean",
					},
					artDirectoryPath: {
						name: "User Art Directory",
						help: `The sub-directory of the "User Data" directory where downloaded images and image packs will be saved.`,
						default: "assets/art",
						type: "string",
						additionalStyleClasses: "code",
						isNullable: true,
					},
					buttonDisplay: {
						name: "Add Button To",
						help: `The place(s) where the Art Browser button should be visible.`,
						default: {
							[ConfigConsts.C_ART_IMAGE_MODE_TOKEN]: false,
							[ConfigConsts.C_ART_IMAGE_MODE_TILE]: true,
							[ConfigConsts.C_ART_IMAGE_MODE_NOTE]: false,
							[ConfigConsts.C_ART_IMAGE_MODE_SCENE]: true,
						},
						type: "multipleChoice",
						choices: [
							{value: ConfigConsts.C_ART_IMAGE_MODE_TOKEN, name: "Token scene controls"},
							{value: ConfigConsts.C_ART_IMAGE_MODE_TILE, name: "Tile scene controls"},
							{value: ConfigConsts.C_ART_IMAGE_MODE_NOTE, name: "Note scene controls"},
							{value: ConfigConsts.C_ART_IMAGE_MODE_SCENE, name: "Scene controls"},
						],
					},
					imageSaveMode: {
						name: "Image Saving Mode",
						help: `How images should be saved to the server. If "Default" is selected, an imported image will only be saved if it cannot be referenced via URL. If "Always" is selected, an imported image will be saved to the server, regardless of whether or not it can be referenced via URL. If "Never" is selected, an imported image will only be referenced by URL; if it cannot be referenced via URL, the import will fail. Note that saving images requires the Plutonium backend mod to be installed.`,
						default: ConfigConsts.C_ART_IMAGE_SAVE_MODE__DEFAULT,
						type: "enum",
						values: [
							{
								value: ConfigConsts.C_ART_IMAGE_SAVE_MODE__DEFAULT,
								name: `Default`,
							},
							{
								value: ConfigConsts.C_ART_IMAGE_SAVE_MODE__ALWAYS,
								name: `Always`,
							},
							{
								value: ConfigConsts.C_ART_IMAGE_SAVE_MODE__NEVER,
								name: `Never`,
							},
						],
					},
				},
				settingsAdvanced: {
					isSwitchLayerOnDrop: {
						name: "Switch to Layer on Drop",
						help: `If, when dropping an image into a given layer, the canvas should switch to that layer.`,
						default: true,
						type: "boolean",
					},
					isShowMissingBackendWarning: {
						name: `Show &quot;Missing Backend&quot; Warning`,
						help: `If enabled, and the Plutonium backend mod is not installed, a warning will be shown in the Art Browser.`,
						default: true,
						type: "boolean",
					},
				},
			},
			journalEntries: {
				name: "Journal Entries",
				settings: {
					isAutoExpandJournalEmbeds: {
						name: "Auto-Expand Page Embeds",
						help: `If enabled, journal pages embedded using "@EmbedUUID[JournalEntry. ... JournalEntryPage. ...]{...}" will be expanded by default.`,
						default: true,
						type: "boolean",
					},
				},
			},
			tools: {
				name: "Tools",
				settings: {
					isDeduplicateIgnoreType: {
						name: "Ignore Types When Deduplicating",
						help: `If enabled, the Collection Deduplicator will ignore entity types, treating e.g. a PC sheet and an NPC sheet with the same name as a set of duplicates.`,
						default: false,
						type: "boolean",
					},
					minimumRolePolymorph: ConfigConsts._template_getMinimumRole({
						name: "Minimum Permission Level for Polymorph Tool",
						help: `Actor "Polymorph" buttons will be hidden for any user with a role less than the chosen role.`,
					}),
					minimumRoleActorTools: ConfigConsts._template_getMinimumRole({
						name: "Minimum Permission Level for Other Actor Tools",
						help: `Actor "Feature/Spell Cleaner," "Prepared Spell Mass-Toggler," etc. buttons will be hidden for any user with a role less than the chosen role.`,
					}),
					minimumRoleTableTools: ConfigConsts._template_getMinimumRole({
						name: "Minimum Permission Level for Other Table Tools",
						help: `Table "Row Cleaner" button will be hidden for any user with a role less than the chosen role.`,
					}),
					isAddClearFlagsContextMenu: {
						name: `Add &quot;Clear Flags&quot; Context Option`,
						help: `If enabled a "Clear Flags" option will be added to directory document context menus. This option will clear all "plutonium" flags from a document, and the document's embedded documents. Note that this will negatively impact Plutonium functionality for the document.`,
						default: false,
						type: "boolean",
						isReloadRequired: true,
					},
				},
			},
			text: {
				name: "Text and Tags",
				settings: {
					isEnableHoverForLinkTags: {
						name: `Enable Hover Popups for &quot;@tag&quot; Links`,
						help: `If links rendered from @tag syntax should display popups when hovered.`,
						default: false,
						type: "boolean",
						isReloadRequired: true,
					},
					isAutoRollActorItemTags: {
						name: "Roll Items Linked by @UUID[Actor.Item.] on Click",
						help: `If enabled, clicking a rendered @UUID[Actor. ... Item. ...] tag will roll the linked embedded item. If disabled, or on SHIFT-click, the default action (opening the item's sheet) is taken.`,
						default: false,
						type: "boolean",
						isPlayerEditable: true,
					},
					isJumpToFolderTags: {
						name: "Show Folder Linked by @UUID[Folder.] on Click",
						help: `If enabled, clicking a rendered @UUID[Folder. ...] tag will switch to that folder's tab and scroll the folder into view. If disabled, or on SHIFT-click, the default action (opening the folder's sheet) is taken.`,
						default: true,
						type: "boolean",
						isPlayerEditable: true,
					},
					isShowLinkParent: {
						name: "Show Parent Icon/Name For Child @UUIDs",
						help: `If enabled, a rendered @UUID[<parentDocumentName>.<parentId>.<documentName>.<documentId>] tag will display the icon of the parent document type and the name of the parent document, in addition to the usual icon of the document type and the name of the document.`,
						default: true,
						type: "boolean",
						isPlayerEditable: true,
					},
				},
			},
			misc: {
				name: "Miscellaneous",
				settings: {
					isSkipAddonAutomationCheck: {
						name: "Skip Addon: Automation Check",
						help: `Avoid posting to chat if the Addon: Automation companion model is not installed.`,
						default: false,
						type: "boolean",
					},
					isSkipBackendCheck: {
						name: "Skip Backend Check",
						help: `Avoid sending a network request during module initialisation to check if the modded Plutonium backend is installed.`,
						default: false,
						type: "boolean",
						isPlayerEditable: true,
					},
				},
				settingsAdvanced: {
					backendEndpoint: {
						name: "Custom Backend Endpoint",
						help: `The API endpoint used to make calls to the modded Plutonium backend, if available. Note that this API is considered "internal," and is therefore undocumented, and may change on a per-version basis.`,
						default: null,
						placeholder: "(Use default)",
						type: "url",
						additionalStyleClasses: "code",
						isNullable: true,
					},
					isPatchFromUuid: {
						name: "Patch <code>fromUuid</code>",
						help: `Patch the built-in Foundry function "fromUuid" to allow Plutonium-specific UUIDs to be processed. This improves compatibility with some modules.`,
						default: true,
						type: "boolean",
					},
				},
			},
			equipmentShop: {
				name: "Equipment Shop",
				settings: {
					priceMultiplier: {
						name: "Price Multiplier",
						help: `A factor by which the prices in the equipment shop are multiplied.`,
						default: 1.0,
						type: "percentage",
						min: 0.0001,
					},
					startingGold: {
						name: "Class Starting Gold",
						help: `A starting gold amount to use instead of a class's starting gold, when using the equipment shop during class creation.`,
						default: null,
						type: "number",
						isNullable: true,
					},
					minimumRole: ConfigConsts._template_getMinimumRole({
						name: "Minimum Permission Level",
						help: `"Equipment Shop" button will be hidden for any user with a role less than the chosen role.`,
					}),
				},
			},
			dataSources: {
				name: "Data Sources",
				settings: {
					isPlayerEnableSourceSelection: {
						name: "Enable Data Source Filtering for Players",
						help: `Whether or not ${ConfigConsts._STR_DATA_SOURCES} are filtered down to only those chosen in the "World Data Source Selector" application. Applies to players only.`,
						default: false,
						type: "boolean",
						isReloadRequired: true,
					},
					isGmEnableSourceSelection: {
						name: "Enable Data Source Filtering for GMs",
						help: `Whether or not ${ConfigConsts._STR_DATA_SOURCES} are filtered down to only those chosen in the "World Data Source Selector" application. Applies to GMs only.`,
						default: false,
						type: "boolean",
						isReloadRequired: true,
					},
					isPlayerForceSelectAllowedSources: {
						name: "Force Select All for Players",
						help: `Whether or not all available ${ConfigConsts._STR_DATA_SOURCES} are forcibly selected for players. Note that this can seriously degrade performance for players if data source filtering is not also enabled.`,
						default: false,
						type: "boolean",
						isReloadRequired: true,
					},
					isGmForceSelectAllowedSources: {
						name: "Force Select All for GMs",
						help: `Whether or not all available ${ConfigConsts._STR_DATA_SOURCES} are forcibly selected for GMs. Note that this can seriously degrade performance for GMs if data source filtering is not also enabled.`,
						default: false,
						type: "boolean",
						isReloadRequired: true,
					},
				},
				settingsAdvanced: {
					tooManySourcesWarningThreshold: {
						name: "Auto-Selected Source Count Warning Threshold",
						help: `If set, a warning will be shown when auto-selecting a number of sources greater than this value, which usually occurs if a "Force Select All..." option is set, without also "Enabl[ing] Data Source Filtering."`,
						default: 50,
						type: "integer",
						isNullable: true,
					},
				},
			},
			integrationQuickInsert: {
				name: "Integrations (Quick Insert)",
				settings: {
					isEnabled: {
						name: "Enabled",
						help: `If enabled, and the Quick Insert module is active, Plutonium content will be indexed by Quick Insert.`,
						default: true,
						type: "boolean",
						isReloadRequired: true,
					},
					isFilterSourcesUa: {
						name: "Exclude UA/etc.",
						help: `If Unearthed Arcana and other unofficial source content should be excluded from the index.`,
						default: true,
						type: "boolean",
						isReloadRequired: true,
					},
					pagesHidden: {
						name: "Hidden Categories",
						help: `Categories of entity which should not be indexed.`,
						default: ConfigConsts._QUICK_INSERT_PAGE_METAS.mergeMap(({page}) => ({[page]: page === UrlUtil.PG_RECIPES})),
						type: "multipleChoice",
						choices: ConfigConsts._QUICK_INSERT_PAGE_METAS
							.map(({page, displayPage}) => ({value: page, name: displayPage})),
					},
				},
			},
			integrationBabele: {
				name: "Integrations (Babele)",
				settings: {
					isEnabled: {
						name: "Enabled",
						help: `If enabled, and the Babele module is active, Plutonium will attempt to translate parts of imported content.`,
						default: true,
						type: "boolean",
					},
					isUseTranslatedDescriptions: {
						name: "Use Translated Descriptions",
						help: `If enabled, and a translated description is found for a document during import, that description will be used instead of the Plutonium default. Note that this may result in embedded functionality (for example, links between documents) being removed.`,
						default: true,
						type: "boolean",
					},
				},
			},
			integrationThreeDiCanvas: {
				name: "Integrations (3D Canvas)",
				settings: {
					isSetThreeDiModels: {
						name: "Allow Importer to Set 3D Models",
						help: `If enabled, and the 3D Canvas, 3D Canvas Mapmaking Pack, and 3D Canvas Token Collection modules are active, Plutonium will attempt to set the "3D Model" field on imported tokens.`,
						default: true,
						type: "boolean",
						isReloadRequired: true,
					},
				},
			},
		};
	}

	static _DEFAULT_CONFIG_SORTED = null;
	static getDefaultConfigSorted_ () {
		return this._DEFAULT_CONFIG_SORTED = this._DEFAULT_CONFIG_SORTED || Object.entries(this.getDefaultConfig_())
			.sort(([, vA], [, vB]) => SortUtil.ascSortLower(vA.name, vB.name));
	}

	static _DEFAULT_CONFIG_SORTED_FLAT = null;
	static getDefaultConfigSortedFlat_ () {
		if (this._DEFAULT_CONFIG_SORTED_FLAT) return this._DEFAULT_CONFIG_SORTED_FLAT;

		return this._DEFAULT_CONFIG_SORTED_FLAT = this._DEFAULT_CONFIG_SORTED_FLAT || this.getDefaultConfigSorted_()
			.map(([groupKey, group]) => {
				const flatGroup = {};
				this._KEYS_SETTINGS_METAS.forEach(keySettings => {
					Object.entries(group[keySettings] || {})
						.forEach(([key, meta]) => {
							flatGroup[key] = meta;
						});
				});
				return [groupKey, flatGroup];
			});
	}

	
		static getCompendiumPaths () {
		const out = [];
		Object.entries(this.getDefaultConfig_())
			.forEach(([groupKey, group]) => {
				this._KEYS_SETTINGS_METAS.forEach(prop => {
					if (!group[prop]) return;

					Object.entries(group[prop])
						.forEach(([key, meta]) => {
							if (meta.typeSub !== "compendiums") return;

							out.push([groupKey, key]);
						});
				});
			});
		return out;
	}
}

ConfigConsts._STR_DATA_SOURCES = `"data sources" (e.g. those displayed in the Import Wizard)`;

ConfigConsts._KEYS_SETTINGS_METAS = ["settings", "settingsHacks", "settingsAdvanced"];

ConfigConsts._TEMPLATE_ENTITY_OWNERSHIP = {
	name: "Default Ownership",
	default: 0,
	type: "enum",
};

ConfigConsts._TEMPALTE_MINIMUM_ROLE = {
	default: 0,
	type: "enum",
	isReloadRequired: true,
};

ConfigConsts._DISP_METRIC_POUNDS = `1 pound \u2248 0.5 kilograms`;
ConfigConsts._DISP_METRIC_FEET = `5 feet \u2248 1.5 metres`;
ConfigConsts._DISP_METRIC_MILES = `1 mile \u2248 1.6 kilometres`;

ConfigConsts.SRD_COMPENDIUMS_CREATURES = ["dnd5e.monsters"];
ConfigConsts.SRD_COMPENDIUMS_CREATURE_FEATURES = ["dnd5e.monsterfeatures"];
ConfigConsts.SRD_COMPENDIUMS_CLASSES = ["dnd5e.classes"];
ConfigConsts.SRD_COMPENDIUMS_SUBCLASSES = ["dnd5e.subclasses"];
ConfigConsts.SRD_COMPENDIUMS_CLASS_FEATURES = ["dnd5e.classfeatures"];
ConfigConsts.SRD_COMPENDIUMS_ITEMS = ["dnd5e.items", "dnd5e.tradegoods"];
ConfigConsts.SRD_COMPENDIUMS_SPELLS = ["dnd5e.spells"];
ConfigConsts.SRD_COMPENDIUMS_OPTIONAL_FEATURES = ["dnd5e.classfeatures"];
ConfigConsts.SRD_COMPENDIUMS_RACES_AND_FEATURES = ["dnd5e.races"];
ConfigConsts.SRD_COMPENDIUMS_BACKGROUNDS_AND_FEATURES = ["dnd5e.backgrounds"];
ConfigConsts.SRD_COMPENDIUMS_TABLES = ["dnd5e.tables"];

ConfigConsts._QUICK_INSERT_PAGE_METAS = [
	...new Set(
		Renderer.tag.TAGS
			.filter(it => it.page)
			.map(it => it.page)
			.filter(it => ![UrlUtil.PG_QUICKREF, "skill", "sense", "card", "legroup"].includes(it)),
	),
]
	.map(page => {
		let displayPage = UrlUtil.pageToDisplayPage(page);
		if (displayPage === page) displayPage = Parser.getPropDisplayName(page);
		return {page, displayPage};
	})
	.sort(({displayPage: displayPageA}, {displayPage: displayPageB}) => SortUtil.ascSortLower(displayPageA, displayPageB));

ConfigConsts.C_ART_IMAGE_MODE_TOKEN = 0;
ConfigConsts.C_ART_IMAGE_MODE_TILE = 1;
ConfigConsts.C_ART_IMAGE_MODE_NOTE = 2;
ConfigConsts.C_ART_IMAGE_MODE_SCENE = 3;

ConfigConsts.C_ART_DROP_ANCHOR_CENTER = 0;
ConfigConsts.C_ART_DROP_ANCHOR_TOP_LEFT = 1;

ConfigConsts.C_ART_IMAGE_SAVE_MODE__DEFAULT = 0;
ConfigConsts.C_ART_IMAGE_SAVE_MODE__ALWAYS = 1;
ConfigConsts.C_ART_IMAGE_SAVE_MODE__NEVER = 2;

ConfigConsts.C_IMPORT_DEDUPE_MODE_NONE = 0;
ConfigConsts.C_IMPORT_DEDUPE_MODE_SKIP = 1;
ConfigConsts.C_IMPORT_DEDUPE_MODE_OVERWRITE = 2;

ConfigConsts.C_IMPORT_DRAG_DROP_MODE_NEVER = 0;
ConfigConsts.C_IMPORT_DRAG_DROP_MODE_PROMPT = 1;
ConfigConsts.C_IMPORT_DRAG_DROP_MODE_ALWAYS = 2;

ConfigConsts.C_CREATURE_NAMETAGS_CR = 0;
ConfigConsts.C_CREATURE_NAMETAGS_TYPE = 1;
ConfigConsts.C_CREATURE_NAMETAGS_TYPE_WITH_TAGS = 2;

ConfigConsts.C_SPELL_POINTS_MODE__DISABLED = 0;
ConfigConsts.C_SPELL_POINTS_MODE__ENABLED = 1;
ConfigConsts.C_SPELL_POINTS_MODE__ENABLED_AND_UNLIMITED_SLOTS = 2;

ConfigConsts.C_SPELL_POINTS_RESOURCE__SHEET_ITEM = "sheetItem";
ConfigConsts.C_SPELL_POINTS_RESOURCE__ATTRIBUTE_CUSTOM = "attributeCustom";

ConfigConsts.C_ITEM_ATTUNEMENT_NONE = 0;
ConfigConsts.C_ITEM_ATTUNEMENT_REQUIRED = 1;
ConfigConsts.C_ITEM_ATTUNEMENT_ATTUNED = 2;

ConfigConsts.C_ITEM_ATTUNEMENT_NEVER = 0;
ConfigConsts.C_ITEM_ATTUNEMENT_SMART = 1;
ConfigConsts.C_ITEM_ATTUNEMENT_ALWAYS = 2;

ConfigConsts.C_USE_GAME_DEFAULT = "VE_USE_GAME_DEFAULT";
ConfigConsts.C_USE_PLUT_VALUE = "VE_USE_MODULE_VALUE";
ConfigConsts.C_BOOL_DISABLED = 0;
ConfigConsts.C_BOOL_ENABLED = 1;

ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_NONE = 0;
ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_STANDARD = 1;
ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_GM = 2;
ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_BLIND = 3;
ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_SELF = 4;
ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_HIDDEN = 5;
ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_MIN = 6;
ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_MAX = 7;

ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__TAKE_AVERAGE = 0;
ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__MIN = 1;
ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__MAX = 2;
ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL = 3;
ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL_CUSTOM = 4;
ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__DO_NOT_INCREASE = 5;

ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE___NAMES = {
	[ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__TAKE_AVERAGE]: "Take Average",
	[ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__MIN]: "Minimum Value",
	[ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__MAX]: "Maximum Value",
	[ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL]: "Roll",
	[ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL_CUSTOM]: "Roll (Custom Formula)",
	[ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__DO_NOT_INCREASE]: "Do Not Increase HP",
};

class UtilHooks {
	static callAll (name, val) { Hooks.callAll(this._getHookName(name), val); }

	static call (name, val) { Hooks.callAll(this._getHookName(name), val); }

	static on (name, fn) { Hooks.on(this._getHookName(name), fn); }

	static off (name, fn) { Hooks.off(this._getHookName(name), fn); }

	static _getHookName (name) { return `${SharedConsts.MODULE_ID_FAKE}.${name}`; }
}
UtilHooks.HK_CONFIG_UPDATE = "configUpdate";
UtilHooks.HK_IMPORT_COMPLETE = "importComplete";

class UtilKeybinding {
	static getPlayerActor ({minRole = null} = {}) {
		if (minRole != null && game.user.role < minRole) {
			ui.notifications.warn(`You do not have the role required!`);
			return null;
		}
		if (!game.user.character) {
			ui.notifications.warn(`You do not have a character!`);
			return null;
		}
		return game.user.character;
	}

	static getCurrentImportableSheetDocumentMeta ({isRequireActor = false, isRequireOwnership = false, minRole = null} = {}) {
		if (minRole != null && game.user.role < minRole) {
			ui.notifications.warn(`You do not have the role required!`);
			return null;
		}
		const app = UtilApplications.getOpenAppsSortedByZindex()
			.filter(it => {
				if (!it.document) return false;
				if (isRequireOwnership && !it.document.isOwner) return false;
				const isActor = it.document instanceof Actor;
				if (isRequireActor && !isActor) return false;
				return isActor || (it.document instanceof RollTable);
			})
			.last();
		if (!app) {
			ui.notifications.warn(`No actor ${isRequireActor ? "" : `or table `}sheets open!`);
			return null;
		}
		return {
			actor: app.document instanceof Actor ? app.document : null,
			table: app.document instanceof RollTable ? app.document : null,
		};
	}

	static getCurrentSelectedTokenActor ({isRequireOwnership = false, minRole = null}) {
		if (minRole != null && game.user.role < minRole) {
			ui.notifications.warn(`You do not have the role required!`);
			return null;
		}

		const actors = [...canvas.tokens.controlled].filter(it => it.actor).map(it => it.actor).unique().filter(act => !isRequireOwnership || act.isOwner);
		if (actors.length > 1) {
			ui.notifications.warn(`Multiple tokens with actors selected!`);
			return null;
		}
		if (!actors.length) {
			ui.notifications.warn(`No tokens with actors selected!`);
			return null;
		}

		return actors[0];
	}
}

class _MultiPatchFnMeta {
	constructor ({fnMulti, isPreCall = false}) {
		this.fnMulti = fnMulti;
		this.isEnabled = true;
		this.isPreCall = !!isPreCall;
	}

	verifyPreCall ({fnMulti, isPreCall}) {
		if (this.isPreCall !== !!isPreCall) throw new Error(`Function "${fnMulti.name}" pre-call value "${isPreCall}" did not match existing value of "${this.isPreCall}"!`);
	}
}

class _PatchMetaMultiBase {
	constructor ({mode}) {
		this._mode = mode;
		this._fnMetas = [];
	}

		get fnPatch () { throw new Error("Unimplemented!"); }

	verifyMode ({ident, mode}) {
		if (this._mode !== mode) throw new Error(`Could not multi-patch "${ident}" using more "${mode}" when an existing multi-patch using mode "${this._mode}" already exists!`);
	}

	addFn (fnMulti, {isPreCall = false} = {}) {
		const existing = this._fnMetas.find(meta => meta.fnMulti === fnMulti);
		if (existing) {
			existing.verifyPreCall({fnMulti, isPreCall});
			existing.isEnabled = true;
			return this;
		}

		const fnMeta = new _MultiPatchFnMeta({fnMulti, isPreCall});
		this._fnMetas.push(fnMeta);
		return this;
	}

	removeFn (fnMulti) {
		const existing = this._fnMetas.find(meta => meta.fnMulti === fnMulti);
		if (!existing) return this;
		existing.isEnabled = false;
		return this;
	}

	isEmpty () {
		return !this._fnMetas.filter(it => it.isEnabled).length;
	}
}

class _PatchMetaMultiSync extends _PatchMetaMultiBase {
	constructor (...args) {
		super(...args);
		this._fnPatch = null;
	}

	get fnPatch () {
		if (this._fnPatch) return this._fnPatch;

		const self = this;

		return this._fnPatch = function (fnOriginal, ...args) {
			const fnMetasEnabled = self._fnMetas
				.filter(meta => meta.isEnabled);

			if (!fnMetasEnabled.length) return fnOriginal(...args);

			const [fnMetasPreCall, fnMetasPostCall] = fnMetasEnabled.segregate(it => it.isPreCall);

			let argsPatch = [...args];
			for (const fnMeta of fnMetasPreCall) {
				argsPatch = fnMeta.fnMulti.call(this, {
					args: argsPatch,
				});
			}

			let outPatch = fnOriginal(...argsPatch);
			for (const fnMeta of fnMetasPostCall) {
				outPatch = fnMeta.fnMulti.call(this, {
					out: outPatch,
					args,
				});
			}
			return outPatch;
		};
	}
}

class _PatchMetaMultiAsync extends _PatchMetaMultiBase {
		get fnPatch () { throw new Error("Unimplemented!"); }
}

class UtilLibWrapper {
	static LIBWRAPPER_MODE_WRAPPER = "WRAPPER";
	static LIBWRAPPER_MODE_MIXED = "MIXED";
	static LIBWRAPPER_MODE_OVERRIDE = "OVERRIDE";

	
	static _PATCHES = {};

	static addPatch (ident, fnPatch, mode) { return this.togglePatch(ident, fnPatch, mode, true); }

	static togglePatch (ident, fnPatch, mode, isActive) {
		if (!isActive) {
			if (!this._PATCHES[ident]) return;
			libWrapper.unregister(SharedConsts.MODULE_ID, ident, false);

			delete this._PATCHES[ident];
			return;
		}

		if (this._PATCHES[ident]) return;

		this._PATCHES[ident] = true;
		libWrapper.register(SharedConsts.MODULE_ID, ident, fnPatch, mode);
	}

	
	static _PATCH_METAS_MULTI = {};

	static addPatchMultiMutatesArgs (ident, fnMulti, mode) { return this._togglePatchMulti(ident, fnMulti, mode, true, {isPreCall: true}); }
	static addPatchMultiMutatesOutput (ident, fnMulti, mode) { return this._togglePatchMulti(ident, fnMulti, mode, true, {isPreCall: false}); }

	static togglePatchMultiMutatesArgs (ident, fnMulti, mode, isActive) { this._togglePatchMulti(ident, fnMulti, mode, isActive, {isPreCall: true}); }
	static togglePatchMultiMutatesOutput (ident, fnMulti, mode, isActive) { this._togglePatchMulti(ident, fnMulti, mode, isActive, {isPreCall: false}); }

	static _togglePatchMulti (ident, fnMulti, mode, isActive, {isPreCall = false} = {}) {
		if (mode !== this.LIBWRAPPER_MODE_WRAPPER) throw new Error(`Only "${this.LIBWRAPPER_MODE_WRAPPER}" mode is supported for multi-patching!`);

		const patchMeta = this._getCreateMultiPatchMeta({ident, mode, isCreate: isActive});

		if (isActive) patchMeta.addFn(fnMulti, {isPreCall});
		else {
			if (patchMeta) patchMeta.removeFn(fnMulti);
		}

		if (!patchMeta || patchMeta.isEmpty()) this.togglePatch(ident, patchMeta.fnPatch, mode, false);
		else this.togglePatch(ident, patchMeta.fnPatch, mode, true);
	}

	static _getCreateMultiPatchMeta ({ident, mode, isCreate = false}) {
		const cur = this._PATCH_METAS_MULTI[ident];
		if (cur) cur.verifyMode({ident, mode});
		if (cur || (!cur && !isCreate)) return cur || null;
		return this._PATCH_METAS_MULTI[ident] = new _PatchMetaMultiSync({mode});
	}
}

class GameStorage {
	static _gameStorageValueOverrides = {};

	static _STORE_KEY_CLIENT = "plutonium_client";
	static _STORE_KEY_WORLD = "plutonium_world";

	static _STORAGE_KEY_RELOADER = "reloader";

	static init () {
		UtilLibWrapper.addPatch(
			"game.settings.get",
			this._lw_game_settings_get,
			UtilLibWrapper.LIBWRAPPER_MODE_WRAPPER,
		);

		game.settings.register(
			SharedConsts.MODULE_ID,
			this._STORAGE_KEY_RELOADER,
			{
				name: "-",
				scope: "world",
				config: false,
				default: 0,
				type: Number,
				onChange: () => setTimeout(() => window.location.reload(), 100),
			},
		);
	}

	static _lw_game_settings_get (fn, ...args) {
		const out = fn(...args);
		const [namespace, key] = args;

		const override = GameStorage._gameStorageValueOverrides?.[namespace]?.[key];
		if (override === undefined) return out;

		return override;
	}

		static async pDoReload () {
		if (!game.user.isGM) return window.location.reload();

		const curr = game.settings.get(SharedConsts.MODULE_ID, this._STORAGE_KEY_RELOADER);
		await game.settings.set(SharedConsts.MODULE_ID, this._STORAGE_KEY_RELOADER, curr + 1);
	}

	static setOverride (namespace, key, val) { MiscUtil.set(this._gameStorageValueOverrides, namespace, key, val); }
	static unsetOverride (namespace, key) { MiscUtil.deleteObjectPath(this._gameStorageValueOverrides, namespace, key); }

	static _registerClient (key) {
		return this._register(key, {type: "client"});
	}

	static _registerWorld (key) {
		return this._register(key, {type: "world"});
	}

	static _register (key, {type = "client"} = {}) {
		const keyPrefix = type === "world" ? GameStorage._STORE_KEY_WORLD : GameStorage._STORE_KEY_CLIENT;
		const keyProc = `${keyPrefix}_${key}`;
		game.settings.register(
			SharedConsts.MODULE_ID,
			keyProc,
			{
				name: keyProc,
				hint: keyProc,
				scope: type,
				config: false,
				default: {},
				type: Object,
				onChange: () => this._RELOAD_REQUIRED[key] ? window.location.reload() : null,
			},
		);
		return keyProc;
	}

	
	static _RELOAD_REQUIRED = {};

		static setReloadRequiredWorld (key, val = true) {
		this._registerWorld(key);
		this._RELOAD_REQUIRED[key] = !!val;
	}

	
	static registerClient (key) { this._registerClient(key); }

	static getClient (key) {
		const fullKey = this._registerClient(key);
		return (UtilGameSettings.getSafe(SharedConsts.MODULE_ID, fullKey) || {})._;
	}

	static async pGetClient (key) {
		return this.getClient(key);
	}

	static async pSetClient (key, value) {
		const fullKey = this._registerClient(key);
		await game.settings.set(SharedConsts.MODULE_ID, fullKey, {_: value});
	}

	static async pRemoveClient (key) {
		return this.pSetClient(key, undefined);
	}

	
	static registerWorld (key) { this._registerWorld(key); }

	static getWorld (key) {
		const fullKey = this._registerWorld(key);
		return (UtilGameSettings.getSafe(SharedConsts.MODULE_ID, fullKey) || {})._;
	}

	static async pGetWorld (key) {
		return this.getWorld(key);
	}

	static async pSetWorld (key, value) {
		const fullKey = this._registerWorld(key);
		await game.settings.set(SharedConsts.MODULE_ID, fullKey, {_: value});
	}

	static async pRemoveWorld (key) {
		return this.pSetWorld(key, undefined);
	}

	
	static getClientThenWorld (key) {
		const outClient = this.getClient(key);
		if (outClient !== undefined) return outClient;
		return this.getWorld(key);
	}

	static async pGetClientThenWorld (key) {
		return this.getClientThenWorld(key);
	}

	static async pSetWorldThenClient (key, value) {
		if (game.user.isGM) return this.pSetWorld(key, value);

				const existing = await this.pGetClientThenWorld(key);
		if (CollectionUtil.deepEquals(value, existing)) return;

		return this.pSetClient(key, value);
	}
}

class UtilPrePreInit {
	static _IS_GM = null;

		static isGM () {
		return UtilPrePreInit._IS_GM = UtilPrePreInit._IS_GM ?? game.data.users.find(it => it._id === game.userId).role >= CONST.USER_ROLES.ASSISTANT;
	}
}

class ModuleSettingsStub extends FormApplication {
	static get defaultOptions () {
		return foundry.utils.mergeObject(super.defaultOptions, {
			title: `Opening...`,
			template: `${SharedConsts.MODULE_LOCATION}/template/_GenericForm.hbs`,
			width: 100,
			height: 100,
		});
	}

		async render (...args) {
		const out = await super.render(...args);
		setTimeout(async () => {
			Config.pHandleButtonClick();
			await this.close();
		}, 30);
		return out;
	}

	_onSubmit () {  }
	_updateObject () {  }
}

class _UtilConfig {
	static getEnumValues (meta) {
		return typeof meta.values === "function" ? meta.values() : meta.values;
	}

	static getEnumValueValue (val) {
		return val.value !== undefined ? val.value : val;
	}

	static isPlayerEditable (group, key) {
		const meta = this._is_getKeyMeta(group, key);
		return !!meta?.isPlayerEditable;
	}

	static isNullable (group, key) {
		const meta = this._is_getKeyMeta(group, key);
		return !!meta?.isNullable;
	}

	static _is_getKeyMeta (groupKey, key) {
		return ConfigConsts.getDefaultConfigSortedFlat_()
			.find(([groupKey_]) => groupKey_ === groupKey)[1][key];
	}
}

class _ConfigSettingBase {
	constructor ({isHideUnavailable, meta, DRAFT_GM, DRAFT_PLAYER, groupKey, k}) {
		this._isHideUnavailable = isHideUnavailable;
		this._meta = meta;
		this._groupKey = groupKey;
		this._k = k;
		this._DRAFT_GM = DRAFT_GM;
		this._DRAFT_PLAYER = DRAFT_PLAYER;

		this._DRAFT = game.user.isGM ? this._DRAFT_GM : this._DRAFT_PLAYER;
	}

	static _getIncompatibleModuleIds (groupKey, key) {
		const groupSettings = ConfigConsts.getDefaultConfigSortedFlat_().find(([groupKey_]) => groupKey_ === groupKey)[1];
		if (!groupSettings[key]?.compatibilityModeValues) return [];
		return Object.keys(groupSettings[key].compatibilityModeValues).filter(moduleId => UtilCompat.isModuleActive(moduleId));
	}

	static _getIsDisabledMessage ({isDisabledPlayer, isDisabledCompatibility, incompatibleModuleNames}) {
		if (isDisabledPlayer) return `(This setting is controlled by the GM)`;
		if (isDisabledCompatibility) return `(This setting is read-only due to the requirements of/the incompatibility with one or more other active modules: ${incompatibleModuleNames.map(it => `"${it}"`).join(", ")})`;
		return null;
	}

	_getValDefault () {
		if (game.user.isGM) return this._meta.default;
		return Config.get(this._groupKey, this._k, {isIgnorePlayer: true});
	}

	render () {
		if (this._meta.default === undefined) throw new Error(`No "default" config value exists for "${this._groupKey}.${this._k}"! This is a bug!`);

		const isPlayerEditable = _UtilConfig.isPlayerEditable(this._groupKey, this._k);
		const isDisabledPlayer = !isPlayerEditable && !game.user.isGM;
		const incompatibleModuleNames = this.constructor._getIncompatibleModuleIds(this._groupKey, this._k);
		const isDisabledCompatibility = incompatibleModuleNames.length > 0;
		const isDisabled = isDisabledPlayer || isDisabledCompatibility;

		if (this._isHideUnavailable && isDisabledPlayer) return null;

		const current = Config.get(this._groupKey, this._k);

		const $btnResetRow = $(`<button class="btn btn-xxs ml-1 cfg__btn-reset-row" title="Reset"><i class="fa fa-undo-alt mr-0"></i></button>`)
			.click(evt => {
				evt.stopPropagation();
				evt.preventDefault();
				fnReset();
			});

		let cbIsDefault = () => {
						const valDefault = game.user.isGM ? this._meta.default : null;
			$btnResetRow.toggleClass("ve-muted", CollectionUtil.deepEquals(this._DRAFT[this._groupKey][this._k], valDefault));
		};
		cbIsDefault();

		let $ele,
			fnDisable, 			fnReset,
			fnHandleUpdate;
		let isLabel = true;

		switch (this._meta.type) {
			case "boolean": {
				$ele = $(`<input type="checkbox">`)
					.change(() => {
						if (isDisabled) return;

						this._DRAFT[this._groupKey][this._k] = $ele.prop("checked");
						doUpdate(this._DRAFT[this._groupKey][this._k]);
					});

				const doUpdate = (val) => {
					$ele.prop("checked", val);
					cbIsDefault();
				};

				doUpdate(current);

				fnReset = () => {
					$ele.prop("checked", this._getValDefault());

					if (game.user.isGM) {
						$ele.change();
						return;
					}

					this._DRAFT[this._groupKey][this._k] = null;
					cbIsDefault();
				};

				fnHandleUpdate = () => doUpdate(Config.get(this._groupKey, this._k));

				break;
			}

			case "enum": {
				const values = _UtilConfig.getEnumValues(this._meta);

				$ele = $(`<select class="w-100"></select>`)
					.change(() => {
						if (isDisabled) return;

						const ixSel = Number($ele.val());
						if (~ixSel) {
							this._DRAFT[this._groupKey][this._k] = _UtilConfig.getEnumValueValue(values[ixSel]);
						} else {
							if (this._meta.isNullable) this._DRAFT[this._groupKey][this._k] = null;
							else this._DRAFT[this._groupKey][this._k] = _UtilConfig.getEnumValueValue(values[0]);
						}
												doUpdate(this._DRAFT[this._groupKey][this._k]);
					});

				if (this._meta.additionalStyleClasses) $ele.addClass(this._meta.additionalStyleClasses);

				if (this._meta.isNullable) $ele.append(`<option value="-1" class="ve-muted">\u2014</option>`);
				values.forEach((it, i) => {
					if (it.fnGetName) it.name = it.name || it.fnGetName();
					$(`<option/>`, {value: i, text: it.name ?? it.value ?? it}).title(it.help).appendTo($ele);
				});

				const doUpdate = (val) => {
					if (this._meta.isNullable && val == null) $ele.val("-1");
					else if (val != null) {
						const ixCurrent = values.findIndex(it => _UtilConfig.getEnumValueValue(it) === val);
						if (~ixCurrent) $ele.val(`${ixCurrent}`);
						else $ele.val("0");
					}
					cbIsDefault();
				};

				doUpdate(current);

				fnReset = () => {
					const ixDefault = values.findIndex(it => (it.value == null ? it : it.value) === this._getValDefault());
					$ele.val(`${ixDefault}`);

					if (game.user.isGM) {
						$ele.change();
						return;
					}

					this._DRAFT[this._groupKey][this._k] = null;
					cbIsDefault();
				};
				fnHandleUpdate = () => doUpdate(Config.get(this._groupKey, this._k));

				break;
			}

			case "string":
			case "url":
			case "color": {
				const iptType = this._meta.type === "color" ? "color" : "text";

				$ele = $(`<input type="${iptType}" class="w-100">`)
					.placeholder(this._meta.placeholder)
					.change(() => {
						if (isDisabled) return;

						const val = $ele.val().trim();
						if (!val && !this._meta.isNullable) {
							this._DRAFT[this._groupKey][this._k] = this._meta.default;
							$ele.val(this._meta.default);
						} else {
							this._DRAFT[this._groupKey][this._k] = (this._meta.isNullable && !val) ? null : val;
						}

						doUpdate(this._DRAFT[this._groupKey][this._k]);
					});

				if (this._meta.additionalStyleClasses) $ele.addClass(this._meta.additionalStyleClasses);

				const doUpdate = (val) => {
					$ele.val(val);
					cbIsDefault();
				};

				doUpdate(current);

				fnReset = () => {
					$ele.val(this._getValDefault());

					if (game.user.isGM) {
						$ele.change();
						return;
					}

					this._DRAFT[this._groupKey][this._k] = null;
					cbIsDefault();
				};
				fnHandleUpdate = () => doUpdate(Config.get(this._groupKey, this._k));

				break;
			}

			case "percentage":
			case "number": 			case "integer": {
				const cur = (this._meta.isNullable && current == null)
					? null
					: (current == null || isNaN(current)) ? this._meta.default : Number(current);

				$ele = $(`<input type="text" class="w-100 text-right">`)
					.placeholder(this._meta.placeholder)
					.change(() => {
						if (isDisabled) return;

						const rawVal = $ele.val().trim();

						if (!rawVal && this._meta.isNullable) {
							this._DRAFT[this._groupKey][this._k] = null;
							$ele.val(null);

							return void cbIsDefault();
						}

						const defaultVal = this._meta.isNullable ? null : this._meta.default;
						const opts = {fallbackOnNaN: defaultVal};
						if (this._meta.min) opts.min = this._meta.min;
						if (this._meta.max) opts.max = this._meta.max;

						let num = UiUtil.strToNumber(rawVal, defaultVal, opts);
						if (this._meta.type === "integer" && defaultVal != null) num = Math.round(num);
						this._DRAFT[this._groupKey][this._k] = num;
						$ele.val(num);

						doUpdate(this._DRAFT[this._groupKey][this._k]);
					});

				if (this._meta.additionalStyleClasses) $ele.addClass(this._meta.additionalStyleClasses);

				const doUpdate = (val) => {
					$ele.val(val);
					cbIsDefault();
				};

				doUpdate(cur);

				fnReset = () => {
					$ele.val(this._getValDefault());

					if (game.user.isGM) {
						$ele.change();
						return;
					}

					this._DRAFT[this._groupKey][this._k] = null;
					cbIsDefault();
				};
				fnHandleUpdate = () => doUpdate(Config.get(this._groupKey, this._k));

				break;
			}

			case "multipleChoice": {
				isLabel = false;

				const $labels = [];
				const cbMetas = [];

				fnDisable = () => {
					$labels.forEach($lbl => $lbl.title(this.constructor._getIsDisabledMessage({isDisabledPlayer, isDisabledCompatibility, incompatibleModuleNames})));
					cbMetas.forEach(({$cb}) => $cb.prop("disabled", true));
				};

								cbIsDefault = () => $btnResetRow.toggleClass("ve-muted", CollectionUtil.deepEquals(Object.entries(this._DRAFT[this._groupKey][this._k] || {}).filter(([, v]) => v), Object.entries(this._meta.default || {}).filter(([, v]) => v)));

				const handleUpdate = () => {
					this._DRAFT[this._groupKey][this._k] = cbMetas.mergeMap(({$cb, value}) => ({[value]: $cb.prop("checked")}));
					cbIsDefault();
				};

				const $rows = this._meta.choices.map(it => {
					const {name, value} = it;

					const $cb = $(`<input type="checkbox">`)
						.prop("checked", !!current[value])
						.change(() => {
							if (isDisabled) return;
							handleUpdate();
						});
					cbMetas.push({$cb, value});

					fnHandleUpdate = () => {
						$ele.prop("checked", !!Config.get(this._groupKey, this._k)[value]);
						cbIsDefault();
					};

					const $lbl = $$`<label class="split-v-center m-0 stripe-even py-1">
									<div class="ve-small">${name.escapeQuotes()}</div>
									${$cb}
								</label>`;
					$labels.push($lbl);
					return $lbl;
				});

				fnReset = () => {
					const valDefault = this._getValDefault();
					cbMetas.forEach(({$cb, value}) => {
						$cb.prop("checked", !!valDefault[value]);
					});

					if (game.user.isGM) {
						handleUpdate();
						return;
					}

					this._DRAFT[this._groupKey][this._k] = null;
					cbIsDefault();
				};

				$ele = $$`<div class="ve-flex-col w-100">${$rows}</div>`;

				break;
			}

			case "arrayStringShort": {
				isLabel = false;

				const cur = current instanceof Array ? MiscUtil.copy(current) : [];

				const comp = BaseComponent.fromObject({values: cur}, "values");
				$ele = ComponentUiUtil.$getPickString(comp, "values", {isCaseInsensitive: !this._meta.isCaseSensitive});
				comp._addHookBase("values", () => {
					this._DRAFT[this._groupKey][this._k] = comp._state.values;
					cbIsDefault();
				});

				fnReset = () => {
					comp._state.values = [...this._getValDefault()];

					if (game.user.isGM) return;

					this._DRAFT[this._groupKey][this._k] = null;
					cbIsDefault();
				};

				fnHandleUpdate = () => {
					comp._state.values = [...Config.get(this._groupKey, this._k) || []];
					cbIsDefault();
				};

				break;
			}

						default: throw new Error(`Unhandled type "${this._meta.type}"`);
		}

		if (isDisabled) {
			if (fnDisable) fnDisable();
			else $ele.prop("disabled", true).title(this.constructor._getIsDisabledMessage({isDisabledPlayer, isDisabledCompatibility, incompatibleModuleNames}));
		}

		const isWideInput = ["url", "arrayStringShort"].includes(this._meta.type);

		const $row = $$`<${isLabel ? "label" : "div"} class="split-v-center py-1 cfg__row w-100" title="${this._meta.help.escapeQuotes()}">
			<div class="ve-flex-v-center cfg__disp-name ${isWideInput ? `cfg__disp-name--narrow` : ""}">
				<div>${this._meta.name}</div>
				${isPlayerEditable && game.user.isGM ? ` <span class="cfg__disp-player-editable ml-1" title="Player Editable">†</span>` : ""}${this._meta.isReloadRequired ? ` <span class="cfg__disp-requires-refresh ml-1" title="Requires Refresh">‡</span>` : ""}
			</div>
			<div class="ve-flex-v-center ve-flex-h-right w-100 cfg__wrp-input ${isWideInput ? `cfg__wrp-input--wide` : ""}">
				${$ele}
				${$btnResetRow}
			</div>
		</${isLabel ? "label" : "div"}>`;

		const searchKey = [this._meta.help, this._meta.name].filter(Boolean).join(" -- ").toLowerCase().trim();
		const cbSearch = (searchTerm) => {
			const isNoMatch = searchTerm && !searchKey.includes(searchTerm);
			const isHidden = this._meta.unlockCode && this._meta.unlockCode !== searchTerm;

			$row.toggleClass("cfg__row--no-match", !!isNoMatch);
			if (this._meta.unlockCode && !isHidden) $row.removeClass("cfg__row--no-match");
			$row.toggleVe(!isHidden);

			return isNoMatch || isHidden;
		};
		cbSearch("");

		return {
			fnReset,
			fnHandleUpdate,
			$row,
			cbSearch,
		};
	}
}

class Config extends Application {
		static api_getWikiSummary () {
		return this._getWikiSummary();
	}

	static api_getWikiSummaryMarkdown () {
		return this._getWikiSummaryMarkdown();
	}
	
	static _IS_INIT = false;
	static _IS_INIT_SAVE_REQUIRED = false;

	static get backendEndpoint () {
		const customUrl = Config.get("misc", "backendEndpoint");
		if (customUrl) return customUrl;
		return ROUTE_PREFIX ? `/${ROUTE_PREFIX}/api/plutonium` : "/api/plutonium";
	}

	static get isInit () { return this._IS_INIT; }

	static prePreInit () {
		this._preInit_doLoadConfig();
		this._preInit_registerKeybinds();
	}

	static _preInit_doLoadConfig () {
		this._pPrePreInit_registerSettings();

		let loadedConfig = UtilGameSettings.getSafe(SharedConsts.MODULE_ID, Config._SETTINGS_KEY);

		if (loadedConfig == null || !Object.keys(loadedConfig).length) Config._CONFIG = Config._getDefaultGmConfig();
		else {
			Config._CONFIG = loadedConfig;
			const anyMods = this._populateMissingConfigValues(Config._CONFIG, {isPlayer: false});
			this._IS_INIT_SAVE_REQUIRED = this._IS_INIT_SAVE_REQUIRED || anyMods;
		}

				game.socket.on(this._SOCKET_ID, data => {
			switch (data.type) {
				case "config.update": {
					const receivedConfig = data.config;

					const old = MiscUtil.copy(Config._CONFIG);

					Object.assign(Config._CONFIG, receivedConfig);

					if (!UtilPrePreInit.isGM() && this._INSTANCE) this._INSTANCE._handleGmConfigUpdate(receivedConfig);

					UtilHooks.callAll(
						UtilHooks.HK_CONFIG_UPDATE,
						{
							previous: old,
							current: MiscUtil.copy(Config._CONFIG),
						},
					);

					break;
				}
			}
		});
		
				if (!UtilPrePreInit.isGM()) {
			const loadedConfigPlayer = GameStorage.getClient(Config._CLIENT_SETTINGS_KEY);
			if (loadedConfigPlayer == null) Config._CONFIG_PLAYER = Config._getDefaultPlayerConfig();
			else {
				Config._CONFIG_PLAYER = loadedConfigPlayer;
				const anyMods = this._populateMissingConfigValues(Config._CONFIG_PLAYER, {isPlayer: true});
				this._IS_INIT_SAVE_REQUIRED = this._IS_INIT_SAVE_REQUIRED || anyMods;
			}
		}
		
				this._pInit_initCompatibilityTempOverrides();
		
				game.settings.registerMenu(SharedConsts.MODULE_ID, "stub", {
			name: "Config Editor",
			hint: "Access the config editor.",
			label: "Open Config Editor",
			icon: "fas fa-fw fa-cogs",
			type: ModuleSettingsStub,
			restricted: false,
		});
		
		this._IS_INIT = true;
	}

	static _preInit_registerKeybinds () {
		game.keybindings.register(
			SharedConsts.MODULE_ID,
			"Config__open",
			{
				name: "Open Config",
				editable: [],
				onDown: () => {
					this._pOpen();
					return true;
				},
			},
		);

		game.keybindings.register(
			SharedConsts.MODULE_ID,
			"Config__setRivetTargetForCharacter",
			{
				name: "Set Player Character as Rivet Target",
				editable: [],
				onDown: () => {
					const actor = UtilKeybinding.getPlayerActor({minRole: Config.get("import", "minimumRole")});
					if (!actor) return true;
					Config.setRivetTargetDocument({actor});
					return true;
				},
			},
		);

		game.keybindings.register(
			SharedConsts.MODULE_ID,
			"Config__setRivetTargetForCurrentSheet",
			{
				name: "Set Current Sheet as Rivet Target",
				editable: [],
				onDown: () => {
					const meta = UtilKeybinding.getCurrentImportableSheetDocumentMeta({isRequireActor: true, isRequireOwnership: true, minRole: Config.get("import", "minimumRole")});
					if (!meta?.actor) return true;
					Config.setRivetTargetDocument({actor: meta.actor});
					return true;
				},
			},
		);

		game.keybindings.register(
			SharedConsts.MODULE_ID,
			"Config__setRivetTargetForCurrentToken",
			{
				name: "Set Current Token as Rivet Target",
				editable: [],
				onDown: () => {
					const actor = UtilKeybinding.getCurrentSelectedTokenActor({isRequireOwnership: true, minRole: Config.get("import", "minimumRole")});
					if (!actor) return true;
					Config.setRivetTargetDocument({actor});
					return true;
				},
			},
		);

		game.keybindings.register(
			SharedConsts.MODULE_ID,
			"Config__clearRivetTarget",
			{
				name: "Clear Rivet Target",
				editable: [],
				onDown: () => {
					Config.setRivetTargetDocument();
					return true;
				},
			},
		);

		game.keybindings.register(
			SharedConsts.MODULE_ID,
			"Config__openBugReportForm",
			{
				name: "Report Bug",
				editable: [],
				onDown: () => {
					Config._doShowBugReportForm();
					return true;
				},
			},
		);
	}

	static _COMPATIBILITY_TEMP_OVERRIDES = null;
	static _pInit_initCompatibilityTempOverrides () {
		ConfigConsts.getDefaultConfigSortedFlat_()
			.forEach(([groupKey, allGroupSettings]) => {
				Object.entries(allGroupSettings)
					.forEach(([key, meta]) => {
						if (!meta.compatibilityModeValues) return;

																		Object.entries(meta.compatibilityModeValues)
							.find(([moduleId, compatibilityValueRaw]) => {
								const compatibilityValue = meta.type === "enum" ? _UtilConfig.getEnumValueValue(compatibilityValueRaw) : compatibilityValueRaw;
								const compatibilityValueDisplay = meta.type === "enum" ? compatibilityValueRaw.name || compatibilityValue : compatibilityValue;

								if (!UtilCompat.isModuleActive(moduleId)) return false;

																const valCur = Config.get(groupKey, key);
								const isChange = !CollectionUtil.deepEquals(compatibilityValue, valCur);

								Config.setTemp(groupKey, key, compatibilityValue, {isSkipPermissionCheck: true});
								if (isChange) {
									const {displayGroup, displayKey} = Config._getDisplayLabels(groupKey, key);
									const dispValCur = valCur != null ? JSON.stringify(valCur) : valCur;
									const dispVal = compatibilityValueDisplay != null ? JSON.stringify(compatibilityValueDisplay) : compatibilityValueDisplay;

									this._COMPATIBILITY_TEMP_OVERRIDES = this._COMPATIBILITY_TEMP_OVERRIDES || {};
									MiscUtil.set(
										this._COMPATIBILITY_TEMP_OVERRIDES,
										groupKey,
										key,
										{
											value: compatibilityValue,
											message: `"${displayGroup} -&gt; ${displayKey}" value \`${dispValCur}\` has compatibility issues with module "${game.modules.get(moduleId).title}" (must be set to \`${dispVal}\`)`,
										},
									);

									console.warn(...LGT, `${game.modules.get(moduleId).title} detected! Setting compatibility config: ${groupKey}.${key} = ${dispVal} (was ${dispValCur}). If you encounter unexpected issues, consider disabling either module.`);
								}
							});
					});
			});
	}

	static _hasCompatibilityWarnings () { return this._COMPATIBILITY_TEMP_OVERRIDES != null; }

	static _getCompatibilityWarnings () {
		if (!this._COMPATIBILITY_TEMP_OVERRIDES) return "";

		const summary = Object.values(this._COMPATIBILITY_TEMP_OVERRIDES)
			.map(keyToMeta => Object.values(keyToMeta).map(it => it.message))
			.flat()
			.map(it => ` - ${it}`)
			.join("\n");
		return `Click to resolve config module compatibility issues. Issues detected:\n${summary}.`;
	}

	static _doResolveCompatibility () {
		Object.entries(this._COMPATIBILITY_TEMP_OVERRIDES)
			.forEach(([groupKey, keyToMeta]) => {
				Object.entries(keyToMeta)
					.forEach(([key, meta]) => {
						Config.set(groupKey, key, meta.value);
					});
			});

		this._COMPATIBILITY_TEMP_OVERRIDES = null;
	}

	static _pPrePreInit_registerSettings () {
		game.settings.register(
			SharedConsts.MODULE_ID,
			Config._SETTINGS_KEY,
			{
				name: "Config",
				default: {},
				type: Object,
				scope: "world",
				onChange: data => {
									},
			},
		);
	}

		static _populateMissingConfigValues (CONFIG, opts) {
		opts = opts || {};
		const isPlayer = !!opts.isPlayer;

		let anyMods = false;

				Object.entries(this._getDefaultConfig({isPlayer}))
			.forEach(([groupKey, groupVals]) => {
								if (!CONFIG[groupKey]) {
					CONFIG[groupKey] = groupVals;
					anyMods = true;
				} else {
										Object.entries(groupVals).forEach(([k, v]) => {
						if (CONFIG[groupKey][k] === undefined) {
							CONFIG[groupKey][k] = v;
							anyMods = true;
						}
					});
				}
			});

		return anyMods;
	}

	static async pInit () {
		if (this._IS_INIT_SAVE_REQUIRED) Config._saveConfigDebounced();
		this._IS_INIT_SAVE_REQUIRED = false;
	}

		static $getDirButton (opts) {
		opts = opts || {};

		const text = `Configure ${Config.get("ui", "isStreamerMode") ? "SRD Module" : "Plutonium"}`;

		return $(`<button class="mx-0 ${opts.isGameSettingsButton ? `cfg__btn-open-alt` : "w-initial"}" ${opts.isGameSettingsButton ? `` : `title="${text}"`}><span class="fas fa-fw fa-cogs"></span>${opts.isGameSettingsButton ? ` ${text}` : ``}</button>`)
			.click(evt => this.pHandleButtonClick(evt));
	}

	static pHandleButtonClick (evt, initialVisibleGroup) {
		if (evt) evt.preventDefault();

		return this._pOpen({initialVisibleGroup});
	}

	static _pOpen ({initialVisibleGroup = null} = {}) {
		if (Config._INSTANCE) {
			Config._INSTANCE.render(true);
			Config._INSTANCE.maximize();
			UtilApplications.bringToFront(Config._INSTANCE);
			if (initialVisibleGroup) Config._INSTANCE._setVisibleGroup(initialVisibleGroup);
			return;
		}

		Config._INSTANCE = new Config({initialVisibleGroup});
		Config._INSTANCE.render(true);
	}

	static _getDefaultGmConfig () { return this._getDefaultConfig({isPlayer: false}); }
	static _getDefaultPlayerConfig () { return this._getDefaultConfig({isPlayer: true}); }

		static _getDefaultConfig (opts) {
		opts = opts || {};
		const isPlayer = opts.isPlayer;

		const defaultTemplate = MiscUtil.copy(ConfigConsts.getDefaultConfigSorted_());
		const out = {};

		defaultTemplate
			.forEach(([groupKey, groupVals]) => {
				const group = (out[groupKey] = {});

				const assignDefaults = settings => Object.entries(settings).forEach(([k, meta]) => {
					if (isPlayer) {
												if (meta.isPlayerEditable) group[k] = null;
					} else group[k] = meta.default;
				});

				if (groupVals.settings) assignDefaults(groupVals.settings);
				if (groupVals.settingsAdvanced) assignDefaults(groupVals.settingsAdvanced);
				if (groupVals.settingsHacks) assignDefaults(groupVals.settingsHacks);
			});

		return out;
	}

	static set (group, key, val) {
		if (!this._isCanSetConfig(group, key)) return;

		const prevVal = Config.get(group, key);

		const TARGET = UtilPrePreInit.isGM() ? Config._CONFIG : Config._CONFIG_PLAYER;
		(TARGET[group] = TARGET[group] || {})[key] = val;
		Config._saveConfigDebounced();

		this._fireConfigUpdateHook(group, key, prevVal, val);
	}

	static setTemp (group, key, val, {isSkipPermissionCheck = false} = {}) {
						if (!isSkipPermissionCheck && !this._isCanSetConfig(group, key)) return;

		const prevVal = Config.get(group, key);

		(Config._CONFIG_TEMP[group] = Config._CONFIG_TEMP[group] || {})[key] = val;

		this._fireConfigUpdateHook(group, key, prevVal, val);
	}

	static setRivetTargetDocument ({actor, pack} = {}) { 		if (actor && pack) throw new Error(`Only one of "actor" or "pack" may be specified!`);

		if (!actor && !pack) {
			ui.notifications.info(`Cleared Rivet import target. Rivet will now import to an appropriate directory.`);
			Config.set("rivet", "targetDocumentId", null);
			return;
		}

		if (actor) {
						const actorId = actor.isToken ? actor.uuid : actor.id;

			if (Config.get("rivet", "targetDocumentId") === actorId) {
				Config.set("rivet", "targetDocumentId", null);
								ui.notifications.warn(`Cleared Rivet import target. Rivet will now import to an appropriate directory.`);
				return;
			}

			Config.set("rivet", "targetDocumentId", actorId);
			ui.notifications.info(`Set Rivet import target. Rivet will now import to Actor "${actor.name}" (${actorId}). This can be changed in the Config.`);

			return;
		}

		if (pack) {
			const packConfigId = `Compendium.${pack.metadata.id}`;
			if (Config.get("rivet", "targetDocumentId") === packConfigId) {
				Config.set("rivet", "targetDocumentId", null);
				ui.notifications.warn(`Cleared Rivet import target. Rivet will now import to an appropriate directory.`);
				return;
			}

			Config.set("rivet", "targetDocumentId", packConfigId);
			ui.notifications.info(`Set Rivet import target. Rivet will now import to Compendium "${pack.metadata.label}" (${pack.metadata.id}). This can be changed in the Config.`);
		}
	}

	static _fireConfigUpdateHook (group, key, oldVal, newVal) {
		UtilHooks.callAll(
			UtilHooks.HK_CONFIG_UPDATE,
			{
				previous: {
					[group]: {
						[key]: oldVal,
					},
				},
				current: {
					[group]: {
						[key]: newVal,
					},
				},
			},
		);
	}

	static _isCanSetConfig (group, key) { return UtilPrePreInit.isGM() || _UtilConfig.isPlayerEditable(group, key); }

	static _LOCK_SAVE_CONFIG = new VeLock({name: "save config"});

	static async _pSaveConfig () {
		try {
			await this._LOCK_SAVE_CONFIG.pLock();
			await this._pSaveConfig_();
		} finally {
			this._LOCK_SAVE_CONFIG.unlock();
		}
	}

	static async _pSaveConfig_ () {
		if (!UtilPrePreInit.isGM()) {
			await GameStorage.pSetClient(Config._CLIENT_SETTINGS_KEY, MiscUtil.copy(Config._CONFIG_PLAYER));
			return;
		}

		await game.settings.set(SharedConsts.MODULE_ID, Config._SETTINGS_KEY, MiscUtil.copy(Config._CONFIG));

								const data = {
			type: "config.update",
			config: MiscUtil.copy(this._CONFIG),
		};

		game.socket.emit(Config._SOCKET_ID, data);
	}

	static _saveConfigDebounced = MiscUtil.throttle(Config._pSaveConfig, 100);

	static get (group, key, {isIgnorePlayer = false} = {}) {
				if (Config._CONFIG_TEMP[group]?.[key] !== undefined) return Config._CONFIG_TEMP[group][key];

		if (!UtilPrePreInit.isGM() && _UtilConfig.isPlayerEditable(group, key) && !isIgnorePlayer) {
			const playerValue = (Config._CONFIG_PLAYER[group] || {})[key];

			if ((_UtilConfig.isNullable(group, key) && playerValue === null) || playerValue != null) return this._get_getValidValue(group, key, playerValue);
		}

		const out = (Config._CONFIG[group] || {})[key];
		return this._get_getValidValue(group, key, out);
	}

	static _get_getValidValue (groupKey, key, value) {
		const meta = ConfigConsts.getDefaultConfigSortedFlat_()
			.find(([groupKey_]) => groupKey_ === groupKey)[1][key];

		if (meta.type !== "enum") return value;

		if (meta.isNullable && value == null) return value;

				const enumValues = _UtilConfig.getEnumValues(meta);
		if (value == null || !enumValues.some(it => (it.value ?? it) === value)) return meta.default ?? (enumValues[0].value ?? enumValues[0]);
		return value;
	}

	static _getDisplayLabels (group, key) {
		const defaultConfig = ConfigConsts.getDefaultConfig_();

		const displayGroup = defaultConfig[group]?.name;
		const displayKey = defaultConfig[group]?.settings?.[key]?.name
			|| defaultConfig[group]?.settingsAdvanced?.[key]?.name
			|| defaultConfig[group]?.settingsHacks?.[key]?.name;
		return {displayGroup, displayKey};
	}

	static has (groupKey, key) {
		return !!ConfigConsts.getDefaultConfigSortedFlat_()
			.find(([groupKey_]) => groupKey_ === groupKey)?.[1]?.[key];
	}

		static handleFailedInitConfigApplication (group, key, error) {
		const {displayGroup, displayKey} = Config._getDisplayLabels(group, key);
		ui.notifications.error(`Failed to apply Config "${displayKey}" -> "${displayGroup}" during initial load! ${VeCt.STR_SEE_CONSOLE}`);
		if (error) console.error(...LGT, error);
	}

		constructor (opts) {
		opts = opts || {};

		super({
			width: 720,
			height: Util.getMaxWindowHeight(),
			title: "Config Editor",
			template: `${SharedConsts.MODULE_LOCATION}/template/Config.hbs`,
			resizable: true,
		});

		this._ixActiveTab = null;
		this._tabMetas = null;
		this._fnsHandleUpdate = {};

		if (opts.initialVisibleGroup) {
			const ix = ConfigConsts.getDefaultConfigSorted_().findIndex(([groupKey]) => groupKey === opts.initialVisibleGroup);
			if (!~ix) throw new Error(`Could not find config group "${opts.initialVisibleGroup}"`);
			this._ixActiveTab = ix;
		}

		this._DRAFT_GM = null;
		this._DRAFT_PLAYER = null;

		Config._INSTANCE = this;
	}

	_addFnHandleUpdate (group, key, fn) {
		const target = MiscUtil.getOrSet(this._fnsHandleUpdate, group, key, []);
		target.push(fn);
	}

	_callFnsHandleUpdate (group, key) {
		const fns = MiscUtil.get(this._fnsHandleUpdate, group, key);
		(fns || []).forEach(fn => fn());
	}

	_setVisibleGroup (visibleGroup) {
		const ix = ConfigConsts.getDefaultConfigSorted_().findIndex(([groupKey]) => groupKey === visibleGroup);
		if (!~ix) throw new Error(`Could not find config group "${visibleGroup}"`);
		this._setActiveTab(ix);
	}

	_$getBtnSave ({isClose, textSaving, textSaved, text, textFailed}) {
		let tmtBtnSaveNotification = null;
		const $btnSave = $(`<button class="btn btn-5et btn-default min-w-100p">${text}</button>`)
			.click(async () => {
				if ($btnSave.prop("disabled")) return;

				clearTimeout(tmtBtnSaveNotification);

				try {
					$btnSave.prop("disabled", true).text(textSaving);

					const TARGET = game.user.isGM ? Config._CONFIG : Config._CONFIG_PLAYER;
					const DRAFT = game.user.isGM ? this._DRAFT_GM : this._DRAFT_PLAYER;

					const old = MiscUtil.copy(TARGET);

					Object.assign(TARGET, MiscUtil.copy(DRAFT));

					await Config._pSaveConfig();

					UtilHooks.callAll(
						UtilHooks.HK_CONFIG_UPDATE,
						{
							previous: old,
							current: MiscUtil.copy(TARGET),
						},
					);

					$btnSave.text(textSaved).prop("disabled", false);
					tmtBtnSaveNotification = setTimeout(() => $btnSave.text(text), VeCt.DUR_INLINE_NOTIFY);
				} catch (e) {
					$btnSave.text(textFailed);
					tmtBtnSaveNotification = setTimeout(() => $btnSave.text(text).prop("disabled", false), VeCt.DUR_INLINE_NOTIFY * 2);
				}

				if (isClose) await this.close();
			});

		return $btnSave;
	}

	activateListeners ($html) {
		super.activateListeners($html);
		$html.empty();

		(async () => {
			if (this._ixActiveTab == null) this._ixActiveTab = await StorageUtil.pGet(Config._SETTINGS_KEY_LAST_ACTIVE_TAB);
			if (this._ixActiveTab == null) this._ixActiveTab = 0;

			this._DRAFT_GM = MiscUtil.copy(Config._CONFIG);
			this._DRAFT_PLAYER = MiscUtil.copy(Config._CONFIG_PLAYER);

			const isHideUnavailable = Config.get("ui", "isHideGmOnlyConfig");

			this._tabMetas = ConfigConsts.getDefaultConfigSorted_()
				.map(([groupKey, groupVals], i) => this._activateListeners_getTabMeta({
					groupKey,
					groupVals,
					ixTab: i,
					isHideUnavailable,
				}));

			const $btnApply = this._$getBtnSave({
				textSaving: "Applying...",
				textSaved: "Applied!",
				textFailed: "Failed to apply",
				text: "Apply",
			});

			const $btnSave = this._$getBtnSave({
				isClose: true,
				textSaving: "Saving...",
				textSaved: "Saved!",
				textFailed: "Failed to save",
				text: "OK",
			});

			const $btnCancel = $(`<button class="btn btn-5et btn-default min-w-100p">Cancel</button>`)
				.click(() => this.close());

			const $iptSearch = $(`<input type="search" placeholder="Find setting..." class="input-xs form-control">`);
			UiUtil.bindTypingEnd({
				$ipt: $iptSearch,
				fnKeyup: () => {
					const searchVal = $iptSearch.val().toLowerCase().trim();
					this._tabMetas.forEach(it => it ? it.cbSearch(searchVal) : null);
				},
			});

			const $btnChangelog = $(`<button class="btn btn-5et btn-xs ml-1">Changelog</button>`)
				.click(async () => {
					const {Changelog} = await Promise.resolve().then(function () { return Changelog$1; });
					Changelog.open();
				});

			const $btnReportBug = $(`<button class="btn btn-5et btn-xs ml-1"><i class="fas fa-bug"></i> Report a Bug</button>`)
				.click(() => Config._doShowBugReportForm());

			const $wrpBtnsPatreon = this._$getWrpBtnsPatreon();

			const titleCompatWarning = this.constructor._getCompatibilityWarnings().qq();
			const $btnCompatWarning = $(`<button class="btn btn-5et btn-xs ml-1 btn-pulse" ${titleCompatWarning ? `title="${titleCompatWarning}"` : ""}><i class="fas fa-exclamation-triangle mr-0"></i></button>`)
				.click(() => {
					this.constructor._doResolveCompatibility();
					$btnCompatWarning.hideVe();
				});
			$btnCompatWarning.toggleVe(game.user.isGM && this.constructor._hasCompatibilityWarnings());

			const $btnResetAll = $(`<button class="btn btn-5et btn-xs ml-1" title="Reset All Settings"><i class="fa fa-undo-alt mr-0"></i></button>`)
				.click(async () => {
					const isContinue = await InputUiUtil.pGetUserBoolean({
						title: "Reset All",
						htmlDescription: "Are you sure you want to reset all config settings?",
						textNo: "Cancel",
						textYes: "Continue",
					});
					if (!isContinue) return;

					this._tabMetas.filter(Boolean).forEach(it => (it.fnsReset || []).forEach(fn => fn()));
				});

			$$`<div class="ve-flex-col w-100 h-100">
				<div class="w-100 p-1 no-shrink cfg__wrp-search ve-flex-v-center">
					${$iptSearch}
					${this._activateListeners_$getWrpImportExport()}
					${$btnChangelog}
					${$btnReportBug}
					${$wrpBtnsPatreon}
					${$btnCompatWarning}
					${$btnResetAll}
				</div>

				<div class="ve-flex w-100 h-100 min-h-0">
					<div class="ve-flex-col h-100 overflow-y-auto no-shrink cfg__wrp-tab-headers pb-1">
						${this._tabMetas.map(it => it ? it.$tabHeader : null)}
					</div>

					<div class="w-100 h-100 overflow-y-auto p-2">
						${this._tabMetas.map(it => it ? it.$tabBody : null)}
					</div>
				</div>

				<div class="w-100 p-1 no-shrink cfg__wrp-save">
					<div class="ve-flex-h-right">
						${$btnSave.addClass("mr-2")}
						${$btnCancel.addClass("mr-2")}
						${$btnApply.addClass("mr-4")}
					</div>
				</div>
			</div>`.appendTo($html);
		})();
	}

	static _doShowBugReportForm () {
		Promise.resolve().then(function () { return AppBugReport$1; })
			.then(({AppBugReport}) => new AppBugReport().render(true));
	}

	_$getWrpBtnsPatreon () {
		const $btnPatreon = $(`<a class="btn btn-5et btn-xs ml-1" href="https://www.patreon.com/Giddy5e" rel="noopener noreferrer"><i class="fab fa-patreon"></i> Become a Patron</a>`);

		const $wrpBtnsPatreon = $$`<div class="btn-group ml-1 ve-flex-vh-center">
			${$btnPatreon}
		</div>`;

		return $wrpBtnsPatreon;
	}

	_activateListeners_$getWrpImportExport () {
		if (!game.user.isGM) return null;

		const $btnExport = $(`<button class="btn btn-5et btn-xs" title="Export Config"><i class="fas fa-file-export fa-fw"></i> Export</button>`)
			.click(() => {
				DataUtil.userDownload(
					`${SharedConsts.MODULE_ID}-config`,
					{
						config: MiscUtil.copy(this.constructor._CONFIG),
					},
					{
						propVersion: "moduleVersion",
						fileType: "config",
						valVersion: game.modules.get(SharedConsts.MODULE_ID).version,
					},
				);
			});

		const $btnImport = $(`<button class="btn btn-5et btn-xs" title="Import Config"><i class="fas fa-file-import fa-fw"></i> Import</button>`)
			.click(async () => {
				const {jsons, errors} = await DataUtil.pUserUpload({
					expectedFileTypes: ["config"],
					propVersion: "moduleVersion",
				});

				DataUtil.doHandleFileLoadErrorsGeneric(errors);

				if (!jsons?.length) return;

				const config = jsons[0]?.config;
				if (!config) return ui.notifications.warn(`Could not find exported config in file!`);

				this.constructor._populateMissingConfigValues(config, {isPlayer: false});

				const old = MiscUtil.copy(Config._CONFIG);

				this._handleGmConfigUpdate(config);

				await Config._pSaveConfig();

				UtilHooks.callAll(
					UtilHooks.HK_CONFIG_UPDATE,
					{
						previous: old,
						current: MiscUtil.copy(Config._CONFIG),
					},
				);

				ui.notifications.info(`Config applied!`);
			});

		return $$`<div class="btn-group ml-1 ve-flex-vh-center">
			${$btnExport}
			${$btnImport}
		</div>`;
	}

	_activateListeners_getTabMeta ({groupKey, groupVals, ixTab, isHideUnavailable}) {
		const $dispResultCount = $(`<div class="cfg__disp-row-count-tab-header ve-hidden ve-flex-vh-center"></div>`);

		const $tabHeader = $$`<div class="relative cfg__btn-tab-header px-2 py-1 ml-1 mt-1 ${ixTab === this._ixActiveTab ? "cfg__btn-tab-header--active" : ""}" ${groupVals.help ? `title="${groupVals.help.escapeQuotes()}"` : ""}>
				${groupVals.name.escapeQuotes()}
				${$dispResultCount}
			</div>`
			.click(() => this._setActiveTab(ixTab));

		const $btnResetTab = $(`<button class="btn btn-xs ml-auto" title="Reset Settings for This Tab"><i class="fa fa-undo-alt mr-0"></i></button>`)
			.click(() => fnsReset.forEach(it => it()));

		const getRowMeta = settings => {
			return Object.entries(settings)
				.map(([k, meta]) => {
					const rowMeta = new _ConfigSettingBase({
						isHideUnavailable,
						meta,
						DRAFT_GM: this._DRAFT_GM,
						DRAFT_PLAYER: this._DRAFT_PLAYER,
						groupKey,
						k,
					}).render();

					if (!rowMeta) return;

					if (rowMeta.fnHandleUpdate) this._addFnHandleUpdate(groupKey, k, rowMeta.fnHandleUpdate);

					return rowMeta;
				})
				.filter(Boolean);
		};

		let metasSettings = groupVals.settings ? getRowMeta(groupVals.settings) : null;
		if (metasSettings && !metasSettings.length) metasSettings = null;
		let metasSettingsAdvanced = groupVals.settingsAdvanced ? getRowMeta(groupVals.settingsAdvanced) : null;
		if (metasSettingsAdvanced && !metasSettingsAdvanced.length) metasSettingsAdvanced = null;
		let metasSettingsHacks = groupVals.settingsHacks ? getRowMeta(groupVals.settingsHacks) : null;
		if (metasSettingsHacks && !metasSettingsHacks.length) metasSettingsHacks = null;

		if (!metasSettings && !metasSettingsAdvanced && !metasSettingsHacks) return null;

		const $tabBody = $$`<div class="ve-flex-col h-100 w-100 ${ixTab === this._ixActiveTab ? "" : "ve-hidden"}">
		<div class="ve-flex-v-center">
			${$btnResetTab}
		</div>
		<hr class="w-100 my-1">

		${metasSettings ? $$`<div class="w-100 ve-flex-col">${metasSettings.map(it => it.$row)}</div>` : null}

		${metasSettingsAdvanced ? `${metasSettings ? `<hr class="cfg__hr-tab-section">` : ""}<div class="cfg__head-tab-section my-1">Advanced Settings</div>` : ""}
		${metasSettingsAdvanced ? $$`<div class="w-100 ve-flex-col">${metasSettingsAdvanced.map(it => it.$row)}</div>` : null}

		${metasSettingsHacks ? `${metasSettings || metasSettingsAdvanced ? `<hr class="cfg__hr-tab-section">` : ""}<div class="cfg__head-tab-section my-1 help" title="These settings may be incompatible with other modules, or even Foundry itself. If something doesn't work, turn these off first.">Experimental Settings</div>` : ""}
		${metasSettingsHacks ? $$`<div class="w-100 ve-flex-col">${metasSettingsHacks.map(it => it.$row)}</div>` : null}
		</div>`;

		const totalRows = [
			metasSettings || [],
			metasSettingsAdvanced || [],
			metasSettingsHacks || [],
		].map(it => it.length).sum();

		const fnsReset = [
			metasSettings || [],
			metasSettingsAdvanced || [],
			metasSettingsHacks || [],
		].flatMap(arr => arr.map(rowMeta => rowMeta.fnReset));

		const cbSearch = (searchTerm) => {
			const cntHiddenRows = (metasSettings || []).map(it => Number(it.cbSearch(searchTerm) || 0)).sum()
				+ (metasSettingsAdvanced || []).map(it => Number(it.cbSearch(searchTerm) || 0)).sum()
				+ (metasSettingsHacks || []).map(it => Number(it.cbSearch(searchTerm) || 0)).sum();

			if (totalRows) {
				const cntVisibleRows = totalRows - cntHiddenRows;
				$tabHeader.toggleClass("cfg__btn-tab-header--muted", cntVisibleRows === 0);
				$dispResultCount
					.text(cntVisibleRows)
					.title(`${cntVisibleRows} result${cntVisibleRows === 1 ? "" : "s"}`)
					.toggleClass("cfg__disp-row-count-tab-header--has-results", !!cntVisibleRows)
					.toggleVe(searchTerm);
			}
		};

		return {$tabHeader, $tabBody, cbSearch, fnsReset};
	}

	_setActiveTab (ix) {
		this._tabMetas.map((it, i) => {
			if (!it) return;
			it.$tabHeader.toggleClass("cfg__btn-tab-header--active", ix === i);
			it.$tabBody.toggleClass("ve-hidden", ix !== i);
		});
		this._ixActiveTab = ix;
		StorageUtil.pSet(Config._SETTINGS_KEY_LAST_ACTIVE_TAB, ix).then(null);
	}

		_handleGmConfigUpdate (receivedConfig) {
		Object.assign(Config._CONFIG, receivedConfig);
		Object.assign(this._DRAFT_GM, MiscUtil.copy(Config._CONFIG));

		Object.entries(receivedConfig || {})
			.forEach(([group, meta]) => {
				Object.keys(meta || {})
					.forEach(key => this._callFnsHandleUpdate(group, key));
			});
	}

	async close (...args) {
		await super.close(...args);
		Config._INSTANCE = null;
	}

	static _getEnumValueValue (val) {

	}

		static isUseMetricDistance ({configGroup, configKey = "isMetricDistance"}) {
		return Config.get("import", "isGlobalMetricDistance") || Config.get(configGroup, configKey);
	}

	static isUseMetricWeight ({configGroup, configKey = "isMetricWeight"}) {
				if (UtilGameSettings.getSafe("dnd5e", "metricWeightUnits")) return true;

		return Config.get("import", "isGlobalMetricWeight") || Config.get(configGroup, configKey);
	}

	static getMetricNumberDistance ({configGroup, originalValue, originalUnit, configKey = "isMetricDistance"}) {
		return this._getMetricNumber({configGroup, originalValue, originalUnit, configKey, fnIsUse: Config.isUseMetricDistance.bind(Config)});
	}

	static getMetricNumberWeight ({configGroup, originalValue, originalUnit, configKey = "isMetricWeight"}) {
		return this._getMetricNumber({configGroup, originalValue, originalUnit, configKey, fnIsUse: Config.isUseMetricWeight.bind(Config)});
	}

	static _getMetricNumber ({configGroup, originalValue, originalUnit, configKey, fnIsUse}) {
		if (!fnIsUse({configGroup, configKey})) return originalValue;
		return Parser.metric.getMetricNumber({originalValue, originalUnit, toFixed: 3});
	}

	static getMetricUnitDistance ({configGroup, originalUnit, configKey = "isMetricDistance", isShortForm = true, isPlural = false}) {
		return this._getMetricUnit({configGroup, originalUnit, configKey, isShortForm, isPlural, fnIsUse: Config.isUseMetricDistance.bind(Config)});
	}

	static getMetricUnitWeight ({configGroup, originalUnit, configKey = "isMetricWeight", isShortForm = true, isPlural = false}) {
		return this._getMetricUnit({configGroup, originalUnit, configKey, isShortForm, isPlural, fnIsUse: Config.isUseMetricWeight.bind(Config)});
	}

	static _getMetricUnit ({configGroup, originalUnit, configKey, isShortForm, isPlural, fnIsUse}) {
		if (!fnIsUse({configGroup, configKey})) {
			if (!isShortForm) return originalUnit;
			switch (originalUnit) {
				case Parser.UNT_FEET: return "ft";
				case Parser.UNT_YARDS: return "yd";
				case Parser.UNT_MILES: return "mi";
				default: return originalUnit;
			}
		}
		return Parser.metric.getMetricUnit({originalUnit, isShortForm, isPlural});
	}

	static getSpellPointsKey ({actorType}) {
		return actorType === "character" ? "spellPointsMode" : "spellPointsModeNpc";
	}

	static getSpellPointsResource ({isValueKey = false, isMaxKey = false} = {}) {
		return this._getSpellPsiPointsResource({configGroup: "importSpell", configKey: "spellPointsResource", configKeyCustom: "spellPointsResourceCustom", isValueKey, isMaxKey});
	}

	static getPsiPointsResource ({isValueKey = false, isMaxKey = false} = {}) {
		return this._getSpellPsiPointsResource({configGroup: "importPsionic", configKey: "psiPointsResource", configKeyCustom: "psiPointsResourceCustom", isValueKey, isMaxKey});
	}

	static _getSpellPsiPointsResource ({configGroup, configKey, configKeyCustom, isValueKey = false, isMaxKey = false} = {}) {
		if (Config.get(configGroup, configKey) === ConfigConsts.C_SPELL_POINTS_RESOURCE__SHEET_ITEM) return ConfigConsts.C_SPELL_POINTS_RESOURCE__SHEET_ITEM;

		if (isValueKey && isMaxKey) throw new Error(`Only one of "isValue" and "isMax" may be specified!`);
		const out = Config.get(configGroup, configKey) === ConfigConsts.C_SPELL_POINTS_RESOURCE__ATTRIBUTE_CUSTOM
			? Config.get(configGroup, configKeyCustom)
			: Config.get(configGroup, configKey);
		return isValueKey ? `${out}.value` : isMaxKey ? `${out}.max` : out;
	}
	
	static _getWikiSummary () {
		const getDefaultValue = (setting) => {
			switch (setting.type) {
				case "boolean":
				case "string":
				case "url":
				case "color":
				case "percentage":
				case "number":
				case "integer": return setting.default;

				case "enum": {
					if (setting.default == null) return undefined;
					const value = _UtilConfig.getEnumValues(setting).find(it => (it?.value ?? it) === setting.default);
					if (value?.fnGetName && !value?.name) value.name = value.fnGetName();
					return value?.name ?? value;
				}

				case "multipleChoice": {
					return (setting.choices || [])
						.filter(it => !!setting.default?.[it.value])
						.map(it => it.name)
						.join("; ");
				}

				case "arrayStringShort": return (setting.default || []).join("; ");
				default: throw new Error(`Unhandled setting type "${setting.type}"!`);
			}
		};

		const getOptions = (setting) => {
			switch (setting.type) {
				case "enum": {
					return _UtilConfig.getEnumValues(setting).map(value => {
						if (typeof value === "string") return ({name: value});

						if (value?.fnGetName && !value?.name) value.name = value.fnGetName();

						if (!value.name) return {name: value.value};
						return value;
					});
				}

				case "multipleChoice": {
					return (setting.choices || []).map(choice => ({name: choice.name}));
				}

				default: return null;
			}
		};

		const getGroupSummary = (settings, type) => {
			return Object.values(settings || {})
				.filter(({unlockCode}) => !unlockCode)
				.map(setting => {
					const defaultValue = getDefaultValue(setting);
					const options = getOptions(setting);

					return {
						name: setting.name,
						description: setting.help,
						type,
						isPlayerEditable: !!setting.isPlayerEditable,
						isReloadRequired: !!setting.isReloadRequired,
						default: defaultValue,
						options,
					};
				});
		};

		return ConfigConsts.getDefaultConfigSorted_().map(([, group]) => {
			return {
				groupName: group.name,
				settings: [
					...getGroupSummary(group.settings, "standard"),
					...getGroupSummary(group.settingsAdvanced, "advanced"),
					...getGroupSummary(group.settingsHacks, "hacks"),
				],
			};
		});
	}

	static _getWikiSummaryMarkdown () {
		return this._getWikiSummary()
			.map(group => {
				let markdown = `## ${group.groupName}\n`;
				markdown += "TODO: Add description\n";

				const settingsTypes = {};
				group.settings.forEach(setting => {
					const typeName = setting.type.toTitleCase();
					settingsTypes[typeName] = [...(settingsTypes[typeName] || []), setting];
				});

				Object.entries(settingsTypes)
					.forEach(([typeName, settings]) => {
						markdown += `### ${typeName}\n`;
						settings.forEach(setting => {
							markdown += `- **${setting.name}**${(!setting.default && setting.default !== false) ? "" : ` *(default: ${setting.default})*`} - ${setting.description}\n`;

							if (setting.options) {
								if (setting.options.length > 10 && setting.options[0].value === ConfigConsts.C_USE_GAME_DEFAULT) {
									markdown += `	- *${setting.options[0].name}*\n`;
									markdown += "	- *Use one of many custom values*\n";
								} else {
									markdown += "	Possible options are:\n";
									setting.options.forEach(option => markdown += `	- *${option.name}*${option.help ? `: ${option.help}` : ""}\n`);
								}
							}
						});
					});

				return markdown.replaceAll(/((&quot;)|")/g, "`");
			})
			.join("");
	}
}
Config._INSTANCE = null;
Config._SETTINGS_KEY = `config`;
Config._CLIENT_SETTINGS_KEY = `${SharedConsts.MODULE_ID}_config`;
Config._SETTINGS_KEY_LAST_ACTIVE_TAB = `config.ixLastActiveTab`;
Config._SOCKET_ID = `module.${SharedConsts.MODULE_ID}`;
Config._CONFIG = {};
Config._CONFIG_PLAYER = {};
Config._CONFIG_TEMP = {}; 
Config._CACHE_DEFAULT_CONFIG_SORTED = null;
Config._CACHE_DEFAULT_CONFIG_SORTED_FLAT = null;

var Config$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Config: Config
});

class JqueryExtension {
	static init () {
		$.fn.extend({
			
			swap: function ($eleMap) {
				Object.entries($eleMap).forEach(([k, $v]) => {
					this.find(`[data-r="${k}"]`).replaceWith($v);
				});

				return this;
			},
		});
	}
}

class UtilNotifications {
	
	static notifyOnce ({id, type = "info", message}) {
		if (!UtilNotifications._VALID_TYPES.has(type)) type = "info";
		id = id || message;

		if (!UtilNotifications._SEEN_NOTIFICATIONS[id]) ui.notifications[type](message);
		UtilNotifications._SEEN_NOTIFICATIONS[id] = true;

		switch (type) {
			case "info": console.log(...LGT, message); break;
			case "warn": console.warn(...LGT, message); break;
			case "error": console.error(...LGT, message); break;
		}
	}

	static isAddSeen ({id, message}) {
		id = id || message;
		const out = UtilNotifications._SEEN_NOTIFICATIONS[id];
		UtilNotifications._SEEN_NOTIFICATIONS[id] = true;
		return out;
	}
}
UtilNotifications._VALID_TYPES = new Set(["info", "warn", "error"]);
UtilNotifications._SEEN_NOTIFICATIONS = {};

class UtilBackend {
	static _GET_BACKEND_VERSION_RESOLVE = null;
	static _P_GET_BACKEND_VERSION = new Promise(resolve => this._GET_BACKEND_VERSION_RESOLVE = resolve);

	static async pPrePreInit () {
		if (Config.get("misc", "isSkipBackendCheck")) {
			this._GET_BACKEND_VERSION_RESOLVE(false);
			console.log(...LGT, `Plutonium backend detected was skipped. Some features may be unavailable.`);
			return;
		}

		try {
			await this._pPrePreInit_pGetRegisterVersion();
		} catch (e) {
			this._pPrePreInit_handleGetRegisterVersionFail();
		}
	}

	static async _pPrePreInit_pGetRegisterVersion () {
		const json = await (await fetch(
			Config.backendEndpoint,
			{
				method: "post",
				headers: {
					"Content-Type": "application/json",
				},
				body: JSON.stringify({
					type: "getVersion",
				}),
			},
		)).json();

		this._GET_BACKEND_VERSION_RESOLVE(json.version);
		console.log(...LGT, `Compatible Plutonium backend (v${json.version}) detected.`);
		UtilHooks.callAll(UtilHooks.HK_CONFIG_UPDATE);
	}

	static _pPrePreInit_handleGetRegisterVersionFail () {
		this._GET_BACKEND_VERSION_RESOLVE(false);
		console.warn(...LGT, `Plutonium backend not detected. Some features may be unavailable. If you have not attempted to install the backend mod (see: the module README), please ignore the above 404. Alternatively, you can disable the backend check in the config.`);
		UtilHooks.callAll(UtilHooks.HK_CONFIG_UPDATE);
	}

	
	static pGetBackendVersion () { return this._P_GET_BACKEND_VERSION; }

	static _EXPECTED_VERSION = {
		min: {
			major: 0,
			minor: 6,
			patch: 0,
		},
		max: {
			major: 0,
			minor: 7,
			patch: 999,
		},
	};

	static async pGetBackendVersionMeta () {
		const version = await this._P_GET_BACKEND_VERSION;

		const out = {
			version: version,
			versionExpected: [
				this._EXPECTED_VERSION.max.major,
				this._EXPECTED_VERSION.max.minor,
				this._EXPECTED_VERSION.max.patch,
			]
				.join("."),
		};
		if (!version) return out;

		Object.assign(out, UtilVersions.getVersionComparison({...this._EXPECTED_VERSION, version}));

		return out;
	}
}

class Vetools {
		static PRERELEASE_INDEX__SOURCE = {};
	static PRERELEASE_INDEX__PROP = {};
	static PRERELEASE_INDEX__META = {};

		static BREW_INDEX__SOURCE = {};
	static BREW_INDEX__PROP = {};
	static BREW_INDEX__META = {};

		static async pDoPreload () {
		if (Config.get("import", "isNoPrereleaseBrewIndexes")) return;

				Vetools._pGetPrereleaseBrewIndices()
			.then(({propPrerelease, sourcePrerelease, metaPrerelease, sourceBrew, propBrew, metaBrew}) => {
				Vetools.PRERELEASE_INDEX__PROP = propPrerelease;
				Vetools.PRERELEASE_INDEX__SOURCE = sourcePrerelease;
				Vetools.PRERELEASE_INDEX__META = metaPrerelease;

				Vetools.BREW_INDEX__PROP = propBrew;
				Vetools.BREW_INDEX__SOURCE = sourceBrew;
				Vetools.BREW_INDEX__META = metaBrew;

				console.log(...LGT, "Loaded prerelease/homebrew indexes.");
			})
			.catch(e => {
				Vetools.PRERELEASE_INDEX__SOURCE = {};
				Vetools.PRERELEASE_INDEX__PROP = {};
				Vetools.PRERELEASE_INDEX__META = {};

				Vetools.BREW_INDEX__PROP = {};
				Vetools.BREW_INDEX__SOURCE = {};
				Vetools.BREW_INDEX__META = {};

				ui.notifications.error(`Failed to load prerelease/homebrew indexes! ${VeCt.STR_SEE_CONSOLE}`);
				setTimeout(() => { throw e; });
			});
	}

	static withUnpatchedDiceRendering (fn) {
		Renderer.getRollableEntryDice = Vetools._CACHED_GET_ROLLABLE_ENTRY_DICE;
		const out = fn();
		Renderer.getRollableEntryDice = Vetools._PATCHED_GET_ROLLABLE_ENTRY_DICE;
		return out;
	}

	static withCustomDiceRenderingPatch (fn, fnRender) {
		Renderer.getRollableEntryDice = fnRender;
		const out = fn();
		Renderer.getRollableEntryDice = Vetools._PATCHED_GET_ROLLABLE_ENTRY_DICE;
		return out;
	}

	static getCleanDiceString (diceString) {
		return diceString
						.replace(/×/g, "*")
			.replace(/÷/g, "/")
						.replace(/#\$.*?\$#/g, "0")
		;
	}

	static doMonkeyPatchPreConfig () {
		VeCt.STR_SEE_CONSOLE = "See the console (F12 or CTRL+SHIFT+J) for details.";

		StorageUtil.pSet = GameStorage.pSetClient.bind(GameStorage);
		StorageUtil.pGet = GameStorage.pGetClient.bind(GameStorage);
		StorageUtil.pRemove = GameStorage.pRemoveClient.bind(GameStorage);

				["monster", "vehicle", "object", "trap", "race", "background"].forEach(prop => {
			const propFullName = `${prop}Name`;
			const propFullSource = `${prop}Source`;
			(Renderer[prop].CHILD_PROPS_EXTENDED || Renderer[prop].CHILD_PROPS || ["feature"]).forEach(propChild => {
				const propChildFull = `${prop}${propChild.uppercaseFirst()}`;
				if (UrlUtil.URL_TO_HASH_BUILDER[propChildFull]) return;
				UrlUtil.URL_TO_HASH_BUILDER[propChildFull] = it => UrlUtil.encodeForHash([it.name, it[propFullName], it[propFullSource], it.source]);
			});
		});
			}

	static _CACHED_DATA_UTIL_LOAD_JSON = null;
	static _CACHED_DATA_UTIL_LOAD_RAW_JSON = null;

	static doMonkeyPatchPostConfig () {
		JqueryExtension.init();
		this._initSourceLookup();

		UtilsChangelog._RELEASE_URL = "https://github.com/TheGiddyLimit/plutonium-next/tags";

		const hkSetRendererUrls = () => {
			Renderer.get().setBaseUrl(Vetools.BASE_SITE_URL);

			if (Config.get("import", "isUseLocalImages")) {
				const localImageDirPath = `${Config.get("import", "localImageDirectoryPath")}/`.replace(/\/+$/, "/");
				Renderer.get().setBaseMediaUrl("img", localImageDirPath);
				return;
			}

			if (this._isCustomBaseSiteUrl()) {
				Renderer.get().setBaseMediaUrl("img", Vetools.BASE_SITE_URL);
				return;
			}

			Renderer.get().setBaseMediaUrl("img", null);
		};
		hkSetRendererUrls();

		UtilHooks.on(UtilHooks.HK_CONFIG_UPDATE, hkSetRendererUrls);

		Renderer.hover.MIN_Z_INDEX = Consts.Z_INDEX_MAX_FOUNDRY + 1;
		Renderer.hover._MAX_Z_INDEX = Renderer.hover.MIN_Z_INDEX + 10;

				Vetools._CACHED_GET_ROLLABLE_ENTRY_DICE = Renderer.getRollableEntryDice;
		Vetools._PATCHED_GET_ROLLABLE_ENTRY_DICE = (
			entry,
			name,
			toDisplay,
			{
				isAddHandlers = true,
				pluginResults = null,
			} = {},
		) => {
			const cpy = MiscUtil.copy(entry);

			if (typeof cpy.toRoll !== "string") {
								cpy.toRoll = Renderer.legacyDiceToString(cpy.toRoll);
			}

									if (cpy.prompt) {
				const minAdditionalDiceLevel = Math.min(...Object.keys(cpy.prompt.options)
					.map(it => Number(it))
					.filter(it => cpy.prompt.options[it]));
				cpy.toRoll = cpy.prompt.options[minAdditionalDiceLevel];
			}

			const toRollClean = this.getCleanDiceString(cpy.toRoll);

			if (Config.get("import", "isRendererDiceDisabled")) return toDisplay || toRollClean;

			return `[[${cpy.autoRoll ? "" : "/r "}${toRollClean}]]${toRollClean.toLowerCase().trim() !== toDisplay.toLowerCase().trim() ? ` (${toDisplay})` : ""}`;
		};

		Renderer.getRollableEntryDice = Vetools._PATCHED_GET_ROLLABLE_ENTRY_DICE;

						const cachedRenderHoverMethods = {};
		const renderHoverMethods = [
			"$getHoverContent_stats",
			"$getHoverContent_fluff",
			"$getHoverContent_statsCode",
			"$getHoverContent_miscCode",
			"$getHoverContent_generic",
		];
		renderHoverMethods.forEach(methodName => {
			cachedRenderHoverMethods[methodName] = Renderer.hover[methodName];
			Renderer.hover[methodName] = (...args) => {
				Renderer.getRollableEntryDice = Vetools._CACHED_GET_ROLLABLE_ENTRY_DICE;
				const out = cachedRenderHoverMethods[methodName](...args);
				Renderer.getRollableEntryDice = Vetools._PATCHED_GET_ROLLABLE_ENTRY_DICE;
				return out;
			};
		});

				const cachedGetMakePredefinedHover = Renderer.hover.getMakePredefinedHover.bind(Renderer.hover);
		Renderer.hover.getMakePredefinedHover = (entry, opts) => {
			const out = cachedGetMakePredefinedHover(entry, opts);
			out.html = `data-plut-hover="${true}" data-plut-hover-preload="${true}" data-plut-hover-preload-id="${out.id}" ${opts ? `data-plut-hover-preload-options="${JSON.stringify(opts).qq()}"` : ""}`;
			return out;
		};
		
		Renderer.dice.rollerClick = (evtMock, ele, packed, name) => {
			const entry = JSON.parse(packed);
			if (entry.toRoll) (new Roll(entry.toRoll)).toMessage();
		};

		Renderer.dice.pRollEntry = (entry, rolledBy, opts) => {
			if (entry.toRoll) (new Roll(entry.toRoll)).toMessage();
		};

		Renderer.dice.pRoll2 = async (str, rolledBy, opts) => {
			const roll = new Roll(str);
			await roll.evaluate({async: true});
			await roll.toMessage();
			return roll.total;
		};
		
				Vetools._CACHED_MONSTER_DO_BIND_COMPACT_CONTENT_HANDLERS = Renderer.monster.doBindCompactContentHandlers;
		Renderer.monster.doBindCompactContentHandlers = (opts) => {
			const nxtOpts = {...opts};
			nxtOpts.fnRender = (...args) => Vetools.withUnpatchedDiceRendering(() => opts.fnRender(...args));
			return Vetools._CACHED_MONSTER_DO_BIND_COMPACT_CONTENT_HANDLERS(nxtOpts);
		};
		
		JqueryUtil.doToast = (options) => {
			if (typeof options === "string") {
				options = {
					content: options,
					type: "info",
				};
			}
			options.type = options.type || "info";

			switch (options.type) {
				case "warning": return ui.notifications.warn(options.content);
				case "danger": return ui.notifications.error(options.content);
				default: return ui.notifications.info(options.content);
			}
		};

				UiUtil.pGetShowModal = opts => UtilApplications.pGetShowApplicationModal(opts);
		InputUiUtil._pGetShowModal = opts => UtilApplications.pGetShowApplicationModal(opts);
		
		this._CACHED_DATA_UTIL_LOAD_JSON = DataUtil.loadJSON.bind(DataUtil);
		this._CACHED_DATA_UTIL_LOAD_RAW_JSON = DataUtil.loadRawJSON.bind(DataUtil);

		DataUtil.loadJSON = async (url, ...rest) => Vetools._CACHED_DATA_UTIL_LOAD_JSON(this._getMaybeLocalUrl(url), ...rest);
		DataUtil.loadRawJSON = async (url, ...rest) => Vetools._CACHED_DATA_UTIL_LOAD_RAW_JSON(this._getMaybeLocalUrl(url), ...rest);

		Vetools._CACHED_RENDERER_HOVER_CACHE_AND_GET = DataLoader.pCacheAndGet.bind(DataLoader);
		DataLoader.pCacheAndGet = async function (page, source, ...others) {
															const sourceLower = `${source}`.toLowerCase();
			if (!Vetools._VET_SOURCE_LOOKUP[sourceLower]) {
				Vetools._pCachingLocalPrerelease = Vetools._pCachingLocalPrerelease || Vetools._pDoCacheLocalPrerelease();
				Vetools._pCachingLocalBrew = Vetools._pCachingLocalBrew || Vetools._pDoCacheLocalBrew();

				await Promise.all([
					Vetools._pCachingLocalPrerelease,
					Vetools._pCachingLocalBrew,
				]);
			}
			
			return Vetools._CACHED_RENDERER_HOVER_CACHE_AND_GET(page, source, ...others);
		};

				PrereleaseUtil._storage = new StorageUtilMemory();
		BrewUtil2._storage = new StorageUtilMemory();
			}

	static _initSourceLookup () { Object.keys(Parser.SOURCE_JSON_TO_FULL).forEach(source => Vetools._VET_SOURCE_LOOKUP[source.toLowerCase()] = true); }

	static _pCachingLocalPrerelease = null;
	static _pCachingLocalBrew = null;

	static async _pDoCacheLocalPrerelease () { await this.pGetLocalPrereleaseSources(); }
	static async _pDoCacheLocalBrew () { await this.pGetLocalBrewSources(); }

		static _getMaybeLocalUrl (url) {
		if (!url.includes("?")) url = `${url}?t=${Consts.RUN_TIME}`;

		const parts = url.split(Vetools._RE_HTTP_URL).filter(Boolean);
		parts[parts.length - 1] = parts.last().replace(/\/+/g, "/");
		url = parts.join("");

		if (
			!Config.get("import", "isNoLocalData")
			&& (
				url.startsWith(`${Vetools.BASE_SITE_URL}data/`)
				|| url.startsWith(`${Vetools.BASE_SITE_URL}search/`)
			)
		) {
			const urlPart = url.split(Vetools.BASE_SITE_URL).slice(1).join(Vetools.BASE_SITE_URL);
			return `modules/${SharedConsts.MODULE_ID}/${urlPart}`;
		} else {
			return url;
		}
	}

	static _CACHE_IMPORTER_SOURCE_SPECIAL = {};

	static async pLoadImporterSourceSpecial (source) {
		if (!source.special.cacheKey) return source.special.pGet();

		this._CACHE_IMPORTER_SOURCE_SPECIAL[source.special.cacheKey] = this._CACHE_IMPORTER_SOURCE_SPECIAL[source.special.cacheKey]
			|| source.special.pGet();

		return this._CACHE_IMPORTER_SOURCE_SPECIAL[source.special.cacheKey];
	}

	static async pGetChangelog () { return DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/changelog.json`); }

	static async pGetPackageIndex () { return DataUtil.loadJSON(Config.get("importAdventure", "indexUrl")); }

	static async pGetItems () {
		return {item: (await Renderer.item.pBuildList()).filter(it => !it._isItemGroup)}; 	}

	static async pGetPrereleaseItems (data) {
		return this._pGetPrereleaseBrewItems({data, pFnGetItems: Renderer.item.pGetItemsFromPrerelease.bind(Renderer.item)});
	}

	static async pGetBrewItems (data) {
		return this._pGetPrereleaseBrewItems({data, pFnGetItems: Renderer.item.pGetItemsFromBrew.bind(Renderer.item)});
	}

	static async _pGetPrereleaseBrewItems ({data, pFnGetItems}) {
		const sources = new Set();
		["item", "magicvariant", "baseitem"].forEach(prop => {
			if (!data[prop]) return;
			data[prop].forEach(ent => sources.add(SourceUtil.getEntitySource(ent)));
		});
		return (await pFnGetItems()).filter(ent => sources.has(SourceUtil.getEntitySource(ent)));
	}

		static async pGetRaces (opts) {
		return DataUtil.race.loadJSON(opts);
	}

	static async pGetClasses () {
		return DataUtil.class.loadRawJSON();
	}

	static async pGetClassSubclassFeatures () {
		return DataUtil.class.loadRawJSON();
	}

	static async pGetRollableTables () {
		return DataUtil.table.loadJSON();
	}

	static async pGetDecks () {
		return DataUtil.deck.loadJSON();
	}

	static async _pGetAdventureBookIndex (filename, {prop, fnGetUrl}) {
		const url = `${Vetools.BASE_SITE_URL}data/${filename}`;
		const index = await DataUtil.loadJSON(url);
		index[prop].forEach(it => {
			it._pubDate = new Date(it.published || "1970-01-01");
			it._url = fnGetUrl(it.id);
		});
		return index;
	}

	static async pGetAdventureIndex () {
		return this._pGetAdventureBookIndex("adventures.json", {prop: "adventure", fnGetUrl: Vetools.getAdventureUrl.bind(Vetools)});
	}

	static async pGetBookIndex () {
		return this._pGetAdventureBookIndex("books.json", {prop: "book", fnGetUrl: Vetools.getBookUrl.bind(Vetools)});
	}

	static _getAdventureBookUrl (type, id) {
		return `${Vetools.BASE_SITE_URL}data/${type}/${type}-${id.toLowerCase()}.json`;
	}

	static getAdventureUrl (id) {
		return this._getAdventureBookUrl("adventure", id);
	}

	static getBookUrl (id) {
		return this._getAdventureBookUrl("book", id);
	}

	static pGetImageUrlFromFluff (fluff) {
		if (!fluff?.images?.length) return;

		const imgEntry = fluff.images[0];
		if (!imgEntry?.href) return;

		if (imgEntry.href.type === "internal") {
			return imgEntry.href.path ? `${Vetools.getInternalImageUrl(imgEntry.href.path)}` : null;
		}

		if (imgEntry.href.type === "external") {
			return imgEntry.href.url ? imgEntry.href.url : null;
		}
	}

	static async pHasTokenUrl (entityType, it, opts) {
		return (await Vetools._pGetTokenUrl(entityType, it, opts))?.hasToken;
	}

	static async pGetTokenUrl (entityType, it, opts) {
		return (await Vetools._pGetTokenUrl(entityType, it, opts))?.url;
	}

	static _isSaveableToServerUrl (originalUrl) { return originalUrl && typeof originalUrl === "string" && Vetools._RE_HTTP_URL.test(originalUrl); }
	static _isSaveTypedImagesToServer ({imageType = "image"} = {}) {
		switch (imageType) {
			case "image": return Config.get("import", "isSaveImagesToServer");
			case "token": return Config.get("import", "isSaveTokensToServer");
			default: throw new Error(`Unhandled type "${imageType}"!`);
		}
	}

	static async _pGetTokenUrl (entityType, it, {isSilent = false} = {}) {
		if (it.tokenUrl) return {url: it.tokenUrl, hasToken: true};

		const fallbackMeta = {
			url: this.getBlankTokenUrl(),
			hasToken: false,
		};

		switch (entityType) {
			case "monster":
			case "vehicle":
			case "object": {
				const fnGets = {
					"monster": Renderer.monster.getTokenUrl,
					"vehicle": Renderer.vehicle.getTokenUrl,
					"object": Renderer.object.getTokenUrl,
				};
				const fnGet = fnGets[entityType];
				if (!fnGet) throw new Error(`Missing getter!`);

				if (it.hasToken) return {url: fnGet(it), hasToken: true};
				if (it._versionBase_hasToken) return {url: fnGet({name: it._versionBase_name, source: it._versionBase_source}), hasToken: true};

				return fallbackMeta;
			}
			case "trap": return fallbackMeta;
			default: {
				if (isSilent) return null;
				throw new Error(`Unhandled entity type "${entityType}"`);
			}
		}
	}

	static getBlankTokenUrl () { return UrlUtil.link(`${Renderer.get().baseMediaUrls["img"] || Renderer.get().baseUrl}img/blank.png`); }

	static getImageUrl (entry) {
		if (entry?.href.type === "internal") return Vetools.getInternalImageUrl(entry.href.path, {isSkipEncode: true});
		return entry.href?.url;
	}

	static getInternalImageUrl (path, {isSkipEncode = false} = {}) {
		if (!path) return null;
		const fnEncode = isSkipEncode ? it => it : encodeURI;

		const out = `${fnEncode(Renderer.get().baseMediaUrls["img"] || Renderer.get().baseUrl)}img/${fnEncode(path)}`;

		if (isSkipEncode) return out;
		return out.replace(/'/g, "%27"); 	}

	static async pOptionallySaveImageToServerAndGetUrl (originalUrl, {imageType = "image"} = {}) {
		if (this._isLocalUrl({originalUrl})) return originalUrl;
		if (!this._isSaveTypedImagesToServer({imageType})) return originalUrl;
		return this.pSaveImageToServerAndGetUrl({originalUrl});
	}

	static _isLocalUrl ({originalUrl}) { return new URL(document.baseURI).origin === new URL(originalUrl, document.baseURI).origin; }

	static getImageSavedToServerUrl ({originalUrl, path, isSaveToRoot = false} = {}) {
		if (!path && !this._isSaveableToServerUrl(originalUrl)) return originalUrl;

		const pathPart = (new URL(path ? `https://example.com/${path}` : originalUrl)).pathname;
		return `${isSaveToRoot ? "" : `${Config.get("import", "localImageDirectoryPath")}/`}${decodeURI(pathPart)}`.replace(/\/+/g, "/");
	}

	static async pSaveImageToServerAndGetUrl ({originalUrl, blob, force = false, path = null, isSaveToRoot = false} = {}) {
		if (blob && originalUrl) throw new Error(`"blob" and "originalUrl" arguments are mutually exclusive!`);

		if (!blob && !this._isSaveableToServerUrl(originalUrl)) return originalUrl;

		let out;
		try {
			await Vetools._LOCK_DOWNLOAD_IMAGE.pLock();
			out = await this._pSaveImageToServerAndGetUrl_({originalUrl, blob, force, path, isSaveToRoot});
		} finally {
			Vetools._LOCK_DOWNLOAD_IMAGE.unlock();
		}
		return out;
	}

	static async _pSaveImageToServerAndGetUrl_ ({originalUrl, blob, force = false, path = null, isSaveToRoot = false} = {}) {
		if (blob && originalUrl) throw new Error(`"blob" and "originalUrl" arguments are mutually exclusive!`);

		const cleanOutPath = this.getImageSavedToServerUrl({originalUrl, path, isSaveToRoot});
		const pathParts = cleanOutPath.split("/");
		const cleanOutDir = pathParts.slice(0, -1).join("/");

		let existingFiles = null;
		let isDirExists = false;
		try {
			existingFiles = await FilePicker.browse("data", cleanOutDir);
			if (existingFiles?.target) isDirExists = true; 		} catch (e) {
			if (!/^Directory .*? does not exist/.test(`${e}`)) {
				const msgStart = `Could not check for existing files when saving imported images to server!`;
				if (!force && blob) throw new Error(msgStart);

				const msg = `${msgStart}${force ? "" : ` The original image URL will be used instead.`}`;
				UtilNotifications.notifyOnce({type: "warn", message: msg});
				return force ? cleanOutPath : originalUrl;
			}
		}

				if (existingFiles?.files && existingFiles?.files.map(it => decodeURI(it)).includes(cleanOutPath)) return cleanOutPath;

		if (!this._canUploadFiles()) {
			if (!force && blob) throw new Error(`Your permission levels do not allow you to upload files!`);

			const msg = `You have the "Save Imported Images to Server" config option enabled, but your permission levels do not allow you to upload files!${force ? "" : ` The original image URL will be used instead.`}`;
			UtilNotifications.notifyOnce({type: "warn", message: msg});
			return force ? cleanOutPath : originalUrl;
		}

		if (!isDirExists) {
			try {
				await this._pSaveImageToServerAndGetUrl_pCreateDirectories(cleanOutPath);
			} catch (e) {
				const msgStart = `Could not create required directories when saving imported images to server!`;
				if (!force && blob) throw new Error(msgStart);

				const msg = `${msgStart}${force ? "" : ` The original image URL will be used instead.`}`;
				UtilNotifications.notifyOnce({type: "warn", message: msg});
				return force ? cleanOutPath : originalUrl;
			}
		}

		try {
			blob = blob || await this._pSaveImageToServerAndGetUrl_pGetBlob(originalUrl);
		} catch (e) {
			const msg = `Failed to download image "${originalUrl}" when saving imported images to server!${force ? "" : ` The original image URL will be used instead.`} ${VeCt.STR_SEE_CONSOLE}`;
			UtilNotifications.notifyOnce({type: "warn", message: msg});
			console.error(...LGT, e);
			return force ? cleanOutPath : originalUrl;
		}

		const name = pathParts.last();
		let mimeType = `image/${(name.split(".").last() || "").trim().toLowerCase()}`;
				if (mimeType === "image/jpg") mimeType = "image/jpeg";

		const resp = await FilePicker.upload(
			"data",
			cleanOutDir,
			new File(
				[blob],
				name,
				{
					lastModified: Date.now(),
					type: mimeType,
				},
			),
		);
		if (resp?.path) return decodeURI(resp.path);

		return force ? cleanOutPath : originalUrl;
	}

	static async _pSaveImageToServerAndGetUrl_pGetBlob (originalUrl) {
		const isBackend = await UtilBackend.pGetBackendVersion();

		try {
			const blobResp = await fetch(originalUrl);
			return blobResp.blob();
		} catch (e) {
			if (!isBackend) throw e;
			console.warn(...LGT, `Could not directly load image from ${originalUrl}\u2014falling back on alternate loader (backend mod).`);
		}

		const blobResp = await fetch(
			Config.backendEndpoint,
			{
				method: "post",
				headers: {
					"Content-Type": "application/json",
				},
				body: JSON.stringify({
					type: "getBinaryData",
					url: originalUrl,
				}),
			},
		);
		return blobResp.blob();
	}

	static async _pSaveImageToServerAndGetUrl_pCreateDirectories (cleanOutPath) {
		const dirParts = cleanOutPath.split("/").slice(0, -1);
		if (!dirParts.length) return;
		for (let i = 0; i < dirParts.length; ++i) {
			const dirPartSlice = dirParts.slice(0, i + 1);
			try {
				await FilePicker.createDirectory("data", dirPartSlice.join("/"));
			} catch (e) {
				if (`${e}`.startsWith(`EEXIST`)) continue;
				throw new Error(e);
			}
		}
	}

	static _canUploadFiles () {
		return game.isAdmin || (game.user && game.user.can("FILES_UPLOAD"));
	}

	static async pGetAllSpells (
		{
			isFilterNonStandard = false,
			additionalSourcesPrerelease = [],
			additionalSourcesBrew = [],
			isIncludeLoadedBrew = false,
			isIncludeLoadedPrerelease = false,
			isApplyBlocklist = false,
		} = {},
	) {
		let spells = MiscUtil.copyFast(await DataUtil.spell.pLoadAll());

		if (isFilterNonStandard) spells = spells.filter(sp => !SourceUtil.isNonstandardSource(sp.source));

		if (isIncludeLoadedPrerelease) {
			const prerelease = await PrereleaseUtil.pGetBrewProcessed();
			if (prerelease.spell?.length) spells = spells.concat(prerelease.spell);
		}

		if (isIncludeLoadedBrew) {
			const brew = await BrewUtil2.pGetBrewProcessed();
			if (brew.spell?.length) spells = spells.concat(brew.spell);
		}

		const pHandleAdditionalSources = async ({additionalSources, pFnLoad}) => {
			for (const src of additionalSources) {
				const json = await pFnLoad(src);
				if (!json) continue;
				if (json.spell?.length) spells = spells.concat(json.spell);
			}
		};

		if (additionalSourcesPrerelease?.length) await pHandleAdditionalSources({additionalSources: additionalSourcesPrerelease, pFnLoad: DataUtil.pLoadPrereleaseBySource.bind(DataUtil)});
		if (additionalSourcesBrew?.length) await pHandleAdditionalSources({additionalSources: additionalSourcesBrew, pFnLoad: DataUtil.pLoadBrewBySource.bind(DataUtil)});

		if (isApplyBlocklist) {
			spells = spells
				.filter(sp => !ExcludeUtil.isExcluded(
					UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_SPELLS](sp),
					"spell",
					sp.source,
					{isNoCount: true},
				),
				);
		}

		spells.forEach(sp => Renderer.spell.initBrewSources(sp));

		return {spell: spells};
	}

	static async pGetAllCreatures (isFilterNonStandard = false) {
		let creatures = await DataUtil.monster.pLoadAll();

		if (isFilterNonStandard) creatures = creatures.filter(mon => !SourceUtil.isNonstandardSource(mon.source));

		return {monster: creatures};
	}

	static async _pGetPrereleaseBrewIndices () {
		const out = {
			sourcePrerelease: {},
			propPrerelease: {},
			metaPrerelease: {},

			sourceBrew: {},
			propBrew: {},
			metaBrew: {},
		};

		try {
			const [
				sourceIndexPrerelease,
				propIndexPrerelease,
				metaIndexPrerelease,

				sourceIndexBrew,
				propIndexBrew,
				metaIndexBrew,
			] = await Promise.all([
				DataUtil.prerelease.pLoadSourceIndex(Config.get("import", "basePrereleaseUrl")),
				DataUtil.prerelease.pLoadPropIndex(Config.get("import", "basePrereleaseUrl")),
				DataUtil.prerelease.pLoadMetaIndex(Config.get("import", "basePrereleaseUrl")),

				DataUtil.brew.pLoadSourceIndex(Config.get("import", "baseBrewUrl")),
				DataUtil.brew.pLoadPropIndex(Config.get("import", "baseBrewUrl")),
				DataUtil.brew.pLoadMetaIndex(Config.get("import", "baseBrewUrl")),
			]);

			out.sourcePrerelease = sourceIndexPrerelease;
			out.propPrerelease = propIndexPrerelease;
			out.metaPrerelease = metaIndexPrerelease;

			out.sourceBrew = sourceIndexBrew;
			out.propBrew = propIndexBrew;
			out.metaBrew = metaIndexBrew;
		} catch (e) {
			ui.notifications.error(`Failed to load prerelease/homebrew index! ${VeCt.STR_SEE_CONSOLE}`);
			setTimeout(() => { throw e; });
		}

		return out;
	}

	static async pGetPrereleaseSources (...dirs) {
		return this._pGetPrereleaseBrewSources({
			dirs,
			brewUtil: PrereleaseUtil,
			indexProp: Vetools.PRERELEASE_INDEX__PROP,
			indexMeta: Vetools.PRERELEASE_INDEX__META,
			configKey: "basePrereleaseUrl",
		});
	}

	static async pGetBrewSources (...dirs) {
		return this._pGetPrereleaseBrewSources({
			dirs,
			brewUtil: BrewUtil2,
			indexProp: Vetools.BREW_INDEX__PROP,
			indexMeta: Vetools.BREW_INDEX__META,
			configKey: "baseBrewUrl",
		});
	}

	static async _pGetPrereleaseBrewSources ({dirs, brewUtil, indexProp, indexMeta, configKey}) {
		const urlRoot = Config.get("import", configKey);

		let paths;
		if (dirs.includes("*")) {
			paths = Object.values(indexProp)
				.map(obj => Object.keys(obj))
				.flat()
				.unique();
		} else {
			paths = dirs
				.map(dir => Object.keys(indexProp[brewUtil.getDirProp(dir)] || {}))
				.flat()
				.unique();
		}

		return paths.map((path) => {
			const metaName = UrlUtil.getFilename(path);
			return ({
				url: brewUtil.getFileUrl(path, urlRoot),
				name: this._getPrereleaseBrewName(path),
				abbreviations: indexMeta[metaName]?.a || [],
			});
		})
			.sort((a, b) => SortUtil.ascSortLower(a.name, b.name));
	}

	static _getPrereleaseBrewName (brewPath) { return brewPath.split("/").slice(-1).join("").replace(/\.json$/i, ""); }

	static _LOCAL_PRERELEASE_SOURCE_SEEN_URLS = new Set();
	static async pGetLocalPrereleaseSources (...dirs) {
		return this._pGetLocalPrereleaseBrewSources({
			brewUtil: PrereleaseUtil,
			dirs,
			displayName: "prerelease",
			configKeyLocal: "localPrerelease",
			configKeyIsLoadIndex: "isLoadLocalPrereleaseIndex",
			configKeyIsUseIndex: "isUseLocalPrereleaseIndexJson",
			configKeyDirectoryPath: "localPrereleaseDirectoryPath",
			setSeenUrls: this._LOCAL_PRERELEASE_SOURCE_SEEN_URLS,
		});
	}

	static _LOCAL_BREW_SOURCE_SEEN_URLS = new Set();
	static async pGetLocalBrewSources (...dirs) {
		return this._pGetLocalPrereleaseBrewSources({
			brewUtil: BrewUtil2,
			dirs,
			displayName: "homebrew",
			configKeyLocal: "localHomebrew",
			configKeyIsLoadIndex: "isLoadLocalHomebrewIndex",
			configKeyIsUseIndex: "isUseLocalHomebrewIndexJson",
			configKeyDirectoryPath: "localHomebrewDirectoryPath",
			setSeenUrls: this._LOCAL_BREW_SOURCE_SEEN_URLS,
		});
	}

	static async _pGetLocalPrereleaseBrewSources ({brewUtil, dirs, displayName, configKeyLocal, configKeyIsLoadIndex, configKeyIsUseIndex, configKeyDirectoryPath, setSeenUrls}) {
		try {
			const listLocal = await this._pGetLocalPrereleaseBrewList({
				displayName,
				configKeyIsLoadIndex,
				configKeyIsUseIndex,
				configKeyDirectoryPath,
			});

			const allFilenames = [
				...(listLocal || []),
				...Config.get("import", configKeyLocal),
			];

			if (!allFilenames.length) return [];

			await allFilenames.pSerialAwaitMap(async name => {
				if (setSeenUrls.has(name)) return;
				setSeenUrls.add(name);
				await brewUtil.pAddBrewFromUrl(name, {isLazy: true});
			});
			await brewUtil.pAddBrewsLazyFinalize();

			const brews = await allFilenames.pSerialAwaitMap(async name => ({
				url: name,
				data: await DataUtil.loadJSON(name),
				name: this._getPrereleaseBrewName(name),
			}));

			const desiredProps = new Set(dirs.map(dir => brewUtil.getDirProp(dir)));

			return brews
				.filter(({data}) => {
					if (desiredProps.has("*")) return true;

					const propsInBrew = new Set([
												...Object.keys(data || {})
							.filter(it => !it.startsWith("_")),
												...Object.keys(data?._meta?.includes || {}),
					]);

					return [...desiredProps].some(it => propsInBrew.has(it));
				})
				.map(it => {
					it.abbreviations = (it.data?._meta?.sources || []).map(it => it.abbreviation).filter(Boolean);
					return it;
				})
				.map(({name, url, abbreviations}) => ({name, url, abbreviations}));
		} catch (e) {
			const msg = `Failed to load local homebrew index!`;
			console.error(...LGT, msg, e);
			ui.notifications.error(`${msg} ${VeCt.STR_SEE_CONSOLE}`);
		}
		return [];
	}

	static async _pGetLocalPrereleaseBrewList ({displayName, configKeyIsLoadIndex, configKeyIsUseIndex, configKeyDirectoryPath}) {
		if (!Config.get("import", configKeyIsLoadIndex)) return null;

		const isUseIndexJson = Config.get("import", configKeyIsUseIndex);

		if (isUseIndexJson) {
			const indexUrl = `${Config.get("import", configKeyDirectoryPath)}/index.json`.replace(/\/+/g, "/");
			const index = await DataUtil.loadJSON(indexUrl);
			if (!index?.toImport) return [];
			return index.toImport.map(it => {
								if (Vetools._RE_HTTP_URL.test(it)) return it;

								return [...indexUrl.split("/").slice(0, -1), it].join("/");
			});
		}

		try {
			const existingFiles = await FilePicker.browse("data", Config.get("import", configKeyDirectoryPath));
			if (!existingFiles?.files?.length) return null;

			return existingFiles.files.map(it => decodeURIComponent(it));
		} catch (e) {
			const msg = `Failed to load local ${displayName}${isUseIndexJson ? " index" : ""}! Does the ${isUseIndexJson ? "file" : "directory"} "<data_dir>/${Config.get("import", configKeyDirectoryPath)}${isUseIndexJson ? "/index.json" : ""}" exist?`;
			console.error(...LGT, msg, e);
			ui.notifications.error(`${msg} ${VeCt.STR_SEE_CONSOLE}`);
			return null;
		}
	}
	
		static async pGetSpellSideData () { return DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/spells/foundry.json`); }
	static async pGetOptionalFeatureSideData () { return DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-optionalfeatures.json`); }
	static async pGetClassSubclassSideData () { return DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/class/foundry.json`); }
	static async pGetRaceSideData () { return DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-races.json`); }
	static async pGetItemSideData () { return DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-items.json`); }
	static async pGetFeatSideData () { return DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-feats.json`); }
	static async pGetRewardSideData () { return DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-rewards.json`); }
	static async pGetActionSideData () { return DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-actions.json`); }
	static async pGetVehicleUpgradeSideData () { return DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-vehicles.json`); }
	static async pGetCreatureSideData () { return DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/bestiary/foundry.json`); }
	static async pGeBackgroundSideData () { return DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-backgrounds.json`); }
	static async pGetPsionicsSideData () { return DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-psionics.json`); }

		static async pGetConditionDiseaseSideData () { return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-conditionsdiseases.json`); }
	static async pGetObjectSideData () { return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-objects.json`); }
	static async pGetVehicleSideData () { return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-vehicles.json`); }
	static async pGetCharCreationOptionSideData () { return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-charcreationoptions.json`); }
	static async pGetCultBoonSideData () { return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-cultsboons.json`); }
	static async pGetTrapHazardSideData () { return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-trapshazards.json`); }
	static async pGetDeckSideData () { return {} || DataUtil.loadJSON(`${Vetools.BASE_SITE_URL}data/foundry-decks.json`); }
	
	
	static getModuleDataUrl (filename) {
		return `modules/${SharedConsts.MODULE_ID}/data/${filename}`;
	}

		static async pGetIconLookup (entityType) {
		return DataUtil.loadJSON(this.getModuleDataUrl(`icon-${entityType}s.json`));
	}
	
	static get BASE_SITE_URL () {
		if (this._isCustomBaseSiteUrl()) {
			return Util.getCleanServerUrl(Config.get("import", "baseSiteUrl"));
		}
		return Vetools._BASE_SITE_URL;
	}

	static _isCustomBaseSiteUrl () {
		const val = Config.get("import", "baseSiteUrl");
		return !!(val && val.trim());
	}

	static get DATA_URL_FEATS () { return `${Vetools.BASE_SITE_URL}data/feats.json`; }
	static get DATA_URL_BACKGROUNDS () { return `${Vetools.BASE_SITE_URL}data/backgrounds.json`; }
	static get DATA_URL_VARIANTRULES () { return `${Vetools.BASE_SITE_URL}data/variantrules.json`; }
	static get DATA_URL_PSIONICS () { return `${Vetools.BASE_SITE_URL}data/psionics.json`; }
	static get DATA_URL_OPTIONALFEATURES () { return `${Vetools.BASE_SITE_URL}data/optionalfeatures.json`; }
	static get DATA_URL_CONDITIONSDISEASES () { return `${Vetools.BASE_SITE_URL}data/conditionsdiseases.json`; }
	static get DATA_URL_VEHICLES () { return `${Vetools.BASE_SITE_URL}data/vehicles.json`; }
	static get DATA_URL_REWARDS () { return `${Vetools.BASE_SITE_URL}data/rewards.json`; }
	static get DATA_URL_OBJECTS () { return `${Vetools.BASE_SITE_URL}data/objects.json`; }
	static get DATA_URL_DEITIES () { return `${Vetools.BASE_SITE_URL}data/deities.json`; }
	static get DATA_URL_RECIPES () { return `${Vetools.BASE_SITE_URL}data/recipes.json`; }
	static get DATA_URL_CHAR_CREATION_OPTIONS () { return `${Vetools.BASE_SITE_URL}data/charcreationoptions.json`; }
	static get DATA_URL_CULTSBOONS () { return `${Vetools.BASE_SITE_URL}data/cultsboons.json`; }
	static get DATA_URL_ACTIONS () { return `${Vetools.BASE_SITE_URL}data/actions.json`; }
	static get DATA_URL_LANGUAGES () { return `${Vetools.BASE_SITE_URL}data/languages.json`; }
	static get DATA_URL_TRAPS_HAZARDS () { return `${Vetools.BASE_SITE_URL}data/trapshazards.json`; }
}
Vetools._RE_HTTP_URL = /(^https?:\/\/)/;
Vetools._BASE_SITE_URL = "https://5etools-mirror-1.github.io/";
Vetools.BESTIARY_FLUFF_INDEX = null;
Vetools.BESTIARY_TOKEN_LOOKUP = null;
Vetools._CACHED_GET_ROLLABLE_ENTRY_DICE = null;
Vetools._PATCHED_GET_ROLLABLE_ENTRY_DICE = null;
Vetools._CACHED_MONSTER_DO_BIND_COMPACT_CONTENT_HANDLERS = null;
Vetools._CACHED_RENDERER_HOVER_CACHE_AND_GET = null;
Vetools._LOCK_DOWNLOAD_IMAGE = new VeLock();
Vetools._VET_SOURCE_LOOKUP = {};

class UtilChat {
	static init () {
		if (game.user.isGM) this._init_gm();
	}

	static _init_gm () {
		$(document.body)
			.on("click", `[data-plut-chat-cancel]`, async evt => {
				await UtilChat.pDeleteMessage({ele: evt.currentTarget});
			});
	}

	
	static async pDeleteMessage ({ele}) {
		const msgId = $(ele)
			.closest(`[data-message-id]`)
			.attr("data-message-id");
		if (!msgId) return;

		const msg = CONFIG.ChatMessage.collection.instance.get(msgId);
		if (msg) await msg.delete();
	}

	static pSendGmOnlyMessage ({content}) {
		return ChatMessage.create({
			sound: "sounds/notify.wav",
			content: `<div class="secret-gm__block">${content}</div>
				<div class="secret-player__flex ve-muted italic help--hover ve-flex-vh-center" title="(GM-Only Message)">???</div>`,
			user: game.userId,
			type: CONST.CHAT_MESSAGE_TYPES.WHISPER,
			whisper: game.users.contents.filter(it => it.isGM).map(it => it.id),
		}).then(null);
	}

	
	static async pDeleteAllAuthoredMessagesByContentMatch ({str}) {
		await game.messages.contents
			.filter(msg => msg.isAuthor && msg.content.includes(str))
			.pSerialAwaitMap(msg => {
				try {
					msg.delete();
				} catch (e) {
									}
			});
	}
}

class ChatNotificationHandlerBase {
	_isPostOnLoad = false;
	_isCleanupOnLoad = false;

	_getAttribBtnAccept () {
		return `data-${
						this.constructor.name
				.split(/([A-Z])/g)
				.filter(Boolean)
				.reduce((accum, cur, i) => {
					if (i % 2 === 0) accum.push(cur);
					else accum.last(accum.last() + cur);
					return accum;
				}, [])
				.map(it => it.toLowerCase())
				.join("-")}`;
	}

	
	getName () { return this.constructor.name.replace("ChatNotificationHandler", ""); }

	
	async pInit () {
		if (await this._pIsEnabled()) {
			if (this._isCleanupOnLoad) await this._pDoMessageCleanup();
			return this._pOnEnabled();
		}
		return this._pDoMessageCleanup();
	}

	
		async _pIsEnabled () { throw new Error("Unimplemented!"); }

	
	async _pOnEnabled () {
		this._registerHandler("click", `[${this._getAttribBtnAccept()}]`, this._pHandleClickAccept.bind(this));

		await this._pOnEnabled_registerAdditionalHandlers();

				if (Config.get("ui", "isStreamerMode")) return;

		if (this._isPostOnLoad) await this.pDoPostChatMessage();
	}

	_pOnEnabled_registerAdditionalHandlers () {  }

		pDoPostChatMessage () { throw new Error("Unimplemented!"); }

	
	async _pDoMessageCleanup () {
		return UtilChat.pDeleteAllAuthoredMessagesByContentMatch({str: `${this._getAttribBtnAccept()}="true"`});
	}

	
	_HANDLERS = {};

	_registerHandler (type, selector, fn) {
		$(document.body).on(type, selector, fn);
		if (MiscUtil.get(this._HANDLERS, type, selector)) throw new Error(`Handler for "${type}" "${selector}" is already registered!`);
		MiscUtil.set(this._HANDLERS, type, selector, fn);
	}

	_deregisterHandlers () {
		Object.entries(this._HANDLERS)
			.forEach(([type, selectorToFn]) => {
				Object.entries(selectorToFn)
					.forEach(([selector, fn]) => {
						$(document.body).off(type, selector, fn);
					});
			});
	}

	
	_getHtmlBtnAccept ({inner}) {
		return `<button ${this._getAttribBtnAccept()}="true">${inner}</button>`;
	}

	async _pHandleClickAccept () {
		this._deregisterHandlers();
		await this._pHandleClickAccept_();
		await this._pDoMessageCleanup();
	}

		_pHandleClickAccept_ () { throw new Error("Unimplemented!"); }
}

class ChatNotificationHandlerStartupWeDontTalk extends ChatNotificationHandlerBase {
	static _STORAGE_KEY_WDT = "we_dont_talk";
	static _NOTIFICATION_ACCEPT_WDT = [
		"Thanks!",
		"You're alright!",
		"Seeya!",
		"We'll be watching!",
		"You're on the list!",
		"Stay safe!",
		"Stay noided!",
		"Trust nobody. Not even yourself!",
		"We'll remember this!",
		"It's only forever!",
		"Contract signed!",
		"Stick to it!",
		"Call your lawyer!",
		"Over and out!",
		"We'll hire the Pinkertons!", 	];

	_isPostOnLoad = true;

	async _pIsEnabled () {
		return !(await StorageUtil.pGet(this.constructor._STORAGE_KEY_WDT));
	}

	_pOnEnabled_registerAdditionalHandlers () {
		const pHandleStreamerMode = evt => Config.pHandleButtonClick(evt, "ui");

		this._registerHandler("click", `[data-plut-wdt-streamer]`, pHandleStreamerMode);
	}

	pDoPostChatMessage () {
		return ChatMessage.create({
			content: `<div>
				<p>Welcome to Plutonium!</p>
				<p>We would like to remind you that neither Foundry nor Forge support piracy in any shape or form, and that <b>all</b> discussion related to the use of Plutonium should be done in our <a target="_blank" href="https://discord.gg/nGvRCDs" rel="noopener noreferrer">Discord</a>.</p>
				<p>Additionally, if you wish to screenshot or stream your game, we recommend <span data-plut-wdt-streamer="true" class="render-roller">Streamer Mode</span>.</p>
				<div>${this._getHtmlBtnAccept({inner: "I Understand"})}</div>
			</div>`,
			user: game.userId,
			type: CONST.CHAT_MESSAGE_TYPES.WHISPER,
			whisper: [game.userId],
		});
	}

	async _pHandleClickAccept_ () {
		await StorageUtil.pSet(this.constructor._STORAGE_KEY_WDT, true);
		ui.notifications.info(RollerUtil.rollOnArray(this.constructor._NOTIFICATION_ACCEPT_WDT));
	}
}

class ChatNotificationHandlerStartupAutomation extends ChatNotificationHandlerBase {
	_isPostOnLoad = true;

	async _pIsEnabled () {
		return game.user.isGM
						&& UtilCompat.isMidiQolActive()
			&& !UtilCompat.isPlutoniumAddonAutomationActive()
			&& !Config.get("misc", "isSkipAddonAutomationCheck");
	}

	_pOnEnabled_registerAdditionalHandlers () {
		const pHandleCopyLink = async (evt) => {
			evt.stopPropagation();
			evt.preventDefault();

			await MiscUtil.pCopyTextToClipboard(`https://github.com/TheGiddyLimit/plutonium-addon-automation/releases/latest/download/module.json`);
			JqueryUtil.showCopiedEffect(evt.currentTarget, "Copied Manifest URL!");
		};

		this._registerHandler("click", `[data-plut-paa-copy-link]`, pHandleCopyLink);
	}

	pDoPostChatMessage () {
		return ChatMessage.create({
			content: `<div>
				<p>It looks like you're running <b>${UtilCompat.getName(UtilCompat.MODULE_MIDI_QOL)}</b>.</p>
				<p>You might want to install Plutonium's <a rel="noopener noreferrer" href="https://github.com/TheGiddyLimit/plutonium-addon-automation">Automation Addon companion module</a> <i title="Copy Link" data-plut-paa-copy-link="true" class="fa fa-fw fa-link mr-0"></i>, which improves compatibility with common automation modules.</p>
				<div>${this._getHtmlBtnAccept({inner: "Dismiss"})}</div>
			</div>`,
			user: game.userId,
			type: CONST.CHAT_MESSAGE_TYPES.WHISPER,
			whisper: [game.userId],
		});
	}

	async _pHandleClickAccept_ () {
		await Config.set("misc", "isSkipAddonAutomationCheck", true);
	}
}

class ChatNotificationHandlerReloadFonts extends ChatNotificationHandlerBase {
	_isCleanupOnLoad = true;

	async _pIsEnabled () {
		return game.user.isGM;
	}

	pDoPostChatMessage () {
		return ChatMessage.create({
			content: `<div>
				<p>One or more fonts has been added, which requires a reload of the application to take effect. Would you like to reload now?</p>
				<div>${this._getHtmlBtnAccept({inner: "Reload"})}</div>
			</div>`,
			user: game.userId,
			type: CONST.CHAT_MESSAGE_TYPES.WHISPER,
			whisper: [game.userId],
		});
	}

	async _pHandleClickAccept_ () {
		game.socket.emit("reload");
		foundry.utils.debouncedReload();
	}
}

class ChatNotificationHandlers {
	static _HANDLERS = {};

	static _CLAZZES_HANDLER = [
		ChatNotificationHandlerStartupWeDontTalk,
		ChatNotificationHandlerStartupAutomation,
		ChatNotificationHandlerReloadFonts,
	];

	static async pInit () {
		await Promise.all(
			this._CLAZZES_HANDLER.map(Clazz => {
				const instance = new Clazz();
				this._HANDLERS[instance.getName()] = instance;
				return instance.pInit();
			}),
		);
	}

	static getHandler (name) { return this._HANDLERS[name]; }
}

class CustomizerStateBase {
	rename = null;

	setRename (val) { this.rename = val; return this; }

	
	toJson () {
		if (Object.values(this).every(it => it == null)) return null;

		const out = {};

		Object.entries(this)
			.forEach(([k, v]) => {
				if (v == null) return;
				out[k] = MiscUtil.copyFast(v);
			});

		return out;
	}

	static fromJson (json) {
		const out = new this();
		Object.entries(json)
			.filter(([k]) => out.hasOwnProperty(k))
			.forEach(([k, v]) => out[k] = v);
		return out;
	}

	
	static getRename (ent) {
		return ent?._fvttCustomizerState?.rename?.rename;
	}
}

class UtilEntity {
	static getName (ent) {
		if (ent._fvttCustomizerState) {
			const rename = CustomizerStateBase.fromJson(ent._fvttCustomizerState)?.rename?.rename;
			if (rename) return rename;
		}

		return ent._displayName || ent.name || "";
	}
}

class UtilDataConverter {
	static getNameWithSourcePart (ent, {displayName = null, isActorItem = false} = {}) {
		return `${displayName || `${ent.type === "variant" ? "Variant: " : ""}${Renderer.stripTags(UtilEntity.getName(ent))}`}${!isActorItem && ent.source && Config.get("import", "isAddSourceToName") ? ` (${Parser.sourceJsonToAbv(ent.source)})` : ""}`;
	}

	static getSourceWithPagePart (ent) {
		return `${Parser.sourceJsonToAbv(ent.source)}${Config.get("import", "isAddPageNumberToSource") && ent.page ? `${UtilDataConverter.SOURCE_PAGE_PREFIX}${ent.page}` : ""}`;
	}

	static async pGetItemWeaponType (uid) {
		uid = uid.toLowerCase().trim();

		if (UtilDataConverter.WEAPONS_MARTIAL.includes(uid)) return "martial";
		if (UtilDataConverter.WEAPONS_SIMPLE.includes(uid)) return "simple";

		let [name, source] = Renderer.splitTagByPipe(uid);
		source = source || "phb";
		const hash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS]({name, source});

				const found = await DataLoader.pCacheAndGet(UrlUtil.PG_ITEMS, source, hash);
		return found?.weaponCategory;
	}

	static async _pGetClassSubclass_pInitCache ({cache}) {
		cache = cache || {};
		if (!cache._allClasses && !cache._allSubclasses) {
			const classData = await DataUtil.class.loadJSON();
			const prerelease = await PrereleaseUtil.pGetBrewProcessed();
			const brew = await BrewUtil2.pGetBrewProcessed();

			cache._allClasses = [
				...(classData.class || []),
				...(prerelease?.class || []),
				...(brew?.class || []),
			];

			cache._allSubclasses = [
				...(classData.subclass || []),
				...(prerelease?.subclass || []),
				...(brew?.subclass || []),
			];
		}
		return cache;
	}

	static async pGetClassItemClassAndSubclass ({sheetItem, subclassSheetItems, cache = null} = {}) {
		cache = await this._pGetClassSubclass_pInitCache({cache});

		const nameLowerClean = sheetItem.name.toLowerCase().trim();
		const sourceLowerClean = (UtilDataConverter.getItemSource(sheetItem).source || "").toLowerCase();

		const matchingClasses = cache._allClasses.filter(cls =>
			cls.name.toLowerCase() === nameLowerClean
				&& (
					!Config.get("import", "isStrictMatching")
					|| sourceLowerClean === Parser.sourceJsonToAbv(cls.source).toLowerCase()
				),
		);
		if (!matchingClasses.length) return {matchingClasses: [], matchingSubclasses: [], sheetItem};

		if (!subclassSheetItems?.length) return {matchingClasses, matchingSubclasses: [], sheetItem};

		const matchingSubclasses = matchingClasses
			.map(cls => {
				const classSubclassSheetItems = subclassSheetItems.filter(scItem => scItem.system.classIdentifier === sheetItem.system.identifier);
				return cache._allSubclasses.filter(sc => {
					if (sc.className !== cls.name || sc.classSource !== cls.source) return false;

					return classSubclassSheetItems.some(scItem =>
						sc.name.toLowerCase() === scItem.name.toLowerCase().trim()
						&& (
							!Config.get("import", "isStrictMatching")
							|| (UtilDataConverter.getItemSource(scItem).source || "").toLowerCase() === Parser.sourceJsonToAbv(sc.source).toLowerCase()
						),
					);
				});
			})
			.flat();

		return {matchingClasses, matchingSubclasses, sheetItem};
	}

	static getItemSource (itm) {
		if (itm.flags?.[SharedConsts.MODULE_ID]?.source) {
			return {
				source: itm.flags?.[SharedConsts.MODULE_ID]?.source,
				isExact: true,
			};
		}

		let sys = itm.system || {};
		let rawSource = sys.source;

								if (rawSource instanceof Array) rawSource = rawSource[0];
		
		if (!rawSource) return {source: null};

		const source = rawSource.split(UtilDataConverter._SOURCE_PAGE_PREFIX_RE)[0].trim();
		return {
			source,
			isExact: false,
		};
	}

	static getSpellPointTotal ({totalSpellcastingLevels}) {
		if (!totalSpellcastingLevels) return 0;

		const spellSlotCounts = UtilDataConverter.CASTER_TYPE_TO_PROGRESSION.full[totalSpellcastingLevels - 1]
			|| UtilDataConverter.CASTER_TYPE_TO_PROGRESSION.full[0];

		return spellSlotCounts
			.map((countSlots, ix) => {
				const spellLevel = ix + 1;
				return Parser.spLevelToSpellPoints(spellLevel) * countSlots;
			})
			.sum();
	}

	static getPsiPointTotal ({totalMysticLevels}) {
		if (!totalMysticLevels || isNaN(totalMysticLevels) || totalMysticLevels < 0) return 0;

		totalMysticLevels = Math.round(Math.min(totalMysticLevels, Consts.CHAR_MAX_LEVEL));

		return [4, 6, 14, 17, 27, 32, 38, 44, 57, 64, 64, 64, 64, 64, 64, 64, 64, 71, 71, 71][totalMysticLevels - 1];
	}

		static async pGetWithDescriptionPlugins (pFn, {actorId = null, tagHashItemIdMap = null} = {}) {
		const hkLink = (entry, procHash) => this._pGetWithDescriptionPlugins_fnPlugin(entry, procHash);

		const hkStr = (tag, text) => {
			const inn = `{${tag} ${text}}`;
			const itemId = this._pGetWithDescriptionPlugins_getTagItemId({tag, text, tagHashItemIdMap});
			const out = this._getConvertedTagLinkString(inn, {actorId, itemId});
			if (inn === out) return null; 			return out;
		};

		const hkStrFont = (tag, text) => {
			if (!game.user.isGM) return;

			const [, fontFamily] = Renderer.splitTagByPipe(text);

			if (UtilDataConverter._DESCRIPTION_FONTS_TRACKED[fontFamily]) return;
			UtilDataConverter._DESCRIPTION_FONTS_TRACKED[fontFamily] = true;

			if (FontConfig.getAvailableFontChoices()[fontFamily]) return;

			if (!Config.get("import", "isAutoAddAdditionalFonts")) {
				ui.notifications.warn(`The "${fontFamily}" font, used by recently-rendered content, is not available in your game. You may need to manually add it via the "Additional Fonts" setting, or text using the "${fontFamily}" font may not display correctly.`);
			}

			const url = BrewUtil2.getMetaLookup("fonts")?.[fontFamily] || PrereleaseUtil.getMetaLookup("fonts")?.[fontFamily];

			if (!url) return void ui.notifications.warn(`Failed to load font "${fontFamily}". You may need to manually add it via the "Additional Fonts" setting, or text using the "${fontFamily}" font may not display correctly.`);

			this._pDoLoadAdditionalFont(fontFamily, url).then(null);
		};

		const hkImg = (entry, url) => {
			const out = Vetools.getImageSavedToServerUrl({originalUrl: url});
																																										Vetools.pSaveImageToServerAndGetUrl({originalUrl: url, force: true}).then(null).catch(() => {});
			return out;
		};

		Renderer.get().addPlugin("link_attributesHover", hkLink);
		Renderer.get().addPlugin("string_@font", hkStrFont);
		if (Config.get("import", "isRenderLinksAsTags")) Renderer.get().addPlugin("string_tag", hkStr);
		if (Config.get("import", "isSaveImagesToServer")) {
			Renderer.get().addPlugin("image_urlPostProcess", hkImg);
			Renderer.get().addPlugin("image_urlThumbnailPostProcess", hkImg);
		}

		let out;
		try {
			out = await pFn();
		} finally {
			Renderer.get().removePlugin("link_attributesHover", hkLink);
			Renderer.get().removePlugin("string_@font", hkStrFont);
			Renderer.get().removePlugin("string_tag", hkStr);
			Renderer.get().removePlugin("image_urlPostProcess", hkImg);
			Renderer.get().removePlugin("image_urlThumbnailPostProcess", hkImg);
		}

		return out;
	}

	static _DESCRIPTION_FONTS_TRACKED = {};
	static _HAS_NOTIFIED_FONTS_RELOAD = false;

	static async _pDoLoadAdditionalFont (family, url) {
		const hasNotified = this._HAS_NOTIFIED_FONTS_RELOAD;
		this._HAS_NOTIFIED_FONTS_RELOAD = true;

				const definitions = game.settings.get("core", FontConfig.SETTING);
		definitions[family] ??= {editor: true, fonts: []};
		const definition = definitions[family];
		definition.fonts.push({urls: [url], weight: 400, style: "normal"});
		await game.settings.set("core", FontConfig.SETTING, definitions);
		await FontConfig.loadFont(family, definition);
		
		if (hasNotified) return;

		ChatNotificationHandlers.getHandler("ReloadFonts").pDoPostChatMessage();
	}

		static _pGetWithDescriptionPlugins_getTagItemId ({tag, text, tagHashItemIdMap}) {
		const tagName = tag.slice(1); 		if (!tagHashItemIdMap?.[tagName]) return null;
		const defaultSource = Renderer.tag.TAG_LOOKUP[tagName]?.defaultSource;
		if (!defaultSource) return null;
		const page = Renderer.tag.getPage(tagName);
		if (!page) return null;
		const hashBuilder = UrlUtil.URL_TO_HASH_BUILDER[page];
		if (!hashBuilder) return null;
		let [name, source] = text.split("|");
		source = source || defaultSource;
		const hash = hashBuilder({name, source});
		return tagHashItemIdMap?.[tagName]?.[hash];
	}

	static _pGetWithDescriptionPlugins_fnPlugin (entry, procHash) {
		const page = entry.href.hover.page;
		const source = entry.href.hover.source;
		const hash = procHash;
		const preloadId = entry.href.hover.preloadId;
		return {
			attributesHoverReplace: [
				`data-plut-hover="${true}" data-plut-hover-page="${page.qq()}" data-plut-hover-source="${source.qq()}" data-plut-hover-hash="${hash.qq()}" ${preloadId ? `data-plut-hover-preload-id="${preloadId.qq()}"` : ""}`,
			],
		};
	}

		static _getConvertedTagLinkString (str, {actorId, itemId} = {}) {
		this._getConvertedTagLinkString_initLinkTagMetas();
		for (const {tag, re} of this._LINK_TAG_METAS_REPLACE) str = str.replace(re, (...m) => this._replaceEntityLinks_getReplacement({tag, text: m.last().text, actorId, itemId}));
		for (const {tag, re} of this._LINK_TAG_METAS_REMOVE) str = str.replace(re, (...m) => this._replaceEntityLinks_getRemoved({tag, text: m.last().text}));
		return str;
	}

	static _LINK_TAGS_TO_REMOVE = new Set([
		"quickref", 	]);
	static _LINK_TAG_METAS_REPLACE = null;
	static _LINK_TAG_METAS_REMOVE = null;

	static _getConvertedTagLinkString_initLinkTagMetas () {
		if (!this._LINK_TAG_METAS_REPLACE) {
			this._LINK_TAG_METAS_REPLACE = Renderer.tag.TAGS.filter(it => it.defaultSource)
				.map(it => it.tagName)
				.filter(tag => !this._LINK_TAGS_TO_REMOVE.has(tag))
				.map(tag => ({tag, re: this._getConvertedTagLinkString_getRegex({tag})}));
		}

		if (!this._LINK_TAG_METAS_REMOVE) {
			this._LINK_TAG_METAS_REMOVE = Renderer.tag.TAGS.filter(it => it.defaultSource)
				.map(it => it.tagName)
				.filter(tag => this._LINK_TAGS_TO_REMOVE.has(tag))
				.map(tag => ({tag, re: this._getConvertedTagLinkString_getRegex({tag})}));
		}
	}

	static _getConvertedTagLinkString_getRegex ({tag}) { return RegExp(`^{@${tag} (?<text>[^}]+)}$`, "g"); }

	static getConvertedTagLinkEntries (entries) {
		if (!entries) return entries;

		return UtilDataConverter.WALKER_GENERIC.walk(
			MiscUtil.copy(entries),
			{
				string: str => {
					const textStack = [""];
					this._getConvertedTagLinkEntries_recurse(str, textStack);
					return textStack.join("");
				},
			},
		);
	}

		static _getConvertedTagLinkEntries_recurse (str, textStack) {
		const tagSplit = Renderer.splitByTags(str);
		const len = tagSplit.length;
		for (let i = 0; i < len; ++i) {
			const s = tagSplit[i];
			if (!s) continue;

						if (s.startsWith("{@")) {
				const converted = this._getConvertedTagLinkString(s);

				if (converted !== s) {
					textStack[0] += (converted);
					continue;
				}

				textStack[0] += s.slice(0, 1);
				this._getConvertedTagLinkEntries_recurse(s.slice(1, -1), textStack);
				textStack[0] += s.slice(-1);

				continue;
			}

			textStack[0] += s;
		}
	}

	static _replaceEntityLinks_getReplacement ({tag, text, actorId, itemId}) {
		if (actorId && itemId) {
			const [, , displayText] = text.split("|");
			return `@UUID[Actor.${actorId}.Item.${itemId}]${displayText ? `{${displayText}}` : ""}`;
		}
		return `@${tag}[${text}]`;
	}

	static _replaceEntityLinks_getRemoved ({tag, text}) {
		return Renderer.stripTags(`{@${tag} ${text}}`);
	}

		static async _pReplaceEntityLinks_pReplace ({str, re, tag}) {
		let m;
		while ((m = re.exec(str))) {
			const prefix = str.slice(0, m.index);
			const suffix = str.slice(re.lastIndex);
			const replacement = this._replaceEntityLinks_getReplacement({tag, m});
			str = `${prefix}${replacement}${suffix}`;
			re.lastIndex = prefix.length + replacement.length;
		}
		return str;
	}
	
	
	static _RECHARGE_TYPES = {
		"round": null,
		"restShort": "sr",
		"restLong": "lr",
		"dawn": "day",
		"dusk": "day",
		"midnight": "day",
		"special": null,
	};

	static getFvttUsesPer (it, {isStrict = true} = {}) {
		if (isStrict && !this._RECHARGE_TYPES[it]) return null;
		return Parser._parse_aToB(this._RECHARGE_TYPES, it);
	}

		static getTempDocumentDefaultOwnership ({documentType}) {
		if (game.user.isGM) return undefined;

		const clazz = CONFIG[documentType].documentClass;

		if (game.user.can(clazz.metadata.permissions.create)) return undefined;

		return CONST.DOCUMENT_OWNERSHIP_LEVELS.OWNER;
	}
}
UtilDataConverter.WALKER_READONLY_GENERIC = MiscUtil.getWalker({isNoModification: true, keyBlocklist: MiscUtil.GENERIC_WALKER_ENTRIES_KEY_BLOCKLIST});
UtilDataConverter.WALKER_GENERIC = MiscUtil.getWalker({keyBlocklist: MiscUtil.GENERIC_WALKER_ENTRIES_KEY_BLOCKLIST});
UtilDataConverter.SOURCE_PAGE_PREFIX = " pg. ";
UtilDataConverter._SOURCE_PAGE_PREFIX_RE = new RegExp(`${UtilDataConverter.SOURCE_PAGE_PREFIX}\\d+`);

UtilDataConverter.WEAPONS_MARTIAL = [
	"battleaxe|phb",
	"blowgun|phb",
	"flail|phb",
	"glaive|phb",
	"greataxe|phb",
	"greatsword|phb",
	"halberd|phb",
	"hand crossbow|phb",
	"heavy crossbow|phb",
	"lance|phb",
	"longbow|phb",
	"longsword|phb",
	"maul|phb",
	"morningstar|phb",
	"net|phb",
	"pike|phb",
	"rapier|phb",
	"scimitar|phb",
	"shortsword|phb",
	"trident|phb",
	"war pick|phb",
	"warhammer|phb",
	"whip|phb",
];
UtilDataConverter.WEAPONS_SIMPLE = [
	"club|phb",
	"dagger|phb",
	"dart|phb",
	"greatclub|phb",
	"handaxe|phb",
	"javelin|phb",
	"light crossbow|phb",
	"light hammer|phb",
	"mace|phb",
	"quarterstaff|phb",
	"shortbow|phb",
	"sickle|phb",
	"sling|phb",
	"spear|phb",
];

UtilDataConverter.CASTER_TYPE_TO_PROGRESSION = {
	"full": [
		[2, 0, 0, 0, 0, 0, 0, 0, 0],
		[3, 0, 0, 0, 0, 0, 0, 0, 0],
		[4, 2, 0, 0, 0, 0, 0, 0, 0],
		[4, 3, 0, 0, 0, 0, 0, 0, 0],
		[4, 3, 2, 0, 0, 0, 0, 0, 0],
		[4, 3, 3, 0, 0, 0, 0, 0, 0],
		[4, 3, 3, 1, 0, 0, 0, 0, 0],
		[4, 3, 3, 2, 0, 0, 0, 0, 0],
		[4, 3, 3, 3, 1, 0, 0, 0, 0],
		[4, 3, 3, 3, 2, 0, 0, 0, 0],
		[4, 3, 3, 3, 2, 1, 0, 0, 0],
		[4, 3, 3, 3, 2, 1, 0, 0, 0],
		[4, 3, 3, 3, 2, 1, 1, 0, 0],
		[4, 3, 3, 3, 2, 1, 1, 0, 0],
		[4, 3, 3, 3, 2, 1, 1, 1, 0],
		[4, 3, 3, 3, 2, 1, 1, 1, 0],
		[4, 3, 3, 3, 2, 1, 1, 1, 1],
		[4, 3, 3, 3, 3, 1, 1, 1, 1],
		[4, 3, 3, 3, 3, 2, 1, 1, 1],
		[4, 3, 3, 3, 3, 2, 2, 1, 1],
	],
	"artificer": [
		[2, 0, 0, 0, 0],
		[2, 0, 0, 0, 0],
		[3, 0, 0, 0, 0],
		[3, 0, 0, 0, 0],
		[4, 2, 0, 0, 0],
		[4, 2, 0, 0, 0],
		[4, 3, 0, 0, 0],
		[4, 3, 0, 0, 0],
		[4, 3, 2, 0, 0],
		[4, 3, 2, 0, 0],
		[4, 3, 3, 0, 0],
		[4, 3, 3, 0, 0],
		[4, 3, 3, 1, 0],
		[4, 3, 3, 1, 0],
		[4, 3, 3, 2, 0],
		[4, 3, 3, 2, 0],
		[4, 3, 3, 3, 1],
		[4, 3, 3, 3, 1],
		[4, 3, 3, 3, 2],
		[4, 3, 3, 3, 2],
	],
	"1/2": [
		[0, 0, 0, 0, 0],
		[2, 0, 0, 0, 0],
		[3, 0, 0, 0, 0],
		[3, 0, 0, 0, 0],
		[4, 2, 0, 0, 0],
		[4, 2, 0, 0, 0],
		[4, 3, 0, 0, 0],
		[4, 3, 0, 0, 0],
		[4, 3, 2, 0, 0],
		[4, 3, 2, 0, 0],
		[4, 3, 3, 0, 0],
		[4, 3, 3, 0, 0],
		[4, 3, 3, 1, 0],
		[4, 3, 3, 1, 0],
		[4, 3, 3, 2, 0],
		[4, 3, 3, 2, 0],
		[4, 3, 3, 3, 1],
		[4, 3, 3, 3, 1],
		[4, 3, 3, 3, 2],
		[4, 3, 3, 3, 2],
	],
	"1/3": [
		[0, 0, 0, 0],
		[0, 0, 0, 0],
		[2, 0, 0, 0],
		[3, 0, 0, 0],
		[3, 0, 0, 0],
		[3, 0, 0, 0],
		[4, 2, 0, 0],
		[4, 2, 0, 0],
		[4, 2, 0, 0],
		[4, 3, 0, 0],
		[4, 3, 0, 0],
		[4, 3, 0, 0],
		[4, 3, 2, 0],
		[4, 3, 2, 0],
		[4, 3, 2, 0],
		[4, 3, 3, 0],
		[4, 3, 3, 0],
		[4, 3, 3, 0],
		[4, 3, 3, 1],
		[4, 3, 3, 1],
	],
	"pact": [
		[1, 0, 0, 0, 0],
		[2, 0, 0, 0, 0],
		[0, 2, 0, 0, 0],
		[0, 2, 0, 0, 0],
		[0, 0, 2, 0, 0],
		[0, 0, 2, 0, 0],
		[0, 0, 0, 2, 0],
		[0, 0, 0, 2, 0],
		[0, 0, 0, 0, 2],
		[0, 0, 0, 0, 2],
		[0, 0, 0, 0, 3],
		[0, 0, 0, 0, 3],
		[0, 0, 0, 0, 3],
		[0, 0, 0, 0, 3],
		[0, 0, 0, 0, 3],
		[0, 0, 0, 0, 3],
		[0, 0, 0, 0, 4],
		[0, 0, 0, 0, 4],
		[0, 0, 0, 0, 4],
		[0, 0, 0, 0, 4],
	],
};

class UtilDocuments {
	static async pCreateDocument (Clazz, docData, {isTemporary = false} = {}) {
		docData = foundry.utils.flattenObject(docData);

						const out = await Clazz.create(docData, {renderSheet: false, temporary: isTemporary});

		if (isTemporary) out._isTempImportedDoc = true;

		return out;
	}

	static async pUpdateDocument (doc, docUpdate, {isTemporary = false} = {}, updateDocOpts) {
		docUpdate = foundry.utils.flattenObject(docUpdate);

				if (this.isTempDocument({doc, isTemporary})) {
						if (updateDocOpts?.diff === false || updateDocOpts?.recursive === false) {
								throw new Error(`Non-diff and non-recursive temporary document updates are unsupported!`);
			}

						foundry.utils.mergeObject(doc.system, docUpdate);

						return doc;
		}

		return doc.update(docUpdate, updateDocOpts);
	}

	static isTempDocument ({isTemporary, doc}) {
				return isTemporary
						|| doc?.id == null
						|| doc?._isTempImportedDoc;
	}

	static async pCreateEmbeddedDocuments (doc, embedArray, {isTemporary = false, propData = null, ClsEmbed, embedName = null}, {keepId = true, keepEmbeddedIds = true, ...createEmbeddedDocOpts} = {}) {
		if (!embedArray?.length) return [];

		propData = propData || ClsEmbed.metadata.collection;
		embedName = embedName || ClsEmbed.metadata.name;

		let createdEmbeds;

		if (this.isTempDocument({doc, isTemporary})) {
						embedArray.forEach(embed => {
				this._setTempId(embed);
				(embed.effects || []).forEach(effect => this._setTempId(effect));
			});

			createdEmbeds = await ClsEmbed.create(embedArray.map(it => foundry.utils.flattenObject(it)), {temporary: true, parent: doc});

			createdEmbeds.forEach(createdEmbed => {
								doc[propData].set(createdEmbed.id, createdEmbed);

												(createdEmbed.effects || []).forEach(effect => {
					doc.effects.set(effect.id, effect);
				});
			});
		} else {
			createdEmbeds = await doc.createEmbeddedDocuments(
				embedName,
				embedArray.map(it => foundry.utils.flattenObject(it)),
				{
					keepId,
					keepEmbeddedIds,
					...createEmbeddedDocOpts,
				},
			);
		}

		if (embedArray.length !== createdEmbeds.length) throw new Error(`Number of returned items did not match number of input items!`); 		return embedArray.map((raw, i) => new UtilDocuments.ImportedEmbeddedDocument({raw, document: createdEmbeds[i]}));
	}

	static _setTempId (ent) {
		if (!ent._id && !ent.id) ent._id = foundry.utils.randomID();
		if (ent._id && !ent.id) ent.id = ent._id;
		if (!ent._id && ent.id) ent._id = ent.id;
	}

	static async pUpdateEmbeddedDocuments (doc, updateArray, {isTemporary = false, propData = null, ClsEmbed, embedName = null}, updateEmbeddedDocOpts = {}) {
		if (!updateArray?.length) return [];

		propData = propData || ClsEmbed.metadata.collection;
		embedName = embedName || ClsEmbed.metadata.name;

		let updatedEmbeds;

		if (this.isTempDocument({doc, isTemporary})) {
			const updateTuples = updateArray.map(update => {
				if (!update._id) throw new Error(`Update had no "_id"!`);
				const embed = doc[propData].get(update._id);
				if (!embed) throw new Error(`${embedName} with id "${update._id}" not found in parent document!`);
				return {update, embed};
			});

			updateTuples.forEach(({update, embed}) => {
								foundry.utils.mergeObject(embed.system, MiscUtil.copy(update));

								Object.keys(embed.system._source)
					.filter(k => update[k])
					.forEach(k => foundry.utils.mergeObject(embed.system._source[k], MiscUtil.copy(update[k])));
			});

			updatedEmbeds = updateTuples.map(it => it.embed);
		} else {
			const updatedEmbedsRaw = await doc.updateEmbeddedDocuments(embedName, updateArray.map(it => foundry.utils.flattenObject(it)), {...updateEmbeddedDocOpts});
			if (updateArray.length === updatedEmbedsRaw.length) {
				updatedEmbeds = updatedEmbedsRaw;
			} else {
								updatedEmbeds = updateArray.map(({_id}) => updateArray.find(it => it.id === _id) || doc[propData].get(_id));
			}
		}

		if (updateArray.length !== updatedEmbeds.length) throw new Error(`Number of returned items did not match number of input items!`); 		return updateArray.map((raw, i) => new UtilDocuments.ImportedEmbeddedDocument({raw, document: updatedEmbeds[i], isUpdate: true}));
	}

	static async pDeleteEmbeddedDocuments (doc, deleteArray, {isTemporary = false, propData = null, ClsEmbed, embedName = null}, deleteEmbeddedDocOpts = {}) {
		if (!deleteArray?.length) return [];

		propData = propData || ClsEmbed.metadata.collection;
		embedName = embedName || ClsEmbed.metadata.name;

		if (this.isTempDocument({doc, isTemporary})) {
			throw new Error(`Deleting embedded documents from a temporary document is not supported! This is a bug!`);
		} else {
			await doc.deleteEmbeddedDocuments(embedName, deleteArray, {...deleteEmbeddedDocOpts});
		}

			}

		static getEvaluatedExpression (doc, expression, rollData) {
		if (!`${expression || ""}`.trim()) return 0;

		expression = `${expression}`;

		const expressionMerged = expression
			.replace(/@(?<path>[-a-zA-Z0-9.]+)/g, (...m) => {
				const out = foundry.utils.getProperty(rollData, m.last().path);
				if (out === undefined) {
					console.warn(...LGT, `Failed to resolve attribute "${m.last().path}" in expression "${expression}" for ${doc.documentName} "${doc.name}" (${doc.id})`);
					return 0;
				}
				return out;
			})
						.replace(/\btrue\b/g, 1)
			.replace(/\bfalse\b/g, 0)
			.replace(/\bnull\b/g, 0)
		;
		let wrpTree;
		try {
			wrpTree = Renderer.dice.lang.getTree3(expressionMerged, false);
		} catch (e) {
			console.warn(...LGT, `Failed to parse expression "${expression}" ("${expressionMerged}" with roll data applied) in ${doc.documentName} (${doc.name}) ${doc.id} active effects`, e.message);
			return 0;
		}

		return wrpTree.tree.evl({});
	}
}

UtilDocuments.ImportedEmbeddedDocument = class {
	constructor ({raw, document, isUpdate = false}) {
		this.raw = raw;
		this.document = document;
		this.isUpdate = isUpdate;
	}
};

class ActiveEffectMeta {
	constructor (path, mode, defaultVal) {
		this.path = path;
		this.mode = mode;
		this.default = defaultVal;
	}

	get dataType () { return typeof this.default; }
}

class UtilActiveEffects {
	static _PATHS_EXTRA__AC = [
		"system.attributes.ac.base", 		"system.attributes.ac.armor",
		"system.attributes.ac.dex",
		"system.attributes.ac.shield",
		"system.attributes.ac.bonus",
		"system.attributes.ac.cover",
	];

	static init () {
		UtilActiveEffects._AVAIL_EFFECTS_ACTOR_DND5E.push(
			new ActiveEffectMeta("system.attributes.prof", CONST.ACTIVE_EFFECT_MODES.OVERRIDE, 1),

			new ActiveEffectMeta("system.resources.primary.label", CONST.ACTIVE_EFFECT_MODES.OVERRIDE, ""),
			new ActiveEffectMeta("system.resources.secondary.label", CONST.ACTIVE_EFFECT_MODES.OVERRIDE, ""),
			new ActiveEffectMeta("system.resources.tertiary.label", CONST.ACTIVE_EFFECT_MODES.OVERRIDE, ""),

			...Object.entries((CONFIG?.DND5E?.characterFlags) || {})
				.map(([k, meta]) => new ActiveEffectMeta(
					`flags.dnd5e.${k}`,
					CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
					meta.placeholder != null ? MiscUtil.copy(meta.placeholder) : meta.type()),
				),

									...Object.keys((CONFIG?.DND5E?.itemActionTypes) || {})
				.map(k => [
					new ActiveEffectMeta(
						`system.bonuses.${k}.attack`,
						CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
						"",
					),
					new ActiveEffectMeta(
						`system.bonuses.${k}.damage`,
						CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
						"",
					),
				])
				.flat(),
			
												...this._PATHS_EXTRA__AC.map(path => new ActiveEffectMeta(
				path,
				CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
				"",
			)),
					);
	}

		static getAvailableEffects (entity, opts) {
		opts = opts || {};

		let modelMeta;
		if (opts.isItemEffect) modelMeta = game.system.model.Item;
		else if (opts.isActorEffect) modelMeta = game.system.model.Actor;
		else throw new Error(`Unhandled effect mode, was neither an item effect nor an actor effect!`);

		const model = modelMeta[entity.type];

		const baseEffects = Object.entries(foundry.utils.flattenObject(model))
						.map(([keyPath, defaultVal]) => new ActiveEffectMeta(`system.${keyPath}`, CONST.ACTIVE_EFFECT_MODES.OVERRIDE, defaultVal));

		if (opts.isItemEffect) return baseEffects;
		return [...baseEffects, ...UtilActiveEffects._AVAIL_EFFECTS_ACTOR_DND5E]
			.unique(it => it.path)
			.sort(SortUtil.ascSortLowerProp.bind(null, "path"));
	}

		static getAvailableEffectsLookup (entity, opts) {
		const effects = this.getAvailableEffects(entity, opts);
		const out = {};
		effects.forEach(it => out[it.path] = it);
		return out;
	}

	static getActiveEffectType (lookup, path) {
		if (!path) return undefined;

				path = this.getKeyFromCustomKey(path);

		if (!lookup[path]) return undefined;
		const meta = lookup[path];
		if (meta.default === undefined) return "undefined";
		if (meta.default === null) return "null";
		if (meta.default instanceof Array) return "array";
		return typeof meta.default;
	}

	static getExpandedEffects (
		rawEffects,
		{actor = null, sheetItem = null, parentName = "", img = null} = {},
		{isTuples = false} = {},
	) {
		if (!rawEffects || !rawEffects.length) return [];

		const tuples = [];

				for (const effectRaw of rawEffects) {
									const cpyEffectRaw = MiscUtil.copy(effectRaw);
			["name", "priority", "icon", "disabled", "changes"].forEach(prop => delete cpyEffectRaw[prop]);

			const effect = UtilActiveEffects.getGenericEffect({
				name: effectRaw.name ?? parentName,
				priority: effectRaw?.changes?.length
					? Math.max(...effectRaw.changes.map(it => UtilActiveEffects.getPriority(UtilActiveEffects.getFoundryMode({mode: it.mode}))))
					: 0,
				icon: effectRaw.img ?? img ?? sheetItem?.img ?? actor?.system?.img ?? actor?.system?.prototypeToken?.texture?.src,
				disabled: !!effectRaw.disabled,
				transfer: !!effectRaw.transfer,
			});

			if (actor && sheetItem) effect.origin = `Actor.${actor.id}.Item.${sheetItem.id}`;

			effect.changes = effect.changes || [];
			(effectRaw.changes || []).forEach(rawChange => {
				const mode = UtilActiveEffects.getFoundryMode(rawChange.mode);

												const key = rawChange.key.replace(/^data\./, "system.");

				effect.changes.push({
					key,
					mode,
					value: rawChange.value,
					priority: UtilActiveEffects.getPriority({mode, rawPriority: rawChange.priority}),
				});
			});

						Object.entries(cpyEffectRaw)
				.forEach(([k, v]) => {
					effect[k] = v;
				});

			tuples.push({effect, effectRaw});
		}

		return isTuples ? tuples : tuples.map(it => it.effect);
	}

	static getGenericEffect (
		{
			name = "",
			icon = "icons/svg/aura.svg",
			disabled = false,
			transfer = true,

			key = "",
			value = "",
			mode = CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
			priority = null,

			durationSeconds = null,
			durationRounds = null,
			durationTurns = null,

			changes = null,

			originActor = null,
			originActorItem = null,
			originActorId = null,
			originActorItemId = null,

			flags = null,
		} = {},
	) {
		if (changes && (key || value)) throw new Error(`Generic effect args "key"/"value" and "changes" are mutually exclusive!`);

		const change = key || value ? this.getGenericChange({key, value, mode, priority}) : null;

		flags = flags || {};

		return {
			name,
			icon,
			changes: changes ?? [change].filter(Boolean),
			disabled,
			duration: {
				startTime: null,
				seconds: durationSeconds,
				rounds: durationRounds,
				turns: durationTurns,
				startRound: null,
				startTurn: null,
			},
												origin: this._getGenericEffect_getOrigin({
				originActor,
				originActorItem,
				originActorId,
				originActorItemId,
			}),
			tint: "",
			transfer,
			flags,
		};
	}

	static _getGenericEffect_getOrigin ({originActor, originActorItem, originActorId, originActorItemId}) {
		originActorId = originActorId ?? originActor?.id;
		originActorItemId = originActorItemId ?? originActorItem?.id;

		return originActorId
			? originActorItemId
				? `Actor.${originActorId}.Item.${originActorItemId}`
				: `Actor.${originActorId}`
			: null;
	}

	static getGenericChange (
		{
			key,
			value,
			mode = CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
			priority = null,
		},
	) {
		if (key == null || value === undefined) throw new Error(`Generic effect change "key" and "value" must be defined!`);
		return {
			key,
			mode,
			value,
			priority,
		};
	}

	static getCustomKey (key) { return `${SharedConsts.MODULE_ID_FAKE}.${key}`; }
	static getKeyFromCustomKey (customKey) { return customKey.replace(new RegExp(`${SharedConsts.MODULE_ID_FAKE}\\.`), ""); }

	static getFoundryMode (modeStrOrInt) {
		if (typeof modeStrOrInt === "number") return modeStrOrInt;
		const [, out = 0] = Object.entries(CONST.ACTIVE_EFFECT_MODES)
			.find(([k]) => k.toLowerCase() === `${modeStrOrInt}`.trim().toLowerCase()) || [];
		return out;
	}

	static getPriority ({mode, rawPriority = null}) {
		if (rawPriority != null && !isNaN(rawPriority)) return rawPriority;
		return mode >= CONST.ACTIVE_EFFECT_MODES.DOWNGRADE ? UtilActiveEffects.PRIORITY_BASE : UtilActiveEffects.PRIORITY_BONUS;
	}

	static _HINTS_DEFAULT_SIDE = {hintTransfer: false, hintDisabled: false};
	static getDisabledTransferHintsSideData (effectRaw) {
		const out = MiscUtil.copy(this._HINTS_DEFAULT_SIDE);
		if (effectRaw?.transfer != null) out.hintTransfer = effectRaw.transfer;
		if (effectRaw?.disabled != null) out.hintDisabled = effectRaw.disabled;
		return out;
	}
}
UtilActiveEffects._AVAIL_EFFECTS_ACTOR_DND5E = [];

UtilActiveEffects.PRIORITY_BASE = 4;
UtilActiveEffects.PRIORITY_BONUS = 7;

class UtilActors {
	static init () {
		UtilActors.VALID_DAMAGE_TYPES = Object.keys(MiscUtil.get(CONFIG, "DND5E", "damageTypes") || {});
		UtilActors.VALID_CONDITIONS = Object.keys(MiscUtil.get(CONFIG, "DND5E", "conditionTypes") || {});
	}

		static async pGetActorSpellItemOpts ({actor, isAllowAutoDetectPreparationMode = false} = {}) {
		const opts = {
			isActorItem: true,
			isActorItemNpc: actor?.type === "npc",
			isPrepared: !!Config.get("importSpell", "prepareActorSpells"),
			preparationMode: Config.get("importSpell", "actorSpellPreparationMode"),
		};

				if (!actor || this.isImporterTempActor(actor)) return opts;

		const spellcastingAbility = MiscUtil.get(actor, "system", "attributes", "spellcasting");
		if (spellcastingAbility) opts.ability = spellcastingAbility.value;

		if (actor && isAllowAutoDetectPreparationMode) {
			const autoPreparationMode = await this._pGetActorSpellItemOpts_getAutoPreparationMode({actor});
			if (autoPreparationMode != null) opts.preparationMode = autoPreparationMode;
		}

		return opts;
	}

	static isImporterTempActor (actor) { return !!MiscUtil.get(actor, "flags", SharedConsts.MODULE_ID, "isImporterTempActor"); }

	static async _pGetActorSpellItemOpts_getAutoPreparationMode ({actor}) {
		if (!Config.get("importSpell", "isAutoDetectActorSpellPreparationMode")) return null;

		const classItems = actor.items.filter(it => it.type === "class" && it.system?.spellcasting?.progression !== "none");
		if (!classItems.length || classItems.length > 1) return null;

		const sheetItem = classItems[0];

		const spellProgression = sheetItem.system.spellcasting.progression;
		switch (spellProgression) {
			case "full":
			case "half":
			case "third":
			case "artificer": {
				const classSubclassMeta = await UtilDataConverter.pGetClassItemClassAndSubclass({sheetItem, subclassSheetItems: actor.items.filter(it => it.type === "subclass")});
				if (classSubclassMeta.matchingClasses.length !== 1) return null;
				return (classSubclassMeta.matchingClasses[0].preparedSpells || classSubclassMeta.matchingClasses[0].preparedSpellsProgression) ? "prepared" : "always";
			}
			case "pact": return "pact";
			default: return null;
		}
	}

	static getSpellItemItemOpts () {
		const opts = {};

		opts.isPrepared = !!Config.get("importSpell", "prepareSpellItems");
		opts.preparationMode = Config.get("importSpell", "spellItemPreparationMode");

		return opts;
	}

	static async pAddActorItems (actor, itemArray, {isTemporary = false} = {}, createEmbeddedDocOpts) {
		if (!itemArray?.length) return [];
		return UtilDocuments.pCreateEmbeddedDocuments(
			actor,
			itemArray,
			{
				isTemporary,
				propData: "items",
				ClsEmbed: Item,
			},
			createEmbeddedDocOpts,
		);
	}

	static async pAddActorEffects (actor, effectArray, {isTemporary = false} = {}, createEmbeddedDocOpts) {
		if (!effectArray?.length) return [];
		return UtilDocuments.pCreateEmbeddedDocuments(
			actor,
			effectArray,
			{
				isTemporary,
				propData: "effects",
				ClsEmbed: ActiveEffect,
			},
			createEmbeddedDocOpts,
		);
	}

	static getMappedTool (str) {
		str = str.toLowerCase().trim();
		if (this.VALID_TOOL_PROFICIENCIES[str]) return this.VALID_TOOL_PROFICIENCIES[str];
		str = str.split("|")[0];
		return this.VALID_TOOL_PROFICIENCIES[str];
	}

	static getUnmappedTool (str) {
		if (!str) return null;
		return Parser._parse_bToA(this.VALID_TOOL_PROFICIENCIES, str, null);
	}

	static getMappedLanguage (str) {
		str = str.toLowerCase().trim();
		return this.VALID_LANGUAGES[str];
	}

	static getMappedCasterType (str) {
		if (!str) return str;
		return this._VET_CASTER_TYPE_TO_FVTT[str];
	}

	static getMappedArmorProficiency (str) {
		if (!str) return null;
		return Parser._parse_aToB(this.VALID_ARMOR_PROFICIENCIES, str, null);
	}

	static getUnmappedArmorProficiency (str) {
		if (!str) return null;
		return Parser._parse_bToA(this.VALID_ARMOR_PROFICIENCIES, str, null);
	}

	static getMappedWeaponProficiency (str) {
		if (!str) return null;
		return Parser._parse_aToB(this.VALID_WEAPON_PROFICIENCIES, str, null);
	}

	static getUnmappedWeaponProficiency (str) {
		if (!str) return null;
		return Parser._parse_bToA(this.VALID_WEAPON_PROFICIENCIES, str, null);
	}

	static getItemUIdFromWeaponProficiency (str) {
		if (!str) return null;
		str = str.trim();
		const tagItemUid = this._getItemUidFromTag(str);
		if (tagItemUid) return tagItemUid;
		return Parser._parse_aToB(this._WEAPON_PROFICIENCIES_TO_ITEM_UIDS, str, null);
	}

	static getItemUIdFromToolProficiency (str) {
		if (!str) return null;
		str = str.trim();
		const tagItemUid = this._getItemUidFromTag(str);
		if (tagItemUid) return tagItemUid;
		return Parser._parse_aToB(this._TOOL_PROFICIENCIES_TO_ITEM_UIDS, str, null);
	}

	static _getItemUidFromTag (str) {
		const mItem = /^{@item ([^}]+)}$/.exec(str);
		if (!mItem) return null;
		const {name, source} = DataUtil.generic.unpackUid(mItem[1], "item", {isLower: true});
		return `${name}|${source}`;
	}

		static getActorBarAttributes (actor) {
		if (!actor) return [];
		const attributes = TokenDocument.getTrackedAttributes(actor.system, []);
		attributes.bar = attributes.bar.map(v => v.join("."));
		attributes.bar.sort((a, b) => a.localeCompare(b));
		attributes.value = attributes.value.map(v => v.join("."));
		attributes.value.sort((a, b) => a.localeCompare(b));
		return {
			[game.i18n.localize("TOKEN.BarAttributes")]: attributes.bar,
			[game.i18n.localize("TOKEN.BarValues")]: attributes.value,
		};
	}

	static getTotalClassLevels (actor) {
		return actor.items
			.filter(it => it.type === "class")
			.map(it => it.system.levels || 0)
			.reduce((a, b) => a + b, 0);
	}

	static isLevelUp (actor) {
		let xpCur = Number(actor?.system?.details?.xp?.value);
		if (isNaN(xpCur)) xpCur = 0;

		const lvlTarget = actor.items.filter(it => it.type === "class").map(it => it.system.levels || 0).sum();
		let xpMax = Parser.LEVEL_XP_REQUIRED[lvlTarget];
		if (isNaN(xpMax)) xpMax = Number.MAX_SAFE_INTEGER;

		return xpCur >= xpMax;
	}

	static async pAddCurrencyToActor ({currency, actor}) {
		if (!currency || !actor) return;

		const totals = this.getActorCurrency({actor});
		Parser.COIN_ABVS.forEach(k => totals[k] += currency[k] || 0);

		const actorUpdate = {
			system: {
				currency: totals,
			},
		};
		await UtilDocuments.pUpdateDocument(actor, actorUpdate);
	}

	static getActorCurrency ({actor}) {
		const currency = {};
		const actorCurrency = MiscUtil.get(actor, "system", "currency") || {};
		Parser.COIN_ABVS.forEach(k => currency[k] = actorCurrency[k] || 0);
		return currency;
	}

	static ICON_SPELL_POINTS_ = "icons/magic/light/explosion-star-glow-silhouette.webp";
	static _SPELL_POINTS_SLOT_COUNT = 99;
	static async pGetCreateActorSpellPointsSlotsEffect ({actor, isTemporary}) {
		if (this.hasActorSpellPointSlotEffect({actor})) return;

		await this.pAddActorEffects(
			actor,
			this.getActorSpellPointsSlotsEffectData({actor}),
			{isTemporary},
		);

		await UtilDocuments.pUpdateDocument(actor, this.getActorSpellPointsSlotsUpdateSys());
	}

	static hasActorSpellPointSlotEffect ({actor}) {
		return (actor?.effects || []).some(it => it.flags[SharedConsts.MODULE_ID]?.["isSpellPointsSlotUnlocker"]);
	}

	static getActorSpellPointsSlotsEffectData ({actor = null, sheetItem = null} = {}) {
		return UtilActiveEffects.getExpandedEffects(
			[
				{
					name: `Spell Points Spell Slot Unlock`,
					changes: [...new Array(9)]
						.map((_, i) => ({
							"key": `system.spells.spell${i + 1}.override`,
							"mode": "OVERRIDE",
							"value": this._SPELL_POINTS_SLOT_COUNT,
						})),
					flags: {
						[SharedConsts.MODULE_ID]: {
							isSpellPointsSlotUnlocker: true,
							dedupeId: "spellPointsSlotUnlocker",
						},
					},
				},
			],
			{
				img: this.ICON_SPELL_POINTS_,
				actor,
				sheetItem,
			},
		);
	}

	static getActorSpellPointsSlotsUpdateSys () {
		return {
			system: {
				spells: [...new Array(9)].mergeMap((_, i) => ({
					[`spell${i + 1}`]: {
						value: 99,
					},
				})),
			},
		};
	}

	static getActorSpellPointsItem ({actor}) {
		return SpellPointsItemBuilder.getItem({actor});
	}

	static async pGetCreateActorSpellPointsItem ({actor, totalSpellcastingLevels = null}) {
		return SpellPointsItemBuilder.pGetCreateItem({actor, totalLevels: totalSpellcastingLevels});
	}

	static getActorPsiPointsItem ({actor}) {
		return PsiPointsItemBuilder.getItem({actor});
	}

	static async pGetCreateActorPsiPointsItem ({actor, totalMysticLevels = null}) {
		return PsiPointsItemBuilder.pGetCreateItem({actor, totalLevels: totalMysticLevels});
	}

	static getActorSpellcastingInfo (
		{
			actor,
			sheetItems,
															isForceSpellcastingMulticlass = false,
		} = {},
	) {
		if (actor && sheetItems) throw new Error(`Only one of "actor" or "sheetItems" may be specified!`);

		const spellcastingClassItems = (actor?.items || sheetItems).filter(it => it.type === "class")
			.filter(it => it.system?.spellcasting);

		if (!spellcastingClassItems.length) {
			return {
				totalSpellcastingLevels: 0,
				casterClassCount: 0,
				maxPactCasterLevel: 0,
				isSpellcastingMulticlass: isForceSpellcastingMulticlass,
			};
		}

		let totalSpellcastingLevels = 0; 		let maxPactCasterLevel = 0;

		const isSpellcastingMulticlass = isForceSpellcastingMulticlass || spellcastingClassItems.length > 1;

		const getSpellcastingLevel = (lvl, type) => {
			switch (type) {
				case "half": return Math.ceil(lvl / 2);
				case "third": return Math.ceil(lvl / 3);
								case "artificer": return lvl === 1 ? 1 : getSpellcastingLevel(lvl, "half");
				default: throw new Error(`Unhandled spellcaster type "${type}"`);
			}
		};

		const getSpellcastingLevelMulticlass = (lvl, type) => {
			switch (type) {
				case "half": return Math.floor(lvl / 2);
				case "third": return Math.floor(lvl / 3);
																case "artificer": return Math.ceil(lvl / 2);
				default: throw new Error(`Unhandled spellcaster type "${type}"`);
			}
		};

		const fnGetSpellcastingLevelHalfThird = isSpellcastingMulticlass ? getSpellcastingLevelMulticlass : getSpellcastingLevel;

		spellcastingClassItems
			.forEach(it => {
				const lvl = it.system.levels || 0;

				switch (it.system.spellcasting.progression) {
					case "full": totalSpellcastingLevels += lvl; break;
					case "half": totalSpellcastingLevels += fnGetSpellcastingLevelHalfThird(lvl, it.system.spellcasting.progression); break;
					case "third": totalSpellcastingLevels += fnGetSpellcastingLevelHalfThird(lvl, it.system.spellcasting.progression); break;
					case "pact": Math.max(maxPactCasterLevel, lvl); break;
					case "artificer": totalSpellcastingLevels += fnGetSpellcastingLevelHalfThird(lvl, it.system.spellcasting.progression); break;
				}
			});

		return {totalSpellcastingLevels, casterClassCount: spellcastingClassItems.length, maxPactCasterLevel, isSpellcastingMulticlass};
	}

	static async pLinkTempUuids ({actor}) {
		const SENTINEL = `__${SharedConsts.MODULE_ID_FAKE}_REPLACE_TARGET__`;

		const reUuid = new RegExp(`(?<prefix>@UUID\\[[^\\]]+\\.)temp-${SharedConsts.MODULE_ID_FAKE}-(?<packed>[^.\\]]+)(?<suffix>](?:\\{[^}]+})?)`, "g");
		const reSentinelLi = new RegExp(`<li[^>]*>\\s*${SENTINEL}\\s*<\\/li>`, "g");
		const reSentinelP = new RegExp(`<p[^>]*>\\s*${SENTINEL}\\s*<\\/p>`, "g");
		const reSentinel = new RegExp(SENTINEL, "g");

		const updates = actor.items
			.map(item => {
				const desc = item.system.description.value || "";
				const nxtDesc = desc
					.replace(reUuid, (...m) => {
						const packed = m.last().packed;
						try {
							const {page, source, hash} = JSON.parse(decodeURIComponent(atob(packed)));
							if (!page || !source || !hash) return SENTINEL;

							const matchedItem = actor.items.find(it => it.flags?.[SharedConsts.MODULE_ID]?.page === page && it.flags?.[SharedConsts.MODULE_ID]?.source === source && it.flags?.[SharedConsts.MODULE_ID]?.hash === hash);

							if (!matchedItem) return SENTINEL;

							return `${m.last().prefix}${matchedItem.id}${m.last().suffix}`;
						} catch (e) {
							console.error(...LGT, `Failed to unpack temp page/source/hash`, e);
							return "";
						}
					})
										.replace(reSentinelLi, "")
					.replace(reSentinelP, "")
					.replace(reSentinel, "")
				;

				if (desc === nxtDesc) return null;

				return {
					_id: item.id,
					system: {
						description: {
							value: nxtDesc,
						},
					},
				};
			})
			.filter(Boolean);

		if (!updates.length) return;

		await UtilDocuments.pUpdateEmbeddedDocuments(actor, updates, {ClsEmbed: Item});
	}

	static isSetMaxHp ({actor}) {
		if (!UtilVersions.getSystemVersion().isVersionTwoOnePlus) return true;
		return actor._source.system.attributes.hp.max != null;
	}

	static getProficiencyBonusNumber ({actor}) {
		const prof = actor.getRollData().prof;
		if (typeof prof === "number") return prof;
		return prof.flat;
	}
}
UtilActors.SKILL_ABV_TO_FULL = {
	acr: "acrobatics",
	ani: "animal handling",
	arc: "arcana",
	ath: "athletics",
	dec: "deception",
	his: "history",
	ins: "insight",
	itm: "intimidation",
	inv: "investigation",
	med: "medicine",
	nat: "nature",
	prc: "perception",
	prf: "performance",
	per: "persuasion",
	rel: "religion",
	slt: "sleight of hand",
	ste: "stealth",
	sur: "survival",
};
UtilActors.TOOL_ABV_TO_FULL = {
	art: "artisan's tools",
	alchemist: "alchemist's supplies",
	brewer: "brewer's supplies",
	calligrapher: "calligrapher's supplies",
	carpenter: "carpenter's tools",
	cartographer: "cartographer's tools",
	cobbler: "cobbler's tools",
	cook: "cook's utensils",
	glassblower: "glassblower's tools",
	jeweler: "jeweler's tools",
	leatherworker: "leatherworker's tools",
	mason: "mason's tools",
	painter: "painter's supplies",
	potter: "potter's tools",
	smith: "smith's tools",
	tinker: "tinker's tools",
	weaver: "weaver's tools",
	woodcarver: "woodcarver's tools",

	disg: "disguise kit",
	forg: "forgery kit",

	game: "gaming set",
	chess: "dragonchess set",
	dice: "dice set",
	card: "three-dragon ante set",

	herb: "herbalism kit",

	music: "musical instrument",
	bagpipes: "bagpipes",
	drum: "drum",
	dulcimer: "dulcimer",
	flute: "flute",
	horn: "horn",
	lute: "lute",
	lyre: "lyre",
	panflute: "pan flute",
	shawm: "shawm",
	viol: "viol",

	navg: "navigator's tools",

	pois: "poisoner's kit",

	thief: "thieves' tools",

	vehicle: "vehicles",
	air: "vehicles (air)",
	land: "vehicles (land)",
	space: "vehicles (space)",
	water: "vehicles (water)",
};
UtilActors.PROF_TO_ICON_CLASS = {
	"1": "fa-check",
	"2": "fa-check-double",
	"0.5": "fa-adjust",
};
UtilActors.PROF_TO_TEXT = {
	"1": "Proficient",
	"2": "Proficient with Expertise",
	"0.5": "Half-Proficient",
	"0": "",
};
UtilActors.VET_SIZE_TO_ABV = {
	[Parser.SZ_TINY]: "tiny",
	[Parser.SZ_SMALL]: "sm",
	[Parser.SZ_MEDIUM]: "med",
	[Parser.SZ_LARGE]: "lg",
	[Parser.SZ_HUGE]: "huge",
	[Parser.SZ_GARGANTUAN]: "grg",
};
UtilActors.VET_SPELL_SCHOOL_TO_ABV = {
	A: "abj",
	C: "con",
	D: "div",
	E: "enc",
	V: "evo",
	I: "ill",
	N: "nec",
	T: "trs",
};

UtilActors.PACT_CASTER_MAX_SPELL_LEVEL = 5;

UtilActors.VALID_DAMAGE_TYPES = null;
UtilActors.VALID_CONDITIONS = null;

UtilActors.TOOL_PROFICIENCIES_ARTISANS = [
	"alchemist's supplies",
	"brewer's supplies",
	"calligrapher's supplies",
	"carpenter's tools",
	"cartographer's tools",
	"cobbler's tools",
	"cook's utensils",
	"glassblower's tools",
	"jeweler's tools",
	"leatherworker's tools",
	"mason's tools",
	"painter's supplies",
	"potter's tools",
	"smith's tools",
	"tinker's tools",
	"weaver's tools",
	"woodcarver's tools",
];
UtilActors.TOOL_PROFICIENCIES_MUSICAL_INSTRUMENTS = [
	"bagpipes",
	"drum",
	"dulcimer",
	"flute",
	"horn",
	"lute",
	"lyre",
	"pan flute",
	"shawm",
	"viol",
];
UtilActors.TOOL_PROFICIENCIES = [
	"artisan's tools",

	...UtilActors.TOOL_PROFICIENCIES_ARTISANS,
	...UtilActors.TOOL_PROFICIENCIES_MUSICAL_INSTRUMENTS,

	"disguise kit",
	"forgery kit",
	"gaming set",
	"herbalism kit",
	"musical instrument",
	"navigator's tools",
	"thieves' tools",
	"poisoner's kit",
	"vehicles (land)",
	"vehicles (water)",
	"vehicles (air)",
	"vehicles (space)",
];
UtilActors.TOOL_PROFICIENCIES_TO_UID = {
	"alchemist's supplies": "alchemist's supplies|phb",
	"brewer's supplies": "brewer's supplies|phb",
	"calligrapher's supplies": "calligrapher's supplies|phb",
	"carpenter's tools": "carpenter's tools|phb",
	"cartographer's tools": "cartographer's tools|phb",
	"cobbler's tools": "cobbler's tools|phb",
	"cook's utensils": "cook's utensils|phb",
	"glassblower's tools": "glassblower's tools|phb",
	"jeweler's tools": "jeweler's tools|phb",
	"leatherworker's tools": "leatherworker's tools|phb",
	"mason's tools": "mason's tools|phb",
	"painter's supplies": "painter's supplies|phb",
	"potter's tools": "potter's tools|phb",
	"smith's tools": "smith's tools|phb",
	"tinker's tools": "tinker's tools|phb",
	"weaver's tools": "weaver's tools|phb",
	"woodcarver's tools": "woodcarver's tools|phb",
	"disguise kit": "disguise kit|phb",
	"forgery kit": "forgery kit|phb",
	"gaming set": "gaming set|phb",
	"herbalism kit": "herbalism kit|phb",
	"musical instrument": "musical instrument|phb",
	"navigator's tools": "navigator's tools|phb",
	"thieves' tools": "thieves' tools|phb",
	"poisoner's kit": "poisoner's kit|phb",
};
UtilActors.VALID_TOOL_PROFICIENCIES = {
	"artisan's tools": "art",
	"alchemist's supplies": "alchemist",
	"brewer's supplies": "brewer",
	"calligrapher's supplies": "calligrapher",
	"carpenter's tools": "carpenter",
	"cartographer's tools": "cartographer",
	"cobbler's tools": "cobbler",
	"cook's utensils": "cook",
	"glassblower's tools": "glassblower",
	"jeweler's tools": "jeweler",
	"leatherworker's tools": "leatherworker",
	"mason's tools": "mason",
	"painter's supplies": "painter",
	"potter's tools": "potter",
	"smith's tools": "smith",
	"tinker's tools": "tinker",
	"weaver's tools": "weaver",
	"woodcarver's tools": "woodcarver",

	"disguise kit": "disg",

	"forgery kit": "forg",

	"gaming set": "game",
	"dice set": "dice",
	"dragonchess set": "chess",
	"playing card set": "card",
	"three-dragon ante set": "card",

	"herbalism kit": "herb",

	"musical instrument": "music",
	"bagpipes": "bagpipes",
	"drum": "drum",
	"dulcimer": "dulcimer",
	"flute": "flute",
	"lute": "lute",
	"lyre": "lyre",
	"horn": "horn",
	"pan flute": "panflute",
	"shawm": "shawm",
	"viol": "viol",

	"navigator's tools": "navg",

	"poisoner's kit": "pois",

	"thieves' tools": "thief",

	"vehicle (land or water)": "vehicle",
	"vehicle (air)": "air",
	"vehicle (land)": "land",
	"vehicle (water)": "water",
	"vehicle (space)": "space",
};
UtilActors.VALID_LANGUAGES = {
	"common": "common",
	"aarakocra": "aarakocra",
	"abyssal": "abyssal",
	"aquan": "aquan",
	"auran": "auran",
	"celestial": "celestial",
	"deep speech": "deep",
	"draconic": "draconic",
	"druidic": "druidic",
	"dwarvish": "dwarvish",
	"elvish": "elvish",
	"giant": "giant",
	"gith": "gith",
	"gnomish": "gnomish",
	"goblin": "goblin",
	"gnoll": "gnoll",
	"halfling": "halfling",
	"ignan": "ignan",
	"infernal": "infernal",
	"orc": "orc",
	"primordial": "primordial",
	"sylvan": "sylvan",
	"terran": "terran",
	"thieves' cant": "cant",
	"undercommon": "undercommon",
};
UtilActors.LANGUAGES_PRIMORDIAL = [
	"aquan",
	"auran",
	"ignan",
	"terran",
];
UtilActors._VET_CASTER_TYPE_TO_FVTT = {
	"full": "full",
	"1/2": "half",
	"1/3": "third",
	"pact": "pact",
	"artificer": "artificer",
};
UtilActors.ARMOR_PROFICIENCIES = [
	"light",
	"medium",
	"heavy",
	"shield|phb",
];
UtilActors.VALID_ARMOR_PROFICIENCIES = {
	"light": "lgt",
	"medium": "med",
	"heavy": "hvy",
	"shield|phb": "shl",
};
UtilActors.WEAPON_PROFICIENCIES = [
	"battleaxe|phb",
	"club|phb",
	"dagger|phb",
	"flail|phb",
	"glaive|phb",
	"greataxe|phb",
	"greatclub|phb",
	"greatsword|phb",
	"halberd|phb",
	"handaxe|phb",
	"javelin|phb",
	"lance|phb",
	"light hammer|phb",
	"longsword|phb",
	"mace|phb",
	"maul|phb",
	"morningstar|phb",
	"pike|phb",
	"quarterstaff|phb",
	"rapier|phb",
	"scimitar|phb",
	"shortsword|phb",
	"sickle|phb",
	"spear|phb",
	"staff|phb",
	"trident|phb",
	"war pick|phb",
	"warhammer|phb",
	"whip|phb",
	"blowgun|phb",
	"dart|phb",
	"hand crossbow|phb",
	"heavy crossbow|phb",
	"light crossbow|phb",
	"longbow|phb",
	"net|phb",
	"shortbow|phb",
	"sling|phb",
];
UtilActors.VALID_WEAPON_PROFICIENCIES = {
	"simple": "sim",
	"martial": "mar",

	"club|phb": "club",
	"dagger|phb": "dagger",
	"dart|phb": "dart",
	"greatclub|phb": "greatclub",
	"handaxe|phb": "handaxe",
	"javelin|phb": "javelin",
	"light crossbow|phb": "lightcrossbow",
	"light hammer|phb": "lighthammer",
	"mace|phb": "mace",
	"quarterstaff|phb": "quarterstaff",
	"shortbow|phb": "shortbow",
	"sickle|phb": "sickle",
	"sling|phb": "sling",
	"spear|phb": "spear",

	"battleaxe|phb": "battleaxe",
	"blowgun|phb": "blowgun",
	"flail|phb": "flail",
	"glaive|phb": "glaive",
	"greataxe|phb": "greataxe",
	"greatsword|phb": "greatsword",
	"halberd|phb": "halberd",
	"hand crossbow|phb": "handcrossbow",
	"heavy crossbow|phb": "heavycrossbow",
	"lance|phb": "lance",
	"longbow|phb": "longbow",
	"longsword|phb": "longsword",
	"maul|phb": "maul",
	"morningstar|phb": "morningstar",
	"net|phb": "net",
	"pike|phb": "pike",
	"rapier|phb": "rapier",
	"scimitar|phb": "scimitar",
	"shortsword|phb": "shortsword",
	"trident|phb": "trident",
	"war pick|phb": "warpick",
	"warhammer|phb": "warhammer",
	"whip|phb": "whip",
};
UtilActors._WEAPON_PROFICIENCIES_TO_ITEM_UIDS = {
		"battleaxes": "battleaxe|phb",
	"clubs": "club|phb",
	"daggers": "dagger|phb",
	"flails": "flail|phb",
	"glaives": "glaive|phb",
	"greataxes": "greataxe|phb",
	"greatclubs": "greatclub|phb",
	"greatswords": "greatsword|phb",
	"halberds": "halberd|phb",
	"handaxes": "handaxe|phb",
	"javelins": "javelin|phb",
	"lances": "lance|phb",
	"light hammers": "light hammer|phb",
	"longswords": "longsword|phb",
	"maces": "mace|phb",
	"mauls": "maul|phb",
	"morningstars": "morningstar|phb",
	"pikes": "pike|phb",
	"quarterstaffs": "quarterstaff|phb",
	"rapiers": "rapier|phb",
	"scimitars": "scimitar|phb",
	"shortswords": "shortsword|phb",
	"sickles": "sickle|phb",
	"spears": "spear|phb",
	"staffs": "staff|phb",
	"tridents": "trident|phb",
	"war picks": "war pick|phb",
	"warhammers": "warhammer|phb",
	"whips": "whip|phb",

	"blowguns": "blowgun|phb",
	"darts": "dart|phb",
	"hand crossbows": "hand crossbow|phb",
	"heavy crossbows": "heavy crossbow|phb",
	"light crossbows": "light crossbow|phb",
	"longbows": "longbow|phb",
	"nets": "net|phb",
	"shortbows": "shortbow|phb",
	"slings": "sling|phb",
	
		"battleaxe": "battleaxe|phb",
	"club": "club|phb",
	"dagger": "dagger|phb",
	"flail": "flail|phb",
	"glaive": "glaive|phb",
	"greataxe": "greataxe|phb",
	"greatclub": "greatclub|phb",
	"greatsword": "greatsword|phb",
	"halberd": "halberd|phb",
	"handaxe": "handaxe|phb",
	"javelin": "javelin|phb",
	"lance": "lance|phb",
	"light hammer": "light hammer|phb",
	"longsword": "longsword|phb",
	"mace": "mace|phb",
	"maul": "maul|phb",
	"morningstar": "morningstar|phb",
	"pike": "pike|phb",
	"quarterstaff": "quarterstaff|phb",
	"rapier": "rapier|phb",
	"scimitar": "scimitar|phb",
	"shortsword": "shortsword|phb",
	"sickle": "sickle|phb",
	"spear": "spear|phb",
	"staff": "staff|phb",
	"trident": "trident|phb",
	"war pick": "war pick|phb",
	"warhammer": "warhammer|phb",
	"whip": "whip|phb",

	"blowgun": "blowgun|phb",
	"dart": "dart|phb",
	"hand crossbow": "hand crossbow|phb",
	"heavy crossbow": "heavy crossbow|phb",
	"light crossbow": "light crossbow|phb",
	"longbow": "longbow|phb",
	"net": "net|phb",
	"shortbow": "shortbow|phb",
	"sling": "sling|phb",
	};
UtilActors._TOOL_PROFICIENCIES_TO_ITEM_UIDS = {
	"alchemist's supplies": "alchemist's supplies|phb",
	"artisan's tools": "artisan's tools|phb",
	"bagpipes": "bagpipes|phb",
	"brewer's supplies": "brewer's supplies|phb",
	"calligrapher's supplies": "calligrapher's supplies|phb",
	"carpenter's tools": "carpenter's tools|phb",
	"cartographer's tools": "cartographer's tools|phb",
	"cobbler's tools": "cobbler's tools|phb",
	"cook's utensils": "cook's utensils|phb",
	"disguise kit": "disguise kit|phb",
	"drum": "drum|phb",
	"dulcimer": "dulcimer|phb",
	"flute": "flute|phb",
	"forgery kit": "forgery kit|phb",
	"glassblower's tools": "glassblower's tools|phb",
	"herbalism kit": "herbalism kit|phb",
	"horn": "horn|phb",
	"jeweler's tools": "jeweler's tools|phb",
	"leatherworker's tools": "leatherworker's tools|phb",
	"lute": "lute|phb",
	"lyre": "lyre|phb",
	"mason's tools": "mason's tools|phb",
	"musical instrument": "musical instrument|phb",
	"navigator's tools": "navigator's tools|phb",
	"painter's supplies": "painter's supplies|phb",
	"pan flute": "pan flute|phb",
	"poisoner's kit": "poisoner's kit|phb",
	"potter's tools": "potter's tools|phb",
	"shawm": "shawm|phb",
	"smith's tools": "smith's tools|phb",
	"thieves' tools": "thieves' tools|phb",
	"tinker's tools": "tinker's tools|phb",
	"viol": "viol|phb",
	"weaver's tools": "weaver's tools|phb",
	"woodcarver's tools": "woodcarver's tools|phb",
};

UtilActors.BG_SKILL_PROFS_CUSTOMIZE = [
	{
		choose: {
			from: Object.keys(Parser.SKILL_TO_ATB_ABV),
			count: 2,
		},
	},
];

UtilActors.LANG_TOOL_PROFS_CUSTOMIZE = [
	{
		anyStandardLanguage: 2,
	},
	{
		anyStandardLanguage: 1,
		anyTool: 1,
	},
	{
		anyTool: 2,
	},
];

class SpellPsiPointsItemBuilder {
	static _ITEM_NAME = "";
	static _ITEM_IMG = "";
	static _FLAG_TYPE = "";

	static getItem ({actor}) {
		if (!this._isEnabled({actor})) return null;

		return actor.items.contents.find(it => it.flags?.[SharedConsts.MODULE_ID]?.type === this._FLAG_TYPE);
	}

	static async pGetCreateItem ({actor, totalLevels = null}) {
		if (!this._isEnabled({actor})) return null;

		Renderer.get().resetHeaderIndex();

				const existingItem = this.getItem({actor});
		if (existingItem) {
			if (totalLevels == null) return existingItem;

			const curPointsVal = (existingItem.system._source || existingItem.system)?.uses?.value || 0;
			const curPointsMax = (existingItem.system._source || existingItem.system)?.uses?.max || 0;

			const points = await this._pGetPoints({totalLevels});
			if (points > curPointsMax) {
				const deltaCur = (points - curPointsMax);
				await UtilDocuments.pUpdateEmbeddedDocuments(
					actor,
					[
						{
							_id: existingItem.id,
							system: {
								uses: {value: curPointsVal + deltaCur, max: points},
							},
						},
					],
					{
						propData: "items",
						ClsEmbed: Item,
					},
				);
			}

			return existingItem;
		}
		
				if (totalLevels == null) totalLevels = await this._pGetTotalLevelsIfNull({actor});

		const points = await this._pGetPoints({totalLevels});
		const iemData = {
			name: this._ITEM_NAME,
			type: "feat",
			system: {
				description: {
					value: await UtilDataConverter.pGetWithDescriptionPlugins(() => this._pGetItemDescription()),
				},
				source: this._getItemSource(),
				activation: {cost: 0, type: "none"},
				uses: {
					value: points,
					max: Math.max(points, 1), 					per: "lr",
				},
			},
			img: this._ITEM_IMG,
			flags: {
				[SharedConsts.MODULE_ID]: {
					type: this._FLAG_TYPE,
				},
			},
		};

		const importedEmbeds = await UtilActors.pAddActorItems(
			actor,
			[iemData],
		);
		return importedEmbeds[0].document;
			}

		static _isEnabled () { throw new Error("Unimplemented!"); }

		static async _pGetTotalLevelsIfNull () { throw new Error("Unimplemented!"); }

		static async _pGetPoints () { throw new Error("Unimplemented!"); }

		static async _pGetItemDescription () { throw new Error("Unimplemented!"); }

		static _getItemSource () { throw new Error("Unimplemented!"); }
}

class SpellPointsItemBuilder extends SpellPsiPointsItemBuilder {
	static _ITEM_NAME = "Spell Points";
	static _ITEM_IMG = UtilActors.ICON_SPELL_POINTS_;
	static _FLAG_TYPE = "spellPointsTracker";

	static _isEnabled ({actor}) {
		if (Config.get("importSpell", Config.getSpellPointsKey({actorType: actor?.type})) === ConfigConsts.C_SPELL_POINTS_MODE__DISABLED) return false;
		if (Config.get("importSpell", "spellPointsResource") !== ConfigConsts.C_SPELL_POINTS_RESOURCE__SHEET_ITEM) return false;

		return true;
	}

	static async _pGetTotalLevelsIfNull ({actor}) {
		return UtilActors.getActorSpellcastingInfo({actor: actor})?.totalSpellcastingLevels;
	}

	static _pGetPoints ({totalLevels}) { return UtilDataConverter.getSpellPointTotal({totalSpellcastingLevels: totalLevels}); }

	static async _pGetItemDescription () {
		const entSpellPointVariant = await DataLoader.pCacheAndGet(UrlUtil.PG_VARIANTRULES, Parser.SRC_DMG, UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_VARIANTRULES]({name: "Spell Points", source: Parser.SRC_DMG}), {isCopy: true});
		delete entSpellPointVariant?.name;
		delete entSpellPointVariant?.page;
		delete entSpellPointVariant?.source;
		return `<div>${Renderer.get().render(`{@note This item was automatically generated to track your spell points. It can be freely modified.}`)}</div>
		<hr class="hr-2">
		<div>${Renderer.get().setFirstSection(true).render(entSpellPointVariant || "")}</div>`;
	}

		static _getItemSource () { return UtilDataConverter.getSourceWithPagePart({source: Parser.SRC_DMG, page: 288}); }
}

class PsiPointsItemBuilder extends SpellPsiPointsItemBuilder {
	static _ITEM_NAME = "Psi Points";
	static _ITEM_IMG = `icons/magic/perception/third-eye-blue-red.webp`;
	static _FLAG_TYPE = "psiPointsTracker";

	static _isEnabled () { return Config.get("importPsionic", "psiPointsResource") === ConfigConsts.C_SPELL_POINTS_RESOURCE__SHEET_ITEM; }

	static async _pGetTotalLevelsIfNull ({actor}) {
		const {Charactermancer_Class_Util} = await Promise.resolve().then(function () { return UtilCharactermancerClass; });
		return Charactermancer_Class_Util.getMysticProgression({otherExistingClassItems: actor.items.contents.filter(it => it.type === "class")}).totalMysticLevels;
	}

	static _pGetPoints ({totalLevels}) { return UtilDataConverter.getPsiPointTotal({totalMysticLevels: totalLevels}); }

	static async _pGetItemDescription () {
		const entries = {
			type: "entries",
			entries: [
				{
					"type": "entries",
					"name": "Psi Points",
					"entries": [
						"You have an internal reservoir of energy that can be devoted to psionic disciplines you know. This energy is represented by psi points. Each psionic discipline describes effects you can create with it by spending a certain number of psi points. A psionic talent requires no psi points.",
						"The number of psi points you have is based on your mystic level, as shown in the Psi Points column of the Mystic table. The number shown for your level is your psi point maximum. Your psi point total returns to its maximum when you finish a long rest. The number of psi points you have can't go below 0 or over your maximum.",
					],
				},
				{
					"type": "entries",
					"name": "Psi Limit",
					"entries": [
						"Though you have access to a potent amount of psionic energy, it takes training and practice to channel that energy. There is a limit on the number of psi points you can spend to activate a psionic discipline. The limit is based on your mystic level, as shown in the Psi Limit column of the Mystic table. For example, as a 3rd-level mystic, you can spend no more than 3 psi points on a discipline each time you use it, no matter how many psi points you have.",
					],
				},
				{
					"type": "table",
					"caption": "Mystic",
					"colLabels": ["Level", "Psi Points", "Psi Limit"],
					"colStyles": ["col-4 text-center", "col-4 text-center", "col-4 text-center"],
					"rows": [
						["1st", 4, 2],
						["2nd", 6, 2],
						["3rd", 14, 3],
						["4th", 17, 3],
						["5th", 27, 5],
						["6th", 32, 5],
						["7th", 38, 6],
						["8th", 44, 6],
						["9th", 57, 7],
						["10th", 64, 7],
						["11th", 64, 7],
						["12th", 64, 7],
						["13th", 64, 7],
						["14th", 64, 7],
						["15th", 64, 7],
						["16th", 64, 7],
						["17th", 64, 7],
						["18th", 71, 7],
						["19th", 71, 7],
						["20th", 71, 7],
					],
				},
			],
		};
		return `<div>${Renderer.get().render(`{@note This item was automatically generated to track your psi points. It can be freely modified.}`)}</div>
		<hr class="hr-2">
		<div>${Renderer.get().setFirstSection(true).render(entries)}</div>`;
	}

		static _getItemSource () { return UtilDataConverter.getSourceWithPagePart({source: Parser.SRC_UATMC, page: 3}); }
}

class UtilCanvas {
		static getPosCanvasSpace (evt, layerName) {
		const layer = canvas.layers.find(it => it.name === layerName);

						const [x, y] = [evt.clientX, evt.clientY];
		const t = layer.worldTransform;
		const tx = (x - t.tx) / canvas.stage.scale.x;
		const ty = (y - t.ty) / canvas.stage.scale.y;
		const p = canvas.grid.getTopLeft(tx, ty);

		return {x: p[0], y: p[1]};
	}

		static getCentroid (arr) {
		const x = arr.map(xy => xy[0]);
		const y = arr.map(xy => xy[1]);
		const cx = (Math.min(...x) + Math.max(...x)) / 2;
		const cy = (Math.min(...y) + Math.max(...y)) / 2;
		return [cx, cy];
	}
}

"use strict";

class Const {}
Const.STATES = ["0", "1", "2"]; 
Const.GH_PATH = `https://raw.githubusercontent.com/DMsGuild201/Roll20_resources/master/ExternalArt/dist/`;
Const.FAKE_FILTER_ARTIST = "Artist";
Const.FAKE_FILTER_SET = "Collection";
Const.IMG_LAZY_180 = `data:image/svg+xml,${encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" width="180" height="180"><rect width="100%" height="100%" fill="#8883"></rect></svg>`)}`;

"use strict";

let SortUtil$1 = class SortUtil {
	static ascSort (a, b) {
		if (b === a) return 0;
		return b < a ? 1 : -1;
	}

	static ascSortLower (a, b) { return SortUtil$1.ascSort((a || "").toLowerCase(), (b || "").toLowerCase()) }
};

let MiscUtil$1 = class MiscUtil {
	static copy (obj) {
		return JSON.parse(JSON.stringify(obj));
	}

	static pCopyTextToClipboard (text) {
		const $temp = $(`<textarea id="copy-temp" style="position: fixed; top: -1000px; left: -1000px; width: 1px; height: 1px;">${text}</textarea>`)
			.appendTo(document.body).select();
		document.execCommand("Copy");
		$temp.remove();
	}

	static showCopiedEffect ($ele, text = "Copied!") {
		const $temp = $(`<div class="copied-tip"><span>${text}</span></div>`)
			.appendTo(document.body);
		const top = $(window).scrollTop();
		const pos = $ele.offset();
		$temp
			.css({
				top: pos.top - $temp.height() - top,
				left: pos.left - ($temp.width() / 2) + ($ele.width() / 2)
			})
			.animate(
				{
					top: "-=8",
					opacity: 0.5
				},
				250,
				() => {
					$temp.remove();
				}
			);
	}

	static pDelay (msecs, resolveAs) {
		return new Promise(resolve => setTimeout(() => resolve(resolveAs), msecs));
	}

		static debounce (func, wait, options) {
		let lastArgs; let lastThis; let maxWait; let result; let timerId; let lastCallTime; let lastInvokeTime = 0; let leading = false; let maxing = false; let trailing = true;

		wait = Number(wait) || 0;
		if (typeof options === "object") {
			leading = !!options.leading;
			maxing = "maxWait" in options;
			maxWait = maxing ? Math.max(Number(options.maxWait) || 0, wait) : maxWait;
			trailing = "trailing" in options ? !!options.trailing : trailing;
		}

		function invokeFunc (time) {
			let args = lastArgs; let thisArg = lastThis;

			lastArgs = lastThis = undefined;
			lastInvokeTime = time;
			result = func.apply(thisArg, args);
			return result;
		}

		function leadingEdge (time) {
			lastInvokeTime = time;
			timerId = setTimeout(timerExpired, wait);
			return leading ? invokeFunc(time) : result;
		}

		function remainingWait (time) {
			let timeSinceLastCall = time - lastCallTime; let timeSinceLastInvoke = time - lastInvokeTime; let result = wait - timeSinceLastCall;
			return maxing ? Math.min(result, maxWait - timeSinceLastInvoke) : result;
		}

		function shouldInvoke (time) {
			let timeSinceLastCall = time - lastCallTime; let timeSinceLastInvoke = time - lastInvokeTime;

			return (lastCallTime === undefined || (timeSinceLastCall >= wait) || (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
		}

		function timerExpired () {
			const time = Date.now();
			if (shouldInvoke(time)) {
				return trailingEdge(time);
			}
						timerId = setTimeout(timerExpired, remainingWait(time));
		}

		function trailingEdge (time) {
			timerId = undefined;

			if (trailing && lastArgs) return invokeFunc(time);
			lastArgs = lastThis = undefined;
			return result;
		}

		function cancel () {
			if (timerId !== undefined) clearTimeout(timerId);
			lastInvokeTime = 0;
			lastArgs = lastCallTime = lastThis = timerId = undefined;
		}

		function flush () {
			return timerId === undefined ? result : trailingEdge(Date.now());
		}

		function debounced () {
			let time = Date.now(); let isInvoking = shouldInvoke(time);
			lastArgs = arguments;
			lastThis = this;
			lastCallTime = time;

			if (isInvoking) {
				if (timerId === undefined) return leadingEdge(lastCallTime);
				if (maxing) {
										timerId = setTimeout(timerExpired, wait);
					return invokeFunc(lastCallTime);
				}
			}
			if (timerId === undefined) timerId = setTimeout(timerExpired, wait);
			return result;
		}

		debounced.cancel = cancel;
		debounced.flush = flush;
		return debounced;
	}

		static throttle (func, wait, options) {
		let leading = true; let trailing = true;

		if (typeof options === "object") {
			leading = "leading" in options ? !!options.leading : leading;
			trailing = "trailing" in options ? !!options.trailing : trailing;
		}

		return this.debounce(func, wait, {leading, maxWait: wait, trailing});
	}
};

let StorageUtil$1 = class StorageUtil {
	static _getSyncStorage () {
		if (StorageUtil$1._init) {
			if (StorageUtil$1.__fakeStorage) return StorageUtil$1._fakeStorage;
			else return window.localStorage;
		}

		StorageUtil$1._init = true;
		try {
			window.localStorage.setItem("_test_storage", true);
			return window.localStorage;
		} catch (e) {
						StorageUtil$1.__fakeStorage = true;
			StorageUtil$1._fakeStorage = {
				isSyncFake: true,
				getItem: k => StorageUtil$1.__fakeStorage[k],
				removeItem: k => delete StorageUtil$1.__fakeStorage[k],
				setItem: (k, v) => StorageUtil$1.__fakeStorage[k] = v
			};
			return StorageUtil$1._fakeStorage;
		}
	}

		static syncGet (key) {
		const rawOut = StorageUtil$1._getSyncStorage().getItem(key);
		if (rawOut && rawOut !== "undefined" && rawOut !== "null") return JSON.parse(rawOut);
		return null;
	}

	static syncSet (key, value) {
		StorageUtil$1._getSyncStorage().setItem(key, JSON.stringify(value));
	}

	static syncRemove (key) {
		StorageUtil$1._getSyncStorage().removeItem(key);
	}
	};
StorageUtil$1._init = false;
StorageUtil$1._fakeStorage = {};

class DownloadHelper {
	constructor ($parent) {
		this._$parent = $parent;
		this._queue = [];
		this._$wrpDlBar = null;
	}

	_doDisplayProgressBar ($content, cbCancel) {
		if (this._$wrpDlBar) this._$wrpDlBar.remove();

		const $wrpContent = $$`<div class="artr__dl_bar-wrp-content">${$content}</div>`;

		const $btnCancelClose = $(`<button class="artr__dl_bar-btn-close px-2"><span class="fas fa-times"></span></button>`)
			.click(() => {
				this._$wrpDlBar.remove();
				cbCancel();
			});

		this._$wrpDlBar = $$`<div class="artr__dl_bar ve-flex">
			${$wrpContent}
			<div class="artr__dl_bar-wrp-control">
				${$btnCancelClose}
			</div>
		</div>`
			.appendTo(this._$parent);

		return $wrpContent;
	}

		async _pDoUpdateProgressBar ($wrpBarContent, str, opts) {
		opts = opts || {};
		if (opts.isError) $wrpBarContent.parent().addClass("artr__dl_bar--error");
		$wrpBarContent.html(str);
		if (opts.isComplete) return this._pDoUpdateQueueAndTriggerNext();
	}

	_doAjaxGet (url) {
		const xhr = new XMLHttpRequest();
		const p = new Promise((resolve, reject) => {
						xhr.open("GET", `https://cors-anywhere.herokuapp.com/${url}`, true);
			xhr.responseType = "arraybuffer";

			let lastContentType = null;

			xhr.onreadystatechange = () => {
				const contentType = xhr.getResponseHeader("content-type");
				if (contentType) lastContentType = contentType;
			};

			xhr.onload = function () {
				const arrayBuffer = xhr.response;
				resolve({buff: arrayBuffer, contentType: lastContentType});
			};

			xhr.onerror = (e) => reject(new Error(`Error during request: ${e}`));

			xhr.send();
		});

		p.abort = () => xhr.abort();

		return p;
	}

	async _pDoUpdateQueueAndTriggerNext () {
		this._queue.shift();
		if (this._queue.length) return this._pDoNextDownload();
	}

	async _pDoNextDownload () {
		const item = this._queue[0];

		let isCancelled = false;
		let downloadTasks = [];

		const $wrpProgressBar = this._doDisplayProgressBar(
			`Download starting...`,
			() => {
				isCancelled = true;
				downloadTasks.forEach(p => {
					try { p.abort(); } catch (ignored) {  }
				});
				this._queue.shift();
				if (this._queue.length) this._pDoNextDownload();
			});

		if (isCancelled) return;

		try {
			const toSave = [];
			let downloaded = 0;
			let errorCount = 0;

			const getWrappedPromise = dataItem => {
				const pAjax = this._doAjaxGet(dataItem.uri);

				const p = (async () => {
					try {
						const data = await pAjax;
						toSave.push(data);
					} catch (e) {
						setTimeout(() => { throw e; });
						++errorCount;
					}
					++downloaded;
					this._pDoUpdateProgressBar(
						$wrpProgressBar,
						`Downloading ${downloaded}/${item.data.length}... (${Math.floor(100 * downloaded / item.data.length)}%)${errorCount ? ` (${errorCount} error${errorCount === 1 ? "" : "s"})` : ""}`
					);
				})();

				p.abort = () => pAjax.abort();

				return p;
			};

			downloadTasks = item.data.map(dataItem => getWrappedPromise(dataItem));
			await Promise.all(downloadTasks);

			if (isCancelled) return;

			this._pDoUpdateProgressBar($wrpProgressBar, `Building ZIP...`);

			const zip = new JSZip();
			toSave.forEach((data, i) => {
				const extension = (data.contentType || "unknown").split("/").last();
				zip.file(`${`${i}`.padStart(3, "0")}.${extension}`, data.buff, {binary: true});
			});

			if (isCancelled) return;

			zip.generateAsync({type: "blob"})
				.then((content) => {
					if (isCancelled) return;

					this._pDoUpdateProgressBar($wrpProgressBar, `Downloading ZIP...`);
					const filename = item.set && item.artist
						? `${item.set}__${item.artist}`
						: "bulk-images";
					DownloadHelper.saveAs(content, DownloadHelper._sanitizeFilename(filename));
					this._pDoUpdateProgressBar(
						$wrpProgressBar,
						`Download complete.`,
						{isComplete: true}
					);
				});
		} catch (e) {
			setTimeout(() => { throw e; });
			this._pDoUpdateProgressBar(
				$wrpProgressBar,
				`Download failed! Error was: ${e.message} (check the log for more information).`,
				{isError: true}
			);
			this._pDoUpdateQueueAndTriggerNext();
		}
	}

	async downloadZip (...items) {
		if (items.length === 1) this._queue.push(items[0]);
		else {
			const fakeItem = {data: items.map(it => it.data).flat()};
			this._queue.push(fakeItem);
		}

		if (this._queue.length === 1) await this._pDoNextDownload();
	}

	async downloadUrls (...items) {
		const filename = items.length === 1
			? `${items[0].set}__${items[0].artist}`
			: `bulk-urls`;

		const contents = items.map(it => it.data).flat().map(it => it.uri).join("\n");
		const blob = new Blob([contents], {type: "text/plain"});
		DownloadHelper.saveAs(blob, DownloadHelper._sanitizeFilename(filename));
	}

	async downloadJson (...items) {
		const filename = items.length === 1
			? `${items[0].set}__${items[0].artist}`
			: `bulk-jsons`;

		const asJson = items.map(it => ({
			artist: it.artist,
			set: it.set,
			uris: it.data.map(it => it.uri)
		}));

		const contents = JSON.stringify(asJson, null, "\t");
		const blob = new Blob([contents], {type: "application/json"});
		DownloadHelper.saveAs(blob, DownloadHelper._sanitizeFilename(filename));
	}

	static _sanitizeFilename (str) {
		return str.trim().replace(/[^\w-]/g, "_");
	}
}

DownloadHelper.saveAs = function () {
	const view = window;
	let
		doc = view.document
				, get_URL = function () {
			return view.URL || view.webkitURL || view;
		}
		, save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")
		, can_use_save_link = "download" in save_link
		, click = function (node) {
			let event = new MouseEvent("click");
			node.dispatchEvent(event);
		}
		, is_safari = /constructor/i.test(view.HTMLElement) || view.safari
		, is_chrome_ios = /CriOS\/[\d]+/.test(navigator.userAgent)
		, setImmediate = view.setImmediate || view.setTimeout
		, throw_outside = function (ex) {
			setImmediate(function () {
				throw ex;
			}, 0);
		}
		, force_saveable_type = "application/octet-stream"
				, arbitrary_revoke_timeout = 1000 * 40 		, revoke = function (file) {
			let revoker = function () {
				if (typeof file === "string") { 					get_URL().revokeObjectURL(file);
				} else { 					file.remove();
				}
			};
			setTimeout(revoker, arbitrary_revoke_timeout);
		}
		, dispatch = function (filesaver, event_types, event) {
			event_types = [].concat(event_types);
			let i = event_types.length;
			while (i--) {
				let listener = filesaver["on" + event_types[i]];
				if (typeof listener === "function") {
					try {
						listener.call(filesaver, event || filesaver);
					} catch (ex) {
						throw_outside(ex);
					}
				}
			}
		}
		, auto_bom = function (blob) {
									if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
				return new Blob([String.fromCharCode(0xFEFF), blob], {type: blob.type});
			}
			return blob;
		}
		, FileSaver = function (blob, name, no_auto_bom) {
			if (!no_auto_bom) {
				blob = auto_bom(blob);
			}
						let
				filesaver = this
				, type = blob.type
				, force = type === force_saveable_type
				, object_url
				, dispatch_all = function () {
					dispatch(filesaver, "writestart progress write writeend".split(" "));
				}
								, fs_error = function () {
					if ((is_chrome_ios || (force && is_safari)) && view.FileReader) {
												let reader = new FileReader();
						reader.onloadend = function () {
							let url = is_chrome_ios ? reader.result : reader.result.replace(/^data:[^;]*;/, 'data:attachment/file;');
							let popup = view.open(url, '_blank');
							if (!popup) view.location.href = url;
							url = undefined; 							filesaver.readyState = filesaver.DONE;
							dispatch_all();
						};
						reader.readAsDataURL(blob);
						filesaver.readyState = filesaver.INIT;
						return;
					}
										if (!object_url) {
						object_url = get_URL().createObjectURL(blob);
					}
					if (force) {
						view.location.href = object_url;
					} else {
						let opened = view.open(object_url, "_blank");
						if (!opened) {
														view.location.href = object_url;
						}
					}
					filesaver.readyState = filesaver.DONE;
					dispatch_all();
					revoke(object_url);
				};
			filesaver.readyState = filesaver.INIT;

			if (can_use_save_link) {
				object_url = get_URL().createObjectURL(blob);
				setImmediate(function () {
					save_link.href = object_url;
					save_link.download = name;
					click(save_link);
					dispatch_all();
					revoke(object_url);
					filesaver.readyState = filesaver.DONE;
				}, 0);
				return;
			}

			fs_error();
		}
		, FS_proto = FileSaver.prototype
		, saveAs = function (blob, name, no_auto_bom) {
			return new FileSaver(blob, name || blob.name || "download", no_auto_bom);
		};
		if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
		return function (blob, name, no_auto_bom) {
			name = name || blob.name || "download";

			if (!no_auto_bom) {
				blob = auto_bom(blob);
			}
			return navigator.msSaveOrOpenBlob(blob, name);
		};
	}
	FS_proto.abort = function () {};
	FS_proto.readyState = FS_proto.INIT = 0;
	FS_proto.WRITING = 1;
	FS_proto.DONE = 2;
	FS_proto.error =
		FS_proto.onwritestart =
			FS_proto.onprogress =
				FS_proto.onwrite =
					FS_proto.onabort =
						FS_proto.onerror =
							FS_proto.onwriteend =
								null;

	return saveAs;
}();

"use strict";

class ArtBrowser {
	static async pGetJson (url) {
		if (ArtBrowser._JSON_FETCHING[url]) {
			await ArtBrowser._JSON_FETCHING[url];
			return ArtBrowser._JSON_CACHE[url];
		}

		ArtBrowser._JSON_FETCHING[url] = (async () => {
			const response = await fetch(url);
			ArtBrowser._JSON_CACHE[url] = await response.json();
		})();

		await ArtBrowser._JSON_FETCHING[url];
		return ArtBrowser._JSON_CACHE[url];
	}

	static _searchFeatures (searchTerm, item, doLowercase) {
				return (item.features || []).some(x => (doLowercase ? x.toLowerCase() : x).includes(searchTerm));
	}

	static _filterProps (filters, item) {
		if (Object.keys(filters).length) {
			const missingOrUnwanted = Object.keys(filters).find(prop => {
				if (!item[prop]) return true;
				const requiredVals = Object.keys(filters[prop]).filter(k => filters[prop][k]);
				const missingEnum = !!requiredVals.find(x => !item[prop].includes(x));
				const excludedVals = Object.keys(filters[prop]).filter(k => !filters[prop][k]);
				const unwantedEnum = !!excludedVals.find(x => item[prop].includes(x));
				return missingEnum || unwantedEnum;
			});
			if (missingOrUnwanted) return false;
		}
		return true;
	}

	static _filterFakeProps (filterStorage, item, filterProp, prop) {
		const filterState = filterStorage[filterProp];
		const key = item[prop];

								if (filterState && Object.keys(filterState).length) return filterState[key];
		else return true;
	}

	constructor ($parent) {
		this._$parent = $parent.addClass("artr__wrp");
		this._downloadHelper = new DownloadHelper($parent);

		this._index = null;

		this._currentItem = null;
		this._currentIndexItem = null;
		this._search = "";

		this._itemMetas = null;

		this._filtersArtists = {};
		this._filtersSets = {};
		this._filters = {};

		this._itemObservers = [];

		this._$sideBody = null;
		this._$mainBody = null;
		this._$mainHeaderElements = null;
		this._$mainBodyInner = null;
		this._$itemBody = null;
		this._$itemBodyInner = null;
		this._$notificationBody = null;
		this._$wrpBread = null;
	}

	_handleHashChange () {
		const key = window.location.hash.slice(1);
		if (key && this._index[key]) {
			const indexItem = this._index[key];

			ArtBrowser.pGetJson(`${Const.GH_PATH}${indexItem._key}.json`)
				.then(file => {
					this._currentItem = file;
					this._currentIndexItem = indexItem;
					this._doRenderItem(true);
				});
		} else {
			this._doRenderIndex();
		}
	}

	_updateCrumbs () {
		this._$wrpBread.empty();
		const $txtIndex = $(`<a href="#" class="artr__crumb">Index</a>`)
			.appendTo(this._$wrpBread);

		if (this._currentItem) {
			const $txtSlash = $(`<span class="artr__crumb--sep">/</span>`).appendTo(this._$wrpBread);
			const $txtItem = $(`<a href="#${this._currentIndexItem._key}" class="artr__crumb">${this._currentItem.set} \u2013 ${this._currentItem.artist}</a>`)
				.appendTo(this._$wrpBread);
		}
	}

		_getSearchTerms () {
		const str = this._search.toLowerCase().trim();

		const len = str.length;
		const out = [];
		let stack = "";
		let inQuotes = false;

		for (let i = 0; i < len; ++i) {
			const c = str[i];
			switch (c) {
				case `"`: {
					if (inQuotes && stack && stack.trim()) {
						out.push(stack.trim());
						stack = "";
					}
					inQuotes = !inQuotes;
					break;
				}
				default: stack += c;
			}
		}

				if (stack && stack.trim()) out.push(stack.trim());

		return out;
	}

	_applyFilterAndSearchToIndex () {
		this._search = this._search.toLowerCase();

				if (Object.keys(this._filtersArtists).length === 0
			&& Object.keys(this._filtersSets).length === 0
			&& Object.keys(this._filters).length === 0
			&& this._search.replace(/"/g, "").length < 2) return [];

		return Object.values(this._index).filter(it => {
			if (this._search) {
				const searchTerms = this._getSearchTerms();

				const lowerSet = it._set.toLowerCase();
				const isSetMatch = searchTerms.every(srch => lowerSet.includes(srch));

				const lowerArtist = it._artist.toLowerCase();
				const isArtistMatch = searchTerms.every(srch => lowerArtist.includes(srch));

				const isFeatureMatch = searchTerms.every(srch => ArtBrowser._searchFeatures(srch, it));

				if (!isSetMatch && !isArtistMatch && !isFeatureMatch) return false;
			}
			if (!ArtBrowser._filterFakeProps(this._filtersArtists, it, Const.FAKE_FILTER_ARTIST, "_artist")) return false;
			if (!ArtBrowser._filterFakeProps(this._filtersSets, it, Const.FAKE_FILTER_SET, "_set")) return false;
			if (!ArtBrowser._filterProps(this._filters, it)) return false;
			return true;
		});
	}

	_doRenderIndex () {
		const indexSlice = this._applyFilterAndSearchToIndex();

		this._currentItem = false;
		this._currentIndexItem = false;
		this._$mainBody.showVe();
		(this._$mainHeaderElements || []).forEach(it => it.showVe());
		this._$itemBody.hideVe();
		this._$mainBodyInner.empty();
		this._itemMetas = null;
		this._updateCrumbs();

		if (!indexSlice.length) {
			$(`<div class="artr__no_results_wrp"><div class="artr__no_results"><div class="text-center"><span class="artr__no_results_headline">No results found</span><br>Please adjust the filters (on the left) or refine your search (above).</div></div></div>`)
				.appendTo(this._$mainBodyInner);
		} else {
			this._itemMetas = indexSlice.map(it => {
				const $cbSel = $(`<input type="checkbox" class="mr-2 artr__item__cb-select">`)
					.change(() => {
						$itemBottom.toggleClass("artr__item__bottom--selected", $cbSel.prop("checked"));
					});

				let isExpanded = false;
				const $btnToggleExpanded = $(`<div class="clickable mr-2 artr__item__btn-toggle-expand">[+]</div>`)
					.click(() => {
						isExpanded = !isExpanded;
						$btnToggleExpanded.toggleClass("active", isExpanded);
						$itemTop.toggleClass("artr__item__top--expanded", isExpanded);
						$btnToggleExpanded.text(isExpanded ? "[\u2013]" : "[+]");
					});

				const $dispName = $(`<div class="clickable mr-2">${it._set} <i>by</i> ${it._artist} (${it._size.toLocaleString()} images)</div>`)
					.click(() => $cbSel.prop("checked", !$cbSel.prop("checked")));

				const $itemBottom = $$`<div class="artr__item__bottom ve-flex-v-center">
					${$cbSel}
					${$btnToggleExpanded}
					${$dispName}
					<a href="#${it._key}" class="artr__item__lnk-view">View</a>
				</div>`;

												const $itemTop = $(`<div class="artr__item__top"><img src="${Const.IMG_LAZY_180}"></div>`);

				const $item = $$`<div class="artr__item ve-flex-col">
					${$itemBottom}
					${$itemTop}
				</div>`
					.appendTo(this._$mainBodyInner);

				return {
					$item,
					$cbSel,
					fnHandleChangeCbAll: value => $itemBottom.toggleClass("artr__item__bottom--selected", value),
					key: it._key,
					fnOnIntersect: this._loadItemThumbnails.bind(this, $itemTop, it._key)
				};
			});

			this._addScrollHandlers();
		}
	}

	_loadItemThumbnails ($itemTop, key) {
		const indexItem = this._index[key];

		ArtBrowser.pGetJson(`${Const.GH_PATH}${indexItem._key}.json`)
			.then(async file => {
				$itemTop.empty();

				const intersectionMetas = [];

				file.data.sort((a, b) => SortUtil$1.ascSortLower(a.uri, b.uri));

				for (const it of file.data) {
					const $img = $(`<img class="artr__item__thumbnail" src="${Const.IMG_LAZY_180}">`);
					const urlThumb = `${Const.GH_PATH}${indexItem._key}--thumb-${it.hash}.jpg`;

					const $btns = await this._p$getBtnsItemThumbnail(it);

					const $lnk = $$`<a href="${it.uri}" target="_blank" class="artr__item__lnk-fullsize" draggable="true">${$img}</a>`
						.on("dragstart", evt => {
							const meta = {
								type: "ve-Art",
								uri: it.uri
							};
							evt.originalEvent.dataTransfer.setData("application/json", JSON.stringify(meta));
						});

					$$`<div class="artr__item__wrp relative">
						${$lnk}
						<div class="artr__item__menu">${$btns}</div>
					</div>`
						.appendTo($itemTop);

					intersectionMetas.push({eleImg: $img[0], urlThumb});
				}

				this._addHorizontalScrollHandler(intersectionMetas);
			});
	}

	async _p$getBtnsItemThumbnail (meta) {
		const $btnCopyUrl = $(`<div class="artr__item__menu_item" title="Copy URL"><span class="fas fa-link"></span></div>`)
			.click(async (evt) => {
				evt.stopPropagation();
				evt.preventDefault();

				await MiscUtil$1.pCopyTextToClipboard(meta.uri);
				MiscUtil$1.showCopiedEffect($btnCopyUrl, "Copied URL!");
			});

		const $btnSupport = meta.support
			? $(`<a class="artr__item__menu_item" href="${meta.support}" target="_blank" title="Support Artist"><span class="fas fa-shopping-cart"></span></a>`)
			: null;

		return [$btnCopyUrl, $btnSupport];
	}

	_doRenderItem (resetScroll) {
		this._$mainBody.hideVe();
		(this._$mainHeaderElements || []).forEach(it => it.hideVe());
		this._$itemBody.showVe();
		this._$itemBodyInner.empty();
		this._updateCrumbs();
		if (resetScroll) this._$itemBodyInner.scrollTop(0);

		const $eles = this._currentItem.data
			.sort((a, b) => SortUtil$1.ascSortLower(a.uri, b.uri))
			.map(it => {
				const urlThumb = `${Const.GH_PATH}${this._currentIndexItem._key}--thumb-${it.hash}.jpg`;

				const $btnCopyUrl = $(`<div class="artr__item__menu_item" title="Copy URL"><span class="fas fa-link"></span></div>`)
					.click(async (evt) => {
						evt.stopPropagation();
						evt.preventDefault();

						await MiscUtil$1.pCopyTextToClipboard(it.uri);
						MiscUtil$1.showCopiedEffect($btnCopyUrl, "Copied URL!");
					});

				const $btnSupport = it.support
					? $(`<a class="artr__item__menu_item" href="${it.support}" target="_blank" title="Support Artist"><span class="fas fa-shopping-cart"></span></a>`)
					: null;

				const $lnk = $$`<a href="${it.uri}" target="_blank" class="artr__item__lnk-fullsize" draggable="true">
					<img class="artr__item__thumbnail" src="${urlThumb}">
				</a>`
					.on("dragstart", evt => {
						const meta = {
							type: "ve-Art",
							uri: it.uri
						};
						evt.originalEvent.dataTransfer.setData("application/json", JSON.stringify(meta));
					});

				return $$`<div class="artr__item__wrp relative">
					${$lnk}
					<div class="artr__item__menu">${$btnCopyUrl}${$btnSupport}</div>
				</div>`;
			});

		const $wrpItem = $$`<div class="artr__item__top artr__item__top--expanded artr__item__top--expanded-sub-page">
			${$eles}
		</div>`;

		const $btnDownload = $(`<button class="artr__btn-lg artr__btn-primary">Download</button>`)
			.click(() => this._pHandleDownloadClick([this._currentIndexItem], {isSingleMode: true}));

		$$`<div class="ve-flex-col w-100 h-100">
			<div class="artr__item__bottom ve-flex-v-center">
				<div class="mr-2">${this._currentIndexItem._set} <i>by</i> ${this._currentIndexItem._artist} (${(this._currentIndexItem._size || 0).toLocaleString()} images)</div>
				${$btnDownload}
			</div>
			${$wrpItem}
		</div>`.appendTo(this._$itemBodyInner);
	}

	_addSidebarSection (propOrHeader, values, filterStorage, fnSort, ix) {
		const isInitialShowing = !ix; 
		const fullName = (() => {
			switch (propOrHeader) {
				case "imageType": return "Image Type";
				case "grid": return "Grid Type";
				case "monster": return "Monster Type";
				case "audience": return "Intended Audience";
				default: return propOrHeader.uppercaseFirst();
			}
		})();

		const $dispToggle = $(`<div>${isInitialShowing ? "[\u2013]" : "[+]"}</div>`);
		const $wrpHead = $$`<div class="artr__side__tag_header mb-1">
			<div>${fullName}</div>
			${$dispToggle}
		</div>`
			.appendTo(this._$sideBody)
			.click(() => {
				$wrpBody.toggleVe();
				$dispToggle.html($dispToggle.html() === "[+]" ? "[\u2013]" : "[+]");
			});

		const getNextState = (state, dir) => {
			const ix = Const.STATES.indexOf(state) + dir;
			if (ix > Const.STATES.length - 1) return Const.STATES[0];
			if (ix < 0) return Const.STATES.last();
			return Const.STATES[ix];
		};

		values.sort(fnSort);
		const btnMetas = values.map(enm => {
			const cycleState = dir => {
				const nxtState = getNextState($btn.attr("data-state"), dir);
				$btn.attr("data-state", nxtState);

				if (nxtState === "0") {
					delete filterStorage[propOrHeader][enm.v];
					if (!Object.keys(filterStorage[propOrHeader]).length) delete filterStorage[propOrHeader];
				} else (filterStorage[propOrHeader] = filterStorage[propOrHeader] || {})[enm.v] = nxtState === "1";

				this._handleHashChange();
			};

			const $btn = $(`<button class="artr__side__tag" data-state="0">${enm.v} (${enm.c})</button>`)
				.click(() => cycleState(1))
				.contextmenu((evt) => {
					if (!evt.ctrlKey) {
						evt.preventDefault();
						cycleState(-1);
					}
				});

			return {
				$btn,
				searchText: (enm.v || "").trim().toLowerCase()
			}
		});

		const $iptSearch = $(`<input placeholder="Filter...">`)
			.change(() => {
				const searchVal = $iptSearch.val().trim().toLowerCase();

				if (!searchVal) btnMetas.forEach(it => it.$btn.showVe());
				else btnMetas.forEach(it => it.$btn.toggleVe(it.searchText.includes(searchVal)));
			});

		const $wrpBody = $$`<div class="ve-flex-col">
			<div class="pb-1 px-1 artr__side__wrp-tag-filter">${$iptSearch}</div>
			<div class="artr__side__tag-grid pb-1 mb-1">${btnMetas.map(it => it.$btn)}</div>
		</div>`
			.toggleVe(isInitialShowing)
			.appendTo(this._$sideBody);
	}

	_addFakeSidebarSection (title, propToCount, filterStorage) {
		const fakeValues = Object.keys(propToCount).sort(SortUtil$1.ascSort).map(it => ({v: it, c: propToCount[it]})); 		this._addSidebarSection(title, fakeValues, filterStorage, (a, b) => SortUtil$1.ascSortLower(a.v, b.v), true); 	}

	async pInit () {
		const $win = $(`<div class="artr__win"></div>`)
			.appendTo(this._$parent);

		const $dispLoadingSidebar = $(`<div class="artr__side__loading" title="Caching repository data, this may take some time">Loading...</div>`);

		const [enums, index] = await Promise.all([ArtBrowser.pGetJson(`${Const.GH_PATH}_meta_enums.json`), ArtBrowser.pGetJson(`${Const.GH_PATH}_meta_index.json`)]);
		this._index = index;

		Object.keys(this._index).forEach(k => this._index[k]._key = k);

		window.addEventListener("hashchange", this._handleHashChange.bind(this));

				const $dispToggleSidebar = $(`<div>[\u2013]</div>`);
		const $sideHead = $$`<div class="artr__side__head split-v-center clickable">
			<div class="artr__side__head__title">Filters</div>
			${$dispToggleSidebar}
		</div>`
			.click(() => {
				$dispToggleSidebar.html($dispToggleSidebar.html() === "[+]" ? "[\u2013]" : "[+]");
				$sidebar.toggleClass("artr__side--minimized");
				this._$sideBody.toggleVe();
			});

		this._$sideBody = $(`<div class="artr__side__body"></div>`);

		const $sidebar = $$`<div class="artr__side">
			${$dispLoadingSidebar}

			${$sideHead}
			${this._$sideBody}
		</div>`.appendTo($win);

				const artists = {};
		const sets = {};
		Object.values(this._index).forEach(it => {
			artists[it._artist] = artists[it._artist] || 0;
			artists[it._artist] += it._size;
			sets[it._set] = sets[it._set] || 0;
			sets[it._set] += it._size;
		});

		this._addFakeSidebarSection(Const.FAKE_FILTER_ARTIST, artists, this._filtersArtists);
		this._addFakeSidebarSection(Const.FAKE_FILTER_SET, sets, this._filtersSets);
		Object.keys(enums).forEach((k, i) => this._addSidebarSection(k, enums[k], this._filters, (a, b) => SortUtil$1.ascSort(b.c, a.c), i));
		
				const $mainPane = $(`<div class="artr__main"></div>`).appendTo($win);

		const $dispLoadingMain = $(`<div class="artr__main__loading" title="Caching repository data, this may take some time">Loading...</div>`).appendTo($mainPane);

		this._$wrpBread = $(`<div class="artr__bread"></div>`);
		this._updateCrumbs();

		this._pInit_renderHeader({$mainPane});

		this._$mainBody = $(`<div class="artr__view"></div>`).appendTo($mainPane);
		this._$mainBodyInner = $(`<div class="artr__view_inner"></div>`).appendTo(this._$mainBody);

		this._$itemBody = $(`<div class="artr__view"></div>`).hideVe().appendTo($mainPane);
		this._$itemBodyInner = $(`<div class="artr__view_inner"></div>`).appendTo(this._$itemBody);

		this._$notificationBody = $(`<div class="artr__stg-notifs"></div>`).hideVe().appendTo($mainPane);

		this._handleHashChange();

		[
			$dispLoadingSidebar,
			$dispLoadingMain
		].forEach($l => $l.remove());
		
		await this._pInit_pOnComplete();
	}

	
	_pInit_renderHeader ({$mainPane}) {
		const $cbAll = this._pInit_renderHeader_$getCbAll();

		const $btnDownloadSelected = this._pInit_renderHeader_$getBtnDownloadSelected();

		const $wrpHeaderControlsMain = $$`<div class="ve-flex-v-center no-shrink">
			${$cbAll}
			${$btnDownloadSelected}
		</div>`;
		const $spcHeaderControlsMain = $(`<div class="artr__search__divider mx-2"></div>`);
		this._$mainHeaderElements = [$wrpHeaderControlsMain, $spcHeaderControlsMain];

		const $iptSearch = this._pInit_renderHeader_$getIptSearch();
		const $sldThumbnailSize = this._pInit_renderHeader_$getSldThumbnailSize();

		$$`<div class="p-2 artr__search ve-flex-v-center">
			${$wrpHeaderControlsMain}
			${$spcHeaderControlsMain}
			<div class="ve-flex-col w-100">
				${this._$wrpBread}
				${$iptSearch}
			</div>
			<div class="ve-flex-v-center h-100">
				<div class="artr__search__divider mx-2"></div>
				<div class="ve-flex-col ve-flex-vh-center">
					<div class="mb-1">Thumbnail Size</div>
					${$sldThumbnailSize}
				</div>
			</div>
			${this._pInit_renderHeader_getAdditionalElements()}
		</div>`.appendTo($mainPane);
	}

	_pInit_renderHeader_$getCbAll () {
		const $cbAll = $(`<input type="checkbox" class="mr-2 artr__item__cb-select artr__item__cb-select--all">`)
			.change(() => {
				if (!this._itemMetas) return;
				const toVal = $cbAll.prop("checked");
				this._itemMetas.forEach(it => {
					it.$cbSel.prop("checked", toVal);
					it.fnHandleChangeCbAll(toVal);
				});
			});

		return $cbAll;
	}

	_pInit_renderHeader_$getBtnDownloadSelected () {
		return $(`<button class="artr__btn-lg artr__btn-primary" title="Download ZIP (SHIFT to download a text file of URLs)">Download Selected</button>`)
			.click(() => {
				if (!this._itemMetas) return;
				const selected = this._itemMetas.filter(it => it.$cbSel.prop("checked"));
				if (!selected.length) return alert(`Please select some items to download!`);
				const indexItems = selected.map(it => this._index[it.key]);
				return this._pHandleDownloadClick(indexItems);
			});
	}

	_pInit_renderHeader_$getIptSearch () {
		let searchTimeout;
		const doSearch = () => {
			this._search = ($iptSearch.val() || "").trim();
			this._handleHashChange();
		};
		const $iptSearch = $(`<input placeholder="Search..." class="artr__search__field">`)
			.title(`Multiple search terms can be provided by using quotes, e.g.: "ship" "pirate"`)
			.on("keydown", (e) => {
				clearTimeout(searchTimeout);
				if (e.which === 13) doSearch();
				else searchTimeout = setTimeout(() => { doSearch(); }, 100);
			});

		return $iptSearch;
	}

	_pInit_renderHeader_$getSldThumbnailSize () {
		let $style = $(`#${ArtBrowser._ID_STYLE_THUMBNAILS}`);
		if (!$style.length) {
			$style = $(`<style id="${ArtBrowser._ID_STYLE_THUMBNAILS}"></style>`).appendTo(document.body);
		}

		let lastThumbnailSize = null;
		const hkThumbnailSize = () => {
			const sliderVal = $sldThumbnailSize.val();
			const size = Math.round(ArtBrowser._SZ_PX_THUMBNAIL * (sliderVal / 100));

			if (lastThumbnailSize === size) return;
			lastThumbnailSize = size;

			$style.html(`
.artr__wrp .artr__item__top {
    height: ${size + ArtBrowser._SZ_PX_MAIN_ROW_HEADER}px;
}

.artr__wrp .artr__item__top--expanded {
	height: initial;
}

.artr__wrp .artr__item__thumbnail {
	min-width: ${size}px;
	min-height: ${size}px;
	max-width: ${size}px;
	max-height: ${size}px;
}`);
			StorageUtil$1.syncSet(ArtBrowser._STORAGE_KEY_THUMBNAIL_SIZE, sliderVal);
		};
		const $sldThumbnailSize = $(`<input type="range" min="25" max="200" title="Thumbnail Size">`)
			.mousemove(evt => {
				if (evt.currentTarget !== $sldThumbnailSize[0]) return;
				hkThumbnailSize();
			})
			.change(() => {
				hkThumbnailSize();
			});
		let savedThumbnailSize = StorageUtil$1.syncGet(ArtBrowser._STORAGE_KEY_THUMBNAIL_SIZE);
		if (savedThumbnailSize != null) {
			$sldThumbnailSize.val(Math.min(200, Math.max(25, savedThumbnailSize)));
			hkThumbnailSize();
		}

		return $sldThumbnailSize;
	}

		_pInit_renderHeader_getAdditionalElements () {  }

	
		async _pInit_pOnComplete () {  }

	
		async _pHandleDownloadClick (indexItems, opts) {
		opts = opts || {};

		const {$modalInner, doClose} = this._$getShowModal();

		$modalInner
			.addClass("ve-flex-vh-center")
			.append(`<div class="ve-flex-vh-center"><i>Collecting data...</i></div>`);

		const jsons = await Promise.all(indexItems.map(indexItem => ArtBrowser.pGetJson(`${Const.GH_PATH}${indexItem._key}.json`)));

		$modalInner.empty();

		const options = await this._pGetDownloadModes();

		const $selMode = $(`<select>
			${options.map((it, ix) => `<option value="${ix}" ${ix === 0 ? "selected" : ""}>${it.name}</option>`).join("")}
		</select>`)
			.change(() => {
				if (!$wrpCb) return;
				const option = options[Number($selMode.val())];
				$wrpCb.toggleVe(!option.isMultipleFilesOnly);
			});

		const $cbFilePerItem = $(`<input type="checkbox" checked>`);

		const $btnDownload = $(`<button class="artr__btn-lg artr__btn-primary">Download</button>`)
			.click(async () => {
				doClose();

				try {
					const isSingleFile = !$cbFilePerItem.prop("checked");
					const option = options[Number($selMode.val())];

					if (isSingleFile && !option.isMultipleFilesOnly) {
						await option.pDownloadAsSingleFile(...jsons);
					} else {
						const len = jsons.length;
						for (let i = 0; i < len; ++i) {
							const json = jsons[i];
							await option.pDownloadAsMultipleFiles(json, i, len);
							await MiscUtil$1.pDelay(33);
						}
					}
				} catch (e) {
					alert(`Download failed! See the console (CTRL+SHIFT+J) for details.`);
					throw e;
				}
			});

		const $wrpCb = indexItems.length > 1 ? $$`<label class="p-0 m-0 mb-2 ve-flex-v-center" title="If the download should be a single file per selected item, as opposed to the default of one file containing all items."><div class="mr-2">One file per item</div>${$cbFilePerItem}</label>` : null;
		$selMode.change();

		$$`<div class="ve-flex-col">
			${opts.isSingleMode ? "" : `<div class="ve-flex-v-center mb-2"><i>${indexItems.length} item${indexItems.length === 1 ? "" : "s"} selected</i></div>`}
			<label class="p-0 m-0 mb-2 ve-flex-v-center"><div class="mr-2">Format</div>${$selMode}</label>
			${$wrpCb}
			<div class="ve-flex-vh-center mt-auto w-100">${$btnDownload}</div>
		</div>`.appendTo($modalInner);
	}

	
	get _textDownloadMode () {
		return {
			name: "Text",
			pDownloadAsSingleFile: (jsons) => this._downloadHelper.downloadUrls(...jsons),
			pDownloadAsMultipleFiles: (json) => this._downloadHelper.downloadUrls(json)
		};
	}

	get _jsonDownloadMode () {
		return {
			name: "JSON",
			pDownloadAsSingleFile: (jsons) => this._downloadHelper.downloadJson(...jsons),
			pDownloadAsMultipleFiles: (json) => this._downloadHelper.downloadJson(json)
		};
	}

		async _pGetDownloadModes () {
		return [
			this._textDownloadMode,
			this._jsonDownloadMode,
			{
				name: "ZIP (Warning: rate-limited)",
				pDownloadAsSingleFile: (jsons) => this._downloadHelper.downloadZip(...jsons),
				pDownloadAsMultipleFiles: (json) => this._downloadHelper.downloadZip(json)
			}
		]
	}

	
	_$getShowModal () {
		const doClose = () => {
			$wrpOverlay.remove();
		};

		const $wrpModal = $(`<div class="ve-flex-col artr__modal__wrp p-2"></div>`);
		const $wrpOverlay = $$`<div class="ve-flex-vh-center artr__modal__overlay">${$wrpModal}</div>`
			.click(evt => {
				if (evt.target === $wrpOverlay[0]) doClose();
			})
			.appendTo(this._$parent);

		return {$modalInner: $wrpModal, doClose};
	}

	
	_addScrollHandlers () {
		const config = {
			rootMargin: "0px 0px",
			threshold: 0.01
		};

		this._itemObservers.forEach(it => it.disconnect());
		this._itemObservers = [];

		this._itemMetas.forEach(meta => {
			const observer = new IntersectionObserver(
				obsEntries => {
					obsEntries.forEach(entry => {
						if (entry.intersectionRatio > 0) { 							observer.unobserve(entry.target);

							meta.fnOnIntersect();
						}
					});
				},
				config
			);

			observer.observe(meta.$item[0]);
			this._itemObservers.push(observer);
		});
	}

	_addHorizontalScrollHandler (intersectionMetas) {
		const observer = new IntersectionObserver(
			obsEntries => {
				obsEntries.forEach(entry => {
					if (entry.intersectionRatio > 0) { 						const eleImg = entry.target;
						observer.unobserve(eleImg);

						const meta = intersectionMetas.find(meta => meta.eleImg === eleImg);
						if (!meta) return; 						meta.eleImg.src = meta.urlThumb;
					}
				});
			},
			{
				rootMargin: "0px 0px",
				threshold: 0.01
			}
		);

		intersectionMetas.forEach(meta => observer.observe(meta.eleImg));
	}

	
	doShowNotification ({content, pFnOnDismiss = null}) {
		this._$notificationBody.showVe();

		const $btnDismiss = $(`<button class="artr__btn-lg artr__btn-dismiss-notif" title="Dismiss">×</button>`)
			.click(evt => {
				evt.stopPropagation();
				$notif.remove();
				this._$notificationBody.hideVe();
				if (pFnOnDismiss) pFnOnDismiss();
			});

		const $notif = $$`<div class="artr__notif">
			<div class="artr__notif-wrp-content">${content}</div>
			${$btnDismiss}
		</div>`
			.appendTo(this._$notificationBody);
	}
}
ArtBrowser._JSON_CACHE = {};
ArtBrowser._JSON_FETCHING = {};
ArtBrowser._ID_STYLE_THUMBNAILS = "artr__style__thumbnails";
ArtBrowser._SZ_PX_MAIN_ROW_HEADER = 18;
ArtBrowser._SZ_PX_THUMBNAIL = 180;
ArtBrowser._STORAGE_KEY_THUMBNAIL_SIZE = "artr__style__thumbnails";

class UtilCollection {
	static getChildMeta (childEntityType) {
		const iconClass = CONFIG[childEntityType]?.sidebarIcon || `fas fa-file`; 		const collectionProp = childEntityType === "Item" ? "items" : "pages";
		return {
			iconClass,
			collectionProp,
		};
	}
}

class UtilEvents {
	static init () {
		this.bindDocumentHandlers();
	}

	static bindDocumentHandlers ({element = document.body} = {}) {
		$(element)
			.on(`click`, `[data-packed-dice]`, function (evt) {
				const $this = $(this);
												if (!$this.attr("onclick")) Renderer.dice.pRollerClickUseData(evt, this);
			})

									.on(`mouseover`, `[data-plut-hover]`, function (evt) {
				const isPreload = !!evt.currentTarget.dataset.plutHoverPreload;
				const preloadUid = evt.currentTarget.dataset.plutHoverPreloadUid;
				const page = evt.currentTarget.dataset.plutHoverPage;
				const source = evt.currentTarget.dataset.plutHoverSource;
				let hash = evt.currentTarget.dataset.plutHoverHash;
				const preloadId = evt.currentTarget.dataset.plutHoverPreloadId;
				const hashPreEncoded = !!evt.currentTarget.dataset.plutHoverHashPreEncoded;
				const pageHover = evt.currentTarget.dataset.plutHoverPageHover || page;
				let hashHover = evt.currentTarget.dataset.plutHoverHashHover;
				const hashPreEncodedHover = !!evt.currentTarget.dataset.plutHoverHashPreEncodedHover;
				const subhashesHover = evt.currentTarget.dataset.plutHoverSubhashesHover;
				const isFauxPage = evt.currentTarget.dataset.plutHoverIsFauxPage;

				if (isPreload) {
					if (preloadId == null) return;
					const preloadOptions = evt.currentTarget.dataset.plutHoverPreloadOptions;
					Renderer.hover.handlePredefinedMouseOver(evt, this, preloadId, preloadOptions ? JSON.parse(preloadOptions) : undefined);
					return;
				}

				if (!pageHover || !source || !hash) return;

				if (!hashPreEncoded) hash = UrlUtil.encodeForHash(hash);
				if (hashHover && !hashPreEncodedHover) hashHover = UrlUtil.encodeForHash(hashHover);
				if (!hashHover) hashHover = hash;

				if (subhashesHover) {
					const parsed = JSON.parse(subhashesHover);
					hashHover += Renderer.utils.getLinkSubhashString(parsed);
				}

				const hoverMeta = {
					page: pageHover,
					source: source,
					hash: hashHover,
					preloadId: preloadId,
										isDelay: !!evt.currentTarget.dataset.plutRichLink,
					isFauxPage: !!isFauxPage,
				};
				Renderer.hover.pHandleLinkMouseOver(evt, this, hoverMeta).then(null);
			})
			.on(`mouseleave`, `[data-plut-hover]`, function (evt) {
				Renderer.hover.handleLinkMouseLeave(evt, this);
			})
			.on(`mousemove`, `[data-plut-hover]`, function (evt) {
				Renderer.hover.handleLinkMouseMove(evt, this);
			})
			
						.on(`dragstart`, `[data-plut-rich-link]`, function (evt) {
				
				const entityType = evt.currentTarget.dataset.plutRichLinkEntityType;
				const page = evt.currentTarget.dataset.plutHoverPage;
				const source = evt.currentTarget.dataset.plutHoverSource;
				let hash = evt.currentTarget.dataset.plutHoverHash;
				const hashPreEncoded = !!evt.currentTarget.dataset.plutHoverHashPreEncoded;
				const subhashesHover = evt.currentTarget.dataset.plutHoverSubhashesHover;

				if (!page || !source || !hash || !entityType) return;

				if (!hashPreEncoded) hash = UrlUtil.encodeForHash(hash);

				if (subhashesHover) {
					const parsed = JSON.parse(subhashesHover);
					hash += Renderer.utils.getLinkSubhashString(parsed);
				}

				evt.stopPropagation();
				evt.originalEvent.dataTransfer.setData(
					"text/plain",
					JSON.stringify({
						type: entityType,
						subType: UtilEvents.EVT_DATA_SUBTYPE__HOVER,
						page,
						source,
						hash,
						originalText: evt.currentTarget.dataset.plutRichLinkOriginalText,
					}),
				);
			})
					;

		Renderer.events.bindGeneric({element});

		UtilEvents._ADDITIONAL_DOCUMENT_HANDLERS.forEach(({eventType, selector, fnEvent}) => this._doBindHandler({element, eventType, selector, fnEvent}));

		UtilEvents._BOUND_DOCUMENT_ELEMENTS.add(element);
	}

	static registerDocumentHandler ({eventType, selector, fnEvent}) {
		UtilEvents._ADDITIONAL_DOCUMENT_HANDLERS.push({eventType, selector, fnEvent});
		UtilEvents._BOUND_DOCUMENT_ELEMENTS.forEach(element => this._doBindHandler({element, eventType, selector, fnEvent}));
	}

	static _doBindHandler ({element, eventType, selector, fnEvent}) {
		$(element).on(eventType, selector, fnEvent);
	}

	static unbindDocumentHandlers ({element = document.body} = {}) {
				UtilEvents._BOUND_DOCUMENT_ELEMENTS.delete(element);
	}

	static getDropJson (evt) {
		let data;
		for (const mimeType of UtilEvents._MIME_TYPES_DROP_JSON) {
			if (!evt.dataTransfer.types.includes(mimeType)) continue;

			try {
				const rawJson = evt.dataTransfer.getData(mimeType);
				if (!rawJson) return;
				data = JSON.parse(rawJson);
			} catch (e) {
							}
		}
		return data;
	}
}
UtilEvents._MIME_TYPES_DROP_JSON = ["application/json", "text/plain"];
UtilEvents.EVT_DATA_SUBTYPE__HOVER = `${SharedConsts.MODULE_ID_FAKE}.Hover`;
UtilEvents.EVT_DATA_SUBTYPE__IMPORT = `${SharedConsts.MODULE_ID_FAKE}.Import`;

UtilEvents._BOUND_DOCUMENT_ELEMENTS = new Set();
UtilEvents._ADDITIONAL_DOCUMENT_HANDLERS = [];

class UtilImage {
	static pLoadImage (uri) {
		return new Promise((resolve, reject) => {
			const img = new Image();
			img.onerror = err => reject(err);
			img.onload = () => resolve(img);
			img.src = uri;
		});
	}

	
	static _CACHE_TEMP_IMAGE = {};

	static async pLoadTempImage (uri, {isCacheable = false} = {}) {
		if (UtilImage._CACHE_TEMP_IMAGE[uri]) return UtilImage._CACHE_TEMP_IMAGE[uri];

		const imgReq = await fetch(uri);
		const imgBlob = await imgReq.blob();

		const img = new Image();
		let resolve = null;
		const pImgLoad = new Promise(resolve_ => resolve = resolve_);
		img.onload = () => resolve();
		img.src = URL.createObjectURL(imgBlob);
		await pImgLoad;

		if (isCacheable) UtilImage._CACHE_TEMP_IMAGE[uri] = img;

		return img;
	}

	
	static async pDrawTextGetBlob (
		{
			text,
			img,
			bbX0,
			bbX1,
			bbY0,
			bbY1,
			color,
			font,
			isBold,
		},
	) {
		const cnv = document.createElement("canvas");
		cnv.width = img.width;
		cnv.height = img.height;
		const ctx = cnv.getContext("2d");
		ctx.drawImage(img, 0, 0);

		ctx.shadowColor = "#000000";
		ctx.shadowBlur = 14;

		ctx.fillStyle = color;
		ctx.font = `${isBold ? "bold" : ""} ${bbY1 - bbY0}px ${font}`;
		ctx.textAlign = "center";
		ctx.textBaseline = "middle";
		ctx.fillText(
			text,
			bbX0 + ((bbX1 - bbX0) / 2),
			bbY0 + ((bbY1 - bbY0) / 2),
			bbX1 - bbX0,
		);

		return new Promise(resolve => {
			cnv.toBlob(blob => resolve(blob), "image/png");
		});
	}

	
	static isDefaultActorImage (img) { return img.toLowerCase().includes("mystery-man.svg"); }
	static isDefaultItemImage (img) { return img.toLowerCase().includes("item-bag.svg"); }
}

class ArtBrowserFvtt extends ArtBrowser {
	constructor ($parent, {app}) {
		super($parent);

		this._parent = app;
		this._$btnCycleImportMode = null;
	}

	async _pGetDownloadModes () {
		const out = [
			this._textDownloadMode,
			this._jsonDownloadMode,
		];

		if (await UtilBackend.pGetBackendVersion()) {
			out.unshift({
				name: "Foundry Assets",
				isMultipleFilesOnly: true,
				pDownloadAsMultipleFiles: (json, ix, len) => this._parent._activateListeners_pHandleDownloadAssets(json, ix, len),
			});
		}

		return out;
	}

	async _p$getBtnsItemThumbnail (meta) {
		const $out = await super._p$getBtnsItemThumbnail(meta);

		if (!await UtilBackend.pGetBackendVersion()) return $out;

		const $btnDownloadSingle = $(`<div class="artr__item__menu_item" title="Download Image"><span class="fas fa-fw fa-download"></span></div>`)
			.click(async (evt) => {
				evt.stopPropagation();
				evt.preventDefault();

				await this._parent.doDownloadSingleImage_(meta);
			});

		return [...$out, $btnDownloadSingle];
	}

	
	_pInit_renderHeader_getAdditionalElements () {
				const $btnCancelPackDownload = $(`<button class="artr__btn-lg artr__btn-lg--search-controls mr-1" title="Cancel running downloads"><span class="fas fa-fw fa-stop"></span></button>`)
			.click(() => ArtBrowserApp._doCancelPackDownload());

		this._$btnCycleImportMode = $(`<button class="artr__btn-lg artr__btn-lg--search-controls mr-1"><span class="fas fa-fw fa-spinner"></span></button>`)
			.click(() => {
				const prevMode = Config.get("artBrowser", "importImagesAs") || 0;
				const nxtMode = prevMode === ConfigConsts.C_ART_IMAGE_MODE_SCENE
					? ConfigConsts.C_ART_IMAGE_MODE_TOKEN
					: prevMode + 1;
				Config.set("artBrowser", "importImagesAs", nxtMode);
			});

		const $btnOpenConfig = $(`<button class="artr__btn-lg artr__btn-lg--search-controls" title="Open ${Config.get("ui", "isStreamerMode") ? "" : "Plutonium "}Config window"><span class="fas fa-fw fa-cogs"></span></button>`)
			.click(evt => Config.pHandleButtonClick(evt, "artBrowser"));

		return [
			$$`<div class="artr__search__divider mx-2"></div>`,
			$$`<div class="ve-flex-v-center">${$btnCancelPackDownload}</div>`,
			$$`<div class="ve-flex-v-center">${this._$btnCycleImportMode}</div>`,
			$$`<div class="ve-flex-v-center">${$btnOpenConfig}</div>`,
		];
	}

	
	handleInstanceConfigUpdate () {
		this._handleInstanceConfigUpdate_cycleImportModeButton();
	}

	_handleInstanceConfigUpdate_cycleImportModeButton () {
		const dropMode = Config.get("artBrowser", "importImagesAs") ?? 0;
		switch (dropMode) {
			case ConfigConsts.C_ART_IMAGE_MODE_TOKEN:
				this._$btnCycleImportMode.html(`<span class="fas fa-fw fa-user"></span>`).title("Drag-Drop Images as Tokens");
				UtilApplications.setApplicationTitle(this._parent, `${ArtBrowserApp._BASE_TITLE} - Tokens`);
				break;
			case ConfigConsts.C_ART_IMAGE_MODE_TILE:
				this._$btnCycleImportMode.html(`<span class="fas fa-fw fa-cubes"></span>`).title("Drag-Drop Images as Tiles");
				UtilApplications.setApplicationTitle(this._parent, `${ArtBrowserApp._BASE_TITLE} - Tiles`);
				break;
			case ConfigConsts.C_ART_IMAGE_MODE_NOTE:
				this._$btnCycleImportMode.html(`<span class="fas fa-fw fa-bookmark"></span>`).title("Drag-Drop Images as Notes");
				UtilApplications.setApplicationTitle(this._parent, `${ArtBrowserApp._BASE_TITLE} - Notes`);
				break;
			case ConfigConsts.C_ART_IMAGE_MODE_SCENE:
				this._$btnCycleImportMode.html(`<span class="fas fa-fw fa-map"></span>`).title("Drag-Drop Images as Scenes");
				UtilApplications.setApplicationTitle(this._parent, `${ArtBrowserApp._BASE_TITLE} - Scenes`);
				break;
			default: throw new Error(`Unhandled drop mode "${dropMode}"`);
		}
	}

	
	_pInit_pOnComplete () {
		this.handleInstanceConfigUpdate();
	}
}

class ArtBrowserApp extends Application {
		static prePreInit () {
		Hooks.on("getSceneControlButtons", (buttonMetas) => {
			if (!game.user.isGM) return;
			this._preInit_addMainButton(buttonMetas);
			this._preInit_addTileButton(buttonMetas);
			this._preInit_addTokenButton(buttonMetas);
			this._preInit_addNotesButton(buttonMetas);
		});
		this._preInit_registerKeybinds();
	}

	static _preInit_registerKeybinds () {
		game.keybindings.register(
			SharedConsts.MODULE_ID,
			"ArtBrowserApp__open",
			{
				name: "Open Art Browser",
				editable: [],
				onDown: () => {
					this._pOpen();
					return true;
				},
				restricted: true,
			},
		);
	}

	static _pOpen () {
		if (ArtBrowserApp._INSTANCE) {
			ArtBrowserApp._INSTANCE.render(true);
			ArtBrowserApp._INSTANCE.maximize();
			UtilApplications.bringToFront(ArtBrowserApp._INSTANCE);
			return;
		}

		ArtBrowserApp._INSTANCE = new ArtBrowserApp();
		ArtBrowserApp._INSTANCE.render(true);
	}

	static _preInit_addMainButton (buttonMetas) {
		const existingOuter = buttonMetas.find(it => it.name === ArtBrowserApp._ART_SCENE_CONTROLS_NAME);
		if (existingOuter) return;

				buttonMetas.push({
			name: ArtBrowserApp._ART_SCENE_CONTROLS_NAME,
			title: "Art Browser",
			icon: "fas fa-fw fa-palette",
						tools: [
				{
					name: ArtBrowserApp._ART_SCENE_CONTROLS_NAME,
					title: "Art Browser",
					icon: "fas fa-fw fa-palette",
					onClick: () => ui.notifications.info(`Hi! You shouldn't be able to click this, something has gone wrong.`),
					button: true,
				},
			],
			visible: Config.isInit && Config.get("artBrowser", "buttonDisplay")[ConfigConsts.C_ART_IMAGE_MODE_SCENE],
			activeTool: "open",
		});
	}

	static _preInit_getInnerToolMeta (modeId) {
		return {
			name: ArtBrowserApp._ART_SCENE_CONTROLS_NAME,
			title: "Art Browser",
			icon: "fas fa-fw fa-palette",
			onClick: () => {
				Config.set("artBrowser", "importImagesAs", modeId);
				ArtBrowserApp._pOpen();
			},
			visible: Config.isInit && Config.get("artBrowser", "buttonDisplay")[modeId],
			button: true,
		};
	}

	static _preInit_addTileButton (buttonMetas) {
		this._preInit_addSubmenuButton(buttonMetas, "tiles", ConfigConsts.C_ART_IMAGE_MODE_TILE);
	}

	static _preInit_addTokenButton (buttonMetas) {
		this._preInit_addSubmenuButton(buttonMetas, "token", ConfigConsts.C_ART_IMAGE_MODE_TOKEN);
	}

	static _preInit_addNotesButton (buttonMetas) {
		this._preInit_addSubmenuButton(buttonMetas, "notes", ConfigConsts.C_ART_IMAGE_MODE_NOTE);
	}

	static _preInit_addSubmenuButton (buttonMetas, mode, modeId) {
		const buttonMeta = buttonMetas.find(it => it.name === mode);
		const isExists = buttonMeta.tools.some(it => it.name === ArtBrowserApp._ART_SCENE_CONTROLS_NAME);
		if (isExists) return;
		buttonMeta.tools.push(this._preInit_getInnerToolMeta(modeId));
	}

	static async _pDownloadPack (json) {
		await fetch(
			Config.backendEndpoint,
			{
				method: "post",
				headers: {
					"Content-Type": "application/json",
				},
				body: JSON.stringify({
					type: "artBrowserDownloadPack",
					json,
					directoryPath: Config.get("artBrowser", "artDirectoryPath"),
				}),
			},
		);
	}

	static init () {
				const cachedOnClickLayer = ui.controls._onClickLayer.bind(ui.controls);
		ui.controls._onClickLayer = function (event, ...rest) {
			if (event.currentTarget.dataset.control === ArtBrowserApp._ART_SCENE_CONTROLS_NAME) {
				ArtBrowserApp._pOpen();
				return;
			}
			cachedOnClickLayer(event, ...rest);
		};

				$(document.body).on("dragstart", ".artr__item__lnk-fullsize", evt => {
			evt.stopPropagation();
		});

		if (!UtilGameSettings.getSafe("core", "noCanvas")) {
			document.getElementById("board").addEventListener("drop", this._handleCustomDrop.bind(this));
		}

		game.socket.on("progress", data => {
			if (data.type !== "plutoniumDownloadPackImage") return;
			if (!ArtBrowserApp._INSTANCE) return;
			if (!ArtBrowserApp._INSTANCE._isDownloadingPack) return;

			SceneNavigation.displayProgressBar({label: data.text, pct: data.pct});
		});

		UtilHooks.on(UtilHooks.HK_CONFIG_UPDATE, (diff) => this._handleConfigUpdate(diff));
		this._handleConfigUpdate({isInit: true});
	}
	
	constructor () {
		super({
			title: ArtBrowserApp._BASE_TITLE,
			template: `${SharedConsts.MODULE_LOCATION}/template/ArtBrowserApp.hbs`,
			height: Util.getMaxWindowHeight(),
			width: Math.max(780, Util.getMaxWindowWidth() / 2),
			resizable: true,
		});
		this._isDownloadingPack = false;
		this.__bound__handleInstanceConfigUpdate = null;
	}

	static _handleConfigUpdate ({isInit = false, current, previous} = {}) {
		if (!this._handleConfigUpdate_isRefreshControls({isInit, current, previous})) return;
		if (ui.controls) ui.controls.initialize(); 	}

	static _handleConfigUpdate_isRefreshControls ({isInit = false, current, previous} = {}) {
		if (isInit) return true;
		if (!current || !previous) return false;
		const path = ["artBrowser", "buttonDisplay"];
		return !CollectionUtil.deepEquals(MiscUtil.get(current, ...path), MiscUtil.get(previous, ...path));
	}

	getData () {
		return {
			owner: true, 			entity: {
				name: "Art Browser", 			},
		};
	}

	activateListeners ($html) {
		$html.closest(`.window-content`)
			.addClass("p-0")
			.addClass("artb__window-outer");

		const artBrowser = new ArtBrowserFvtt($html, {app: this});

		this.__bound__handleInstanceConfigUpdate = artBrowser.handleInstanceConfigUpdate.bind(artBrowser);
		UtilHooks.on(UtilHooks.HK_CONFIG_UPDATE, this.__bound__handleInstanceConfigUpdate);

		artBrowser.pInit()
			.then(async () => {
				if (!Config.get("artBrowser", "isShowMissingBackendWarning")) return;
				if (await UtilBackend.pGetBackendVersion()) return;

				artBrowser.doShowNotification({
					content: `<div>${Config.get("ui", "isStreamerMode") ? SharedConsts.MODULE_TITLE_FAKE : SharedConsts.MODULE_TITLE} backend mod not detected! Some features may be disabled, or fail to function as expected. See the <a href="https://wiki.tercept.net/en/Plutonium/Plutonium_Installation#how-to-modify-the-backend" target="_blank" rel="noopener noreferrer">wiki article</a> for more information.</div>`,
					pFnOnDismiss: async () => {
						Config.set("artBrowser", "isShowMissingBackendWarning", false);
					},
				});
			});
	}

	static async _doCancelPackDownload () {
		await fetch(
			Config.backendEndpoint,
			{
				method: "post",
				headers: {
					"Content-Type": "application/json",
				},
				body: JSON.stringify({
					type: "artBrowserCancelDownloadPack",
				}),
			},
		);
	}

	async _activateListeners_pHandleDownloadAssets (json, ix, len) {
		try {
			ArtBrowserApp._INSTANCE._isDownloadingPack = true;
			await ArtBrowserApp._pDownloadPack(json);
		} catch (e) {
			ArtBrowserApp._INSTANCE._isDownloadingPack = false;
		}

		if (ix + 1 === len) {
			ArtBrowserApp._INSTANCE._isDownloadingPack = false;
			ui.notifications.info(`Download complete! Images will be available in your "User Data" directory.`);
		}
	}

	async doDownloadSingleImage_ (meta) {
		try {
			await this.constructor._pLoadImageViaBackend(meta.uri);
			ui.notifications.info(`Image downloaded to your Art Directory ("${Config.get("artBrowser", "artDirectoryPath")}")`);
		} catch (e) {
			ui.notifications.error(`Failed to download image! ${VeCt.STR_SEE_CONSOLE}`);
		}
	}

	static _handleCustomDrop (evt) {
		const data = UtilEvents.getDropJson(evt);

		if (data?.type !== "ve-Art") return;

		this._pDoLoadAndPlaceImage(evt, data)
			.catch(err => {
				ui.notifications.error(`Failed to load image! ${VeCt.STR_SEE_CONSOLE}`);
				setTimeout(() => { throw err; });
			});

				return false;
	}

	static _getDropOffsets ({width, height}) {
		switch (Config.get("artBrowser", "dropAnchor")) {
			case ConfigConsts.C_ART_DROP_ANCHOR_CENTER: {
				return {
					offsetX: -Math.round(width / 2),
					offsetY: -Math.round(height / 2),
				};
			}

			case ConfigConsts.C_ART_DROP_ANCHOR_TOP_LEFT:
			default: {
				return {
					offsetX: 0,
					offsetY: 0,
				};
			}
		}
	}

	static _doActivateLayer ({layerName}) {
		if (!Config.get("artBrowser", "isSwitchLayerOnDrop")) return;

		if (layerName === game.canvas.activeLayer) return;
		const layer = game.canvas.layers.find(it => it.name === layerName);
		layer.activate();
	}

	static async _pDoLoadAndPlaceImage (evt, data) {
				const dropMode = Config.get("artBrowser", "importImagesAs") ?? 0;

		const imageMeta = await this._pDoLoadAndPlaceImage_pGetImageMeta({url: data.uri});
		if (!imageMeta) return;
		const {url, image} = imageMeta;

		const getPrettyName = () => {
			let prettyName = url.split("/").last();
			try {
				prettyName = decodeURIComponent(prettyName);
				prettyName = prettyName.split(".")[0];
				prettyName = prettyName
					.replace(/_/g, " ")
					.replace(/\s+/g, " ")
					.replace(/\d+\s*[xX*]\s*\d+/g, "")
				;
			} catch (ignored) {
							}
			return prettyName;
		};

		const width = image.naturalWidth;
		const height = image.naturalHeight;
		const scale = Config.get("artBrowser", "scale");

		switch (dropMode) {
			case ConfigConsts.C_ART_IMAGE_MODE_TOKEN: {
				const canvasPos = UtilCanvas.getPosCanvasSpace(evt, "TokenLayer");
				this._doActivateLayer({layerName: "TokenLayer"});

				const tokenSize = Config.get("artBrowser", "tokenSize") || 1;

				const {offsetX, offsetY} = this._getDropOffsets({
					width: tokenSize,
					height: tokenSize,
				});

				await TokenDocument.create(
					{
						name: "-",
						x: canvasPos.x + offsetX,
						y: canvasPos.y + offsetY,
						img: url,
						width: tokenSize,
						height: tokenSize,
						scale: 1,
					},
					{
						parent: canvas.scene,
					},
				);

				break;
			}

			case ConfigConsts.C_ART_IMAGE_MODE_TILE: {
				const canvasPos = UtilCanvas.getPosCanvasSpace(evt, "TilesLayer");
				this._doActivateLayer({layerName: "TilesLayer"});

				const widthTile = Math.round(width * scale);
				const heightTile = Math.round(height * scale);

				const {offsetX, offsetY} = this._getDropOffsets({
					width: widthTile,
					height: heightTile,
				});

				await canvas.scene.createEmbeddedDocuments(
					"Tile",
					[
						{
							img: url,
							width: widthTile,
							height: heightTile,
							hidden: false,
							scale,
							x: canvasPos.x + offsetX,
							y: canvasPos.y + offsetY,
							overhead: canvas.foreground?._active ?? false,
						},
					],
				);

				break;
			}

			case ConfigConsts.C_ART_IMAGE_MODE_NOTE: {
				const canvasPos = UtilCanvas.getPosCanvasSpace(evt, "NotesLayer");
				this._doActivateLayer({layerName: "NotesLayer"});

				const iconSize = 40;

				const {offsetX, offsetY} = this._getDropOffsets({
					width: iconSize,
					height: iconSize,
				});

				const name = getPrettyName();
				const journalEntry = await JournalEntry.create({
					name,
					pages: [
						{
							name: `${name} (Image)`,
							type: "image",
							src: url,
							ownership: {default: 0},
						},
					],
				});

				await canvas.scene.createEmbeddedDocuments(
					"Note",
					[
						{
							entryId: journalEntry.id,
							icon: "icons/svg/book.svg",
							iconSize,
							text: "",
							x: canvasPos.x + offsetX,
							y: canvasPos.y + offsetY,
						},
					],
				);

				break;
			}

			case ConfigConsts.C_ART_IMAGE_MODE_SCENE: {
				const isActivate = Config.get("artBrowser", "isSwitchToCreatedScene");

								const createData = {
					name: getPrettyName(),
					active: isActivate,
					navigation: Config.get("artBrowser", "isSceneAddToNavigation"),
					img: url,
					width: Math.round(width * scale),
					height: Math.round(height * scale),

					padding: Config.get("artBrowser", "scenePadding"),
					backgroundColor: Config.get("artBrowser", "sceneBackgroundColor"),
					tokenVision: Config.get("artBrowser", "isSceneTokenVision"),
					fogExploration: Config.get("artBrowser", "isSceneFogExploration"),

					gridDistance: Config.getMetricNumberDistance({configGroup: "artBrowser", originalValue: 5, originalUnit: "ft", configKey: "isSceneGridMetric"}),
					gridUnits: Config.getMetricNumberDistance({configGroup: "artBrowser", originalUnit: "ft", configKey: "isSceneGridMetric"}),

					flags: {},
				};
				const scene = await Scene.create(createData, {renderSheet: Config.get("artBrowser", "isDisplaySheetCreatedScene")});

				if (isActivate) canvas.draw();

				break;
			}
		}
	}

	static _displayImageLoadingProgress ({pct}) {
		SceneNavigation.displayProgressBar({label: "Loading image...", pct});
	}

	static async _pDoLoadAndPlaceImage_pGetImageMeta ({url}) {
		this._displayImageLoadingProgress({pct: 25});
		try {
			return await this._pDoLoadAndPlaceImage_pGetImageMeta_({url});
		} finally {
			this._displayImageLoadingProgress({pct: 100});
		}
	}

	static async _pDoLoadAndPlaceImage_pGetImageMeta_ ({url}) {
		switch (Config.get("artBrowser", "imageSaveMode")) {
			case ConfigConsts.C_ART_IMAGE_SAVE_MODE__DEFAULT: {
				this._displayImageLoadingProgress({pct: 50});

				const fromDefault = await this._pDoLoadAndPlaceImage_pDoLoadViaDefault({url});
				if (fromDefault) return fromDefault;

				this._displayImageLoadingProgress({pct: 75});

				return this._pDoLoadAndPlaceImage_pDoLoadViaBackend({url});
			}

			case ConfigConsts.C_ART_IMAGE_SAVE_MODE__ALWAYS: {
				return this._pDoLoadAndPlaceImage_pDoLoadViaBackend({url});
			}

			case ConfigConsts.C_ART_IMAGE_SAVE_MODE__NEVER: {
				return this._pDoLoadAndPlaceImage_pDoLoadViaDefault({url});
			}
		}
	}

	static async _pDoLoadAndPlaceImage_pDoLoadViaDefault ({url}) {
		if (!(await this._pPingImage(url))) return null;

		const image = await UtilImage.pLoadImage(url);
		return {image, url};
	}

	static async _pDoLoadAndPlaceImage_pDoLoadViaBackend ({url}) {
		if (await UtilBackend.pGetBackendVersion()) {
			if (Config.get("artBrowser", "imageSaveMode") !== ConfigConsts.C_ART_IMAGE_SAVE_MODE__ALWAYS) console.warn(...LGT, `Could not directly load image from ${url}\u2014falling back on alternate loader (backend mod).`);

			try {
				const out = await this._pLoadImageViaBackend(url);
				void out;
				return out;
			} catch (e) {
				console.error(...LGT, "Failed to load image!", e);
				ui.notifications.error(`Failed to load image! ${VeCt.STR_SEE_CONSOLE}`);
				return null;
			}
		}

		new Dialog({
			title: "Art Browser\u2014Backend Mod Required",
			content: `<div>
					<p>The image you dropped could not be loaded, likely due to CORS blocking. CORS blocking is a browser security feature which prevents potentially harmful content from being loaded from other websites.</p>
					<p>Unfortunately, this security feature also blocks images. In order to work around this, you can install the ${Config.get("ui", "isStreamerMode") ? SharedConsts.MODULE_TITLE_FAKE : SharedConsts.MODULE_TITLE} backend mod. See the &quot;How to Modify the Backend&quot; section on the <a href="https://wiki.tercept.net/en/Plutonium/Plutonium_Installation" target="_blank" rel="noopener noreferrer">wiki</a> for more information.</p>
					<p><b>Note that this is not possible on managed Foundry hosting services, such as The Forge.</b></p>
				</div>`,
			buttons: {
				one: {
					icon: `<i class="fas fa-fw fa-times"></i>`,
					label: "Close",
				},
			},
		}).render(true);

		return null;
	}

	static async _pPingImage (uri) {
		let url;
		try {
			url = new URL(uri);
		} catch (ignored) {
					}

				if (url && ArtBrowserApp._BLOCKED_HOSTS[url.host]) return false;

		try {
			const result = await fetch(uri);
			await result.blob();
			return true;
		} catch (e) {
			if (url) ArtBrowserApp._BLOCKED_HOSTS[url.host] = true;
			return false;
		}
	}

	static async _pCopyImageToLocalViaBackend (url) {
		const fetched = await fetch(
			Config.backendEndpoint,
			{
				method: "post",
				headers: {
					"Content-Type": "application/json",
				},
				body: JSON.stringify({
					type: "artBrowserCopyToLocal",
					url: url,
					directoryPath: Config.get("artBrowser", "artDirectoryPath"),
				}),
			},
		);
		const json = await fetched.json();
		return json.path;
	}

	static async _pLoadImageViaBackend (uri) {
		const url = await this._pCopyImageToLocalViaBackend(uri);
		const image = await UtilImage.pLoadImage(url);
		return {url, image};
	}

	async close (...args) {
		await super.close(...args);
		UtilHooks.off(UtilHooks.HK_CONFIG_UPDATE, this.__bound__handleInstanceConfigUpdate);
		ArtBrowserApp._INSTANCE = null;
	}
}
ArtBrowserApp._BLOCKED_HOSTS = {};
ArtBrowserApp._INSTANCE = null;
ArtBrowserApp._ID_HIDE_TOKEN_BUTTON = "plutonium__art__hide-token-button";
ArtBrowserApp._ID_HIDE_TILE_BUTTON = "plutonium__art__hide-tile-button";
ArtBrowserApp._ID_HIDE_NOTES_BUTTON = "plutonium__art__hide-notes-button";
ArtBrowserApp._ID_HIDE_MAIN_BUTTON = "plutonium__art__hide-main-button";
ArtBrowserApp._ART_SCENE_CONTROLS_NAME = "ve-art__btn-scene";
ArtBrowserApp._BASE_TITLE = "Art Browser";

"use strict";

class UtilHandlebars {
	static async pInit () {
		this._pInit_helpers();
		await this._pInit_pTemplates();
	}

	
	static _COMPARE_OPERATORS = {
				"==": (l, r) => l == r,
		"===": (l, r) => l === r,
				"!=": (l, r) => l != r,
		"!==": (l, r) => l !== r,
		"<": (l, r) => l < r,
		">": (l, r) => l > r,
		"<=": (l, r) => l <= r,
		">=": (l, r) => l >= r,
				"typeof": (l, r) => typeof l === `${r}`,
	};

	static _pInit_helpers () {
		Handlebars.registerHelper("decodeUriComponent", (inputData) => decodeURIComponent(inputData));
		Handlebars.registerHelper("toLowerCase", str => str.toLowerCase());
		Handlebars.registerHelper("toUpperCase", str => str.toUpperCase());
		Handlebars.registerHelper("join", (data, joiner) => data.join(joiner));
		Handlebars.registerHelper("Parser_spellLevelToFull", level => Parser.spLevelToFull(level));
		Handlebars.registerHelper("Parser_getOrdinalForm", i => Parser.getOrdinalForm(i));

				Handlebars.registerHelper("compare", function (lvalue, rvalue, options) {
			if (arguments.length < 3) throw new Error(`Handlebars Helper "compare" needs 2 parameters`);

			const operator = options.hash.operator || "==";

			if (!UtilHandlebars._COMPARE_OPERATORS[operator]) throw new Error(`Handlebars Helper "compare" unknown operator: "${operator}"`);

			if (UtilHandlebars._COMPARE_OPERATORS[operator](lvalue, rvalue)) return options.fn(this);
			else return options.inverse(this);
		});
	}

	
	static _TEMPLATE_PARTIALS = [
		`modules/${SharedConsts.MODULE_ID}/template/partial/CustomizeToken.hbs`,
	];

	static async _pInit_pTemplates () {
		return loadTemplates(this._TEMPLATE_PARTIALS
			.mergeMap(path => ({
				[`${SharedConsts.MODULE_ID}.${path.split("/").pop().replace(".hbs", "")}`]: path,
			})));
	}
}

class UtilUi {
	static async pInit () {
		if (game.user.isGM) {
			await UtilUi._init_pAddDirectoryWrapper("renderSceneDirectory");
			await UtilUi._init_pAddDirectoryWrapper("renderActorDirectory");
			await UtilUi._init_pAddDirectoryWrapper("renderItemDirectory");
			await UtilUi._init_pAddDirectoryWrapper("renderJournalDirectory");
			await UtilUi._init_pAddDirectoryWrapper("renderRollTableDirectory");
			await UtilUi._init_pAddDirectoryWrapper("renderCardsDirectory");
			await UtilUi._init_pAddDirectoryWrapper("renderMacroDirectory");
			await UtilUi._init_pAddDirectoryWrapper("renderCompendiumDirectory");
		}
		UtilUi._init_addCompendiumObfuscation();

		UtilHooks.on(UtilHooks.HK_CONFIG_UPDATE, () => this._handleConfigUpdate());
		this._handleConfigUpdate();
	}

	static _init_addCompendiumObfuscation () {
		const searchTerm = `(${SharedConsts.MODULE_ID})`;

		Hooks.on("renderCompendiumDirectory", () => {
			if (!Config.get("ui", "isStreamerMode")) return;

			$(`#compendium`).find(`.compendium-footer`).each((i, e) => {
				$(e).find(`span`).filter((i2, e2) => $(e2).text().trim() === searchTerm).text(` (Expanded SRD)`);
			});
		});

		ui.compendium.render();
	}

		static async _init_pAddDirectoryWrapper (hookName) {
		const minRole = Config.get("import", "minimumRole");

		const {ChooseImporter} = await Promise.resolve().then(function () { return ChooseImporter$1; });
		const isAddImportButton = game.user.role >= minRole && ChooseImporter.isImportableFvttEntityHook(hookName);

		Hooks.on(hookName, async (app, $html) => {
			$html.find(`.dir__wrp-header`).remove();

			const {MenuCollectionTools} = await Promise.resolve().then(function () { return MenuCollectionTools$1; });

			const $btnImport = ChooseImporter.$getDirButton(hookName);
			const $btnQuick = ChooseImporter.$getDirButtonQuick(hookName);

			const $ptBtnsImport = isAddImportButton ? $$`<div class="btn-group ve-flex-v-center mr-1 w-100">
				${$btnImport ? $btnImport.addClass(`dir__btn-header`) : null}
				${$btnQuick ? $btnQuick.addClass(`dir__btn-header`) : null}
			</div>` : `<div class="w-100"></div>`;

			const $wrp = $$`<div class="ve-flex-col dir__wrp-header w-100 no-shrink min-w-100 dir__control-header ${this._init_isRequireExtraSpacingFvttEntityType(hookName) ? "pb-1" : ""}">
					<div class="ve-flex w-100">
						${$ptBtnsImport}
						${MenuCollectionTools.$getDirButton(hookName).addClass(`dir__btn-header`)}
						${Config.$getDirButton().addClass(`dir__btn-header`)}
					</div>
				</div>`;

						const $insertAfterTarget = $html.find(`.header-actions`);
			if ($insertAfterTarget.length) $wrp.insertAfter($insertAfterTarget[0]);

			MenuCollectionTools.$getDirButton(hookName)
				.addClass(`dir__btn-header dir__control-header--alt`)
				.css({maxWidth: 28})
				.appendTo($html.find(`.header-actions.action-buttons`));
		});
	}

	static _init_isRequireExtraSpacingFvttEntityType (hookName) {
		return ["renderMacroDirectory", "renderCompendiumDirectory", "renderCardsDirectory"].includes(hookName);
	}

	static _handleConfigUpdate () {
		if (!ui.settings || !ui.settings.element) return;

		this._doRenderSettings_handleConfigFixEscapeKey(ui.settings, ui.settings.element);
		this._doRenderSettings_handleConfigHidePlutoniumDirectoryButtons(ui.settings, ui.settings.element);
		this._doRenderSettings_addPlayerConfigButton(ui.settings, ui.settings.element);
	}

	static _doRenderSettings_handleConfigFixEscapeKey (app, $html) {
		if (!Config.get("ui", "isFixEscapeKey") || !Config.get("ui", "isAddOpenMainMenuButtonToSettings")) {
			return $html.find(`.ui__btn-open-menu`).remove();
		}

		if ($html.find(`.ui__btn-open-menu`).length) return;

		$(`<button class="ui__btn-open-menu"><i class="fas fa-fw fa-bars"></i> Open Game Menu</button>`)
			.click(() => {
				if (this.isGameMenuOpen()) {
					ui.menu.toggle();
					return;
				}

				const menu = ui.menu.element;
				if (!menu.length) ui.menu.render(true);
				else menu.slideDown(150);
			})
			.insertBefore($html.find(`button[data-action="configure"]`));
	}

	static _doRenderSettings_handleConfigHidePlutoniumDirectoryButtons (app, $html) {
		if (!Config.get("ui", "isHidePlutoniumDirectoryButtons")) {
			return $html.find(`.cfg__btn-open-alt`).remove();
		}

		if ($html.find(`.cfg__btn-open-alt`).length) return;

		Config.$getDirButton({isGameSettingsButton: true})
			.insertAfter($html.find(`button[data-action="configure"]`));
	}

	static _doRenderSettings_addPlayerConfigButton (app, $html) {
		if (game.user.isGM) return;

		if ($html.find(`.ui__wrp-player-settings`).length) return;

		const $btnOpenPlayerConfig = $(`<button><i class="fas fa-fw fa-cogs"></i> Configure ${Config.get("ui", "isStreamerMode") ? "SRD Module" : "Plutonium "}</button>`)
			.click(evt => Config.pHandleButtonClick(evt));

		$$`<div class="ui__wrp-player-settings">${$btnOpenPlayerConfig}</div>`.insertAfter($html.find(`.game-system`));
	}

	static getModuleFaIcon () {
		return Config.get("ui", "isStreamerMode")
			? `<i class="fab fa-fw fa-d-and-d"></i>`
			: `<i class="fas fa-fw fa-atom"></i>`;
	}

	static isGameMenuOpen () {
		return ui.menu.element && ui.menu.element?.[0]?.style?.display === "";
	}
}

class UtilRenderer {
	static init () {
		UtilHooks.on(UtilHooks.HK_CONFIG_UPDATE, () => this._handleConfigUpdate());
		this._handleConfigUpdate();
	}

	static _handleConfigUpdate () {
		Renderer.get().setInternalLinksDisabled(Config.get("import", "isRendererLinksDisabled"));
	}
}

class PopoutSheet {
		static init () {
		PopoutSheet._POPOUT_HOOKS.forEach(hookName => {
			Hooks.on(hookName, (app, $html, data) => {
				PopoutSheet._doAddButtonSheet(app, $html, data);
				PopoutSheet._doHandleSubPopout(app, $html, data);
			});
		});

		UtilLibWrapper.addPatch(
			"Application.prototype.bringToTop",
			this._lw_Application_prototype_bringToTop,
			UtilLibWrapper.LIBWRAPPER_MODE_WRAPPER,
		);
	}

	static _lw_Application_prototype_bringToTop (fn, ...args) {
		const out = fn(...args);
		if (this._plut_popoutWindow) {
			try {
				this._plut_popoutWindow.focus();
			} catch (e) {
							}
		}
		return out;
	}

	static _doAddButtonSheet (app, $html, data) {
		const $sheetHeader = UtilApplications.$getAppElement(app).closest(`.app`).find(`.window-header`);
		$sheetHeader.find(`.pop__btn-open`).remove();

		$(`<a class="pop__btn-open" title="Pop Out"><span class="fas fa-fw fa-external-link-alt"></span></a>`)
			.click(evt => this.pHandleButtonClick(evt, app, $html, data))
			.insertBefore($sheetHeader.find(`.close`));
	}

	static pHandleButtonClick (evt, app, $html, data) {
		evt.preventDefault();
		this.doPopout(app, data);
	}
	
	static _getDocumentStyleHtml () {
		const out = [];

		const addAsRules = (sheet) => {
			const rules = "cssRules" in sheet ? sheet.cssRules : sheet.rules;
			if (!rules) return;

			const css = [];

			[...(rules || [])].forEach(rule => {
				let str = "cssText" in rule ? rule.cssText : `${rule.selectorText} {\n${rule.style.cssText}\n}\n`;

								if (str.includes("@font-face")) {
					str = str.replace(/(url\(")([^"]+)("\))/g, (...m) => {
						if (m[2].startsWith("/") || !sheet.href) return `${m[1]}${m[2]}${m[3]}`;
						else {
							const path = (new URL(sheet.href)).pathname.split("/").slice(0, -1).join("/");
							return `${m[1]}${path}/${m[2]}${m[3]}`;
						}
					});
				}
				css.push(str);
			});

			out.push(`<style>
				${css.join("\n")}
			</style>`);
		};

		[...(document.styleSheets || [])].forEach(sheet => {
			try {
								addAsRules(sheet);
			} catch (e) {
				console.error(...LGT, e);
								if (sheet.href) out.push(`<link rel="stylesheet" href="${sheet.href}">`);
			}
		});

		return out.join("\n");
	}

	static doPopout (app, data) {
		const name = app.title || UtilApplications.getDataName(data);

		const width = app.position?.width || 800;
		const height = app.position?.height || 800;

				const win = open(
			"",
			name,
			`width=${width},height=${height},location=0,menubar=0,status=0,titlebar=0,toolbar=0,directories=0`,
		);

		if (win == null) {
			ui.notifications.error(`Could not open pop-up window! Please check your browser settings, and allow this site to open (multiple) pop-up windows.`);
			throw new Error(`Could not open popout window!`);
		}

		win.document.write(`
		<!DOCTYPE html>
		<html lang="en" class="ve-popwindow ${document.documentElement.className || ""}"><head>
			<meta name="viewport" content="width=device-width, initial-scale=1">
			<title>${name}</title>

			${this._getDocumentStyleHtml()}
		</head><body class="ve-flex-col overflow-overlay ${document.body.className}"></body></html>
		`);

		const $body = $(win.document.body);

						app._plut_popoutWindow = win;

				const cachedMinimize = app.minimize;
		app.minimize = async () => {};

								const $appElement = UtilApplications.$getAppElement(app).closest(`.app`);

		$appElement.addClass("pop__window");
		$body.append($appElement);

		const $drgResize = $appElement.find(`.window-resizable-handle`)
			.addClass("ve-hidden");

		UtilEvents.bindDocumentHandlers({element: win.document.body});

		win.addEventListener("unload", () => {
			UtilEvents.unbindDocumentHandlers({element: win.document.body});
			$(document.body).append($appElement);
			$appElement.removeClass("pop__window");
			$drgResize.removeClass("ve-hidden");
			delete app._plut_popoutWindow;
			app.minimize = cachedMinimize;
			app.close();
		});

				window.addEventListener("beforeunload", () => {
			win.close();
		});
	}

	static _doHandleSubPopout (app, $html, data) {
		if (!Config.get("ui", "isEnableSubPopouts")) return;

		if (app._plut_popoutWindow) return;

		const parentApps = app?.object?.parent?.apps || {};
		if (!parentApps) return;

		const isParentPopped = Object.values(parentApps).some(parentApp => !!parentApp._plut_popoutWindow);
		if (!isParentPopped) return;

		this.doPopout(app, data);
	}

	static isPoppedOut (app) { return !!app._plut_popoutWindow; }
}
PopoutSheet._POPOUT_HOOKS = [
	"renderSceneConfig",
	"renderActorSheet",
	"renderItemSheet",
	"renderJournalSheet",
	"renderRollTableConfig",
	"renderCardsConfig",
	"renderCardConfig",

	"renderArtBrowserApp",
	"renderChooseImporter",
	"renderImportList",

	"renderCombatTracker",
	"renderSceneDirectory",
	"renderActorDirectory",
	"renderItemDirectory",
	"renderJournalDirectory",
	"renderRollTableDirectory",
	"renderCardsDirectory",
	"renderPlaylistDirectory",
	"renderCompendiumDirectory",
	"renderSettings",
	"renderMacroDirectory",
];

class Menu {
		constructor (opts) {
		this._eventNamespace = opts.eventNamespace;
		this._toolsList = opts.toolsList;
		this._direction = opts.direction;

		this._$wrpMenu = null;
	}

	_closeMenu (evt) {
		if (evt) evt.preventDefault();
		this._$wrpMenu.remove();
		$(document.body).off(`pointerup.${this._eventNamespace}`);
		Menu._OPEN_MENUS.delete(this);
	}

	_getFilteredToolList (toolArgs) {
		let availableToolList = this._toolsList.filter(it => !it?.fnCheckRequirements || it.fnCheckRequirements(...toolArgs));

				while (availableToolList.length && !availableToolList[0]) availableToolList.shift();
		while (availableToolList.length && !availableToolList.last()) availableToolList.pop();

		let prevVal = null;
		availableToolList = availableToolList.filter(it => {
			if (it == null && prevVal == null) return false;
			prevVal = it;
			return true;
		});

		return availableToolList;
	}

	async _pOpenMenu (evt, ...toolArgs) {
				Menu.closeAllMenus();

		Menu._OPEN_MENUS.add(this);

		const $eles = [];
		const filteredToolList = this._getFilteredToolList(toolArgs);
		filteredToolList.forEach((toolMeta, i) => {
			if (!toolMeta) {
				$eles.push($(`<div class="veapp-ctx-menu__spacer veapp-ctx-menu__spacer--double"></div>`));
				return;
			}

			const displayName = toolMeta.streamerName && Config.get("ui", "isStreamerMode") ? toolMeta.streamerName : toolMeta.name;

			const $btnOpen = $(`<a class="veapp-ctx-menu__item m-1 ve-flex-v-center px-1 ${toolMeta.additionalClassesButton || ""}" ${toolMeta.title ? `title="${toolMeta.title.escapeQuotes()}"` : ""}>${toolMeta.getIcon ? toolMeta.getIcon() : `<i class="fas fa-fw ${toolMeta.iconClass}"></i>`}<span class="ml-1">${displayName}</span></a>`)
				.on("pointerup", evt => {
					this._closeMenu(evt);
					this._pHandleOpenButtonClick(evt, toolMeta, ...toolArgs);
				});

			$eles.push($btnOpen);

			if (filteredToolList[i + 1]) $eles.push($(`<div class="veapp-ctx-menu__spacer"></div>`));
		});

		$(document.body).on(`pointerup.${this._eventNamespace}`, () => {
			this._closeMenu();
		});

		this._$wrpMenu = $$`<div class="veapp-ctx-menu__wrp ve-flex-col">${$eles}</div>`
			.appendTo(document.body);

		const w = this._$wrpMenu.width();
		if (this._direction === "up") {
			const h = this._$wrpMenu.height();
			this._$wrpMenu.css({top: EventUtil.getClientY(evt) - h + 4, left: EventUtil.getClientX(evt) - w + 4});
		} else {
			let left = EventUtil.getClientX(evt) - 16;
			if (EventUtil.getClientX(evt) + w > window.innerWidth) left -= w - 32;
			this._$wrpMenu.css({top: EventUtil.getClientY(evt) - 10, left});
		}
	}

	async _pHandleOpenButtonClick (evt, toolMeta, ...toolArgs) {
		if (toolMeta.Class) {
			if (toolMeta.Class.pHandleButtonClick) return toolMeta.Class.pHandleButtonClick(evt, ...toolArgs);

			const tool = new toolMeta.Class(...toolArgs);
			if (tool.pInit) await tool.pInit();
			tool.render(true);
			return;
		}

		if (toolMeta.pFnOnClick) {
			await toolMeta.pFnOnClick(evt, ...toolArgs);
			return;
		}

		throw new Error(`No handler class or onclick function defined for tool "${toolMeta.name}"! This is a bug!`);
	}

		static closeAllMenus () {
		return !![...Menu._OPEN_MENUS].map(it => it._closeMenu()).length;
	}
}
Menu._OPEN_MENUS = new Set();

class UtilMigrate {
	
	static isOwner (doc) {
		return doc.owner || doc.isOwner;
	}
}

class MenuTitle extends Menu {
		static init () {
		if (!this._HOOK_NAME) throw new Error(`Missing hook name!`);
		if (!this._TOOL_LIST.length) return; 
		Hooks.on(this._HOOK_NAME, (app, $html, data) => {
			const availableTools = this._TOOL_LIST.filter(it => (it.isRequireOwner && UtilMigrate.isOwner(data)) || !it.isRequireOwner);

			const menu = new this(this._EVT_NAMESPACE, availableTools);
			menu._doAddButtonSheet(app, $html, data);
		});
	}
	
	constructor (eventNamespace, toolsList) {
		if (!eventNamespace) throw new Error(`Missing namespace argument!`);
		if (!toolsList) throw new Error(`Missing tools list argument!`);

		toolsList = toolsList.filter(it => it.getMinRole == null || game.user.role >= it.getMinRole());

		super({
			eventNamespace,
			toolsList,
			direction: "down",
		});
	}

	_doAddButtonSheet (app, $html, data) {
		const $sheetHeader = UtilApplications.$getAppElement(app).find(`.window-header`);
		$sheetHeader.find(`.tit-menu__btn-open--sheet`).remove();

		$(`<a class="tit-menu__btn-open--sheet text-center" title="${Config.get("ui", "isStreamerMode") ? "Other" : "Plutonium"} Options"><span class="fas fa-ellipsis-v"></span></a>`)
						.on("pointerdown", evt => evt.stopPropagation())
			.on("pointerup", evt => {
				evt.preventDefault();
				evt.stopPropagation();

				return this._pOpenMenu(evt, app, $html, data);
			})
			.insertBefore($sheetHeader.find(`.close`));
	}
}

class MenuTitleSceneConfig extends MenuTitle {}
MenuTitleSceneConfig._HOOK_NAME = "renderSceneConfig";
MenuTitleSceneConfig._EVT_NAMESPACE = "plutonium-scene-config-title-menu";
MenuTitleSceneConfig._TOOL_LIST = [];

class UtilList2 {
	static absorbFnGetData (li) {
		const cbSel = li.ele.firstElementChild?.firstElementChild?.firstElementChild?.tagName === "INPUT"
			? li.ele.firstElementChild.firstElementChild.firstElementChild
			: li.ele.querySelector(`input[type="checkbox"], input[type="radio"]`);

		const btnShowHidePreview = li.ele.firstElementChild?.children?.[1]?.firstElementChild?.innerHTML === "[+]"
			? li.ele.firstElementChild.children[1].firstElementChild
			: li.ele.querySelector(`.ui-list__btn-inline[title="Toggle Preview"]`);

		return {cbSel, btnShowHidePreview};
	}

	static absorbFnBindListeners (listSelectClickHandler, listItem) {
		listItem.ele.addEventListener("click", evt => listSelectClickHandler.handleSelectClick(listItem, evt));
	}

	static absorbFnBindListenersRadio (listSelectClickHandler, listItem) {
		listItem.ele.addEventListener("click", (evt) => listSelectClickHandler.handleSelectClickRadio(listItem, evt));
	}
}

class UtilFolders {
	static async pCreateFoldersGetId ({folderType, folderIdRoot = null, folderNames, folderMetas, sorting = null}) {
		if (folderNames != null && folderMetas != null) throw new Error(`Only one of "folderNames" and "folderMetas" may be specified!`);
		if (folderMetas != null && sorting != null) throw new Error(`Only one of "folderMetas" and "sorting" may be specified!`);

		folderMetas = this._getFolderMetas({folderNames, folderMetas, sorting});

		try {
			await this._LOCK_FOLDER_CREATE.pLock();
			return (await this._pGetCreateFolders_({folderType, folderIdRoot, folderMetas}));
		} finally {
			this._LOCK_FOLDER_CREATE.unlock();
		}
	}

	static _getFolderMetas ({folderNames, folderMetas, sorting = null}) {
		folderMetas = folderMetas || folderNames.map((it, i) => ({
			name: it,
			color: null,
			description: null,
			flags: {},
			sort: 0,
						sorting: i === folderNames.length - 1 ? sorting || "a" : "a",
		}));

		folderMetas.forEach(it => it.name = `${it.name}`.trim() || " ");

		return folderMetas;
	}

	static async pFoldersGetId ({folderType, folderIdRoot = null, folderNames}) {
		const folderMetas = this._getFolderMetas({folderNames});

		return this._pGetCreateFolders_({folderMetas, folderIdRoot, isCreate: false});
	}

	static async _pGetCreateFolders_ ({folderType, folderIdRoot, folderMetas, isCreate = true}) {
		if (!folderMetas?.length || !folderType) return folderIdRoot;

		const stack = [];
		if (folderIdRoot != null) {
			const folder = CONFIG.Folder.collection.instance.get(folderIdRoot);
			if (folder) stack.push(folder);
		}

		for (let i = 0; i < folderMetas.length; ++i) {
			const {name} = folderMetas[i];

			const parentId = stack.length ? stack.last().id : null;

			const folder = this._pCreateFolders_findFolder({folderType, folderStack: stack, name, parentId});
			if (folder) {
				stack.push(folder);
				continue;
			}

						if (!isCreate) {
				return null;
			}

									if (!Util.Fvtt.canUserCreateFolders()) {
				break;
			}

						const folderData = {
				...folderMetas[i],
				parent: parentId,
				type: folderType,
			};
			const nuFolder = await Folder.create(folderData, {});
			stack.push(nuFolder);
		}

		if (stack.length) return stack.last().id;
		return folderIdRoot;
	}

	static _pCreateFolders_findFolder ({folderType, folderStack, name, parentId}) {
		const matches = CONFIG.Folder.collection.instance.contents.filter(it => {
			if (it.name !== name) return false;
			if (it.type !== folderType) return false;
			return parentId ? it.folder?.id === parentId : it.folder == null;
		});

		if (matches.length > 1) {
			const msg = `Ambiguous folder path! Found multiple folders for ${folderStack.map(it => it.name).join(" > ")}`;
			ui.notifications.error(msg);
			throw new Error(msg);
		}
		if (matches.length) return matches[0];
		return null;
	}

	
	static async pCreateTempFolderGetId ({folderType}) {
				if (!Util.Fvtt.canUserCreateFolders()) return null;
		return this.pCreateFoldersGetId({
			folderType,
			folderNames: [
				Config.get("import", "tempFolderName"),
			],
		});
	}
}
UtilFolders._LOCK_FOLDER_CREATE = new VeLock();

class UtilJournalEntries {
	static async pGetCreateJournalEntryId ({name, folderId = null, defaultOwnership = null, userOwnership = null}) {
		const searchName = name.toLowerCase().trim();

		const existing = game.journal.find(it =>
			it.name.toLowerCase().trim() === searchName
			&& ((it.folder == null && folderId == null) || it.folder?.id === folderId),
		);
		if (existing) return existing.id;

		const journalEntryData = {
			name,
			pages: [],
			folder: folderId,
		};

		if (defaultOwnership != null) journalEntryData.ownership = {default: defaultOwnership};
		if (userOwnership) {
			journalEntryData.ownership = journalEntryData.ownership || {};
			Object.assign(journalEntryData.ownership, userOwnership);
		}

		const journalEntry = await JournalEntry.create(journalEntryData, {renderSheet: false});
		return journalEntry.id;
	}
}

class _FolderInfo {
	constructor (
		{
			displayName,
			folder,
		},
	) {
		this.displayName = displayName;
		this.folder = folder;
	}
}

class UtilFolderPathBuilder {
	static isJournalEntryNamer ({folderType}) {
		return Config.get("import", "isTreatJournalEntriesAsFolders") && folderType === "JournalEntry";
	}

	static async pGetCreateFolderIdMeta (
		{
			folderType,
			folderIdRoot = null,
			folderNames,
			sorting = "a",
			defaultOwnership = null,
			userOwnership = null,
			isFoldersOnly = false,
		},
	) {
		if (!folderType) throw new Error(`Missing "folderType" option!`);
		if (!folderNames.length || !folderType) return new FolderIdMeta();

		if (isFoldersOnly || !UtilFolderPathBuilder.isJournalEntryNamer({folderType})) {
			const folderId = await UtilFolders.pCreateFoldersGetId({folderType, folderIdRoot, folderNames, sorting});
			return new FolderIdMeta({folderId});
		}

		const [pathStringJournalEntry, ...pathStringsFolders] = [...folderNames].reverse();
		const folderId = await UtilFolders.pCreateFoldersGetId({folderType, folderIdRoot, folderNames: pathStringsFolders.reverse(), sorting});

		const parentDocumentId = await UtilJournalEntries.pGetCreateJournalEntryId({
			name: pathStringJournalEntry,
			folderId,
			defaultOwnership,
			userOwnership,
		});

		return new FolderIdMeta({folderId, parentDocumentId});
	}
}

class FolderIdMeta {
	constructor ({folderId = null, parentDocumentId = null} = {}) {
		this.folderId = folderId;
		this.parentDocumentId = parentDocumentId;
	}
}

function MixinFolderPathBuilder (Cls) {
	class MixedFolderPathBuilder extends Cls {
				_getFullFolderPathSpecKey () { throw new Error("Unimplemented!"); }
		getFolderPathMeta () { throw new Error("Unimplemented!"); }
		
		constructor (...args) {
			super(...args);
			this._folderPathSpec = [];
			this._defaultFolderPath = [];
			this._mxFolderPathBuilder_textOnlyMode = false;
		}

		get folderPathSpec () { return this._folderPathSpec; }

		async _pInit_folderPathSpec () {
			this._folderPathSpec = MiscUtil.get((await GameStorage.pGetClient(this._getFullFolderPathSpecKey())), "path");
			if (this._folderPathSpec != null) return;

			const folderPathMeta = this.getFolderPathMeta();
			const defaultSpec = (this._defaultFolderPath || [])
				.map(it => (this._mxFolderPathBuilder_textOnlyMode ? FolderPathBuilderRowTextOnly : FolderPathBuilderRow).getStateFromDefault_(it, {folderPathMeta}));
			await this.pSetFolderPathSpec(defaultSpec);
		}

		async pSetFolderPathSpec (folderPathSpec) {
			this._folderPathSpec = folderPathSpec;
			return GameStorage.pSetClient(this._getFullFolderPathSpecKey(), {path: this._folderPathSpec});
		}

		async pHandleEditFolderPathClick () {
			await this._pInit_folderPathSpec();
			const builderApp = new FolderPathBuilderApp({fpApp: this, folderType: this.constructor.FOLDER_TYPE});
			builderApp.render(true);
		}

		async _pGetCreateFoldersGetIdFromObject ({folderType, obj, sorting = "a", defaultOwnership = null, userOwnership = null, isFoldersOnly = false}) {
			if (!this._folderPathSpec.length || !folderType) return new FolderIdMeta();

			const pathStrings = this._getFolderPathStrings({obj});

			return UtilFolderPathBuilder.pGetCreateFolderIdMeta({
				folderType,
				folderNames: pathStrings,
				sorting,
				defaultOwnership,
				userOwnership,
				isFoldersOnly,
			});
		}

		_getFolderPathStrings ({obj}) {
			return FolderPathBuilder.getFolderPathStrings({obj, folderPathSpec: this._folderPathSpec, folderPathMeta: this.getFolderPathMeta()});
		}
	}
	return MixedFolderPathBuilder;
}

class FolderPathBuilder extends BaseComponent {
	constructor ({fpApp = null, defaultFolderPathSpec = null, fnOnRowKeydown = null, folderType}) {
		super();
		this._fpApp = fpApp;
		this._ClsRow = fpApp ? FolderPathBuilderRow : FolderPathBuilderRowTextOnly;
		this._initialFolderPathSpec = FolderPathBuilder._getInitialFolderPathSpec({fpApp, ClsRow: this._ClsRow, defaultFolderPathSpec, fnOnRowKeydown});
		this._fnOnRowKeydown = fnOnRowKeydown;
		this._folderType = folderType;

		this._lock = new VeLock();
		this._childComps = [];
		this._$wrpRows = null;
	}

	static _getInitialFolderPathSpec ({fpApp, defaultFolderPathSpec, ClsRow, fnOnRowKeydown}) {
		if (defaultFolderPathSpec) {
			return defaultFolderPathSpec
				.map(it => ClsRow.getStateFromDefault_(it, {fnOnKeydown: fnOnRowKeydown}));
		}

		return fpApp ? MiscUtil.copy(fpApp.folderPathSpec) : [];
	}

	_getMaxDepth () {
		let out = CONST.FOLDER_MAX_DEPTH__ORIGINAL ?? CONST.FOLDER_MAX_DEPTH;
		if (UtilFolderPathBuilder.isJournalEntryNamer({folderType: this._folderType})) return out + 1;
		return out;
	}

	static _SEL_EXISTING_BASE_OPTION = `<option value="-1" selected>Select Existing...</option>`;

	static _$getSelExistingFolder (
		{
			folderType,
			fnOnAccept,
		},
	) {
		let folderMetas;
		const $selExisting = $(`<select class="w-80p input-xs form-control italic mr-1" title="Select Existing Folder Path">
			${this._SEL_EXISTING_BASE_OPTION}
		</select>`)
			.click(() => {
				folderMetas = game.folders.contents
					.filter(it => it.type === folderType)
					.map(folder => {
						const path = UtilApplications.getFolderPath(folder, {isAddTrailingSlash: true});
						return new _FolderInfo({
							displayName: `${path || ""}${folder.name}`,
							folder,
						});
					})
					.sort((a, b) => SortUtil.ascSortLower(a.displayName, b.displayName));

				$selExisting
					.removeClass("italic")
					.html(
						this._SEL_EXISTING_BASE_OPTION
						+ folderMetas
							.map((it, ix) => `<option value="${ix}">${it.displayName}</option>`)
							.join(""),
					);
			})
			.change(() => {
				const meta = folderMetas[$selExisting.val()];
				fnOnAccept(meta);
				$selExisting.val("-1").addClass("italic");
			})
			.blur(() => {
				$selExisting.val("-1").addClass("italic");
			});

		return $selExisting;
	}

	render ($parent) {
		$parent.empty();

		const pod = this.getPod();

		this._$wrpRows = $$`<div class="ve-flex-col w-100 h-100 overflow-y-auto relative"></div>`;
		this._childComps.forEach(it => it.render(this._$wrpRows, pod));
		this._render_checkAddEmptyMessage();

		const $selExisting = this.constructor._$getSelExistingFolder({
			folderType: this._folderType,
			fnOnAccept: folderInfo => {
				if (!folderInfo) return;
				const folders = [
					...UtilApplications.getFolderPathFolders(folderInfo.folder),
					folderInfo.folder,
				];

				this._removeAllRows();

				folders.forEach(fld => {
					this._render_addRow(pod, FolderPathBuilderRow.getStateFromFolder_(fld));
				});
			},
		});

		const $btnAdd = $(`<button class="btn btn-5et btn-xs"><span class="fas fa-fw fa-folder-plus"></span> Add Path Part</button>`)
			.click(() => {
				const maxDepth = this._getMaxDepth();
				if (this._childComps.length >= maxDepth) return ui.notifications.warn(`Foundry currently supports a maximum of ${Parser.numberToText(maxDepth)} levels of directory nesting. T-too deep!`);
				this._render_addRow(pod);
			});

		this._initialFolderPathSpec.forEach(state => this._render_addRow(pod, state));

		$$($parent)`
			<div class="w-100 split-v-center mb-1">
				<div>Folder Path:</div>
				<div class="ipt-group ve-flex-vh-center">
					${$selExisting}
					${$btnAdd}
				</div>
			</div>
			${this._$wrpRows}
		`;
	}

	_getFolderPathSpec () { return this._childComps.map(it => MiscUtil.copy(it._state)); }

	static getFolderPathStrings ({obj = null, folderPathSpec = null, folderPathMeta = null} = {}) {
		return folderPathSpec
			.filter(it => it.isFreeText ? it.text && it.text.trim() : it.selectedProp)
			.map(it => it.isFreeText ? it.text : folderPathMeta[it.selectedProp].getter(obj));
	}

	getFolderPathStrings ({obj = null, folderPathSpec = null, folderPathMeta = null} = {}) {
		folderPathSpec = folderPathSpec || this._getFolderPathSpec();
		folderPathMeta = folderPathMeta || (this._fpApp ? this._fpApp.getFolderPathMeta() : null);
		return this.constructor.getFolderPathStrings({obj, folderPathSpec, folderPathMeta});
	}

	async _render_updateParentPath () {
		if (!this._fpApp) return;

		await (this._lock.pLock());
		await this._fpApp.pSetFolderPathSpec(this._getFolderPathSpec());
		this._lock.unlock();
	}

	_render_addRow (pod, state) {
		const folderMeta = this._fpApp ? this._fpApp.getFolderPathMeta() : {};
		const comp = new this._ClsRow(folderMeta, {fnOnKeydown: this._fnOnRowKeydown, folderType: this._folderType});
		if (state) Object.assign(comp.__state, state);

		comp._addHookAll("state", () => this._render_updateParentPath());

		if (!this._childComps.length) this._$wrpRows.empty();

		this._childComps.push(comp);
		comp.render(this._$wrpRows, pod);
		this._render_updateJournalEntryNameDisplays();
		this._render_updateParentPath().then(null);
	}

	_swapRowPositions (ixA, ixB) {
		const a = this._childComps[ixA];
		this._childComps[ixA] = this._childComps[ixB];
		this._childComps[ixB] = a;

		this._childComps.forEach(it => it.$row.detach().appendTo(this._$wrpRows));
		this._render_updateJournalEntryNameDisplays();
		this._render_updateParentPath().then(null);
	}

	_removeRow (comp) {
		const ix = this._childComps.indexOf(comp);
		if (~ix) {
			this._childComps.splice(ix, 1);
			comp.$row.remove();
			this._render_updateParentPath().then(null);
		}

		this._render_updateJournalEntryNameDisplays();
		this._render_checkAddEmptyMessage();
	}

	_removeAllRows () {
		this._childComps.splice(0, this._childComps.length);
		this._render_updateParentPath().then(null);
		this._render_checkAddEmptyMessage();
	}

	_render_updateJournalEntryNameDisplays () {
		const isJournalEntryNamer = UtilFolderPathBuilder.isJournalEntryNamer({folderType: this._folderType});
		this._childComps.forEach((comp, i) => comp.isJournalEntryName = isJournalEntryNamer && i === this._childComps.length - 1);
	}

	_render_checkAddEmptyMessage () {
		if (!this._childComps.length) this._$wrpRows.append(`<div class="ve-flex-v-center w-100 my-1"><i>(Directory root)</i></div>`);
	}

	getPod () {
		const pod = super.getPod();
		pod.swapRowPositions = this._swapRowPositions.bind(this);
		pod.removeRow = this._removeRow.bind(this);
		pod.$getChildren = () => this._childComps.map(it => it.$row);
		return pod;
	}
}

class FolderPathBuilderRowTextOnly extends BaseComponent {
	constructor (folderMeta, {fnOnKeydown, folderType} = {}) {
		super();
		this._folderMeta = folderMeta;
		this._$row = null;
		this._fnOnKeydown = fnOnKeydown;
		this._folderType = folderType;
	}

	get $row () { return this._$row; }

	set isJournalEntryName (val) { this._state.isJournalEntryName = !!val; }

	_$getDispIsJournalEntry () {
		const $dispIsJournalEntry = $(`<div class="ve-muted ve-small italic help-subtle" title="Imported entities will be created as pages within a journal entry with this name. If you would prefer to have each page imported to its own journal entry with this name, click to open the Config, and disable the &quot;Treat Journal Entries as Folders&quot; option.">Journal Entry name</div>`)
			.click(evt => Config.pHandleButtonClick(evt, "journalEntries"));
		const hkIsJournalEntry = () => $dispIsJournalEntry.toggleVe(this._state.isJournalEntryName);
		this._addHookBase("isJournalEntryName", hkIsJournalEntry);
		hkIsJournalEntry();
		return $dispIsJournalEntry;
	}

	render ($parent, parent) {
		this._parent = parent;

		const $dispIsJournalEntry = this._$getDispIsJournalEntry();

		const $iptName = ComponentUiUtil.$getIptStr(this, "text").attr("type", "text").addClass("mr-2");
		if (this._fnOnKeydown) $iptName.keydown(evt => this._fnOnKeydown(evt));

		const $btnRemove = $(`<button class="btn btn-danger btn-xs"><span class="fas fa-fw fa-trash"></span></button>`)
			.click(() => {
				const {removeRow} = this._parent;
				removeRow(this);
			});

		this._$row = $$`<div class="ve-flex-v-center w-100 my-1 imp-folder__row">
			<div class="ve-flex-col w-100 min-w-0">
				${$dispIsJournalEntry}
				${$iptName}
			</div>
			${DragReorderUiUtil.$getDragPad2(() => this._$row, $parent, this._parent)}
			${$btnRemove}
		</div>`.appendTo($parent);
	}

	_getDefaultState () { return {...FolderPathBuilderRowTextOnly._DEFAULT_STATE}; }

	static getStateFromDefault_ (val, {...rest} = {}) {
		const comp = new FolderPathBuilderRowTextOnly({...rest});
		comp.__state.text = val;
		return comp.__state;
	}
}
FolderPathBuilderRowTextOnly._DEFAULT_STATE = {
	text: "",
	isFreeText: true,
	isJournalEntryName: false,
};

class FolderPathBuilderRow extends FolderPathBuilderRowTextOnly {
	render ($parent, parent) {
		this._parent = parent;

		const $dispIsJournalEntry = this._$getDispIsJournalEntry();

		const $btnToggleFreeText = ComponentUiUtil.$getBtnBool(this, "isFreeText", {$ele: $(`<button class="btn btn-xs mr-1 imp-folder__btn-mode">Custom</button>`)});

		const $iptName = ComponentUiUtil.$getIptStr(this, "text").attr("type", "text");
		if (this._fnOnKeydown) $iptName.keydown(evt => this._fnOnKeydown(evt));
		const $wrpFreeText = $$`<div class="ve-flex mr-1 w-100">${$iptName}</div>`;

		const folderMetaKeys = Object.keys(this._folderMeta)
			.sort((a, b) => SortUtil.ascSortLower(this._folderMeta[a].label, this._folderMeta[b].label));
		const $selProp = ComponentUiUtil.$getSelEnum(
			this,
			"selectedProp",
			{
				values: folderMetaKeys,
				isAllowNull: true,
				fnDisplay: (k) => this._folderMeta[k].label,
			},
		);
		const $wrpSelProp = $$`<div class="ve-flex mr-1 w-100">${$selProp}</div>`;

		const hookFreeText = () => {
			$wrpFreeText.toggleClass("ve-hidden", !this._state.isFreeText);
			$wrpSelProp.toggleClass("ve-hidden", this._state.isFreeText);
		};
		hookFreeText();
		this._addHookBase("isFreeText", hookFreeText);

		const $btnRemove = $(`<button class="btn btn-danger btn-xs"><span class="fas fa-fw fa-trash"></span></button>`)
			.click(() => {
				const {removeRow} = this._parent;
				removeRow(this);
			});

		this._$row = $$`<div class="ve-flex-v-center w-100 my-1 imp-folder__row">
			${$btnToggleFreeText}
			<div class="ve-flex-col">
				${$dispIsJournalEntry}
				${$wrpFreeText}
				${$wrpSelProp}
			</div>
			${DragReorderUiUtil.$getDragPad2(() => this._$row, $parent, this._parent)}
			${$btnRemove}
		</div>`.appendTo($parent);
	}

	_getDefaultState () { return {...FolderPathBuilderRow._DEFAULT_STATE}; }

	static getStateFromDefault_ (val, {folderPathMeta, ...rest} = {}) {
		const comp = new FolderPathBuilderRow({...rest});
		if (val?.metaKey) {
			if (!folderPathMeta?.[val.metaKey]) throw new Error(`Folder path meta key "${val.metaKey}" was not found in the available values!`);
			comp.__state.isFreeText = false;
			comp.__state.selectedProp = val.metaKey;
		} else {
			comp.__state.text = val;
		}
		return comp.__state;
	}

	static getStateFromFolder_ (fld) {
		return {
			...FolderPathBuilderRow._DEFAULT_STATE,
			text: fld.name,
			isFreeText: true,
		};
	}
}
FolderPathBuilderRow._DEFAULT_STATE = {
	isFreeText: true,
	text: "",
	selectedProp: null,
};

class FolderPathBuilderApp extends Application {
	constructor ({fpApp, folderType}) {
		super({
			width: 480,
			height: 480,
			title: "Edit Folder Path",
			template: `${SharedConsts.MODULE_LOCATION}/template/FolderPathBuilder.hbs`,
			resizable: true,
		});
		this._comp = new FolderPathBuilder({fpApp, folderType});
	}

	activateListeners ($html) {
		super.activateListeners($html);
		this._comp.render($html);
	}
}

class UtilCompendium {
		static init () {
		UtilHooks.on(UtilHooks.HK_CONFIG_UPDATE, () => this._pHandleConfigUpdate());
		this._pHandleConfigUpdate().then(null);

		Hooks.on("updateCompendium", (pack) => this._pHandleCompendiumUpdate({pack}));
	}

	static async _pHandleConfigUpdate () {
		await this._pFlushCompendiumCaches();
	}

	static async _pHandleCompendiumUpdate ({pack}) {
		await this._pFlushCompendiumCaches({pack});
	}

		static async _pFlushCompendiumCaches ({pack} = {}) {
		await this._COMPENDIUM_CACHES_LOCK.pLock();
		try {
			this._pFlushCompendiumCaches_({pack});
		} finally {
			this._COMPENDIUM_CACHES_LOCK.unlock();
		}
	}

	static _pFlushCompendiumCaches_ ({pack} = {}) {
				if (pack) {
			ConfigConsts.getCompendiumPaths()
				.forEach(([group, key]) => {
					const currentValue = Config.get(group, key) || "";

					const toCheckIdents = new Set(this._getCompendiumsFromString(currentValue).map(it => it.collection));
					if (!toCheckIdents.has(pack.collection)) return;

					Object.entries(this._COMPENDIUM_CACHES)
						.forEach(([_KEY, cached]) => {
							Object.keys(cached)
								.filter(ident => ident === pack.collection)
								.forEach(ident => MiscUtil.deleteObjectPath(this._COMPENDIUM_CACHES, _KEY, ident));
						});
				});

			return;
		}

		ConfigConsts.getCompendiumPaths()
			.forEach(path => {
				const [group, key] = path;
				const pathKey = path.join("___");

				const storedValue = this._COMPENDIUM_CONFIG_PREV_VALUES[pathKey] || "";
				const currentValue = Config.get(group, key) || "";

				if (storedValue.trim() !== currentValue.trim()) {
					const toDumpIdents = CollectionUtil.setDiff(
						new Set(this._getCompendiumsFromString(storedValue).map(it => it.collection)),
						new Set(this._getCompendiumsFromString(currentValue).map(it => it.collection)),
					);

					Object.entries(this._COMPENDIUM_CACHES)
						.forEach(([_KEY, cached]) => {
							Object.keys(cached)
								.filter(ident => toDumpIdents.has(ident))
								.forEach(ident => MiscUtil.deleteObjectPath(this._COMPENDIUM_CACHES, _KEY, ident));
						});
				}

				this._COMPENDIUM_CONFIG_PREV_VALUES[pathKey] = currentValue;
			});
	}
	
		static async pGetCompendiumData (compendium, isContent, {taskRunner = null} = {}) {
				isContent = isContent || UtilCompat.isBabeleActive();

						const maxTimeSecs = 10;
		const taskRunnerLineMeta = taskRunner ? taskRunner.addLogLine(`Caching compendium &quot;<i>${compendium.metadata.label.qq()}</i>&quot;...`) : null;
		const compendiumData = await Promise.race([
			isContent ? compendium.getDocuments() : compendium.getIndex(),
			MiscUtil.pDelay(maxTimeSecs * 1000, null),
		]);
		if (taskRunner) taskRunner.addLogLine(`Cached compendium &quot;<i>${compendium.metadata.label.qq()}</i>&quot;.`, {linkedLogLineMeta: taskRunnerLineMeta});
		if (!compendiumData) {
			console.warn(...LGT, `Loading of ${compendium?.metadata?.system}.${compendium?.metadata?.name} took more than ${maxTimeSecs} seconds! This usually means the compendium is inaccessible. Cancelling compendium load.`);
			return [];
		}
		return compendiumData;
	}

		static async pGetCompendiumImage (entityType, entity, opts) {
		return this._pGetCacheAndGetCompendiumData(
			this._COMPENDIUM_CACHE_KEY_IMAGE,
			this._getAdditionalDataCompendiums({entityType}),
			entityType,
			entity,
			opts,
		);
	}

		static async _pGetCacheAndGetCompendiumData (cacheId, compendiums, entityType, entity, opts) {
		opts = opts || {};

		if (!compendiums?.length) return null;

		if (!opts.isIgnoreSrd && !entity.srd) return null;

		let lookupMetas = [];
		if (entity.name) lookupMetas.push((typeof entity.srd === "string" ? entity.srd : entity.name).toLowerCase().trim());
		if (entity._displayName) lookupMetas.push(entity._displayName.toLowerCase().trim());

		if (opts.deepKeys) {
						lookupMetas = lookupMetas.map(it => ({name: it}));

			if (opts.fnGetAliases) {
				const aliasMetas = opts.fnGetAliases(entity);
				aliasMetas.forEach(it => it.name = it.name ? it.name.toLowerCase().trim() : it.name);
								lookupMetas.unshift(...aliasMetas);
			}
		} else {
			if (opts.fnGetAliases) lookupMetas.push(...opts.fnGetAliases(entity).map(it => it.toLowerCase().trim()));
		}

				if (opts.deepKeys) {
			cacheId = {
				baseCacheId: cacheId,
				deepKeys: opts.deepKeys,
				cacheId: [cacheId, ...opts.deepKeys.sort(SortUtil.ascSortLower)].join("__"),
			};
		}

		await this._COMPENDIUM_CACHES_LOCK.pLock();
		try {
						for (const lookupMeta of lookupMetas) {
				for (const compendium of compendiums) {
					if (!this._isCompendiumCached(this._COMPENDIUM_CACHES, cacheId, compendium)) {
						await this._pCacheCompendium(this._COMPENDIUM_CACHES, cacheId, compendium, {taskRunner: opts.taskRunner});
					}

					const out = this._getCachedCompendiumData(this._COMPENDIUM_CACHES, cacheId, compendium, lookupMeta);
					if (out) return out;
				}
			}
		} finally {
			this._COMPENDIUM_CACHES_LOCK.unlock();
		}
	}

	static _getCompendiumsFromString (joinedCompendiumNamesOrArray) {
		if (!joinedCompendiumNamesOrArray) return [];

		joinedCompendiumNamesOrArray = typeof joinedCompendiumNamesOrArray === "string"
			? joinedCompendiumNamesOrArray
				.split(",")
				.map(it => it.trim().toLowerCase())
			: joinedCompendiumNamesOrArray
				.map(it => it.toLowerCase());

		return joinedCompendiumNamesOrArray
			.map(it => game.packs.find(x => x.collection.toLowerCase() === it))
			.filter(Boolean);
	}

	static _getAdditionalDataCompendiums ({entityType}) {
		switch (entityType) {
			case "spell": return this._getCompendiumsFromString(Config.get("importSpell", "additionalDataCompendium"));
			case "monster": return this._getCompendiumsFromString(Config.get("importCreature", "additionalDataCompendium"));
			case "item": return this._getCompendiumsFromString(Config.get("importItem", "additionalDataCompendium"));
			case "class": return this._getCompendiumsFromString(Config.get("importClass", "additionalDataCompendiumClasses"));
			case "subclass": return this._getCompendiumsFromString(Config.get("importClass", "additionalDataCompendiumSubclasses"));
			case "classFeature": return this._getCompendiumsFromString(Config.get("importClass", "additionalDataCompendiumFeatures"));
			case "subclassFeature": return this._getCompendiumsFromString(Config.get("importClass", "additionalDataCompendiumFeatures"));
			case "optionalfeature": return this._getCompendiumsFromString(Config.get("importOptionalFeature", "additionalDataCompendium"));
			case "race": return this._getCompendiumsFromString(Config.get("importRace", "additionalDataCompendium"));
			case "raceFeature": return this._getCompendiumsFromString(Config.get("importRaceFeature", "additionalDataCompendiumFeatures"));
			case "monsterFeature": return this._getCompendiumsFromString(Config.get("importCreature", "additionalDataCompendiumFeatures"));
			case "background": return this._getCompendiumsFromString(Config.get("importBackground", "additionalDataCompendium"));
			case "backgroundFeature": return this._getCompendiumsFromString(Config.get("importBackground", "additionalDataCompendiumFeatures"));
			case "table": return this._getCompendiumsFromString(Config.get("importTable", "additionalDataCompendium"));
			default: return null;
		}
	}

	static _getReplacementDataCompendiums ({entityType}) {
		switch (entityType) {
			case "spell": return this._getCompendiumsFromString(Config.get("importSpell", "replacementDataCompendium"));
			case "item": return this._getCompendiumsFromString(Config.get("importItem", "replacementDataCompendium"));
			default: return null;
		}
	}

		static async pGetActorItemCompendiumImage (entityType, entity, opts) {
		return this._pGetCacheAndGetActorItemCompendiumData(
			this._COMPENDIUM_CACHE_KEY_IMAGE,
			entityType,
			entity,
			opts,
		);
	}

		static async _pGetCacheAndGetActorItemCompendiumData (cacheId, entityType, entity, opts) {
		opts = opts || {};

		let lookupMetas = [];
		if (entity.name) lookupMetas.push((typeof entity.srd === "string" ? entity.srd : entity.name).toLowerCase().trim());
		if (entity._displayName) lookupMetas.push(entity._displayName.toLowerCase().trim());

		if (opts.fnGetAliases) lookupMetas.push(...opts.fnGetAliases(entity).map(it => it.toLowerCase().trim()));

		let compendiums;
		switch (cacheId) {
			case this._COMPENDIUM_CACHE_KEY_IMAGE: {
				switch (entityType) {
					case "monsterFeature": compendiums = this._getCompendiumsFromString(Config.get("importCreature", "additionalDataCompendium")); break;
					default: return null;
				}

				break;
			}

			case this._COMPENDIUM_CACHE_KEY_SYSTEM: {
				switch (entityType) {
					case "monsterFeature": compendiums = this._getCompendiumsFromString(ConfigConsts.SRD_COMPENDIUMS_CREATURES); break;
					default: return null;
				}

				break;
			}

			default: throw new Error(`Unknown cache ID "${cacheId}"`);
		}

		if (!compendiums.length) return null;

		await this._COMPENDIUM_ACTOR_CACHES_LOCK.pLock();
		try {
						for (const lookupMeta of lookupMetas) {
				for (const compendium of compendiums) {
					if (!this._isCompendiumCached(this._COMPENDIUM_ACTOR_CACHES, cacheId, compendium)) {
						await this._pCacheActorItemCompendium(this._COMPENDIUM_ACTOR_CACHES, cacheId, compendium, {taskRunner: opts.taskRunner});
					}

					const out = this._getCachedCompendiumData(this._COMPENDIUM_ACTOR_CACHES, cacheId, compendium, lookupMeta);
					if (out) return out;
				}
			}
		} finally {
			this._COMPENDIUM_ACTOR_CACHES_LOCK.unlock();
		}
	}

		static async getCompendiumEntity (entityType, entity, opts = {}) {
		const out = await this._pGetCacheAndGetCompendiumData(
			this._COMPENDIUM_CACHE_KEY_SYSTEM,
			this._getReplacementDataCompendiums({entityType}),
			entityType,
			entity,
			{
				...opts,
				isIgnoreSrd: true,
			},
		);
		if (!out) return out;

				delete out._id;

		return out;
	}

		static async getSrdCompendiumEntity (entityType, entity, opts) {
		return this._pGetCacheAndGetCompendiumData(
			this._COMPENDIUM_CACHE_KEY_SYSTEM,
			this._getAdditionalDataCompendiums({entityType}),
			entityType,
			entity,
			opts,
		);
	}

	static _isCompendiumCached (_CACHES, cacheId, compendium) {
		cacheId = cacheId.cacheId || cacheId;
		return !!MiscUtil.get(_CACHES, cacheId, compendium.collection);
	}

		static async _pCacheCompendium (_CACHES, cacheId, compendium, {taskRunner = null} = {}) {
		let isContent;
		if (cacheId.baseCacheId) {
			isContent = true;
		} else {
			switch (cacheId) {
				case this._COMPENDIUM_CACHE_KEY_IMAGE: isContent = false; break;
				case this._COMPENDIUM_CACHE_KEY_SYSTEM: isContent = true; break;
				default: throw new Error(`Unknown cache ID "${cacheId}"`);
			}
		}

		const compendiumData = await this.pGetCompendiumData(compendium, isContent, {taskRunner});

		const cache = MiscUtil.getOrSet(_CACHES, cacheId.cacheId || cacheId, compendium.collection, {});
		if (!compendiumData) return;

		if (cacheId.baseCacheId) {
			compendiumData.forEach(it => cache[this._getCleanCompendiumContentName(this._getCompendiumDocOriginalName(it))] = MiscUtil.copy(it.system));
		} else {
			switch (cacheId) {
				case this._COMPENDIUM_CACHE_KEY_IMAGE: compendiumData.forEach(it => cache[this._getCleanCompendiumContentName(this._getCompendiumDocOriginalName(it))] = it.img); break;
				case this._COMPENDIUM_CACHE_KEY_SYSTEM: compendiumData.forEach(it => cache[this._getCleanCompendiumContentName(this._getCompendiumDocOriginalName(it))] = it.toObject()); break;
				default: throw new Error(`Unknown cache ID "${cacheId}"`);
			}
		}
	}

		static async _pCacheActorItemCompendium (caches, cacheId, compendium, {taskRunner = null} = {}) {
		const compendiumData = await this.pGetCompendiumData(compendium, true, {taskRunner});

		const cache = MiscUtil.getOrSet(caches, cacheId.cacheId || cacheId, compendium.collection, {});
		if (!compendiumData) return;

		compendiumData.forEach(act => {
			act.items.forEach(it => {
				const cleanName = this._getCleanCompendiumContentName(this._getCompendiumDocOriginalName(it));
								switch (cacheId) {
					case this._COMPENDIUM_CACHE_KEY_IMAGE: {
						if (!it.img || UtilImage.isDefaultActorImage(it.img)) return;
						cache[cleanName] = cache[cleanName] || it.img;
						break;
					}
					case this._COMPENDIUM_CACHE_KEY_SYSTEM: cache[cleanName] = cache[cleanName] || it.toObject(); break;
					default: throw new Error(`Unknown cache ID "${cacheId}"`);
				}
			});
		});
	}

	static _getCachedCompendiumData (_CACHES, cacheId, compendium, lookupNameOrMeta) {
		const cache = MiscUtil.get(_CACHES, cacheId.cacheId || cacheId, compendium.collection);
		if (!cache) return null;
		const fromCache = cache[lookupNameOrMeta.name || lookupNameOrMeta];
		if (!fromCache || typeof lookupNameOrMeta === "string") return fromCache;

		const isMatch = Object.entries(lookupNameOrMeta)
			.filter(([keyPath]) => keyPath !== "name")
			.every(([keyPath, valRequired]) => {
				if (typeof valRequired === "string") valRequired = valRequired.toLowerCase().trim();

				let it;
				const pathParts = keyPath.split(".");
				for (const pathPart of pathParts) {
					it = (it || fromCache)[pathPart];
					if (it === undefined) return false;
				}
				if (typeof it === "string") it = this._getCleanCompendiumContentName(it);

				return it === valRequired;
			});

		if (!isMatch) return null;

		switch (cacheId.baseCacheId) {
			case this._COMPENDIUM_CACHE_KEY_IMAGE: return fromCache.img;
			case this._COMPENDIUM_CACHE_KEY_SYSTEM: return fromCache;
			default: throw new Error(`Unknown cache ID "${cacheId.baseCacheId}"`);
		}
	}

		static _getCompendiumDocOriginalName (doc) {
		if (!UtilCompat.isBabeleActive()) return doc.name;
		return doc.getFlag(UtilCompat.MODULE_BABELE, "originalName") || doc.name;
	}

	static _getCleanCompendiumContentName (name) {
		return name
			.trim()
			.toLowerCase()
			.replace(CleanUtil.SHARED_REPLACEMENTS_REGEX, (match) => CleanUtil.SHARED_REPLACEMENTS[match]);
	}

		static pGetPlutoniumCompendiumId (page, hash) {
		switch (page) {
			case UrlUtil.PG_BESTIARY: return this._pGetPlutoniumCompendiumId_generic({page, hash, packName: SharedConsts.PACK_NAME_CREATURES});
			case UrlUtil.PG_ITEMS: return this._pGetPlutoniumCompendiumId_generic({page, hash, packName: SharedConsts.PACK_NAME_ITEMS});
			case UrlUtil.PG_SPELLS: return this._pGetPlutoniumCompendiumId_generic({page, hash, packName: SharedConsts.PACK_NAME_SPELLS});
			default: throw new Error(`Unhandled page "${page}"`);
		}
	}

	static async _pGetPlutoniumCompendiumId_generic ({page, hash, packName}) {
		const pack = game.packs.get(`${SharedConsts.MODULE_ID}.${packName}`);
		if (!pack) return null;

		if (!UtilCompendium._PLUT_CACHES[packName]) {
			const lock = UtilCompendium._PLUT_CACHES_LOCKS[packName] || new VeLock();
			try {
				await lock.pLock();
				if (!UtilCompendium._PLUT_CACHES[packName]) UtilCompendium._PLUT_CACHES[packName] = await pack.getDocuments();
			} finally {
				lock.unlock();
			}
		}

		const match = UtilCompendium._PLUT_CACHES[packName].find(it => it.flags?.[SharedConsts.MODULE_ID]?.page === page && it.flags?.[SharedConsts.MODULE_ID]?.hash === hash);
		if (!match) return null;

		return {
			packName: packName,
			packPackage: SharedConsts.MODULE_ID,
			packId: match.id,
		};
	}
	
	static getAvailablePacks ({folderType}) {
		return game.packs.filter(it => !it.locked && it.metadata.type === folderType);
	}

	static async pGetUserCreatePack ({folderType}) {
		const $dispPackName = $(`<div class="w-100 italic"></div>`);
		const packLabel = await InputUiUtil.pGetUserString({
			title: `Enter New "${folderType}" Compendium Name`,
			fnIsValid: str => Parser.stringToSlug(str).length,
			$elePost: $$`<label class="mb-2 split-v-center ve-muted">
					<div class="mr-2 bold no-wrap">Compendium ID:</div>
					${$dispPackName}
				</label>`,
			cbPostRender: ({comp, propValue}) => {
				const hkId = () => $dispPackName.text(comp._state[propValue] ? (Parser.stringToSlug(comp._state[propValue]) || "(Invalid)") : "\u2014");
				comp._addHookBase(propValue, hkId);
				hkId();
			},
		});
		if (!packLabel || !packLabel.trim()) return null;

		return CompendiumCollection.createCompendium({
			type: "Item",
			label: packLabel,
			name: Parser.stringToSlug(packLabel),
			package: "world",
		});
	}

	static $getSelCompendium ({availablePacks = null, folderType = null}) {
		availablePacks = availablePacks || this.getAvailablePacks({folderType});
		return $(`<select class="block ve-foundry-button m-0">
			${availablePacks.map((pack) => `<option value="${pack.collection}">${pack.metadata.label}</option>`).join("")}
		</select>`);
	}

	static getPackByCollection ({collection}) {
		if (collection == null) return null;
		return game.packs.find(it => it.collection === collection);
	}
}

UtilCompendium._COMPENDIUM_CACHE_KEY_IMAGE = "img";
UtilCompendium._COMPENDIUM_CACHE_KEY_SYSTEM = "system";
UtilCompendium._COMPENDIUM_CONFIG_PREV_VALUES = {};
UtilCompendium._COMPENDIUM_CACHES = {};
UtilCompendium._COMPENDIUM_CACHES_LOCK = new VeLock();
UtilCompendium._COMPENDIUM_ACTOR_IMAGE_LAST_VALUES = {};
UtilCompendium._COMPENDIUM_ACTOR_CACHES = {};
UtilCompendium._COMPENDIUM_ACTOR_CACHES_LOCK = new VeLock();

UtilCompendium._PLUT_CACHES = {};
UtilCompendium._PLUT_CACHES_LOCKS = {};

class Charactermancer_Race_Util {
	static async pPostLoadPrereleaseBrew (fileData) {
		const out = {race: []};

		if (fileData.race) out.race.push(...Renderer.race.mergeSubraces(fileData.race, {isAddBaseRaces: true}));

		if (fileData.subrace) {
			const baseListSite = MiscUtil.copy((await Vetools.pGetRaces({isAddBaseRaces: true})).race);
			baseListSite.forEach(it => PageFilterRaces.mutateForFilters(it));

			const baseListBrew = MiscUtil.copy([...fileData.race || []]);
			baseListBrew.forEach(it => PageFilterRaces.mutateForFilters(it));
			const baseList = [...baseListBrew, ...baseListSite];

			const nxtData = Renderer.race.adoptSubraces(baseList, fileData.subrace);
			const mergedNxtData = Renderer.race.mergeSubraces(nxtData);

			out.race.push(...mergedNxtData);
		}

		return out;
	}
}

class Charactermancer_Race_SizeSelect extends BaseComponent {
		static async pGetUserInput ({sizes}) {
		if (!sizes || !sizes.length) return {isFormComplete: true, data: Parser.SZ_MEDIUM};
		const comp = new this({sizes});
		if (comp.isNoChoice()) return comp.pGetFormData();
		return UtilApplications.pGetImportCompApplicationFormData({comp, isAutoResize: true});
	}
	
		constructor (opts) {
		opts = opts || {};
		super();

		this._sizes = opts.sizes || [Parser.SZ_MEDIUM];
	}

	get modalTitle () { return `Choose Size`; }

	render ($wrp) {
		if (this._sizes.length === 1) {
			$wrp.append(`<div>${Parser.sizeAbvToFull(this._sizes[0])}</div>`);
			return;
		}

		ComponentUiUtil.$getSelEnum(
			this,
			"size",
			{
				values: this._sizes,
				isAllowNull: true,
				fnDisplay: Parser.sizeAbvToFull,
			},
		)
			.appendTo($wrp);
	}

	isNoChoice () { return this._sizes.length <= 1; }

	pGetFormData () {
		return {
			isFormComplete: this._state.size != null,
			data: this._sizes.length === 1 ? this._sizes[0] : this._state.size,
		};
	}
}

class UtilDataSource {
	static sortListItems (a, b, o) {
		const ixTypeA = Math.min(...a.values.filterTypes.map(it => UtilDataSource.SOURCE_TYPE_ORDER.indexOf(it)));
		const ixTypeB = Math.min(...b.values.filterTypes.map(it => UtilDataSource.SOURCE_TYPE_ORDER.indexOf(it)));

		return SortUtil.ascSort(ixTypeA, ixTypeB) || SortUtil.compareListNames(a, b);
	}

	static _PROPS_NO_BLOCKLIST = new Set(["itemProperty", "itemType", "spellList"]);
	static _PROP_RE_FOUNDRY = /^foundry[A-Z]/;

	static getMergedData (data, {isFilterBlocklisted = true} = {}) {
		const mergedData = {};

		data.forEach(sourceData => {
			Object.entries(sourceData)
				.forEach(([prop, arr]) => {
					if (!arr || !(arr instanceof Array)) return;
					if (mergedData[prop]) mergedData[prop] = [...mergedData[prop], ...MiscUtil.copy(arr)];
					else mergedData[prop] = MiscUtil.copy(arr);
				});
		});

		if (isFilterBlocklisted) {
			Object.entries(mergedData)
				.forEach(([prop, arr]) => {
					if (!arr || !(arr instanceof Array)) return;
					mergedData[prop] = mergedData[prop]
						.filter(it => {
														if (SourceUtil.getEntitySource(it) === VeCt.STR_GENERIC) return false;

							if (it.__prop && this._PROPS_NO_BLOCKLIST.has(it.__prop)) return true;
							if (it.__prop && this._PROP_RE_FOUNDRY.test(it.__prop)) return false;

														if (!SourceUtil.getEntitySource(it)) {
								console.warn(`Entity did not have a "source"! This should never occur.`);
								return true;
							}
							if (!it.__prop) {
								console.warn(`Entity did not have a "__prop"! This should never occur.`);
								return true;
							}
							if (!UrlUtil.URL_TO_HASH_BUILDER[it.__prop]) {
								console.warn(`No hash builder found for "__prop" "${it.__prop}"! This should never occur.`);
								return true;
							}
							
														switch (it.__prop) {
								case "class": {
									if (!it.subclasses?.length) break;

									it.subclasses = it.subclasses.filter(sc => {
										if (sc.source === VeCt.STR_GENERIC) return false;

										return !ExcludeUtil.isExcluded(
											UrlUtil.URL_TO_HASH_BUILDER["subclass"](sc),
											"subclass",
											sc.source,
											{isNoCount: true},
										);
									});

									break;
								}

								case "item":
								case "baseitem":
								case "itemGroup":
								case "magicvariant":
								case "_specificVariant": {
									return !Renderer.item.isExcluded(it);
								}
							}
							
							return !ExcludeUtil.isExcluded(
								UrlUtil.URL_TO_HASH_BUILDER[it.__prop](it),
								it.__prop,
								SourceUtil.getEntitySource(it),
								{isNoCount: true},
							);
						});
				});
		}

		return mergedData;
	}

		static async pHandleBackgroundLoad ({pLoad, isBackground = false, cntSources = null}) {
		const pTimeout = isBackground ? MiscUtil.pDelay(500, VeCt.SYM_UTIL_TIMEOUT) : null;

		const promises = [pLoad, pTimeout].filter(Boolean);

		const winner = await Promise.race(promises);
		if (winner === VeCt.SYM_UTIL_TIMEOUT) ui.notifications.info(`Please wait while ${cntSources != null ? `${cntSources} source${cntSources === 1 ? " is" : "s are"}` : "data is being"} loaded...`);
		return pLoad;
	}

	static _IGNORED_KEYS = new Set([
		"_meta",
		"$schema",
	]);
	static async pGetAllContent (
		{
			sources,
			uploadedFileMetas,
			customUrls,
			isBackground = false,
			userData,
			cacheKeys = null,

						page,
			isDedupable = false,
			fnGetDedupedData = null,
			
									fnGetBlocklistFilteredData = null,
			
						isAutoSelectAll = false,
					},
	) {
		const allContent = [];

		if (
			isAutoSelectAll
			&& this.isTooManySources({cntSources: sources.length})
		) {
			const ptHelp = `This may take a (very) long time! If this seems like too much, ${game.user.isGM ? "your GM" : "you"} may have to adjust ${game.user.isGM ? "your" : "the"} "Data Sources" Config options/${game.user.isGM ? "your" : "the"} "World Data Source Selector" list to limit the number of sources selected by default.`;

			console.warn(...LGT, `${sources.length} source${sources.length === 1 ? "" : "s"} are being loaded! ${ptHelp}`);

			if (
				!(await InputUiUtil.pGetUserBoolean({
					title: "Too Many Sources",
					htmlDescription: `You are about to load ${sources.length} source${sources.length === 1 ? "" : "s"}. ${ptHelp}<br>Would you like to load ${sources.length} source${sources.length === 1 ? "" : "s"}?`,
					textNo: "Cancel",
					textYes: "Continue",
				}))
			) return null;
		}

		const pLoad = sources.pMap(async source => {
			await source.pLoadAndAddToAllContent({uploadedFileMetas, customUrls, allContent, cacheKeys});
		});

		await UtilDataSource.pHandleBackgroundLoad({pLoad, isBackground, cntSources: sources.length});

				const allContentMerged = {};

				if (allContent.length === 1) Object.assign(allContentMerged, allContent[0]);
		else {
						allContent.forEach(obj => {
				Object.entries(obj)
					.forEach(([k, v]) => {
						if (v == null) return;
						if (this._IGNORED_KEYS.has(k)) return;

						if (!(v instanceof Array)) console.warn(`Could not merge "${typeof v}" for key "${k}"!`);

						allContentMerged[k] = allContentMerged[k] || [];
						allContentMerged[k] = [...allContentMerged[k], ...v];
					});
			});
		}

		let dedupedAllContentMerged = fnGetDedupedData
			? fnGetDedupedData({allContentMerged, isDedupable})
			: this._getDedupedAllContentMerged({allContentMerged, isDedupable});

		dedupedAllContentMerged = fnGetBlocklistFilteredData
			? fnGetBlocklistFilteredData({dedupedAllContentMerged, page})
			: this._getBlocklistFilteredData({dedupedAllContentMerged, page});

		if (Config.get("import", "isShowVariantsInLists")) {
			Object.entries(dedupedAllContentMerged)
				.forEach(([k, arr]) => {
					if (!(arr instanceof Array)) return;
					dedupedAllContentMerged[k] = arr
						.map(it => [it, ...DataUtil.proxy.getVersions(it.__prop, it)])
						.flat();
				});
		}

		Object.entries(dedupedAllContentMerged)
			.forEach(([k, arr]) => {
				if (!(arr instanceof Array)) return;
				if (!arr.length) delete dedupedAllContentMerged[k];
			});

		return {dedupedAllContentMerged, cacheKeys, userData};
	}

	static isTooManySources ({cntSources}) {
		return Config.get("dataSources", "tooManySourcesWarningThreshold") != null
			&& cntSources >= Config.get("dataSources", "tooManySourcesWarningThreshold");
	}

	static _getBlocklistFilteredData ({dedupedAllContentMerged, page}) {
		if (!UrlUtil.URL_TO_HASH_BUILDER[page]) return dedupedAllContentMerged;
		dedupedAllContentMerged = {...dedupedAllContentMerged};
		Object.entries(dedupedAllContentMerged)
			.forEach(([k, arr]) => {
				if (!(arr instanceof Array)) return;
				dedupedAllContentMerged[k] = arr.filter(it => {
					if (it.source === VeCt.STR_GENERIC) return false;

										if (!SourceUtil.getEntitySource(it)) {
						console.warn(`Entity did not have a "source"! This should never occur.`);
						return true;
					}
					if (!it.__prop) {
						console.warn(`Entity did not have a "__prop"! This should never occur.`);
						return true;
					}
					
										switch (it.__prop) {
						case "item":
						case "baseitem":
						case "itemGroup":
						case "magicvariant":
						case "_specificVariant": {
							return !Renderer.item.isExcluded(it);
						}
					}
					
					return !ExcludeUtil.isExcluded(
						(UrlUtil.URL_TO_HASH_BUILDER[it.__prop] || UrlUtil.URL_TO_HASH_BUILDER[page])(it),
						it.__prop,
						SourceUtil.getEntitySource(it),
						{isNoCount: true},
					);
				});
			});
		return dedupedAllContentMerged;
	}

	static _getDedupedAllContentMerged ({allContentMerged, page, isDedupable = false}) {
		if (!isDedupable) return allContentMerged;
		return this._getDedupedData({allContentMerged, page});
	}

	static _getDedupedData ({allContentMerged, page}) {
		if (!UrlUtil.URL_TO_HASH_BUILDER[page]) return allContentMerged;

		const contentHashes = new Set();
		Object.entries(allContentMerged)
			.forEach(([k, arr]) => {
				if (!(arr instanceof Array)) return;
				allContentMerged[k] = arr.filter(it => {
					const fnGetHash = UrlUtil.URL_TO_HASH_BUILDER[page];
					if (!fnGetHash) return true;
					const hash = fnGetHash(it);
					if (contentHashes.has(hash)) return false;
					contentHashes.add(hash);
					return true;
				});
			});

		return allContentMerged;
	}

	static async pPostLoadGeneric ({isPrerelease, isBrew}, out) {
		out = {...out};

		if ((isBrew || isPrerelease) && (out.race || out.subrace)) {
			const nxt = await Charactermancer_Race_Util.pPostLoadPrereleaseBrew(out);
			Object.assign(out, nxt || {});
		}

		if ((isBrew || isPrerelease) && (out.item || out.baseitem || out.magicvariant || out.itemGroup)) {
			if (isBrew) out.item = await Vetools.pGetBrewItems(out);
			else if (isPrerelease) out.item = await Vetools.pGetPrereleaseItems(out);

			delete out.baseitem;
			delete out.magicvariant;
			delete out.itemProperty;
			delete out.itemType;
			delete out.itemGroup;
		}

		return out;
	}

	
	static getSourceFilterTypes (src) {
		return SourceUtil.isPrereleaseSource(src)
			? [UtilDataSource.SOURCE_TYP_PRERELEASE]
			: SourceUtil.isNonstandardSource(src)
				? [UtilDataSource.SOURCE_TYP_EXTRAS]
				: [UtilDataSource.SOURCE_TYP_OFFICIAL_SINGLE];
	}

	
	static getSourcesCustomUrl (nxtOpts = {}) {
		return [
			new UtilDataSource.DataSourceUrl(
				"Custom URL",
				"",
				{
					...nxtOpts,
					filterTypes: [UtilDataSource.SOURCE_TYP_CUSTOM],
					isAutoDetectPrereleaseBrew: true,
				},
			),
		];
	}

	static getSourcesUploadFile (nxtOpts = {}) {
		return [
			new UtilDataSource.DataSourceFile(
				"Upload File",
				{
					...nxtOpts,
					filterTypes: [UtilDataSource.SOURCE_TYP_CUSTOM],
					isAutoDetectPrereleaseBrew: true,
				},
			),
		];
	}

	static async pGetSourcesPrerelease (dirsPrerelease, nxtOpts = {}) {
		return this._pGetSourcesPrereleaseBrew({
			brewUtil: PrereleaseUtil,
			localSources: await Vetools.pGetLocalPrereleaseSources(...dirsPrerelease),
			sources: await Vetools.pGetPrereleaseSources(...dirsPrerelease),
			filterTypesLocal: [UtilDataSource.SOURCE_TYP_PRERELEASE, UtilDataSource.SOURCE_TYP_PRERELEASE_LOCAL],
			filterTypes: [UtilDataSource.SOURCE_TYP_PRERELEASE],
			nxtOpts,
		});
	}

	static async pGetSourcesBrew (dirsHomebrew, nxtOpts = {}) {
		return this._pGetSourcesPrereleaseBrew({
			brewUtil: BrewUtil2,
			localSources: await Vetools.pGetLocalBrewSources(...dirsHomebrew),
			sources: await Vetools.pGetBrewSources(...dirsHomebrew),
			filterTypesLocal: [UtilDataSource.SOURCE_TYP_BREW, UtilDataSource.SOURCE_TYP_BREW_LOCAL],
			filterTypes: [UtilDataSource.SOURCE_TYP_BREW],
			nxtOpts,
		});
	}

	static async _pGetSourcesPrereleaseBrew ({localSources, sources, nxtOpts, brewUtil, filterTypesLocal, filterTypes}) {
		return [
			...localSources.map(({name, url, abbreviations}) => new UtilDataSource.DataSourceUrl(
				name,
				url,
				{
					...nxtOpts,
					filterTypes: [...filterTypesLocal],
					abbreviations,
					brewUtil,
					isExistingPrereleaseBrew: true, 				},
			)),
			...sources.map(({name, url, abbreviations}) => new UtilDataSource.DataSourceUrl(
				name,
				url,
				{
					...nxtOpts,
					filterTypes: [...filterTypes],
					abbreviations,
					brewUtil,
				},
			)),
		];
	}

	static getSourceType (json, {isErrorOnMultiple = false} = {}) {
		const isPrereleasePerSource = (json._meta?.sources || []).map(it => SourceUtil.isPrereleaseSource(it.json || ""));
		const isPrerelease = isPrereleasePerSource.every(it => it);
		const isBrew = isPrereleasePerSource.every(it => !it);

		if (isPrerelease && isBrew && isErrorOnMultiple) throw new Error(`Could not determine if data contained homebrew or if data contained prerelease content! Please ensure all homebrew/prerelease files have a valid "_meta.sources", and that no file contains both homebrew and prerelease sources.`);

		return {isPrerelease, isBrew};
	}
}

UtilDataSource.SOURCE_TYP_OFFICIAL_BASE = "Official";
UtilDataSource.SOURCE_TYP_OFFICIAL_ALL = `${UtilDataSource.SOURCE_TYP_OFFICIAL_BASE} (All)`;
UtilDataSource.SOURCE_TYP_OFFICIAL_SINGLE = `${UtilDataSource.SOURCE_TYP_OFFICIAL_BASE} (Single Source)`;
UtilDataSource.SOURCE_TYP_CUSTOM = "Custom/User";
UtilDataSource.SOURCE_TYP_EXTRAS = "Extras";
UtilDataSource.SOURCE_TYP_PRERELEASE = "Prerelease";
UtilDataSource.SOURCE_TYP_PRERELEASE_LOCAL = "Local Prerelease";
UtilDataSource.SOURCE_TYP_BREW = "Homebrew";
UtilDataSource.SOURCE_TYP_BREW_LOCAL = "Local Homebrew";
UtilDataSource.SOURCE_TYP_UNKNOWN = "Unknown";

UtilDataSource.SOURCE_TYPE_ORDER = [
	UtilDataSource.SOURCE_TYP_OFFICIAL_ALL,
	UtilDataSource.SOURCE_TYP_CUSTOM,
	UtilDataSource.SOURCE_TYP_OFFICIAL_SINGLE,
	UtilDataSource.SOURCE_TYP_EXTRAS,
	UtilDataSource.SOURCE_TYP_PRERELEASE_LOCAL,
	UtilDataSource.SOURCE_TYP_PRERELEASE,
	UtilDataSource.SOURCE_TYP_BREW_LOCAL,
	UtilDataSource.SOURCE_TYP_BREW,
	UtilDataSource.SOURCE_TYP_UNKNOWN,
];

UtilDataSource.SOURCE_TYPE_ORDER__FILTER = [ 	UtilDataSource.SOURCE_TYP_OFFICIAL_ALL,
	UtilDataSource.SOURCE_TYP_OFFICIAL_SINGLE,
	UtilDataSource.SOURCE_TYP_EXTRAS,
	UtilDataSource.SOURCE_TYP_PRERELEASE_LOCAL,
	UtilDataSource.SOURCE_TYP_PRERELEASE,
	UtilDataSource.SOURCE_TYP_BREW_LOCAL,
	UtilDataSource.SOURCE_TYP_BREW,
	UtilDataSource.SOURCE_TYP_CUSTOM,
	UtilDataSource.SOURCE_TYP_UNKNOWN,
];

UtilDataSource.DataSourceBase = class {
		constructor (name, opts) {
		this.name = name;

		this._pPostLoad = opts.pPostLoad;
		this._brewUtil = opts.brewUtil;
		this._isAutoDetectPrereleaseBrew = !!opts.isAutoDetectPrereleaseBrew;
		this._isExistingPrereleaseBrew = !!opts.isExistingPrereleaseBrew;
		this.filterTypes = opts.filterTypes || [UtilDataSource.SOURCE_TYP_UNKNOWN];
		this.isDefault = !!opts.isDefault;
		this.abbreviations = opts.abbreviations;
		this.isWorldSelectable = !!opts.isWorldSelectable;
	}

	get identifier () { throw new Error(`Unimplemented!`); }
	get identifierWorld () { return this.isDefault ? "5etools" : this.identifier; }

		isCacheable () { throw new Error("Unimplemented!"); }
		async pGetOutputs ({uploadedFileMetas, customUrls}) { throw new Error("Unimplemented!"); }

	async _pGetBrewUtil (...args) {
		if (this._brewUtil) return this._brewUtil;
		if (!this._isAutoDetectPrereleaseBrew) return null;
		return this._pGetBrewUtilAutodetected(...args);
	}

		async _pGetBrewUtilAutodetected (...args) { throw new Error("Unimplemented!"); }

	async pLoadAndAddToAllContent ({uploadedFileMetas, customUrls, allContent, cacheKeys = null}) {
		const meta = await this.pGetOutputs({uploadedFileMetas, customUrls});
		allContent.push(...meta.contents);
		if (cacheKeys && this.isCacheable()) cacheKeys.push(...meta.cacheKeys);
	}
};

UtilDataSource.DataSourceUrl = class extends UtilDataSource.DataSourceBase {
		constructor (name, url, opts) {
		opts = opts || {};

		super(name, {isWorldSelectable: !!url, ...opts});

		this.url = url;
		this.source = opts.source;
		this.userData = opts.userData;
	}

	get identifier () { return this.url === "" ? `VE_SOURCE_CUSTOM_URL` : this.url; }
	get identifierWorld () { return this.source ?? super.identifierWorld; }

	isCacheable () { return true; }

	async pGetOutputs ({uploadedFileMetas, customUrls}) {
		if (this.url === "") {
			customUrls = customUrls || [];

			let loadedDatas;
			try {
				loadedDatas = await Promise.all(customUrls.map(async url => {
					const brewUtil = await this._pGetBrewUtil(url);
					if (brewUtil && !this._isExistingPrereleaseBrew) await brewUtil.pAddBrewFromUrl(url);

					const data = await DataUtil.loadJSON(url);
					return this._pPostLoad ? this._pPostLoad(data, this.userData) : data;
				}));
			} catch (e) {
				ui.notifications.error(`Failed to load one or more URLs! ${VeCt.STR_SEE_CONSOLE}`);
				throw e;
			}

			return {
				cacheKeys: customUrls,
				contents: loadedDatas,
			};
		}

		let data;
		try {
			const brewUtil = await this._pGetBrewUtil(this.url);
			if (brewUtil && !this._isExistingPrereleaseBrew) await brewUtil.pAddBrewFromUrl(this.url);

			data = await DataUtil.loadJSON(this.url);
			if (this._pPostLoad) data = await this._pPostLoad(data, this.userData);
		} catch (e) {
			const msg = `Failed to load URL "${this.url}"!`;
			ui.notifications.error(`${msg} ${VeCt.STR_SEE_CONSOLE}`);
			console.error(msg);
			throw e;
		}
		return {
			cacheKeys: [this.url],
			contents: [data],
		};
	}

	async _pGetBrewUtilAutodetected (url) {
		const json = await DataUtil.loadJSON(url);
		const {isPrerelease, isBrew} = UtilDataSource.getSourceType(json, {isErrorOnMultiple: true});
		if (isPrerelease) return PrereleaseUtil;
		if (isBrew) return BrewUtil2;
		return null;
	}
};

UtilDataSource.DataSourceFile = class extends UtilDataSource.DataSourceBase {
		constructor (name, opts) {
		opts = opts || {};

		super(name, {isWorldSelectable: false, ...opts});

		this.isFile = true;
	}

	get identifier () { return `VE_SOURCE_CUSTOM_FILE`; }

		isCacheable () { return false; }

	async pGetOutputs ({uploadedFileMetas, customUrls}) {
		uploadedFileMetas = uploadedFileMetas || [];

		const allContent = await uploadedFileMetas.pMap(async fileMeta => {
			const brewUtil = await this._pGetBrewUtil(fileMeta.contents);
			if (brewUtil && !this._isExistingPrereleaseBrew) await brewUtil.pAddBrewsFromFiles([{json: fileMeta.contents, name: fileMeta.name}]);

			const contents = await DataUtil.pDoMetaMerge(CryptUtil.uid(), MiscUtil.copyFast(fileMeta.contents));

			return this._pPostLoad ? this._pPostLoad(contents, this.userData) : contents;
		});

		return {
			contents: allContent
				.filter(it => it != null),
		};
	}

	async _pGetBrewUtilAutodetected (json) {
		const {isPrerelease, isBrew} = UtilDataSource.getSourceType(json, {isErrorOnMultiple: true});
		if (isPrerelease) return PrereleaseUtil;
		if (isBrew) return BrewUtil2;
		return null;
	}
};

UtilDataSource.DataSourceSpecial = class extends UtilDataSource.DataSourceBase {
		constructor (name, pGet, opts) {
		opts = opts || {};

		super(name, {isWorldSelectable: true, ...opts});

		this.special = {pGet};
		if (!opts.cacheKey) throw new Error(`No cache key specified!`);
		this.cacheKey = opts.cacheKey;
	}

	get identifier () { return this.cacheKey; }

	isCacheable () { return true; }

	async pGetOutputs ({uploadedFileMetas, customUrls}) {
		let loadedData;
		try {
			const json = await Vetools.pLoadImporterSourceSpecial(this);
			loadedData = json;
			if (this._pPostLoad) loadedData = await this._pPostLoad(loadedData, json, this.userData);
		} catch (e) {
			ui.notifications.error(`Failed to load pre-defined source "${this.cacheKey}"! ${VeCt.STR_SEE_CONSOLE}`);
			throw e;
		}
		return {
			cacheKeys: [this.cacheKey],
			contents: [loadedData],
		};
	}

	async _pGetBrewUtilAutodetected () { throw new Error("Unimplemented!"); }
};

function MixinModalFilterFvtt (Cls) {
	class MixedModalFilterFvtt extends Cls {
		constructor (...args) {
			super(...args);

			this._prevApp = null;
		}

		_getNameStyle () { return ""; }

		_getShowModal (resolve) {
			if (this._prevApp) this._prevApp.close();

			const self = this;

			const app = new class TempApplication extends Application {
				constructor () {
					super({
						title: `Filter/Search for ${self._modalTitle}`,
						template: `${SharedConsts.MODULE_LOCATION}/template/_Generic.hbs`,
						width: Util.getMaxWindowWidth(900),
						height: Util.getMaxWindowHeight(),
						resizable: true,
					});

					this._$wrpHtmlInner = $(`<div class="ve-flex-col w-100 h-100"></div>`);
				}

				get $modalInner () { return this._$wrpHtmlInner; }

				async close (...args) {
					self._filterCache.$wrpModalInner.detach();
					await super.close(...args);
					resolve([]);
				}

				activateListeners ($html) {
					this._$wrpHtmlInner.appendTo($html);
				}
			}();

			app.render(true);
			this._prevApp = app;

			return {$modalInner: app.$modalInner, doClose: app.close.bind(app)};
		}

		getDataFromSelected (selected) { return this._allData[selected.ix]; }
	}
	return MixedModalFilterFvtt;
}

class ModalFilterBackgroundsFvtt extends MixinModalFilterFvtt(ModalFilterBackgrounds) {}

class ModalFilterClassesFvtt extends MixinModalFilterFvtt(ModalFilterClasses) {}

class ModalFilterFeatsFvtt extends MixinModalFilterFvtt(ModalFilterFeats) {}

class ModalFilterRacesFvtt extends MixinModalFilterFvtt(ModalFilterRaces) {}

class ModalFilterSpellsFvtt extends MixinModalFilterFvtt(ModalFilterSpells) {}

class ModalFilterItemsFvtt extends MixinModalFilterFvtt(ModalFilterItems) {}

class Charactermancer_AdditionalSpellsUtil {
		static getFlatData (additionalSpells) {
		additionalSpells = MiscUtil.copy(additionalSpells);

		return additionalSpells.map(additionalSpellBlock => {
			const outMeta = {};
			const outSpells = {};

			const keyPath = [];

			Object.entries(additionalSpellBlock).forEach(([additionType, additionMeta]) => {
				keyPath.push(additionType);

				switch (additionType) {
										case "name":
					case "ability": outMeta[additionType] = additionMeta; break;

										case "resourceName": break;

					case "innate":
					case "known":
					case "prepared":
					case "expanded": {
						this._getFlatData_doProcessAdditionMeta({additionType, additionMeta, outSpells, keyPath, resourceName: additionalSpellBlock.resourceName});
						break;
					}

					default: throw new Error(`Unhandled spell addition type "${additionType}"`);
				}

				keyPath.pop();
			});

			return {meta: outMeta, spells: outSpells};
		});
	}

	static _getFlatData_doProcessAdditionMeta (opts) {
		const {additionMeta, keyPath} = opts;

		Object.entries(additionMeta).forEach(([levelOrCasterLevel, levelMeta]) => {
			keyPath.push(levelOrCasterLevel);

			if (levelMeta instanceof Array) {
				levelMeta.forEach((spellItem, ix) => this._getFlatData_doProcessSpellItem({...opts, levelOrCasterLevel, spellItem, ix}));
			} else {
				Object.entries(levelMeta).forEach(([rechargeType, levelMetaInner]) => {
					this._getFlatData_doProcessSpellRechargeBlock({...opts, levelOrCasterLevel, rechargeType, levelMetaInner});
				});
			}

			keyPath.pop();
		});
	}

	static _getFlatData_doProcessSpellItem (opts) {
		const {additionType, additionMeta, outSpells, keyPath, spellItem, ix, rechargeType, uses, usesPer, levelOrCasterLevel, consumeType, consumeAmount, consumeTarget, vetConsumes} = opts;

		keyPath.push(ix);

		const outSpell = {
			isExpanded: additionType === "expanded",
			isAlwaysPrepared: additionType === "prepared",
			isAlwaysKnown: additionType === "known",
			isPrepared: additionType === "prepared" || additionType === "innate" || additionType === "known",
			preparationMode: (additionType === "prepared" || additionType === "known") ? "always" : "innate",
			consumeType,
			consumeAmount,
			consumeTarget,
			vetConsumes,
		};

		if (levelOrCasterLevel !== "_") { 			const mCasterLevel = /^s(\d+)$/.exec(levelOrCasterLevel);
			if (mCasterLevel) outSpell.requiredCasterLevel = Number(mCasterLevel[1]);
			else if (!isNaN(levelOrCasterLevel)) outSpell.requiredLevel = Number(levelOrCasterLevel);
		}

		if (rechargeType) {
			switch (rechargeType) {
				case "rest":
				case "daily": break; 
				case "will":
				case "ritual":
				case "resource": {
					outSpell.preparationMode = "atwill";
					outSpell.isPrepared = rechargeType !== "ritual";
					break;
				}

				case "_": break;

				default: throw new Error(`Unhandled recharge type "${rechargeType}"`);
			}
		}

		if (uses) outSpell.uses = uses;
		if (usesPer) outSpell.usesPer = usesPer;

		if (typeof spellItem === "string") {
			const key = keyPath.join("__");

			outSpells[key] = new Charactermancer_AdditionalSpellsUtil.FlatSpell({
				type: "spell",

				key,
				...outSpell,
				uid: spellItem,
			});
		} else {
			if (spellItem.all != null) { 				const key = keyPath.join("__");

				outSpells[key] = new Charactermancer_AdditionalSpellsUtil.FlatSpell({
					type: "all",

					key,
					...outSpell,
					filterExpression: spellItem.all,
				});
			} else if (spellItem.choose != null) {
				if (typeof spellItem.choose === "string") { 					const count = spellItem.count || 1;

					for (let i = 0; i < count; ++i) {
						keyPath.push(i);

						const key = keyPath.join("__");

						outSpells[key] = new Charactermancer_AdditionalSpellsUtil.FlatSpell({
							type: "choose",

							key,
							...outSpell,
							filterExpression: spellItem.choose,
						});

						keyPath.pop();
					}
				} else if (spellItem.choose.from) { 					const count = spellItem.choose.count || 1;

					const groupId = CryptUtil.uid();
					[...spellItem.choose.from]
						.sort((a, b) => SortUtil.ascSortLower(a, b))
						.forEach((uid, i) => {
							keyPath.push(i);

							const key = keyPath.join("__");

							outSpells[key] = new Charactermancer_AdditionalSpellsUtil.FlatSpell({
								type: "chooseFrom",

								key,
								...outSpell,
								uid: uid,
								chooseFromGroup: groupId,
								chooseFromCount: count,
							});

							keyPath.pop();
						});
				} else {
					throw new Error(`Unhandled additional spell format: "${JSON.stringify(spellItem)}"`);
				}
			} else throw new Error(`Unhandled additional spell format: "${JSON.stringify(spellItem)}"`);
		}

		keyPath.pop();
	}

	static _getFlatData_doProcessSpellRechargeBlock (opts) {
		const {additionType, additionMeta, outSpells, keyPath, resourceName, levelOrCasterLevel, rechargeType, levelMetaInner} = opts;

		keyPath.push(rechargeType);

		switch (rechargeType) {
			case "rest":
			case "daily": {
				const usesPer = rechargeType === "rest" ? "sr" : "lr";

				Object.entries(levelMetaInner)
					.forEach(([numTimesCast, spellList]) => {
						keyPath.push(numTimesCast);

												numTimesCast = numTimesCast.replace(/^(\d+)e$/, "$1");
						const uses = Number(numTimesCast);

						spellList.forEach((spellItem, ix) => this._getFlatData_doProcessSpellItem({...opts, spellItem, ix, uses, usesPer}));

						keyPath.pop();
					});

				break;
			}

			case "resource": {
				Object.entries(levelMetaInner)
					.forEach(([consumeAmount, spellList]) => {
						keyPath.push(consumeAmount);

						spellList.forEach((spellItem, ix) => this._getFlatData_doProcessSpellItem({...opts, spellItem, ix, vetConsumes: {name: resourceName, amount: Number(consumeAmount)}}));

						keyPath.pop();
					});

				break;
			}

			case "will":
			case "ritual":
			case "_": {
				levelMetaInner.forEach((spellItem, ix) => this._getFlatData_doProcessSpellItem({...opts, spellItem, ix}));
				break;
			}

			default: throw new Error(`Unhandled spell recharge type "${rechargeType}"`);
		}

		keyPath.pop();
	}
	}

Charactermancer_AdditionalSpellsUtil.FlatSpell = class {
	#opts = null; 
		constructor (opts) {
		this.#opts = opts;

		this.type = opts.type;
		this.key = opts.key;
		this.isExpanded = opts.isExpanded; 		this.isPrepared = opts.isPrepared;
		this.isAlwaysKnown = opts.isAlwaysKnown;
		this.isAlwaysPrepared = opts.isAlwaysPrepared;
		this.preparationMode = opts.preparationMode;
		this.requiredCasterLevel = opts.requiredCasterLevel;
		this.requiredLevel = opts.requiredLevel;

		this.uses = opts.uses;
		this.usesPer = opts.usesPer;

		this.consumeType = opts.consumeType;
		this.consumeAmount = opts.consumeAmount;
		this.consumeTarget = opts.consumeTarget;

		this.vetConsumes = opts.vetConsumes;

		this.isCantrip = false;

						this.uid = null;
		this.castAtLevel = null;
		if (opts.uid) {
			const {uid, isCantrip, castAtLevel} = Charactermancer_AdditionalSpellsUtil.FlatSpell._getExpandedUid(opts.uid);
			this.uid = uid;
			this.isCantrip = isCantrip;
			this.castAtLevel = castAtLevel;
		}
		
				this.filterExpression = opts.filterExpression;
		if (opts.filterExpression && opts.filterExpression.split("|").filter(Boolean).some(it => /^level=0$/i.test(it.trim()))) {
			this.isCantrip = true;
		}
		
				this.chooseFromGroup = opts.chooseFromGroup;
		this.chooseFromCount = opts.chooseFromCount;
		
				if (this.isCantrip && !this.isExpanded) this.isAlwaysKnown = true;
	}

	static _getExpandedUid (uidRaw) {
		const [uidPart, castAtLevelPart] = uidRaw.split("#").map(it => it.trim()).filter(Boolean);

		let [name, source] = Renderer.splitTagByPipe(uidPart.toLowerCase());
		source = source || Parser.SRC_PHB.toLowerCase();
		const uid = `${name}|${source}`;

		const isCantrip = castAtLevelPart && castAtLevelPart.toLowerCase() === "c";
		const castAtLevel = isCantrip ? null : (castAtLevelPart && !isNaN(castAtLevelPart)) ? Number(castAtLevelPart) : null;

		return {uid, isCantrip, castAtLevel};
	}

	getCopy (optsNxt = null) {
		return new this.constructor({
			...this.#opts,
			...optsNxt || {},
		});
	}

	toObject () { return MiscUtil.copy(this); }
};

class Charactermancer_AdditionalSpellsSelect extends BaseComponent {
			static async pGetUserInput (opts) {
		opts = opts || {};
		const {additionalSpells} = opts;

		if (!additionalSpells || !additionalSpells.length) return {isFormComplete: true, data: []};

		const comp = this.getComp(opts);

		if (comp.isNoChoice({curLevel: opts.curLevel, targetLevel: opts.targetLevel, isStandalone: opts.isStandalone})) return comp.pGetFormData();

		return UtilApplications.pGetImportCompApplicationFormData({
			comp,
			width: 640,
			height: 220,
		});
	}

	static _MODAL_FILTER_SPELLS_DEFAULT = null;

	static async pGetInitModalFilterSpells () {
		if (!this._MODAL_FILTER_SPELLS_DEFAULT) {
			this._MODAL_FILTER_SPELLS_DEFAULT = new ModalFilterSpellsFvtt({namespace: "Charactermancer_AdditionalSpellsSelect.spells", isRadio: true});
			await this._MODAL_FILTER_SPELLS_DEFAULT.pPreloadHidden();
		}
		return this._MODAL_FILTER_SPELLS_DEFAULT;
	}

		static getComp (opts) {
		opts = opts || {};

		const comp = new this({...opts});
		comp.curLevel = opts.curLevel;
		comp.targetLevel = opts.targetLevel;
		comp.spellLevelLow = opts.spellLevelLow;
		comp.spellLevelHigh = opts.spellLevelHigh;
		comp.isAnyCantrips = !!opts.isAnyCantrips;

		return comp;
	}

		static async pApplyFormDataToActor (actor, formData, opts) {
		opts = opts || {};

		if (!formData || !formData?.data?.length) return;

		const ability = ((opts.abilityAbv === "inherit" ? opts.parentAbilityAbv : opts.abilityAbv) || (formData.abilityAbv === "inherit" ? opts.parentAbilityAbv : formData.abilityAbv)) ?? undefined;

		const {ImportListSpell} = await Promise.resolve().then(function () { return ImportListSpell$1; });
		const importListSpell = new ImportListSpell({actor});

		for (const spellMeta of formData.data) {
						if (spellMeta.isExpanded) continue;

			let [name, source] = spellMeta.uid.split("|");
			if (!source) source = Parser.SRC_PHB;
			const hash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_SPELLS]({name, source});

			const spell = await DataLoader.pCacheAndGet(UrlUtil.PG_SPELLS, source, hash);
			if (!spell) {
				const message = `Could not find spell "${hash}" when applying additional spells!`;
				ui.notifications.warn(message);
				console.warn(...LGT, message);
				continue;
			}

			await importListSpell.pImportEntry(
				spell,
				{
					taskRunner: opts.taskRunner,
					opts_pGetSpellItem: {
						ability,
						usesMax: spellMeta.uses,
						usesValue: spellMeta.uses,
						usesPer: spellMeta.usesPer,
						consumeType: spellMeta.consumeType,
						consumeAmount: spellMeta.consumeAmount,
						consumeTarget: spellMeta.consumeTarget,
						vetConsumes: spellMeta.vetConsumes,
						isPrepared: spellMeta.isPrepared,
						preparationMode: spellMeta.preparationMode,
						castAtLevel: spellMeta.castAtLevel,

												isIgnoreExisting: true,
					},
				},
			);
		}
	}

	static isNoChoice (additionalSpells, {additionalSpellsFlat = null, curLevel = null, targetLevel = null, isStandalone = false} = {}) {
		if (additionalSpells.length !== 1) return false;
		additionalSpellsFlat = additionalSpellsFlat || Charactermancer_AdditionalSpellsUtil.getFlatData(additionalSpells);

		const minLevel = curLevel ?? Number.MIN_SAFE_INTEGER;
		const maxLevel = targetLevel ?? Number.MAX_SAFE_INTEGER;

		const spellsInRange = additionalSpellsFlat.some(it => Object.values(it.spells)
			.some(it => (!isStandalone || !it.isExpanded) && (it.requiredLevel == null || (it.requiredLevel >= minLevel && it.requiredLevel <= maxLevel))),
		);

		if (!spellsInRange) return true;

		return !additionalSpellsFlat.some(it => it.meta.ability?.choose || Object.values(it.spells).some(it => (it.type !== "all" && it.filterExpression != null) || it.chooseFromGroup != null));
	}
	
		constructor (opts) {
		opts = opts || {};
		super();

		this._additionalSpells = opts.additionalSpells;
		this._sourceHintText = opts.sourceHintText;
		this._modalFilterSpells = opts.modalFilterSpells;

		this._additionalSpellsFlat = Charactermancer_AdditionalSpellsUtil.getFlatData(opts.additionalSpells);
	}

	get modalTitle () { return `Choose Additional Spell Set${this._sourceHintText ? ` (${this._sourceHintText})` : ""}`; }

	set curLevel (val) { this._state.curLevel = val; }
	set targetLevel (val) { this._state.targetLevel = val; }
	set spellLevelLow (val) { this._state.spellLevelLow = val; }
	set spellLevelHigh (val) { this._state.spellLevelHigh = val; }
	set isAnyCantrips (val) { this._state.isAnyCantrips = !!val; }

		addHookAlwaysPreparedSpells (hk) { this._addHookBase("spellsAlwaysPrepared", hk); }
	addHookExpandedSpells (hk) { this._addHookBase("spellsExpanded", hk); }
	addHookAlwaysKnownSpells (hk) { this._addHookBase("spellsAlwaysKnown", hk); }

	get spellsAlwaysPrepared () { return this._state.spellsAlwaysPrepared; }
	get spellsExpanded () { return this._state.spellsExpanded; }
	get spellsAlwaysKnown () { return this._state.spellsAlwaysKnown; }

	_render_addLastAlwaysPreparedSpellsHook () { return this._render_addLastBoolSpellsHook({propState: "spellsAlwaysPrepared", propIsBool: "isAlwaysPrepared"}); }
	_render_addLastExpandedSpellsHook () { return this._render_addLastBoolSpellsHook({propState: "spellsExpanded", propIsBool: "isExpanded"}); }
	_render_addLastAlwaysKnownSpellsHook () { return this._render_addLastBoolSpellsHook({propState: "spellsAlwaysKnown", propIsBool: "isAlwaysKnown"}); }

	_render_addLastBoolSpellsHook ({propState, propIsBool}) {
		const hk = () => {
			const formData = this.getFormData();
			const nxt = formData.data.filter(it => it[propIsBool]).map(it => it.uid.toLowerCase());

			const setCurr = new Set(this._state[propState]);
			const setNxt = new Set(nxt);
			if (!CollectionUtil.setEq(setCurr, setNxt)) this._state[propState] = nxt;
		};
		this._addHookBase("ixSet", hk);
		this._addHookBase("curLevel", hk);
		this._addHookBase("targetLevel", hk);
		this._addHookBase("spellLevelLow", hk);
		this._addHookBase("spellLevelHigh", hk);
		this._addHookBase("isAnyCantrips", hk);
		this._addHookBase("pulseChoose", hk);
		hk();
	}
	
	render ($wrp) {
		this._render_addLastAlwaysPreparedSpellsHook();
		this._render_addLastExpandedSpellsHook();
		this._render_addLastAlwaysKnownSpellsHook();

		const $wrpOptionsButtons = $(`<div class="ve-flex-v-center ve-flex-wrap w-100 btn-group ${this._additionalSpellsFlat.length > 1 ? "mb-1" : ""}"></div>`);
		const $wrpOptions = $(`<div class="ve-flex-col w-100"></div>`);

		for (let i = 0; i < this._additionalSpellsFlat.length; ++i) this._render_renderOptions($wrpOptionsButtons, $wrpOptions, i);

		$$($wrp)`
			${$wrpOptionsButtons}
			${$wrpOptions}
		`;
	}

	_render_renderOptions ($wrpOptionsButtons, $wrpOptions, ix) {
		const additionalSpellsFlatBlock = this._additionalSpellsFlat[ix];

								const $btnSelect = this._additionalSpellsFlat.length === 1
			? null
			: $(`<button class="btn btn-xs ve-flex-1" title="Select Spell Set">${additionalSpellsFlatBlock.meta.name ?? `Spell Set ${ix + 1}`}</button>`)
				.click(() => this._state.ixSet = ix);

																const isInnatePreparedList = this._isAnyInnatePrepared(ix);
		const isExpandedList = this._isAnyExpanded(ix);

		const sortedSpells = Object.values(additionalSpellsFlatBlock.spells)
			.sort((a, b) => SortUtil.ascSort(a.requiredLevel || 0, b.requiredLevel || 0) || SortUtil.ascSort(a.requiredCasterLevel || 0, b.requiredCasterLevel || 0));

		const $wrpInnatePreparedHeaders = isInnatePreparedList ? $(`<div class="ve-flex-v-center py-1">
			<div class="col-3 text-center">Level</div>
			<div class="col-9">Spells</div>
		</div>`) : null;

		const $wrpExpandedHeaders = isExpandedList ? $(`<div class="ve-flex-v-center py-1">
			<div class="col-3 text-center">Spell Level</div>
			<div class="col-9">Spells</div>
		</div>`) : null;

		const $rowsInnatePrepared = isInnatePreparedList ? this._render_$getRows(ix, sortedSpells, {isExpandedMatch: false}) : null;
		const $rowsExpanded = isExpandedList ? this._render_$getRows(ix, sortedSpells, {isExpandedMatch: true}) : null;

		const $wrpNoneAvailableInnatePrepared = isInnatePreparedList ? $(`<div class="ve-small ve-flex-v-center my-1 w-100 italic ve-muted">No spells at this level</div>`) : null;
		const $wrpNoneAvailableExpanded = isExpandedList ? $(`<div class="ve-small ve-flex-v-center my-1 w-100 italic ve-muted">No spells at this level</div>`) : null;

		const hkSpellsAvailable = () => {
			const isInnatePreparedAvailable = !!this._getFlatInnatePreparedSpellsInRange(ix).length;
			if ($wrpInnatePreparedHeaders) $wrpInnatePreparedHeaders.toggleVe(isInnatePreparedAvailable);
			if ($wrpNoneAvailableInnatePrepared) $wrpNoneAvailableInnatePrepared.toggleVe(!isInnatePreparedAvailable);

			const isExpandedAvailable = !!this._getFlatExpandedSpellsInRange(ix).length;
			if ($wrpExpandedHeaders) $wrpExpandedHeaders.toggleVe(isExpandedAvailable);
			if ($wrpNoneAvailableExpanded) $wrpNoneAvailableExpanded.toggleVe(!isExpandedAvailable);
		};
		this._addHookBase("spellLevelLow", hkSpellsAvailable);
		this._addHookBase("spellLevelHigh", hkSpellsAvailable);
		this._addHookBase("isAnyCantrips", hkSpellsAvailable);
		this._addHookBase("curLevel", hkSpellsAvailable);
		this._addHookBase("targetLevel", hkSpellsAvailable);
		this._addHookBase("ixSet", hkSpellsAvailable);
		hkSpellsAvailable();

		const $stgInnatePrepared = isInnatePreparedList ? $$`<div class="ve-flex-col">
			<div class="bold my-0">Innate/Prepared/Known Spells</div>
			${$wrpInnatePreparedHeaders}
			${$rowsInnatePrepared}
			${$wrpNoneAvailableInnatePrepared}
		</div>` : null;

		const $stgExpanded = isExpandedList ? $$`<div class="ve-flex-col">
			<div class="bold my-0">Expanded Spell List</div>
			${$wrpExpandedHeaders}
			${$rowsExpanded}
			${$wrpNoneAvailableExpanded}
		</div>` : null;

		const isChooseAbility = this._isChooseAbility(ix);

		const $wrpChooseAbility = isChooseAbility ? this._render_$getSelChooseAbility(ix) : null;

		const $stgAbility = isChooseAbility ? $$`<div class="split-v-center">
			<div class="bold my-0 no-shrink mr-2">Ability Score</div>
			${$wrpChooseAbility}
		</div>` : null;

		if ($btnSelect) $wrpOptionsButtons.append($btnSelect);

		const $stg = $$`<div class="ve-flex-col">
			${$stgInnatePrepared}
			${$stgExpanded}
			${$stgAbility}
		</div>`.appendTo($wrpOptions);

		if (this._additionalSpellsFlat.length !== 1) {
			const hkIsActive = () => {
				$btnSelect.toggleClass("active", this._state.ixSet === ix);
				$stg.toggleVe(this._state.ixSet === ix);
			};
			this._addHookBase("ixSet", hkIsActive);
			hkIsActive();

									const hkResetActive = (prop, value, prevValue) => {
				const prevBlock = this._additionalSpellsFlat[prevValue];
				const nxtState = Object.values(prevBlock.spells).mergeMap(it => ({[it.key]: null}));
				this._proxyAssignSimple("state", nxtState);
			};
			this._addHookBase("ixSet", hkResetActive);
		}
	}

	_getProps_chooseFrom ({groupUid}) {
		return {
			propBase: `chooseFrom_${groupUid}`,
		};
	}

	_render_$getRows (ix, spells, {isExpandedMatch}) {
		if (!spells.length) return null;

		const byLevel = {};
		spells.forEach(flat => {
			if (flat.isExpanded !== isExpandedMatch) return;

			const level = flat.requiredCasterLevel || flat.requiredLevel;
			(byLevel[level] = byLevel[level] || []).push(flat);
		});

		const getFlatVars = flat => ({
			requiredLevel: flat.requiredLevel,
			requiredCasterLevel: flat.requiredCasterLevel,
			isRequiredCasterLevel: flat.requiredCasterLevel != null,
			isRequiredLevel: flat.requiredLevel != null,
			isExpanded: flat.isExpanded,
		});

		return Object.entries(byLevel)
			.sort(([kA], [kB]) => SortUtil.ascSort(Number(kA), Number(kB)))
			.map(([, flats]) => {
				const {
					requiredLevel,
					requiredCasterLevel,
					isRequiredCasterLevel,
					isRequiredLevel,
					isExpanded: isAnyExpanded,
				} = getFlatVars(flats[0]);

				const metasRenderedFlats = [];

								const chooseFromGroups = {};
				flats = flats.filter(flat => {
					if (!flat.chooseFromGroup) return true;

					chooseFromGroups[flat.chooseFromGroup] = chooseFromGroups[flat.chooseFromGroup] || {
						from: [],
						count: flat.chooseFromCount ?? 1,
						...getFlatVars(flat),
					};
					chooseFromGroups[flat.chooseFromGroup].from.push(flat);

					return false;
				});
				
				const [flatsBasic, flatsFilter] = flats.segregate(it => it.filterExpression == null);
				flatsBasic.sort((a, b) => SortUtil.ascSortLower(a.uid, b.uid));
				flatsFilter.sort((a, b) => SortUtil.ascSortLower(a.filterExpression, b.filterExpression));

				const $colSpells = $$`<div class="col-9 ve-flex-v-center ve-flex-wrap"></div>`;

				flatsBasic.forEach(flat => {
					const $pt = $(`<div class="ve-flex-v-center"></div>`).fastSetHtml(Renderer.get().render(`{@spell ${flat.uid.toSpellCase()}}`)).appendTo($colSpells);
					const $sep = $(`<div class="mr-1">,</div>`).appendTo($colSpells);

					metasRenderedFlats.push({
						flat,
						$pt,
						$sep,
						...getFlatVars(flat),
					});
				});

				const [flatsFilterChoose, flatsFilterAll] = flatsFilter.segregate(it => it.type !== "all");

				flatsFilterChoose.forEach(flat => {
					const $dispSpell = $(`<div class="ve-flex-v-center"></div>`);
					const hkChosenSpell = () => {
						$dispSpell.html(
							this._state[flat.key] != null && this._state.ixSet === ix
								? `<div>${Renderer.get().render(`{@spell ${this._state[flat.key].toLowerCase()}}`)}</div>`
								: `<div class="italic ve-muted">(select a spell)</div>`,
						);
					};
					this._addHookBase(flat.key, hkChosenSpell);
					if (this._additionalSpellsFlat.length !== 1) {
						this._addHookBase("ixSet", hkChosenSpell);
					}
					hkChosenSpell();

					const $btnFilter = $(`<button class="btn btn-default btn-xxs mx-1" title="Choose a Spell"><span class="fas fa-fw fa-search"></span></button>`)
						.click(async () => {
							const selecteds = await this._modalFilterSpells.pGetUserSelection({filterExpression: flat.filterExpression});
							if (selecteds == null || !selecteds.length) return;

							const selected = selecteds[0];

							this._state[flat.key] = DataUtil.proxy.getUid("spell", {name: selected.name, source: selected.values.sourceJson});
							this._state.pulseChoose = !this._state.pulseChoose;
						});

					if (this._additionalSpellsFlat.length !== 1) {
						const hkDisableBtnFilter = () => $btnFilter.prop("disabled", this._state.ixSet !== ix);
						this._addHookBase("ixSet", hkDisableBtnFilter);
						hkDisableBtnFilter();
					}

					const $pt = $$`<div class="ve-flex-v-center">${$btnFilter}${$dispSpell}</div>`.appendTo($colSpells);
					const $sep = $(`<div class="mr-1">,</div>`).appendTo($colSpells);

					metasRenderedFlats.push({
						flat,
						$pt,
						$sep,
						...getFlatVars(flat),
					});
				});

				flatsFilterAll.forEach(flat => {
					const ptFilter = this._modalFilterSpells.getRenderedFilterExpression({filterExpression: flat.filterExpression});
					const $pt = $$`<div class="ve-flex-v-center"><i class="mr-2 ve-muted">Spells matching:</i> ${ptFilter ? `${ptFilter} ` : ""}</div>`.appendTo($colSpells);
					const $sep = $(`<div class="mr-1">,</div>`).appendTo($colSpells);

					metasRenderedFlats.push({
						flat,
						$pt,
						$sep,
						...getFlatVars(flat),
					});
				});

				Object.entries(chooseFromGroups)
					.forEach(([groupUid, group]) => {
						const {propBase} = this._getProps_chooseFrom({groupUid});

						const meta = ComponentUiUtil.getMetaWrpMultipleChoice(
							this,
							propBase,
							{
								values: group.from.map(it => it.uid),
								fnDisplay: v => Renderer.get().render(`{@spell ${v}}`),
								count: group.count,
							},
						);

												const hkPulse = () => this._state.pulseChoose = !this._state.pulseChoose;
						this._addHookBase(meta.propPulse, hkPulse);

												if (this._additionalSpellsFlat.length !== 1) {
							const hkDisableUi = () => {
								meta.rowMetas.forEach(({$cb}) => $cb.prop("disabled", this._state.ixSet !== ix));
							};
							this._addHookBase("ixSet", hkDisableUi);
							hkDisableUi();
						}

												const $ptsInline = meta.rowMetas.map(({$cb, displayValue}) => {
							return $$`<div class="ve-flex-v-center mr-2 no-wrap">${displayValue}${$cb.addClass("ml-1")}</div>`;
						});

						const $pt = $$`<div class="ve-flex-v-center ve-flex-wrap"><i class="mr-1 ve-muted no-wrap">Choose ${group.count === 1 ? "" : `${group.count} `}from:</i>${$ptsInline}</div>`.appendTo($colSpells);
						const $sep = $(`<div class="mr-1">,</div>`).appendTo($colSpells);

						metasRenderedFlats.push({
							flat: null,
							$pt,
							$sep,
							...group,
						});
					});

				const $row = $$`<div class="py-1 ve-flex-v-center stripe-even">
					<div class="col-3 text-center">${Parser.getOrdinalForm(requiredCasterLevel || requiredLevel) || `<i class="ve-muted">Current</i>`}</div>
					${$colSpells}
				</div>`;

				const doShowInitialPts = () => {
					metasRenderedFlats.forEach(({$pt, $sep}, i) => {
						$pt.showVe();
						$sep.toggleVe(i !== metasRenderedFlats.length - 1);
					});
				};

				const doShowExpandedPts = () => {
					let isExpandedVisible;
					let isAllVisible;
					if (isRequiredCasterLevel) {
						isExpandedVisible = this._isRequiredCasterLevelInRangeUpper(requiredCasterLevel);
						isAllVisible = this._isRequiredCasterLevelInRange(requiredCasterLevel);
					} else if (isRequiredLevel) {
						isExpandedVisible = this._isRequiredLevelInRangeUpper(requiredCasterLevel);
						isAllVisible = this._isRequiredLevelInRange(requiredCasterLevel);
					} else throw new Error(`No need to use this method!`);

					if (isAllVisible || !isExpandedVisible) return doShowInitialPts();

					metasRenderedFlats.forEach((meta, i) => {
						meta.$pt.toggleVe(meta.isExpanded);
						meta.$sep.toggleVe(i !== metasRenderedFlats.length - 1);
					});

															let isFoundFirst = false;
					for (let i = metasRenderedFlats.length - 1; i >= 0; --i) {
						const meta = metasRenderedFlats[i];

						meta.$sep.hideVe();
						if (!meta.isExpanded) continue;

						if (isFoundFirst) {
							meta.$sep.showVe();
							break;
						}

						isFoundFirst = true;
					}
									};

				if (isRequiredCasterLevel) {
					const hkLevel = () => {
						const isVisible = isAnyExpanded ? this._isRequiredCasterLevelInRangeUpper(requiredCasterLevel) : this._isRequiredCasterLevelInRange(requiredCasterLevel);
						$row.toggleVe(isVisible);
						if (!isVisible || !isAnyExpanded) return doShowInitialPts();
						doShowExpandedPts();
					};
					this._addHookBase("spellLevelLow", hkLevel);
					this._addHookBase("spellLevelHigh", hkLevel);
					this._addHookBase("isAnyCantrips", hkLevel);
					hkLevel();
				} else if (isRequiredLevel) {
					const hkLevel = () => {
						const isVisible = isAnyExpanded ? this._isRequiredLevelInRangeUpper(requiredLevel) : this._isRequiredLevelInRange(requiredLevel);
						$row.toggleVe(isVisible);
						if (!isVisible && !isAnyExpanded) return doShowInitialPts();
						doShowExpandedPts();
					};
					this._addHookBase("curLevel", hkLevel);
					this._addHookBase("targetLevel", hkLevel);
					hkLevel();
				} else {
					$row.showVe();
					doShowInitialPts();
				}

				return $row;
			});
	}

	_render_$getSelChooseAbility (ix) {
		return ComponentUiUtil.$getSelEnum(
			this,
			"ability",
			{
				values: this._additionalSpells[ix].ability.choose,
				fnDisplay: abv => Parser.attAbvToFull(abv),
				isAllowNull: true,
			},
		);
	}

	_isRequiredLevelInRange (requiredLevel) {
		return this._isRequiredLevelInRangeLower(requiredLevel)
			&& this._isRequiredLevelInRangeUpper(requiredLevel);
	}

	_isRequiredLevelInRangeLower (requiredLevel) {
		return requiredLevel > (this._state.curLevel ?? Number.MAX_SAFE_INTEGER);
	}

	_isRequiredLevelInRangeUpper (requiredLevel) {
		return requiredLevel <= (this._state.targetLevel ?? Number.MIN_SAFE_INTEGER);
	}

	_isRequiredCasterLevelInRange (requiredCasterLevel) {
				if (requiredCasterLevel === 0) return this._state.isAnyCantrips;

		return this._isRequiredCasterLevelInRangeLower(requiredCasterLevel)
			&& this._isRequiredCasterLevelInRangeUpper(requiredCasterLevel);
	}

	_isRequiredCasterLevelInRangeLower (requiredCasterLevel) {
				if (requiredCasterLevel === 0) return this._state.isAnyCantrips;

		return requiredCasterLevel >= (this._state.spellLevelLow ?? Number.MAX_SAFE_INTEGER);
	}

	_isRequiredCasterLevelInRangeUpper (requiredCasterLevel) {
				if (requiredCasterLevel === 0) return this._state.isAnyCantrips;

		return requiredCasterLevel <= (this._state.spellLevelHigh == null ? Number.MIN_SAFE_INTEGER : this._state.spellLevelHigh);
	}

	_getFlatSpellsInRange (ixSet = null, {isExpandedMatch = null} = {}) {
		if (ixSet == null) ixSet = this._state.ixSet;

		return Object.values((this._additionalSpellsFlat[ixSet] || {spells: []}).spells).filter(flat => {
			if (isExpandedMatch != null) {
				if (flat.isExpanded !== isExpandedMatch) return false;
			}

												if (flat.isExpanded) {
				if (flat.requiredCasterLevel != null) return this._isRequiredCasterLevelInRangeUpper(flat.requiredCasterLevel);
				else if (flat.requiredLevel != null) return this._isRequiredLevelInRangeUpper(flat.requiredLevel);
				return true;
			}

			if (flat.requiredCasterLevel != null) return this._isRequiredCasterLevelInRange(flat.requiredCasterLevel);
			else if (flat.requiredLevel != null) return this._isRequiredLevelInRange(flat.requiredLevel);
			return true;
		});
	}

	_getFlatInnatePreparedSpellsInRange (ixSet) { return this._getFlatSpellsInRange(ixSet, {isExpandedMatch: false}); }
	_getFlatExpandedSpellsInRange (ixSet) { return this._getFlatSpellsInRange(ixSet, {isExpandedMatch: true}); }

	_isAnyInnatePrepared (ixSet) { return this._isAnyInnatePreparedExpanded(ixSet, {isExpandedMatch: false}); }
	_isAnyExpanded (ixSet) { return this._isAnyInnatePreparedExpanded(ixSet, {isExpandedMatch: true}); }

	_isAnyInnatePreparedExpanded (ixSet, {isExpandedMatch}) {
		if (ixSet == null) ixSet = this._state.ixSet;

		return Object.values((this._additionalSpellsFlat[ixSet] || {spells: []}).spells).some(flat => flat.isExpanded === isExpandedMatch);
	}

	_isChooseAbility (ixSet) {
		if (ixSet == null) ixSet = this._state.ixSet;
		return (this._additionalSpells[ixSet]?.ability?.choose?.length ?? 0) > 1;
	}

	isNoChoice ({curLevel, targetLevel, isStandalone} = {}) {
		return this.constructor.isNoChoice(this._additionalSpells, {additionalSpellsFlat: this._additionalSpellsFlat, curLevel, targetLevel, isStandalone});
	}

	getFormData () {
		let flatSpellsInRange = this._getFlatSpellsInRange().map(it => it.getCopy());

				const chooseFromGroups = {};
		flatSpellsInRange.forEach(flat => {
			if (!flat.chooseFromGroup) return;

			chooseFromGroups[flat.chooseFromGroup] = chooseFromGroups[flat.chooseFromGroup] || {
				from: [],
				selectedValues: [],
				isAcceptable: false,
				count: flat.chooseFromCount ?? 1,
			};
			chooseFromGroups[flat.chooseFromGroup].from.push(flat);
		});

		Object.entries(chooseFromGroups)
			.forEach(([groupUid, groupMeta]) => {
				const {propBase} = this._getProps_chooseFrom({groupUid});

				groupMeta.isAcceptable = this._state[ComponentUiUtil.getMetaWrpMultipleChoice_getPropIsAcceptable(propBase)];

				groupMeta.selectedValues = ComponentUiUtil.getMetaWrpMultipleChoice_getSelectedValues(this, propBase, {values: groupMeta.from.map(it => it.uid)});
			});
		
		let cntNotChosen = 0;
		flatSpellsInRange = flatSpellsInRange.filter(flat => {
			if (flat.type === "all") return true; 
			if (flat.filterExpression != null) {
				const choiceMade = this._state[flat.key];
				if (!choiceMade) {
					cntNotChosen++;
					return false;
				}

				flat.filterExpression = null;
				flat.uid = this._state[flat.key];
				return true;
			}

			if (flat.chooseFromGroup != null) {
				return chooseFromGroups[flat.chooseFromGroup].selectedValues.includes(flat.uid);
			}

			return true;
		});

		flatSpellsInRange = flatSpellsInRange
			.flatMap(flat => {
				if (flat.type !== "all") return flat;

												if (flat.filterExpression != null) {
					const filterExpression = flat.filterExpression;
					flat.filterExpression = null;
					return this._modalFilterSpells.getItemsMatchingFilterExpression({filterExpression})
						.map((li, i) => flat.getCopy(
							{
								type: "spell",
								key: `${flat.key}__${i}`,
								uid: DataUtil.proxy.getUid("spell", {name: li.name, source: li.values.sourceJson}),
							},
						));
				}

				if (flat.chooseFromGroup != null) {
					if (chooseFromGroups[flat.chooseFromGroup].selectedValues.includes(flat.uid)) return flat;
				}

				return null;
			})
			.filter(Boolean);

		let abilityAbv;
		if (this._isChooseAbility(this._state.ixSet)) {
			abilityAbv = this._state.ability;
			if (abilityAbv == null) cntNotChosen++;
		} else abilityAbv = (this._additionalSpellsFlat[this._state.ixSet] || {meta: {}}).meta.ability;

		return {
			isFormComplete: cntNotChosen === 0 && Object.values(chooseFromGroups).every(it => it.isAcceptable),
			data: flatSpellsInRange.map(it => it.toObject()),
			abilityAbv,
		};
	}

	pGetFormData () { return this.getFormData(); }

	_getDefaultState () {
		return {
			ixSet: 0,

			curLevel: null,
			targetLevel: null,
			spellLevelLow: null,
			spellLevelHigh: null,
			isAnyCantrips: false,

			spellsAlwaysPrepared: [],
			spellsExpanded: [],
			spellsAlwaysKnown: [],

			ability: null,

			pulseChoose: false,
		};
	}
}

class PageFilterClassesFoundry extends PageFilterClassesRaw {
	static _handleReferenceError (msg) { console.error(...LGT, msg); ui.notifications.error(msg); }

	static _pLoadSubEntries_getMappedWalkerArrayEntry ({it, path, references, actor, isIgnoredLookup, ...opts}) {
		const out = super._pLoadSubEntries_getMappedWalkerArrayEntry({it, path, references, actor, ...opts});
		if (out != null) return out;

		const isIgnored = this._pLoadSubEntries_getMappedWalkerArrayEntry_isIgnored({it, isIgnoredLookup});
		if (isIgnored) return null;

																				
		const meta = this._pLoadSubEntries_getMappedWalkerArrayEntry_getMeta({it});
		const {name, source} = meta;

		const ident = this._pLoadSubEntries_getMappedWalkerArrayEntry_getPageSourceHash({it});
		const b64Ident = btoa(encodeURIComponent(JSON.stringify(ident)));
		
				return {
			type: "wrapper",
						wrapped: actor
				? `@UUID[Actor.${actor.id}.Item.temp-${SharedConsts.MODULE_ID_FAKE}-${b64Ident}]{${name}}`
				: `@UUID[Item.temp-${SharedConsts.MODULE_ID_FAKE}-${b64Ident}]{${name}}`,
			source,
			data: {
				isFvttSyntheticFeatureLink: true,
			},
		};
	}

	static _pLoadSubEntries_getMappedWalkerArrayEntry_getMeta ({it}) {
		switch (it.type) {
			case "refClassFeature": return DataUtil.class.unpackUidClassFeature(it.classFeature);
			case "refSubclassFeature": return DataUtil.class.unpackUidSubclassFeature(it.subclassFeature);
			case "refOptionalfeature": return DataUtil.proxy.unpackUid("optionalfeature", it.optionalfeature, "optfeature");
			default: throw new Error(`Unhandled reference type "${it.type}"`);
		}
	}

	static _pLoadSubEntries_getMappedWalkerArrayEntry_getPageSourceHash ({it}) {
		let page;
		let source;
		let hash;
		switch (it.type) {
			case "refClassFeature": {
				const meta = DataUtil.class.unpackUidClassFeature(it.classFeature);
				page = "classFeature";
				hash = UrlUtil.URL_TO_HASH_BUILDER[page](meta);
				source = meta.source;
				break;
			}

			case "refSubclassFeature": {
				const meta = DataUtil.class.unpackUidSubclassFeature(it.subclassFeature);
				page = "subclassFeature";
				hash = UrlUtil.URL_TO_HASH_BUILDER[page](meta);
				source = meta.source;
				break;
			}

			case "refOptionalfeature": {
				const meta = DataUtil.proxy.unpackUid("optionalfeature", it.optionalfeature, "optfeature");
				page = UrlUtil.PG_OPT_FEATURES;
				hash = UrlUtil.URL_TO_HASH_BUILDER[page](meta);
				source = meta.source;
				break;
			}

			default: throw new Error(`Unhandled reference type "${it.type}"`);
		}

		return {page, source, hash};
	}

	static _pLoadSubEntries_getMappedWalkerArrayEntry_isIgnored ({it, isIgnoredLookup}) {
		if (!isIgnoredLookup) return false;

		switch (it.type) {
			case "refClassFeature": return isIgnoredLookup[(it.classFeature || "").toLowerCase()];
			case "refSubclassFeature": return isIgnoredLookup[(it.subclassFeature || "").toLowerCase()];
			default: return false;
		}
	}
}

class Charactermancer_Class_Util {
	static getAllFeatures (cls) {
		let allFeatures = [];
		const seenSubclassFeatureHashes = new Set();

		const gainSubclassFeatureLevels = cls.classFeatures
			.filter(it => it.gainSubclassFeature)
			.map(cf => cf.level ?? DataUtil.class.unpackUidClassFeature(cf.classFeature || cf).level);

				cls.classFeatures.forEach(cf => {
			allFeatures.push(cf);

			const cfLevel = cf.level ?? DataUtil.class.unpackUidClassFeature(cf.classFeature || cf).level;
			const nxtCfLevel = gainSubclassFeatureLevels.includes(cfLevel) ? gainSubclassFeatureLevels[gainSubclassFeatureLevels.indexOf(cfLevel) + 1] : null;

			cls.subclasses.forEach(sc => {
				sc.subclassFeatures
					.filter(scf => {
						const scfHash = scf.hash ?? DataUtil.class.unpackUidSubclassFeature(scf.subclassFeature || scf).hash;
						const scfLevel = scf.level ?? DataUtil.class.unpackUidSubclassFeature(scf.subclassFeature || scf).level;

						if (seenSubclassFeatureHashes.has(scfHash)) return false;

						if (scf.isGainAtNextFeatureLevel) {
							if (!cf.gainSubclassFeature) return false;

														if (cfLevel === gainSubclassFeatureLevels[0] && scfLevel <= cfLevel) return true;

																					if (scfLevel <= cfLevel && (nxtCfLevel == null || scfLevel < nxtCfLevel)) return true;

							return false;
						}

						return scfLevel === cfLevel;
					})
					.forEach(scf => {
						const scfHash = scf.hash ?? DataUtil.class.unpackUidSubclassFeature(scf.subclassFeature || scf).hash;
						seenSubclassFeatureHashes.add(scfHash);

												scf.level = cfLevel;

						allFeatures.push(scf);
					});
			});
		});

		return MiscUtil.copy(allFeatures);
	}

	static isClassEntryFilterMatch (entry, pageFilter, filterValues) {
		const source = entry.source;
		const options = entry.isClassFeatureVariant ? {isClassFeatureVariant: true} : null;

				if (pageFilter.filterBox) {
			return pageFilter.filterBox.toDisplayByFilters(
				filterValues,
				...[
					{
						filter: pageFilter.sourceFilter,
						value: source,
					},
					pageFilter.optionsFilter ? {
						filter: pageFilter.optionsFilter,
						value: options,
					} : null,
				].filter(Boolean),
			);
		}

				return pageFilter.sourceFilter.toDisplay(filterValues, source)
			&& (!pageFilter.optionsFilter || pageFilter.optionsFilter.toDisplay(filterValues, options));
	}

	static getFilteredEntries_bySource (entries, pageFilter, filterValues) {
		const isDisplayableEntry = ({entry, filterValues, pageFilter}) => {
						if (!entry.source) return true;

			return this.isClassEntryFilterMatch(entry, pageFilter, filterValues);
		};

		return this._getFilteredEntries(
			{
				entries,
				pageFilter,
				filterValues,
				fnIsDisplayableEntry: isDisplayableEntry,
			},
		);
	}

	static _getFilteredEntries (
		{
			entries,
			pageFilter,
			filterValues,
			fnIsDisplayableEntry,
		},
	) {
		const recursiveFilter = (entry) => {
			if (entry == null) return entry;
			if (typeof entry !== "object") return entry;

			if (entry instanceof Array) {
				entry = entry.filter(it => fnIsDisplayableEntry({
					entry: it,
					pageFilter,
					filterValues,
				}));

				return entry.map(it => recursiveFilter(it));
			}

			Object.keys(entry).forEach(k => {
				if (entry[k] instanceof Array) {
					entry[k] = recursiveFilter(entry[k]);
					if (!entry[k].length) delete entry[k];
				} else entry[k] = recursiveFilter(entry[k]);
			});
			return entry;
		};

		entries = MiscUtil.copy(entries);
		return recursiveFilter(entries);
	}

		static async pGetPreparableSpells (spells, cls, spellLevelLow, spellLevelHigh) {
		Renderer.spell.populatePrereleaseLookup(await PrereleaseUtil.pGetBrewProcessed(), {isForce: true});
		Renderer.spell.populateBrewLookup(await BrewUtil2.pGetBrewProcessed(), {isForce: true});

		return spells.filter(it => {
			if (!(it.level > 0 				&& it.level >= spellLevelLow && it.level <= spellLevelHigh)) return false;

			Renderer.spell.uninitBrewSources(it);
			Renderer.spell.initBrewSources(it);

			const fromClassList = Renderer.spell.getCombinedClasses(it, "fromClassList");
			return fromClassList.some(c => (c.name || "").toLowerCase() === cls.name.toLowerCase() && (c.source || Parser.SRC_PHB).toLowerCase() === cls.source.toLowerCase());
		});
	}
	
	static getCasterProgression (cls, sc, {targetLevel, otherExistingClassItems = null, otherExistingSubclassItems = null}) {
		otherExistingClassItems = otherExistingClassItems || [];
		otherExistingSubclassItems = otherExistingSubclassItems || [];

		const isSpellcastingMulticlass = [
			...otherExistingClassItems.filter(it => it.system?.spellcasting && it.system?.spellcasting !== "none"),
			...otherExistingSubclassItems.filter(it => it.system?.spellcasting && it.system?.spellcasting !== "none"),
			cls.casterProgression != null || sc?.casterProgression != null,
		]
			.filter(Boolean)
			.length > 1;

		let {
			totalSpellcastingLevels,
			casterClassCount,
			maxPactCasterLevel,
		} = UtilActors.getActorSpellcastingInfo({
			sheetItems: [...otherExistingClassItems, ...otherExistingSubclassItems],
			isForceSpellcastingMulticlass: isSpellcastingMulticlass,
		});

		maxPactCasterLevel = Math.max(maxPactCasterLevel, targetLevel);

				const casterProgression = sc?.casterProgression || cls.casterProgression;
		const spellAbility = sc?.spellcastingAbility || cls.spellcastingAbility;

		if (casterProgression) {
									const fnRound = casterClassCount ? Math.floor : Math.ceil;
			switch (casterProgression) {
				case "full": totalSpellcastingLevels += targetLevel; break;
				case "1/2": totalSpellcastingLevels += fnRound(targetLevel / 2); break;
				case "1/3": totalSpellcastingLevels += fnRound(targetLevel / 3); break;
							}
		}

		return {
			casterProgression,
			spellAbility,
			totalSpellcastingLevels,
			maxPactCasterLevel,
		};
	}

	static getMysticProgression ({cls = null, targetLevel = 0, otherExistingClassItems = null, otherExistingSubclassItems = null}) {
		otherExistingClassItems = otherExistingClassItems || [];
		otherExistingSubclassItems = otherExistingSubclassItems || []; 
		let totalMysticLevels = 0;

		if (cls?.name === "Mystic" && cls?.source === Parser.SRC_UATMC) totalMysticLevels += targetLevel;

		if (otherExistingClassItems) {
			totalMysticLevels += otherExistingClassItems
				.filter(it => it.name.toLowerCase().trim() === "mystic")
				.map(it => it.system.levels)
				.sum();
		}

		return {
			totalMysticLevels,
		};
	}

		static addFauxOptionalFeatureFeatures (classList, optfeatList) {
		for (const cls of classList) {
			if (cls.classFeatures && cls.optionalfeatureProgression?.length) {
				for (const optFeatProgression of cls.optionalfeatureProgression) {
					this._addFauxOptionalFeatureFeatures_handleClassProgression(
						optfeatList,
						cls,
						null,
						optFeatProgression,
					);
				}
			}

			for (const sc of cls.subclasses) {
				if (sc.subclassFeatures && sc.optionalfeatureProgression?.length) {
					for (const optFeatProgression of sc.optionalfeatureProgression) {
						this._addFauxOptionalFeatureFeatures_handleClassProgression(
							optfeatList,
							cls,
							sc,
							optFeatProgression,
						);
					}
				}
			}
		}
	}

	static _addFauxOptionalFeatureFeatures_handleClassProgression (optfeatList, cls, sc, optFeatProgression) {
		const fauxLoadeds = this._addFauxOptionalFeatureFeatures_getLoadeds(optfeatList, cls, optFeatProgression);

				let progression = optFeatProgression.progression;
		if (!(progression instanceof Array)) {
						if (progression["*"]) {
				progression = MiscUtil.copy(progression);
				progression[1] = progression["*"];
			}
			
			const populated = new Set(Object.keys(progression).map(it => Number(it)).sort(SortUtil.ascSort));
			const nxt = [];
			const lvlMax = Math.max(...populated, Consts.CHAR_MAX_LEVEL);
			for (let i = 0; i < lvlMax; ++i) {
				nxt[i] = populated.has(i + 1) ? progression[i + 1] : nxt.length ? nxt.last() : 0;
			}
			progression = nxt;
		}

		let required = optFeatProgression.required;
		if (required && !(required instanceof Array)) {
			const populated = new Set(Object.keys(required).map(it => Number(it)).sort(SortUtil.ascSort));
			const nxt = [];
			const lvlMax = Math.max(...populated, Consts.CHAR_MAX_LEVEL);
			for (let i = 0; i < lvlMax; ++i) {
				nxt[i] = populated.has(i + 1) ? required[i + 1] : [];
			}
			required = nxt;
		}
		
		const propFeatures = sc ? "subclassFeatures" : "classFeatures";
		const propFeature = sc ? "subclassFeature" : "classFeature";
		const fnUnpackUidFeature = sc ? DataUtil.class.unpackUidSubclassFeature : DataUtil.class.unpackUidClassFeature;

		let cntPrev = 0;
		progression.forEach((cntOptFeats, ixLvl) => {
			if (cntOptFeats === cntPrev) return;
			const cntDelta = cntOptFeats - cntPrev;
			if (!~cntDelta) return; 
			const lvl = ixLvl + 1;
			const requiredUidsUnpacked = (required?.[ixLvl] || []).map(it => DataUtil.proxy.unpackUid("optionalfeature", it, "optfeature", {isLower: true}));

			const feature = this._addFauxOptionalFeatureFeatures_getFauxFeature(cls, sc, optFeatProgression, lvl, fauxLoadeds, cntDelta, requiredUidsUnpacked);

						const ixInsertBefore = (sc || cls)[propFeatures].findIndex(it => {
				return (it.level || fnUnpackUidFeature(it[propFeature] || it).level) > lvl;
			});
			if (~ixInsertBefore) (sc || cls)[propFeatures].splice(ixInsertBefore, 0, feature);
			else (sc || cls)[propFeatures].push(feature);

			cntPrev = cntOptFeats;
		});
	}

	static _addFauxOptionalFeatureFeatures_getLoadeds (optfeatList, clsSc, optFeatProgression) {
		const availOptFeats = optfeatList.filter(it => optFeatProgression.featureType instanceof Array && (optFeatProgression.featureType || []).some(ft => it.featureType.includes(ft)));
		const optionsMeta = {setId: CryptUtil.uid(), name: optFeatProgression.name};
		return availOptFeats.map(it => {
			return {
				type: "optionalfeature",
				entry: `{@optfeature ${it.name}|${it.source}}`,
				entity: MiscUtil.copy(it),
				optionsMeta,
				page: UrlUtil.PG_OPT_FEATURES,
				source: it.source,
				hash: UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_OPT_FEATURES](it),
				isRequiredOption: false,
			};
		});
	}

	static _addFauxOptionalFeatureFeatures_getFauxFeature (cls, sc, optFeatProgression, lvl, fauxLoadeds, cntOptions, requiredUidsUnpacked) {
		const loadeds = MiscUtil.copy(fauxLoadeds)
			.filter(l => !ExcludeUtil.isExcluded(
				UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_OPT_FEATURES]({name: l.entity.name, source: l.entity.source}),
				"optionalfeature",
				l.entity.source,
				{isNoCount: true},
			));

		loadeds.forEach(l => {
			l.isRequiredOption = requiredUidsUnpacked.some(it => it.name === l.entity.name.toLowerCase() && it.source === l.entity.source.toLowerCase());
			l.optionsMeta.count = cntOptions;
			PageFilterClassesFoundry.populateEntityTempData({
				entity: l.entity,
				ancestorClassName: cls.name,
				ancestorSubclassName: sc?.name,
				level: lvl,
				ancestorType: "optionalfeature",
				displayName: `${optFeatProgression.name}: ${l.entity.name}`,
				foundrySystem: {
					requirements: cls.name ? `${cls.name}${sc ? ` (${sc.name})` : ""} ${lvl}` : null,
				},
			});
		});

		const out = {
			name: optFeatProgression.name,
			level: lvl,
			loadeds: loadeds,
		};

		if (sc) {
			Object.assign(
				out,
				{
					source: sc.source,
					subclassFeature: `${optFeatProgression.name}|${cls.name}|${cls.source}|${sc.shortName}|${sc.source}|${lvl}|${Parser.SRC_5ETOOLS_TMP}`,
					hash: UrlUtil.URL_TO_HASH_BUILDER["subclassFeature"]({
						name: optFeatProgression.name,
						subclassName: sc.name,
						subclassSource: sc.source,
						className: cls.name,
						classSource: cls.source,
						level: lvl,
						source: Parser.SRC_5ETOOLS_TMP,
					}),
				},
			);
		} else {
			Object.assign(
				out,
				{
					source: cls.source,
					classFeature: `${optFeatProgression.name}|${cls.name}|${cls.source}|${lvl}|${Parser.SRC_5ETOOLS_TMP}`,
					hash: UrlUtil.URL_TO_HASH_BUILDER["classFeature"]({
						name: optFeatProgression.name,
						className: cls.name,
						classSource: cls.source,
						level: lvl,
						source: Parser.SRC_5ETOOLS_TMP,
					}),
				},
			);
		}

		return out;
	}

	static getExistingClassItems (actor, cls) {
		if (!cls) return [];

		return actor.items.filter(actItem =>
			actItem.type === "class"
			&& (actItem.name || "").toLowerCase().trim() === cls.name.toLowerCase().trim()
			&& (
				!Config.get("import", "isStrictMatching")
				|| (UtilDataConverter.getItemSource(actItem).source || "").toLowerCase() === Parser.sourceJsonToAbv(cls.source).toLowerCase()
			),
		);
	}

	static getExistingSubclassItems (actor, cls, sc) {
		if (!cls || !sc) return [];

		return actor.items.filter(actItem =>
			actItem.type === "subclass"
			&& (actItem.name || "").toLowerCase().trim() === sc.name.toLowerCase().trim()
			&& (
				!Config.get("import", "isStrictMatching")
				|| (UtilDataConverter.getItemSource(actItem).source || "").toLowerCase() === Parser.sourceJsonToAbv(sc.source).toLowerCase()
			),
		);
	}

	static getClassFromExistingClassItem (existingClassItem, classes) {
		if (!existingClassItem || existingClassItem.type !== "class" || !classes?.length) return null;

				classes = [...classes].sort(this._sortByOfficialAndRecent.bind(this));

		return classes.find(cls =>
			cls.name.toLowerCase().trim() === existingClassItem.name.toLowerCase().trim()
			&& (
				!Config.get("import", "isStrictMatching")
				|| (UtilDataConverter.getItemSource(existingClassItem).source || "").toLowerCase() === Parser.sourceJsonToAbv(cls.source).toLowerCase()
			),
		);
	}

	static getSubclassFromExistingSubclassItem (existingSubclassItem, cls, subclasses) {
		if (!existingSubclassItem || existingSubclassItem.type !== "subclass" || !subclasses?.length) return null;

		subclasses = subclasses.filter(it => it.className === cls.name && it.classSource === cls.source);

				subclasses = [...subclasses].sort(this._sortByOfficialAndRecent.bind(this));

		return subclasses.find(sc =>
			sc.name.toLowerCase().trim() === existingSubclassItem.name.toLowerCase().trim()
			|| sc.shortName.toLowerCase().trim() === existingSubclassItem.name.toLowerCase().trim(),
		);
	}

	static _sortByOfficialAndRecent (a, b) {
		const isNonStandardSourceA = SourceUtil.isNonstandardSource(a.source);
		const isNonStandardSourceB = SourceUtil.isNonstandardSource(b.source);

		if (isNonStandardSourceA === isNonStandardSourceB) {
			return SortUtil.ascSortDateString(Parser.sourceJsonToDate(a.source), Parser.sourceJsonToDate(b.source))
				|| SortUtil.ascSortLower(a.name, b.name);
		}

		return isNonStandardSourceA ? 1 : -1;
	}

	static getClassSubclassFeatureReferences (obj) {
		const refsClassFeature = [];
		const refsSubclassFeature = [];

		MiscUtil.getWalker({isNoModification: true})
			.walk(
				obj,
				{
					object: (obj) => {
						if (obj.type === "refClassFeature") {
							refsClassFeature.push(MiscUtil.copy(obj));
							return;
						}

						if (obj.type === "refSubclassFeature") {
							refsSubclassFeature.push(MiscUtil.copy(obj));
						}
					},
				},
			);

		return {refsClassFeature, refsSubclassFeature};
	}

	static getClassSubclassItemTuples ({classItems, subclassItems}) {
		if (!classItems?.length) return [];

		subclassItems = subclassItems || [];

		return classItems.map(classItem => ({
			classItem,
			subclassItem: subclassItems.find(it => it.system.classIdentifier === classItem.system.identifier),
		}));
	}

	
	static getToolProficiencyData (profs) {
		if (!profs) return null;
		if (profs.toolProficiencies) return profs.toolProficiencies;
		if (!profs.tools) return null;

		const out = {};
		profs.tools
			.forEach(str => {
				const itemUid = UtilActors.getItemUIdFromToolProficiency(str);
				if (!itemUid) return;
				const mappedTool = UtilActors.getMappedTool(itemUid);
				if (!mappedTool) return;
				const unmappedTool = UtilActors.getUnmappedTool(mappedTool);
				if (!unmappedTool) return;
				out[unmappedTool] = true;
			});

		return [out];
	}
}

Charactermancer_Class_Util.ExistingFeatureChecker = class {
	constructor (actor) {
		this._actor = actor;

		this._existingSheetFeatures = {};
		this._existingImportFeatures = {};

		actor.items
			.filter(it => it.type === "feat")
			.forEach(it => {
				const cleanSource = (UtilDataConverter.getItemSource(it).source || "").trim().toLowerCase();
				Charactermancer_Class_Util.ExistingFeatureChecker._getNameAliases(it.name)
					.forEach(alias => this._existingSheetFeatures[alias] = cleanSource);

				const {page, source, hash} = it.flags?.[SharedConsts.MODULE_ID] || {};
				if (page && source && hash) this.addImportFeature(page, source, hash);
			});
	}

	static _getNameAliases (name) {
		const cleanName = name.trim().toLowerCase();
		const out = [
			cleanName,
		];

		const mTrailingParens = /^(.*?)\(.*\)$/.exec(cleanName);
		if (mTrailingParens) out.push(mTrailingParens[1].trim());

						if (cleanName.includes(": ")) {
			const cleanNamePostColon = cleanName.split(":").slice(1).join(":").trim();
			out.push(cleanNamePostColon);
			const mTrailingParensPostColon = /^(.*?)\(.*\)$/.exec(cleanNamePostColon);
			if (mTrailingParensPostColon) out.push(mTrailingParensPostColon[1].trim());
		}

		return out;
	}

	isExistingFeature (name, page, source, hash) {
		if (MiscUtil.get(this._existingImportFeatures, page, source, hash)) return true;

		const searchNameAliases = Charactermancer_Class_Util.ExistingFeatureChecker._getNameAliases(name);
		if (!searchNameAliases.some(it => this._existingSheetFeatures[it])) return false;

		if (!Config.get("import", "isStrictMatching")) return true;

		const searchSource = Parser.sourceJsonToAbv(source).trim().toLowerCase();
		return searchNameAliases.some(it => this._existingSheetFeatures[it] === searchSource);
	}

	addImportFeature (page, source, hash) {
		MiscUtil.set(this._existingImportFeatures, page, source, hash, true);
	}
};

class Charactermancer_Class_LevelSelect extends BaseComponent {
			static async pGetUserInput (opts) {
		return UtilApplications.pGetImportCompApplicationFormData({
			comp: new this(opts),
			isUnskippable: true,
			fnGetInvalidMeta: (formData) => {
				if (formData.data.length === 0) return {type: "error", message: `Please select some levels first!`};
			},
			isAutoResize: true,
			width: 640,
		});
	}
	
		constructor (opts) {
		super();

		this._isSubclass = !!opts.isSubclass;
		this._isRadio = !!opts.isRadio;
		this._isForceSelect = !!opts.isForceSelect;
		this._featureArr = this.constructor._getLevelGroupedFeatures(opts.features, this._isSubclass);
		this._maxPreviousLevel = opts.maxPreviousLevel || 0;

		this._list = null;
		this._listSelectClickHandler = null;

		this._fnsOnChange = [];
	}

	get modalTitle () { return `Select ${this._isSubclass ? "Subclass" : "Class"} Levels`; }

	onchange (fn) {
		this._fnsOnChange.push(fn);
	}

	_doRunFnsOnchange () {
		this._fnsOnChange.forEach(fn => fn());
	}

	setFeatures (features) {
		this._featureArr = this.constructor._getLevelGroupedFeatures(features, this._isSubclass);
		this._list.items.forEach(it => it.data.fnUpdateRowText());
	}

	render ($wrp) {
		const $cbAll = this._isRadio ? null : $(`<input type="checkbox" name="cb-select-all">`);
		const $wrpList = $(`<div class="veapp__list mb-1"></div>`);

		this._list = new List({
			$wrpList: $wrpList,
			fnSort: null,
			isUseJquery: true,
		});

		this._listSelectClickHandler = new ListSelectClickHandler({list: this._list});

		for (let ix = 0; ix < this._featureArr.length; ++ix) {
			const $cb = this._render_$getCbRow(ix);

			const $dispFeatures = $(`<span class="col-9-5"></span>`);
			const fnUpdateRowText = () => $dispFeatures.text(this.constructor._getRowText(this._featureArr[ix]));
			fnUpdateRowText();

			const $li = $$`<label class="w-100 ve-flex veapp__list-row veapp__list-row-hoverable ${this._isRadio && this._isForceSelect && ix <= this._maxPreviousLevel ? `list-multi-selected` : ""} ${ix < this._maxPreviousLevel ? `ve-muted` : ""}">
				<span class="col-1 ve-flex-vh-center">${$cb}</span>
				<span class="col-1-5 text-center">${ix + 1}</span>
				${$dispFeatures}
			</label>`
				.click((evt) => {
					this._handleSelectClick(listItem, evt);
				});

			const listItem = new ListItem(
				ix,
				$li,
				"",
				{},
				{
					cbSel: $cb[0],
					fnUpdateRowText,
				},
			);
			this._list.addItem(listItem);
		}

		if (!this._isRadio) this._listSelectClickHandler.bindSelectAllCheckbox($cbAll);

		this._list.init();

		$$`<div class="ve-flex-col min-h-0">
			<div class="ve-flex-v-stretch input-group mb-1 no-shrink">
				<label class="btn btn-5et col-1 px-1 ve-flex-vh-center">${$cbAll}</label>
				<button class="btn-5et col-1-5">Level</button>
				<button class="btn-5et col-9-5">Features</button>
			</div>

			${$wrpList}
		</div>`.appendTo($wrp);
	}

	_render_$getCbRow (ix) {
		if (!this._isRadio) return $(`<input type="checkbox" class="no-events">`);

		const $cb = $(`<input type="radio" class="no-events">`);
		if (ix === this._maxPreviousLevel && this._isForceSelect) $cb.prop("checked", true);
		else if (ix < this._maxPreviousLevel) $cb.prop("disabled", true);

		return $cb;
	}

	_handleSelectClick (listItem, evt) {
		if (!this._isRadio) return this._listSelectClickHandler.handleSelectClick(listItem, evt);

		const isCheckedOld = listItem.data.cbSel.checked;

		const isDisabled = this._handleSelectClickRadio(this._list, listItem, evt);
		if (isDisabled) return;

		const isCheckedNu = listItem.data.cbSel.checked;
		if (isCheckedOld !== isCheckedNu) this._doRunFnsOnchange();
	}

		_handleSelectClickRadio (list, item, evt) {
		evt.preventDefault();
		evt.stopPropagation();

		if (item.data.cbSel.disabled) return true;

		list.items.forEach(it => {
			if (it === item) {
								if (it.data.cbSel.checked && !this._isForceSelect) {
					it.data.cbSel.checked = false;
					it.ele.removeClass("list-multi-selected");
					return;
				}

				it.data.cbSel.checked = true;
				it.ele.addClass("list-multi-selected");
			} else {
				it.data.cbSel.checked = false;
				if (it.ix < item.ix) it.ele.addClass("list-multi-selected");
				else it.ele.removeClass("list-multi-selected");
			}
		});
	}

	pGetFormData () {
		let out = this._list.items
			.filter(it => it.data.cbSel.checked)
			.map(it => it.ix);

				if (this._isRadio && out.length) {
			const max = out[0] + 1;
			out = [];
			for (let i = this._maxPreviousLevel; i < max; ++i) out.push(i);
		}

		return {
			isFormComplete: !!out.length,
			data: out,
		};
	}

		getCurLevel () {
		if (this._maxPreviousLevel) return this._maxPreviousLevel;
		return 0;
	}

		getTargetLevel () {
		const ixs = this._list.items
			.filter(it => it.data.cbSel.checked)
			.map(it => it.ix);
		if (!ixs.length) return null;
		return Math.max(...ixs) + 1;
	}

	static _getRowText (lvl) { return lvl.map(f => f.tableDisplayName || f.name).join(", ") || "\u2014"; }

		static _getLevelGroupedFeatures (allFeatures, isSubclass) {
		allFeatures = MiscUtil.copy(allFeatures);
		if (!isSubclass) allFeatures = allFeatures.filter(it => it.classFeature); 		const allFeaturesByLevel = [];

		let level = 1;
		let stack = [];
		const output = () => {
			allFeaturesByLevel.push(stack);
			stack = [];
		};
		allFeatures.forEach(f => {
						while (level < f.level) {
				output();
				level++;
			}
			stack.push(f);
			level = f.level;
		});
		output();

				while (level < Consts.CHAR_MAX_LEVEL) {
			output();
			level++;
		}

		return allFeaturesByLevel;
	}
}

class Charactermancer_Class_HpIncreaseModeSelect extends BaseComponent {
		static async pGetUserInput () {
		if (this.isNoChoice()) {
			const comp = new this();
			return comp.pGetFormData();
		}

		return UtilApplications.pGetImportCompApplicationFormData({
			comp: new this(),
			width: 480,
			height: 150,
		});
	}

	static isHpAvailable (cls) {
		return cls.hd && cls.hd.number && !isNaN(cls.hd.number) && cls.hd.faces && !isNaN(cls.hd.faces);
	}

	static isNoChoice () {
		if (game.user.isGM) return false;

		if (
			Config.get("importClass", "hpIncreaseMode") === ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL_CUSTOM
			&& Config.get("importClass", "hpIncreaseModeCustomRollFormula") == null
		) return false;

		return Config.get("importClass", "hpIncreaseMode") != null;
	}
	
	pGetFormData () {
		return {
			isFormComplete: true,
			data: {
				mode: this._state.mode,
				customFormula: this._state.customFormula,
			},
		};
	}

	get modalTitle () { return `Select Hit Points Increase Mode`; }

	render ($wrp) {
		const $sel = ComponentUiUtil.$getSelEnum(
			this,
			"mode",
			{
				values: [
					ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__TAKE_AVERAGE,
					ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__MIN,
					ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__MAX,
					ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL,
					ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL_CUSTOM,
					ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__DO_NOT_INCREASE,
				],
				fnDisplay: mode => ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE___NAMES[mode],
			},
		);

		if (!game.user.isGM && Config.get("importClass", "hpIncreaseMode") != null) $sel.disable();

		const $iptCustom = ComponentUiUtil.$getIptStr(this, "customFormula").addClass("code");

		if (!game.user.isGM && Config.get("importClass", "hpIncreaseModeCustomRollFormula") != null) $iptCustom.disable();

		const $stgCustom = $$`<div class="mt-2 ve-flex-v-center">
			<div class="inline-block bold mr-1 no-wrap">Custom Formula:</div>
			${$iptCustom}
		</div>`;
		const hkMode = () => {
			$stgCustom.toggleVe(this._state.mode === ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL_CUSTOM);
		};
		this._addHookBase("mode", hkMode);
		hkMode();

		$$`<div class="ve-flex-col min-h-0">
			${$sel}
			${$stgCustom}
		</div>`.appendTo($wrp);
	}

	_getDefaultState () {
		return {
			mode: Config.get("importClass", "hpIncreaseMode") ?? ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__TAKE_AVERAGE,
			customFormula: Config.get("importClass", "hpIncreaseModeCustomRollFormula") ?? "(2 * @hd.number)d(@hd.faces / 2)",
		};
	}
}

class Charactermancer_Class_HpInfo extends BaseComponent {
	constructor ({className, hitDice}) {
		super();
		this._className = className;
		this._hitDice = hitDice;
	}

	render ($wrp) {
		const hdEntry = Renderer.class.getHitDiceEntry(this._hitDice);

		$$`<div class="ve-flex-col min-h-0 ve-small">
			<div class="block"><div class="inline-block bold mr-1">Hit Dice:</div>${Vetools.withUnpatchedDiceRendering(() => Renderer.getEntryDice(hdEntry, "Hit die"))}</div>
			<div class="block"><div class="inline-block bold mr-1">Hit Points:</div>${Renderer.class.getHitPointsAtFirstLevel(this._hitDice)}</div>
			<div class="block"><div class="inline-block bold mr-1">Hit Points at Higher Levels:</div>${Vetools.withUnpatchedDiceRendering(() => Renderer.class.getHitPointsAtHigherLevels(this._className, this._hitDice, hdEntry))}</div>
		</div>`.appendTo($wrp);
	}
}

class Charactermancer_Class_ProficiencyImportModeSelect extends BaseComponent {
		static async pGetUserInput () {
		return UtilApplications.pGetImportCompApplicationFormData({
			comp: new this(),
			isUnskippable: true,
			isAutoResize: true,
		});
	}
	
	pGetFormData () {
		return {
			isFormComplete: true,
			data: this._state.mode,
		};
	}

	get modalTitle () { return `Select Class Proficiency Import Mode`; }

	render ($wrp) {
		const $sel = ComponentUiUtil.$getSelEnum(
			this,
			"mode",
			{
				values: [
					Charactermancer_Class_ProficiencyImportModeSelect.MODE_MULTICLASS,
					Charactermancer_Class_ProficiencyImportModeSelect.MODE_PRIMARY,
					Charactermancer_Class_ProficiencyImportModeSelect.MODE_NONE,
				],
				fnDisplay: mode => Charactermancer_Class_ProficiencyImportModeSelect.DISPLAY_MODES[mode],
			},
		);

		$$`<div class="ve-flex-col min-h-0">
			${$sel}
		</div>`.appendTo($wrp);
	}

	_getDefaultState () {
		return {
			mode: Charactermancer_Class_ProficiencyImportModeSelect.MODE_MULTICLASS,
		};
	}
}
Charactermancer_Class_ProficiencyImportModeSelect.MODE_MULTICLASS = 0;
Charactermancer_Class_ProficiencyImportModeSelect.MODE_PRIMARY = 1;
Charactermancer_Class_ProficiencyImportModeSelect.MODE_NONE = 2;

Charactermancer_Class_ProficiencyImportModeSelect.DISPLAY_MODES = {
	[Charactermancer_Class_ProficiencyImportModeSelect.MODE_MULTICLASS]: "Add multiclass proficiencies (this is my second+ class)",
	[Charactermancer_Class_ProficiencyImportModeSelect.MODE_PRIMARY]: "Add base class proficiencies and equipment (this is my first class)",
	[Charactermancer_Class_ProficiencyImportModeSelect.MODE_NONE]: "Do not add proficiencies or equipment",
};

class Charactermancer_Class_StartingProficiencies extends BaseComponent {
		static get (
		{
			featureSourceTracker,
			primaryProficiencies,
			multiclassProficiencies,
			savingThrowsProficiencies,
			mode,
			existingProficienciesFvttArmor,
			existingProficienciesFvttWeapons,
			existingProficienciesFvttSavingThrows,
		} = {},
	) {
		const {
			existingProficienciesVetArmor,
			existingProficienciesCustomArmor,

			existingProficienciesVetWeapons,
			existingProficienciesCustomWeapons,

			existingProficienciesVetSavingThrows,
		} = this._getExistingProficienciesVet({
			existingProficienciesFvttArmor,
			existingProficienciesFvttWeapons,
			existingProficienciesFvttSavingThrows,
		});

		const comp = new this({
			featureSourceTracker,
			primaryProficiencies,
			multiclassProficiencies,
			savingThrowsProficiencies,
			existingProficienciesVetArmor,
			existingProficienciesVetWeapons,
			existingProficienciesVetSavingThrows,

			existingProficienciesCustomArmor,
			existingProficienciesCustomWeapons,

						existingProficienciesFvttArmor,
			existingProficienciesFvttWeapons,
			existingProficienciesFvttSavingThrows,
		});

		if (mode != null) comp.mode = mode;

		return comp;
	}

	static async pGetUserInput (
		{
			featureSourceTracker,
			primaryProficiencies,
			multiclassProficiencies,
			savingThrowsProficiencies,
			mode,
			existingProficienciesFvttArmor,
			existingProficienciesFvttWeapons,
			existingProficienciesFvttSavingThrows,
		} = {},
	) {
		return this.get({
			featureSourceTracker,
			primaryProficiencies,
			multiclassProficiencies,
			savingThrowsProficiencies,
			mode,
			existingProficienciesFvttArmor,
			existingProficienciesFvttWeapons,
			existingProficienciesFvttSavingThrows,
		}).pGetFormData();
	}

		static applyFormDataToActorUpdate (actUpdate, formData) {
		MiscUtil.getOrSet(actUpdate, "system", "traits", {});

		this._applyFormDataToActorUpdate_applyProfList({
			actUpdate,
			profList: formData?.data?.armor || [],
			profsExisting: formData?.existingDataFvtt?.existingProficienciesArmor || {},
			propTrait: "armorProf",
			fnGetMapped: UtilActors.getMappedArmorProficiency.bind(UtilActors),
		});

		this._applyFormDataToActorUpdate_applyProfList({
			actUpdate,
			profList: formData.data?.weapons || [],
			profsExisting: formData?.existingDataFvtt?.existingProficienciesWeapons || {},
			propTrait: "weaponProf",
			fnGetMapped: UtilActors.getMappedWeaponProficiency.bind(UtilActors),
			fnGetPreMapped: UtilActors.getItemUIdFromWeaponProficiency.bind(UtilActors),
		});

		const tgtAbils = MiscUtil.getOrSet(actUpdate, "system", "abilities", {});
		[...(formData.data?.savingThrows || []), ...(formData.existingDataFvtt?.savingThrows || [])]
			.forEach(abv => (tgtAbils[abv] = tgtAbils[abv] || {}).proficient = 1);
	}

	static _applyFormDataToActorUpdate_addIfNotExists (arr, itm) {
		if (!arr.some(it => it.toLowerCase().trim() === itm.toLowerCase().trim())) arr.push(itm);
	}

	static _applyFormDataToActorUpdate_applyProfList (
		{
			actUpdate,
			profList,
			profsExisting,
			propTrait,
			fnGetMapped,
			fnGetPreMapped,
		},
	) {
		if (!profList?.length) return;

		const tgt = MiscUtil.getOrSet(actUpdate, "system", "traits", propTrait, {});
		tgt.value = tgt.value || [];
		tgt.custom = tgt.custom || "";

		const customArr = tgt.custom.split(";").map(it => it.trim()).filter(Boolean);

				(profsExisting.value || [])
			.forEach(it => this._applyFormDataToActorUpdate_addIfNotExists(tgt.value, it));

		(profsExisting.custom || "")
			.split(";")
			.map(it => it.trim())
			.filter(Boolean)
			.forEach(it => this._applyFormDataToActorUpdate_addIfNotExists(customArr, it));
		
		profList.forEach(it => {
						const clean = (fnGetPreMapped ? fnGetPreMapped(it) : null) ?? Renderer.stripTags(it).toLowerCase();
			const mapped = fnGetMapped(clean);
			if (mapped) return this._applyFormDataToActorUpdate_addIfNotExists(tgt.value, mapped);

						const [itemTag] = /{@item [^}]+}/i.exec(it) || [];
			if (itemTag) {
				const mappedAlt = fnGetMapped(Renderer.stripTags(itemTag));
				if (mappedAlt) return this._applyFormDataToActorUpdate_addIfNotExists(tgt.value, mappedAlt);
			}

						this._applyFormDataToActorUpdate_addIfNotExists(customArr, Renderer.stripTags(it));
		});

		tgt.custom = customArr.join("; ");
	}

	static getExistingProficienciesFvttSavingThrows (actor) {
						return Object.entries(MiscUtil.get(actor, "_source", "system", "abilities") || {})
			.filter(([, abMeta]) => abMeta.proficient)
			.map(([ab]) => ab);
	}
	
	static _getExistingProficienciesVet ({existingProficienciesFvttArmor, existingProficienciesFvttWeapons, existingProficienciesFvttSavingThrows}) {
		const vetValidWeapons = new Set();
		const customWeapons = new Set();
		const vetValidArmors = new Set();
		const customArmors = new Set();

		this._getExistingProficienciesVet_({
			existingFvtt: existingProficienciesFvttWeapons,
			fnGetUnmapped: UtilActors.getUnmappedWeaponProficiency.bind(UtilActors),
			fnCheckUnmappedAlt: UtilActors.getItemUIdFromWeaponProficiency.bind(UtilActors),
			vetValidSet: vetValidWeapons,
			customSet: customWeapons,
		});

		this._getExistingProficienciesVet_({
			existingFvtt: existingProficienciesFvttArmor,
			fnGetUnmapped: UtilActors.getUnmappedArmorProficiency.bind(UtilActors),
			vetValidSet: vetValidArmors,
			customSet: customArmors,
		});

		return {
			existingProficienciesVetWeapons: [...vetValidWeapons],
			existingProficienciesCustomWeapons: [...customWeapons],
			existingProficienciesVetArmor: [...vetValidArmors],
			existingProficienciesCustomArmor: [...customArmors],
			existingProficienciesVetSavingThrows: existingProficienciesFvttSavingThrows, 		};
	}

	static _getExistingProficienciesVet_ ({
		existingFvtt,
		vetValidSet,
		customSet,
		fnGetUnmapped,
		fnCheckUnmappedAlt,
	}) {
		(existingFvtt?.value || []).forEach(it => {
			const unmapped = fnGetUnmapped(it);
			if (unmapped) vetValidSet.add(unmapped);
			else {
				if (fnCheckUnmappedAlt) {
					const unmappedVet = fnCheckUnmappedAlt(it);
										if (unmappedVet) vetValidSet.add(it);
					else customSet.add(it);
				} else {
					customSet.add(it);
				}
			}
		});

		(existingFvtt?.custom || "").trim().split(";").map(it => it.trim()).filter(Boolean).forEach(it => {
			const low = it.toLowerCase();
			const unmapped = fnGetUnmapped(low);
			if (unmapped) vetValidSet.add(unmapped);
			else {
				if (fnCheckUnmappedAlt) {
					const unmappedVet = fnCheckUnmappedAlt(low);
										if (unmappedVet) vetValidSet.add(low);
					else customSet.add(it);
				} else {
					customSet.add(it);
				}
			}
		});
	}

		static _getCleanVetProfs (vetProfs) {
		if (!vetProfs) return {};

		const out = {};

		if (vetProfs.armor) out.armor = this._getCleanVetProfs_getMappedItemTags(vetProfs.armor.map(it => it.proficiency || it));
		if (vetProfs.weapons) out.weapons = this._getCleanVetProfs_getMappedItemTags(vetProfs.weapons.map(it => (it.proficiency || it).toLowerCase().trim()));

		return out;
	}

	static _getCleanVetProfs_getMappedItemTags (arr) {
		return arr.map(it => it.replace(/^{@item ([^}]+)}$/g, (...m) => {
			const [name, source] = Renderer.splitTagByPipe(m[1]);
			return `${name}|${source || Parser.SRC_DMG}`.toLowerCase();
		}));
	}

	constructor (
		{
			featureSourceTracker,
			primaryProficiencies,
			multiclassProficiencies,
			savingThrowsProficiencies,
			existingProficienciesVetArmor,
			existingProficienciesVetWeapons,
			existingProficienciesVetSavingThrows,
			existingProficienciesFvttArmor,
			existingProficienciesFvttWeapons,
			existingProficienciesFvttSavingThrows,
			existingProficienciesCustomArmor,
			existingProficienciesCustomWeapons,
		} = {},
	) {
		super();
		this._featureSourceTracker = featureSourceTracker;
		this._primaryProficiencies = Charactermancer_Class_StartingProficiencies._getCleanVetProfs(primaryProficiencies);
		this._multiclassProficiencies = Charactermancer_Class_StartingProficiencies._getCleanVetProfs(multiclassProficiencies);
		this._savingThrowsProficiencies = savingThrowsProficiencies;

		this._existingProficienciesVetArmor = existingProficienciesVetArmor;
		this._existingProficienciesVetWeapons = existingProficienciesVetWeapons;
		this._existingProficienciesVetSavingThrows = existingProficienciesVetSavingThrows;

		this._existingProficienciesCustomArmor = existingProficienciesCustomArmor;
		this._existingProficienciesCustomWeapons = existingProficienciesCustomWeapons;
						this._existingProficienciesFvttArmor = existingProficienciesFvttArmor ? MiscUtil.copy(existingProficienciesFvttArmor) : null;
		this._existingProficienciesFvttWeapons = existingProficienciesFvttWeapons ? MiscUtil.copy(existingProficienciesFvttWeapons) : null;
		this._existingProficienciesFvttSavingThrows = existingProficienciesFvttSavingThrows ? MiscUtil.copy(existingProficienciesFvttSavingThrows) : null;
			}

	set mode (mode) { this._state.mode = mode; }

	_getFormData () {
		const isPrimary = this._state.mode === Charactermancer_Class_ProficiencyImportModeSelect.MODE_PRIMARY;
		const profs = isPrimary ? this._primaryProficiencies : this._multiclassProficiencies;

		if (!profs) return {isFormComplete: true, data: {}, existingData: {}};

		return {
			isFormComplete: true,
			data: {
				armor: profs.armor || [],
				weapons: profs.weapons || [],
				savingThrows: isPrimary ? (this._savingThrowsProficiencies || []) : [],
			},
			existingDataFvtt: {
				existingProficienciesArmor: this._existingProficienciesFvttArmor,
				existingProficienciesWeapons: this._existingProficienciesFvttWeapons,
								existingProficienciesSavingThrows: this._existingProficienciesFvttSavingThrows,
			},
		};
	}

	pGetFormData () { return this._getFormData(); }

	render ($wrp) {
		const $wrpDisplay = $(`<div class="ve-flex-col min-h-0 ve-small"></div>`).appendTo($wrp);

		const fnsCleanup = [];

		const hkMode = () => {
			fnsCleanup.forEach(fn => fn());
			fnsCleanup.splice(0, fnsCleanup.length);

			$wrpDisplay.empty();
			const isPrimary = this._state.mode === Charactermancer_Class_ProficiencyImportModeSelect.MODE_PRIMARY;

			const profs = isPrimary ? this._primaryProficiencies : this._multiclassProficiencies;
			if (profs) {
				this._render_profType({
					profList: profs.armor,
					title: "Armor",
					$wrpDisplay,
					propTracker: "armorProficiencies",
					propTrackerPulse: "pulseArmorProficiencies",
					fnsCleanup,
					existing: this._existingProficienciesVetArmor,
					existingProficienciesCustom: this._existingProficienciesCustomArmor,
					fnDisplay: str => ["light", "medium", "heavy"].includes(str) ? `${str} armor` : str.includes("|") ? `{@item ${str}}` : str,
				});

				this._render_profType({
					profList: profs.weapons,
					title: "Weapons",
					$wrpDisplay,
					propTracker: "weaponProficiencies",
					propTrackerPulse: "pulseWeaponProficiencies",
					fnsCleanup,
					existing: this._existingProficienciesVetWeapons,
					existingProficienciesCustom: this._existingProficienciesCustomWeapons,
					fnDisplay: str => ["simple", "martial"].includes(str) ? `${str} weapons` : str.includes("|") ? `{@item ${str}}` : str,
				});
			}

			if (isPrimary && this._savingThrowsProficiencies) {
				this._render_profType({
					profList: this._savingThrowsProficiencies,
					title: "Saving Throws",
					$wrpDisplay,
					propTracker: "savingThrowProficiencies",
					propTrackerPulse: "pulseSavingThrowProficiencies",
					fnsCleanup,
					existing: this._existingProficienciesVetSavingThrows,
					fnDisplay: str => Parser.attAbvToFull(str),
				});
			}

						if (this._featureSourceTracker) this._featureSourceTracker.setState(this, this._getStateTrackerData());
					};
		this._addHookBase("mode", hkMode);
		hkMode();
	}

	_getStateTrackerData () {
		const formData = this._getFormData();

		const getNoTags = (arr) => arr.map(it => this.constructor._getUid(it)).filter(Boolean);

		return {
			armorProficiencies: getNoTags(formData.data?.armor || []).mergeMap(it => ({[it]: true})),
			weaponProficiencies: getNoTags(formData.data?.weapons || []).mergeMap(it => ({[it]: true})),
		};
	}

	static _getUid (str) {
		if (!str.startsWith("{@item")) return str;

		let [name, source] = Renderer.splitTagByPipe((Renderer.splitFirstSpace(str.slice(1, -1))[1] || "").toLowerCase());
		source = source || Parser.SRC_DMG.toLowerCase();
		if (!name) return null;

		return `${name}|${source}`;
	}

	_render_profType ({profList, title, $wrpDisplay, propTracker, propTrackerPulse, fnsCleanup, existing, existingProficienciesCustom, fnDisplay}) {
		if (!profList?.length) return;

		const profListUids = profList.map(prof => this.constructor._getUid(prof));

		const $ptsExisting = {};

		const $wrps = profList.map((it, i) => {
			const $ptExisting = $(`<div class="ve-small veapp__msg-warning inline-block"></div>`);
			const uid = profListUids[i];
			$ptsExisting[uid] = $ptExisting;
			const isNotLast = i < profList.length - 1;
			return $$`<div class="inline-block ${isNotLast ? "mr-1" : ""}">${Renderer.get().render(fnDisplay ? fnDisplay(it) : it)}${$ptExisting}${isNotLast ? `,` : ""}</div>`;
		});

		$$`<div class="block">
			<div class="mr-1 bold inline-block">${title}:</div>${$wrps}
		</div>`.appendTo($wrpDisplay);

		const pHkUpdatePtsExisting = async () => {
			try {
				await this._pLock("updateExisting");
				await pHkUpdatePtsExisting_();
			} finally {
				this._unlock("updateExisting");
			}
		};

		const pHkUpdatePtsExisting_ = async () => {
			const otherStates = this._featureSourceTracker ? this._featureSourceTracker.getStatesForKey(propTracker, {ignore: this}) : null;

			for (const v of profListUids) {
				if (!$ptsExisting[v]) return;

				const parentGroup = await UtilDataConverter.pGetItemWeaponType(v);

								let isExisting = (existing || []).includes(v)
					|| (parentGroup && (existing || []).includes(parentGroup))
					|| (existingProficienciesCustom || []).includes(v)
					|| (parentGroup && (existingProficienciesCustom || []).includes(parentGroup));

								isExisting = isExisting
					|| (otherStates || []).some(otherState => !!otherState[v] || (parentGroup && !!otherState[parentGroup]));

				$ptsExisting[v]
					.title(isExisting ? "Proficient from Another Source" : "")
					.toggleClass("ml-1", isExisting)
					.html(isExisting ? `(<i class="fas fa-fw ${UtilActors.PROF_TO_ICON_CLASS[1]}"></i>)` : "");
			}
		};
		if (this._featureSourceTracker) {
			this._featureSourceTracker.addHook(this, propTrackerPulse, pHkUpdatePtsExisting);
			fnsCleanup.push(() => this._featureSourceTracker.removeHook(this, propTrackerPulse, pHkUpdatePtsExisting));
		}
		pHkUpdatePtsExisting();
	}

	_getDefaultState () {
		return {
			mode: Charactermancer_Class_ProficiencyImportModeSelect.MODE_PRIMARY,
		};
	}
}

var UtilCharactermancerClass = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Charactermancer_Class_HpIncreaseModeSelect: Charactermancer_Class_HpIncreaseModeSelect,
    Charactermancer_Class_HpInfo: Charactermancer_Class_HpInfo,
    Charactermancer_Class_LevelSelect: Charactermancer_Class_LevelSelect,
    Charactermancer_Class_ProficiencyImportModeSelect: Charactermancer_Class_ProficiencyImportModeSelect,
    Charactermancer_Class_StartingProficiencies: Charactermancer_Class_StartingProficiencies,
    Charactermancer_Class_Util: Charactermancer_Class_Util,
    PageFilterClassesFoundry: PageFilterClassesFoundry
});

function __variableDynamicImportRuntime2__(path) {
  switch (path) {
    case './DataConverter.js': return Promise.resolve().then(function () { return DataConverter$1; });
    case './DataConverterAction.js': return Promise.resolve().then(function () { return DataConverterAction$1; });
    case './DataConverterActor.js': return Promise.resolve().then(function () { return DataConverterActor$1; });
    case './DataConverterAdventure.js': return Promise.resolve().then(function () { return DataConverterAdventure$1; });
    case './DataConverterAdventureBook.js': return Promise.resolve().then(function () { return DataConverterAdventureBook$1; });
    case './DataConverterBackground.js': return Promise.resolve().then(function () { return DataConverterBackground$1; });
    case './DataConverterBackgroundFeature.js': return Promise.resolve().then(function () { return DataConverterBackgroundFeature$1; });
    case './DataConverterBook.js': return Promise.resolve().then(function () { return DataConverterBook$1; });
    case './DataConverterCharCreationOption.js': return Promise.resolve().then(function () { return DataConverterCharCreationOption$1; });
    case './DataConverterClass.js': return Promise.resolve().then(function () { return DataConverterClass$1; });
    case './DataConverterClassSubclassFeature.js': return Promise.resolve().then(function () { return DataConverterClassSubclassFeature$1; });
    case './DataConverterConditionDisease.js': return Promise.resolve().then(function () { return DataConverterConditionDisease$1; });
    case './DataConverterCreature.js': return Promise.resolve().then(function () { return DataConverterCreature$1; });
    case './DataConverterCreatureFeature.js': return Promise.resolve().then(function () { return DataConverterCreatureFeature$1; });
    case './DataConverterCultBoon.js': return Promise.resolve().then(function () { return DataConverterCultBoon$1; });
    case './DataConverterDeck.js': return Promise.resolve().then(function () { return DataConverterDeck$1; });
    case './DataConverterDeity.js': return Promise.resolve().then(function () { return DataConverterDeity$1; });
    case './DataConverterFeat.js': return Promise.resolve().then(function () { return DataConverterFeat$1; });
    case './DataConverterFeature.js': return Promise.resolve().then(function () { return DataConverterFeature$1; });
    case './DataConverterHazard.js': return Promise.resolve().then(function () { return DataConverterHazard$1; });
    case './DataConverterItem.js': return Promise.resolve().then(function () { return DataConverterItem$1; });
    case './DataConverterJournal.js': return Promise.resolve().then(function () { return DataConverterJournal$1; });
    case './DataConverterLanguage.js': return Promise.resolve().then(function () { return DataConverterLanguage$1; });
    case './DataConverterObject.js': return Promise.resolve().then(function () { return DataConverterObject$1; });
    case './DataConverterOptionalfeature.js': return Promise.resolve().then(function () { return DataConverterOptionalfeature$1; });
    case './DataConverterPsionic.js': return Promise.resolve().then(function () { return DataConverterPsionic$1; });
    case './DataConverterRace.js': return Promise.resolve().then(function () { return DataConverterRace$1; });
    case './DataConverterRaceFeature.js': return Promise.resolve().then(function () { return DataConverterRaceFeature$1; });
    case './DataConverterRecipe.js': return Promise.resolve().then(function () { return DataConverterRecipe$1; });
    case './DataConverterReward.js': return Promise.resolve().then(function () { return DataConverterReward$1; });
    case './DataConverterSpell.js': return Promise.resolve().then(function () { return DataConverterSpell$1; });
    case './DataConverterTable.js': return Promise.resolve().then(function () { return DataConverterTable$1; });
    case './DataConverterTrap.js': return Promise.resolve().then(function () { return DataConverterTrap$1; });
    case './DataConverterVariantRule.js': return Promise.resolve().then(function () { return DataConverterVariantRule$1; });
    case './DataConverterVehicle.js': return Promise.resolve().then(function () { return DataConverterVehicle$1; });
    case './DataConverterVehicleUpgrade.js': return Promise.resolve().then(function () { return DataConverterVehicleUpgrade$1; });
    default: return new Promise(function(resolve, reject) {
      (typeof queueMicrotask === 'function' ? queueMicrotask : setTimeout)(
        reject.bind(null, new Error("Unknown variable dynamic import: " + path))
      );
    })
   }
 }

class Charactermancer_Util {
	static getCurrentLevel (actor) {
		return actor.items.filter(it => it.type === "class").map(it => Number(it.system.levels || 0)).sum();
	}

	static getBaseAbilityScores (actor) { return this._getAbilityScores(actor, true); }

	static getCurrentAbilityScores (actor) { return this._getAbilityScores(actor, false); }

	static _getAbilityScores (actor, isBase) {
		const actorData = isBase ? (actor.system._source || actor.system) : actor.system;
		const out = {
			str: Number(MiscUtil.get(actorData, "abilities", "str", "value") || 0),
			dex: Number(MiscUtil.get(actorData, "abilities", "dex", "value") || 0),
			con: Number(MiscUtil.get(actorData, "abilities", "con", "value") || 0),
			int: Number(MiscUtil.get(actorData, "abilities", "int", "value") || 0),
			wis: Number(MiscUtil.get(actorData, "abilities", "wis", "value") || 0),
			cha: Number(MiscUtil.get(actorData, "abilities", "cha", "value") || 0),
		};
		Object.entries(out)
			.forEach(([abv, val]) => {
				if (isNaN(val)) out[abv] = 0;
			});
		return out;
	}

	static getBaseHp (actor) {
		return this._getHp(actor, true);
	}

	static _getHp (actor, isBase) {
		const actorData = isBase ? (actor.system._source || actor.system) : actor.system;
		return {
			value: (actorData?.attributes?.hp?.value || 0),
						max: actorData?.attributes?.hp?.max,
		};
	}

	static getAttackAbilityScore (itemAttack, abilityScores, mode) {
		if (!itemAttack || !abilityScores) return null;
		switch (mode) {
			case "melee": {
				const isFinesse = !!MiscUtil.get(itemAttack, "system", "properties", "fin");
				if (!isFinesse) return abilityScores.str;
				return abilityScores.str > abilityScores.dex ? abilityScores.str : abilityScores.dex;
			}
			case "ranged": {
				const isThrown = !!MiscUtil.get(itemAttack, "system", "properties", "thr");
				if (!isThrown) return abilityScores.dex;
				return abilityScores.str > abilityScores.dex ? abilityScores.str : abilityScores.dex;
			}
			default: throw new Error(`Unhandled mode "${mode}"`);
		}
	}

		static getFilteredFeatures (allFeatures, pageFilter, filterValues) {
		return allFeatures.filter(f => {
			const source = f.source
				|| (f.classFeature
					? DataUtil.class.unpackUidClassFeature(f.classFeature).source : f.subclassFeature ? DataUtil.class.unpackUidSubclassFeature(f.subclassFeature) : null);

						if (!pageFilter.sourceFilter.toDisplay(filterValues, source)) return false;

									f.loadeds = f.loadeds.filter(meta => {
				return Charactermancer_Class_Util.isClassEntryFilterMatch(meta.entity, pageFilter, filterValues);
			});

			return f.loadeds.length;
		});
	}

	static getImportableFeatures (allFeatures) {
				return allFeatures.filter(f => {
						if (f.gainSubclassFeature && !f.gainSubclassFeatureHasContent) return false;

			const lowName = f.name.toLowerCase();
			switch (lowName) {
				case "proficiency versatility": return false;
				default: return true;
			}
		});
	}

	static doApplyFilterToFeatureEntries_bySource (allFeatures, pageFilter, filterValues) {
				allFeatures.forEach(f => {
			f.loadeds.forEach(loaded => {
				switch (loaded.type) {
					case "classFeature":
					case "subclassFeature": {
						if (loaded.entity.entries) loaded.entity.entries = Charactermancer_Class_Util.getFilteredEntries_bySource(loaded.entity.entries, pageFilter, filterValues);
						break;
					}
				}
			});
		});

		return allFeatures;
	}

	static getFeaturesGroupedByOptionsSet (allFeatures) {
		return allFeatures.map(topLevelFeature => {
						const optionsSets = [];

			let optionsStack = [];
			let lastOptionsSetId = null;
			topLevelFeature.loadeds.forEach(l => {
				const optionsSetId = MiscUtil.get(l, "optionsMeta", "setId") || null;
				if (lastOptionsSetId !== optionsSetId) {
					if (optionsStack.length) optionsSets.push(optionsStack);
					optionsStack = [l];
					lastOptionsSetId = optionsSetId;
				} else {
					optionsStack.push(l);
				}
			});
			if (optionsStack.length) optionsSets.push(optionsStack);

			return {topLevelFeature, optionsSets};
		});
	}
	
		static getFilterSearchMeta ({comp, prop, propVersion = null, data, modalFilter, title}) {
		const {$wrp: $sel, fnUpdateHidden: fnUpdateSelHidden, unhook} = ComponentUiUtil.$getSelSearchable(
			comp,
			prop,
			{
				values: data.map((_, i) => i),
				isAllowNull: true,
				fnDisplay: ix => {
					const it = data[ix];

					if (!it) { 						console.warn(...LGT, `Could not find ${prop} with index ${ix} (${data.length} ${prop} entries were available)`);
						return "(Unknown)";
					}

					return `${it.name} ${it.source !== Parser.SRC_PHB ? `[${Parser.sourceJsonToAbv(it.source)}]` : ""}`;
				},
				fnGetAdditionalStyleClasses: ix => {
					if (ix == null) return null;
					const it = data[ix];
					if (!it) return; 					return it._versionBase_isVersion ? ["italic"] : null;
				},
				asMeta: true,
			},
		);

		const doApplyFilterToSel = () => {
			const f = modalFilter.pageFilter.filterBox.getValues();
			const isHiddenPer = data.map(it => !modalFilter.pageFilter.toDisplay(f, it));
			fnUpdateSelHidden(isHiddenPer, false);
		};

		modalFilter.pageFilter.filterBox.on(
			FilterBox.EVNT_VALCHANGE,
			doApplyFilterToSel,
		);
		doApplyFilterToSel();

		const $btnFilter = $(`<button class="btn btn-xs btn-5et br-0 pr-2" title="Filter for a ${title}"><span class="glyphicon glyphicon-filter"></span> Filter</button>`)
			.click(async () => {
				const selecteds = await modalFilter.pGetUserSelection();
				if (selecteds == null || !selecteds.length) return;

				const selected = selecteds[0];
				const ix = data.findIndex(it => it.name === selected.name && it.source === selected.values.sourceJson);
				if (!~ix) throw new Error(`Could not find selected entity: ${JSON.stringify(selected)}`); 				comp._state[prop] = ix;
			});

		const {$stg: $stgSelVersion = null, unhook: unhookVersion = null} = this._getFilterSearchMeta_getVersionMeta({comp, prop, propVersion, data}) || {};

		return {
			$sel,
			$btnFilter,
			$stgSelVersion,
			unhook: () => {
				unhook();
				modalFilter.pageFilter.filterBox.off(FilterBox.EVNT_VALCHANGE, doApplyFilterToSel);
				if (unhookVersion) unhookVersion();
			},
		};
	}

	static _getFilterSearchMeta_getVersionMeta ({comp, prop, propVersion, data}) {
		if (!propVersion) return;

		const {$sel, setValues, unhook} = ComponentUiUtil.$getSelEnum(
			comp,
			propVersion,
			{
				values: [],
				isAllowNull: true,
				displayNullAs: "(Base version)",
				fnDisplay: it => `${it.name}${it.source !== data[comp._state[prop]]?.source ? ` (${Parser.sourceJsonToAbv(it.source)})` : ""}`,
				asMeta: true,
				isSetIndexes: true,
			},
		);

		const hkProp = () => {
			const ent = data[comp._state[prop]];
			if (ent == null) {
				setValues([]);
				return $stg.hideVe();
			}

			const versions = DataUtil.generic.getVersions(ent);
			setValues(versions);
			$stg.toggleVe(versions.length);
		};
		comp._addHookBase(prop, hkProp);

		const $stg = $$`<div class="ve-flex-col mt-2">
			<label class="split-v-center btn-group w-100">
				<div class="mr-2">Version:</div>
				${$sel}
			</label>
		</div>`;

		hkProp();

		return {
			$stg,
			unhook: () => {
				unhook();
				comp._removeHookBase(prop, hkProp);
			},
		};
	}
	}
Charactermancer_Util.STR_WARN_SOURCE_SELECTION = `Did you change your source selection since using the Charactermancer initially?`;

class Charactermancer_FeatureSourceTracker extends BaseComponent {
	constructor () {
		super();
		this._registered = new Map();
	}

	register (comp) {
		this._registered.set(comp, {state: null, hookMetas: []});
	}

	_validateProp (propPulse) {
		if (!Charactermancer_FeatureSourceTracker._VALID_HOOK_PROPS.has(propPulse)) throw new Error(`Unhandled pulse prop "${propPulse}"`);
	}

	addHook (comp, propPulse, hk) {
		this._validateProp(propPulse);

		if (!this._registered.has(comp)) this.register(comp);

		this._registered.get(comp).hookMetas.push({propPulse, hook: hk});
		this._addHookBase(propPulse, hk);
	}

	removeHook (comp, propPulse, hk) {
		this._validateProp(propPulse);

		if (!this._registered.has(comp)) return;

		const compMeta = this._registered.get(comp);
		const ixHook = compMeta.hookMetas.findIndex(it => it.hook === hk);
		if (~ixHook) compMeta.hookMetas.splice(ixHook, 1);
		this._removeHookBase(propPulse, hk);
	}

		setState (comp, state) {
		if (!this._registered.has(comp)) this.register(comp);

		const compMeta = this._registered.get(comp);

		const prevState = compMeta.state ? MiscUtil.copy(compMeta.state) : compMeta.state;
		compMeta.state = state;

		const allKeys = new Set([
			...Object.keys(prevState || {}),
			...Object.keys(state || {}),
		]);

				allKeys
			.forEach(k => {
				const oldVal = prevState?.[k];
				const nuVal = state?.[k];

				if (CollectionUtil.deepEquals(oldVal, nuVal)) return;

				this._doPulseForProp(k);
			});
	}

		getStatesForKey (key, {ignore = null} = {}) {
		const out = [];
		for (const [comp, compMeta] of this._registered.entries()) {
			if (ignore === comp) continue;
			if (compMeta?.state?.[key]) out.push(compMeta.state[key]);
		}
		return out;
	}

		unregister (comp) {
		if (!comp) return;

		const registered = this._registered.get(comp);
		if (!registered) return;

				this._registered.delete(comp);

				registered.hookMetas.forEach(({propPulse, hook}) => {
			this._removeHookBase(propPulse, hook);
		});

				if (registered.state) {
			Object.keys(registered.state)
				.forEach(k => { 					this._doPulseForProp(k);
				});
		}
	}

	_doPulseForProp (k) {
		switch (k) {
			case "skillProficiencies": return this._state.pulseSkillProficiencies = !this._state.pulseSkillProficiencies;
			case "languageProficiencies": return this._state.pulseLanguageProficiencies = !this._state.pulseLanguageProficiencies;
			case "toolProficiencies": return this._state.pulseToolProficiencies = !this._state.pulseToolProficiencies;
			case "armorProficiencies": return this._state.pulseArmorProficiencies = !this._state.pulseArmorProficiencies;
			case "weaponProficiencies": return this._state.pulseWeaponProficiencies = !this._state.pulseWeaponProficiencies;
			case "features": return this._state.pulseFeatures = !this._state.pulseFeatures;
			case "savingThrowProficiencies": return this._state.pulseSavingThrowProficiencies = !this._state.pulseSavingThrowProficiencies;
			case "immune": return this._state.pulseImmune = !this._state.pulseImmune;
			case "resist": return this._state.pulseResist = !this._state.pulseResist;
			case "vulnerable": return this._state.pulseVulnerable = !this._state.pulseVulnerable;
			case "conditionImmune": return this._state.pulseConditionImmune = !this._state.pulseConditionImmune;
			case "expertise": return this._state.pulseExpertise = !this._state.pulseExpertise;
			default: throw new Error(`Unhandled tracked state key ${k}`);
		}
	}

	_getDefaultState () {
		return [...Charactermancer_FeatureSourceTracker._VALID_HOOK_PROPS].mergeMap(it => ({[it]: false}));
	}
}
Charactermancer_FeatureSourceTracker._VALID_HOOK_PROPS = new Set([
	"pulseSkillProficiencies",
	"pulseLanguageProficiencies",
	"pulseToolProficiencies",
	"pulseArmorProficiencies",
	"pulseWeaponProficiencies",
	"pulseFeatures",
	"pulseSavingThrowProficiencies",
	"pulseImmune",
	"pulseResist",
	"pulseVulnerable",
	"pulseConditionImmune",
	"pulseExpertise",
]);

class Charactermancer_AbilityScoreSelect extends BaseComponent {
		static async pFillActorAbilityData (actor, ability, actUpdate, opts) {
		if (!ability || !ability.length) return;

		const formData = await this.pGetUserInput(ability);
		if (!formData) return opts.isCancelled = true;
		if (formData === VeCt.SYM_UI_SKIP) return;

		actUpdate.system = actUpdate.system || {};
		actUpdate.system.abilities = actUpdate.system.abilities || {};
		const abilityScores = Charactermancer_Util.getBaseAbilityScores(actor);
		Parser.ABIL_ABVS.filter(ab => formData.data[ab]).forEach(ab => actUpdate.system.abilities[ab] = {value: abilityScores[ab] + formData.data[ab]});

		return formData;
	}

	static async pGetUserInput (ability) {
		if (!ability || !ability.length) return {isFormComplete: true, data: {}};

		const comp = new Charactermancer_AbilityScoreSelect({ability});
		if (comp.isNoChoice()) {
			const isFill = await InputUiUtil.pGetUserBoolean({
				title: `Ability Scores?`,
				htmlDescription: `Do you wish to apply ability score modifications?`,
				textYes: "Yes",
				textNo: "No",
			});
			if (isFill == null) return null;
			if (!isFill) return {isFormComplete: true, data: {}};
			return comp.pGetFormData();
		}

		return UtilApplications.pGetImportCompApplicationFormData({comp, isAutoResize: true});
	}
	
		constructor (opts) {
		opts = opts || {};
		super();

		this._ability = opts.ability;

		this._lastMeta = null;
	}

	get modalTitle () { return "Ability Score Increase"; }

	render ($wrp) {
		let $stgSelGroup = null;
		if (this._ability.length > 1) {
			const $selIxSet = ComponentUiUtil.$getSelEnum(
				this,
				"ixSet",
				{
					values: this._ability.map((_, i) => i),
					fnDisplay: ix => Renderer.getAbilityData([this._ability[ix]]).asText,
				},
			);

			$stgSelGroup = $$`<div class="w-100 mb-2 ve-flex-vh-center">
				${$selIxSet}
			</div>`;
		}

		const $stgGroup = $$`<div class="ve-flex-col"></div>`;

		const hkIxSet = () => {
			$stgGroup.empty();

			if (this._lastMeta) this._lastMeta.cleanup();

			const abilitySet = this._ability[this._state.ixSet];

			const ptsNoChoose = Parser.ABIL_ABVS.filter(ab => abilitySet[ab]).map(ab => `${Parser.attAbvToFull(ab)} ${UiUtil.intToBonus(abilitySet[ab], {isPretty: true})}`);
			if (ptsNoChoose.length) $stgGroup.append(`<div>${ptsNoChoose.join(", ")}</div>${abilitySet.choose ? `<hr class="hr-2 hr--dotted">` : ""}`);

			if (abilitySet.choose) {
				if (abilitySet.choose.from) this._render_renderPtChooseFrom($stgGroup, abilitySet);
				else if (abilitySet.choose.weighted) this._render_renderPtChooseWeighted($stgGroup, abilitySet);
			}
		};
		this._addHookBase("ixSet", hkIxSet);
		hkIxSet();

		$$($wrp)`
			${$stgSelGroup}
			${$stgGroup}
		`;
	}

	_render_renderPtChooseFrom ($stgGroup, abilitySet) {
		const count = abilitySet.choose.count || 1;
		const amount = abilitySet.choose.amount || 1;

		this._lastMeta = ComponentUiUtil.getMetaWrpMultipleChoice(
			this,
			"race_asiChoice",
			{
				values: abilitySet.choose.from,
				fnDisplay: v => `${Parser.attAbvToFull(v)} ${UiUtil.intToBonus(amount, {isPretty: true})}`,
				count,
			},
		);

		$stgGroup.append(`<div class="mb-1">Choose ${Parser.numberToText(count)} ability score${count === 1 ? "" : "s"} to increase by ${amount}:</div>`);
		this._lastMeta.$ele.appendTo($stgGroup);
	}

	_getWeightedProps (ixAb, ixWeight) {
		return {
			propWeightAbility: `weight_ability_${ixAb}_${ixWeight}`,
		};
	}

	_render_renderPtChooseWeighted ($stgGroup, abilitySet) {
		const fnsCleanup = [];

		const from = this.constructor._getSortedWeightedFrom(abilitySet);
		const weights = this.constructor._getSortedWeights(abilitySet);

		const $wrpRows = $(`<div class="ve-flex-col"></div>`);

		from.forEach((ab, ixAb) => {
			const $wrpsCbs = weights
				.map((bon, ixBon) => {
					const {propWeightAbility} = this._getWeightedProps(ixAb, ixBon);

					const metaCb = ComponentUiUtil.$getCbBool(
						this,
						propWeightAbility,
						{asMeta: true},
					);
					fnsCleanup.push(metaCb.unhook);

					const hkResetOthers = () => {
						if (!this._state[propWeightAbility]) return;

						const nxtState = {};

												from.forEach((_, ixAbSub) => {
							const {propWeightAbility: propWeightAbilitySub} = this._getWeightedProps(ixAbSub, ixBon);
							if (propWeightAbilitySub === propWeightAbility) return;
							nxtState[propWeightAbilitySub] = false;
						});

												weights.forEach((_, ixBonSub) => {
							const {propWeightAbility: propWeightAbilitySub} = this._getWeightedProps(ixAb, ixBonSub);
							if (propWeightAbilitySub === propWeightAbility) return;
							nxtState[propWeightAbilitySub] = false;
						});

						this._proxyAssignSimple("state", nxtState);
					};
					this._addHookBase(propWeightAbility, hkResetOthers);
					fnsCleanup.push(() => this._removeHookBase(propWeightAbility, propWeightAbility));
					hkResetOthers();

					return $$`<label class="ve-flex-vh-center w-40p py-1">${metaCb.$cb}</label>`;
				});

			const $row = $$`<div class="ve-flex-v-center">
				<div class="w-100p text-right pr-2">${Parser.attAbvToFull(ab)}</div>
				${$wrpsCbs}
			</div>`.appendTo($wrpRows);
		});

		$$($stgGroup)`<div class="ve-flex-col">
			<div class="mb-1">${Renderer.getAbilityData([{choose: abilitySet.choose}]).asText}:</div>

			<div class="ve-flex-v-center py=1">
				<div class="w-100p"></div>
				${weights.map(it => `<div class="w-40p ve-flex-vh-center">${UiUtil.intToBonus(it, {isPretty: true})}</div>`).join("")}
			</div>

			${$wrpRows}
		</div>`;

		this._lastMeta = {
			cleanup: () => {
				fnsCleanup.forEach(it => it());
			},
		};
	}

	isNoChoice () { return this._ability.length === 1 && !this._ability[0].choose; }

	static _getSortedWeights (abilitySet) { return MiscUtil.copy(abilitySet.choose.weighted.weights).sort((a, b) => SortUtil.ascSort(b, a)); }
	static _getSortedWeightedFrom (abilitySet) { return MiscUtil.copy(abilitySet.choose.weighted.from).sort(SortUtil.ascSortAtts); }

	pGetFormData () {
		const out = {};

		const abilitySet = this._ability[this._state.ixSet];

				Parser.ABIL_ABVS.forEach(ab => { if (abilitySet[ab]) out[ab] = abilitySet[ab]; });

		if (abilitySet.choose) {
			if (abilitySet.choose.from) {
				const ixs = ComponentUiUtil.getMetaWrpMultipleChoice_getSelectedIxs(this, "race_asiChoice");
				ixs.map(it => abilitySet.choose.from[it]).forEach(ab => out[ab] = (out[ab] || 0) + (abilitySet.choose.amount || 1));
			} else if (abilitySet.choose.weighted) {
				const from = this.constructor._getSortedWeightedFrom(abilitySet);
				const weights = this.constructor._getSortedWeights(abilitySet);

				from.forEach((ab, ixAb) => {
					weights
						.map((bon, ixBon) => {
							const {propWeightAbility} = this._getWeightedProps(ixAb, ixBon);
							if (this._state[propWeightAbility]) out[ab] = (out[ab] || 0) + bon;
						});
				});
			}
		}

		return {
			isFormComplete: !!this._state[ComponentUiUtil.getMetaWrpMultipleChoice_getPropIsAcceptable("race_asiChoice")],
			data: out,
		};
	}

	_getDefaultState () {
		return {
			ixSet: 0,
		};
	}
}

class Charactermancer_ProficiencySelect extends BaseComponent {}

Charactermancer_ProficiencySelect.PropGroup = class {
	constructor ({prop, propTrackerPulse, propTracker}) {
		this.prop = prop;
		this.propTrackerPulse = propTrackerPulse;
		this.propTracker = propTracker;
	}
};

class Charactermancer_SkillSaveProficiencySelect extends Charactermancer_ProficiencySelect {
			static async pGetUserInput (opts) {
		opts = opts || {};

		if (!opts.available) return {isFormComplete: true, data: {}};

		const comp = new this({
			...opts,
			existing: this.getExisting(opts.existingFvtt),
			existingFvtt: opts.existingFvtt,
		});
		if (comp.isNoChoice()) return comp.pGetFormData();

		return UtilApplications.pGetImportCompApplicationFormData({comp, isAutoResize: true});
	}

		static getExisting (existingFvtt) { throw new Error(`Unimplemented!`); }

	static isNoChoice (available) {
		if (!available?.length) return true; 		return available.length === 1 && !available[0].choose;
	}
	
		constructor (opts) {
		opts = opts || {};
		super();

		this._propGroup = opts.propGroup;
		this._existing = opts.existing;
		this._existingFvtt = opts.existingFvtt;
		this._available = opts.available;
		this._titlePrefix = opts.titlePrefix;
		this._featureSourceTracker = opts.featureSourceTracker;
		this._modalTitle = opts.modalTitle;
		this._title = opts.title;
		this._titlePlural = opts.titlePlural;

		this._hkUpdateExisting = null;
		this._$stgGroup = null;
		this._lastMeta = null;
	}

	get modalTitle () { return this._modalTitle; }

		_getStaticDisplay (prof, {isPlainText = false} = {}) { throw new Error(`Unimplemented!`); }
		_getMultiChoiceDisplay ($ptsExisting, profOrObj) { throw new Error(`Unimplemented!`); }
		_getMultiChoiceTitle (cpyProfSet, count) { throw new Error(`Unimplemented!`); }

	_getNonStaticDisplay (key, value, {isPlainText = false} = {}) {
		switch (key) {
			case "choose": return this._getChooseFromDisplay(key, value, {isPlainText});
			default: throw new Error(`Unhandled non-static key "${key}" (value was ${JSON.stringify(value)})`);
		}
	}

	_getChooseFromDisplay (key, value, {isPlainText = false} = {}) {
		return `Choose ${value.count || 1} from ${value.from.map(it => this._getStaticDisplay(it, {isPlainText})).join(", ")}`;
	}

	render ($wrp) {
		const $stgSelGroup = this._render_$getStgSelGroup();
		this._$stgGroup = $$`<div class="ve-flex-col"></div>`;

		this._addHookBase("ixSet", this._hk_ixSet.bind(this));
		this._hk_ixSet();

		$$($wrp)`
			${$stgSelGroup}
			${this._$stgGroup}
		`;
	}

	_render_$getStgSelGroup () {
		if (this._available.length <= 1) return null;

		const $selIxSet = ComponentUiUtil.$getSelEnum(
			this,
			"ixSet",
			{
				values: this._available.map((_, i) => i),
				fnDisplay: ix => {
					const v = this._available[ix];

					const out = [];

					out.push(
						Object.keys(v)
							.sort(SortUtil.ascSortLower)
							.filter(it => this._isStaticKey(it))
							.map(k => this._getStaticDisplay(k, {isPlainText: true}))
							.join(", "),
					);

					Object.keys(v)
						.filter(it => !this._isStaticKey(it))
						.forEach(k => out.push(this._getNonStaticDisplay(k, v[k], {isPlainText: true})));

					return out.filter(Boolean).join("; ") || "(Nothing)";
				},
			},
		);

		if (this._featureSourceTracker) this._addHookBase("ixSet", () => this._doSetTrackerState());

		return $$`<div class="w-100 mb-2 ve-flex-vh-center">
			${$selIxSet}
		</div>`;
	}

	_doSetTrackerState () {
		this._featureSourceTracker.setState(this, {[this._propGroup.propTracker]: this._getFormData().data?.[this._propGroup.prop]});
	}

	static _getSortedProfSet (profSet) {
		if (!profSet) return profSet;

		profSet = MiscUtil.copy(profSet);

		if (profSet.choose?.from) {
			profSet.choose.from.sort((a, b) => {
				if (typeof a === "object" && typeof b === "object") return 0;
				if (typeof a === "object") return 1;
				if (typeof b === "object") return -1;
				return SortUtil.ascSortLower(a, b);
			});
		}

		return profSet;
	}

	_render_renderPtStatic ($stgGroup, profSet) {
		const $ptsExisting = {};

		const profList = this._getStaticKeys_profSet()
			.filter(key => profSet[key]);

		const $wrps = profList
			.map((it, i) => {
				const $ptExisting = $(`<div class="ve-small veapp__msg-warning inline-block"></div>`);
				($ptsExisting[it] = $ptsExisting[it] || []).push($ptExisting);
				const isNotLast = i < profList.length - 1;
				return $$`<div class="inline-block ${isNotLast ? "mr-1" : ""}">${this._getStaticDisplay(it)}${$ptExisting}${isNotLast ? `,` : ""}</div>`;
			});

		$$`<div class="block">
			${$wrps}
		</div>`.appendTo($stgGroup);

		return $ptsExisting;
	}

	_getStaticKeys_all () { throw new Error("Unimplemented!"); }

	_getStaticKeys_profSet () { throw new Error("Unimplemented!"); }

	_hk_ixSet () {
		this._$stgGroup.empty();

		if (this._featureSourceTracker && this._hkUpdateExisting) this._featureSourceTracker.removeHook(this, this._propGroup.propTrackerPulse, this._hkUpdateExisting);
		if (this._lastMeta) this._lastMeta.cleanup();

		const profSet = this._available[this._state.ixSet];

		if (this._featureSourceTracker) this._doSetTrackerState();

		this._hk_ixSet_renderPts(profSet);

		if (this._featureSourceTracker) this._featureSourceTracker.addHook(this, this._propGroup.propTrackerPulse, this._hkUpdateExisting);
		this._hkUpdateExisting();
	}

	_hk_ixSet_renderPts (profSet) {
		const $ptsExistingStatic = Object.keys(profSet).some(it => this._isStaticKey(it)) ? this._render_renderPtStatic(this._$stgGroup, profSet) : null;

		if ($ptsExistingStatic && profSet.choose) this._$stgGroup.append(`<hr class="hr-2 hr--dotted">`);
		const $ptsExistingChooseFrom = profSet.choose ? this._render_renderPtChooseFrom(this._$stgGroup, profSet) : null;

		this._hkUpdateExisting = () => this._hk_updatePtsExisting($ptsExistingStatic, $ptsExistingChooseFrom);
	}

	_isStaticKey (key) { return this._getStaticKeys_all().includes(key); }

	_hk_updatePtsExisting ($ptsExistingStatic, $ptsExistingChoose) {
		const otherStates = this._featureSourceTracker ? this._featureSourceTracker.getStatesForKey(this._propGroup.propTracker, {ignore: this}) : null;

		const $ptsExistings = [$ptsExistingStatic, $ptsExistingChoose].filter(Boolean);

		this._getStaticKeys_all()
			.forEach(prof => {
				$ptsExistings.forEach($ptsExisting => {
					if (!$ptsExisting[prof]) return;

										let maxExisting = this._existing?.[prof] || 0;

										if (otherStates) otherStates.forEach(otherState => maxExisting = Math.max(maxExisting, otherState[prof] || 0));

					if (maxExisting) {
						const helpText = maxExisting === 1
							? `Proficient from Another Source`
							: maxExisting === 2 ? `Proficient with Expertise from Another Source` : `Half-Proficient from Another Source`;

						$ptsExisting[prof]
							.forEach($ptExisting => {
								$ptExisting
									.title(helpText)
									.addClass("ml-1")
									.html(`(<i class="fas fa-fw ${UtilActors.PROF_TO_ICON_CLASS[maxExisting]}"></i>)`);
							});
					} else {
						$ptsExisting[prof]
							.forEach($ptExisting => {
								$ptExisting
									.title("")
									.removeClass("ml-1")
									.html("");
							});
					}
				});
			});
	}

	_render_renderPtChooseFrom ($stgGroup, profSet) {
		const count = profSet.choose.count || 1;

		const cpyProfSet = this.constructor._getSortedProfSet(profSet);

		const $ptsExisting = {};
		const multiChoiceMeta = ComponentUiUtil.getMetaWrpMultipleChoice(
			this,
			"proficiencyChoice",
			{
				count,
				values: cpyProfSet.choose.from,
				fnDisplay: profOrObj => this._getMultiChoiceDisplay($ptsExisting, profOrObj),
			},
		);

				let hkSetTrackerInfo = null;
		if (this._featureSourceTracker) {
			hkSetTrackerInfo = () => this._doSetTrackerState();
			this._addHookBase(multiChoiceMeta.propPulse, hkSetTrackerInfo);
		}
		
		$stgGroup.append(`<div class="mb-1">${this._getMultiChoiceTitle(cpyProfSet, count)}:</div>`);
		multiChoiceMeta.$ele.appendTo($stgGroup);

		this._lastMeta = {
			cleanup: () => {
				multiChoiceMeta.cleanup();
				if (hkSetTrackerInfo) this._removeHookBase(multiChoiceMeta.propPulse, hkSetTrackerInfo);
			},
		};

		return $ptsExisting;
	}

	isNoChoice () { return this.constructor.isNoChoice(this._available); }

	_getFormData () {
		const out = {};

		const profSet = this._available[this._state.ixSet];

		const cpyProfSet = this.constructor._getSortedProfSet(profSet);

				this._getStaticKeys_all().filter(name => cpyProfSet[name]).map(name => out[name] = 1);

		if (cpyProfSet.choose) {
			const ixs = ComponentUiUtil.getMetaWrpMultipleChoice_getSelectedIxs(this, "proficiencyChoice");
			ixs.map(it => cpyProfSet.choose.from[it]).forEach(name => out[name] = 1);
		}

		return {
			isFormComplete: !!this._state[ComponentUiUtil.getMetaWrpMultipleChoice_getPropIsAcceptable("proficiencyChoice")],
			data: {
				[this._propGroup.prop]: out,
			},
		};
	}

	pGetFormData () { return this._getFormData(); }

	_getDefaultState () {
		return {
			ixSet: 0,
		};
	}
}

class Charactermancer_OtherProficiencySelect extends Charactermancer_ProficiencySelect {
			static async pGetUserInput (opts) {
		opts = opts || {};

		if (!opts.available) return {isFormComplete: true, data: {}};

		const comp = new this({
			...opts,
			existing: this.getExisting(opts.existingFvtt),
			existingFvtt: opts.existingFvtt,
		});
		if (comp.isNoChoice()) return comp.pGetFormData();

		return UtilApplications.pGetImportCompApplicationFormData({
			comp,
			width: 640,
			isAutoResize: true,
		});
	}

	static getExistingFvttFromActor (actor) {
		return {
			skillProficiencies: MiscUtil.get(actor, "_source", "system", "skills"),
			toolProficiencies: MiscUtil.get(actor, "_source", "system", "tools"),
			languageProficiencies: MiscUtil.get(actor, "_source", "system", "traits", "languages"),
			armorProficiencies: MiscUtil.get(actor, "_source", "system", "traits", "armorProf"),
			weaponProficiencies: MiscUtil.get(actor, "_source", "system", "traits", "weaponProf"),
			savingThrowProficiencies: MiscUtil.get(actor, "_source", "system", "abilities"),
		};
	}

	static getExisting (existingFvtt) {
		return {
			skillProficiencies: this._getExistingSkillToolProficiencies({
				existingProficienciesSetFvtt: existingFvtt.skillProficiencies,
				mapAbvToFull: UtilActors.SKILL_ABV_TO_FULL,
			}),
			toolProficiencies: this._getExistingSkillToolProficiencies({
				existingProficienciesSetFvtt: existingFvtt.toolProficiencies,
				mapAbvToFull: UtilActors.SKILL_ABV_TO_FULL,
			}),
			languageProficiencies: this._getExistingProficiencies({
				existingProficienciesSetFvtt: existingFvtt?.languageProficiencies,
				vetToFvttProfs: UtilActors.VALID_LANGUAGES,
				allProfsVet: Parser.LANGUAGES_ALL,
			}),
			armorProficiencies: this._getExistingProficiencies({
				existingProficienciesSetFvtt: existingFvtt?.armorProficiencies,
				vetToFvttProfs: UtilActors.VALID_ARMOR_PROFICIENCIES,
				allProfsVet: UtilActors.ARMOR_PROFICIENCIES,
			}),
			weaponProficiencies: this._getExistingProficiencies({
				existingProficienciesSetFvtt: existingFvtt?.weaponProficiencies,
				vetToFvttProfs: UtilActors.VALID_WEAPON_PROFICIENCIES,
				allProfsVet: UtilActors.WEAPON_PROFICIENCIES,
			}),
			savingThrowProficiencies: this._getExistingSavingThrowProficiencies(existingFvtt),
		};
	}

	static isNoChoice (available) {
		return this._isNoChoice({available});
	}

	static _isNoChoice ({available, isAlreadyMapped}) {
		if (!available?.length) return true; 
		if (isAlreadyMapped && !this._isValidAvailableData(available)) throw new Error(`Proficiency data was not valid! Data was:\n${JSON.stringify(available)}`);

		if (!isAlreadyMapped) available = Charactermancer_OtherProficiencySelect._getNormalizedAvailableProficiencies(available);

		return available.length === 1 && !available[0].choose;
	}

		static _isValidAvailableData (available) {
		if (!(available instanceof Array)) return false;

		for (const profSet of available) {
			const badKeys = Object.keys(profSet).filter(it => it !== "static" && it !== "choose");
			if (badKeys.length) return false;

			if ((profSet.static || []).filter(it => !it.prop).length) return false;
			if ((profSet.choose || []).filter(it => it.from && it.from.some(from => !from.prop)).length) return false;
			if ((profSet.choose || []).filter(it => it.fromFilter && !it.prop).length) return false;
		}

		return true;
	}

		static getMappedSkillProficiencies (skillProficiencies) {
		if (!skillProficiencies) return skillProficiencies;
		return skillProficiencies.map(it => {
			it = MiscUtil.copy(it);
			if (it.any) { it.anySkill = it.any; delete it.any; }
			if (it.choose?.from && CollectionUtil.setEq(new Set(it.choose.from), new Set(Charactermancer_OtherProficiencySelect._ALL_SKILLS))) {
				it.anySkill = it.choose.count ?? 1;
				delete it.choose;
			}
			this._getMappedProficiencies_expandChoose({proficienciesSet: it, prop: "skillProficiencies"});
			return it;
		});
	}

		static getMappedLanguageProficiencies (languageProficiencies) {
		if (!languageProficiencies) return languageProficiencies;
		return languageProficiencies.map(it => {
			it = MiscUtil.copy(it);
			if (it.any) { it.anyLanguage = it.any; delete it.any; }
			if (it.anyStandard) { it.anyStandardLanguage = it.anyStandard; delete it.anyStandard; }
			this._getMappedProficiencies_expandChoose({proficienciesSet: it, prop: "languageProficiencies"});
			this._getMappedProficiencies_expandStatic({proficienciesSet: it, prop: "languageProficiencies"});
			return it;
		});
	}

		static getMappedToolProficiencies (toolProficiencies) {
		if (!toolProficiencies) return toolProficiencies;
		return toolProficiencies.map(it => {
			it = MiscUtil.copy(it);
			if (it.any) { it.anyTool = it.any; delete it.any; }
			if (it.anyArtisans) { it.anyArtisansTool = it.anyArtisans; delete it.anyArtisans; }
			this._getMappedProficiencies_expandChoose({proficienciesSet: it, prop: "toolProficiencies"});
			this._getMappedProficiencies_expandStatic({proficienciesSet: it, prop: "toolProficiencies"});
			return it;
		});
	}

		static getMappedArmorProficiencies (armorProficiencies) {
		if (!armorProficiencies) return armorProficiencies;
		return armorProficiencies.map(it => {
			it = MiscUtil.copy(it);
			if (it.any) { it.anyArmor = it.any; delete it.any; }
			this._getMappedProficiencies_expandChoose({proficienciesSet: it, prop: "armorProficiencies"});
			this._getMappedProficiencies_expandStatic({proficienciesSet: it, prop: "armorProficiencies"});
			return it;
		});
	}

		static getMappedWeaponProficiencies (weaponProficiencies) {
		if (!weaponProficiencies) return weaponProficiencies;
		return weaponProficiencies.map(it => {
			it = MiscUtil.copy(it);
			if (it.any) { it.anyWeapon = it.any; delete it.any; }
			this._getMappedProficiencies_expandChoose({proficienciesSet: it, prop: "weaponProficiencies"});
			this._getMappedProficiencies_expandStatic({proficienciesSet: it, prop: "weaponProficiencies"});
			return it;
		});
	}

		static getMappedSavingThrowProficiencies (savingThrowProficiencies) {
		if (!savingThrowProficiencies) return savingThrowProficiencies;
		return savingThrowProficiencies.map(it => {
			it = MiscUtil.copy(it);
			if (it.any) { it.anySavingThrow = it.any; delete it.any; }
			this._getMappedProficiencies_expandChoose({proficienciesSet: it, prop: "savingThrowProficiencies"});
			this._getMappedProficiencies_expandStatic({proficienciesSet: it, prop: "savingThrowProficiencies"});
			return it;
		});
	}

	static _getMappedProficiencies_expandChoose ({proficienciesSet, prop}) {
				if (!proficienciesSet.choose) return;
		if (proficienciesSet.choose.fromFilter) proficienciesSet.choose.prop = prop;
		if (proficienciesSet.choose.from) {
			proficienciesSet.choose.from = proficienciesSet.choose.from.map(it => {
								if (typeof it !== "string") return it;
				return {prop, name: it};
			});
		}
		proficienciesSet.choose = [proficienciesSet.choose];
	}

	static _getMappedProficiencies_expandStatic ({proficienciesSet, prop, ignoredKeys}) {
		Object.entries(proficienciesSet)
			.forEach(([k, v]) => {
				if ((ignoredKeys && ignoredKeys.has(k)) || Charactermancer_OtherProficiencySelect._MAPPED_IGNORE_KEYS.has(k)) return;

				if (typeof v === "boolean") { proficienciesSet[k] = {prop}; return; }
				if (typeof v === "number") { proficienciesSet[k] = {prop, count: v}; return; }

				throw new Error(`Unhandled type "${typeof v}" for value of proficiency "${k}"`);
			});
	}
	
	static _getExistingFvttProficiencySetsMeta (existingFvtt) {
		return {
			existingProficienciesFvttSet: new Set(existingFvtt?.value || []),
			existingProficienciesFvttSetCustom: new Set((existingFvtt?.custom || "").split(";").map(it => it.trim().toLowerCase()).filter(Boolean)),
		};
	}

		constructor (opts) {
		opts = opts || {};
		super();

		this._existing = opts.existing;
		this._available = Charactermancer_OtherProficiencySelect._getNormalizedAvailableProficiencies(opts.available);
		this._titlePrefix = opts.titlePrefix;
		this._featureSourceTracker = opts.featureSourceTracker || new Charactermancer_FeatureSourceTracker();
		this._$elesPreFromGroups = opts.$elesPreFromGroups;
		this._$elesPostFromGroups = opts.$elesPostFromGroups;

		this._lastMetas = [];
		this._hkExisting = null;
	}

	static _getNormalizedAvailableProficiencies (availProfs) {
		return availProfs
			.map(availProfSet => {
				const out = {};

				Object.entries(availProfSet)
					.forEach(([k, v]) => {
						if (!v) return;

						switch (k) {
							case "choose": {
								v
									.forEach(choose => {
										const mappedCount = choose.count != null && !isNaN(choose.count) ? Number(choose.count) : 1;
										if (mappedCount <= 0) return;

										const mappedFroms = (choose?.from || [])
											.map(it => this._getMappedAny({keyAny: it, countRaw: mappedCount}) || this._getNormalizedProficiency(null, it))
											.filter(Boolean);

																				const mappedFromFilter = (choose?.fromFilter || "").trim();

										if (!mappedFroms.length && !mappedFromFilter) return;
										if (mappedFroms.length && mappedFromFilter) throw new Error(`Invalid proficiencies! Only one of "from" and "fromFilter" may be provided. Data was:\n${JSON.stringify(choose)}`);

										const tgt = (out.choose = out.choose || []);

										if (mappedFromFilter) {
											if (!choose.type && !choose.prop) throw new Error(`"fromFilter" did not have an associated "type"!`);
											tgt.push({fromFilter: mappedFromFilter, count: mappedCount, prop: choose.prop || this._getNormalizedProficiencyPropFromType(choose.type)});
											return;
										}

										if (!mappedFroms.length) return;

																				const subOut = {from: [], count: mappedCount};
										mappedFroms.forEach(it => {
																						if (it.from) {
												subOut.from = [...subOut.from, ...it.from];
												if (it.groups) Object.assign((subOut.groups = subOut.groups || {}), it.groups);
												return;
											}

																						subOut.from.push(it);
										});
										tgt.push(subOut);
									});

								break;
							}

							case "anySkill":
							case "anyTool":
							case "anyArtisansTool":
							case "anyMusicalInstrument":
							case "anyLanguage":
							case "anyStandardLanguage":
							case "anyWeapon":
							case "anyArmor":
							case "anySavingThrow": {
								const mappedAny = this._getMappedAny({keyAny: k, countRaw: v});
								if (!mappedAny) break;
								(out.choose = out.choose || []).push(mappedAny);
								break;
							}

							default: {
								if (k === "static") throw new Error(`Property handling for "static" is unimplemented!`);

								if (v?.prop) { (out.static = out.static || []).push({name: k, prop: v.prop}); break; }
								if (v?.type) { (out.static = out.static || []).push({name: k, prop: this._getNormalizedProficiencyPropFromType(v.type)}); break; }

								const normalized = this._getNormalizedProficiency(k, v);
								if (normalized) (out.static = out.static || []).push(normalized);
							}
						}
					});

												if (out.static && out.choose) {
					out.choose.forEach(choose => {
						if (choose.fromFilter) return;

						choose.from = choose.from.filter(({name, prop}) => !out.static.some(({name: nameStatic, prop: propStatic}) => nameStatic === name && propStatic === prop));
					});
				}

				return out;
			});
	}

	static _getMappedAny ({keyAny, countRaw}) {
		const mappedCount = !isNaN(countRaw) ? Number(countRaw) : 1;
		if (mappedCount <= 0) return null;

		switch (keyAny) {
			case "anySkill": return {
				name: mappedCount === 1 ? `Any Skill` : `Any ${mappedCount} Skills`,
				from: Charactermancer_OtherProficiencySelect._ALL_SKILLS
					.map(it => ({name: it, prop: "skillProficiencies"})),
				count: mappedCount,
			};
			case "anyTool": return {
				name: mappedCount === 1 ? `Any Tool` : `Any ${mappedCount} Tools`,
				from: Charactermancer_OtherProficiencySelect._ALL_TOOLS
					.map(it => ({name: it, prop: "toolProficiencies"})),
				count: mappedCount,
			};
			case "anyArtisansTool": return {
				name: mappedCount === 1 ? `Any Artisan's Tool` : `Any ${mappedCount} Artisan's Tools`,
				from: Charactermancer_OtherProficiencySelect._ALL_TOOLS_ARTISANS
					.map(it => ({name: it, prop: "toolProficiencies"})),
				count: mappedCount,
			};
			case "anyMusicalInstrument": return {
				name: mappedCount === 1 ? `Any Musical Instrument` : `Any ${mappedCount} Musical Instruments`,
				from: Charactermancer_OtherProficiencySelect._ALL_TOOLS_MUSICAL_INSTRUMENTS
					.map(it => ({name: it, prop: "toolProficiencies"})),
				count: mappedCount,
			};
			case "anyLanguage": return {
				name: mappedCount === 1 ? `Any Language` : `Any ${mappedCount} Languages`,
				from: Charactermancer_OtherProficiencySelect._ALL_LANGUAGES
					.map(it => ({name: it, prop: "languageProficiencies"})),
				count: mappedCount,
			};
			case "anyStandardLanguage": return {
				name: mappedCount === 1 ? `Any Standard Language` : `Any ${mappedCount} Standard Languages`,
				...MiscUtil.copy(Charactermancer_OtherProficiencySelect._ALL_LANGUAGES_STANDARD__CHOICE_OBJECT),
				count: mappedCount,
			};
			case "anySavingThrow": return {
				name: mappedCount === 1 ? `Any Saving Throw` : `Any ${mappedCount} Saving Throws`,
				from: Charactermancer_OtherProficiencySelect._ALL_SAVING_THROWS
					.map(it => ({name: it, prop: "savingThrowProficiencies"})),
				count: mappedCount,
			};

			case "anyWeapon": throw new Error(`Property handling for "anyWeapon" is unimplemented!`);
			case "anyArmor": throw new Error(`Property handling for "anyArmor" is unimplemented!`);

			default: return null;
		}
	}

		static _getNormalizedProficiency (k, v) {
		if (!v) return null;

		let name = v?.name ?? k ?? v;
		if (!name || typeof name !== "string") return null;
		name = name.trim();

		if (v?.prop) {
			return {name, prop: v.prop};
		}

		if (v?.type) {
			const prop = this._getNormalizedProficiencyPropFromType(v.type);
			return {name, prop};
		}

		if (Charactermancer_OtherProficiencySelect._VALID_SKILLS.has(name)) return {name, prop: "skillProficiencies"};
		if (Charactermancer_OtherProficiencySelect._VALID_TOOLS.has(name)) return {name, prop: "toolProficiencies"};
		if (Charactermancer_OtherProficiencySelect._VALID_LANGUAGES.has(name)) return {name, prop: "languageProficiencies"};
		if (Charactermancer_OtherProficiencySelect._VALID_WEAPONS.has(name)) return {name, prop: "weaponProficiencies"};
		if (Charactermancer_OtherProficiencySelect._VALID_ARMORS.has(name)) return {name, prop: "armorProficiencies"};
		if (Charactermancer_OtherProficiencySelect._VALID_SAVING_THROWS.has(name)) return {name, prop: "savingThrowProficiencies"};

		console.warn(...LGT, `Could not discern the type of proficiency "${name}"\u2014you may need to specify it directly with "type".`);

				return null;
	}

	static _getNormalizedProficiencyPropFromType (type) {
		type = type.trim().toLowerCase();
		switch (type) {
			case "skill": return "skillProficiencies";
			case "tool": return "toolProficiencies";
			case "language": return "languageProficiencies";
			case "weapon": return "weaponProficiencies";
			case "armor": return "armorProficiencies";
			case "savingThrow": return "savingThrowProficiencies";
			default: throw new Error(`Type "${type}" did not have an associated proficiency property!`);
		}
	}

	static _getTagFromProp (prop) {
		switch (prop) {
			case "armorProficiencies": return "@item";
			case "weaponProficiencies": return "@item";
			default: throw new Error(`Cannot get @tag from prop "${prop}"`);
		}
	}

	_getTitle () {
		const props = this._getAllPossibleProps();
		return `${props.map(prop => this.constructor._getPropDisplayName({prop})).join("/")} Proficiency`;
	}

	_getTitlePlural () {
		const props = this._getAllPossibleProps();
		return `${props.map(prop => this.constructor._getPropDisplayName({prop, isPlural: true})).join("/")} Proficiencies`;
	}

	_getAllPossibleProps () {
		const propSet = new Set();

		this._available.forEach(profSet => {
			const subSet = this.constructor._getAllPossiblePropsForProfSet(profSet);
			subSet.forEach(prop => propSet.add(prop));
		});

		return [...propSet];
	}

	static _getAllPossiblePropsForProfSet (profSet) {
		const out = new Set();
		(profSet.static || []).forEach(it => out.add(it.prop));
		(profSet.choose || []).forEach(it => {
			if (it.prop) return out.add(it.prop);
			it.from.forEach(from => out.add(from.prop));
		});
		return out;
	}

	get modalTitle () { return this._getTitlePlural(); }

	render ($wrp) {
		const $stgSelGroup = this._render_$getStgSelGroup();

		const $stgGroup = $$`<div class="ve-flex-col"></div>`;

		const hkIxSet = () => {
			$stgGroup.empty();

			if (this._featureSourceTracker && this._hkExisting) {
				Object.values(Charactermancer_OtherProficiencySelect._PROP_GROUPS)
					.forEach(({propTrackerPulse}) => this._featureSourceTracker.removeHook(this, propTrackerPulse, this._hkExisting));
			}
			this._lastMetas.forEach(it => it.cleanup());
			this._lastMetas = [];

			const selProfs = this._available[this._state.ixSet];

			if (this._featureSourceTracker) this._doSetTrackerState();

						const $ptsExistingStatic = selProfs.static?.length ? this._render_renderPtStatic($stgGroup, selProfs.static) : null;
			
			if ($ptsExistingStatic && selProfs.choose?.length) $stgGroup.append(`<hr class="hr-2">`);

						const $ptsExistingChoose = (selProfs.choose || [])
				.map(({count, from, groups, fromFilter, prop}, i) => {
					if (this._$elesPreFromGroups?.[i]) $stgGroup.append(this._$elesPreFromGroups?.[i]);

					const $outPtsExisting = fromFilter
						? this._render_renderPtChooseFromFilter($stgGroup, {ix: i, count, fromFilter, prop})
						: this._render_renderPtChooseFrom($stgGroup, {ix: i, count, from, groups});

					if (this._$elesPostFromGroups?.[i]) $stgGroup.append(this._$elesPostFromGroups?.[i]);

										if (selProfs.choose.length > 1 && (i < selProfs.choose.length - 1)) {
						$stgGroup.append(`<hr class="hr-2">`);
					}

					return $outPtsExisting;
				});
			
			this._hkExisting = () => this._hk_pUpdatePtsExisting($ptsExistingStatic, $ptsExistingChoose);
			if (this._featureSourceTracker) {
				Object.values(Charactermancer_OtherProficiencySelect._PROP_GROUPS)
					.forEach(({propTrackerPulse}) => this._featureSourceTracker.addHook(this, propTrackerPulse, this._hkExisting));
			}
			this._hkExisting();
		};
		this._addHookBase("ixSet", hkIxSet);
		hkIxSet();

		$$($wrp)`
			${$stgSelGroup}
			${$stgGroup}
		`;
	}

	_doSetTrackerState () {
		const formData = this._getFormData();
		this._featureSourceTracker.setState(
			this,
			Object.keys(Charactermancer_OtherProficiencySelect._PROP_GROUPS)
				.mergeMap(prop => ({[prop]: formData.data?.[prop]})),
		);
	}

	static _render_getStaticKeyFullText ({name, prop}) {
		switch (prop) {
			case "weaponProficiencies": return name.split("|")[0].toTitleCase();

			case "armorProficiencies": {
				switch (name) {
					case "light":
					case "medium":
					case "heavy": return name.toTitleCase();
					case "shield|phb": return "Shields";
					default: return name.split("|")[0].toTitleCase();
				}
			}

			case "savingThrowProficiencies": return Parser.attAbvToFull(name).toTitleCase();

			default: return name.toTitleCase();
		}
	}

	static _render_getStaticKeyFullTextOther ({prop}) {
		switch (prop) {
			case "skillProficiencies": return "(Other skill proficiency)";
			case "toolProficiencies": return "(Other tool proficiency)";
			case "languageProficiencies": return "(Other language proficiency)";
			case "weaponProficiencies": return "(Other weapon proficiency)";
			case "armorProficiencies": return "(Other armor proficiency)";
			case "savingThrowProficiencies": return "(Other saving throw proficiency)";
			default: throw new Error(`Unhandled prop "${prop}"`);
		}
	}

	static async _pGetParentGroup ({prop, name}) {
		switch (prop) {
			case "weaponProficiencies": return UtilDataConverter.pGetItemWeaponType(name);
			default: return null;
		}
	}

	static _getRenderedStatic ({prop, name}) {
		switch (prop) {
			case "skillProficiencies": return this._getRenderedStatic_skillProficiencies(name);
			case "languageProficiencies": return this._getRenderedStatic_languageProficiencies(name);
			case "toolProficiencies": return this._getRenderedStatic_toolProficiencies(name);
			case "armorProficiencies": return this._getRenderedStatic_armorProficiencies(name);
			case "weaponProficiencies": return Renderer.get().render(`{@item ${name.split("|").map(sub => sub.toTitleCase()).join("|")}}`);
			case "savingThrowProficiencies": return Parser.attAbvToFull(name).toTitleCase();
			default: return name.toTitleCase();
		}
	}

	static _getRenderedStatic_skillProficiencies (name) {
		const atb = Parser.skillToAbilityAbv(name);
		const ptAbility = `<div class="ml-1 ve-small ve-muted" title="${Parser.attAbvToFull(atb)}">(${atb.toTitleCase()})</div>`;

		return `<div class="ve-inline-flex-v-center">${Renderer.get().render(`{@skill ${name.toTitleCase()}}`)}${ptAbility}</div>`;
	}

	static _getRenderedStatic_languageProficiencies (name) {
		if (name === "other") return name.toTitleCase();
		if (UtilActors.LANGUAGES_PRIMORDIAL.includes(name)) return Renderer.get().render(`{@language primordial||${name.toTitleCase()}}`);
		return Renderer.get().render(`{@language ${name.toTitleCase()}}`);
	}

	static _getRenderedStatic_toolProficiencies (name) {
		if (UtilActors.TOOL_PROFICIENCIES_TO_UID[name]) return Renderer.get().render(`{@item ${UtilActors.TOOL_PROFICIENCIES_TO_UID[name].toTitleCase()}}`);
		return name.toTitleCase();
	}

	static _getRenderedStatic_armorProficiencies (key) {
		if (key === "light" || key === "medium" || key === "heavy") return key.toTitleCase();
		if (key === "shield|phb") return Renderer.get().render(`{@item shield|phb|Shields}`);
		return Renderer.get().render(`{@item ${key.split("|").map(sub => sub.toTitleCase()).join("|")}}`);
	}

	static _getPropDisplayName ({prop}) {
		switch (prop) {
			case "skillProficiencies": return `Skill`;
			case "toolProficiencies": return `Tool`;
			case "languageProficiencies": return `Language`;
			case "weaponProficiencies": return `Weapon`;
			case "armorProficiencies": return `Armor`;
			case "savingThrowProficiencies": return `Saving Throw`;
			default: throw new Error(`Unhandled prop "${prop}"`);
		}
	}

		_render_$getStgSelGroup () {
		if (this._available.length <= 1) return null;

		const $selIxSet = ComponentUiUtil.$getSelEnum(
			this,
			"ixSet",
			{
				placeholder: `Select ${this._getTitle()} Set`,
				values: this._available.map((_, i) => i),
				fnDisplay: ix => {
					const selProfs = this._available[ix];

					const out = [];

					if (selProfs.static) {
						const pt = MiscUtil.copy(selProfs.static)
							.sort((a, b) => SortUtil.ascSortLower(a.name, b.name))
							.map(({name, prop}) => {
								if (name === "other") return this.constructor._render_getStaticKeyFullTextOther({prop});
								return this.constructor._render_getStaticKeyFullText({name, prop});
							})
							.join(", ");
						out.push(pt);
					}

					if (selProfs.choose) {
						selProfs.choose.forEach(fromBlock => {
							if (fromBlock.name) {
								out.push(`Choose ${fromBlock.name.toLowerCase()}`);
								return;
							}

							if (fromBlock.fromFilter) {
								out.push(`Choose ${Parser.numberToText(fromBlock.count)} from filtered selection`);
								return;
							}

							if (fromBlock.groups) {
								out.push(`Choose ${Parser.numberToText(fromBlock.count)} from ${Object.values(fromBlock.groups).map(({name}) => name).joinConjunct(", ", " or ")}`);
								return;
							}

							out.push(`Choose ${Parser.numberToText(fromBlock.count || 1)} from ${fromBlock.from.map(({name}) => name.toTitleCase()).join(", ")}`);
						});
					}

					return out.filter(Boolean).join("; ") || "(Nothing)";
				},
			},
		);

		if (this._featureSourceTracker) {
			const hk = () => {
				const formData = this._getFormData().data;
				const trackerState = Object.keys(formData.data || {})
					.filter(k => Charactermancer_OtherProficiencySelect._PROP_GROUPS[k])
					.mergeMap(it => it);
				this._featureSourceTracker.setState(this, trackerState);
			};
			this._addHookBase("ixSet", hk);
		}

		return $$`<div class="w-100 mb-2 ve-flex-vh-center">
			${$selIxSet}
		</div>`;
	}

	_getAllValuesMaybeInUseLookup () {
		const out = {};

		const activeSet = this._available[this._state.ixSet] || {};

		if (activeSet.static) {
			activeSet.static.forEach(({name, prop}) => {
				out[prop] = out[prop] || new Set();
				out[prop].add(name);
			});
		}

		if (activeSet.choose) {
			activeSet.choose.forEach(({from, fromFilter}) => {
				if (fromFilter) {
					const prefix = `${this._getStateKeyPrefix()}_chooseFilter_`;
										Object.entries(this._state)
						.filter(([k, v]) => k.startsWith(prefix) && v)
						.forEach(([, {prop, name}]) => {
							if (!name) throw new Error(`"fromFilter" choice had no "name"--this should never occur!`);
							out[prop] = out[prop] || new Set();
							out[prop].add(name);
						});
					return;
				}

				from.forEach(({name, prop}) => {
					out[prop] = out[prop] || new Set();
					out[prop].add(name);
				});
			});
		}

		return out;
	}

	_getStateKeyPrefix () { return "otherProfSelect"; }

	_getPropsChooseFromFilter ({ixChoose, ixCount}) {
		return {
			propState: `${this._getStateKeyPrefix()}_chooseFilter_${ixChoose}_${ixCount}`,
		};
	}

	_getPropsChooseFrom ({ixChoose}) {
		return {
			propState: `${this._getStateKeyPrefix()}_${ixChoose}`,
		};
	}

	async _hk_pUpdatePtsExisting ($ptsExistingStatic, $ptsExistingChooseFrom) {
		try {
			await this._pLock("updateExisting");
			await this._hk_pUpdatePtsExisting_({$ptsExistingStatic, $ptsExistingChooseFrom});
		} finally {
			this._unlock("updateExisting");
		}
	}

	async _hk_pUpdatePtsExisting_ ({$ptsExistingStatic, $ptsExistingChooseFrom}) {
		const allValueLookupEntries = Object.entries(this._getAllValuesMaybeInUseLookup());

		if ($ptsExistingStatic) await this._hk_pUpdatePtsExisting_part({allValueLookupEntries, $ptsExisting: $ptsExistingStatic});
		if (!$ptsExistingChooseFrom) return;
		for (const $ptsExisting of $ptsExistingChooseFrom) await this._hk_pUpdatePtsExisting_part({allValueLookupEntries, $ptsExisting});
	}

	async _hk_pUpdatePtsExisting_part ({allValueLookupEntries, $ptsExisting}) {
		for (const [prop, allProfs] of allValueLookupEntries) {
			const otherStates = this._featureSourceTracker ? this._featureSourceTracker.getStatesForKey(prop, {ignore: this}) : null;

			for (const v of allProfs) {
				const parentGroup = await this.constructor._pGetParentGroup({prop, name: v});

				if (!$ptsExisting[prop]?.[v] && !parentGroup) continue;

								let maxExisting = this._existing?.[prop]?.[v]
					|| (parentGroup && this._existing?.[prop]?.[parentGroup])
					|| 0;

								if (otherStates) otherStates.forEach(otherState => maxExisting = Math.max(maxExisting, otherState[v] || 0, (parentGroup ? otherState[parentGroup] : 0) || 0));

				const helpText = maxExisting === 0 ? "" : `${UtilActors.PROF_TO_TEXT[maxExisting]} from Another Source`;

				$ptsExisting[prop][v]
					.title(helpText)
					.toggleClass("ml-1", !!maxExisting)
					.html(maxExisting ? `(<i class="fas fa-fw ${UtilActors.PROF_TO_ICON_CLASS[maxExisting]}"></i>)` : "");
			}
		}
	}

	_render_renderPtStatic ($stgGroup, profsStatic) {
		const $ptsExisting = {};

		const byProp = {};
		profsStatic.forEach(({prop, name}) => MiscUtil.set(byProp, prop, name, true));
		const isMultiProp = this.constructor._getAllPossiblePropsForProfSet(this._available[this._state.ixSet]).size > 1;

		const $wrps = Object.entries(byProp)
			.map(([prop, profsStaticSet]) => {
				const ptPropType = isMultiProp ? ` (${this.constructor._getPropDisplayName({prop})} Proficiency)` : "";
				const profsStaticSetKeys = Object.keys(profsStaticSet);
				return profsStaticSetKeys
					.sort(SortUtil.ascSortLower)
					.map((name, i) => {
						const $ptExisting = $(`<div class="ve-small veapp__msg-warning inline-block"></div>`);
						MiscUtil.set($ptsExisting, prop, name, $ptExisting);
						const isNotLast = i < profsStaticSetKeys.length - 1;
						return $$`<div class="inline-block ${isNotLast ? "mr-1" : ""}">${this.constructor._getRenderedStatic({prop, name})}${ptPropType}${$ptExisting}${isNotLast ? `,` : ""}</div>`;
					});
			})
			.flat();

		$$`<div class="block">
			${$wrps}
		</div>`.appendTo($stgGroup);

		return $ptsExisting;
	}

	_render_renderPtChooseFrom ($stgGroup, {ix, count, from, groups}) {
		const {propState} = this._getPropsChooseFrom({ixChoose: ix});

		const $ptsExisting = {};
		const compOpts = {
			count,
			fnDisplay: ({prop, name}) => {
				const $ptExisting = $(`<div class="ve-small veapp__msg-warning"></div>`);
				MiscUtil.set($ptsExisting, prop, name, $ptExisting);

				return $$`<div class="ve-flex-v-center w-100">
					<div class="ve-flex-v-center">${this.constructor._getRenderedStatic({prop, name})}</div>
					${$ptExisting}
				</div>`;
			},
		};

		const fromProps = new Set(from.map(({prop}) => prop));

		const byPropThenGroup = {};

		from.forEach(({name, prop, group}) => {
			group = group ?? "_";
			MiscUtil.set(byPropThenGroup, prop, group, name, Charactermancer_OtherProficiencySelect._PROFICIENT);
		});

		const isMultiProp = Object.keys(byPropThenGroup).length > 1;
		const isGrouped = Object.values(byPropThenGroup).some(groupMeta => Object.keys(groupMeta).some(group => group !== "_"));

										if (isMultiProp || isGrouped) {
						const valueGroups = [];
			Object.entries(byPropThenGroup)
				.forEach(([prop, groupMeta]) => {
					Object.entries(groupMeta)
						.forEach(([groupId, names]) => {
							const groupDetails = groups?.[groupId];

							valueGroups.push({
								name: [
									(isMultiProp ? `${this.constructor._getPropDisplayName({prop})} Proficiencies` : ""),
									groupDetails?.name,
								]
									.filter(Boolean)
									.join(""),
								text: groupDetails?.hint,
								values: Object.keys(names).map(name => ({prop, name})),
							});
						});
				});

			compOpts.valueGroups = valueGroups;
		} else {
			compOpts.values = from;
		}

		const meta = ComponentUiUtil.getMetaWrpMultipleChoice(
			this,
			propState,
			compOpts,
		);

				let hkSetTrackerInfo = null;
		if (this._featureSourceTracker) {
			hkSetTrackerInfo = () => this._doSetTrackerState();
			this._addHookBase(meta.propPulse, hkSetTrackerInfo);
		}
		
		this._lastMetas.push({
			cleanup: () => {
				meta.cleanup();
				if (hkSetTrackerInfo) this._removeHookBase(meta.propPulse, hkSetTrackerInfo);
			},
		});

		const header = fromProps.size === 1
			? (`${this.constructor._getPropDisplayName({prop: [...fromProps][0]})} ${count === 1 ? "Proficiency" : "Proficiencies"}`)
			: (count === 1 ? this._getTitle() : this._getTitlePlural());
		$stgGroup.append(`<div class="mb-1">${this._titlePrefix ? `${this._titlePrefix}: ` : ""}Choose ${Parser.numberToText(count)} ${header}:</div>`);
		meta.$ele.appendTo($stgGroup);

		return $ptsExisting;
	}

	_render_renderPtChooseFromFilter ($stgGroup, {ix, fromFilter, count, prop}) {
		const $ptsExisting = {};

		const $row = $(`<div class="ve-flex-v-center"></div>`);

		[...new Array(count)].forEach((_, i) => {
			const {propState} = this._getPropsChooseFromFilter({ixChoose: ix, ixCount: i});

			const $ptExisting = $(`<div class="ve-small veapp__msg-warning"></div>`);

			const $disp = $(`<div class="ve-flex-v-center"></div>`);
			const hkChosen = (propHk, valueHk, prevValueHk) => {
				const isFirstRun = !propHk;
				if (!isFirstRun) {
					if (prevValueHk) {
						const {prop: propPrev, name: namePrev} = prevValueHk;
						const uidPrev = (namePrev || "").toLowerCase();
						MiscUtil.delete($ptsExisting, propPrev, uidPrev, $ptExisting);
					}

					if (valueHk) {
						const {prop, name} = valueHk || {};
						const uid = (name || "").toLowerCase();
						MiscUtil.set($ptsExisting, prop, uid, $ptExisting);
					}
				}

				$disp.html(
					this._state[propState] != null
						? `<div>${Renderer.get().render(`{${this.constructor._getTagFromProp(prop)} ${this._state[propState].name.toLowerCase()}}`)}</div>`
						: `<div class="italic ve-muted">(select a ${this.constructor._getPropDisplayName({prop}).toLowerCase()} proficiency)</div>`,
				);

				if (!isFirstRun && this._featureSourceTracker) this._doSetTrackerState();
			};
			this._addHookBase(propState, hkChosen);
			this._lastMetas.push({cleanup: () => this._removeHookBase(propState, hkChosen)});
			hkChosen();

			const $btnFilter = $(`<button class="btn btn-default btn-xxs mx-1" title="Choose a ${this.constructor._getPropDisplayName({prop})} Proficiency"><span class="fas fa-fw fa-search"></span></button>`)
				.click(async () => {
					const selecteds = await this._pGetFilterChoice({prop, fromFilter});
					if (selecteds == null || !selecteds.length) return;

					const selected = selecteds[0];
					this._state[propState] = {prop, name: `${selected.name}|${selected.values.sourceJson}`.toLowerCase()};
				});

			$$`<div class="ve-flex-v-center mr-1">${$btnFilter}${$disp}${$ptExisting}</div>`.appendTo($row);
		});

		$$`<div class="py-1 ve-flex-v-center">
			${$row}
		</div>`.appendTo($stgGroup);

		return $ptsExisting;
	}

	_pGetFilterChoice ({prop, fromFilter}) {
		switch (prop) {
			case "armorProficiencies":
			case "weaponProficiencies": {
				const modalFilterItems = new ModalFilterItemsFvtt({
					filterExpression: fromFilter,
					namespace: "Charactermancer_OtherProficiencySelect.items",
					isRadio: true,
				});
				return modalFilterItems.pGetUserSelection({filterExpression: fromFilter});
			}

			default: throw new Error(`Filter choices for "${prop}" are unimplemented!`);
		}
	}

	isNoChoice () { return this.constructor._isNoChoice({available: this._available, isAlreadyMapped: true}); }

	_getFormData () {
		let isFormComplete = true;
		const out = {};

		const selProfs = this._available[this._state.ixSet];

				(selProfs.static || []).forEach(({prop, name}) => MiscUtil.set(out, prop, name, Charactermancer_OtherProficiencySelect._PROFICIENT));
		
				(selProfs.choose || []).forEach(({count, from, groups, fromFilter, prop}, ixChoose) => {
			if (fromFilter) {
				[...new Array(count)].forEach((_, ixCount) => {
					const {propState} = this._getPropsChooseFromFilter({ixChoose, ixCount});

					if (!this._state[propState]) return isFormComplete = false;

					const {prop, name} = this._state[propState];
					MiscUtil.set(out, prop, name, Charactermancer_OtherProficiencySelect._PROFICIENT);
				});

				return;
			}

			const {propState} = this._getPropsChooseFrom({ixChoose});

			const ixs = ComponentUiUtil.getMetaWrpMultipleChoice_getSelectedIxs(this, propState);
			ixs.map(ix => from[ix]).forEach(({prop, name}) => MiscUtil.set(out, prop, name, Charactermancer_OtherProficiencySelect._PROFICIENT));

			if (!this._state[ComponentUiUtil.getMetaWrpMultipleChoice_getPropIsAcceptable(propState)]) isFormComplete = false;
		});
		
		return {
			isFormComplete,
			data: out,
		};
	}

	pGetFormData () { return this._getFormData(); }

	_getDefaultState () {
		return {
			ixSet: 0,
		};
	}

	static _getExistingProficiencies ({existingProficienciesSetFvtt, vetToFvttProfs, allProfsVet}) {
		const {existingProficienciesFvttSet, existingProficienciesFvttSetCustom} = this._getExistingFvttProficiencySetsMeta(existingProficienciesSetFvtt);

		const existing = {};

		Object.entries(vetToFvttProfs)
			.filter(([_, fvtt]) => existingProficienciesFvttSet.has(fvtt))
			.forEach(([vet, fvtt]) => {
				existing[vet] = Charactermancer_OtherProficiencySelect._PROFICIENT;
				existingProficienciesFvttSet.delete(fvtt);
			});

		allProfsVet.forEach(vet => {
			if (existingProficienciesFvttSet.has(vet)) {
				existing[vet] = Charactermancer_OtherProficiencySelect._PROFICIENT;
				existingProficienciesFvttSet.delete(vet);
			} else if (existingProficienciesFvttSetCustom.has(vet)) {
				existing[vet] = Charactermancer_OtherProficiencySelect._PROFICIENT;
				existingProficienciesFvttSetCustom.delete(vet);
			}
		});

		if (existingProficienciesFvttSet.size || existingProficienciesFvttSetCustom.size) {
			existing.other = existingProficienciesFvttSet.size + existingProficienciesFvttSetCustom.size;
		}

		return existing;
	}

	static _getExistingSkillToolProficiencies ({existingProficienciesSetFvtt, mapAbvToFull}) {
				const existing = {};

		Object.entries(existingProficienciesSetFvtt || {})
			.forEach(([abv, data]) => {
				if (!data.value) return;
				existing[mapAbvToFull[abv]] = data.value;
			});

		return existing;
	}

	static _getExistingSavingThrowProficiencies (existingFvtt) {
				const existing = {};

		Object.entries(existingFvtt?.savingThrowProficiencies || {})
			.forEach(([ab, data]) => {
				if (!data.proficient) return;
				existing[ab] = data.proficient;
			});

		return existing;
	}
}
Charactermancer_OtherProficiencySelect._PROFICIENT = 1;
Charactermancer_OtherProficiencySelect._PROP_GROUPS = {
	"skillProficiencies": {
		propTrackerPulse: "pulseSkillProficiencies",
	},
	"toolProficiencies": {
		propTrackerPulse: "pulseToolProficiencies",
	},
	"languageProficiencies": {
		propTrackerPulse: "pulseLanguageProficiencies",
	},
	"weaponProficiencies": {
		propTrackerPulse: "pulseWeaponProficiencies",
	},
	"armorProficiencies": {
		propTrackerPulse: "pulseArmorProficiencies",
	},
	"savingThrowProficiencies": {
		propTrackerPulse: "pulseSavingThrowProficiencies",
	},
};

Charactermancer_OtherProficiencySelect._MAPPED_IGNORE_KEYS = new Set([
	"choose",
	"any",
	"anySkill",
	"anyTool",
	"anyArtisansTool",
	"anyMusicalInstrument",
	"anyLanguage",
	"anyStandardLanguage",
	"anyWeapon",
	"anyArmor",
	"anySavingThrow",
]);

Charactermancer_OtherProficiencySelect._ALL_SKILLS = Object.keys(Parser.SKILL_TO_ATB_ABV).sort(SortUtil.ascSortLower);
Charactermancer_OtherProficiencySelect._ALL_TOOLS = [...UtilActors.TOOL_PROFICIENCIES];
Charactermancer_OtherProficiencySelect._ALL_TOOLS_ARTISANS = [...UtilActors.TOOL_PROFICIENCIES_ARTISANS];
Charactermancer_OtherProficiencySelect._ALL_TOOLS_MUSICAL_INSTRUMENTS = [...UtilActors.TOOL_PROFICIENCIES_MUSICAL_INSTRUMENTS];
Charactermancer_OtherProficiencySelect._ALL_LANGUAGES = Parser.LANGUAGES_ALL.map(it => it.toLowerCase());
Charactermancer_OtherProficiencySelect._ALL_SAVING_THROWS = [...Parser.ABIL_ABVS];

Charactermancer_OtherProficiencySelect._VALID_SKILLS = new Set([
	...Charactermancer_OtherProficiencySelect._ALL_SKILLS,
	"anySkill",
]);
Charactermancer_OtherProficiencySelect._VALID_TOOLS = new Set([
	...Charactermancer_OtherProficiencySelect._ALL_TOOLS,
	"anyTool",
	"anyArtisansTool",
	"anyMusicalInstrument",
]);
Charactermancer_OtherProficiencySelect._VALID_LANGUAGES = new Set([
	...Charactermancer_OtherProficiencySelect._ALL_LANGUAGES,
	"anyLanguage",
	"anyStandardLanguage",
]);
Charactermancer_OtherProficiencySelect._VALID_WEAPONS = new Set([
	...UtilActors.WEAPON_PROFICIENCIES,
	"anyWeapon",
]);
Charactermancer_OtherProficiencySelect._VALID_ARMORS = new Set([
	...UtilActors.ARMOR_PROFICIENCIES,
	"anyArmor",
]);
Charactermancer_OtherProficiencySelect._VALID_SAVING_THROWS = new Set([
	...Parser.ABIL_ABVS,
	"anySavingThrow",
]);

Charactermancer_OtherProficiencySelect._ALL_LANGUAGES_STANDARD__CHOICE_OBJECT = {
	from: [
		...Parser.LANGUAGES_STANDARD
			.map(it => ({
				name: it.toLowerCase(),
				prop: "languageProficiencies",
				group: "languagesStandard",
			})),
		...Parser.LANGUAGES_EXOTIC
			.map(it => ({
				name: it.toLowerCase(),
				prop: "languageProficiencies",
				group: "languagesExotic",
			})),
		...Parser.LANGUAGES_SECRET
			.map(it => ({
				name: it.toLowerCase(),
				prop: "languageProficiencies",
				group: "languagesSecret",
			})),
	],
	groups: {
		languagesStandard: {
			name: "Standard Languages",
		},
		languagesExotic: {
			name: "Exotic Languages",
			hint: "With your DM's permission, you can choose an exotic language.",
		},
		languagesSecret: {
			name: "Secret Languages",
			hint: "With your DM's permission, you can choose a secret language.",
		},
	},
};

class Charactermancer_ImmResVulnSelect extends BaseComponent {
			static async pGetUserInput (opts) {
		opts = opts || {};

		if (!opts.available) return {isFormComplete: true, data: {}};

		const comp = new this({
			...opts,
			existing: this.getExisting(opts.existingFvtt),
			existingFvtt: opts.existingFvtt,
		});
		if (comp.isNoChoice()) return comp.pGetFormData();

		return UtilApplications.pGetImportCompApplicationFormData({comp, isAutoResize: true});
	}

		static getExisting () { throw new TypeError(`Unimplemented!`); }

	static isNoChoice (available) {
		let cntChoices = 0;
		UtilDataConverter.WALKER_READONLY_GENERIC.walk(available, {object: (obj) => { if (obj.choose) cntChoices++; }});
		return cntChoices === 0;
	}
	
		constructor (opts) {
		opts = opts || {};
		super();

		this._existing = opts.existing;
		this._available = opts.available;
		this._prop = opts.prop;
		this._modalTitle = opts.modalTitle;
		this._titlePlural = opts.titlePlural;
		this._titleSingle = opts.titleSingle;

		this._lastChoiceMeta = null;

		Object.assign(this.__state.readonly_selectedValues, this._getOutputObject());
	}

	get modalTitle () { return this._modalTitle; }

	render ($wrp) {
		this._lastChoiceMeta = {isActive: true, children: []};
		this._render_recurse($wrp, MiscUtil.copy(this._available), this._lastChoiceMeta, false);
	}

	_render_recurse ($wrp, arr, outMeta, isChoices) {
		const arrStrings = arr
			.filter(it => typeof it === "string")
			.sort(SortUtil.ascSortLower);

		if (!isChoices) {
						const staticValues = arrStrings
				.map(it => {
					outMeta.children.push({isActive: true, value: it});
					return it.toTitleCase();
				});
			$wrp.append(`<div>${staticValues.join(", ")}</div>`);
		} else {
			arrStrings
				.forEach(it => {
					const $cb = $(`<input type="checkbox" class="ml-1 mr-2">`)
						.change(() => {
														if ($cb.prop("checked")) {
								const numChecked = outMeta.children.filter(it => it.isChoosable && it.isActive()).length;
								if (numChecked > outMeta.count) {
									const toDeActive = outMeta.lastChecked || outMeta.children.filter(it => it.isChoosable).last();
									toDeActive.setActive(false);
								}
								outMeta.lastChecked = node;
							} else {
								if (outMeta.lastChecked === node) outMeta.lastChecked = null;
							}

							this._state.readonly_selectedValues = this._getOutputObject();
						});

					const node = {
						isActive: () => $cb.prop("checked") ? it : null,
						value: it,
						isChoosable: true,
						setActive: (val) => $cb.prop("checked", val),
					};
					outMeta.children.push(node);

					return $$`<label class="py-1 stripe-even ve-flex-v-center">
						${$cb}
						<span>${it.toTitleCase()}</span>
					</label>`.appendTo($wrp);
				});
		}

		arr
			.filter(it => typeof it !== "string")
			.forEach((it, i) => {
				if (!it.choose) throw new Error(`Unhandled immune/resist/vulnerability properties "${Object.keys(it).join(", ")}"`);

				if (isChoices) {
										
										const $btnSetActive = $(`<button class="btn btn-primary btn-5et btn-xs">Set Group Active</button>`)
						.click(() => {
							outMeta.children.forEach(it => it.isActive = false);
							nxtMeta.isActive = true;
							this._state.readonly_selectedValues = this._getOutputObject();
						});

					const nxtMeta = {isActive: false, children: []};

					const $wrpChoice = $(`<div class="ve-flex-col my-1"></div>`);
					this._render_recurse($wrpChoice, it.choose.from, nxtMeta, true);

					$$`<div class="ve-flex-col pl-2 stripe-even">
						<div class="ve-flex-v-center my-1">${$btnSetActive}</div>
						${$wrpChoice}
					</div>`;

					return;
				}

				const count = it.choose.count || 1;
				const nxtMeta = {isActive: true, children: [], count, lastChecked: null};
				outMeta.children.push(nxtMeta);

				const $wrpChoice = $(`<div class="ve-flex-col py-1 pt-0">
					${arrStrings.length || i > 0 ? `<hr class="hr-2 hr--dotted">` : ""}
					<div class="py-1">Choose ${count} ${count === 1 ? this._titleSingle : this._titlePlural}:</div>
				</div>`).appendTo($wrp);
				this._render_recurse($wrpChoice, it.choose.from, nxtMeta, true);
			});
	}

	isNoChoice () { return this.constructor.isNoChoice(this._available); }

	_getOutputSet () {
		const outSet = new Set(this._existing[this._prop] || []); 
		if (this._lastChoiceMeta) this._getOutputSet_recurse(outSet, this._lastChoiceMeta);
		else UtilDataConverter.WALKER_READONLY_GENERIC.walk(this._available, {string: (str) => { outSet.add(str); }});

		return outSet;
	}

	_getOutputSet_recurse (outSet, node) {
		if (!node.isActive) return;
		const isNodeActive = node.isActive === true || node.isActive();
		if (!isNodeActive) return;

		if (node.value) outSet.add(node.value);
		if (node.children) node.children.forEach(it => this._getOutputSet_recurse(outSet, it));
	}

	_getOutputObject () {
		return [...this._getOutputSet()].sort(SortUtil.ascSortLower).mergeMap(it => ({[it]: true}));
	}

	pGetFormData () {
		let isFormComplete = true;

		return {
			isFormComplete,
			data: {
				[this._prop]: MiscUtil.copy(this._state.readonly_selectedValues),
			},
		};
	}

	_getDefaultState () {
		return {
			readonly_selectedValues: {},
		};
	}
}

class Charactermancer_DamageImmunitySelect extends Charactermancer_ImmResVulnSelect {
		static getExisting (existingFvtt) {
		return MiscUtil.copy([existingFvtt?.immune?.value || []]);
	}
	
	constructor (opts) {
		opts = opts || {};
		super({
			...opts,
			modalTitle: `Damage Immunities`,
			titlePlural: `Damage Immunities`,
			titleSingle: `Damage Immunity`,
			prop: "immune",
		});
	}
}

class Charactermancer_DamageResistanceSelect extends Charactermancer_ImmResVulnSelect {
		static getExisting (existingFvtt) {
		return MiscUtil.copy([existingFvtt?.resist?.value || []]);
	}
	
	constructor (opts) {
		opts = opts || {};
		super({
			...opts,
			modalTitle: `Damage Resistances`,
			titlePlural: `Damage Resistances`,
			titleSingle: `Damage Resistance`,
			prop: "resist",
		});
	}
}

class Charactermancer_DamageVulnerabilitySelect extends Charactermancer_ImmResVulnSelect {
		static getExisting (existingFvtt) {
		return MiscUtil.copy([existingFvtt?.vulnerable?.value || []]);
	}
	
	constructor (opts) {
		opts = opts || {};
		super({
			...opts,
			modalTitle: `Damage Vulnerabilities`,
			titlePlural: `Damage Vulnerabilities`,
			titleSingle: `Damage Vulnerability`,
			prop: "vulnerable",
		});
	}
}

class Charactermancer_ConditionImmunitySelect extends Charactermancer_ImmResVulnSelect {
		static getExisting (existingFvtt) {
		return [existingFvtt?.conditionImmune?.value || []].map(it => it === "diseased" ? "disease" : it);
	}
	
	constructor (opts) {
		opts = opts || {};
		super({
			...opts,
			modalTitle: `Condition Immunities`,
			titlePlural: `Condition Immunities`,
			titleSingle: `Condition Immunity`,
			prop: "conditionImmune",
		});
	}
}

class Charactermancer_ExpertiseSelect extends Charactermancer_SkillSaveProficiencySelect {
		static getExisting (existingFvtt) {
		const existingSkills = Object.entries(Charactermancer_OtherProficiencySelect.getExisting({skillProficiencies: existingFvtt.skillProficiencies})?.skillProficiencies || {})
			.filter(([, profLevel]) => Number(profLevel) === 2)
			.mergeMap(([prof, profLevel]) => ({[prof]: profLevel}));

		const existingTools = Object.entries(Charactermancer_OtherProficiencySelect.getExisting({skillProficiencies: existingFvtt.toolProficiencies})?.toolProficiencies || {})
			.filter(([, profLevel]) => Number(profLevel) === 2)
			.mergeMap(([prof, profLevel]) => ({[prof]: profLevel}));

				return {...existingSkills, ...existingTools};
	}

	static getExistingFvttFromActor (actor) {
		return {
			skillProficiencies: MiscUtil.get(actor, "_source", "system", "skills"),
			toolProficiencies: MiscUtil.get(actor, "_source", "system", "tools"),
		};
	}

	static isNoChoice (available) {
		if (!available?.length) return true; 		return available.length === 1
			&& !available[0].choose
			&& !available[0].anyProficientSkill
			&& !available[0].anyProficientTool;
	}
	
		constructor (opts) {
		super({
			...opts,
			propGroup: new Charactermancer_ProficiencySelect.PropGroup({
				prop: "expertise",
				propTrackerPulse: "pulseExpertise",
				propTracker: "expertise",
			}),
			modalTitle: "Expertise",
			title: "Expertise",
			titlePlural: "Expertise",
		});
	}

	_getStaticDisplay (key, {isPlainText = false} = {}) {
		if (isPlainText) return key.toTitleCase();

		if (Parser.SKILL_TO_ATB_ABV[key]) return Renderer.get().render(`{@skill ${key.toTitleCase()}}`);
				return key.toTitleCase();
	}

	_getNonStaticDisplay (key, value, {isPlainText = false} = {}) {
		switch (key) {
			case "anyProficientSkill": return `Choose ${value || 1} existing skill ${value > 1 ? "proficiencies" : "proficiency"}`;
			case "anyProficientTool": return `Choose ${value || 1} existing tool ${value > 1 ? "proficiencies" : "proficiency"}`;
			default: return super._getNonStaticDisplay(key, value, {isPlainText});
		}
	}

	_getStaticKeys_all () {
		return this._available
			.map(profSet => this._getStaticKeys_profSet({profSet}))
			.flat()
			.unique();
	}

	_getStaticKeys_profSet ({profSet = null} = {}) {
		profSet = profSet || this._available[this._state.ixSet];
		return Object.keys(profSet).filter(it => this._isStaticKey(it));
	}

	_isStaticKey (key) {
		return !["anyProficientSkill", "anyProficientTool"].includes(key);
	}

	_isSkillKey (key) {
		return key === "anyProficientSkill" || Object.keys(Parser.SKILL_TO_ATB_ABV).includes(key);
	}

	_hk_ixSet_renderPts (profSet) {
		this._lastMeta = {
			cleanup: () => {
				this._lastMeta._fnsCleanup.forEach(fn => fn());
			},
			_fnsCleanup: [],
		};

		const $ptsExistingStatic = Object.keys(profSet).some(it => this._isStaticKey(it)) ? this._render_renderPtStatic(this._$stgGroup, profSet) : null;
		let needsHr = $ptsExistingStatic != null;

		if (needsHr && profSet.anyProficientSkill) (needsHr = false) || this._$stgGroup.append(`<hr class="hr-2 hr--dotted">`);
		const $ptsExistingChooseAnyProficientSkill = profSet.anyProficientSkill ? this._render_renderPtChooseAnyProficientSkill(this._$stgGroup, profSet) : null;
		needsHr = needsHr || $ptsExistingChooseAnyProficientSkill != null;

		if (needsHr && profSet.anyProficientTool) (needsHr = false) || this._$stgGroup.append(`<hr class="hr-2 hr--dotted">`);
		const $ptsExistingChooseAnyProficientTool = profSet.anyProficientTool ? this._render_renderPtChooseAnyProficientTool(this._$stgGroup, profSet) : null;

		this._hkUpdateExisting = () => this._hk_updatePtsExisting($ptsExistingStatic, $ptsExistingChooseAnyProficientSkill, $ptsExistingChooseAnyProficientTool);
	}

	_getProps (prop, ix) {
		return {
			propAnyProficientSkill: `${prop}_ix_skill_${ix}`,
			propAnyProficientTool: `${prop}_ix_tool_${ix}`,
		};
	}

	_render_$getPtExisting () {
		return $(`<div class="ve-small veapp__msg-warning inline-block ml-1 no-shrink" title="Expertise from Another Source">(<i class="fas fa-fw ${UtilActors.PROF_TO_ICON_CLASS[2]}"></i>)</div>`);
	}

	_render_renderPtStatic ($stgGroup, profSet) {
		const $ptsExisting = [];

		const profList = this._getStaticKeys_profSet()
			.filter(key => profSet[key]);

		const $wrps = profList
			.map((it, i) => {
				const $ptExisting = this._render_$getPtExisting();

				$ptsExisting.push({
					prof: it,
					$ptExisting,
				});

				const isNotLast = i < profList.length - 1;
				return $$`<div class="inline-block ${isNotLast ? "mr-1" : ""}">${this._getStaticDisplay(it)}${$ptExisting}${isNotLast ? `,` : ""}</div>`;
			});

		$$`<div class="block">
			${$wrps}
		</div>`.appendTo($stgGroup);

		return $ptsExisting;
	}

	_render_renderPtChooseAnyProficientSkill ($stgGroup, profSet) {
		return this._render_renderPtChooseAnyProficient({
			$stgGroup,
			profSet,
			propProfSet: "anyProficientSkill",
			propIxProps: "propAnyProficientSkill",
			fnGetValues: this._getAvailableSkills.bind(this),
			propPulse: "pulseSkillProficiencies",
			titleRow: "Existing Skill",
		});
	}

	_render_renderPtChooseAnyProficientTool ($stgGroup, profSet) {
		return this._render_renderPtChooseAnyProficient({
			$stgGroup,
			profSet,
			propProfSet: "anyProficientTool",
			propIxProps: "propAnyProficientTool",
			fnGetValues: this._getAvailableTools.bind(this),
			propPulse: "pulseToolProficiencies",
			titleRow: "Existing Tool",
		});
	}

	_render_renderPtChooseAnyProficient (
		{
			$stgGroup,
			profSet,
			propProfSet,
			propIxProps,
			fnGetValues,
			propPulse,
			titleRow,
		},
	) {
		const numChoices = Number(profSet[propProfSet] || 1);

		const $wrp = $(`<div class="ve-flex-col"></div>`).appendTo($stgGroup);

		const $ptsExisting = [];

		for (let i = 0; i < numChoices; ++i) {
			const ixProps = this._getProps(propProfSet, i);

			const selMeta = ComponentUiUtil.$getSelEnum(
				this,
				ixProps[propIxProps],
				{
					values: fnGetValues(),
					isAllowNull: true,
					asMeta: true,
					fnDisplay: it => it.toTitleCase(),
				},
			);
			this._lastMeta._fnsCleanup.push(selMeta.unhook);

			const $ptExisting = this._render_$getPtExisting();
			$ptsExisting.push({
				prop: ixProps[propIxProps],
				$ptExisting,
			});

			const hk = () => selMeta.setValues(fnGetValues(), {isResetOnMissing: true});
			if (this._featureSourceTracker) {
				this._featureSourceTracker.addHook(this, propPulse, hk);
				this._lastMeta._fnsCleanup.push(() => this._featureSourceTracker.removeHook(this, propPulse, hk));

								const hkSetTrackerInfo = () => this._doSetTrackerState();
				this._addHookBase(ixProps[propIxProps], hkSetTrackerInfo);
				this._lastMeta._fnsCleanup.push(() => this._removeHookBase(ixProps[propIxProps], hkSetTrackerInfo));
							}
			hk();

			this._lastMeta._fnsCleanup.push(() => delete this._state[ixProps[propIxProps]]);

			$$`<div class="ve-flex-v-center ${i ? "mt-2" : ""}">
					<div class="mr-2 no-wrap">${titleRow}:</div>
					${selMeta.$sel}
					${$ptExisting}
				</div>`
				.appendTo($wrp);
		}

		return $ptsExisting;
	}

	_getAvailableSkills () {
		return this._getAvailableByType({
			propExistingFvtt: "skillProficiencies",
			propFeatureTracker: "skillProficiencies",
		});
	}

	_getAvailableTools () {
		return this._getAvailableByType({
			propExistingFvtt: "toolProficiencies",
			propFeatureTracker: "toolProficiencies",
		});
	}

	_getAvailableByType (
		{
			propExistingFvtt,
			propFeatureTracker,
		},
	) {
				const existingAnyProfLevel = Charactermancer_OtherProficiencySelect.getExisting({
			[propExistingFvtt]: this._existingFvtt[propExistingFvtt],
		});

				const out = new Set(Object.entries(existingAnyProfLevel[propExistingFvtt])
			.filter(([, profLevel]) => profLevel >= 1)
			.map(([prof]) => prof));

				if (this._featureSourceTracker) {
			(this._featureSourceTracker.getStatesForKey(propFeatureTracker, {ignore: this}) || [])
				.forEach(otherState => {
					Object.entries(otherState)
						.filter(([, isAvailable]) => isAvailable)
						.forEach(([prof]) => out.add(prof));
				});
		}

		return [...out].sort(SortUtil.ascSortLower);
	}

	_hk_updatePtsExisting ($ptsExistingStatic, $ptsExistingChooseAnyProficientSkill, $ptsExistingChooseAnyProficientTool) {
		const otherStates = this._featureSourceTracker ? this._featureSourceTracker.getStatesForKey(this._propGroup.propTracker, {ignore: this}) : null;

		const ptsExistingMetas = [$ptsExistingStatic, $ptsExistingChooseAnyProficientSkill, $ptsExistingChooseAnyProficientTool]
			.filter(Boolean)
			.flat();

		ptsExistingMetas.forEach(ptExistingMeta => {
			const prof = ptExistingMeta.prof ?? this._state[ptExistingMeta.prop];

			if (prof == null) {
				ptExistingMeta.$ptExisting.hideVe();
				return;
			}

						let maxExisting = this._existing?.[prof] || 0;

						if (otherStates) otherStates.forEach(otherState => maxExisting = Math.max(maxExisting, otherState[prof] || 0));

			ptExistingMeta.$ptExisting.toggleVe(maxExisting === 2);
		});
	}

	_doSetTrackerState () {
		const formData = this._getFormData();
		this._featureSourceTracker.setState(this, {
			[this._propGroup.propTracker]: formData.data?.[this._propGroup.prop],
			"skillProficiencies": formData.data?.skillProficiencies,
			"toolProficiencies": formData.data?.toolProficiencies,
		});
	}

	_getFormData () {
		const outSkills = {};
		const outTools = {};
		const outExpertise = {};

		let isFormComplete = true;

		const profSet = this._available[this._state.ixSet];

		Object.entries(profSet)
			.forEach(([k, v]) => {
				if (k === "anyProficientSkill" || k === "anyProficientTool") {
					const numChoices = Number(v || 1);
					for (let i = 0; i < numChoices; ++i) {
						const {propAnyProficientSkill, propAnyProficientTool} = this._getProps(k, i);
						const prop = this._isSkillKey(k) ? propAnyProficientSkill : propAnyProficientTool;
						const chosenProf = this._state[prop];
						if (chosenProf == null) {
							isFormComplete = false;
							continue;
						}
						(this._isSkillKey(k) ? outSkills : outTools)[chosenProf] = outExpertise[chosenProf] = 2;
					}
					return;
				}

				(this._isSkillKey(k) ? outSkills : outTools)[k] = outExpertise[k] = 2;
			});

		return {
			isFormComplete,
			data: {
				skillProficiencies: outSkills,
				toolProficiencies: outTools,
				expertise: outExpertise,
			},
		};
	}

	pGetFormData () { return this._getFormData(); }

	_getDefaultState () {
		return {
			ixSet: 0,
		};
	}
}

class Charactermancer_ResourceSelect extends BaseComponent {
	static isNoChoice () { return true; }

	static async pApplyFormDataToActor (actor, formData) {
		if (!formData?.data?.length) return;

		const itemLookup = {};
		actor.items.contents.forEach(it => itemLookup[it.name.toLowerCase().trim()] = it);

		const toCreate = [];

		formData.data.forEach(res => {
			const existing = itemLookup[res.name.toLowerCase().trim()];

			if (existing) return;

			toCreate.push({
				name: res.name,
				type: "feat",
				data: this._getItemDataData({res}),
				img: this._getItemDataImg({res}),
			});
		});

		await UtilDocuments.pCreateEmbeddedDocuments(
			actor,
			toCreate,
			{
				propData: "items",
				ClsEmbed: Item,
			},
		);
	}

	render () {  }

	static _getItemDataData ({res}) {
		switch (res.type) {
			case "dicePool": return this._getItemDataData_dicePool({res});
			default: throw new Error(`Unhandled resource type "${res.type}"`);
		}
	}

	static _getItemDataData_dicePool ({res}) {
		return {
			actionType: "other",
			formula: `${res.number}d${res.faces}`,
			activation: {
				type: "special",
			},
			uses: {
				value: 0,
				max: res.count,
				per: UtilDataConverter.getFvttUsesPer(res.recharge),
			},
		};
	}

	static _IMAGES = {
		"Superiority Die": `icons/sundries/gaming/dice-runed-brown.webp`,
		"Psionic Energy Die": "icons/sundries/gaming/dice-pair-white-green.webp",
	};
	static _getItemDataImg ({res}) {
		if (this._IMAGES[res.name]) return this._IMAGES[res.name];

		if (/\b(?:dice|die)\b/i.test((res.name || ""))) return `icons/sundries/gaming/dice-runed-brown.webp`;

		return `modules/${SharedConsts.MODULE_ID}/media/icon/mighty-force.svg`;
	}

	constructor ({resources, className, classSource, subclassShortName, subclassSource}) {
		super();
		this._resources = resources;
		this._className = className;
		this._classSource = classSource;
		this._subclassShortName = subclassShortName;
		this._subclassSource = subclassSource;

		this._mappedResources = this._getMappedResources();
	}

	_getMappedResources () {
		return (this._resources || [])
			.map(res => {
				switch (res.type) {
					case "dicePool": return this._getMappedResources_dicePool({res});
					default: throw new Error(`Unhandled resource type "${res.type}"`);
				}
			});
	}

	_getMappedResources_dicePool ({res}) {
		res = MiscUtil.copy(res);
		res.number = this._getMappedResources_getReplacedVars(res.number || 1);
		res.faces = this._getMappedResources_getReplacedVars(res.faces);
		res.count = this._getMappedResources_getReplacedVars(res.count || 1);
		return res;
	}

	_getMappedResources_getReplacedVars (val) {
		return `${val}`
			.replace(/\bPB\b/g, "@attributes.prof")
			.replace(/<\$(?<variable>[^$]+)\$>/g, (...m) => {
				switch (m.last().variable) {
					case "level": return `@classes.${Parser.stringToSlug(this._className || "unknown")}.levels`;
					default: return m[0];
				}
			})
		;
	}

	pGetFormData () {
		return {
			isFormComplete: true,
			data: MiscUtil.copy(this._mappedResources || []),
		};
	}
}

class Charactermancer_SenseSelect extends BaseComponent {
	static isNoChoice () { return true; }

	static getExistingFvttFromActor (actor) {
		return {
			senses: MiscUtil.get(actor, "_source", "system", "attributes", "senses"),
		};
	}

	static getExisting (existingFvtt) {
				return Object.keys(CONFIG.DND5E.senses)
			.filter(sense => existingFvtt?.senses[sense])
			.mergeMap(sense => ({[sense]: existingFvtt?.senses[sense]}));
	}

	render () {  }

	constructor ({senses, existing, existingFvtt}) {
		super();
		this._senses = senses;
				this._existing = existing;
		this._existingFvtt = existingFvtt;
			}

		static getFormDataFromRace (race) {
		return {
			isFormComplete: true,
			data: {
				darkvision: race.darkvision,
				blindsight: race.blindsight,
				truesight: race.truesight,
				tremorsense: race.tremorsense,
			},
		};
	}

	pGetFormData () {
		return {
			isFormComplete: true,
			data: MiscUtil.copy(this._senses[0] || {}),
		};
	}
}

class Charactermancer_FeatureOptionsSelect extends BaseComponent {
			static async pGetUserInput (opts) {
		const comp = new this({
			...opts,
						featureSourceTracker: opts.featureSourceTracker || new Charactermancer_FeatureSourceTracker(),
			isModal: true,
		});
		if (await comp.pIsNoChoice()) {
			comp.render($(document.createElement("div"))); 			return comp.pGetFormData();
		}

		return UtilApplications.pGetImportCompApplicationFormData({
			comp,
			width: 640,
			height: Util.getMaxWindowHeight(),
			isAutoResize: true,
		});
	}

	static async pDoApplyProficiencyFormDataToActorUpdate (actor, actorUpdate, formData) {
		const formDataData = formData.data;
		if (!formDataData) return;

		const {DataConverter} = await Promise.resolve().then(function () { return DataConverter$1; });

		actorUpdate.system = actorUpdate.system || {};

				for (const formData of formDataData.formDatasSkillToolLanguageProficiencies || []) {
			DataConverter.doApplySkillFormDataToActorUpdate({
				existingProfsActor: MiscUtil.get(actor, "_source", "system", "skills"),
				formData: formData,
				actorData: actorUpdate.system,
			});

			DataConverter.doApplyLanguageProficienciesFormDataToActorUpdate({
				existingProfsActor: MiscUtil.get(actor, "_source", "system", "traits", "languages"),
				formData,
				actorData: actorUpdate.system,
			});

			DataConverter.doApplyToolProficienciesFormDataToActorUpdate({
				existingProfsActor: MiscUtil.get(actor, "_source", "system", "tools"),
				formData,
				actorData: actorUpdate.system,
			});
		}

		for (const formData of formDataData.formDatasSkillProficiencies || []) {
			DataConverter.doApplySkillFormDataToActorUpdate({
				existingProfsActor: MiscUtil.get(actor, "_source", "system", "skills"),
				formData: formData,
				actorData: actorUpdate.system,
			});
		}

		for (const formData of formDataData.formDatasLanguageProficiencies || []) {
			DataConverter.doApplyLanguageProficienciesFormDataToActorUpdate({
				existingProfsActor: MiscUtil.get(actor, "_source", "system", "traits", "languages"),
				formData,
				actorData: actorUpdate.system,
			});
		}

		for (const formData of formDataData.formDatasToolProficiencies || []) {
			DataConverter.doApplyToolProficienciesFormDataToActorUpdate({
				existingProfsActor: MiscUtil.get(actor, "_source", "system", "tools"),
				formData,
				actorData: actorUpdate.system,
			});
		}

		for (const formData of formDataData.formDatasWeaponProficiencies || []) {
			DataConverter.doApplyWeaponProficienciesFormDataToActorUpdate({
				existingProfsActor: MiscUtil.get(actor, "_source", "system", "traits", "weaponProf"),
				formData,
				actorData: actorUpdate.system,
			});
		}

		for (const formData of formDataData.formDatasArmorProficiencies || []) {
			DataConverter.doApplyArmorProficienciesFormDataToActorUpdate({
				existingProfsActor: MiscUtil.get(actor, "_source", "system", "traits", "armorProf"),
				formData,
				actorData: actorUpdate.system,
			});
		}

		for (const formData of formDataData.formDatasSavingThrowProficiencies || []) {
			DataConverter.doApplySavingThrowProficienciesFormDataToActorUpdate({
				existingProfsActor: MiscUtil.get(actor, "_source", "system", "abilities"),
				formData,
				actorData: actorUpdate.system,
			});
		}

		for (const formData of formDataData.formDatasDamageImmunities || []) {
			DataConverter.doApplyDamageImmunityFormDataToActorUpdate({
				existingProfsActor: MiscUtil.get(actor, "_source", "system", "traits", "di"),
				formData,
				actorData: actorUpdate.system,
			});
		}

		for (const formData of formDataData.formDatasDamageResistances || []) {
			DataConverter.doApplyDamageResistanceFormDataToActorUpdate({
				existingProfsActor: MiscUtil.get(actor, "_source", "system", "traits", "dr"),
				formData,
				actorData: actorUpdate.system,
			});
		}

		for (const formData of formDataData.formDatasDamageVulnerabilities || []) {
			DataConverter.doApplyDamageVulnerabilityFormDataToActorUpdate({
				existingProfsActor: MiscUtil.get(actor, "_source", "system", "traits", "dv"),
				formData,
				actorData: actorUpdate.system,
			});
		}

		for (const formData of formDataData.formDatasConditionImmunities || []) {
			DataConverter.doApplyConditionImmunityFormDataToActorUpdate({
				existingProfsActor: MiscUtil.get(actor, "_source", "system", "traits", "ci"),
				formData,
				actorData: actorUpdate.system,
			});
		}

		for (const formData of formDataData.formDatasExpertise || []) {
			DataConverter.doApplyExpertiseFormDataToActorUpdate({
				existingProfsActor: {
					skillProficiencies: MiscUtil.get(actor, "_source", "system", "skills"),
					toolProficiencies: MiscUtil.get(actor, "_source", "system", "tools"),
				},
				formData: formData,
				actorData: actorUpdate.system,
			});
		}
			}

	static async pDoApplyResourcesFormDataToActor ({actor, formData}) {
		const formDataData = formData.data;

		if (!formDataData?.formDatasResources?.length) return;

		for (const formDataResources of formDataData.formDatasResources) {
			await Charactermancer_ResourceSelect.pApplyFormDataToActor(
				actor,
				formDataResources,
			);
		}
	}

	static async pDoApplySensesFormDataToActor ({actor, actorUpdate, formData, configGroup}) {
		const formDataData = formData.data;
		if (!formDataData || !formDataData.formDatasSenses?.length) return;

		const {DataConverter} = await Promise.resolve().then(function () { return DataConverter$1; });

		actorUpdate.prototypeToken = actorUpdate.prototypeToken || {};
		actorUpdate.system = actorUpdate.system || {};

		for (const formData of formDataData.formDatasSenses || []) {
			DataConverter.doApplySensesFormDataToActorUpdate({
				existingSensesActor: MiscUtil.get(actor, "_source", "system", "attributes", "senses"),
				existingTokenActor: MiscUtil.get(actor, "_source", "prototypeToken"),
				formData: formData,
				actorData: actorUpdate.system,
				actorToken: actorUpdate.prototypeToken,
				configGroup,
			});
		}
	}

	static async pDoApplyAdditionalSpellsFormDataToActor ({actor, formData, abilityAbv, parentAbilityAbv = null, taskRunner = null}) {
		const formDataData = formData.data;
		if (!formDataData || !formDataData.formDatasAdditionalSpells?.length) return;

		for (const formDataAdditionalSpells of formDataData.formDatasAdditionalSpells) {
			await Charactermancer_AdditionalSpellsSelect.pApplyFormDataToActor(
				actor,
				formDataAdditionalSpells,
				{
					taskRunner,
					abilityAbv,
					parentAbilityAbv,
				},
			);
		}
	}
	
		constructor (opts) {
		super();

		this._optionsSet = opts.optionsSet;
		this._actor = opts.actor;
		this._level = opts.level;
		this._existingFeatureChecker = opts.existingFeatureChecker;
		this._featureSourceTracker = opts.featureSourceTracker;
		this._isModal = !!opts.isModal;
		this._modalFilterSpells = opts.modalFilterSpells;
		this._isSkipCharactermancerHandled = !!opts.isSkipCharactermancerHandled;
		this._isSkipRenderingFirstFeatureTitle = !!opts.isSkipRenderingFirstFeatureTitle;

				if (this._isOptions()) {
			this._optionsSet.sort((a, b) => SortUtil.ascSortLower(a.entity.name, b.entity.name) || SortUtil.ascSortLower(Parser.sourceJsonToAbv(a.entity.source), Parser.sourceJsonToAbv(b.entity.source)));
		}

		this._lastMeta = null;
		this._lastSubMetas = [];

						this._subCompsSkillToolLanguageProficiencies = [];
		this._subCompsSkillProficiencies = [];
		this._subCompsLanguageProficiencies = [];
		this._subCompsToolProficiencies = [];
		this._subCompsWeaponProficiencies = [];
		this._subCompsArmorProficiencies = [];
		this._subCompsSavingThrowProficiencies = [];
		this._subCompsDamageImmunities = [];
		this._subCompsDamageResistances = [];
		this._subCompsDamageVulnerabilities = [];
		this._subCompsConditionImmunities = [];
		this._subCompsExpertise = [];
		this._subCompsResources = [];
		this._subCompsSenses = [];
		this._subCompsAdditionalSpells = [];

				this._prevSubCompsSkillToolLanguageProficiencies = null;
		this._prevSubCompsSkillProficiencies = null;
		this._prevSubCompsLanguageProficiencies = null;
		this._prevSubCompsToolProficiencies = null;
		this._prevSubCompsWeaponProficiencies = null;
		this._prevSubCompsArmorProficiencies = null;
		this._prevSubCompsSavingThrowProficiencies = null;
		this._prevSubCompsDamageImmunities = [];
		this._prevSubCompsDamageResistances = [];
		this._prevSubCompsDamageVulnerabilities = [];
		this._prevSubCompsConditionImmunities = [];
		this._prevSubCompsExpertise = [];
		this._prevSubCompsResources = [];
		this._prevSubCompsSenses = null;
		this._prevSubCompsAdditionalSpells = null;
			}

	get optionSet_ () { return this._optionsSet; }

		_isOptions () {
		return !!(this._optionsSet[0] && this._optionsSet[0].optionsMeta);
	}

	unregisterFeatureSourceTracking () {
		if (this._featureSourceTracker) this._featureSourceTracker.unregister(this);
		this._unregisterSubComps();
	}

	async _pIsSubChoiceForceDisplay (selectedLoadeds) {
		const isSubChoice_sideDataChooseSystem = await this._pHasChoiceInSideData_chooseSystem(selectedLoadeds);
		const isSubChoice_sideDataChooseFlags = await this._pHasChoiceInSideData_chooseFlags(selectedLoadeds);
		const isForceDisplay_entryDataSkillToolLanguageProficiencies = await this._pIsForceDisplay_skillToolLanguageProficiencies(selectedLoadeds);
		const isForceDisplay_entryDataSkillProficiencies = await this._pIsForceDisplay_skillProficiencies(selectedLoadeds);
		const isForceDisplay_entryDataLanguageProficiencies = await this._pIsForceDisplay_languageProficiencies(selectedLoadeds);
		const isForceDisplay_entryDataToolProficiencies = await this._pIsForceDisplay_toolProficiencies(selectedLoadeds);
		const isForceDisplay_entryDataWeaponProficiencies = await this._pIsForceDisplay_weaponProficiencies(selectedLoadeds);
		const isForceDisplay_entryDataArmorProficiencies = await this._pIsForceDisplay_armorProficiencies(selectedLoadeds);
		const isForceDisplay_entryDataSavingThrowProficiencies = await this._pIsForceDisplay_savingThrowProficiencies(selectedLoadeds);
		const isForceDisplay_entryDataDamageImmunities = await this._pIsForceDisplay_damageImmunities(selectedLoadeds);
		const isForceDisplay_entryDataDamageResistances = await this._pIsForceDisplay_damageResistances(selectedLoadeds);
		const isForceDisplay_entryDataDamageVulnerabilities = await this._pIsForceDisplay_damageVulnerabilities(selectedLoadeds);
		const isForceDisplay_entryDataConditionImmunities = await this._pIsForceDisplay_conditionImmunities(selectedLoadeds);
		const isForceDisplay_entryDataExpertise = await this._pIsForceDisplay_expertise(selectedLoadeds);
		const isForceDisplay_entryDataResources = await this._pIsForceDisplay_resources(selectedLoadeds);
		const isForceDisplay_entryDataSenses = await this._pIsForceDisplay_senses(selectedLoadeds);
		const isForceDisplay_entryDataAdditionalSpells = await this._pIsForceDisplay_additionalSpells(selectedLoadeds);

		return [
			isSubChoice_sideDataChooseSystem,
			isSubChoice_sideDataChooseFlags,
			isForceDisplay_entryDataSkillToolLanguageProficiencies,
			isForceDisplay_entryDataSkillProficiencies,
			isForceDisplay_entryDataLanguageProficiencies,
			isForceDisplay_entryDataToolProficiencies,
			isForceDisplay_entryDataWeaponProficiencies,
			isForceDisplay_entryDataArmorProficiencies,
			isForceDisplay_entryDataSavingThrowProficiencies,
			isForceDisplay_entryDataDamageImmunities,
			isForceDisplay_entryDataDamageResistances,
			isForceDisplay_entryDataDamageVulnerabilities,
			isForceDisplay_entryDataConditionImmunities,
			isForceDisplay_entryDataExpertise,
			isForceDisplay_entryDataResources,
			isForceDisplay_entryDataSenses,
			isForceDisplay_entryDataAdditionalSpells,
		].some(Boolean);
	}

	async _pIsSubChoiceAvailable (selectedLoadeds) {
		const isSubChoice_sideDataChooseSystem = await this._pHasChoiceInSideData_chooseSystem(selectedLoadeds);
		const isSubChoice_sideDataChooseFlags = await this._pHasChoiceInSideData_chooseFlags(selectedLoadeds);
		const isAvailable_entryDataSkillToolLanguageProficiencies = await this._pIsAvailable_skillToolLanguageProficiencies(selectedLoadeds);
		const isAvailable_entryDataSkillProficiencies = await this._pIsAvailable_skillProficiencies(selectedLoadeds);
		const isAvailable_entryDataLanguageProficiencies = await this._pIsAvailable_languageProficiencies(selectedLoadeds);
		const isAvailable_entryDataToolProficiencies = await this._pIsAvailable_toolProficiencies(selectedLoadeds);
		const isAvailable_entryDataWeaponProficiencies = await this._pIsAvailable_weaponProficiencies(selectedLoadeds);
		const isAvailable_entryDataArmorProficiencies = await this._pIsAvailable_armorProficiencies(selectedLoadeds);
		const isAvailable_entryDataSavingThrowProficiencies = await this._pIsAvailable_savingThrowProficiencies(selectedLoadeds);
		const isAvailable_entryDataDamageImmunities = await this._pIsAvailable_damageImmunities(selectedLoadeds);
		const isAvailable_entryDataDamageResistances = await this._pIsAvailable_damageResistances(selectedLoadeds);
		const isAvailable_entryDataDamageVulnerabilities = await this._pIsAvailable_damageVulnerabilities(selectedLoadeds);
		const isAvailable_entryDataConditionImmunities = await this._pIsAvailable_conditionImmunities(selectedLoadeds);
		const isAvailable_entryDataExpertise = await this._pIsAvailable_expertise(selectedLoadeds);
		const isAvailable_entryDataResources = await this._pIsAvailable_resources(selectedLoadeds);
		const isAvailable_entryDataSenses = await this._pIsAvailable_senses(selectedLoadeds);
		const isAvailable_entryDataAdditionalSpells = await this._pIsAvailable_additionalSpells(selectedLoadeds);

		return [
			isSubChoice_sideDataChooseSystem,
			isSubChoice_sideDataChooseFlags,
			isAvailable_entryDataSkillToolLanguageProficiencies,
			isAvailable_entryDataSkillProficiencies,
			isAvailable_entryDataLanguageProficiencies,
			isAvailable_entryDataToolProficiencies,
			isAvailable_entryDataWeaponProficiencies,
			isAvailable_entryDataArmorProficiencies,
			isAvailable_entryDataSavingThrowProficiencies,
			isAvailable_entryDataDamageImmunities,
			isAvailable_entryDataDamageResistances,
			isAvailable_entryDataDamageVulnerabilities,
			isAvailable_entryDataConditionImmunities,
			isAvailable_entryDataExpertise,
			isAvailable_entryDataResources,
			isAvailable_entryDataSenses,
			isAvailable_entryDataAdditionalSpells,
		].some(Boolean);
	}

	static _ENTITY_TYPE_TO_SIDE_DATA_META = {
		"backgroundFeature": {file: "DataConverterBackgroundFeature", dataConverter: "DataConverterBackgroundFeature"},
		"charoption": {file: "DataConverterCharCreationOption", dataConverter: "DataConverterCharCreationOption"},
		"classFeature": {file: "DataConverterClassSubclassFeature", dataConverter: "DataConverterClassSubclassFeature"},
		"subclassFeature": {file: "DataConverterClassSubclassFeature", dataConverter: "DataConverterClassSubclassFeature"},
		"feat": {file: "DataConverterFeat", dataConverter: "DataConverterFeat"},
		"optionalfeature": {file: "DataConverterOptionalfeature", dataConverter: "DataConverterOptionalfeature"},
		"raceFeature": {file: "DataConverterRaceFeature", dataConverter: "DataConverterRaceFeature"},
		"reward": {file: "DataConverterReward", dataConverter: "DataConverterReward"},
		"vehicleUpgrade": {file: "DataConverterVehicleUpgrade", dataConverter: "DataConverterVehicleUpgrade"},
	};

	async _pHasChoiceInSideData_chooseSystem (optionsSet) {
		return this._pHasChoiceInSideData_chooseSystemOrFlags({optionsSet, propChoose: "chooseSystem"});
	}

	async _pHasChoiceInSideData_chooseFlags (optionsSet) {
		return this._pHasChoiceInSideData_chooseSystemOrFlags({optionsSet, propChoose: "chooseFlags"});
	}

	async _pHasChoiceInSideData_chooseSystemOrFlags ({optionsSet, propChoose}) {
		optionsSet = optionsSet || this._optionsSet;

		if (this._isSkipCharactermancerHandled) return false;

		for (const loaded of optionsSet) {
			const {entity, type} = loaded;

			const sideDataConverterMeta = this.constructor._ENTITY_TYPE_TO_SIDE_DATA_META[type];

			if (sideDataConverterMeta) {
								if (!sideDataConverterMeta.file.startsWith("DataConverter")) throw new Error(`Expected side-data import to start with "DataLoader"!`);
				const mod = await __variableDynamicImportRuntime2__(`./DataConverter${sideDataConverterMeta.file.replace(/^DataConverter/, "")}.js`);
				
				const sideData = await mod[sideDataConverterMeta.dataConverter].pGetSideLoadedMatch(entity);
				if (sideData?.[propChoose]?.length) return true;
			}
		}
		return false;
	}

	async _pHasSubChoice_entryData_skillToolLanguageProficiencies (optionsSet) {
		return this._pHasEntryData_prop({
			optionsSet,
			CompClass: Charactermancer_OtherProficiencySelect,
			prop: "skillToolLanguageProficiencies",
			isRequireChoice: true,
		});
	}

	async _pHasSubChoice_entryData_skillProficiencies (optionsSet) {
		return this._pHasEntryData_prop({
			optionsSet,
			CompClass: Charactermancer_OtherProficiencySelect,
			prop: "skillProficiencies",
			isRequireChoice: true,
			fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedSkillProficiencies.bind(Charactermancer_OtherProficiencySelect),
		});
	}

	async _pHasSubChoice_entryData_languageProficiencies (optionsSet) {
		return this._pHasEntryData_prop({
			optionsSet,
			CompClass: Charactermancer_OtherProficiencySelect,
			prop: "languageProficiencies",
			isRequireChoice: true,
			fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedLanguageProficiencies.bind(Charactermancer_OtherProficiencySelect),
		});
	}

	async _pHasSubChoice_entryData_toolProficiencies (optionsSet) {
		return this._pHasEntryData_prop({
			optionsSet,
			CompClass: Charactermancer_OtherProficiencySelect,
			prop: "toolProficiencies",
			isRequireChoice: true,
			fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedToolProficiencies.bind(Charactermancer_OtherProficiencySelect),
		});
	}

	async _pHasSubChoice_entryData_weaponProficiencies (optionsSet) {
		return this._pHasEntryData_prop({
			optionsSet,
			CompClass: Charactermancer_OtherProficiencySelect,
			prop: "weaponProficiencies",
			isRequireChoice: true,
			fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedWeaponProficiencies.bind(Charactermancer_OtherProficiencySelect),
		});
	}

	async _pHasSubChoice_entryData_armorProficiencies (optionsSet) {
		return this._pHasEntryData_prop({
			optionsSet,
			CompClass: Charactermancer_OtherProficiencySelect,
			prop: "armorProficiencies",
			isRequireChoice: true,
			fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedArmorProficiencies.bind(Charactermancer_OtherProficiencySelect),
		});
	}

	async _pHasSubChoice_entryData_savingThrowProficiencies (optionsSet) {
		return this._pHasEntryData_prop({
			optionsSet,
			CompClass: Charactermancer_OtherProficiencySelect,
			prop: "savingThrowProficiencies",
			isRequireChoice: true,
			fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedSavingThrowProficiencies.bind(Charactermancer_OtherProficiencySelect),
		});
	}

	async _pHasSubChoice_damageImmunities (optionsSet) {
		return this._pHasEntryData_prop({
			optionsSet,
			CompClass: Charactermancer_DamageImmunitySelect,
			prop: "immune",
			isRequireChoice: true,
		});
	}

	async _pHasSubChoice_damageResistances (optionsSet) {
		return this._pHasEntryData_prop({
			optionsSet,
			CompClass: Charactermancer_DamageResistanceSelect,
			prop: "resist",
			isRequireChoice: true,
		});
	}

	async _pHasSubChoice_damageVulnerabilities (optionsSet) {
		return this._pHasEntryData_prop({
			optionsSet,
			CompClass: Charactermancer_DamageVulnerabilitySelect,
			prop: "vulnerable",
			isRequireChoice: true,
		});
	}

	async _pHasSubChoice_conditionImmunities (optionsSet) {
		return this._pHasEntryData_prop({
			optionsSet,
			CompClass: Charactermancer_ConditionImmunitySelect,
			prop: "conditionImmune",
			isRequireChoice: true,
		});
	}

	async _pHasSubChoice_expertise (optionsSet) {
		return this._pHasEntryData_prop({
			optionsSet,
			CompClass: Charactermancer_ExpertiseSelect,
			prop: "expertise",
			isRequireChoice: true,
		});
	}

	async _pHasSubChoice_resources (optionsSet) {
		return this._pHasEntryData_prop({
			optionsSet,
			CompClass: Charactermancer_ResourceSelect,
			prop: "resources",
			isRequireChoice: true,
		});
	}

	async _pHasSubChoice_entryData_senses (optionsSet) {
		return this._pHasEntryData_prop({
			optionsSet,
			CompClass: Charactermancer_SenseSelect,
			prop: "senses",
			isRequireChoice: true,
		});
	}

	async _pHasSubChoice_entryData_additionalSpells (optionsSet) {
		return this._pHasEntryData_prop({
			optionsSet,
			CompClass: Charactermancer_AdditionalSpellsSelect,
			prop: "additionalSpells",
			isRequireChoice: true,
		});
	}

	async _pHasEntryData_prop ({optionsSet, CompClass, prop, isRequireChoice, fnGetMappedProficiencies}) {
		optionsSet = optionsSet || this._optionsSet;

		if (this._isSkipCharactermancerHandled) return false;

		for (const loaded of optionsSet) {
			const {entity} = loaded;

			let proficiencies = entity?.[prop] || entity?.entryData?.[prop];
			if (proficiencies) {
				if (fnGetMappedProficiencies) proficiencies = fnGetMappedProficiencies(proficiencies);

				if (!isRequireChoice) return true;
				else {
					const isNoChoice = CompClass.isNoChoice(proficiencies);
					if (!isNoChoice) return true;
				}
			}
		}
		return false;
	}

	async _pIsForceDisplay_skillToolLanguageProficiencies (optionsSet) {
		return this._pHasEntryData_prop({
			optionsSet,
			CompClass: Charactermancer_OtherProficiencySelect,
			prop: "skillToolLanguageProficiencies",
		});
	}

	async _pIsForceDisplay_skillProficiencies (optionsSet) {
		return this._pHasEntryData_prop({
			optionsSet,
			CompClass: Charactermancer_OtherProficiencySelect,
			prop: "skillProficiencies",
			fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedSkillProficiencies.bind(Charactermancer_OtherProficiencySelect),
		});
	}

	async _pIsForceDisplay_languageProficiencies (optionsSet) {
		return this._pHasEntryData_prop({
			optionsSet,
			CompClass: Charactermancer_OtherProficiencySelect,
			prop: "languageProficiencies",
			fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedLanguageProficiencies.bind(Charactermancer_OtherProficiencySelect),
		});
	}

	async _pIsForceDisplay_toolProficiencies (optionsSet) {
		return this._pHasEntryData_prop({
			optionsSet,
			CompClass: Charactermancer_OtherProficiencySelect,
			prop: "toolProficiencies",
			fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedToolProficiencies.bind(Charactermancer_OtherProficiencySelect),
		});
	}

	async _pIsForceDisplay_weaponProficiencies (optionsSet) {
		return this._pHasEntryData_prop({
			optionsSet,
			CompClass: Charactermancer_OtherProficiencySelect,
			prop: "weaponProficiencies",
			fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedWeaponProficiencies.bind(Charactermancer_OtherProficiencySelect),
		});
	}

	async _pIsForceDisplay_armorProficiencies (optionsSet) {
		return this._pHasEntryData_prop({
			optionsSet,
			CompClass: Charactermancer_OtherProficiencySelect,
			prop: "armorProficiencies",
			fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedArmorProficiencies.bind(Charactermancer_OtherProficiencySelect),
		});
	}

	async _pIsForceDisplay_savingThrowProficiencies (optionsSet) {
		return this._pHasEntryData_prop({
			optionsSet,
			CompClass: Charactermancer_OtherProficiencySelect,
			prop: "savingThrowProficiencies",
			fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedSavingThrowProficiencies.bind(Charactermancer_OtherProficiencySelect),
		});
	}

	async _pIsForceDisplay_damageImmunities (optionsSet) {
		return this._pHasEntryData_prop({
			optionsSet,
			CompClass: Charactermancer_ConditionImmunitySelect,
			prop: "immune",
		});
	}

	async _pIsForceDisplay_damageResistances (optionsSet) {
		return this._pHasEntryData_prop({
			optionsSet,
			CompClass: Charactermancer_DamageResistanceSelect,
			prop: "resist",
		});
	}

	async _pIsForceDisplay_damageVulnerabilities (optionsSet) {
		return this._pHasEntryData_prop({
			optionsSet,
			CompClass: Charactermancer_DamageVulnerabilitySelect,
			prop: "vulnerable",
		});
	}

	async _pIsForceDisplay_conditionImmunities (optionsSet) {
		return this._pHasEntryData_prop({
			optionsSet,
			CompClass: Charactermancer_ConditionImmunitySelect,
			prop: "conditionImmune",
		});
	}

	async _pIsForceDisplay_expertise (optionsSet) {
		return this._pHasEntryData_prop({
			optionsSet,
			CompClass: Charactermancer_ExpertiseSelect,
			prop: "expertise",
		});
	}

	async _pIsForceDisplay_resources (optionsSet) {
		return this._pHasEntryData_prop({
			optionsSet,
			CompClass: Charactermancer_ResourceSelect,
			prop: "resources",
			isRequireChoice: true, 		});
	}

	_pIsForceDisplay_senses (optionsSet) {
		return this._pHasEntryData_prop({
			optionsSet,
			CompClass: Charactermancer_SenseSelect,
			prop: "senses",
			isRequireChoice: true, 		});
	}

	_pIsForceDisplay_additionalSpells (optionsSet) {
		return this._pHasEntryData_prop({
			optionsSet,
			CompClass: Charactermancer_AdditionalSpellsSelect,
			prop: "additionalSpells",
		});
	}

	_pIsAvailable_skillToolLanguageProficiencies (...args) { return this._pIsForceDisplay_skillToolLanguageProficiencies(...args); }
	_pIsAvailable_skillProficiencies (...args) { return this._pIsForceDisplay_skillProficiencies(...args); }
	_pIsAvailable_languageProficiencies (...args) { return this._pIsForceDisplay_languageProficiencies(...args); }
	_pIsAvailable_toolProficiencies (...args) { return this._pIsForceDisplay_toolProficiencies(...args); }
	_pIsAvailable_weaponProficiencies (...args) { return this._pIsForceDisplay_weaponProficiencies(...args); }
	_pIsAvailable_armorProficiencies (...args) { return this._pIsForceDisplay_armorProficiencies(...args); }
	_pIsAvailable_savingThrowProficiencies (...args) { return this._pIsForceDisplay_savingThrowProficiencies(...args); }
	_pIsAvailable_damageImmunities (...args) { return this._pIsForceDisplay_damageImmunities(...args); }
	_pIsAvailable_damageResistances (...args) { return this._pIsForceDisplay_damageResistances(...args); }
	_pIsAvailable_damageVulnerabilities (...args) { return this._pIsForceDisplay_damageVulnerabilities(...args); }
	_pIsAvailable_conditionImmunities (...args) { return this._pIsForceDisplay_conditionImmunities(...args); }
	_pIsAvailable_expertise (...args) { return this._pIsForceDisplay_expertise(...args); }

	async _pIsAvailable_resources (optionsSet) {
		return this._pHasEntryData_prop({
			optionsSet,
			CompClass: Charactermancer_ResourceSelect,
			prop: "resources",
		});
	}

	_pIsAvailable_senses (optionsSet) {
		return this._pHasEntryData_prop({
			optionsSet,
			CompClass: Charactermancer_SenseSelect,
			prop: "senses",
		});
	}

	_pIsAvailable_additionalSpells (...args) { return this._pIsForceDisplay_additionalSpells(...args); }

	async _pGetLoadedsSideDataRaws (optionsSet) {
		optionsSet = optionsSet || this._optionsSet;
		const out = [];
		for (const loaded of optionsSet) {
			const {entity, type} = loaded;

			switch (type) {
				case "classFeature":
				case "subclassFeature": {
					const {DataConverterClassSubclassFeature} = await Promise.resolve().then(function () { return DataConverterClassSubclassFeature$1; });
					const sideData = await DataConverterClassSubclassFeature.pGetSideLoadedMatch(entity);
					out.push(sideData);
					break;
				}

				
				default: {
					out.push(null);
					break;
				}
			}
		}
		return out;
	}

	async pIsNoChoice () {
		if (this._isOptions()) return false;
		if (await this._pHasChoiceInSideData_chooseSystem()) return false;
		if (await this._pHasChoiceInSideData_chooseFlags()) return false;
		if (await this._pHasSubChoice_entryData_skillToolLanguageProficiencies()) return false;
		if (await this._pHasSubChoice_entryData_skillProficiencies()) return false;
		if (await this._pHasSubChoice_entryData_languageProficiencies()) return false;
		if (await this._pHasSubChoice_entryData_toolProficiencies()) return false;
		if (await this._pHasSubChoice_entryData_weaponProficiencies()) return false;
		if (await this._pHasSubChoice_entryData_armorProficiencies()) return false;
		if (await this._pHasSubChoice_entryData_savingThrowProficiencies()) return false;
		if (await this._pHasSubChoice_damageImmunities()) return false;
		if (await this._pHasSubChoice_damageResistances()) return false;
		if (await this._pHasSubChoice_damageVulnerabilities()) return false;
		if (await this._pHasSubChoice_conditionImmunities()) return false;
		if (await this._pHasSubChoice_expertise()) return false;
		if (await this._pHasSubChoice_resources()) return false;
		if (await this._pHasSubChoice_entryData_senses()) return false;
		if (await this._pHasSubChoice_entryData_additionalSpells()) return false;
		return true;
	}

	async pIsForceDisplay () {
		if (await this._pIsForceDisplay_skillToolLanguageProficiencies()) return true;
		if (await this._pIsForceDisplay_skillProficiencies()) return true;
		if (await this._pIsForceDisplay_languageProficiencies()) return true;
		if (await this._pIsForceDisplay_toolProficiencies()) return true;
		if (await this._pIsForceDisplay_weaponProficiencies()) return true;
		if (await this._pIsForceDisplay_armorProficiencies()) return true;
		if (await this._pIsForceDisplay_savingThrowProficiencies()) return true;
		if (await this._pIsForceDisplay_damageImmunities()) return true;
		if (await this._pIsForceDisplay_damageResistances()) return true;
		if (await this._pIsForceDisplay_damageVulnerabilities()) return true;
		if (await this._pIsForceDisplay_conditionImmunities()) return true;
		if (await this._pIsForceDisplay_expertise()) return true;
		if (await this._pIsForceDisplay_resources()) return true;
		if (await this._pIsForceDisplay_senses()) return true;
		if (await this._pIsForceDisplay_additionalSpells()) return true;
		return false;
	}

	async pIsAvailable () {
		if (await this._pIsAvailable_skillToolLanguageProficiencies()) return true;
		if (await this._pIsAvailable_skillProficiencies()) return true;
		if (await this._pIsAvailable_languageProficiencies()) return true;
		if (await this._pIsAvailable_toolProficiencies()) return true;
		if (await this._pIsAvailable_weaponProficiencies()) return true;
		if (await this._pIsAvailable_armorProficiencies()) return true;
		if (await this._pIsAvailable_savingThrowProficiencies()) return true;
		if (await this._pIsAvailable_damageImmunities()) return true;
		if (await this._pIsAvailable_damageResistances()) return true;
		if (await this._pIsAvailable_damageVulnerabilities()) return true;
		if (await this._pIsAvailable_conditionImmunities()) return true;
		if (await this._pIsAvailable_expertise()) return true;
		if (await this._pIsAvailable_resources()) return true;
		if (await this._pIsAvailable_senses()) return true;
		if (await this._pIsAvailable_additionalSpells()) return true;
		return false;
	}

	_getTrackableFeatures () {
		const ixs = ComponentUiUtil.getMetaWrpMultipleChoice_getSelectedIxs(this, "ixsChosen");
		const selectedLoadeds = ixs.map(ix => this._optionsSet[ix]);

		return selectedLoadeds.map(({page, hash}) => ({page, hash}));
	}

		findAndCopyStateFrom (comps) {
		if (!comps?.length) return;

		const comp = comps.find(it => CollectionUtil.deepEquals(it.optionSet_, this.optionSet_));
		if (comp) {
			this._proxyAssignSimple("state", MiscUtil.copy(comp.__state));
			this._prevSubCompsSkillToolLanguageProficiencies = comp._subCompsSkillToolLanguageProficiencies;
			this._prevSubCompsSkillProficiencies = comp._subCompsSkillProficiencies;
			this._prevSubCompsLanguageProficiencies = comp._subCompsLanguageProficiencies;
			this._prevSubCompsToolProficiencies = comp._subCompsToolProficiencies;
			this._prevSubCompsWeaponProficiencies = comp._subCompsWeaponProficiencies;
			this._prevSubCompsArmorProficiencies = comp._subCompsArmorProficiencies;
			this._prevSubCompsSavingThrowProficiencies = comp._subCompsSavingThrowProficiencies;
			this._prevSubCompsDamageImmunities = comp._prevSubCompsDamageImmunities;
			this._prevSubCompsDamageResistances = comp._prevSubCompsDamageResistances;
			this._prevSubCompsDamageVulnerabilities = comp._prevSubCompsDamageVulnerabilities;
			this._prevSubCompsConditionImmunities = comp._prevSubCompsConditionImmunities;
			this._prevSubCompsExpertise = comp._prevSubCompsExpertise;
			this._prevSubCompsResources = comp._prevSubCompsResources;
			this._prevSubCompsSenses = comp._subCompsSenses;
			this._prevSubCompsAdditionalSpells = comp._subCompsAdditionalSpells;
		}
	}

	async pGetFormData () {
				if (await this.pIsNoChoice() && !await this.pIsAvailable()) {
						const sideDatas = await this._pGetLoadedsSideDataRaws();
			const cpyOptionsSet = MiscUtil.copy(this._optionsSet);
			cpyOptionsSet.forEach((loaded, i) => {
				const sideData = sideDatas[i];
				if (!sideData) return;

				const {entity} = loaded;
				if (sideData.data) entity.foundryAdditionalSystem = MiscUtil.copy(sideData.data);
				if (sideData.flags) entity.foundryAdditionalFlags = MiscUtil.copy(sideData.flags);
				if (sideData.effects) entity.effectsRaw = MiscUtil.copy(sideData.effects);
			});

			return {
				isFormComplete: true,
				data: {
					features: cpyOptionsSet,
				},
			};
		}

		await this._pGate("ixsChosen");

		const selectedLoadeds = this._getSelectedLoadeds();

		const sideDatas = await this._pGetLoadedsSideDataRaws(selectedLoadeds);
		const cpySelectedLoadeds = MiscUtil.copy(selectedLoadeds);

		const outSkillToolLanguageProficiencies = [];
		const outSkillProficiencies = [];
		const outLanguageProficiencies = [];
		const outToolProficiencies = [];
		const outWeaponProficiencies = [];
		const outArmorProficiencies = [];
		const outSavingThrowProficiencies = [];
		const outDamageImmunities = [];
		const outDamageResistances = [];
		const outDamageVulnerabilities = [];
		const outConditionImmunities = [];
		const outExpertise = [];
		const outResources = [];
		const outSenses = [];
		const outAdditionalSpells = [];

		for (let i = 0; i < cpySelectedLoadeds.length; ++i) {
			const loaded = cpySelectedLoadeds[i];

			const sideData = sideDatas[i];

			const {entity} = loaded;

			if (sideData) {
				if (sideData.data) entity.foundryAdditionalSystem = MiscUtil.copy(sideData.data);
				if (sideData.flags) entity.foundryAdditionalFlags = MiscUtil.copy(sideData.flags);
				if (sideData.effects) entity.effectsRaw = MiscUtil.copy(sideData.effects);

				const selectedChooseDataSystem = this._getFormData_getChooseSystemOrChooseFlags({
					sideData,
					ixCpySelectedLoaded: i,
					propChoose: "chooseSystem",
					propCompProp: "propChooseSystem",
				});
				if (selectedChooseDataSystem) {
					entity.foundryAdditionalSystem = entity.foundryAdditionalSystem || {};
					Object.assign(entity.foundryAdditionalSystem, MiscUtil.copy(selectedChooseDataSystem.system));
				}

				const selectedChooseDataFlags = this._getFormData_getChooseSystemOrChooseFlags({
					sideData,
					ixCpySelectedLoaded: i,
					propChoose: "chooseFlags",
					propCompProp: "propChooseFlags",
				});
				if (selectedChooseDataFlags) {
					entity.foundryAdditionalFlags = entity.foundryAdditionalFlags || {};
					foundry.utils.mergeObject(entity.foundryAdditionalFlags, MiscUtil.copy(selectedChooseDataFlags.flags));
				}
			}

			if (!this._isSkipCharactermancerHandled) {
								if ((entity?.skillToolLanguageProficiencies || entity?.entryData?.skillToolLanguageProficiencies) && this._subCompsSkillToolLanguageProficiencies[i]) {
					const formData = await this._subCompsSkillToolLanguageProficiencies[i].pGetFormData();
					outSkillToolLanguageProficiencies.push(formData);
				}
				
								if ((entity?.skillProficiencies || entity?.entryData?.skillProficiencies) && this._subCompsSkillProficiencies[i]) {
					const formData = await this._subCompsSkillProficiencies[i].pGetFormData();
					outSkillProficiencies.push(formData);
				}
				
								if ((entity?.languageProficiencies || entity?.entryData?.languageProficiencies) && this._subCompsLanguageProficiencies[i]) {
					const formData = await this._subCompsLanguageProficiencies[i].pGetFormData();
					outLanguageProficiencies.push(formData);
				}
				
								if ((entity?.toolProficiencies || entity?.entryData?.toolProficiencies) && this._subCompsToolProficiencies[i]) {
					const formData = await this._subCompsToolProficiencies[i].pGetFormData();
					outToolProficiencies.push(formData);
				}
				
								if ((entity?.weaponProficiencies || entity?.entryData?.weaponProficiencies) && this._subCompsWeaponProficiencies[i]) {
					const formData = await this._subCompsWeaponProficiencies[i].pGetFormData();
					outWeaponProficiencies.push(formData);
				}
				
								if ((entity?.armorProficiencies || entity?.entryData?.armorProficiencies) && this._subCompsArmorProficiencies[i]) {
					const formData = await this._subCompsArmorProficiencies[i].pGetFormData();
					outArmorProficiencies.push(formData);
				}
				
								if ((entity?.savingThrowProficiencies || entity?.entryData?.savingThrowProficiencies) && this._subCompsSavingThrowProficiencies[i]) {
					const formData = await this._subCompsSavingThrowProficiencies[i].pGetFormData();
					outSavingThrowProficiencies.push(formData);
				}
				
								if ((entity?.immune || entity?.entryData?.immune) && this._subCompsDamageImmunities[i]) {
					const formData = await this._subCompsDamageImmunities[i].pGetFormData();
					outDamageImmunities.push(formData);
				}
				
								if ((entity?.resist || entity?.entryData?.resist) && this._subCompsDamageResistances[i]) {
					const formData = await this._subCompsDamageResistances[i].pGetFormData();
					outDamageResistances.push(formData);
				}
				
								if ((entity?.vulnerable || entity?.entryData?.vulnerable) && this._subCompsDamageVulnerabilities[i]) {
					const formData = await this._subCompsDamageVulnerabilities[i].pGetFormData();
					outDamageVulnerabilities.push(formData);
				}
				
								if ((entity?.conditionImmune || entity?.entryData?.conditionImmune) && this._subCompsConditionImmunities[i]) {
					const formData = await this._subCompsConditionImmunities[i].pGetFormData();
					outConditionImmunities.push(formData);
				}
				
								if ((entity?.expertise || entity?.entryData?.expertise) && this._subCompsExpertise[i]) {
					const formData = await this._subCompsExpertise[i].pGetFormData();
					outExpertise.push(formData);
				}
				
								if ((entity?.resources || entity?.entryData?.resources) && this._subCompsResources[i]) {
					const formData = await this._subCompsResources[i].pGetFormData();
					outResources.push(formData);
				}
				
								if ((entity?.senses || entity?.entryData?.senses) && this._subCompsSenses[i]) {
					const formData = await this._subCompsSenses[i].pGetFormData();
					outSenses.push(formData);
				}
				
								if ((entity?.additionalSpells || entity?.entryData?.additionalSpells) && this._subCompsAdditionalSpells[i]) {
					const formData = await this._subCompsAdditionalSpells[i].pGetFormData();
					outAdditionalSpells.push(formData);
				}
							}
		}

		return {
			isFormComplete: true,
			data: {
				features: cpySelectedLoadeds,
				formDatasSkillToolLanguageProficiencies: outSkillToolLanguageProficiencies,
				formDatasSkillProficiencies: outSkillProficiencies,
				formDatasLanguageProficiencies: outLanguageProficiencies,
				formDatasToolProficiencies: outToolProficiencies,
				formDatasWeaponProficiencies: outWeaponProficiencies,
				formDatasArmorProficiencies: outArmorProficiencies,
				formDatasSavingThrowProficiencies: outSavingThrowProficiencies,
				formDatasDamageImmunities: outDamageImmunities,
				formDatasDamageResistances: outDamageResistances,
				formDatasDamageVulnerabilities: outDamageVulnerabilities,
				formDatasConditionImmunities: outConditionImmunities,
				formDatasExpertise: outExpertise,
				formDatasResources: outResources,
				formDatasSenses: outSenses,
				formDatasAdditionalSpells: outAdditionalSpells,
			},
		};
	}

	_getFormData_getChooseSystemOrChooseFlags ({sideData, ixCpySelectedLoaded, propChoose, propCompProp}) {
		if (!sideData[propChoose]) return null;

		const compProps = this._getProps(ixCpySelectedLoaded);

		const ixs = ComponentUiUtil.getMetaWrpMultipleChoice_getSelectedIxs(this, compProps[propCompProp]);
		const selectedChoose = ixs.map(ix => sideData[propChoose][ix]);

		if (!selectedChoose.length) return null;

				return selectedChoose[0];
	}

	_getOptionsNameAndCount () {
		const {name, count} = this._optionsSet[0].optionsMeta;
		const required = this._optionsSet.map((it, ix) => ({it, ix})).filter(({it}) => it.isRequiredOption).map(({ix}) => ix);
		const dispCount = count - required.length;

		return {name, count, dispCount, required};
	}

	get modalTitle () {
		if (!this._isOptions()) return null;

		const {dispCount, name} = this._getOptionsNameAndCount();
		return `Choose ${dispCount === 1 ? "" : `${dispCount} `}Option${dispCount === 1 ? "" : "s"}: ${name}${this._level != null ? ` (Level ${this._level})` : ""}`;
	}

	static _getLoadedTmpUid (loaded) { return `${loaded.page}__${loaded.hash}`; }

	_getSelectedLoadeds () {
		if (this._isOptions()) {
			const ixs = ComponentUiUtil.getMetaWrpMultipleChoice_getSelectedIxs(this, "ixsChosen");
			const {required} = this._getOptionsNameAndCount();
			return [...ixs, ...required].map(ix => this._optionsSet[ix]);
		} else {
			return this._optionsSet;
		}
	}

	render ($wrp) {
		const $stgSubChoiceData = $$`<div class="w-100 ve-flex-col mt-2"></div>`.hideVe();

		this._render_options();

		$$`<div class="ve-flex-col min-h-0 overflow-y-auto">
			${this._lastMeta?.$ele}
			${$stgSubChoiceData}
		</div>`.appendTo($wrp);

		this._addHookBase(
			ComponentUiUtil.getMetaWrpMultipleChoice_getPropPulse("ixsChosen"),
			() => this._render_pHkIxsChosen({$stgSubChoiceData}),
		);
		return this._render_pHkIxsChosen({$stgSubChoiceData});
	}

	async pRender ($wrp) {
		return this.render($wrp);
	}

	async _render_pHkIxsChosen ({$stgSubChoiceData}) {
		try {
			await this._pLock("ixsChosen");
			await this._render_pHkIxsChosen_({$stgSubChoiceData});
		} finally {
			this._unlock("ixsChosen");
		}
	}

	async _render_pHkIxsChosen_ ({$stgSubChoiceData}) {
				const {prefixSubComps} = this._getProps();
		Object.keys(this._state).filter(k => k.startsWith(prefixSubComps)).forEach(k => delete this._state[k]);

		const selectedLoadeds = this._getSelectedLoadeds();

		if (!selectedLoadeds.length) return this._render_noSubChoices({$stgSubChoiceData});

		const isSubChoiceForceDisplay = await this._pIsSubChoiceForceDisplay(selectedLoadeds);
		const isSubChoiceAvailable = await this._pIsSubChoiceAvailable(selectedLoadeds);
		if (!isSubChoiceForceDisplay && !isSubChoiceAvailable) return this._render_noSubChoices({$stgSubChoiceData});

		$stgSubChoiceData.empty();
		this._unregisterSubComps();

		const sideDataRaws = await this._pGetLoadedsSideDataRaws(selectedLoadeds);
		const ptrIsFirstSection = {_: true};

		for (let i = 0; i < selectedLoadeds.length; ++i) {
			const loaded = selectedLoadeds[i];

									if (!(await this._pIsSubChoiceForceDisplay([selectedLoadeds[i]]) || await this._pIsSubChoiceAvailable([selectedLoadeds[i]]))) continue;
			
			const isSubChoice_sideDataChooseSystem = await this._pHasChoiceInSideData_chooseSystem([selectedLoadeds[i]]);
			const isSubChoice_sideDataChooseFlags = await this._pHasChoiceInSideData_chooseFlags([selectedLoadeds[i]]);

			const isForceDisplay_entryDataSkillToolLanguageProficiencies = await this._pIsForceDisplay_skillToolLanguageProficiencies([selectedLoadeds[i]]);
			const isForceDisplay_entryDataSkillProficiencies = await this._pIsForceDisplay_skillProficiencies([selectedLoadeds[i]]);
			const isForceDisplay_entryDataLanguageProficiencies = await this._pIsForceDisplay_languageProficiencies([selectedLoadeds[i]]);
			const isForceDisplay_entryDataToolProficiencies = await this._pIsForceDisplay_toolProficiencies([selectedLoadeds[i]]);
			const isForceDisplay_entryDataWeaponProficiencies = await this._pIsForceDisplay_weaponProficiencies([selectedLoadeds[i]]);
			const isForceDisplay_entryDataArmorProficiencies = await this._pIsForceDisplay_armorProficiencies([selectedLoadeds[i]]);
			const isForceDisplay_entryDataSavingThrowProficiencies = await this._pIsForceDisplay_savingThrowProficiencies([selectedLoadeds[i]]);
			const isForceDisplay_entryDataDamageImmunities = await this._pIsForceDisplay_damageImmunities([selectedLoadeds[i]]);
			const isForceDisplay_entryDataDamageResistances = await this._pIsForceDisplay_damageResistances([selectedLoadeds[i]]);
			const isForceDisplay_entryDataDamageVulnerabilities = await this._pIsForceDisplay_damageVulnerabilities([selectedLoadeds[i]]);
			const isForceDisplay_entryDataConditionImmunities = await this._pIsForceDisplay_conditionImmunities([selectedLoadeds[i]]);
			const isForceDisplay_entryDataExpertise = await this._pIsForceDisplay_expertise([selectedLoadeds[i]]);
			const isForceDisplay_entryDataResources = await this._pIsForceDisplay_resources([selectedLoadeds[i]]);
			const isForceDisplay_entryDataSenses = await this._pIsForceDisplay_senses([selectedLoadeds[i]]);
			const isForceDisplay_entryDataAdditionalSpells = await this._pIsForceDisplay_additionalSpells([selectedLoadeds[i]]);

			const isAvailable_entryDataSkillToolLanguageProficiencies = await this._pIsAvailable_skillToolLanguageProficiencies([selectedLoadeds[i]]);
			const isAvailable_entryDataSkillProficiencies = await this._pIsAvailable_skillProficiencies([selectedLoadeds[i]]);
			const isAvailable_entryDataLanguageProficiencies = await this._pIsAvailable_languageProficiencies([selectedLoadeds[i]]);
			const isAvailable_entryDataToolProficiencies = await this._pIsAvailable_toolProficiencies([selectedLoadeds[i]]);
			const isAvailable_entryDataWeaponProficiencies = await this._pIsAvailable_weaponProficiencies([selectedLoadeds[i]]);
			const isAvailable_entryDataArmorProficiencies = await this._pIsAvailable_armorProficiencies([selectedLoadeds[i]]);
			const isAvailable_entryDataSavingThrowProficiencies = await this._pIsAvailable_savingThrowProficiencies([selectedLoadeds[i]]);
			const isAvailable_entryDataDamageImmunities = await this._pIsAvailable_damageImmunities([selectedLoadeds[i]]);
			const isAvailable_entryDataDamageResistances = await this._pIsAvailable_damageResistances([selectedLoadeds[i]]);
			const isAvailable_entryDataDamageVulnerabilities = await this._pIsAvailable_damageVulnerabilities([selectedLoadeds[i]]);
			const isAvailable_entryDataConditionImmunities = await this._pIsAvailable_conditionImmunities([selectedLoadeds[i]]);
			const isAvailable_entryDataExpertise = await this._pIsAvailable_expertise([selectedLoadeds[i]]);
			const isAvailable_entryDataResources = await this._pIsAvailable_resources([selectedLoadeds[i]]);
			const isAvailable_entryDataSenses = await this._pIsAvailable_senses([selectedLoadeds[i]]);
			const isAvailable_entryDataAdditionalSpells = await this._pIsAvailable_additionalSpells([selectedLoadeds[i]]);

			const {entity, type} = loaded;

			if (i !== 0 || !this._isSkipRenderingFirstFeatureTitle) $stgSubChoiceData.append(this._render_getSubCompTitle(entity));

			if (isSubChoice_sideDataChooseSystem) {
				const sideDataRaw = sideDataRaws[i];
				if (sideDataRaw?.chooseSystem) {
					ptrIsFirstSection._ = false;
					this._render_renderSubComp_chooseSystem(i, $stgSubChoiceData, entity, type, sideDataRaw);
				}
			}

			if (isSubChoice_sideDataChooseFlags) {
				const sideDataRaw = sideDataRaws[i];
				if (sideDataRaw?.chooseFlags) {
					ptrIsFirstSection._ = false;
					this._render_renderSubComp_chooseFlags(i, $stgSubChoiceData, entity, type, sideDataRaw);
				}
			}

						this._render_pHkIxsChosen_comp({
				ix: i,
				$stgSubChoiceData,
				selectedLoadeds,
				propSubComps: "_subCompsSkillToolLanguageProficiencies",
				propPrevSubComps: "_prevSubCompsSkillToolLanguageProficiencies",
				isAvailable: isAvailable_entryDataSkillToolLanguageProficiencies,
				isForceDisplay: isForceDisplay_entryDataSkillToolLanguageProficiencies,
				prop: "skillToolLanguageProficiencies",
				ptrIsFirstSection,
				CompClass: Charactermancer_OtherProficiencySelect,
				fnGetExistingFvtt: Charactermancer_OtherProficiencySelect.getExistingFvttFromActor.bind(Charactermancer_OtherProficiencySelect),
				fnSetComp: this._render_pHkIxsChosen_setCompOtherProficiencies.bind(this),
			});
			
						this._render_pHkIxsChosen_comp({
				ix: i,
				$stgSubChoiceData,
				selectedLoadeds,
				propSubComps: "_subCompsSkillProficiencies",
				propPrevSubComps: "_prevSubCompsSkillProficiencies",
				isAvailable: isAvailable_entryDataSkillProficiencies,
				isForceDisplay: isForceDisplay_entryDataSkillProficiencies,
				prop: "skillProficiencies",
				title: "Skill Proficiencies",
				ptrIsFirstSection,
				CompClass: Charactermancer_OtherProficiencySelect,
				propPathActorExistingProficiencies: ["system", "skills"],
				fnSetComp: this._render_pHkIxsChosen_setCompOtherProficiencies.bind(this),
				fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedSkillProficiencies.bind(Charactermancer_OtherProficiencySelect),
			});
			
						this._render_pHkIxsChosen_comp({
				ix: i,
				$stgSubChoiceData,
				selectedLoadeds,
				propSubComps: "_subCompsLanguageProficiencies",
				propPrevSubComps: "_prevSubCompsLanguageProficiencies",
				isAvailable: isAvailable_entryDataLanguageProficiencies,
				isForceDisplay: isForceDisplay_entryDataLanguageProficiencies,
				prop: "languageProficiencies",
				title: "Language Proficiencies",
				ptrIsFirstSection,
				CompClass: Charactermancer_OtherProficiencySelect,
				propPathActorExistingProficiencies: ["system", "traits", "languages"],
				fnSetComp: this._render_pHkIxsChosen_setCompOtherProficiencies.bind(this),
				fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedLanguageProficiencies.bind(Charactermancer_OtherProficiencySelect),
			});
			
						this._render_pHkIxsChosen_comp({
				ix: i,
				$stgSubChoiceData,
				selectedLoadeds,
				propSubComps: "_subCompsToolProficiencies",
				propPrevSubComps: "_prevSubCompsToolProficiencies",
				isAvailable: isAvailable_entryDataToolProficiencies,
				isForceDisplay: isForceDisplay_entryDataToolProficiencies,
				prop: "toolProficiencies",
				title: "Tool Proficiencies",
				ptrIsFirstSection,
				CompClass: Charactermancer_OtherProficiencySelect,
				propPathActorExistingProficiencies: ["system", "tools"],
				fnSetComp: this._render_pHkIxsChosen_setCompOtherProficiencies.bind(this),
				fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedToolProficiencies.bind(Charactermancer_OtherProficiencySelect),
			});
			
						this._render_pHkIxsChosen_comp({
				ix: i,
				$stgSubChoiceData,
				selectedLoadeds,
				propSubComps: "_subCompsWeaponProficiencies",
				propPrevSubComps: "_prevSubCompsWeaponProficiencies",
				isAvailable: isAvailable_entryDataWeaponProficiencies,
				isForceDisplay: isForceDisplay_entryDataWeaponProficiencies,
				prop: "weaponProficiencies",
				title: "Weapon Proficiencies",
				ptrIsFirstSection,
				CompClass: Charactermancer_OtherProficiencySelect,
				propPathActorExistingProficiencies: ["system", "traits", "weaponProf"],
				fnSetComp: this._render_pHkIxsChosen_setCompOtherProficiencies.bind(this),
				fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedWeaponProficiencies.bind(Charactermancer_OtherProficiencySelect),
			});
			
						this._render_pHkIxsChosen_comp({
				ix: i,
				$stgSubChoiceData,
				selectedLoadeds,
				propSubComps: "_subCompsArmorProficiencies",
				propPrevSubComps: "_prevSubCompsArmorProficiencies",
				isAvailable: isAvailable_entryDataArmorProficiencies,
				isForceDisplay: isForceDisplay_entryDataArmorProficiencies,
				prop: "armorProficiencies",
				title: "Armor Proficiencies",
				ptrIsFirstSection,
				CompClass: Charactermancer_OtherProficiencySelect,
				propPathActorExistingProficiencies: ["system", "traits", "armorProf"],
				fnSetComp: this._render_pHkIxsChosen_setCompOtherProficiencies.bind(this),
				fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedArmorProficiencies.bind(Charactermancer_OtherProficiencySelect),
			});
			
						this._render_pHkIxsChosen_comp({
				ix: i,
				$stgSubChoiceData,
				selectedLoadeds,
				propSubComps: "_subCompsSavingThrowProficiencies",
				propPrevSubComps: "_prevSubCompsSavingThrowProficiencies",
				isAvailable: isAvailable_entryDataSavingThrowProficiencies,
				isForceDisplay: isForceDisplay_entryDataSavingThrowProficiencies,
				prop: "savingThrowProficiencies",
				title: "Saving Throw Proficiencies",
				ptrIsFirstSection,
				CompClass: Charactermancer_OtherProficiencySelect,
				propPathActorExistingProficiencies: ["system", "abilities"],
				fnSetComp: this._render_pHkIxsChosen_setCompOtherProficiencies.bind(this),
				fnGetMappedProficiencies: Charactermancer_OtherProficiencySelect.getMappedSavingThrowProficiencies.bind(Charactermancer_OtherProficiencySelect),
			});
			
						this._render_pHkIxsChosen_comp({
				ix: i,
				$stgSubChoiceData,
				selectedLoadeds,
				propSubComps: "_subCompsDamageImmunities",
				propPrevSubComps: "_prevSubCompsDamageImmunities",
				isAvailable: isAvailable_entryDataDamageImmunities,
				isForceDisplay: isForceDisplay_entryDataDamageImmunities,
				prop: "immune",
				title: "Damage Immunities",
				ptrIsFirstSection,
				CompClass: Charactermancer_DamageImmunitySelect,
				propPathActorExistingProficiencies: ["system", "traits", "di"],
				fnSetComp: this._render_pHkIxsChosen_setCompOtherProficiencies.bind(this),
			});
			
						this._render_pHkIxsChosen_comp({
				ix: i,
				$stgSubChoiceData,
				selectedLoadeds,
				propSubComps: "_subCompsDamageResistances",
				propPrevSubComps: "_prevSubCompsDamageResistances",
				isAvailable: isAvailable_entryDataDamageResistances,
				isForceDisplay: isForceDisplay_entryDataDamageResistances,
				prop: "resist",
				title: "Damage Resistances",
				ptrIsFirstSection,
				CompClass: Charactermancer_DamageResistanceSelect,
				propPathActorExistingProficiencies: ["system", "traits", "dr"],
				fnSetComp: this._render_pHkIxsChosen_setCompOtherProficiencies.bind(this),
			});
			
						this._render_pHkIxsChosen_comp({
				ix: i,
				$stgSubChoiceData,
				selectedLoadeds,
				propSubComps: "_subCompsDamageVulnerabilities",
				propPrevSubComps: "_prevSubCompsDamageVulnerabilities",
				isAvailable: isAvailable_entryDataDamageVulnerabilities,
				isForceDisplay: isForceDisplay_entryDataDamageVulnerabilities,
				prop: "vulnerable",
				title: "Damage Vulnerabilities",
				ptrIsFirstSection,
				CompClass: Charactermancer_DamageVulnerabilitySelect,
				propPathActorExistingProficiencies: ["system", "traits", "dv"],
				fnSetComp: this._render_pHkIxsChosen_setCompOtherProficiencies.bind(this),
			});
			
						this._render_pHkIxsChosen_comp({
				ix: i,
				$stgSubChoiceData,
				selectedLoadeds,
				propSubComps: "_subCompsConditionImmunities",
				propPrevSubComps: "_prevSubCompsConditionImmunities",
				isAvailable: isAvailable_entryDataConditionImmunities,
				isForceDisplay: isForceDisplay_entryDataConditionImmunities,
				prop: "conditionImmune",
				title: "Condition Immunities",
				CompClass: Charactermancer_ConditionImmunitySelect,
				propPathActorExistingProficiencies: ["system", "traits", "ci"],
				ptrIsFirstSection,
				fnSetComp: this._render_pHkIxsChosen_setCompOtherProficiencies.bind(this),
			});
			
						this._render_pHkIxsChosen_comp({
				ix: i,
				$stgSubChoiceData,
				selectedLoadeds,
				propSubComps: "_subCompsExpertise",
				propPrevSubComps: "_prevSubCompsExpertise",
				isAvailable: isAvailable_entryDataExpertise,
				isForceDisplay: isForceDisplay_entryDataExpertise,
				prop: "expertise",
				title: "Expertise",
				ptrIsFirstSection,
				fnSetComp: this._render_pHkIxsChosen_setCompExpertise.bind(this),
			});
			
						this._render_pHkIxsChosen_comp({
				ix: i,
				$stgSubChoiceData,
				selectedLoadeds,
				propSubComps: "_subCompsResources",
				propPrevSubComps: "_prevSubCompsResources",
				isAvailable: isAvailable_entryDataResources,
				isForceDisplay: isForceDisplay_entryDataResources,
				prop: "resources",
				ptrIsFirstSection,
				fnSetComp: this._render_pHkIxsChosen_setCompResources.bind(this),
			});
			
						this._render_pHkIxsChosen_comp({
				ix: i,
				$stgSubChoiceData,
				selectedLoadeds,
				propSubComps: "_subCompsSenses",
				propPrevSubComps: "_prevSubCompsSenses",
				isAvailable: isAvailable_entryDataSenses,
				isForceDisplay: isForceDisplay_entryDataSenses,
				prop: "senses",
				ptrIsFirstSection,
				fnSetComp: this._render_pHkIxsChosen_setCompSenses.bind(this),
			});
			
						this._render_pHkIxsChosen_comp({
				ix: i,
				$stgSubChoiceData,
				selectedLoadeds,
				propSubComps: "_subCompsAdditionalSpells",
				propPrevSubComps: "_prevSubCompsAdditionalSpells",
				isAvailable: isAvailable_entryDataAdditionalSpells,
				isForceDisplay: isForceDisplay_entryDataAdditionalSpells,
				prop: "additionalSpells",
				ptrIsFirstSection,
				fnSetComp: this._render_pHkIxsChosen_setCompAdditionalSpells.bind(this),
			});
					}

		this._prevSubCompsSkillToolLanguageProficiencies = null;
		this._prevSubCompsSkillProficiencies = null;
		this._prevSubCompsLanguageProficiencies = null;
		this._prevSubCompsToolProficiencies = null;
		this._prevSubCompsWeaponProficiencies = null;
		this._prevSubCompsArmorProficiencies = null;
		this._prevSubCompsSavingThrowProficiencies = null;
		this._prevSubCompsDamageImmunities = null;
		this._prevSubCompsDamageResistances = null;
		this._prevSubCompsDamageVulnerabilities = null;
		this._prevSubCompsConditionImmunities = null;
		this._prevSubCompsExpertise = null;
		this._prevSubCompsResources = null;
		this._prevSubCompsSenses = null;
		this._prevSubCompsAdditionalSpells = null;

		$stgSubChoiceData.toggleVe(isSubChoiceForceDisplay);
	}

	_render_pHkIxsChosen_comp (
		{
			ix,
			$stgSubChoiceData,
			propSubComps,
			propPrevSubComps,
			isAvailable,
			isForceDisplay,
			selectedLoadeds,
			prop,
			title,
			CompClass,
			propPathActorExistingProficiencies,
			ptrIsFirstSection,
			fnSetComp,
			fnGetMappedProficiencies,
			fnGetExistingFvtt,
		},
	) {
		this[propSubComps][ix] = null;
		if (!isAvailable) return;

		const {entity} = selectedLoadeds[ix];

		if (!entity?.[prop] && !entity?.entryData?.[prop]) return;

		fnSetComp({
			ix,
			propSubComps,
			prop,
			CompClass,
			propPathActorExistingProficiencies,
			entity,
			fnGetMappedProficiencies,
			fnGetExistingFvtt,
		});

				if (this[propPrevSubComps] && this[propPrevSubComps][ix]) {
			this[propSubComps][ix]._proxyAssignSimple("state", MiscUtil.copy(this[propPrevSubComps][ix].__state));
		}

		if (!isForceDisplay) return;

		if (!title) title = this[propSubComps][ix]?.modalTitle;

		if (title) $stgSubChoiceData.append(`${ptrIsFirstSection._ ? "" : `<div class="w-100 mt-1 mb-2"></div>`}<div class="bold mb-2">${title}</div>`);
		this[propSubComps][ix].render($stgSubChoiceData);
		ptrIsFirstSection._ = false;
	}

	_render_pHkIxsChosen_setCompOtherProficiencies (
		{
			ix,
			propSubComps,
			prop,
			CompClass,
			propPathActorExistingProficiencies,
			entity,
			fnGetMappedProficiencies,
			fnGetExistingFvtt,
		},
	) {
		const availableRaw = entity[prop] || entity.entryData[prop];
		const existingFvtt = fnGetExistingFvtt
			? fnGetExistingFvtt()
			: {[prop]: MiscUtil.get(this._actor, ...propPathActorExistingProficiencies)};
		this[propSubComps][ix] = new CompClass({
			featureSourceTracker: this._featureSourceTracker,
			existing: CompClass.getExisting(existingFvtt),
			existingFvtt,
			available: fnGetMappedProficiencies ? fnGetMappedProficiencies(availableRaw) : availableRaw,
		});
	}

	_render_pHkIxsChosen_setCompExpertise (
		{
			ix,
			propSubComps,
			prop,
			entity,
		},
	) {
		const existingFvtt = Charactermancer_ExpertiseSelect.getExistingFvttFromActor(this._actor);
		this[propSubComps][ix] = new Charactermancer_ExpertiseSelect({
			featureSourceTracker: this._featureSourceTracker,
			existing: Charactermancer_ExpertiseSelect.getExisting(existingFvtt),
			existingFvtt,
			available: entity[prop] || entity.entryData[prop],
		});
	}

	_render_pHkIxsChosen_setCompResources (
		{
			ix,
			propSubComps,
			prop,
			entity,
		},
	) {
		this[propSubComps][ix] = new Charactermancer_ResourceSelect({
			resources: entity[prop] || entity.entryData[prop],
			className: entity.className,
			classSource: entity.classSource,
			subclassShortName: entity.subclassShortName,
			subclassSource: entity.subclassSource,
		});
	}

	_render_pHkIxsChosen_setCompSenses (
		{
			ix,
			propSubComps,
			prop,
			entity,
		},
	) {
		const existingFvtt = Charactermancer_SenseSelect.getExistingFvttFromActor(this._actor);
		this[propSubComps][ix] = new Charactermancer_SenseSelect({
			existing: Charactermancer_SenseSelect.getExisting(existingFvtt),
			existingFvtt,
			senses: entity[prop] || entity.entryData[prop],
		});
	}

	_render_pHkIxsChosen_setCompAdditionalSpells (
		{
			ix,
			propSubComps,
			prop,
			entity,
		},
	) {
		this[propSubComps][ix] = Charactermancer_AdditionalSpellsSelect.getComp({
			additionalSpells: entity[prop] || entity.entryData[prop],
			modalFilterSpells: this._modalFilterSpells,

						curLevel: 0,
			targetLevel: Consts.CHAR_MAX_LEVEL,
			spellLevelLow: 0,
			spellLevelHigh: 9,
		});
	}

	_getProps (ix) {
		return {
			prefixSubComps: "subComp_",
			propChooseSystem: `subComp_${ix}_chooseSystem`,
			propChooseFlags: `subComp_${ix}_chooseFlags`,
		};
	}

	_unregisterSubComps () {
		if (!this._featureSourceTracker) return;

		this._subCompsSkillToolLanguageProficiencies.filter(Boolean).forEach(comp => this._featureSourceTracker.unregister(comp));
		this._subCompsSkillProficiencies.filter(Boolean).forEach(comp => this._featureSourceTracker.unregister(comp));
		this._subCompsLanguageProficiencies.filter(Boolean).forEach(comp => this._featureSourceTracker.unregister(comp));
		this._subCompsToolProficiencies.filter(Boolean).forEach(comp => this._featureSourceTracker.unregister(comp));
		this._subCompsWeaponProficiencies.filter(Boolean).forEach(comp => this._featureSourceTracker.unregister(comp));
		this._subCompsArmorProficiencies.filter(Boolean).forEach(comp => this._featureSourceTracker.unregister(comp));
		this._subCompsSavingThrowProficiencies.filter(Boolean).forEach(comp => this._featureSourceTracker.unregister(comp));
		this._subCompsDamageImmunities.filter(Boolean).forEach(comp => this._featureSourceTracker.unregister(comp));
		this._subCompsDamageResistances.filter(Boolean).forEach(comp => this._featureSourceTracker.unregister(comp));
		this._subCompsDamageVulnerabilities.filter(Boolean).forEach(comp => this._featureSourceTracker.unregister(comp));
		this._subCompsConditionImmunities.filter(Boolean).forEach(comp => this._featureSourceTracker.unregister(comp));
		this._subCompsExpertise.filter(Boolean).forEach(comp => this._featureSourceTracker.unregister(comp));
		this._subCompsResources.filter(Boolean).forEach(comp => this._featureSourceTracker.unregister(comp));
		this._subCompsSenses.filter(Boolean).forEach(comp => this._featureSourceTracker.unregister(comp));
		this._subCompsAdditionalSpells.filter(Boolean).forEach(comp => this._featureSourceTracker.unregister(comp));
	}

	_render_noSubChoices ({$stgSubChoiceData}) {
		this._lastSubMetas.forEach(it => it.unhook());
		this._lastSubMetas = [];

		this._unregisterSubComps();

		this._subCompsSkillToolLanguageProficiencies = [];
		this._subCompsSkillProficiencies = [];
		this._subCompsLanguageProficiencies = [];
		this._subCompsToolProficiencies = [];
		this._subCompsWeaponProficiencies = [];
		this._subCompsArmorProficiencies = [];
		this._subCompsSavingThrowProficiencies = [];
		this._subCompsDamageImmunities = [];
		this._subCompsDamageResistances = [];
		this._subCompsDamageVulnerabilities = [];
		this._subCompsConditionImmunities = [];
		this._subCompsExpertise = [];
		this._subCompsResources = [];
		this._subCompsSenses = [];
		this._subCompsAdditionalSpells = [];

		$stgSubChoiceData.empty().hideVe();
	}

	_render_options () {
		if (!this._isOptions()) return;

		const {count, required} = this._getOptionsNameAndCount();

		const $ptsExisting = {};
		this._lastMeta = ComponentUiUtil.getMetaWrpMultipleChoice(
			this,
			"ixsChosen",
			{
				values: this._optionsSet,
				ixsRequired: required,
				count,
				fnDisplay: v => {
					const ptName = Renderer.get().render(v.entry);

					const $ptExisting = $(`<div class="ml-1 ve-small ve-muted"></div>`);
					$ptsExisting[this.constructor._getLoadedTmpUid(v)] = $ptExisting;

					return $$`<div class="w-100 split-v-center">
						<div class="mr-2 ve-flex-v-center">${ptName}${$ptExisting}</div>
						<div class="${Parser.sourceJsonToColor(v.entity.source)} pr-1" title="${Parser.sourceJsonToFull(v.entity.source)}">${Parser.sourceJsonToAbv(v.entity.source)}</div>
					</div>`;
				},
			},
		);

		const hkUpdatePtsExisting = () => {
			const otherStates = this._featureSourceTracker ? this._featureSourceTracker.getStatesForKey("features", {ignore: this}) : null;

			this._optionsSet
				.forEach(v => {
					const tmpUid = this.constructor._getLoadedTmpUid(v);

					if (!$ptsExisting[tmpUid]) return;

										let isExists = this._existingFeatureChecker && this._existingFeatureChecker.isExistingFeature(UtilEntity.getName(v.entity), v.page, v.source, v.hash);

										if (otherStates) isExists = isExists || otherStates.some(arr => arr.some(it => it.page === v.page && it.hash === v.hash));

					$ptsExisting[tmpUid]
						.title(isExists ? `Gained from Another Source` : "")
						.html(isExists ? `(<i class="fas fa-fw fa-check"></i>)` : "")
						.toggleClass("ml-1", isExists);
				});
		};
		if (this._featureSourceTracker) this._featureSourceTracker.addHook(this, "pulseFeatures", hkUpdatePtsExisting);
		hkUpdatePtsExisting();

				if (this._featureSourceTracker) {
			const hkSetTrackerState = () => this._featureSourceTracker.setState(this, {features: this._getTrackableFeatures()});
			this._addHookBase(this._lastMeta.propPulse, hkSetTrackerState);
			hkSetTrackerState(); 		}
			}

	_render_getSubCompTitle (entity) {
		const titleIntro = [
			entity.className,
			entity.subclassShortName ? `(${entity.subclassShortName})` : "",
			entity.level ? `Level ${entity.level}` : "",
		].filter(Boolean).join(" ");
		const title = `${titleIntro}${titleIntro ? ": " : ""}${entity.name}`;
		return `${this._isModal ? "" : `<hr class="hr-2">`}<div class="mb-2 bold w-100">${title}</div>`;
	}

		_render_renderSubComp_chooseSystem (ix, $stgSubChoice, entity, type, sideData) {
		return this._render_renderSubComp_chooseSystemChooseFlags({
			ix,
			$stgSubChoice,
			entity,
			type,
			sideData,
			propChoose: "chooseSystem",
			propCompProp: "propChooseSystem",
			propIsRenderEntries: "isChooseSystemRenderEntries",
		});
	}

	_render_renderSubComp_chooseFlags (ix, $stgSubChoice, entity, type, sideData) {
		return this._render_renderSubComp_chooseSystemChooseFlags({
			ix,
			$stgSubChoice,
			entity,
			type,
			sideData,
			propChoose: "chooseFlags",
			propCompProp: "propChooseFlags",
			propIsRenderEntries: "isChooseFlagsRenderEntries",
		});
	}

	_render_renderSubComp_chooseSystemChooseFlags ({ix, $stgSubChoice, entity, type, sideData, propChoose, propCompProp, propIsRenderEntries}) {
		const compProps = this._getProps(ix);

		const htmlDescription = sideData[propIsRenderEntries]
			? Vetools.withUnpatchedDiceRendering(() => `${(entity.entries || []).map(ent => `<div>${Renderer.get().render(ent)}</div>`).join("")}`)
			: null;

		const choiceMeta = ComponentUiUtil.getMetaWrpMultipleChoice(
			this,
			compProps[propCompProp],
			{
				count: 1,
				fnDisplay: val => val.name,
				values: sideData[propChoose],
			},
		);

		this._lastSubMetas.push(choiceMeta);

		$$`<div class="ve-flex-col w-100">
			${htmlDescription}
			${choiceMeta.$ele}
		</div>`.appendTo($stgSubChoice);
	}

	_getDefaultState () {
		return {
			ixsChosen: [],
		};
	}
}

class CreatureConditionInflictedConverter {
	static getConditionMatches (str) {
		const out = new Set();

		this._CONDITION_INFLICTED_MATCHERS.forEach(re => str.replace(re, (...m) => {
			out.add(m[1]);

						if (m[2]) m[2].replace(/{@condition ([^}]+)}/g, (...n) => out.add(n[1]));

						if (m[3]) m[3].replace(/{@condition ([^}]+)}/g, (...n) => out.add(n[1]));
		}));

		return [...out].sort(SortUtil.ascSortLower);
	}
}

const __TGT = `(?:target|wielder)`;

CreatureConditionInflictedConverter._CONDITION_INFLICTED_MATCHERS = [
	`(?:creature|enemy|target) is \\w+ {@condition ([^}]+)}`, 	`(?:creature|enemy|target) becomes (?:\\w+ )?{@condition ([^}]+)}`,
	`saving throw (?:by \\d+ or more, it )?is (?:\\w+ )?{@condition ([^}]+)}`, 	`(?:the save|fails) by \\d+ or more, [^.!?]+?{@condition ([^}]+)}`, 	`(?:${__TGT}|creatures?|humanoid|undead|other creatures|enemy) [^.!?]+?(?:succeed|make|pass)[^.!?]+?saving throw[^.!?]+?or (?:fall|be(?:come)?|is) (?:\\w+ )?{@condition ([^}]+)}`,
	`and then be (?:\\w+ )?{@condition ([^}]+)}`,
	`(?:be|is) knocked (?:\\w+ )?{@condition (prone|unconscious)}`,
	`a (?:\\w+ )?{@condition [^}]+} (?:creature|enemy) is (?:\\w+ )?{@condition ([^}]+)}`, 	`(?<!if )the[^.!?]+?${__TGT} is [^.!?]*?(?<!that isn't ){@condition ([^}]+)}`,
	`the[^.!?]+?${__TGT} is [^.!?]+?, it is {@condition ([^}]+)}(?: \\(escape [^\\)]+\\))?`,
	`begins to [^.!?]+? and is {@condition ([^}]+)}`, 	`saving throw[^.!?]+?or [^.!?]+? and remain {@condition ([^}]+)}`, 	`saving throw[^.!?]+?or be [^.!?]+? and land {@condition (prone)}`, 	`saving throw[^.!?]+?or be (?:pushed|pulled) [^.!?]+? and (?:\\w+ )?{@condition ([^}]+)}`, 	`the engulfed (?:creature|enemy) [^.!?]+? {@condition ([^}]+)}`, 	`the ${__TGT} is [^.!?]+? and (?:is )?{@condition ([^}]+)} while`, 	`on a failed save[^.!?]+?the (?:${__TGT}|creature) [^.!?]+? {@condition ([^}]+)}`, 	`on a failure[^.!?]+?${__TGT}[^.!?]+?(?:pushed|pulled)[^.!?]+?and (?:\\w+ )?{@condition ([^}]+)}`, 	`a[^.!?]+?(?:creature|enemy)[^.!?]+?to the[^.!?]+?is (?:also )?{@condition ([^}]+)}`, 	`(?:creature|enemy) gains? \\w+ levels? of {@condition (exhaustion)}`, 	`(?:saving throw|failed save)[^.!?]+? gains? \\w+ levels? of {@condition (exhaustion)}`, 	`(?:on a successful save|if the saving throw is successful), (?:the ${__TGT} |(?:a|the )creature |(?:an |the )enemy )[^.!?]*?isn't {@condition ([^}]+)}`,
	`or take[^.!?]+?damage and (?:becomes?|is|be) {@condition ([^}]+)}`, 	`the (?:${__TGT}|creature|enemy) [^.!?]+? and is {@condition ([^}]+)}`, 	`${__TGT}\\. [^.!?]+?damage[^.!?]+?and[^.!?]+?${__TGT} is {@condition ([^}]+)}`, 	`on a failure[^.!?]+?${__TGT} [^.!?]+?\\. [^.!?]+?is also {@condition ([^}]+)}`, 	`(?:(?:a|the|each) ${__TGT}|(?:a|the|each) creature|(?:an|each) enemy)[^.!?]+?takes?[^.!?]+?damage[^.!?]+?and [^.!?]+? {@condition ([^}]+)}`, 	`(?:creatures|enemies) within \\d+ feet[^.!?]+must succeed[^.!?]+saving throw or be {@condition ([^}]+)}`, 	`creature that fails the save[^.!?]+?{@condition ([^}]+)}`, 	`if the ${__TGT} is a creature[^.!?]+?saving throw[^.!?]*?\\. On a failed save[^.!?]+?{@condition ([^}]+)}`, 	`while {@condition (?:[^}]+)} in this way, an? (?:${__TGT}|creature|enemy) [^.!?]+{@condition ([^}]+)}`, 	`${__TGT} must succeed[^.!?]+?saving throw[^.!?]+?{@condition ([^}]+)}`, 	`fails the saving throw[^.!?]+?is instead{@condition ([^}]+)}`, 	`on a failure, the [^.!?]+? can [^.!?]+?{@condition ([^}]+)}`, 	`the {@condition ([^}]+)} creature can repeat the saving throw`, 	`if the (?:${__TGT}|creature) is already {@condition [^}]+}, it becomes {@condition ([^}]+)}`,
	`(?<!if the )(?:creature|${__TGT}) (?:also becomes|is) {@condition ([^}]+)}`, 	`magically (?:become|turn)s? {@condition (invisible)}`, 	{re: `The (?!(?:[^.]+) can sense)(?:[^.]+) is {@condition (invisible)}`, flags: "g"}, 	`succeed\\b[^.!?]+\\bsaving throw\\b[^.!?]+\\. (?:It|The (?:creature|target)) is {@condition ([^}]+)}`, ]
	.map(it => typeof it === "object" ? it : ({re: it, flags: "gi"}))
	.map(({re, flags}) => new RegExp(`${re}((?:, {@condition [^}]+})*)(,? (?:and|or) {@condition [^}]+})?`, flags));

class UtilAutomation {
	static _WALKER_BOR = null;

	static _getEffectConcentrating ({entry, img}) {
		return UtilActiveEffects.getGenericEffect({
			name: entry.name,
			icon: img,
			disabled: false,
			transfer: false,

			key: `StatusEffect`,
			value: `Convenient Effect: Concentrating`,
			mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
			priority: UtilActiveEffects.PRIORITY_BASE,

			flags: {[UtilCompat.MODULE_DAE]: {"selfTarget": true}},
		});
	}

	static getCreatureFeatureEffects ({entry, img, entity}) {
		UtilAutomation._WALKER_BOR = UtilAutomation._WALKER_BOR
			|| MiscUtil.getWalker({keyBlocklist: MiscUtil.GENERIC_WALKER_ENTRIES_KEY_BLOCKLIST, isNoModification: true, isBreakOnReturn: true});

		const condSet = new Set();

		UtilAutomation._WALKER_BOR.walk(
			entry.entries,
			{
				string: str => {
					CreatureConditionInflictedConverter.getConditionMatches(str)
						.forEach(cond => condSet.add(cond));
				},
			},
		);

		if (!condSet.size) return [];

		const conds = [...condSet].sort(SortUtil.ascSortLower);
		const additionalEffects = [];

		let isDisabled = false;
		let isTransfer = false;
		let endsMeta = null;

		const addToEndsMeta = nxt => {
			if (endsMeta == null) endsMeta = {};
			endsMeta = foundry.utils.mergeObject(endsMeta, nxt);
		};

		UtilAutomation._WALKER_BOR.walk(
			entry.entries,
			{
				string: str => { 					const mEonTCreature = /\b(?<mode>start|end) of (?:the creature's|its) (?:next )?turn\b/i.exec(str);
					if (mEonTCreature) {
						const mode = mEonTCreature.groups.mode.toLowerCase() === "start" ? `turnStart` : `turnEnd`;
						addToEndsMeta({flags: {[UtilCompat.MODULE_DAE]: {"specialDuration": [mode]}}});
					}

					const mEonTSelf = /\b(?<mode>start|end) of\b[^.!?]+\bnext turn\b/i.exec(str);
					if (mEonTSelf) {
						const mode = mEonTSelf.groups.mode.toLowerCase() === "start" ? `turnStartSource` : `turnEndSource`;
						addToEndsMeta({flags: {[UtilCompat.MODULE_DAE]: {"specialDuration": [mode]}}});
					}

					const mDuration = /\b(?:for|the effect lasts(?: for)?)(?: up to)? (?<amount>\d+) (?<unit>minute|hour|day)s??\b/i.exec(str);
					if (mDuration) {
						const amount = Number(mDuration.groups.amount);
						const mult = mDuration.groups.unit.toLowerCase() === "day"
							? 24 * 60 * 60
							: mDuration.groups.unit.toLowerCase() === "hour"
								? 60 * 60
								: mDuration.groups.unit.toLowerCase() === "minute"
									? 60
									: 1;
						addToEndsMeta({durationSeconds: Number(amount) * mult});
					}

										const mSelfUntilAttackOrSpell = /\buntil [^.?!]+ attacks(?:, )?(?: or )?(?:casts a spell|it forces a creature to make a saving throw)\b/.exec(str);
					if (mSelfUntilAttackOrSpell) {
						isTransfer = false;
						addToEndsMeta({
							flags: {
								[UtilCompat.MODULE_DAE]: {
									"selfTarget": true,
									"specialDuration": ["1Action", "1Spell"],
								},
							},
						});
					}

										const mUntilAttack = /\bbecomes \{@condition invisible} [^.?!]+\bafter it makes an attack roll\b/.exec(str);
					if (mUntilAttack) {
						isTransfer = false;
						addToEndsMeta({
							flags: {
								[UtilCompat.MODULE_DAE]: {
									"selfTarget": true,
									"specialDuration": ["1Attack"],
								},
							},
						});
					}

										const mAbilityCheck = new RegExp(`\\b(?<ability>${Object.values(Parser.ATB_ABV_TO_FULL).join("|")}) check,?(?: (?:ending|escaping) [^.?!]+ on a success| and succeeds| [^.?!]*?\\b the effect on a success| freeing\\b[^.?!]*?\\bon a success)\\b`, "i").exec(str);
										const mAbilityCheck2 = new RegExp(`\\bending the effect\\b[^.?!]*?\\bwith a successful\\b[^.?!]*?\\b(?<ability>${Object.values(Parser.ATB_ABV_TO_FULL).join("|")}) check`).exec(str);
					if (mAbilityCheck || mAbilityCheck2) {
						const m = mAbilityCheck || mAbilityCheck2;
						const abilAbv = m.groups.ability.slice(0, 3).toLowerCase();
																		addToEndsMeta({flags: {[UtilCompat.MODULE_DAE]: {"specialDuration": [`isCheck.${abilAbv}`]}}});
					}

										const mUntilConcEnds = /\buntil [^.?!]+ concentration ends\b/i.exec(str);
					if (mUntilConcEnds) {
																		addToEndsMeta({});
					}

										const mUseShortOrLongRest = /\buntil it finishes a short or long rest\b/i.exec(str);
					if (mUseShortOrLongRest) {
						addToEndsMeta({flags: {[UtilCompat.MODULE_DAE]: {"specialDuration": ["shortRest", "longRest"]}}});
					}

										const mUseShortRest = /\bcan remove [^.?!]+ using a short rest\b/i.exec(str);
					if (mUseShortRest) {
						addToEndsMeta({flags: {[UtilCompat.MODULE_DAE]: {"specialDuration": ["shortRest"]}}});
					}

										const mInitiative20NextRound = /\b(?:until initiative count 20 on the next round|until the next initiative count 20)\b/i.exec(str);
					if (mInitiative20NextRound) {
																		addToEndsMeta({flags: {[UtilCompat.MODULE_DAE]: {"specialDuration": ["turnEndSource"]}}});
					}

										const mDiseaseCured = /\buntil the disease (?:is cured|ends)\b/i.exec(str);
					if (mDiseaseCured) {
																		addToEndsMeta({});
					}

															const mRemovedBySpell = /\buntil (?:it is removed by the [^.]+? spell or similar magic|magic such as the [^.]+? spell)\b/i.exec(str);
					if (mRemovedBySpell) {
																		addToEndsMeta({});
					}

										const mDeath = /\buntil the [^.!?]+? dies\b/i.exec(str);
					if (mDeath) {
																		addToEndsMeta({});
					}

					if (endsMeta) return true;
				},
			},
		);

		if (UtilGameSettings.isDbg() && !endsMeta) {
			const condsLog = conds
				.filter(it => !["prone", "grappled", "deafened"].includes(it))
				.filter(it => !(conds.includes("grappled") && it === "restrained"));
			if (condsLog.length) {
				console.warn(`No end found for ${entry.name} ending for "${condsLog.join("/")}" for creature "${entity.name}" in e.g.\n${entry.entries[0]}`);
			}
		}

		return [
			...conds
				.map(cond => {
					return UtilActiveEffects.getGenericEffect({
						name: Renderer.stripTags(entry.name),
						icon: img,
						disabled: isDisabled,
						transfer: isTransfer,

						key: `StatusEffect`,
						value: `Convenient Effect: ${cond.toTitleCase()}`,
						mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
						priority: UtilActiveEffects.PRIORITY_BASE,

						...endsMeta,
					});
				}),
			...additionalEffects,
		];
	}

	static getCreatureFeatureFlags ({entry, hasDamageParts = false, hasSavingThrow = false}) {
		UtilAutomation._WALKER_BOR = UtilAutomation._WALKER_BOR
			|| MiscUtil.getWalker({keyBlocklist: MiscUtil.GENERIC_WALKER_ENTRIES_KEY_BLOCKLIST, isNoModification: true, isBreakOnReturn: true});

		const flags = {};

		UtilAutomation._WALKER_BOR
			.walk(
				entry.entries,
				{
					string: str => {
						if (/\buntil [^.?!]+ concentration ends\b/i.test(str)) {
							MiscUtil.set(flags, "midiProperties", "concentration", true);
							return true;
						}
					},
				},
			);

				if (hasDamageParts && hasSavingThrow) {
									let isHalfDamageOnSave = false;

			UtilAutomation._WALKER_BOR
				.walk(
					entry.entries,
					{
						string: str => {
							if (/\bhalf (?:as much )?damage\b/i.test(str)) {
								isHalfDamageOnSave = true;
								return true;
							}
						},
					},
				);

			if (!isHalfDamageOnSave) MiscUtil.set(flags, "midiProperties", "nodam", true);
		}
		
		return flags;
	}
}

class DataConverter {
		
	static _SIDE_LOAD_OPTS = null;

	static _getResolvedSideLoadOpts ({ent, propOpts = "_SIDE_LOAD_OPTS"} = {}) {
		return this._getSideLoadOpts(ent) || this[propOpts];
	}

	static async _pGetRootSideLoaded (ent, {propOpts = "_SIDE_LOAD_OPTS"} = {}) {
		const opts = this._getResolvedSideLoadOpts({ent, propOpts});
		if (!opts) return null;

		const {propBrew, fnLoadJson, propJson, propsMatch} = opts;
		return this._pGetStarSideLoaded(ent, {propBrew, fnLoadJson, propJson, propsMatch, propFromEntity: "foundryRoot", propFromSideLoaded: "root"});
	}

	static async _pGetDataSideLoaded (ent, {propOpts = "_SIDE_LOAD_OPTS"} = {}) {
		const opts = this._getResolvedSideLoadOpts({ent, propOpts});
		if (!opts) return null;

		const {propBrew, fnLoadJson, propJson, propsMatch} = opts;
		return this._pGetStarSideLoaded(ent, {propBrew, fnLoadJson, propJson, propsMatch, propFromEntity: "foundrySystem", propFromSideLoaded: "system"});
	}

	static async _pGetFlagsSideLoaded (ent, {propOpts = "_SIDE_LOAD_OPTS"} = {}) {
		const opts = this._getResolvedSideLoadOpts({ent, propOpts});
		if (!opts) return null;

		const {propBrew, fnLoadJson, propJson, propsMatch} = opts;
		return this._pGetStarSideLoaded(ent, {propBrew, fnLoadJson, propJson, propsMatch, propFromEntity: "foundryFlags", propFromSideLoaded: "flags"});
	}

	static async _pGetAdvancementSideLoaded (ent, {propOpts = "_SIDE_LOAD_OPTS"} = {}) {
		const opts = this._getResolvedSideLoadOpts({ent, propOpts});
		if (!opts) return null;

		const {propBrew, fnLoadJson, propJson, propsMatch} = opts;
		return this._pGetStarSideLoaded(ent, {propBrew, fnLoadJson, propJson, propsMatch, propFromEntity: "foundryAdvancement", propFromSideLoaded: "advancement"});
	}

	static async _pGetImgSideLoaded (ent, {propOpts = "_SIDE_LOAD_OPTS"} = {}) {
		const opts = this._getResolvedSideLoadOpts({ent, propOpts});
		if (!opts) return null;

		const {propBrew, fnLoadJson, propJson, propsMatch} = opts;
		return this._pGetStarSideLoaded(ent, {propBrew, fnLoadJson, propJson, propsMatch, propFromEntity: "foundryImg", propFromSideLoaded: "img"});
	}

	static async _pGetIsIgnoredSideLoaded (ent, {propOpts = "_SIDE_LOAD_OPTS"} = {}) {
		const opts = this._getResolvedSideLoadOpts({ent, propOpts});
		if (!opts) return null;

		const {propBrew, fnLoadJson, propJson, propsMatch} = opts;
		return this._pGetStarSideLoaded(ent, {propBrew, fnLoadJson, propJson, propsMatch, propFromEntity: "foundryIsIgnored", propFromSideLoaded: "isIgnored"});
	}

	static async _pIsIgnoreSrdEffectsSideLoaded (ent, {propOpts = "_SIDE_LOAD_OPTS"} = {}) {
		const opts = this._getResolvedSideLoadOpts({ent, propOpts});
		if (!opts) return null;
		return this._pGetStarSideLoaded(ent, {...opts, propFromEntity: "foundryIgnoreSrdEffects", propFromSideLoaded: "ignoreSrdEffects"});
	}

	static async _pGetEffectsRawSideLoaded (ent, {propOpts = "_SIDE_LOAD_OPTS"} = {}) {
		const opts = this._getResolvedSideLoadOpts({ent, propOpts});
		if (!opts) return null;
		return DataConverter._pGetEffectsRawSideLoaded_(ent, opts);
	}

	static async _pGetEffectsSideLoadedTuples ({ent, actor = null, sheetItem = null, additionalData = null, img = null}, {propOpts = "_SIDE_LOAD_OPTS"} = {}) {
		const outRaw = await this._pGetEffectsRawSideLoaded(ent, {propOpts});
		if (!outRaw?.length) return [];

		return UtilActiveEffects.getExpandedEffects(
			outRaw,
			{
				actor,
				sheetItem,
				parentName: UtilEntity.getName(ent),
				img,
			},
			{
				isTuples: true,
			},
		);
	}

		static _getSideLoadOpts (ent) { return null; }
	
		static _IMG_FALLBACK = null;

	static async _pGetImagePath (ent, {fluff, propCompendium, isAllowCustom = true, taskRunner = null} = {}) {
		const meta = await this._pGetImagePathMeta_(...arguments);
		return meta.img;
	}

	static async _pGetSaveImagePath (ent, {fluff, propCompendium, isAllowCustom = true, taskRunner = null} = {}) {
		return Vetools.pOptionallySaveImageToServerAndGetUrl(await this._pGetImagePath(ent, {fluff, propCompendium, isAllowCustom, taskRunner}));
	}

	static async _pGetSaveImagePathMeta (ent, {fluff, propCompendium, isAllowCustom = true, taskRunner} = {}) {
		const meta = this._pGetImagePathMeta_(ent, {fluff, propCompendium, isAllowCustom, taskRunner});

		return {
			img: await Vetools.pOptionallySaveImageToServerAndGetUrl(meta.img),
			isFallback: meta.isFallback,
		};
	}

	static async _pGetImagePathMeta_ (ent, {fluff, propCompendium, isAllowCustom = true, taskRunner = null} = {}) {
		if (ent.foundryImg) return {img: ent.foundryImg};

		const fromSide = await this._pGetImgSideLoaded(ent);
		if (fromSide) return {img: fromSide};

		const getters = [
			async () => {
								if (isAllowCustom) {
					const fromCustom = await this._pGetImgCustom(ent);
					if (fromCustom) return fromCustom;
				}

				if (fluff) {
					const fromFluff = await Vetools.pGetImageUrlFromFluff(fluff);
					if (fromFluff) return fromFluff;
				}
			},
			async () => {
				if (!propCompendium) return null;

				const fromCompendium = await this._pGetImagePath_pGetCompendiumImage({ent, propCompendium, taskRunner});
				if (fromCompendium) return fromCompendium;
			},
		];
		if (Config.get("import", "isPreferFoundryImages")) getters.reverse();

		for (const getter of getters) {
			const url = await getter();
			if (url) return {img: url};
		}

				const fromFallback = this._getImgFallback(ent);
		if (fromFallback) return {img: fromFallback, isFallback: true};

				return {img: this._IMG_FALLBACK, isFallback: true};
	}

	static async _pGetImagePath_pGetCompendiumImage ({ent, propCompendium, taskRunner}) {
		return UtilCompendium.pGetCompendiumImage(propCompendium, ent, {fnGetAliases: this._getCompendiumAliases.bind(this), isIgnoreSrd: true, taskRunner});
	}

		static async _pGetImgCustom (ent) { return null; }
	static _getImgFallback (ent) { return null; }
	static _getCompendiumAliases (ent) { return []; }
	
	static async pGetDocumentJson (ent, opts) { throw new Error("Unimplemented!"); }

	static isStubEntity (ent) { return false; }

	static getTagUids (tag, str) {
		const re = new RegExp(`{@${tag} ([^}]+)}`, "gi");
		const out = [];
		str.replace(re, (...m) => out.push(m[1]));
		return out;
	}

	static async pGetIconImage (entityType, entity) {
		switch (entityType) {
			case "spell": {
				const iconLookup = await Vetools.pGetIconLookup(entityType);
				return MiscUtil.get(iconLookup, entity.source, entity.name);
			}
			case "feat": {
				const iconLookup = await Vetools.pGetIconLookup(entityType);
				const path = MiscUtil.get(iconLookup, entity.source, entity.name);
				if (!path) return null;
				return `modules/${SharedConsts.MODULE_ID}/${path}`;
			}
			default: return null;
		}
	}

		static getCombinedFoundrySystem (foundrySystem, _foundryData) {
		if (!_foundryData && !foundrySystem) return {};

		const combinedFoundrySystem = MiscUtil.copy(_foundryData || {});
		Object.assign(combinedFoundrySystem, MiscUtil.copy(foundrySystem || {}));

		return combinedFoundrySystem;
	}

		static getCombinedFoundryFlags (foundryFlags, _foundryFlags) {
		if (!foundryFlags && !_foundryFlags) return {};

		const combinedFoundryFlags = MiscUtil.copy(_foundryFlags || {});

				Object.entries(MiscUtil.copy(foundryFlags || {}))
			.forEach(([flagNamespace, flagData]) => {
				if (!combinedFoundryFlags[flagNamespace]) return combinedFoundryFlags[flagNamespace] = flagData;
				Object.assign(combinedFoundryFlags[flagNamespace], flagData);
			});

		return combinedFoundryFlags;
	}

		static async pGetEntryDescription (entry, opts) {
		opts = opts || {};
		opts.prop = opts.prop || "entries";

		Renderer.get().resetHeaderIndex();

		let description = "";
		if (entry[opts.prop]) {
			let cpyEntries = MiscUtil.copy(entry[opts.prop]);

			cpyEntries = UtilDataConverter.WALKER_GENERIC.walk(
				cpyEntries,
				{
					string: (str) => {
						return str
														.replace(/{@hitYourSpellAttack}/gi, () => `{@dice 1d20 + @${SharedConsts.MODULE_ID_FAKE}.userchar.spellAttackRanged|your spell attack modifier}`)
							.replace(/{(@dice|@damage|@scaledice|@scaledamage|@hit) ([^}]+)}/gi, (...m) => {
								const [, tag, text] = m;
								let [rollText, displayText, name, ...others] = Renderer.splitTagByPipe(text);
								const originalRollText = rollText;

								rollText = this._pGetEntryDescription_getCleanDicePart(rollText, opts);
								displayText = this._pGetEntryDescription_getCleanDisplayPart({displayText, originalText: originalRollText, text: rollText});

								return `{${tag} ${[rollText, displayText || "", name || "", ...others].join("|")}}`;
							})
							.replace(/{(@dc) ([^}]+)}/gi, (...m) => {
								const [, tag, text] = m;
								let [dcText, displayText] = Renderer.splitTagByPipe(text);
								const originalDcText = dcText;

								dcText = this._pGetEntryDescription_getCleanDicePart(dcText, opts);
								displayText = this._pGetEntryDescription_getCleanDisplayPart({displayText, originalText: originalDcText, text: dcText});

								return `{${tag} ${[dcText, displayText || ""].join("|")}}`;
							})
						;
					},
				},
			);

			description = await UtilDataConverter.pGetWithDescriptionPlugins(
				() => Renderer.get().setFirstSection(true).render(
					{
						type: "entries",
						entries: cpyEntries,
					},
					opts.depth != null ? opts.depth : 2,
				),
			);
		}

		return description;
	}

	static _pGetEntryDescription_getCleanDicePart (str, opts) {
		return str
						.replace(/\bPB\b/gi, `@${SharedConsts.MODULE_ID_FAKE}.userchar.pb`)
						.replace(/\bsummonSpellLevel\b/gi, `${opts.summonSpellLevel ?? 0}`);
	}

	static _pGetEntryDescription_getCleanDisplayPart ({displayText, originalText, text}) {
				if (!displayText && originalText !== text) {
			displayText = originalText
								.replace(/\bsummonSpellLevel\b/gi, `the spell's level`);
		}
		return displayText;
	}

		static mutActorUpdate (actor, actorUpdate, entry, opts) {
		opts = opts || {};

		this._mutActorUpdate_mutFromSideDataMod(actor, actorUpdate, opts);
		this._mutActorUpdate_mutFromSideTokenMod(actor, actorUpdate, opts);
	}

	static _mutActorUpdate_mutFromSideDataMod (actor, actorUpdate, opts) {
		return this._mutActorUpdate_mutFromSideMod(actor, actorUpdate, opts, "actorDataMod", "data");
	}

	static _mutActorUpdate_mutFromSideTokenMod (actor, actorUpdate, opts) {
		return this._mutActorUpdate_mutFromSideMod(actor, actorUpdate, opts, "actorTokenMod", "token");
	}

	static _mutActorUpdate_mutFromSideMod (actor, actorUpdate, opts, sideProp, actorProp) {
		if (!opts.sideData || !opts.sideData[sideProp]) return;

		Object.entries(opts.sideData[sideProp])
			.forEach(([path, modMetas]) => this._mutActorUpdate_mutFromSideMod_handleProp(actor, actorUpdate, opts, sideProp, actorProp, path, modMetas));
	}

	static _mutActorUpdate_mutFromSideMod_handleProp (actor, actorUpdate, opts, sideProp, actorProp, path, modMetas) {
		const pathParts = path.split(".");

				if (path === "_") {
			modMetas.forEach(modMeta => {
				switch (modMeta.mode) {
					case "conditionals": {
						for (const cond of modMeta.conditionals) {
														
														window.PLUT_CONTEXT = {actor};

														if (cond.condition && !eval(cond.condition)) continue;

							Object.entries(cond.mod)
								.forEach(([path, modMetas]) => this._mutActorUpdate_mutFromSideMod_handleProp(actor, actorUpdate, opts, sideProp, actorProp, path, modMetas));

							break;
						}

						break;
					}

					default: throw new Error(`Unhandled mode "${modMeta.mode}"`);
				}
			});
			return;
		}

		const fromActor = MiscUtil.get(actor, "system", actorProp, ...pathParts);
		const fromUpdate = MiscUtil.get(actorUpdate, actorProp, ...pathParts);
		const existing = fromUpdate || fromActor;

		modMetas.forEach(modMeta => {
			switch (modMeta.mode) {
				case "appendStr": {
					const existing = MiscUtil.get(actorUpdate, actorProp, ...pathParts);
					const next = existing ? `${existing}${modMeta.joiner || ""}${modMeta.str}` : modMeta.str;
					MiscUtil.set(actorUpdate, actorProp, ...pathParts, next);
					break;
				}

				case "appendIfNotExistsArr": {
					const existingArr = MiscUtil.copy(existing || []);
					const out = [...existingArr];
					out.push(...modMeta.items.filter(it => !existingArr.some(x => CollectionUtil.deepEquals(it, x))));
					MiscUtil.set(actorUpdate, actorProp, ...pathParts, out);
					break;
				}

				case "scalarAdd": {
					MiscUtil.set(actorUpdate, actorProp, ...pathParts, modMeta.scalar + existing || 0);
					break;
				}

				case "scalarAddUnit": {
					const existingLower = `${existing || 0}`.toLowerCase();

					const handle = (toFind) => {
						const ix = existingLower.indexOf(toFind.toLowerCase());
						let numPart = existing.slice(0, ix);
						const rest = existing.slice(ix);
						const isSep = numPart.endsWith(" ");
						numPart = numPart.trim();

						if (!isNaN(numPart)) {
							const out = `${modMeta.scalar + Number(numPart)}${isSep ? " " : ""}${rest}`;
							MiscUtil.set(actorUpdate, actorProp, ...pathParts, out);
						} 					};

					if (!existing) MiscUtil.set(actorUpdate, actorProp, ...pathParts, `${modMeta.scalar} ${modMeta.unitShort || modMeta.unit}`);
					else if (modMeta.unit && existingLower.includes(modMeta.unit.toLowerCase())) {
						handle(modMeta.unit);
					} else if (modMeta.unitShort && existingLower.includes(modMeta.unitShort.toLowerCase())) {
						handle(modMeta.unitShort);
					} 					break;
				}

								case "setMax": {
					const existingLower = `${existing || 0}`.toLowerCase();
					let asNum = Number(existingLower);
					if (isNaN(asNum)) asNum = 0;
					const maxValue = Math.max(asNum, modMeta.value);
					MiscUtil.set(actorUpdate, actorProp, ...pathParts, maxValue);
					break;
				}

				case "set": {
					MiscUtil.set(actorUpdate, actorProp, ...pathParts, MiscUtil.copy(modMeta.value));
					break;
				}

				default: throw new Error(`Unhandled mode "${modMeta.mode}"`);
			}
		});
	}

	static _getProfBonusExpressionParts (str) {
														const parts = str.split(/([-+]\s*[^-+]+)/g).map(it => it.trim().replace(/\s*/g, "")).filter(Boolean);

		const [partsNumerical, partsNonNumerical] = parts.segregate(it => !isNaN(it));

		const totalNumerical = partsNumerical.map(it => Number(it)).sum();

		return {partsNumerical, partsNonNumerical, totalNumerical};
	}

	static _PassiveEntryParseState = class {
		constructor ({entry, img, name}, opts) {
			this._entry = entry;
			this._opts = opts;

			this.name = name;
			this.img = img;

						let {
				id,

				description,

				activationType,
				activationCost,
				activationCondition,

				saveAbility,
				saveDc,
				saveScaling,

				damageParts,

				attackBonus,

				requirements,

				actionType,

				durationValue,
				durationUnits,

				consumeType,
				consumeTarget,
				consumeAmount,

				formula,

				targetValue,
				targetUnits,
				targetType,

				rangeShort,
				rangeLong,
				rangeUnits,

				ability,

				usesValue,
				usesMax,
				usesPer,

				isProficient,

				foundrySystem,
				_foundryData,
				foundryFlags,
				_foundryFlags,
			} = opts;

			this.combinedFoundrySystem = DataConverter.getCombinedFoundrySystem(foundrySystem, _foundryData);
			this.combinedFoundryFlags = DataConverter.getCombinedFoundryFlags(foundryFlags, _foundryFlags);

			if (entry._foundryId && id && entry._foundryId !== id) throw new Error(`Item given two different IDs (${this.id} and ${id})! This is a bug!`);

			this.id = entry._foundryId || id;

			this.description = description;

			this.activationType = activationType;
			this.activationCost = activationCost;
			this.activationCondition = activationCondition;

			this.saveAbility = saveAbility;
			this.saveDc = saveDc;
			this.saveScaling = saveScaling;

			this.damageParts = damageParts;

			this.attackBonus = attackBonus;

			this.requirements = requirements;

			this.actionType = actionType;

			this.durationValue = durationValue;
			this.durationUnits = durationUnits;

			this.consumeType = consumeType;
			this.consumeTarget = consumeTarget;
			this.consumeAmount = consumeAmount;

			this.formula = formula;

			this.targetValue = targetValue;
			this.targetUnits = targetUnits;
			this.targetType = targetType;

			this.rangeShort = rangeShort;
			this.rangeLong = rangeLong;
			this.rangeUnits = rangeUnits;

			this.ability = ability;

			this.usesValue = usesValue; 			this.usesMax = usesMax; 			this.usesPer = usesPer;

			this.isProficient = isProficient;
			
						this.effectsParsed = [];

						this.flagsParsed = {};
		}

		async pInit ({isSkipDescription = false, isSkipImg = false} = {}) {
			if (!isSkipDescription && !this.description && !this._opts.isSkipDescription) {
				this.description = await DataConverter.pGetEntryDescription(this._entry, {depth: this._opts.renderDepth, summonSpellLevel: this._opts.summonSpellLevel});
			}

			if (!isSkipImg && this._opts.img) {
				this.img = await Vetools.pOptionallySaveImageToServerAndGetUrl(this._opts.img);
			}
		}
	};

		static async pGetItemActorPassive (entry, opts) {
		opts = opts || {};
		opts.modeOptions = opts.modeOptions || {};

				if (opts.mode === "object") opts.mode = "creature";

		const state = new this._PassiveEntryParseState(
			{
				entry,
				name: UtilApplications.getCleanEntityName(UtilDataConverter.getNameWithSourcePart(entry, {displayName: opts.displayName, isActorItem: true})),
			},
			opts,
		);
		await state.pInit();

		const strEntries = entry.entries ? JSON.stringify(entry.entries) : null;

				let rechargeOn = null;
		if (entry.name) {
			const mRecharge = /{@recharge( \d+)?}/gi.exec(entry.name);
			if (mRecharge) {
				rechargeOn = mRecharge[1] ? Number(mRecharge[1].trim()) : 6;
				state.name = state.name
					.replace(/\(Recharge \d+(–\d+)?\)/gi, "")
					.trim()
					.replace(/[ ]+/g, " ")
				;
			}
		}
		
		this._pGetItemActorPassive_mutActivation({entry, opts, state});

		this._pGetItemActorPassive_mutUses({entry, opts, strEntries, state});

		this._pGetItemActorPassive_mutSave({entry, opts, strEntries, state});

				if (opts.mode === "player" && entry.entries) {
			UtilDataConverter.WALKER_READONLY_GENERIC.walk(
				entry.entries,
				{
					string: (str) => {
												if (state.durationValue || state.durationUnits) return;

																		str.replace(/(?:^|\W)lasts for (\d+) (minute|hour|day|month|year|turn|round)s?(?:\W|$)/gi, (...m) => {
							state.durationValue = Number(m[1]);
							state.durationUnits = m[2].toLowerCase();
						});

												str.replace(/(?:^|\W)for the next (\d+) (minute|hour|day|month|year|turn|round)s?(?:\W|$)/gi, (...m) => {
							state.durationValue = Number(m[1]);
							state.durationUnits = m[2].toLowerCase();
						});

												str.replace(/(?:^|\W)turned for (\d+) (minute|hour|day|month|year|turn|round)s?(?:\W|$)/gi, (...m) => {
							state.durationValue = Number(m[1]);
							state.durationUnits = m[2].toLowerCase();
						});

												str.replace(/(?:^|\W)this effect lasts for (\d+) (minute|hour|day|month|year|turn|round)s?(?:\W|$)/gi, (...m) => {
							state.durationValue = Number(m[1]);
							state.durationUnits = m[2].toLowerCase();
						});

												str.replace(/(?:^|\W)until the end of your next turn(?:\W|$)/gi, () => {
							state.durationValue = 1;
							state.durationUnits = "turn";
						});

												Renderer.stripTags(str).replace(/(?:^|\W)is \w+ by you for (\d+) (minute|hour|day|month|year|turn|round)s(?:\W|$)/gi, (...m) => {
							state.durationValue = Number(m[1]);
							state.durationUnits = m[2].toLowerCase();
						});
					},
				},
			);
		}
		
				this._pGetItemActorPassive_mutDamageAndFormula({entry, opts, strEntries, state});
		
				if (opts.mode === "creature" && strEntries && !state.targetValue && !state.targetUnits && !state.targetType) {
			const targetMeta = this._pGetItemActorPassive_getTargetMeta(strEntries);
			state.targetValue = targetMeta.targetValue || state.targetValue;
			state.targetUnits = targetMeta.targetUnits || state.targetUnits;
			state.targetType = targetMeta.targetType || state.targetType;
		}
		
				this._pGetItemActorPassive_mutActionType({entry, opts, state});
		
		this._pGetItemActorPassive_mutEffects({entry, opts, state});

				try { state.activationCondition = Renderer.stripTags(state.activationCondition); } catch (e) { console.error(...LGT, e); }

				if (
			(
				state.consumeType
				|| state.usesPer
				|| opts.additionalData?.["consume.type"]
				|| opts.additionalData?.consume?.type
				|| opts.additionalData?.["uses.per"]
				|| opts.additionalData?.uses?.per
			)
			&& !state.activationType
		) state.activationType = "special";
		
		state.name = state.name.trim().replace(/\s+/g, " ");
		if (!state.name) state.name = "(Unnamed)"; 
		const fauxEntrySourcePage = {...entry};
		if (opts.source != null) fauxEntrySourcePage.source = opts.source;
		if (opts.page != null) fauxEntrySourcePage.page = opts.page;

		this._pGetItemActorPassive_mutFlags({entry, opts, state});

		const {name: translatedName, description: translatedDescription, flags: translatedFlags} = this._getTranslationMeta({
			translationData: opts.translationData,
			name: state.name,
			description: state.description,
		});

		return {
			_id: state.id,
			id: state.id,
			name: translatedName,
			type: opts.fvttType || "feat",
			system: {
				source: opts.fvttSource !== undefined ? opts.fvttSource : UtilDataConverter.getSourceWithPagePart(fauxEntrySourcePage),
				description: {value: translatedDescription, chat: "", unidentified: ""},

				damage: {
					parts: state.damageParts ?? [],
					versatile: "",
				},
				duration: {
					value: state.durationValue,
					units: state.durationUnits,
				},
				range: {
					value: state.rangeShort,
					long: state.rangeLong,
					units: state.rangeUnits || ((state.rangeShort != null || state.rangeLong != null) ? "ft" : ""),
				},
				proficient: state.isProficient,
				requirements: state.requirements,

				save: {
					ability: state.saveAbility,
					dc: state.saveDc,
					scaling: state.saveScaling || "flat",
				},

				activation: {
					type: state.activationType,
					cost: state.activationCost,
					condition: state.activationCondition,
				},

				target: {
					value: state.targetValue,
					units: state.targetUnits,
					type: state.targetType,
				},

				uses: {
					value: state.usesValue,
					max: state.usesMax,
					per: state.usesPer,
				},
				ability: state.ability,
				actionType: state.actionType,
				attackBonus: state.attackBonus,
				chatFlavor: "",
				critical: {threshold: null, damage: ""},

				formula: state.formula,

				recharge: {
					value: rechargeOn,
					charged: rechargeOn != null,
				},

				consume: {
					type: state.consumeType,
					target: state.consumeTarget,
					amount: state.consumeAmount,
				},

				...(state.combinedFoundrySystem || {}),
				...(opts.additionalData || {}),
			},
			ownership: {default: 0},
			img: state.img,
			flags: {
				...translatedFlags,
				...state.flagsParsed,
				...(UtilCompat.getFeatureFlags({isReaction: ["reaction", "reactiondamage", "reactionmanual"].includes(state.activationType)})),
				...(state.combinedFoundryFlags || {}),
				...opts.additionalFlags,
			},
			effects: DataConverter.getEffectsMutDedupeId([
				...(opts.effects || []),
				...state.effectsParsed,
			]),
		};
	}

	static _pGetItemActorPassive_mutActivation ({entry, opts, state}) {
		this._pGetItemActorPassive_mutActivation_player({entry, opts, state});
		this._pGetItemActorPassive_mutActivation_creature({entry, opts, state});
	}

	static _pGetItemActorPassive_mutActivation_player ({entry, opts, state}) {
		if (opts.mode !== "player" || !entry.entries?.length) return;

		if (state.activationType || state.activationCost) {
			this._pGetItemActorPassive_mutActivation_playerCompat({entry, opts, state});
			return;
		}

		let isAction = false;
		let isBonusAction = false;
		let isReaction = false;

		UtilDataConverter.WALKER_READONLY_GENERIC.walk(
			entry.entries,
			{
				string: (str) => {
					if (state.activationType) return str;

					const sentences = Util.getSentences(str);
					for (const sentence of sentences) {
						if (/\b(?:as an action|can take an action|can use your action)\b/i.test(sentence)) {
							isAction = true;
							break;
						}

						if (/\bbonus action\b/i.test(sentence)) {
							isBonusAction = true;
							break;
						}

						const mReact = /\b(?:your reaction|this special reaction|as a reaction)\b/i.exec(sentence);
						if (mReact) {
							isReaction = true;

																					let preceding = sentence.slice(0, mReact.index).trim().replace(/,$/, "");
							const mCondition = /(^|\W)(?:if|when)(?:|\W)/i.exec(preceding);
							if (mCondition) {
								preceding = preceding.slice(mCondition.index + mCondition[1].length).trim();
								state.activationCondition = state.activationCondition || preceding;
							}

							break;
						}
					}
				},
			},
		);

						if (isAction) state.activationType = "action";
		else if (isBonusAction) state.activationType = "bonus";
		else if (isReaction) state.activationType = "reaction";

		if (state.activationType) state.activationCost = 1;

				if (!state.activationType) {
			UtilDataConverter.WALKER_READONLY_GENERIC.walk(
				entry.entries,
				{
					string: (str) => {
						if (state.activationType) return str;

						const sentences = Util.getSentences(str);

						for (const sentence of sentences) {
							if (/you can't use this feature again|once you use this feature/i.test(sentence)) state.activationType = "special";
						}
					},
				},
			);
		}

		this._pGetItemActorPassive_mutActivation_playerCompat({entry, opts, state});
	}

	static _pGetItemActorPassive_mutActivation_creature ({entry, opts, state}) {
		if (opts.mode !== "creature" || !entry.entries?.length || !entry.name) return;

		if (state.activationType || state.activationCost) {
			this._pGetItemActorPassive_mutActivation_creatureCompat({entry, opts, state});
			return;
		}

		MiscUtil.getWalker({
			isNoModification: true,
			keyBlocklist: MiscUtil.GENERIC_WALKER_ENTRIES_KEY_BLOCKLIST,
			isBreakOnReturn: true,
		}).walk(
			entry.entries,
			{
				string: str => {
					if (/\bbonus action\b/i.test(str)) {
						state.activationType = "bonus";
						state.activationCost = 1;
						return true;
					}
				},
			},
		);

		if (/^legendary resistance/i.test(entry.name)) {
			state.activationType = "special";
		}

		this._pGetItemActorPassive_mutActivation_creatureCompat({entry, opts, state});
	}

	static _pGetItemActorPassive_mutActivation_playerCompat ({entry, opts, state}) {
		if (!UtilCompat.isMidiQolActive() || state.activationType !== "reaction") return null;

					}

	static _pGetItemActorPassive_mutActivation_creatureCompat ({entry, opts, state}) {
		if (!UtilCompat.isMidiQolActive() || state.activationType !== "reaction") return;

				state.activationType = "reactionmanual";

				let firstEntry = entry.entries[0];
		if (typeof firstEntry !== "string") return;

		firstEntry
						.replace(/\bcauses the attack to miss\b/i, () => {
				state.activationType = "reaction";
				return "";
			})

			.replace(/\badds? (?<ac>\d+) to (its|their|his|her) AC\b/i, (...m) => {
				const argsDuration = UtilCompat.isDaeActive()
					? {flags: {[UtilCompat.MODULE_DAE]: {specialDuration: ["1Reaction"]}}}
					: {durationTurns: 1};

				state.effectsParsed.push(UtilActiveEffects.getGenericEffect({
					...argsDuration,
					key: `system.attributes.ac.bonus`,
					value: Number(m.last().ac),
					mode: CONST.ACTIVE_EFFECT_MODES.ADD,
					name: `${entry.name}`,
					icon: state.img,
					disabled: false,
					transfer: false,
					priority: UtilActiveEffects.PRIORITY_BONUS,
				}));

				state.targetType = state.targetType || "self";

				return "";
			})

			.replace(/\battack that would (?:hit|miss) (?:it|them|him|her|or miss)\b/i, () => {
				state.activationType = "reaction";
				return "";
			})
			.replace(/\bin response to being (?:hit|missed)\b/i, () => {
				state.activationType = "reaction";
				return "";
			})

			.replace(/\bafter taking damage from\b/i, () => {
				state.activationType = "reactiondamage";
				return "";
			})
			.replace(/\bIf [^.!?:]+ takes damage(?:,| while it)\b/i, () => {
				state.activationType = "reactiondamage";
				return "";
			})
			.replace(/\bIn response to taking damage\b/i, () => {
				state.activationType = "reactiondamage";
				return "";
			})
		;
	}

	static _pGetItemActorPassive_mutSave ({entry, opts, strEntries, state}) {
		this._pGetItemActorPassive_mutSave_player({entry, opts, strEntries, state});
		this._pGetItemActorPassive_mutSave_creature({entry, opts, strEntries, state});
	}

	static _pGetItemActorPassive_mutSave_player ({entry, opts, strEntries, state}) {
		if (opts.mode !== "player" || !entry.entries?.length) return;

		UtilDataConverter.WALKER_READONLY_GENERIC.walk(
			entry.entries,
			{
				object: (obj) => {
					if (obj.type !== "abilityDc") return obj;

					if (state.actionType && state.saveScaling) return obj;

					state.actionType = state.actionType || "save";
					state.saveScaling = obj.attributes[0]; 
					return obj;
				},
				string: (str) => {
					if (state.actionType && state.saveAbility && state.saveScaling) return str;

										str.replace(/8\s*\+\s*your proficiency bonus\s*\+\s*your (.*?) modifier/i, (...m) => {
						const customAbilities = [];
						m[1].replace(/(Strength|Dexterity|Constitution|Intelligence|Wisdom|Charisma)/i, (...m2) => {
							customAbilities.push(m2[1].toLowerCase().slice(0, 3));
						});
						if (!customAbilities.length) return;

						state.actionType = state.actionType || "save";
						state.saveScaling = customAbilities[0]; 					});
					
																				str.replace(/(Strength|Dexterity|Constitution|Intelligence|Wisdom|Charisma) saving throw against your (.*? )spell save DC/i, (...m) => {
						state.actionType = state.actionType || "save";
						state.saveAbility = state.saveAbility || m[1].toLowerCase().slice(0, 3);
						state.saveScaling = state.saveScaling || "spell";
					});
					
					str.replace(/(?:make a|succeed on a) (Strength|Dexterity|Constitution|Intelligence|Wisdom|Charisma) saving throw/gi, (...m) => {
						state.actionType = state.actionType || "save";
						state.saveAbility = state.saveAbility || m[1].toLowerCase().slice(0, 3);
						state.saveScaling = state.saveScaling || "spell";
					});

					return str;
				},
			},
		);
	}

	static _pGetItemActorPassive_mutSave_creature ({entry, opts, strEntries, state}) {
		if (opts.mode !== "creature" || !entry.entries?.length) return;

				const m = /{@dc (?<save>[^|}]+)(?:\|[^}]+)?}\s+(?<abil>Strength|Dexterity|Constitution|Intelligence|Wisdom|Charisma)/i.exec(strEntries);
		if (!m) return;

		const {partsNonNumerical, totalNumerical} = this._getProfBonusExpressionParts(m.groups.save);

		state.actionType = state.actionType === undefined
			? "save"
			: state.actionType;
		state.saveAbility = state.saveAbility === undefined
			? m.groups.abil.toLowerCase().slice(0, 3)
			: state.saveAbility;
		state.saveDc = state.saveDc === undefined
			? totalNumerical 			: state.saveDc;

		if (partsNonNumerical.length || opts.pb == null || opts.entity == null || Parser.ABIL_ABVS.some(ab => opts.entity[ab] == null || typeof opts.entity[ab] !== "number")) {
			state.saveScaling = state.saveScaling === undefined ? "flat" : state.saveScaling;
			return;
		}

						if (state.saveScaling) return;

						const fromAbil = state.saveDc - opts.pb - 8;
		const abilToBonus = Parser.ABIL_ABVS.map(ab => ({ability: ab, bonus: Parser.getAbilityModNumber(Renderer.monster.getSafeAbilityScore(opts.entity, ab, {isDefaultTen: true}))}));
		const matchingAbils = abilToBonus.filter(it => it.bonus === fromAbil);

		if (matchingAbils.length === 1) state.saveScaling = state.saveScaling || matchingAbils[0].ability;
		else state.saveScaling = "flat";
			}

	static _pGetItemActorPassive_mutUses ({entry, opts, strEntries, state}) {
		this._pGetItemActorPassive_mutUses_creature({entry, opts, strEntries, state});
		this._pGetItemActorPassive_mutUses_player({entry, opts, strEntries, state});
	}

	static _pGetItemActorPassive_mutUses_creature ({entry, opts, strEntries, state}) {
				if (opts.mode !== "creature" || !entry.name) return;

				const isLegendary = /legendary resistance/gi.test(state.name);

		let isFound = false;

		state.name = state.name
			.replace(/\(Recharges after a (?<restPart>[^)]+)\)/i, (...m) => {
				isFound = true;

				if (isLegendary) return "";

				if (state.usesValue === undefined) state.usesValue = 1;
				if (state.usesMax === undefined) state.usesMax = `${state.usesValue}`;

				const restPartClean = m.last().restPart.toLowerCase();
				if (/\bshort\b/.test(restPartClean)) {
					if (state.usesPer === undefined) state.usesPer = "sr";
				} else if (/\blong\b/.test(restPartClean)) {
					if (state.usesPer === undefined) state.usesPer = "lr";
				}

				return "";
			});

		if (state.usesPer === undefined) {
			state.name = state.name.replace(/\(\s*(\d+)\s*\/\s*(Day|Short Rest|Long Rest)\s*\)/i, (...m) => {
				isFound = true;

				if (isLegendary) return "";

				if (state.usesValue === undefined) state.usesValue = Number(m[1]);
				if (state.usesMax === undefined) state.usesMax = `${state.usesValue}`;

				if (state.usesPer === undefined) {
					const cleanTime = m[2].trim().toLowerCase();
					switch (cleanTime) {
						case "day": state.usesPer = "day"; break;
						case "short rest": state.usesPer = "sr"; break;
						case "long rest": state.usesPer = "lr"; break;
					}
				}

				return "";
			});
		}

		if (state.usesPer === undefined) {
			state.name = state.name.replace(/\(\s*(\d+)\s+Charges\s*\)/i, (...m) => {
				isFound = true;

				if (isLegendary) return "";

				if (state.usesValue === undefined) state.usesValue = Number(m[1]);
				if (state.usesMax === undefined) state.usesMax = `${state.usesValue}`;
				if (state.usesPer === undefined) state.usesPer = "charges";

				return "";
			});
		}

		if (!isFound) return;

				state.name = state.name.trim().replace(/ +/g, " ");

				if (state.activationType === undefined) state.activationType = state.activationType || "none";

				if (entry.entries && typeof entry.entries[0] === "string" && /^(?:If |When )/i.test(entry.entries[0].trim())) {
			if (state.activationCondition === undefined) state.activationCondition = entry.entries[0].trim();
		}
	}

	static _pGetItemActorPassive_mutUses_player ({entry, opts, strEntries, state}) {
		if (opts.mode !== "player" || !entry.entries) return;

				if (state.consumeType === "charges") return;

				const isShortRest = /\b(?:finish|complete) a short rest\b/.test(strEntries) || /\b(?:finish|complete) a short or long rest\b/.test(strEntries) || /\b(?:finish|complete) a short rest or a long rest\b/.test(strEntries) || /\b(?:finish|complete) a short or long rest\b/.test(strEntries);
		const isLongRest = !isShortRest && /\b(?:finish|complete) a long rest\b/.test(strEntries);

		if (state.usesPer === undefined) {
			if (isShortRest) state.usesPer = "sr";
			else if (isLongRest) state.usesPer = "lr";
		}
		
				const mAbilModifier = new RegExp(`a number of times equal to(?: (${Consts.TERMS_COUNT.map(it => it.tokens.join("")).join("|")}))? your (Strength|Dexterity|Constitution|Intelligence|Wisdom|Charisma) modifier(?: \\(minimum of (${Consts.TERMS_COUNT.map(it => it.tokens.join("")).join("|")})\\))?`, "i").exec(strEntries);
		if (mAbilModifier && opts.actor) {
			const abv = mAbilModifier[2].slice(0, 3).toLowerCase();
			const abilScore = MiscUtil.get(opts.actor, "system", "abilities", abv, "value");
			if (abilScore != null) {
				let mod = Parser.getAbilityModNumber(abilScore);
												let modFormula = `floor((@abilities.${abv}.value - 10) / 2)`;

				if (mAbilModifier[1]) {
					const multiplier = (Consts.TERMS_COUNT.find(it => it.tokens.join(" ") === mAbilModifier[1].trim().toLowerCase()) || {}).count || 1;
					mod = mod * multiplier;
					modFormula = `${modFormula} * ${multiplier}`;
				}

				if (mAbilModifier[3]) {
					const min = (Consts.TERMS_COUNT.find(it => it.tokens.join("") === mAbilModifier[3].trim().toLowerCase()) || {}).count || 1;
					mod = Math.max(min, mod);
					modFormula = `max(${min}, ${modFormula})`;
				}

				if (state.usesValue === undefined) state.usesValue = mod;
				if (state.usesMax === undefined) state.usesMax = modFormula;
			}
		}

		strEntries.replace(/(you can ([^.!?]+)) a number of times equal to(?<mult> twice)? your proficiency bonus/i, (...m) => {
			const mult = m.last().mult
				? (Consts.TERMS_COUNT.find(meta => CollectionUtil.deepEquals(meta.tokens, m.last().mult.trim().toLowerCase().split(/( )/g)))?.count || 1)
				: 1;
			if (state.usesValue === undefined) state.usesValue = opts.actor ? (UtilActors.getProficiencyBonusNumber({actor: opts.actor}) * mult) : null;
			if (state.usesMax === undefined) state.usesMax = `@prof${mult > 1 ? ` * ${mult}` : ""}`;
		});

		strEntries.replace(/you can use this (?:feature|ability) (?<mult>once|twice|[a-zA-Z]+ times)/i, (...m) => {
			const mult = (Consts.TERMS_COUNT.find(meta => CollectionUtil.deepEquals(meta.tokens, m.last().mult.trim().toLowerCase().split(/( )/g)))?.count || 1);
			if (state.usesValue === undefined) state.usesValue = mult;
			if (state.usesMax === undefined) state.usesMax = mult;
		});

				if (state.usesPer && !state.usesValue && (!state.usesMax || state.usesMax === "0")) {
			if (state.usesValue === undefined) state.usesValue = 1;
			if (state.usesMax === undefined) state.usesMax = `${state.usesValue}`;
		}
			}

	static _pGetItemActorPassive_getTargetMeta (strEntries) {
		let targetValue, targetUnits, targetType;
		let found = false;

		let tmpEntries = strEntries
						.replace(/exhales [^.]*a (?<size>\d+)-foot[- ](?<shape>cone|line)/, (...m) => {
				targetValue = Number(m.last().size);
				targetUnits = "ft";
				targetType = m.last().shape; 
				found = true;

				return "";
			});

		if (found) return {targetValue, targetUnits, targetType};

				tmpEntries = tmpEntries.replace(/(?<size>\d+)-foot-radius,? \d+-foot-tall cylinder/, (...m) => {
			targetValue = Number(m.last().size);
			targetUnits = "ft";
			targetType = "cylinder";

			found = true;
			return "";
		});

		if (found) return {targetValue, targetUnits, targetType};

								tmpEntries = tmpEntries.replace(/(?<size>\d+)-foot[- ]radius(?<ptSphere> sphere)?/, (...m) => {
			targetValue = Number(m.last().size);
			targetUnits = "ft";
			targetType = (m.last().ptSphere ? "sphere" : "radius");

			found = true;
			return "";
		});

		if (found) return {targetValue, targetUnits, targetType};

				tmpEntries = tmpEntries.replace(/(?<size>\d+)-foot[- ]cube/, (...m) => {
			targetValue = Number(m.last().size);
			targetUnits = "ft";
			targetType = "cube";

			found = true;
			return "";
		});

		if (found) return {targetValue, targetUnits, targetType};

				tmpEntries = tmpEntries.replace(/(?<size>\d+)-foot[- ]square/, (...m) => {
			targetValue = Number(m.last().size);
			targetUnits = "ft";
			targetType = "square";

			found = true;
			return "";
		});

		if (found) return {targetValue, targetUnits, targetType};

				tmpEntries = tmpEntries.replace(/(?<size>\d+)-foot line/, (...m) => {
			targetValue = Number(m.last().size);
			targetUnits = "ft";
			targetType = "line";

			found = true;
			return "";
		});

				tmpEntries = tmpEntries.replace(/(?<size>\d+)-foot cone/, (...m) => {
			targetValue = Number(m.last().size);
			targetUnits = "ft";
			targetType = "cone";

			found = true;
			return "";
		});

		if (found) return {targetValue, targetUnits, targetType};
		return {};
	}

	static _pGetItemActorPassive_mutDamageAndFormula ({entry, opts, strEntries, state}) {
		this._pGetItemActorPassive_mutDamageAndFormula_playerOrVehicle({entry, opts, strEntries, state});
		this._pGetItemActorPassive_mutDamageAndFormula_creature({entry, opts, strEntries, state});
	}

	static _pGetItemActorPassive_mutDamageAndFormula_playerOrVehicle ({entry, opts, state, strEntries}) {
		if (opts.mode !== "player" && opts.mode !== "vehicle") return;
		if (!entry.entries) return;

				let strEntriesNoDamageDice = strEntries;
		if (!state.damageParts?.length) {
			const {str, damageTupleMetas} = DataConverter.getDamageTupleMetas(strEntries, {summonSpellLevel: opts.summonSpellLevel});
			strEntriesNoDamageDice = str;

			const {damageParts: damageParts_, formula: formula_} = DataConverter.getDamagePartsAndOtherFormula(damageTupleMetas);

			state.damageParts = damageParts_;
			state.formula = state.formula ?? formula_;
		}
		
				if (state.formula == null) {
						strEntriesNoDamageDice.replace(/{(?:@dice|@scaledice) ([^|}]+)(?:\|[^}]+)?}/i, (...m) => {
				const [dice] = m[1].split("|");
				state.formula = dice;
			});
		}
			}

	static _pGetItemActorPassive_mutDamageAndFormula_creature ({entry, opts, strEntries, state}) {
		if (opts.mode !== "creature") return;
		if (!entry.entries?.length) return;

		if (!state.damageParts?.length && state.formula == null) {
			const str = entry.entries[0];
			if (typeof str !== "string") return;

			const {damageTupleMetas} = DataConverter.getDamageTupleMetas(str);
			const {damageParts, formula} = DataConverter.getDamagePartsAndOtherFormula(damageTupleMetas);

			state.damageParts = damageParts;
			state.formula = formula;
		}
	}

	static _pGetItemActorPassive_mutActionType ({entry, opts, state}) {
		this._pGetItemActorPassive_mutActionType_player({entry, opts, state});
		this._pGetItemActorPassive_mutActionType_creature({entry, opts, state});
	}

	static _pGetItemActorPassive_mutActionType_player ({entry, opts, state}) {
		if (state.actionType || opts.mode !== "player" || !entry.entries?.length) return;

		const walker = MiscUtil.getWalker({keyBlocklist: MiscUtil.GENERIC_WALKER_ENTRIES_KEY_BLOCKLIST, isNoModification: true, isBreakOnReturn: true});
		walker.walk(
			entry.entries,
			{
				string: str => {
					const mMeleeRangedWeaponAttack = /you\b[^.!?]*\bmake a (?<type>melee|ranged) weapon attack/i.exec(str);
					if (mMeleeRangedWeaponAttack) {
						state.actionType = mMeleeRangedWeaponAttack.groups.type.toLowerCase() === "melee" ? "mwak" : "rwak";
						return true;
					}

					const mMeleeRangedSpellAttack = /you\b[^.!?]*\bmake a (?<type>melee|ranged) spell attack/i.exec(str);
					if (mMeleeRangedSpellAttack) {
						state.actionType = mMeleeRangedSpellAttack.groups.type.toLowerCase() === "melee" ? "msak" : "rsak";
						return true;
					}

					const mHeal = /creature\b[^.!?]*\bregains\b[^.!?]*\bhit points?/i.exec(str);
					if (mHeal) {
						state.actionType = "heal";
						return true;
					}
				},
			},
		);

		state.actionType = state.actionType || "other";
	}

	static _pGetItemActorPassive_mutActionType_creature ({entry, opts, state}) {
		if (state.actionType || opts.mode !== "creature" || !entry.entries?.length) return;

		state.actionType = "other";
	}

	static _pGetItemActorPassive_mutEffects ({entry, opts, state}) {
		this._pGetItemActorPassive_mutEffects_player({entry, opts, state});
		this._pGetItemActorPassive_mutEffects_creature({entry, opts, state});
	}

	static _pGetItemActorPassive_mutEffects_player ({entry, opts, state}) {
		if (opts.mode !== "player" || !entry.entries?.length) return;

				void 0;
	}

	static _pGetItemActorPassive_mutEffects_creature ({entry, opts, state}) {
		if (opts.mode !== "creature" || !entry.entries?.length) return;

				if (!UtilCompat.isPlutoniumAddonAutomationActive()) return;

		const effects = UtilAutomation.getCreatureFeatureEffects({entry, img: state.img, entity: opts.entity});
		if (effects.length) state.effectsParsed.push(...effects);
	}

	static _pGetItemActorPassive_mutFlags ({entry, opts, state}) {
		this._pGetItemActorPassive_mutFlags_player({entry, opts, state});
		this._pGetItemActorPassive_mutFlags_creature({entry, opts, state});
	}

	static _pGetItemActorPassive_mutFlags_player ({entry, opts, state}) {
		if (opts.mode !== "player" || !entry.entries?.length) return;

				void 0;
	}

	static _pGetItemActorPassive_mutFlags_creature ({entry, opts, state}) {
		if (opts.mode !== "creature" || !entry.entries?.length) return;

		if (!UtilCompat.isPlutoniumAddonAutomationActive()) return;

		const flags = UtilAutomation.getCreatureFeatureFlags({
			entry,
			hasDamageParts: !!state.damageParts?.length,
			hasSavingThrow: !!state.saveDc,
		});

		foundry.utils.mergeObject(state.flagsParsed, flags);
	}

	static getMaxCasterProgression (...casterProgressions) {
		casterProgressions = casterProgressions.filter(Boolean);
		const ixs = casterProgressions.map(it => this._CASTER_PROGRESSIONS.indexOf(it)).filter(ix => ~ix);
		if (!ixs.length) return null;
		return this._CASTER_PROGRESSIONS[Math.min(...ixs)];
	}

	static getMaxCantripProgression (...casterProgressions) {
		const out = [];
		casterProgressions
			.filter(Boolean)
			.forEach(progression => {
				progression.forEach((cnt, i) => {
					if (out[i] == null) return out[i] = cnt;
					out[i] = Math.max(out[i], cnt);
				});
			});
		return out;
	}

		static async pFillActorSkillToolLanguageData (
		{
			existingProficienciesSkills,
			existingProficienciesTools,
			existingProficienciesLanguages,
			skillProficiencies,
			languageProficiencies,
			toolProficiencies,
			skillToolLanguageProficiencies,
			actorData,
			importOpts,
						titlePrefix,
		},
	) {
		skillToolLanguageProficiencies = this._pFillActorSkillToolLanguageData_getMergedProfs({
			skillProficiencies,
			languageProficiencies,
			toolProficiencies,
			skillToolLanguageProficiencies,
		});

		const formData = await Charactermancer_OtherProficiencySelect.pGetUserInput({
			titlePrefix,
			existingFvtt: {
				skillProficiencies: existingProficienciesSkills,
				toolProficiencies: existingProficienciesTools,
				languageProficiencies: existingProficienciesLanguages,
			},
			available: skillToolLanguageProficiencies,
		});
		if (!formData) return importOpts.isCancelled = true;
		if (formData === VeCt.SYM_UI_SKIP) return;

		this.doApplySkillFormDataToActorUpdate({
			existingProfsActor: existingProficienciesSkills,
			formData,
			actorData,
		});

		this.doApplyOtherProficienciesFormData({
			existingProfsActor: existingProficienciesLanguages,
			formData,
			formDataProp: "languageProficiencies",
			actorData,
			opts: {
				fnGetMappedItem: it => UtilActors.getMappedLanguage(it),
				fnGetMappedCustomItem: it => Renderer.splitTagByPipe(it)[0].toTitleCase(),
				actorTraitProp: "languages",
			},
		});

		this.doApplyToolFormDataToActorUpdate({
			existingProfsActor: existingProficienciesTools,
			formData,
			actorData,
		});
			}

		static _pFillActorSkillToolLanguageData_getMergedProfs (
		{
			skillProficiencies,
			languageProficiencies,
			toolProficiencies,
			skillToolLanguageProficiencies,
		},
	) {
		const hasAnySingles = skillProficiencies?.length || languageProficiencies?.length || toolProficiencies?.length;
		if (!hasAnySingles) return skillToolLanguageProficiencies;

		if (!skillToolLanguageProficiencies?.length) {
			const out = [];
			this._pFillActorSkillToolLanguageData_doMergeToSingleArray({
				targetArray: out,
				skillProficiencies,
				languageProficiencies,
				toolProficiencies,
			});
			return out;
		}

		if (skillToolLanguageProficiencies?.length && hasAnySingles) console.warn(...LGT, `Founds individual skill/language/tool proficiencies alongside combined skill/language/tool; these will be merged together.`);

		const out = MiscUtil.copy(skillToolLanguageProficiencies || []);
		this._pFillActorSkillToolLanguageData_doMergeToSingleArray({
			targetArray: out,
			skillProficiencies,
			languageProficiencies,
			toolProficiencies,
		});
		return out;
	}

	static _pFillActorSkillToolLanguageData_doMergeToSingleArray (
		{
			targetArray,
			skillProficiencies,
			languageProficiencies,
			toolProficiencies,
		},
	) {
		const maxLen = Math.max(
			targetArray?.length || 0,
			skillProficiencies?.length || 0,
			languageProficiencies?.length || 0,
			toolProficiencies?.length || 0,
		);
		for (let i = 0; i < maxLen; ++i) {
			const tgt = (targetArray[i] = {});

			const skillProfSet = skillProficiencies?.[i];
			const langProfSet = languageProficiencies?.[i];
			const toolProfSet = toolProficiencies?.[i];

						if (skillProfSet) {
				this._pFillActorSkillToolLanguageData_doAddProfType({
					targetObject: tgt,
					profSet: skillProfSet,
					validKeySet: new Set(Object.keys(Parser.SKILL_TO_ATB_ABV)),
					anyKeySet: new Set(["any"]),
					anyKeySuffix: "Skill",
				});
			}
			
						if (langProfSet) {
				this._pFillActorSkillToolLanguageData_doAddProfType({
					targetObject: tgt,
					profSet: langProfSet,
					anyKeySet: new Set(["any", "anyStandard"]),
					anyKeySuffix: "Language",
				});
			}
			
						if (toolProfSet) {
				this._pFillActorSkillToolLanguageData_doAddProfType({
					targetObject: tgt,
					profSet: toolProfSet,
					anyKeySet: new Set(["any"]),
					anyKeySuffix: "Tool",
				});
			}
					}
	}

	static _pFillActorSkillToolLanguageData_doAddProfType (
		{
			targetObject,
			profSet,
			validKeySet,
			anyKeySet,
			anyKeySuffix,
		},
	) {
		Object.entries(profSet)
			.forEach(([k, v]) => {
				switch (k) {
					case "choose": {
						if (v?.from?.length) {
							const choose = MiscUtil.copy(v);
							choose.from = choose.from.filter(kFrom => !validKeySet || validKeySet.has(kFrom));
							if (choose.from.length) {
								const tgtChoose = (targetObject.choose = targetObject.choose || []);
								tgtChoose.push(choose);
							}
						}
						break;
					}

					default: {
						if (anyKeySet && anyKeySet.has(k)) {
							targetObject[`${k}${anyKeySuffix}`] = MiscUtil.copy(v);
							break;
						}

						if (!validKeySet || validKeySet.has(k)) targetObject[k] = MiscUtil.copy(v);
					}
				}
			});
	}

		static async pFillActorSkillData (existingProfsActor, skillProficiencies, actorData, dataBuilderOpts, opts) {
		return this._pFillActorSkillToolData({
			existingProfsActor,
			proficiencies: skillProficiencies,
			actorData,
			dataBuilderOpts,
			opts,
			fnGetMapped: Charactermancer_OtherProficiencySelect.getMappedSkillProficiencies.bind(Charactermancer_OtherProficiencySelect),
			propProficiencies: "skillProficiencies",
			pFnApplyToActorUpdate: this.doApplySkillFormDataToActorUpdate.bind(this),
		});
	}

		static async pFillActorToolData (existingProfsActor, toolProficiencies, actorData, dataBuilderOpts, opts) {
		return this._pFillActorSkillToolData({
			existingProfsActor,
			proficiencies: toolProficiencies,
			actorData,
			dataBuilderOpts,
			opts,
			fnGetMapped: Charactermancer_OtherProficiencySelect.getMappedToolProficiencies.bind(Charactermancer_OtherProficiencySelect),
			propProficiencies: "toolProficiencies",
			pFnApplyToActorUpdate: this.doApplyToolFormDataToActorUpdate.bind(this),
		});
	}

	static async _pFillActorSkillToolData (
		{
			existingProfsActor,
			proficiencies,
			actorData,
			dataBuilderOpts,
			opts,
			fnGetMapped,
			propProficiencies,
			pFnApplyToActorUpdate,
		},
	) {
		opts = opts || {};

		if (!proficiencies) return {};
		proficiencies = fnGetMapped(proficiencies);

		const formData = await Charactermancer_OtherProficiencySelect.pGetUserInput({
			...opts,
			existingFvtt: {
				[propProficiencies]: existingProfsActor,
			},
			available: proficiencies,
		});
		if (!formData) return dataBuilderOpts.isCancelled = true;
		if (formData === VeCt.SYM_UI_SKIP) return;

		return pFnApplyToActorUpdate({existingProfsActor, formData, actorData});
	}

	static doApplySkillFormDataToActorUpdate ({existingProfsActor, formData, actorData}) {
		return this._doApplySkillToolFormDataToActorUpdate(
			{
				existingProfsActor,
				formData,
				actorData,
				mapAbvToFull: UtilActors.SKILL_ABV_TO_FULL,
				propFormData: "skillProficiencies",
				propActorData: "skills",
			},
		);
	}

	static doApplyToolFormDataToActorUpdate ({existingProfsActor, formData, actorData}) {
		return this._doApplySkillToolFormDataToActorUpdate(
			{
				existingProfsActor,
				formData,
				actorData,
				mapAbvToFull: UtilActors.TOOL_ABV_TO_FULL,
				propFormData: "toolProficiencies",
				propActorData: "tools",
			},
		);
	}

	static _doApplySkillToolFormDataToActorUpdate ({existingProfsActor, formData, actorData, mapAbvToFull, propFormData, propActorData}) {
		if (!formData?.data?.[propFormData]) return;

		const out = {};

				actorData[propActorData] = actorData[propActorData] || {};
		Object.entries(mapAbvToFull)
			.filter(([_, name]) => formData.data[propFormData][name])
			.forEach(([abv, name]) => {
				out[abv] = formData.data[propFormData][name];

				const maxValue = Math.max(
					(existingProfsActor[abv] || {}).value || 0,
					formData.data[propFormData][name] != null ? Number(formData.data[propFormData][name]) : 0,
					(actorData[propActorData][abv] || {}).value || 0,
				);

				const isUpdate = maxValue > (MiscUtil.get(actorData[propActorData], abv, "value") || 0);
				if (isUpdate) (actorData[propActorData][abv] = actorData[propActorData][abv] || {}).value = maxValue;
			});

		return out;
	}

		static async pFillActorLanguageData (existingProfsActor, importingProfs, data, importOpts, opts) {
		opts = opts || {};

		if (!importingProfs) return;
		importingProfs = Charactermancer_OtherProficiencySelect.getMappedLanguageProficiencies(importingProfs);

		const formData = await Charactermancer_OtherProficiencySelect.pGetUserInput({
			...opts,
			existingFvtt: {
				languageProficiencies: existingProfsActor,
			},
			available: importingProfs,
		});
		if (!formData) return importOpts.isCancelled = true;
		if (formData === VeCt.SYM_UI_SKIP) return;

		this.doApplyLanguageProficienciesFormDataToActorUpdate({existingProfsActor, formData, actorData: data});
	}

	static doApplyLanguageProficienciesFormDataToActorUpdate ({existingProfsActor, formData, actorData}) {
		this.doApplyOtherProficienciesFormData({
			existingProfsActor,
			formData,
			formDataProp: "languageProficiencies",
			actorData,
			opts: {
				fnGetMappedItem: it => UtilActors.getMappedLanguage(it),
				fnGetMappedCustomItem: it => Renderer.splitTagByPipe(it)[0].toTitleCase(),
				actorTraitProp: "languages",
			},
		});
	}

		static async pFillActorToolProfData (existingProfsActor, importingProfs, data, dataBuilderOpts, opts) {
		opts = opts || {};

		if (!importingProfs) return;
		importingProfs = Charactermancer_OtherProficiencySelect.getMappedToolProficiencies(importingProfs);

		const formData = await Charactermancer_OtherProficiencySelect.pGetUserInput({
			...opts,
			existingFvtt: {
				toolProficiencies: existingProfsActor,
			},
			available: importingProfs,
		});
		if (!formData) return dataBuilderOpts.isCancelled = true;
		if (formData === VeCt.SYM_UI_SKIP) return;

		this.doApplyToolProficienciesFormDataToActorUpdate({existingProfsActor, formData, actorData: data});
	}

	static doApplyToolProficienciesFormDataToActorUpdate ({existingProfsActor, formData, actorData}) {
		this.doApplyToolFormDataToActorUpdate({
			existingProfsActor: existingProfsActor,
			formData,
			actorData,
		});
	}

		static async pFillActorLanguageOrToolData (existingProfsLanguages, existingProfsTools, importingProfs, actorData, importOpts, opts) {
		opts = opts || {};

		if (!importingProfs) return;
		importingProfs = Charactermancer_OtherProficiencySelect.getMappedLanguageProficiencies(importingProfs);
		importingProfs = Charactermancer_OtherProficiencySelect.getMappedToolProficiencies(importingProfs);

		const formData = await Charactermancer_OtherProficiencySelect.pGetUserInput({
			...opts,
			existingFvtt: {
				languageProficiencies: existingProfsLanguages,
				toolProficiencies: existingProfsTools,
			},
			available: importingProfs,
		});
		if (!formData) return importOpts.isCancelled = true;
		if (formData === VeCt.SYM_UI_SKIP) return;

		this.doApplyOtherProficienciesFormData({
			existingProfsActor: existingProfsLanguages,
			formData,
			formDataProp: "languageProficiencies",
			actorData,
			opts: {
				fnGetMappedItem: it => UtilActors.getMappedLanguage(it),
				fnGetMappedCustomItem: it => Renderer.splitTagByPipe(it)[0].toTitleCase(),
				actorTraitProp: "languages",
			},
		});

		this.doApplyToolFormDataToActorUpdate({
			existingProfsActor: existingProfsTools,
			formData,
			actorData,
		});
	}

		static async pFillActorArmorProfData (existingProfsActor, importingProfs, data, importOpts, opts) {
		opts = opts || {};

		if (!importingProfs) return;
		importingProfs = Charactermancer_OtherProficiencySelect.getMappedArmorProficiencies(importingProfs);

		const formData = await Charactermancer_OtherProficiencySelect.pGetUserInput({
			...opts,
			existingFvtt: {
				armorProficiencies: existingProfsActor,
			},
			available: importingProfs,
		});
		if (!formData) return importOpts.isCancelled = true;
		if (formData === VeCt.SYM_UI_SKIP) return;

		this.doApplyArmorProficienciesFormDataToActorUpdate({existingProfsActor, formData, actorData: data});
	}

	static doApplyArmorProficienciesFormDataToActorUpdate ({existingProfsActor, formData, actorData}) {
		this.doApplyOtherProficienciesFormData({
			existingProfsActor,
			formData,
			formDataProp: "armorProficiencies",
			actorData,
			opts: {
				fnGetMappedItem: it => UtilActors.getMappedArmorProficiency(it),
				fnGetMappedCustomItem: it => Renderer.splitTagByPipe(it)[0].toTitleCase(),
				actorTraitProp: "armorProf",
			},
		});
	}

		static async pFillActorWeaponProfData (existingProfsActor, importingProfs, data, importOpts, opts) {
		opts = opts || {};

		if (!importingProfs) return;
		importingProfs = Charactermancer_OtherProficiencySelect.getMappedWeaponProficiencies(importingProfs);

		const formData = await Charactermancer_OtherProficiencySelect.pGetUserInput({
			...opts,
			existingFvtt: {
				weaponProficiencies: existingProfsActor,
			},
			available: importingProfs,
		});
		if (!formData) return importOpts.isCancelled = true;
		if (formData === VeCt.SYM_UI_SKIP) return;

		this.doApplyWeaponProficienciesFormDataToActorUpdate({existingProfsActor, formData, actorData: data});
	}

	static doApplyWeaponProficienciesFormDataToActorUpdate ({existingProfsActor, formData, actorData}) {
		this.doApplyOtherProficienciesFormData({
			existingProfsActor,
			formData,
			formDataProp: "weaponProficiencies",
			actorData,
			opts: {
				fnGetMappedItem: it => UtilActors.getMappedWeaponProficiency(it),
				fnGetMappedCustomItem: it => Renderer.splitTagByPipe(it)[0].toTitleCase(),
				actorTraitProp: "weaponProf",
			},
		});
	}

		static doApplyOtherProficienciesFormData ({existingProfsActor, formData, formDataProp, actorData, opts}) {
		if (!formData?.data?.[formDataProp]) return false;

		existingProfsActor = existingProfsActor || {};

		const formDataSet = formData.data[formDataProp];

		if (!Object.keys(formDataSet).length) return false;
		const cpyFormDataSet = MiscUtil.copy(formDataSet);

		const profSet = new Set();
		Object.keys(cpyFormDataSet).filter(k => cpyFormDataSet[k]).forEach(k => profSet.add(k));

				const mappedValidItems = new Set();
		const customItems = [];

				(existingProfsActor.value || []).forEach(it => mappedValidItems.add(it));
		(existingProfsActor.custom || "").split(";").map(it => it.trim()).filter(Boolean).forEach(it => this._doApplyFormData_doCheckAddCustomItem(customItems, it));

				const existingProfsActorData = MiscUtil.get(actorData, "traits", opts.actorTraitProp);
		(existingProfsActorData?.value || []).forEach(it => mappedValidItems.add(it));
		(existingProfsActorData?.custom || "").split(";").map(it => it.trim()).filter(Boolean).forEach(it => this._doApplyFormData_doCheckAddCustomItem(customItems, it));

				profSet.forEach(it => {
			const mapped = opts.fnGetMappedItem ? opts.fnGetMappedItem(it) : it;
			if (mapped) mappedValidItems.add(mapped);
			else {
				const toAdd = opts.fnGetMappedCustomItem ? opts.fnGetMappedCustomItem(it) : it.toTitleCase();
				this._doApplyFormData_doCheckAddCustomItem(customItems, toAdd);
			}
		});

				const dataTarget = MiscUtil.set(actorData, "traits", opts.actorTraitProp, {});
		dataTarget.value = [...mappedValidItems].map(it => it.toLowerCase()).sort(SortUtil.ascSortLower);
		dataTarget.custom = customItems.join(";");
	}

	static _doApplyFormData_doCheckAddCustomItem (customItems, item) {
		const cleanItem = item.trim().toLowerCase();
		if (!customItems.some(it => it.trim().toLowerCase() === cleanItem)) customItems.push(item);
	}

	static doApplySavingThrowProficienciesFormDataToActorUpdate ({existingProfsActor, formData, actorData}) {
		if (!formData?.data?.savingThrowProficiencies) return;

		actorData.abilities = actorData.abilities || {};
		Parser.ABIL_ABVS
			.filter(ab => formData.data.savingThrowProficiencies[ab])
			.forEach(ab => {
				const maxValue = Math.max(
					existingProfsActor[ab]?.proficient || 0,
					formData.data.savingThrowProficiencies[ab] ? 1 : 0,
					actorData.abilities[ab]?.proficient || 0,
				);
				const isUpdate = maxValue > (MiscUtil.get(actorData.abilities, ab, "proficient") || 0);
				if (isUpdate) MiscUtil.set(actorData.abilities, ab, "proficient", maxValue);
			});
	}

		static async pFillActorImmunityData (existingProfsActor, importing, data, importOpts, opts) {
		opts = opts || {};

		const formData = await Charactermancer_DamageImmunitySelect.pGetUserInput({
			...opts,
			existingFvtt: {
				immune: existingProfsActor,
			},
			available: importing,
		});
		if (!formData) return importOpts.isCancelled = true;
		if (formData === VeCt.SYM_UI_SKIP) return;

		this.doApplyDamageImmunityFormDataToActorUpdate({existingProfsActor, formData, actorData: data});
	}

		static async pFillActorResistanceData (existingProfsActor, importing, data, importOpts, opts) {
		opts = opts || {};

		const formData = await Charactermancer_DamageResistanceSelect.pGetUserInput({
			...opts,
			existingFvtt: {
				resist: existingProfsActor,
			},
			available: importing,
		});
		if (!formData) return importOpts.isCancelled = true;
		if (formData === VeCt.SYM_UI_SKIP) return;

		this.doApplyDamageResistanceFormDataToActorUpdate({existingProfsActor, formData, actorData: data});
	}

		static async pFillActorVulnerabilityData (existingProfsActor, importing, data, importOpts, opts) {
		opts = opts || {};

		const formData = await Charactermancer_DamageVulnerabilitySelect.pGetUserInput({
			...opts,
			existingFvtt: {
				vulnerable: existingProfsActor,
			},
			available: importing,
		});
		if (!formData) return importOpts.isCancelled = true;
		if (formData === VeCt.SYM_UI_SKIP) return;

		this.doApplyDamageVulnerabilityFormDataToActorUpdate({existingProfsActor, formData, actorData: data});
	}

		static async pFillActorConditionImmunityData (existing, importing, data, importOpts, opts) {
		opts = opts || {};

		const formData = await Charactermancer_ConditionImmunitySelect.pGetUserInput({
			...opts,
			existingFvtt: {
				conditionImmune: existing,
			},
			available: importing,
		});
		if (!formData) return importOpts.isCancelled = true;
		if (formData === VeCt.SYM_UI_SKIP) return;

		this.doApplyConditionImmunityFormDataToActorUpdate({existingProfsActor: existing, formData, actorData: data});
	}

	static doApplyDamageImmunityFormDataToActorUpdate ({existingProfsActor, formData, actorData}) {
		this.doApplyOtherProficienciesFormData({
			existingProfsActor,
			formData,
			formDataProp: "immune",
			actorData,
			opts: {
				actorTraitProp: "di",
			},
		});
	}

	static doApplyDamageResistanceFormDataToActorUpdate ({existingProfsActor, formData, actorData}) {
		this.doApplyOtherProficienciesFormData({
			existingProfsActor,
			formData,
			formDataProp: "resist",
			actorData,
			opts: {
				actorTraitProp: "dr",
			},
		});
	}

	static doApplyDamageVulnerabilityFormDataToActorUpdate ({existingProfsActor, formData, actorData}) {
		this.doApplyOtherProficienciesFormData({
			existingProfsActor,
			formData,
			formDataProp: "vulnerable",
			actorData,
			opts: {
				actorTraitProp: "dv",
			},
		});
	}

	static doApplyConditionImmunityFormDataToActorUpdate ({existingProfsActor, formData, actorData}) {
		this.doApplyOtherProficienciesFormData({
			existingProfsActor,
			formData,
			formDataProp: "conditionImmune",
			actorData,
			opts: {
				fnGetMappedItem: it => it === "disease" ? "diseased" : it,
				actorTraitProp: "ci",
			},
		});
	}

		static async pFillActorExpertiseData (
		{
			existingProficienciesSkills,
			existingProficienciesTools,
			expertise,
			actorData,
			importOpts,
						titlePrefix,
		},
	) {
				const mergedExistingProficienciesSkills = existingProficienciesSkills ? MiscUtil.copy(existingProficienciesSkills) : existingProficienciesSkills;
		const mergedExistingProficienciesTools = existingProficienciesTools ? MiscUtil.copy(existingProficienciesTools) : existingProficienciesTools;

		if (mergedExistingProficienciesSkills && actorData.skills) {
			Object.entries(actorData.skills)
				.forEach(([key, meta]) => {
					if (!meta) return;

					mergedExistingProficienciesSkills[key] = mergedExistingProficienciesSkills[key] || MiscUtil.copy(meta);
					mergedExistingProficienciesSkills[key].value = Math.max(mergedExistingProficienciesSkills[key].value, meta.value);
				});
		}

		if (mergedExistingProficienciesSkills && actorData.tools) {
			Object.entries(actorData.tools)
				.forEach(([key, meta]) => {
					if (!meta) return;

					mergedExistingProficienciesTools[key] = mergedExistingProficienciesTools[key] || MiscUtil.copy(meta);
					mergedExistingProficienciesTools[key].value = Math.max(mergedExistingProficienciesTools[key].value, meta.value);
				});
		}
		
		const formData = await Charactermancer_ExpertiseSelect.pGetUserInput({
			titlePrefix,
			existingFvtt: {
				skillProficiencies: mergedExistingProficienciesSkills,
				toolProficiencies: mergedExistingProficienciesTools,
			},
			available: expertise,
		});
		if (!formData) return importOpts.isCancelled = true;
		if (formData === VeCt.SYM_UI_SKIP) return;

		this.doApplyExpertiseFormDataToActorUpdate({
			existingProfsActor: {
				skillProficiencies: existingProficienciesSkills,
				toolProficiencies: existingProficienciesTools,
			},
			formData,
			actorData: actorData,
		});
	}

	static doApplyExpertiseFormDataToActorUpdate ({existingProfsActor, formData, actorData}) {
		this.doApplySkillFormDataToActorUpdate({
			existingProfsActor: existingProfsActor.skillProficiencies,
			formData,
			actorData,
		});

		this.doApplyToolFormDataToActorUpdate({
			existingProfsActor: existingProfsActor.toolProficiencies,
			formData,
			actorData,
		});
	}

	static doApplySensesFormDataToActorUpdate ({existingSensesActor, existingTokenActor, formData, actorData, actorToken, configGroup}) {
		if (!Object.keys(formData?.data).length) return;

		const dataTarget = MiscUtil.getOrSet(actorData, "attributes", "senses", {});
		Object.assign(dataTarget, MiscUtil.copy(existingSensesActor));

		Object.entries(formData.data)
			.forEach(([sense, range]) => {
				if (!range) return dataTarget[sense] = Math.max(dataTarget[sense], 0);

				range = Config.getMetricNumberDistance({configGroup, originalValue: range, originalUnit: "feet"});
								range = Number(range.toFixed(2));

				if (!dataTarget[sense]) return dataTarget[sense] = range;
				dataTarget[sense] = Math.max(dataTarget[sense], range);
			});

		const units = Config.getMetricUnitDistance({configGroup, originalUnit: "ft"});
		if (Object.keys(dataTarget).length && (!dataTarget.units || units !== "ft")) dataTarget.units = units;

				let {dimSight: curDimSight} = existingTokenActor || {};
		if (curDimSight === 999) curDimSight = 0; 		if (!curDimSight) curDimSight = 0;
		if (isNaN(curDimSight)) curDimSight = 0;
		curDimSight = Number(curDimSight);

				if (!curDimSight) actorToken.dimSight = curDimSight;
		actorToken.vision = true;

		this.mutTokenSight({
			dataAttributesSenses: dataTarget,
			dataToken: actorToken,
		});
			}

		static mutTokenSight ({dataAttributesSenses, dataToken}) {
		if (!dataAttributesSenses) return {dataAttributesSenses, dataToken};

		if (dataAttributesSenses.darkvision) dataToken.dimSight = Math.max(dataToken.dimSight, dataAttributesSenses.darkvision);

				for (const prop of ["blindsight", "tremorsense", "truesight"]) {
			if (dataAttributesSenses[prop]) dataToken.brightSight = Math.max(dataToken.brightSight ?? 0, dataAttributesSenses[prop]);
		}

		return {dataAttributesSenses, dataToken};
	}

	static _RE_IS_VERSATILE = / (?:two|both) hands/i;
	static getDamageTupleMetas (str, {summonSpellLevel = 0} = {}) {
		const damageTupleMetas = [];

		const ixFirstDc = str.indexOf(`{@dc `);

		let ixLastMatch = null;
		let lenLastMatch = null;

								const strOut = str
			.replace(/(?:(?<dmgFlat>\d+)|\(?{@(?:dice|damage) (?<dmgDice1>[^|}]+)(?:\|[^}]+)?}(?:\s+[-+]\s+the spell's level)?(?: plus {@(?:dice|damage) (?<dmgDice2>[^|}]+)(?:\|[^}]+)?})?\)?)(?:\s+[-+]\s+[-+a-zA-Z0-9 ]*?)?(?: (?<dmgType>[^ ]+))? damage/gi, (...mDamage) => {
				const [fullMatch] = mDamage;
				const [ixMatch] = mDamage.slice(-2, -1);
				const {dmgFlat, dmgDice1, dmgDice2, dmgType} = mDamage.last();

				const dmgDice1Clean = dmgDice1 ? dmgDice1.split("|")[0] : null;
				const dmgDice2Clean = dmgDice2 ? dmgDice2.split("|")[0] : null;
				const dmgTypeClean = dmgType || "";

				const isFlatDamage = dmgFlat != null;
				let dmg = isFlatDamage
					? dmgFlat
					: dmgDice2Clean
						? `${dmgDice1Clean} + ${dmgDice2Clean}` : dmgDice1Clean;

								if (isFlatDamage) {
					const tokens = str.split(/( )/g);
					let lenTokenStack = 0;
					const tokenStack = [];
					for (let i = 0; i < tokens.length; ++i) {
						tokenStack.push(tokens[i]);
						lenTokenStack += tokens[i].length;

						if (lenTokenStack === ixMatch) {
							const lastFourTokens = tokenStack.slice(-4);
							if (/^by dealing$/i.test(lastFourTokens.join("").trim())) {
								return "";
							}
						}
					}
				}

								dmg = dmg.replace(/\bPB\b/gi, `@${SharedConsts.MODULE_ID_FAKE}.userchar.pb`);

								dmg = dmg.replace(/\bsummonSpellLevel\b/gi, `${summonSpellLevel ?? 0}`);

				const tupleMeta = {
					tuple: [dmg, dmgTypeClean],
					isOnFailSavingThrow: false,
					isAlternateRoll: false,
				};

								if (~ixFirstDc && ixMatch >= ixFirstDc) {
					tupleMeta.isOnFailSavingThrow = true;
				}

												if (
					damageTupleMetas.last()?.isAlternateRoll
					|| (
						damageTupleMetas.length
						&& /\bor\b/.test(str.slice(ixLastMatch + lenLastMatch, ixMatch))
						&& !this._RE_IS_VERSATILE.test(str.slice(ixMatch + fullMatch.length))
					)
				) {
					tupleMeta.isAlternateRoll = true;
				}

				damageTupleMetas.push(tupleMeta);

				ixLastMatch = ixMatch;
				lenLastMatch = fullMatch.length;

				return "";
			})
			.replace(/ +/g, " ");

		return {
			str: strOut, 			damageTupleMetas: damageTupleMetas.filter(it => it.tuple.length),
		};
	}

	static getDamagePartsAndOtherFormula (damageTupleMetas) {
		damageTupleMetas = damageTupleMetas || [];

		const damageTuples = [];
		const otherFormulaParts = [];

		damageTupleMetas.forEach(meta => {
			if (
				(!Config.get("import", "isUseOtherFormulaFieldForSaveHalvesDamage") || !meta.isOnFailSavingThrow)
				&& (!Config.get("import", "isUseOtherFormulaFieldForSaveHalvesDamage") || !meta.isAlternateRoll)
			) return damageTuples.push(meta.tuple);

			otherFormulaParts.push(`${meta.tuple[1] ? "(" : ""}${meta.tuple[0]}${meta.tuple[1] ? `)[${meta.tuple[1]}]` : ""}`);
		});

				if (!damageTuples.length) return {damageParts: damageTupleMetas.map(it => it.tuple), formula: ""};

		return {damageParts: damageTuples, formula: otherFormulaParts.join(" + ")};
	}

	static getSpeedValue (speeds, prop, configGroup) {
		if (speeds == null) return null;

		if (typeof speeds === "number") {
			return prop === "walk"
				? Config.getMetricNumberDistance({configGroup, originalValue: speeds, originalUnit: "feet"})
				: null;
		}

		const speed = speeds[prop];

		if (speed == null) return null;
				if (typeof speed === "boolean") return null;
		if (speed.number != null) return Config.getMetricNumberDistance({configGroup, originalValue: speed.number, originalUnit: "feet"});
		if (isNaN(speed)) return null;
		return Config.getMetricNumberDistance({configGroup, originalValue: Number(speed), originalUnit: "feet"});
	}

		static _SPEED_PROPS_IS_EQUAL_MAP = {
		burrow: "burrow",
		climb: "climb",
		fly: "fly",
		swim: "swim",
	};
	static async _pGetSpeedEffects (speeds, {actor, actorItem, iconEntity, iconPropCompendium, taskRunner = null} = {}) {
		if (speeds == null) return [];

		const icon = iconEntity && iconPropCompendium
			? await this._pGetSaveImagePath(iconEntity, {propCompendium: iconPropCompendium, taskRunner})
			: undefined;

				
		if (typeof speeds === "number") return [];

		const toMap = Object.entries(speeds)
			.filter(([k, v]) => this._SPEED_PROPS_IS_EQUAL_MAP[k] && v === true);

		if (!toMap.length) return [];

		return [
			...toMap.map(([k]) => {
				return UtilActiveEffects.getGenericEffect({
					key: `system.attributes.movement.${this._SPEED_PROPS_IS_EQUAL_MAP[k]}`,
					value: `@attributes.movement.walk`,
					mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
					name: `${k.toTitleCase()} Speed`,
					icon,
					disabled: false,
					priority: UtilActiveEffects.PRIORITY_BASE,
					originActor: actor,
					originActorItem: actorItem,
				});
			}),
		];
	}

	static isSpeedHover (speed) {
		if (typeof speed === "number") return false;
		return !!speed.canHover;
	}

	static getMovement (speed, {configGroup = null, propAllowlist = null} = {}) {
		return {
			burrow: (!propAllowlist || propAllowlist.has("burrow")) ? DataConverter.getSpeedValue(speed, "burrow", configGroup) : null,
			climb: (!propAllowlist || propAllowlist.has("climb")) ? DataConverter.getSpeedValue(speed, "climb", configGroup) : null,
			fly: (!propAllowlist || propAllowlist.has("fly")) ? DataConverter.getSpeedValue(speed, "fly", configGroup) : null,
			swim: (!propAllowlist || propAllowlist.has("swim")) ? DataConverter.getSpeedValue(speed, "swim", configGroup) : null,
			walk: (!propAllowlist || propAllowlist.has("walk")) ? DataConverter.getSpeedValue(speed, "walk", configGroup) : null,
			units: Config.getMetricUnitDistance({configGroup, originalUnit: "ft"}),
			hover: DataConverter.isSpeedHover(speed),
		};
	}

	static getParsedWeaponEntryData (imp, weap) {
		if (!(weap.entries && weap.entries[0] && typeof weap.entries[0] === "string")) return;

		const damageTupleMetas = [];
		let attackBonus = 0;

		const str = weap.entries[0];

		damageTupleMetas.push(...DataConverter.getDamageTupleMetas(str).damageTupleMetas);

		const {rangeShort, rangeLong} = DataConverter.getAttackRange(str);

		const mHit = /{@hit ([^|}]+)(?:\|[^}]+)?}/gi.exec(str);
		if (mHit) {
			const hitBonus = Number(mHit[1]);
			if (!isNaN(hitBonus)) {
				attackBonus = hitBonus;
			}
		}

		const {isAttack, isRecharge, actionType, attackTypes} = DataConverter.getAttackActionType(weap.name, str);

		return {
			damageTupleMetas,
			isAttack,
			isRecharge,
			rangeShort,
			rangeLong,
			actionType,
			attackBonus,
			attackTypes, 		};
	}

	static getAttackRange (str) {
		let rangeShort = null;
		let rangeLong = null;

				const mRange = /range (\d+)(?:\/(\d+))? ft/gi.exec(str);
		if (mRange) {
			rangeShort = Number(mRange[1]);
			if (mRange[2]) rangeLong = Number(mRange[2]);
		} else {
			const mReach = /reach (\d+) ft/gi.exec(str);
			if (mReach) {
				rangeShort = Number(mReach[1]);
			}
		}

		return {rangeShort, rangeLong};
	}

	static getAttackActionType (name, str) {
		const state = new class {
			constructor () {
				this.actionType = "";
				this.isAttack = false;
				this.isRecharge = false;
				this.attackTypes = "";
				this.isMelee = false;
				this.isRanged = false;
				this.isSpell = false;
			}
		}();

		this._getAttackActionType_attackTypes({name, str, state});

		if (name) {
			if (/{@recharge( \d+)?}/.test(name)) state.isRecharge = true;
		}

		return {...state};
	}

	static _getAttackActionType_attackTypes ({name, str, state}) {
		const mAtk = /{@atk (?<types>[^}]+)}/gi.exec(str);
		if (!mAtk) return;

		state.attackTypes = mAtk.groups.types;
		state.isAttack = true;

		state.isMelee = state.attackTypes.includes("m");
		state.isRanged = state.attackTypes.includes("r");
		state.isSpell = state.attackTypes.includes("s");

		if (state.isSpell && state.isMelee) return state.actionType = "msak";
		if (state.isSpell && state.isRanged) return state.actionType = "rsak";

		if (state.isMelee) return state.actionType = "mwak";
		if (state.isRanged) return state.actionType = "rwak";
	}

	static getActorDamageResImmVulnConditionImm (ent) {
		const out = {};

		const allDis = new Set();
		const bypassDis = new Set();
		let customDis = [];
		this._getActorDamageResImmVulnConditionImm_addDamageTypesOrConditionTypes({
			ent,
			validTypesArr: UtilActors.VALID_DAMAGE_TYPES,
			fnRender: Parser.getFullImmRes,
			prop: "immune",
			allSet: allDis,
			bypassSet: bypassDis,
			customStack: customDis,
		});

		out.di = {
			value: [...allDis],
			custom: customDis.join(", "),
			bypasses: [...bypassDis],
		};

		const allDrs = new Set();
		const bypassDrs = new Set();
		let customDrs = [];
		this._getActorDamageResImmVulnConditionImm_addDamageTypesOrConditionTypes({
			ent,
			validTypesArr: UtilActors.VALID_DAMAGE_TYPES,
			fnRender: Parser.getFullImmRes,
			prop: "resist",
			allSet: allDrs,
			bypassSet: bypassDrs,
			customStack: customDrs,
		});

		out.dr = {
			value: [...allDrs],
			custom: customDrs.join(", "),
			bypasses: [...bypassDrs],
		};

		const allDvs = new Set();
		const bypassDvs = new Set();
		let customDvs = [];
		this._getActorDamageResImmVulnConditionImm_addDamageTypesOrConditionTypes({
			ent,
			validTypesArr: UtilActors.VALID_DAMAGE_TYPES,
			fnRender: Parser.getFullImmRes,
			prop: "vulnerable",
			allSet: allDvs,
			bypassSet: bypassDvs,
			customStack: customDvs,
		});

		out.dv = {
			value: [...allDvs],
			custom: customDvs.join(", "),
			bypasses: [...bypassDvs],
		};

		const allCis = new Set();
		let customCis = [];
		this._getActorDamageResImmVulnConditionImm_addDamageTypesOrConditionTypes({
			ent,
			validTypesArr: UtilActors.VALID_CONDITIONS,
			fnRender: arr => Parser.getFullCondImm(arr, true),
			prop: "conditionImmune",
			allSet: allCis,
			customStack: customCis,
		});

		out.ci = {
			value: [...allCis],
			custom: customCis.join(", "),
		};

		return out;
	}

	static _getActorDamageResImmVulnConditionImm_addDamageTypesOrConditionTypes (
		{ent, validTypesArr, fnRender, prop, allSet, bypassSet, customStack},
	) {
		if (!ent[prop]) return;

		ent[prop].forEach(it => {
			if (validTypesArr.includes(it)) {
				allSet.add(it);
				return;
			}

			if (
				this._PROPS_DAMAGE_IMM_VULN_RES.has(prop)
				&& it[prop]
				&& it[prop] instanceof Array
				&& CollectionUtil.setEq(new Set(it[prop]), this._SET_PHYSICAL_DAMAGE)
				&& it.note
				&& it.cond
			) {
				const mNote = /\bnon[- ]?magical\b.*?(?:\baren't (?<bypass>silvered|adamantine)\b)?$/.exec(it.note);

				if (mNote) {
					bypassSet.add("mgc");

					switch ((mNote.groups.bypass || "").toLowerCase()) {
						case "silvered": bypassSet.add("sil"); break;
						case "adamantine": bypassSet.add("ada"); break;
					}

					it[prop].forEach(sub => allSet.add(sub));
					return;
				}
			}

			const asText = fnRender([it]);
			customStack.push(asText);
		});
	}

		static async _pGetSideLoadedMatch (ent, {propBrew, fnLoadJson, propJson, propsMatch = ["source", "name"], isSilent = false}) {
		const founds = [];

		if (UtilCompat.isPlutoniumAddonAutomationActive()) {
			const valsLookup = propsMatch.map(prop => ent[prop]).filter(Boolean);
			const found = await UtilCompat.getApi(UtilCompat.MODULE_PLUTONIUM_ADDON_AUTOMATION)
				.pGetExpandedAddonData({
					propJson,
					path: valsLookup,
					fnMatch: this._pGetAdditional_fnMatch.bind(this, propsMatch, ent),
					ent,
					isSilent,
				});
			if (found) founds.push(found);
		}

		if (propBrew) {
			const prerelease = await PrereleaseUtil.pGetBrewProcessed();
			const foundPrerelease = (MiscUtil.get(prerelease, propBrew) || [])
				.find(it => this._pGetAdditional_fnMatch(propsMatch, ent, it));
			if (foundPrerelease) founds.push(foundPrerelease);

			const brew = await BrewUtil2.pGetBrewProcessed();
			const foundBrew = (MiscUtil.get(brew, propBrew) || [])
				.find(it => this._pGetAdditional_fnMatch(propsMatch, ent, it));
			if (foundBrew) founds.push(foundBrew);
		}

		if (fnLoadJson && propJson) {
			const sideJson = await fnLoadJson();
			const found = (sideJson[propJson] || [])
				.find(it => this._pGetAdditional_fnMatch(propsMatch, ent, it));
			if (found) founds.push(found);
		}

		if (!founds.length) return null;
		if (founds.length === 1) return founds[0];

								const out = MiscUtil.copy(founds[0]);
		this._pGetSideLoadedMatch_mutMigrateData(out);
		delete out._merge;

		founds.slice(1)
			.forEach((found, i) => {
				this._pGetSideLoadedMatch_mutMigrateData(found);

				Object.entries(found)
					.filter(([prop]) => prop !== "_merge")
					.forEach(([prop, v]) => {
						if (out[prop] === undefined) return out[prop] = v;

						const prevFounds = founds.slice(0, i + 1);
						if (!prevFounds.every(foundPrev => foundPrev[prop] === undefined || foundPrev._merge?.[prop])) return;

						if (out[prop] == null) return out[prop] = v;
						if (typeof out[prop] !== "object") return out[prop] = v;

						if (out[prop] instanceof Array) {
							if (!(v instanceof Array)) throw new Error(`Could not _merge array and non-array`); 
							return out[prop] = [...out[prop], ...v];
						}

												out[prop] = foundry.utils.mergeObject(v, out[prop]);
					});
			});

		return out;
	}

			static _pGetSideLoadedMatch_mutMigrateData (found) {
		if (!found) return;

		if (found.system && !found.data) {
			found.data = found.system;
			delete found.system;
		}
	}

	static _pGetAdditional_fnMatch (propsMatch, entity, additionalDataEntity) {
		return propsMatch
			.every(prop => {
				if (typeof entity[prop] === "number" || typeof additionalDataEntity[prop] === "number") return Number(entity[prop]) === Number(additionalDataEntity[prop]);
				return `${(entity[prop] || "")}`.toLowerCase() === `${(additionalDataEntity[prop] || "").toLowerCase()}`;
			});
	}

	static async pGetSideLoadedType_ (ent, {propBrew, fnLoadJson, propJson, propsMatch, validTypes}) {
		let out = await this._pGetStarSideLoaded(ent, {propBrew, fnLoadJson, propJson, propsMatch, propFromEntity: "foundryType", propFromSideLoaded: "type"});
		if (!out) return out;
		out = out.toLowerCase().trim();
		if (validTypes && !validTypes.has(out)) return null;
		return out;
	}

	static async _pGetEffectsRawSideLoaded_ (ent, {propBrew, fnLoadJson, propJson, propsMatch}) {
		const out = await this._pGetStarSideLoaded(ent, {propBrew, fnLoadJson, propJson, propsMatch, propFromEntity: "foundryEffects", propFromSideLoaded: "effects"});

		if (!out?.length) return out;

		return out.filter(it => {
			if (!it) return false;
			if (!it.requires) return true;

			return Object.keys(it.requires).every(k => UtilCompat.isModuleActive(k));
		});
	}

	static async _pGetStarSideLoaded (ent, {propBrew, fnLoadJson, propJson, propsMatch, propFromEntity, propFromSideLoaded}) {
		const found = await this._pGetSideLoadedMatch(ent, {propBrew, fnLoadJson, propJson, propsMatch});
		return this._pGetStarSideLoadedFound(ent, {propFromEntity, propFromSideLoaded, found});
	}

	static async _pGetStarSideLoadedFound (ent, {propFromEntity, propFromSideLoaded, found}) {
		const fromEntity = ent[propFromEntity];

		if ((!found || !found[propFromSideLoaded]) && !fromEntity) return null;

				const out = MiscUtil.copy(found?.[propFromSideLoaded] ? found[propFromSideLoaded] : fromEntity);
		if (found?.[propFromSideLoaded] && fromEntity) {
			if (out instanceof Array) out.push(...MiscUtil.copy(fromEntity)); 			else Object.assign(out, MiscUtil.copy(fromEntity)); 		}

		return out;
	}

	static getImportedEmbed (importedEmbeds, itemData) {
		const importedEmbed = importedEmbeds.find(it => it.raw === itemData);

		if (!importedEmbed) {
			ui.notifications.warn(`Failed to link embedded entity for active effects! ${VeCt.STR_SEE_CONSOLE}`);
			console.warn(...LGT, `Could not find loaded item data`, itemData, `in imported embedded entities`, importedEmbeds);
			return null;
		}

		return importedEmbed;
	}

	static getConsumedSheetItem ({consumes, actor}) {
		const lookupNames = [
			consumes.name.toLowerCase().trim(),
			consumes.name.toLowerCase().trim().toPlural(),
		];

		return (actor?.items?.contents || [])
			.find(it => it.type === "feat" && lookupNames.includes(it.name.toLowerCase().trim()));
	}

	
	static mutEffectsDisabledTransfer (effects, configGroup, opts = {}) {
		if (!effects) return;

		return effects.map(effect => this.mutEffectDisabledTransfer(effect, configGroup, opts));
	}

	static mutEffectDisabledTransfer (
		effect,
		configGroup,
		{
			hintDisabled = null,
			hintTransfer = null,
		} = {},
	) {
		if (!effect) return;

		const disabled = Config.get(configGroup, "setEffectDisabled");
		switch (disabled) {
			case ConfigConsts.C_USE_PLUT_VALUE: effect.disabled = hintDisabled != null
				? hintDisabled
				: false;
				break;
			case ConfigConsts.C_BOOL_DISABLED: effect.disabled = false; break;
			case ConfigConsts.C_BOOL_ENABLED: effect.disabled = true; break;
		}

		const transfer = Config.get(configGroup, "setEffectTransfer");
		switch (transfer) {
			case ConfigConsts.C_USE_PLUT_VALUE: effect.transfer = hintTransfer != null
				? hintTransfer
				: true;
				break;
			case ConfigConsts.C_BOOL_DISABLED: effect.transfer = false; break;
			case ConfigConsts.C_BOOL_ENABLED: effect.transfer = true; break;
		}

		return effect;
	}

	
	static getEffectsMutDedupeId (effects) {
		if (!effects?.length) return effects;

		const usedDedupeIds = new Set();

		effects
			.forEach(eff => {
				const dedupeIdExisting = eff.flags?.[SharedConsts.MODULE_ID]?.dedupeId;
				if (dedupeIdExisting && !usedDedupeIds.has(dedupeIdExisting)) {
					usedDedupeIds.add(dedupeIdExisting);
					return;
				}

				if (!eff.name) throw new Error(`Effect did not have a name!`);

				const dedupeIdBase = dedupeIdExisting ?? Util.Slugify.slugifyFast.call(eff.name, {strict: true});
				if (!usedDedupeIds.has(dedupeIdBase)) {
					usedDedupeIds.add(dedupeIdBase);
					MiscUtil.set(eff, "flags", SharedConsts.MODULE_ID, "dedupeId", dedupeIdBase);
					return;
				}

				for (let i = 0; i < 99; ++i) {
					const dedupeId = `${dedupeIdBase}-${i}`;
					if (!usedDedupeIds.has(dedupeId)) {
						usedDedupeIds.add(dedupeId);
						MiscUtil.set(eff, "flags", SharedConsts.MODULE_ID, "dedupeId", dedupeId);
						return;
					}
				}

				throw new Error(`Could not find an available dedupeId for base "${dedupeIdBase}"!`);
			});

		return effects;
	}

	
	static _getTranslationData (
		{
			srdData,
		},
	) {
		if (
			!srdData
			|| !Config.get("integrationBabele", "isEnabled")
			|| !UtilCompat.isBabeleActive()
			|| !srdData.flags?.[UtilCompat.MODULE_BABELE]
		) return null;

		return {
			name: srdData.name,
			description: srdData.system?.description?.value,
			flags: {
				[UtilCompat.MODULE_BABELE]: {
					translated: !!srdData.flags[UtilCompat.MODULE_BABELE].translated,
					hasTranslation: !!srdData.flags[UtilCompat.MODULE_BABELE].hasTranslation,
				},
			},
		};
	}

	static _getTranslationMeta (
		{
			name,
			translationData,
			description,
		},
	) {
		if (translationData == null) return {name, description, flags: {}};

		const flags = {
			[UtilCompat.MODULE_BABELE]: {
				...(translationData.flags?.[UtilCompat.MODULE_BABELE] || {}),
				originalName: name,
			},
		};

		name = translationData.name;

		if (description && Config.get("integrationBabele", "isUseTranslatedDescriptions")) description = translationData.description || description;

		return {name, description, flags};
	}
}

DataConverter.SYM_AT = "<PLUT_SYM__AT>";

DataConverter.ITEM_TYPES_ACTOR_TOOLS = new Set(["AT", "GS", "INS", "T"]);
DataConverter.ITEM_TYPES_ACTOR_WEAPONS = new Set(["M", "R"]);
DataConverter.ITEM_TYPES_ACTOR_ARMOR = new Set(["LA", "MA", "HA", "S"]);

DataConverter._PROPS_DAMAGE_IMM_VULN_RES = new Set(["immune", "resist", "vulnerable"]);
DataConverter._SET_PHYSICAL_DAMAGE = new Set(["bludgeoning", "piercing", "slashing"]);

DataConverter._CASTER_PROGRESSIONS = [ 	"full",
	"artificer",
	"1/2",
	"1/3",
	"pact",
];

var DataConverter$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DataConverter: DataConverter
});

class DataConverterJournal extends DataConverter {
	static get _CONFIG_GROUP () { throw new Error(`Unimplemented!`); }

	static _mutOwnership (obj, opts) {
		if (opts.defaultOwnership != null) obj.ownership = {default: opts.defaultOwnership};
		else if (opts.isAddDefaultOwnershipFromConfig) obj.ownership = {default: Config.get(this._CONFIG_GROUP, "ownership")};
		if (opts.userOwnership) Object.assign(obj.ownership, opts.userOwnership);
	}

	static _getPages ({name, content, img, flags}) {
		const out = [
			content
				? {
					name,
					type: "text",
					text: {
						format: 1,
						content,
					},
				}
				: null,
			img
				? {
					name: `${name} (Image)`,
					type: "image",
					src: img,
				}
				: null,
		].filter(Boolean);

		out.forEach(page => {
			page.ownership = {default: CONST.DOCUMENT_OWNERSHIP_LEVELS.INHERIT};
			page.flags = flags ? MiscUtil.copy(flags) : {};
		});

		return out;
	}

	static async _pGetWithJournalDescriptionPlugins (pFn) {
		return UtilDataConverter.pGetWithDescriptionPlugins(async () => {
			const renderer = Renderer.get().setPartPageExpandCollapseDisabled(true);
			const out = await pFn();
			renderer.setPartPageExpandCollapseDisabled(false);
			return out;
		});
	}
}

var DataConverterJournal$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DataConverterJournal: DataConverterJournal
});

class DataConverterTable extends DataConverterJournal {
	static get _CONFIG_GROUP () { return "importTable"; }

	static _IMG_FALLBACK = `modules/${SharedConsts.MODULE_ID}/media/icon/hamburger-menu.svg`;

		static getTableGroupJournal (tg, rollableTables, opts) {
		opts = opts || {};

		Renderer.get().resetHeaderIndex();

		const out = {
			name: UtilApplications.getCleanEntityName(tg.name),
			ownership: {default: 0},
			pages: [
				this._getTableGroupJournalPage(tg, rollableTables, opts),
			],
		};

		if (opts.defaultOwnership != null) out.ownership = {default: opts.defaultOwnership};
		else if (opts.isAddDefaultOwnershipFromConfig) out.ownership = {default: Config.get("importTable", "ownership")};
		if (opts.userOwnership) Object.assign(out.ownership, opts.userOwnership);

		return out;
	}

		static _getTableGroupJournalPage (tg, rollableTables, opts) {
		opts = opts || {};

		const entry = {
			type: "list",
			items: rollableTables.map(it => `${DataConverter.SYM_AT}RollTable[${it.id}]{${it.caption || it.name}}`),
		};

		const page = {
			name: UtilApplications.getCleanEntityName(tg.name),
			type: "text",
			text: {
				format: 1,
				content: `<div>
					<p>The following tables belong to this group:</p>
					${Renderer.get().setFirstSection(true).render(entry).replace(new RegExp(DataConverter.SYM_AT, "g"), "@")}
					</div>`,
			},
			ownership: {default: 0},
		};

		if (opts.defaultOwnership != null) page.ownership = {default: opts.defaultOwnership};
		else if (opts.isAddDefaultOwnershipFromConfig) page.ownership = {default: Config.get("importTable", "ownership")};
		if (opts.userOwnership) Object.assign(out.ownership, opts.userOwnership);

		return page;
	}

		static async pGetDocumentJson (tbl, opts) {
		opts = opts || {};

		Renderer.get().resetHeaderIndex();

		if (opts.isImportAsJournalEntry) return this.pGetTableJournal(tbl, opts);

		if (this._isRollableTable(tbl)) return this._pGetTableRollableTable_pRollTable(tbl, opts);
		else return this._pGetTableRollableTable_pOtherTable(tbl, opts);
	}

	static _isRollableTable (tbl) {
		return this._isRollableTable_getEntriesTableRollMode(tbl) || Renderer.table.getAutoConvertedRollMode(tbl);
	}

	static _isRollableTable_getEntriesTableRollMode (tbl) {
		const headerRowMetas = Renderer.table.getHeaderRowMetas(tbl);

		if (!headerRowMetas || headerRowMetas.length < 2) return RollerUtil.ROLL_COL_NONE;

		const rollColMode = RollerUtil.getColRollType(headerRowMetas.last()[0]);
		if (!rollColMode) return RollerUtil.ROLL_COL_NONE;

				if (tbl.rows.some(r => r[0]?.type !== "cell" || r[0].roll == null || (r[0].roll.exact == null && r[0].roll.min == null && r[0].roll.max == null))) return RollerUtil.ROLL_COL_NONE;

		return rollColMode;
	}

	static _getTableDescription (tbl) {
		const headerRowMetas = Renderer.table.getHeaderRowMetas(tbl);
		if (!headerRowMetas?.length) return "";

		const ptHeaders = headerRowMetas
			.map(headerRowMeta => headerRowMeta.map(it => Renderer.stripTags(it)).join(" | "))
			.join("\n");

		return `Table columns:\n${ptHeaders}`;
	}

	static async _pGetTableRollableTable_pRollTable (tbl, opts) {
		opts = opts || {};

		const img = await this._pGetSaveImagePath(tbl, {propCompendium: "table", taskRunner: opts.taskRunner});

		const headerRowMetas = Renderer.table.getHeaderRowMetas(tbl);

		const toRoll = (headerRowMetas?.last()?.[0] || "").trim().replace(/{@dice ([^}]+)}/, "$1");

		const out = {
			name: UtilApplications.getCleanEntityName(tbl.name),
			formula: toRoll,
			description: this._getTableDescription(tbl),
			results: await tbl.rows.pSerialAwaitMap(async r => {
				const {rangeLow, rangeHigh} = this._getRollRange(toRoll, r[0]);

				return this.pGetTableResult({
					type: CONST.TABLE_RESULT_TYPES.TEXT,
					text: await this._pGetResultText(r.slice(1)),
					rangeLow,
					rangeHigh,
				});
			}),
			replacement: true,
			displayRoll: true,
			img,
			ownership: {default: 0},
			flags: {
				...this._getTableFlags(tbl, opts),
			},
		};

		if (opts.defaultOwnership != null) out.ownership = {default: opts.defaultOwnership};
		else if (opts.isAddDefaultOwnershipFromConfig) out.ownership = {default: Config.get("importTable", "ownership")};
		if (opts.userOwnership) Object.assign(out.ownership, opts.userOwnership);

		return out;
	}

	static _getRollRange (toRoll, cell) {
		if (cell.type === "cell" && cell.roll != null) {
			if (cell.roll.exact != null) {
				return {rangeLow: cell.roll.exact, rangeHigh: cell.roll.exact};
			}

						const rangeHigh = cell.roll.max < cell.roll.min ? this._getHighestRoll(toRoll) : cell.roll.max;
			return {rangeLow: cell.roll.min, rangeHigh: rangeHigh};
		}

		let rangeLow;
		let rangeHigh;

		const cellClean = String(cell).trim();

				const mBasic = /^(\d+)([-\u2013](\d+))?$/.exec(cellClean);
		if (mBasic) {
			if (mBasic[1] && !mBasic[2]) {
				rangeLow = Number(mBasic[1]);
								if (rangeLow === 0) rangeLow = this._getHighestRoll(toRoll);
				rangeHigh = rangeLow;
			} else {
				rangeLow = Number(mBasic[1]);
				rangeHigh = Number(mBasic[3]);

								if (rangeHigh < rangeLow) {
					rangeHigh = this._getHighestRoll(toRoll);
				}
			}

			return {rangeLow, rangeHigh};
		}

				const mOrLess = /^(\d+) or less$/i.exec(cellClean);
		if (mOrLess) {
			rangeLow = 1;
			rangeHigh = Number(mOrLess[1]);

			return {rangeLow, rangeHigh};
		}

				const mPlus = /^(\d+)\s*\+$/.exec(cellClean);
		rangeLow = Number(mPlus[1]);
		rangeHigh = rangeLow;

		return {rangeLow, rangeHigh};
	}

	static async _pGetResultText (cells) {
		const walker = MiscUtil.getWalker({keyBlocklist: MiscUtil.GENERIC_WALKER_ENTRIES_KEY_BLOCKLIST});

		let cpyCells = UtilDataConverter.getConvertedTagLinkEntries(MiscUtil.copy(cells));

		cpyCells = walker.walk(
			cpyCells,
			{
				string: str => {
					return Renderer.stripTags(this._getFoundryDiceTagged(str));
				},
			},
		);

		return cpyCells
			.map(it => Renderer.get().setFirstSection(true).render(it))
			.join(" | ");
	}

	static _getHighestRoll (toRoll) {
		const mFirstNum = /\d+/.exec(toRoll); 		if (mFirstNum) return Number(mFirstNum[0]);
		return 100; 	}

	static async _pGetTableRollableTable_pOtherTable (tbl, opts) {
		opts = opts || {};

		const img = await this._pGetSaveImagePath(tbl, {propCompendium: "table", taskRunner: opts.taskRunner});

		const out = {
			name: UtilApplications.getCleanEntityName(tbl.name),
			formula: `1d${tbl.rows ? tbl.rows.length : "1"}`,
			description: this._getTableDescription(tbl),
			results: await tbl.rows.pSerialAwaitMap(async (r, i) => {
				r = r.row || r;
				return this.pGetTableResult({
					type: CONST.TABLE_RESULT_TYPES.TEXT,
					text: await this._pGetResultText(r),
					rangeExact: i + 1,
				});
			}),
			replacement: true,
			displayRoll: true,
			img,
			ownership: {default: 0},
			flags: {
				...this._getTableFlags(tbl, opts),
			},
		};

		if (opts.defaultOwnership != null) out.ownership = {default: opts.defaultOwnership};
		else if (opts.isAddDefaultOwnershipFromConfig) out.ownership = {default: Config.get("importTable", "ownership")};
		if (opts.userOwnership) Object.assign(out.ownership, opts.userOwnership);

		return out;
	}

	static _getTableFlags (tbl) {
		return {
			[SharedConsts.MODULE_ID]: {
				page: UrlUtil.PG_TABLES,
				source: tbl.source,
				hash: UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_TABLES](tbl),
			},
		};
	}

		static async pGetTableResult (
		{
			type,
			text,
			resultId,
			collection,
			rangeLow,
			rangeHigh,
			rangeExact,
			img = "icons/svg/d20-black.svg",
		},
	) {
		if (rangeExact != null && (rangeLow != null || rangeHigh != null)) throw new Error(`Only one of "rangeExact" and "rangeLow/rangeHigh" may be specified!`);

		const range = [
			rangeLow ?? rangeExact,
			rangeHigh ?? rangeExact,
		];

		return {
			id: foundry.utils.randomID(),
			resultId,
			collection,
			type,
			text,
			img: await Vetools.pOptionallySaveImageToServerAndGetUrl(img),
			weight: 1,
			range,
			drawn: false,
			flags: {
				[SharedConsts.MODULE_ID]: {
					dedupeId: `${range[0]}-${range[1]}`,
				},
			},
		};
	}

	static getMaxTableRange (table) { return Math.max(0, ...table.results.map(it => it.data.range).flat()); }

	static _getFoundryDiceTagged (str) {
		return str.replace(/{@(?<tag>dice|damage|autodice) (?<text>[^}]+)}/gi, (...m) => {
			const isAuto = m.last().tag === "autodice";
			const [rollText, displayText] = Renderer.splitTagByPipe(m.last().text);
			const rollTextClean = Vetools.getCleanDiceString(rollText);
			return `[[${isAuto ? "" : "/r "}${rollTextClean}]]${displayText && rollTextClean.toLowerCase().trim() !== displayText.toLowerCase().trim() ? ` (${displayText})` : ""}`;
		});
	}

		static async pGetTableJournal (tbl, opts) {
		opts = opts || {};

		const cpy = MiscUtil.copy(tbl);
		delete cpy.name;
		cpy.type = cpy.type || "table";

		Renderer.get().resetHeaderIndex();

		const content = await this._pGetWithJournalDescriptionPlugins(() => {
			return `<div>${Renderer.get().setFirstSection(true).render(cpy)}</div>`;
		});

		const imgMeta = await this._pGetSaveImagePathMeta(tbl, {propCompendium: "table", taskRunner: opts.taskRunner});

		const name = UtilApplications.getCleanEntityName(UtilDataConverter.getNameWithSourcePart(tbl));
		const out = {
			name,
			pages: this._getPages({name, content, img: imgMeta?.isFallback ? null : imgMeta?.img}),
			ownership: {default: 0},
		};

		this._mutOwnership(out, opts);

		return out;
	}
}

var DataConverterTable$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DataConverterTable: DataConverterTable
});

class UtilWorldDataSourceSelector {
	static _SETTINGS_KEY = "data-source-selection";

	static async pInit () {
		await game.settings.register(
			SharedConsts.MODULE_ID,
			this._SETTINGS_KEY,
			{
				name: "World Data Source Selection",
				default: {},
				type: Object,
				scope: "world",
				onChange: data => {
									},
			},
		);
	}

	static async pSaveState (saveableState) {
		await game.settings.set(SharedConsts.MODULE_ID, this._SETTINGS_KEY, saveableState);
		ui.notifications.info(`Saved! Note that you (and connected players) may need to reload for any changes to take effect.`);
	}

	static loadState () { return UtilGameSettings.getSafe(SharedConsts.MODULE_ID, this._SETTINGS_KEY); }

	static isSourceSelectionActive () {
		return (!game.user.isGM && Config.get("dataSources", "isPlayerEnableSourceSelection"))
			|| (game.user.isGM && Config.get("dataSources", "isGmEnableSourceSelection"));
	}

	static isFiltered (dataSource) {
		if (!this.isSourceSelectionActive()) return false;

		const savedState = this.loadState();
		if (savedState == null) return false;

		return !savedState.state?.[dataSource.identifierWorld];
	}
}

class DuplicateMeta {
	constructor ({mode, existing}) {
		this.mode = mode;
		this.existing = existing;

				this.isSkip = mode === ConfigConsts.C_IMPORT_DEDUPE_MODE_SKIP && existing != null;
		this.isOverwrite = mode === ConfigConsts.C_IMPORT_DEDUPE_MODE_OVERWRITE && existing != null;
			}
}

class ImportSummary {
		constructor (
		{
			imported,
			status,
		},
	) {
		this.imported = imported;
		this.status = status;
	}

	static cancelled () { return new this({status: ConstsTaskRunner.TASK_EXIT_CANCELLED}); }
	static failed () { return new this({status: ConstsTaskRunner.TASK_EXIT_FAILED}); }
	static completedStub () { return new this({imported: [], status: ConstsTaskRunner.TASK_EXIT_COMPLETE}); }

	getPrimaryDocument () {
		return this.imported?.[0]?.embeddedDocument
			|| this.imported?.[0]?.document;
	}
}

class ImportedDocument {
		constructor (
		{
			name = null,
			isExisting = false,
			document = null,
			actor = null,
			embeddedDocument = null,
			pack = null,
		},
	) {
		if (document && embeddedDocument) throw new Error(`Only one of "document" and "embeddedDocument" may be specified!`);
		if (actor && pack) throw new Error(`Only one of "actor" and "pack" may be specified!`);

		this.name = name;
		this.isExisting = isExisting;
		this.document = document;
		this.actor = actor;
		this.embeddedDocument = embeddedDocument;
		this.pack = pack;
	}
}

class UtilDragDrop {
	static isCustomUuid (uuid) {
		if (!uuid) return false;
		return /^@[a-z][a-zA-Z]+\[[^\]]+]$/.test(uuid);
	}
}

class TaskClosure {
	constructor ({fnGetPromise}) {
		this.fnGetPromise = fnGetPromise;
	}
}

class _LogLineMeta {
	#id = null;
	#dispMessage = null;
	#wrpRow = null;

	constructor ({dispMessage, wrpRow}) {
		this.#id = CryptUtil.uid();
		this.#dispMessage = dispMessage;
		this.#wrpRow = wrpRow;
	}

	getId () { return this.#id; }

	updateMessage (html, {isError = false} = {}) {
		this.#dispMessage
			.html(html)
			.toggleClass(`veapp__msg-error`, isError)
			.toggleClass(`bold`, isError);
	}

	cleanup () {
		this.#wrpRow.remove();
	}

	getPod () {
		return {id: this.#id};
	}
}

class AppTaskRunner extends Application {
	#isClosable = false;
	#isCancelled = false;
	#$dispProgress = null;
	#$dispProgressNumber = null;
	#$wrpConsole = null;
	#$btnCancel = null;
	#ix = 0;
	#depth = 0;
	#logLineMetaPrevDepthZero = null;
	#logLineMetaPrevDepthOther = null;

		constructor (
		{
			tasks,
			titleInitial,
			titleComplete,
			isForceClose = false,
			isStopOnError = false,
		},
	) {
		super({
			title: titleInitial,
			template: `${SharedConsts.MODULE_LOCATION}/template/AppTaskRunner.hbs`,
			width: 500,
			height: 420,
			resizable: true,
		});
		this._tasks = tasks;
		this._titleComplete = titleComplete;
		this._isForceClose = !!isForceClose;
		this._isStopOnError = !!isStopOnError;
	}

	async _render (...args) {
		const out = await super._render(...args);

		this.#$dispProgress = this.element.find(`[data-name="disp-progress"]`);
		this.#$dispProgressNumber = this.element.find(`[data-name="disp-progress-number"]`);
		this.#$wrpConsole = this.element.find(`[data-name="wrp-console"]`);
		this.#$btnCancel = this.element.find(`[name="btn-cancel"]`).on("click", this._render_handleButtonClick_cancel.bind(this));

		return out;
	}

	_render_handleButtonClick_cancel () {
		this.#isClosable = true;
		this.#isCancelled = true;
	}

		_getHeaderButtons () { return []; }

		async close (...args) {
		if (!this.#isClosable) return;
		return super.close(...args);
	}

	
	async pRun () {
		await UtilApplications.pForceRenderApp(this, true);
		const out = await this._pRun_pDoRunTasks();
		this._pRun_doSwitchToCloseButton();
		return out;
	}

	async _pRun_pDoRunTasks () {
		try {
			for (; this.#ix < this._tasks.length; ++this.#ix) {
				if (this.#isCancelled) break;
				try {
					const result = await (await this._tasks[this.#ix].fnGetPromise({taskRunner: this}));
					if (this._isStopOnError && result?.status === ConstsTaskRunner.TASK_EXIT_FAILED) break;
				} catch (e) {
					console.error(...LGT, e);
					if (this._isStopOnError) break;
				}
				this._pRun_updateBarProgress();
			}

			this._pRun_updateBarProgress();

			this.#isClosable = true;
			if (this._isForceClose && !this.#isCancelled) this.close();
			else this._pRun_updateTitleText({text: this._titleComplete});

			return this.#isCancelled
				? ConstsTaskRunner.TASK_EXIT_CANCELLED
				: ConstsTaskRunner.TASK_EXIT_COMPLETE;
		} catch (e) {
			console.error(...LGT, e);
			ui.notifications.error(`Critical failure! ${VeCt.STR_SEE_CONSOLE}`);
			return ConstsTaskRunner.TASK_EXIT_FAILED;
		}
	}

	_pRun_doSwitchToCloseButton () {
		this.#isClosable = true;
		this.#$btnCancel.off("click").text("Close").on("click", () => this.close());
	}

	_pRun_updateBarProgress () {
		const fraction = Math.clamped((this.#ix + 1) / this._tasks.length, 0, 1);
		const pct = Math.round(fraction * 100);
		const isActive = pct !== 0 && pct !== 100;

		this.#$dispProgress.css({width: `${pct}%`});
		this.#$dispProgress.toggleClass("veapp-task-runner__wrp-progress-inner--active", isActive);
		this.#$dispProgressNumber.text(isActive && !this.#isCancelled ? `${(fraction * 100).toFixed(2)}%` : "");
	}

	_pRun_updateTitleText ({text}) {
		this.element.find(`.window-header .window-title`).text(text);
	}

	
		addLogLine (html, {isError = false, linkedLogLineMeta = null} = {}) {
		const logLineMeta = this.#depth ? this.#logLineMetaPrevDepthOther : this.#logLineMetaPrevDepthZero;

		if (
			(
				logLineMeta
				&& linkedLogLineMeta
				&& logLineMeta.getId() === linkedLogLineMeta.id
			)
			|| (
				logLineMeta
				&& this.#depth
			)
		) {
			logLineMeta.updateMessage(html, {isError});
			this._addLogLine_doCleanupDepthOther();
			return linkedLogLineMeta;
		}

		const dispMessage = e_({
			tag: "div",
			clazz: isError ? `veapp__msg-error bold` : "",
			html,
		});

		const wrpRow = e_({
			tag: "div",
			clazz: `px-1 py-1p w-100 split-v-center ${this.#depth ? "" : "veapp__list-row-hoverable"} ve-flex-v-center ${this.#depth ? "pl-3 ve-muted" : ""}`,
			children: [
								e_({
					tag: "div",
					clazz: "ve-flex-v-center",
					children: [
						this.#depth
							? e_({
								tag: "div",
								clazz: "trans-x-flip mr-1",
								text: `\u21b4`,
							})
							: null,
						dispMessage,
					],
				}),
								this.#depth
					? null
					: e_({
						tag: "div",
						clazz: "ve-small code ve-muted",
						text: `(${StrUtil.padNumber(this.#ix + 1, `${this._tasks.length}`.length, "\u00A0")}/${this._tasks.length})`,
					}),
			],
		});

		this._addLogLine_doCleanupDepthOther();
		this.#$wrpConsole.prepend(wrpRow);

		const out = new _LogLineMeta({dispMessage, wrpRow});
		return (this.#depth ? this.#logLineMetaPrevDepthOther = out : this.#logLineMetaPrevDepthZero = out).getPod();
	}

	_addLogLine_doCleanupDepthOther () {
		if (this.#depth || !this.#logLineMetaPrevDepthOther) return;
		this.#logLineMetaPrevDepthOther.cleanup();
		this.#logLineMetaPrevDepthOther = null;
	}

	
	pushDepth () { this.#depth++; }

	popDepth () {
		this.#depth--;
		if (this.#depth < 0) console.warn(...LGT, `Depth <0 (${this.#depth}); this is a bug!`);
	}
}

class AppTaskRunnerBasic extends AppTaskRunner {
	static _getClosure (
		{
			verbPresent,
			verbPast,
			verbInfinitive,
			fnGetLogName,
			pFnRun,
			dataItem,
		},
	) {
		return new TaskClosure({
			fnGetPromise: ({taskRunner}) => this._pRunWrapper({
				taskRunner,
				verbPresent,
				verbPast,
				verbInfinitive,
				fnGetLogName,
				pFnRun,
				dataItem,
			}),
		});
	}

	static async _pRunWrapper (
		{
			taskRunner,
			verbPresent,
			verbPast,
			verbInfinitive,
			fnGetLogName,
			pFnRun,
			dataItem,
		},
	) {
		const taskRunnerLineMeta = taskRunner.addLogLine(`${verbPresent.uppercaseFirst()} ${fnGetLogName({dataItem})}...`);
		try {
			await pFnRun({taskRunner, dataItem});
			taskRunner.addLogLine(`${verbPast.uppercaseFirst()} ${fnGetLogName({dataItem})}.`, {linkedLogLineMeta: taskRunnerLineMeta});
		} catch (e) {
			console.error(...LGT, e);
			taskRunner.addLogLine(`Failed to ${verbInfinitive} ${fnGetLogName({dataItem})}! ${VeCt.STR_SEE_CONSOLE}`, {isError: true, linkedLogLineMeta: taskRunnerLineMeta});
		}
	}

	constructor (
		{
			verbPresent,
			verbPast,
			verbInfinitive,
			fnGetLogName,
			pFnRun,
			data,
			...rest
		},
	) {
		super({
			tasks: data
				.map(dataItem => AppTaskRunnerBasic._getClosure({
					verbPresent,
					verbPast,
					verbInfinitive,
					fnGetLogName,
					pFnRun,
					dataItem,
				})),
			titleInitial: `${verbPresent.toTitleCase()}...`,
			titleComplete: `${verbInfinitive.toTitleCase()} Complete`,
			...rest,
		});
	}
}

class ImportEntryManager {
	constructor ({instance, ent, importOpts, dataOpts}) {
		this._instance = instance;
		this._ent = ent;
		this._importOpts = importOpts;
		this._dataOpts = dataOpts;

		this._taskRunner = importOpts?.taskRunner;
	}

	async pImportEntry () {
		const taskRunnerLineMeta = this._pImportEntry_doUpdateTaskRunner_preImport();

		try {
			const importSummary = await this._pImportEntry_pDoImport();
			this._pImportEntry_doUpdateTaskRunner_postImport_success({importSummary, taskRunnerLineMeta});
			UtilHooks.callAll(UtilHooks.HK_IMPORT_COMPLETE, importSummary);
			return importSummary;
		} catch (e) {
			this._pImportEntry_doUpdateTaskRunner_postImport_failure({taskRunnerLineMeta, e});
			return ImportSummary.failed();
		}
	}

	async _pImportEntry_pDoImport () {
		return this._instance._pImportEntry(this._ent, this._importOpts, this._dataOpts);
	}

	_pImportEntry_getTaskRunnerEntityName ({isPlainText = false} = {}) {
		const source = SourceUtil.getEntitySource(this._ent);

		if (isPlainText) return `${UtilEntity.getName(this._ent)} (${Parser.sourceJsonToAbv(source)})`;

		const sourceStyle = PrereleaseUtil.sourceJsonToStylePart(source) || BrewUtil2.sourceJsonToStylePart(source);
		return `<i>${UtilEntity.getName(this._ent)} (<span class="${Parser.sourceJsonToColor(source)}" ${sourceStyle ? `style="${sourceStyle}"` : ""}>${Parser.sourceJsonToAbv(source)}</span>)</i>`;
	}

	_pImportEntry_doUpdateTaskRunner_preImport () {
		if (!this._taskRunner) return null;

		const out = this._taskRunner.addLogLine(`Importing ${this._pImportEntry_getTaskRunnerEntityName()}...`);
		this._taskRunner.pushDepth();
		return out;
	}

	_pImportEntry_doUpdateTaskRunner_postImport_success ({importSummary, taskRunnerLineMeta}) {
		if (!this._taskRunner) return;

		this._taskRunner.popDepth();
		const {message, isError} = this._pImportEntry_doUpdateTaskRunner_postImport_getMessageMeta({importSummary});
		this._taskRunner.addLogLine(message, {isError, linkedLogLineMeta: taskRunnerLineMeta});
	}

	_pImportEntry_doUpdateTaskRunner_postImport_failure ({taskRunnerLineMeta, e}) {
		console.error(...LGT, `Task "${this._pImportEntry_getTaskRunnerEntityName({isPlainText: true})}" failed!`, e);

		if (!this._taskRunner) return;

		this._taskRunner.popDepth();
		this._taskRunner.addLogLine(`Failed to import ${this._pImportEntry_getTaskRunnerEntityName()}! ${VeCt.STR_SEE_CONSOLE}`, {isError: true, linkedLogLineMeta: taskRunnerLineMeta});
	}

	_pImportEntry_doUpdateTaskRunner_postImport_getMessageMeta ({importSummary}) {
		const taskRunnerName = this._pImportEntry_getTaskRunnerEntityName();

		switch (importSummary.status || ConstsTaskRunner.TASK_EXIT_COMPLETE) {
			case ConstsTaskRunner.TASK_EXIT_CANCELLED: return {message: `Import of ${taskRunnerName} was cancelled.`};
			case ConstsTaskRunner.TASK_EXIT_SKIPPED_DUPLICATE: return {message: `Import of ${taskRunnerName} was skipped (duplicate found).`};
			case ConstsTaskRunner.TASK_EXIT_COMPLETE_UPDATE_OVERWRITE: return {message: `Imported ${taskRunnerName}, overwriting existing.`};
			case ConstsTaskRunner.TASK_EXIT_COMPLETE_UPDATE_OVERWRITE_DUPLICATE: return {message: `Imported ${taskRunnerName}, overwriting existing (duplicate found).`};
			case ConstsTaskRunner.TASK_EXIT_FAILED: return {message: `Failed to import ${taskRunnerName}! ${VeCt.STR_SEE_CONSOLE}`, isError: true};

			case ConstsTaskRunner.TASK_EXIT_COMPLETE:
			default: return {message: `Imported ${taskRunnerName}.`};
		}
	}
}

class ImportList extends MixinHidableApplication(MixinFolderPathBuilder(Application)) {
		static async api_pImportEntry (entry, {isTemp = false, packId = null} = {}) {
		if (game.user.role < Config.get("import", "minimumRole")) throw new Error(`You do not have sufficient permissions!`);

		const pack = packId ? game.packs.get(packId) : null;
		if (!pack && packId) throw new Error(`Could not find pack "${pack}"`);

		if (isTemp && packId) throw new Error(`Options "isTemp" and "packId" are mutually exclusive!`);

		entry = await entry;
		if (entry == null) throw new Error(`Entry cannot be null/undefined!`);

		const imp = new this();
		await imp.pInit();
		imp.pack = pack;
		return imp.pImportEntry(entry, {isTemp});
	}
	
		static init () {
				UtilLibWrapper.addPatch(
			"Actor.fromDropData",
			this._lw_Actor_fromDropData,
			UtilLibWrapper.LIBWRAPPER_MODE_MIXED,
		);
		UtilLibWrapper.addPatch(
			"Item.fromDropData",
			this._lw_Item_fromDropData,
			UtilLibWrapper.LIBWRAPPER_MODE_MIXED,
		);
		UtilLibWrapper.addPatch(
			"JournalEntry.fromDropData",
			this._lw_JournalEntry_fromDropData,
			UtilLibWrapper.LIBWRAPPER_MODE_MIXED,
		);
		UtilLibWrapper.addPatch(
			"RollTable.fromDropData",
			this._lw_RollTable_fromDropData,
			UtilLibWrapper.LIBWRAPPER_MODE_MIXED,
		);
			}

	static async _lw_Actor_fromDropData (fn, ...args) {
		const out = await ImportList._pHandleDropGetImportedDoc(args[0]);
		if (out) return out;
		return fn(...args);
	}

	static async _lw_Item_fromDropData (fn, ...args) {
		const out = await ImportList._pHandleDropGetImportedDoc(args[0], {isTemp: true});
		if (out) return out;
		return fn(...args);
	}

	static async _lw_JournalEntry_fromDropData (fn, ...args) {
		const out = await ImportList._pHandleDropGetImportedDoc(args[0]);
		if (out) return out;
		return fn(...args);
	}

	static async _lw_RollTable_fromDropData (fn, ...args) {
		const out = await ImportList._pHandleDropGetImportedDoc(args[0]);
		if (out) return out;
		return fn(...args);
	}

	static preInit () {
		UtilLibWrapper.addPatch(
			"ActorDirectory.prototype._onDrop",
			this._lw_ActorDirectory_prototype__onDrop,
			UtilLibWrapper.LIBWRAPPER_MODE_MIXED,
		);

		UtilLibWrapper.addPatch(
			"Compendium.prototype._onDrop",
			this._lw_Compendium_prototype__onDrop,
			UtilLibWrapper.LIBWRAPPER_MODE_MIXED,
		);
	}

	static async _lw_ActorDirectory_prototype__onDrop (fn, ...args) {
		if (await ImportList._pHandleSidebarDrop(this, ...args)) return;
		return fn(...args);
	}

	static async _lw_Compendium_prototype__onDrop (fn, ...args) {
		const data = UtilEvents.getDropJson(args[0]);
		const out = await ImportList._pHandleDropGetImportedDoc(data, {pack: this.collection});
		if (out) return out;
		return fn(...args);
	}
	
	static get ID () { throw new Error("Unimplemented!"); }
	static get DISPLAY_NAME_TYPE_SINGLE () { throw new Error("Unimplemented!"); }
	static get DISPLAY_NAME_TYPE_PLURAL () { throw new Error("Unimplemented!"); }
	static get PROPS () { return null; }

	static IMPLS = new Map();

	static registerImpl (Impl) {
		if (!Impl.ID || this.IMPLS.get(Impl.ID)) throw new Error(`Duplicate or missing importer ID! Importer "${Impl.name}" ID was "${Impl.ID}".`);
		this.IMPLS.set(Impl.ID, Impl);
		ConfigConsts.registerImporter({id: Impl.ID, name: Impl.DISPLAY_NAME_TYPE_PLURAL});
		return this.IMPLS;
	}

	static get FOLDER_TYPE () { return "Item"; }

		static _isImporterDropEvent ({evt, data}) {
		if (!evt && !data) return false; 
		if (!data) data = UtilEvents.getDropJson(evt);

		if (data.subType !== UtilEvents.EVT_DATA_SUBTYPE__HOVER && data.subType !== UtilEvents.EVT_DATA_SUBTYPE__IMPORT) return false;

		return data.page && data.source && data.hash;
	}

	static async patcher_pHandleActorDrop (evt) {
		const data = UtilEvents.getDropJson(evt);

		if (!ImportList._isImporterDropEvent({evt})) return;

		const doc = await ImportList._pHandleDropGetImportedDoc(data, {isTemp: true});
		if (!doc) return;

								ImportList._suppressCreateSheetItemHookTimeStart = Date.now();

		const evtNxt = new DragEvent(
			"drop",
			{
				"dataTransfer": new DataTransfer(),
			},
		);
		evtNxt.dataTransfer.setData(
			"text/plain",
			JSON.stringify({
				type: doc.documentName,
				data: doc.toJSON(),
				uuid: `${doc.documentName}.${doc.id}`,
			}),
		);
		return this._onDrop(evtNxt);
	}

	static async _pHandleSidebarDrop (sidebar, evt) {
		const data = UtilEvents.getDropJson(evt);

		if (!ImportList._isImporterDropEvent({evt})) return;

		await ImportList._pHandleDropGetImportedDoc(data, {requiresDocumentName: sidebar.constructor.documentName});

		return true;
	}

	static async _pHandleDropGetImportedDoc (data, {isTemp = false, requiresDocumentName = null, pack = null} = {}) {
		if (ImportList._isImporterDropEvent({data})) return this._pHandleDropGetImportedDoc_importerDrop(...arguments);
		if (ImportList._isBadlyDroppedCustomUid({data})) return this._pHandleDropGetImportedDoc_badCustomUidDrop(...arguments);
		return null;
	}

	static async _pHandleDropGetImportedDoc_importerDrop (data, {isTemp = false, requiresDocumentName = null, pack = null} = {}) {
		const entity = await DataLoader.pCacheAndGet(data.page, data.source, data.hash, {isCopy: true});

		const {ChooseImporter} = await Promise.resolve().then(function () { return ChooseImporter$1; });

		return this._pHandleDropGetImportedDoc_getFromEntity({
			ChooseImporter,
			entity,
			page: data.page,
			pack,
			requiresDocumentName,
			isTemp,
		});
	}

		static _isBadlyDroppedCustomUid ({data}) {
		if (!data.uuid) return false;
		return UtilDragDrop.isCustomUuid(data.uuid);
	}

	static async _pHandleDropGetImportedDoc_badCustomUidDrop (data, {isTemp = false, requiresDocumentName = null, pack = null} = {}) {
		const [_, tag, pipeParts] = /^@([a-z][a-zA-Z]+)\[([^\]]+)]$/.exec(data.uuid);

		const {ChooseImporter} = await Promise.resolve().then(function () { return ChooseImporter$1; });

		const importerMeta = ChooseImporter.getImporterClassMeta(tag);
		if (!importerMeta) return null;

		const {page, pageHover, source, hash, hashHover} = Renderer.utils.getTagMeta(`@${tag}`, pipeParts);

		const entity = await DataLoader.pCacheAndGet(pageHover || page, source, hashHover || hash, {isCopy: true});

		return this._pHandleDropGetImportedDoc_getFromEntity({
			ChooseImporter,
			entity,
			page: pageHover || page,
			pack,
			requiresDocumentName,
			isTemp,
		});
	}

	static async _pHandleDropGetImportedDoc_getFromEntity (
		{
			ChooseImporter,
			entity,
			page,
			pack,
			requiresDocumentName,
			isTemp,
		},
	) {
		const importer = ChooseImporter.getImporter(entity?.__prop || page);
		if (pack) importer.pack = pack;
		await importer.pInit();

		if (requiresDocumentName != null && importer.constructor.FOLDER_TYPE !== requiresDocumentName) return null;

		const importSummary = await importer.pImportEntry(
			entity,
			{
				isTemp,
				defaultOwnership: UtilDataConverter.getTempDocumentDefaultOwnership({documentType: importer.constructor.FOLDER_TYPE}),
			},
		);

		return (importSummary.imported || [])
			.map(it => it.document)
			.filter(Boolean)[0];
	}

	static _initCreateSheetItemHook (
		{
			prop,
			importerName,
			isForce,
			pFnGetEntity,
			pFnImport,
			fnGetSuccessMessage,
			fnGetFailedMessage,
		},
	) {
										Hooks.on("preCreateItem", (item, itemData, options, itemId) => {
			if (item.parent?.documentName !== "Actor") return;

			const flags = itemData.flags?.[SharedConsts.MODULE_ID];
			if (!flags || flags?.propDroppable !== prop) return;
			if (flags.isStandardDragDrop || flags.isDirectImport) return;

												if (
				ImportList._suppressCreateSheetItemHookTimeStart != null
				&& (Date.now() - ImportList._suppressCreateSheetItemHookTimeStart) < 10_000
			) {
				ImportList._suppressCreateSheetItemHookTimeStart = null;
				return;
			}
			ImportList._suppressCreateSheetItemHookTimeStart = null;
			
			const actor = item.parent;

			this._pGetUseImporterDragDrop({isForce})
				.then(async isUseImporter => {
										if (isUseImporter == null) return;

					let ent;
					try {
						if (pFnGetEntity) ent = await pFnGetEntity(flags);
						else ent = await DataLoader.pCacheAndGet(flags.propDroppable, flags.source, flags.hash);
					} catch (e) {
						if (isUseImporter) {
							ui.notifications.error(`Failed to import "${ent?.name ?? flags.hash}"! ${VeCt.STR_SEE_CONSOLE}`);
							throw e;
						}
					}

					if (isUseImporter && !ent) {
						const msg = `Failed to import "${flags.hash}"!`;
						ui.notifications.error(`${msg} ${VeCt.STR_SEE_CONSOLE}`);
						throw new Error(`${msg} The original entity could not be found.`);
					}

					try {
						if (isUseImporter) {
							const imp = new this({actor});
							await imp.pInit();

							if (pFnImport) await pFnImport({ent, imp, flags});
							else await imp.pImportEntry(ent, {filterValues: flags.filterValues});

							const msg = fnGetSuccessMessage ? fnGetSuccessMessage({ent, flags}) : `Imported "${ent.name}" via ${importerName} Importer`;
							ui.notifications.info(msg);
							return;
						}

						itemData = MiscUtil.copy(itemData);
						MiscUtil.set(itemData.flags, SharedConsts.MODULE_ID, "isStandardDragDrop", true);
						await UtilActors.pAddActorItems(actor, [itemData], {}, {keepId: false, keepEmbeddedIds: false});
					} catch (e) {
						const msg = fnGetFailedMessage ? fnGetFailedMessage({ent, flags}) : `Failed to import "${ent.name}"! ${VeCt.STR_SEE_CONSOLE}`;
						ui.notifications.error(msg);
						throw e;
					}
				});

			return false;
		});
	}

	static async _pGetUseImporterDragDrop ({isForce}) {
		if (isForce) return true;

		const dragDropMode = Config.get("import", "dragDropMode");
		if (dragDropMode === ConfigConsts.C_IMPORT_DRAG_DROP_MODE_NEVER) return false;

		if (dragDropMode === ConfigConsts.C_IMPORT_DRAG_DROP_MODE_PROMPT) {
			return InputUiUtil.pGetUserBoolean({
				title: `Import via ${Config.get("ui", "isStreamerMode") ? "SRD Importer" : SharedConsts.MODULE_TITLE}? Note that this will ignore any in-Foundry modifications made to the item.`,
				textYes: "Yes, use the importer",
				textNo: "No, use normal drag-drop",
			});
		}

		return true;
	}

		static get defaultOptions () {
		return mergeObject(super.defaultOptions, {
			template: `${SharedConsts.MODULE_LOCATION}/template/ImportList.hbs`,
			width: 960,
			height: Util.getMaxWindowHeight(),
			resizable: true,
			title: `Import ${this.DISPLAY_NAME_TYPE_PLURAL}`,
		});
	}

	_isSkipContentFlatten = false;
		_dirsHomebrew = null;
		_titleSearch = "entry";
		_sidebarTab = null;
		_gameProp = null;
		_defaultFolderPath = null;
		_pageFilter = null;
		_page = null;
		_listInitialSortBy = null;
		_isPreviewable = false;
		_isDedupable = false;
		_isNotDroppable = false;
		_configGroup = null;
		_isFolderOnly = false;
		_isNonCacheableInstance = null;
		_titleButtonRun = "Import";
		_namespace = null;
		_fnListSort = undefined;
		_pFnGetFluff = null;
		_isActorRadio = false;
		_isAlwaysRadio = false;
		_ClsCustomizer = null;
		static _DataConverter = null;

		constructor (externalData) {
		super();

						this._actor = externalData?.actor;
		this._table = externalData?.table;
		this._pack = null;
		this._packCache = null;
		this._packCacheFlat = null;

		this._isInit = false;
		this._content = null;
		this._list = null;
		this._listSelectClickHandler = null;

		this._$bntFilter = null;
		this._$btnReset = null;
		this._$btnFeelingLucky = null;
		this._$btnToggleSummary = null;
		this._$iptSearch = null;
		this._$dispNumVisible = null;
		this._$cbAll = null;
		this._$btnTogglePreviewAll = null;
		this._$wrpRun = null;
		this._$btnRun = null;
		this._$btnsRunAdditional = {};
		this._$wrpBtnsSort = null;
		this._$wrpList = null;
		this._$wrpMiniPills = null;
		
				this._userData = null;
	}

	get _isRadio () {
		return this._isAlwaysRadio
			|| (!!this._actor && this._isActorRadio);
	}

	get page () { return this._page; }
	set pack (val) { this._pack = val; }
	get isFolderOnly () { return this._isFolderOnly; }
	get isNonCacheableInstance () { return !!this._isNonCacheableInstance; }
	get isDedupable () { return !!this._isDedupable; }
	set userData (val) { this._userData = val; }

	get gameProp () { return this._gameProp; }
	get actor () { return this._actor; }
	get table () { return this._table; }
	get configGroup () { return this._configGroup; }

	get propsNamespace () {
		if (!this._namespace && !this.constructor.PROPS) throw new Error(`One of "PROPS" or "namespace" must be provided!`);
		return this._namespace || this.constructor.PROPS.join("_");
	}

	async pSetContent (val) {
				if (!this.constructor.PROPS?.length || this._isSkipContentFlatten) {
			this._content = val;
			return;
		}

		let content = [];
		Object.entries(val)
			.forEach(([k, arr]) => {
				if (!this.constructor.PROPS.includes(k)) return;
				content = [...content, ...arr];
			});
		this._content = content;
	}

	async pSyncStateFrom (that) {
		this._actor = that._actor;
		this._table = that._table;
		this._pack = that._pack;
		await this.pSetFolderPathSpec(that._folderPathSpec);
	}

	async _close_isAlwaysHardClose () {
		return !!this._isNonCacheableInstance;
	}

	async _close_doHardCloseTeardown () {
		if (this._pageFilter?.filterBox) this._pageFilter.filterBox.teardown();
	}

	isInvalidatedByConfigChange (configDiff) { return false; }

	async pPreRender () {}

	activateSidebarTab ({sidebarTab = null} = {}) {
		sidebarTab = sidebarTab || this._sidebarTab;

		if (this._table) ui.sidebar.activateTab("tables");
		if (this._pack) ui.sidebar.activateTab("compendium");
		else if (!this._actor && !this._table && sidebarTab) ui.sidebar.activateTab(sidebarTab);
	}

	async pInit () {
		if (this._isInit) return true;
		this._isInit = true;

				await this._pInit_folderPathSpec();
	}

	_getFullFolderPathSpecKey () { return `${ImportList._STO_K_FOLDER_PATH_SPEC}.${this._folderPathSpecKeyConstructorName}`; }
	get _folderPathSpecKeyConstructorName () { return this.constructor.name; }

	_colWidthName = 9;
	_colWidthSource = 2;

		getData () {
		return {
			isRadio: !!this._isRadio,
			isPreviewable: this._isPreviewable,
			isNotDroppable: this._isNotDroppable,
			titleButtonRun: this._titleButtonRun,
			titleSearch: this._titleSearch,
			...this._getData_cols(),
			rows: this._content.map((it, ix) => this._getData_row({it, ix})),
		};
	}

	_getData_cols () {
		return {
			cols: [
				...this._getData_cols_otherPre(),
				{
					name: "Name",
					width: this._colWidthName,
					field: "name",
				},
				...this._getData_cols_other(),
				{
					name: "Source",
					width: this._colWidthSource,
					field: "source",
					titleProp: "sourceLong",
					displayProp: "sourceShort",
					classNameProp: "sourceClassName",
					styleProp: "sourceStyle",
					rowClassName: "text-center",
				},
			],
		};
	}

	_getData_cols_otherPre () { return []; }
	_getData_cols_other () { return []; }

	_getData_row ({it, ix}) {
		if (this._pageFilter) this._pageFilter.constructor.mutateForFilters(it);

		return {
			name: it.name,
			source: it.source,
			sourceShort: Parser.sourceJsonToAbv(it.source),
			sourceLong: Parser.sourceJsonToFull(it.source),
			sourceClassName: Parser.sourceJsonToColor(it.source),
			sourceStyle: PrereleaseUtil.sourceJsonToStylePart(it.source) || BrewUtil2.sourceJsonToStylePart(it.source),
			__prop: it.__prop,
			...this._getData_row_mutGetAdditionalValues({it, ix}),
			ix,
		};
	}

	_getData_row_mutGetAdditionalValues ({it, ix}) { return {}; }

	_renderInner_doFindUiElements ($html) {
		const root = $html[0];

		const $wrpFilterControls = $(root.children[0]);
		this._$bntFilter = $wrpFilterControls.find(`[name="btn-filter"]`);
		this._$btnReset = $wrpFilterControls.find(`[name="btn-reset"]`);
		this._$btnFeelingLucky = $wrpFilterControls.find(`[name="btn-feeling-lucky"]`);
		this._$btnToggleSummary = $wrpFilterControls.find(`[name="btn-toggle-summary"]`);
		this._$iptSearch = $wrpFilterControls.find(`.search`);
		this._$dispNumVisible = $wrpFilterControls.find(`.lst__wrp-search-visible`);

		this._$wrpMiniPills = $(root.children[1]);

		const $wrpBtnsSort = $(root.children[2]);
		this._$cbAll = $wrpBtnsSort.find(`[name="cb-select-all"]`);
		this._$btnTogglePreviewAll = $wrpBtnsSort.find(`[name="btn-toggle-all-previews"]`);
		this._$wrpBtnsSort = $wrpBtnsSort;

		this._$wrpList = $(root.children[3]);

		this._$wrpRun = $(root.children[4]);
		this._$btnRun = this._$wrpRun.find(`[name="btn-run"]`);

		this._$wrpRun
			.find(`[name]`)
			.each((i, e) => {
				if (e.name === "btn-run") return;
				this._$btnsRunAdditional[e.name] = $(e);
			});
	}

	async _renderInner (data) {
		const $html = await super._renderInner(data);
		await this._renderInner_custom($html);
		return $html;
	}

	async _renderInner_custom ($html) {
		this._renderInner_doFindUiElements($html);

		this._renderInner_initRunButton();
		this._renderInner_initRunButtonsAdditional();

		this._renderInner_initSearchKeyHandlers();

		const doResetSearch = () => {
			if (this._$iptSearch) this._$iptSearch.val("");
			if (this._list) this._list.reset();
		};

		this._$btnReset.click(() => {
			doResetSearch();
		});

		this._renderInner_initFeelingLuckyButton();

		if (this._pageFilter) {
			await this._renderInner_pInitFilteredList();
			await this._renderInner_initPreviewsAndQuicksImportsAndDroppables();
		} else {
			this._renderInner_initList();
		}

		this._list.on("updated", () => this._$dispNumVisible.html(`${this._list.visibleItems.length}/${this._list.items.length}`));
		this._listSelectClickHandler.bindSelectAllCheckbox(this._$cbAll);
		ListUiUtil.bindPreviewAllButton(this._$btnTogglePreviewAll, this._list);

		doResetSearch();
	}

	_renderInner_initFeelingLuckyButton () {
		this._$btnFeelingLucky.click(() => {
			if (!this._list || !this._list.visibleItems.length) return;

			this._listSelectClickHandler.setCheckboxes({isChecked: false, isIncludeHidden: true, list: this._list});

			const listItem = RollerUtil.rollOnArray(this._list.visibleItems);
			if (!listItem) return;

			this._listSelectClickHandler.setCheckbox(listItem, {toVal: true});

			listItem.ele.scrollIntoView({block: "center"});
		});
	}

	_renderInner_initPreviewsAndQuicksImportsAndDroppables () {
		if (!this._isPreviewable && this._isNotDroppable) return;

		const items = this._list.items;
		const len = items.length;
		for (let i = 0; i < len; ++i) {
			const item = items[i];

			if (this._isPreviewable) {
				const eleControlsWrp = item.ele.firstElementChild.children[1];

				const btnShowHidePreview = eleControlsWrp.children[0];
				const btnImport = eleControlsWrp.children[1];

				this._renderInner_initPreviewButton(item, btnShowHidePreview);
				this._renderInner_initPreviewImportButton(item, btnImport);
			}

			if (!this._isNotDroppable) {
				this._renderInner_initDroppable(item);
			}
		}
	}

	_renderInner_initPreviewButton (item, btnShowHidePreview) {
		ListUiUtil.bindPreviewButton(this._page, this._content, item, btnShowHidePreview);
	}

	_renderInner_initPreviewImportButton (item, btnImport) {
		btnImport.addEventListener("click", async evt => {
			evt.stopPropagation();
			evt.preventDefault();

			if (this._isRadio) this.close();

			const toImport = this._content[item.ix];
			try {
				await this._pDoPreCachePack();
				let imported;
				try {
					imported = await this.pImportEntry(toImport);
				} finally {
					this._pHandleClickRunButton_doDumpPackCache();
				}
				if (!imported) return; 				UtilApplications.doShowImportedNotification(imported);
			} catch (e) {
				setTimeout(() => { throw e; });
				UtilApplications.doShowImportedNotification({entity: toImport, status: ConstsTaskRunner.TASK_EXIT_FAILED});
			}
		});
	}

	_renderInner_initDroppable (listItem) {
		listItem.ele.addEventListener("dragstart", evt => {
			const meta = {
				type: this.constructor.FOLDER_TYPE,
				subType: UtilEvents.EVT_DATA_SUBTYPE__IMPORT,
				page: this._page,
				source: listItem.values.source,
				hash: listItem.values.hash,
				name: listItem.name,
				tag: this._getAsTag(listItem),
			};
			evt.dataTransfer.setData("text/plain", JSON.stringify(meta));
		});
	}

		_renderInner_initRunButton () {
		this._$btnRun.click(() => this._pHandleClickRunButton());
	}

	_renderInner_initRunButtonsAdditional () {
		if (this._$btnsRunAdditional["btn-run-mods"]) this._$btnsRunAdditional["btn-run-mods"].click(() => this._pHandleClickRunButton({optsPostProcessing: {isUseMods: true}}));
	}

	_renderInner_initSearchKeyHandlers () {
		if (!this._$iptSearch) return;

		this._renderInner_initSearchKeyHandlers_enter();
	}

	_renderInner_initSearchKeyHandlers_enter () {
		this._$iptSearch.keydown(async evt => {
			if (evt.key !== "Enter") return;
			if (!this._list) return;

			evt.stopPropagation();
			evt.preventDefault();

			const li = this._list.visibleItems[0];
			if (!li) return;

			await this._pImportListItems({
				listItems: [li],
				isBackground: true,
			});
		});
	}

		async _pGetPreCustomizedEntries (entries) {
		return entries;
	}

	async _pFnPostProcessEntries (entries, {isUseMods = false} = {}) {
		if (!this._ClsCustomizer) return entries;

		const entriesPreCustomized = await this._pGetPreCustomizedEntries(entries);
		if (!isUseMods) return entriesPreCustomized;

		const customizer = new this._ClsCustomizer(entriesPreCustomized, {titleSearch: this._titleSearch, isActor: !!this._actor});
		await customizer.pInit();
		return customizer.pGetCustomizedEntries();
	}

	async _pHandleClickRunButton (
		{
			gameProp = null,
			sidebarTab = null,
			optsPostProcessing = {},
			optsImportEntry = {},
		} = {},
	) {
		if (!this._list) return;

		const listItems = this._list.items
			.filter(it => it.data.cbSel.checked);

		if (!listItems.length) return ui.notifications.warn(`Please select something to import!`);

		if (!this._pack && listItems.length > 100 && !Config.get("ui", "isDisableLargeImportWarning")) {
			const isContinue = await InputUiUtil.pGetUserBoolean({
				title: `Warning: Large Import`,
				htmlDescription: `You have selected ${listItems.length} ${listItems.length === 1 ? "entity" : "entities"} to import.<br>Importing a large number of entities may degrade game performance (consider importing to a compendium instead).<br>Do you wish to continue?`,
				textYesRemember: "Continue and Remember",
				textYes: "Continue",
				textNo: "Cancel",
				fnRemember: val => Config.set("ui", "isDisableLargeImportWarning", val),
			});
			if (isContinue == null || isContinue === false) return;
		}

		if (this._pack && !Config.get("ui", "isDisableLargeImportWarning") && (this._pack.index.size + listItems.length) > 500) {
			const isContinue = await InputUiUtil.pGetUserBoolean({
				title: `Warning: Large Compendium`,
				htmlDescription: `You have selected ${listItems.length} ${listItems.length === 1 ? "entity" : "entities"} to import${this._pack.index.size ? ` to a compendium with ${this._pack.index.size} existing document${this._pack.index.size !== 1 ? "s" : ""}` : ""}.<br>Importing a large number of documents to a single compendium may degrade game performance.<br>Do you wish to continue?`,
				textYesRemember: "Continue and Remember",
				textYes: "Continue",
				textNo: "Cancel",
				fnRemember: val => Config.set("ui", "isDisableLargeImportWarning", val),
			});
			if (isContinue == null || isContinue === false) return;
		}

		this.close();

		await this._pImportListItems({
			listItems,
			optsPostProcessing,
			optsImportEntry,
			gameProp,
			sidebarTab,
		});

		this._$cbAll.prop("checked", false);
		this._list.items.forEach(item => {
			item.data.cbSel.checked = false;
			item.ele.classList.remove("list-multi-selected");
		});
	}

	async _pImportListItems (
		{
			listItems,
			optsPostProcessing,
			optsImportEntry,
			gameProp,
			sidebarTab,

			isBackground = false,
		},
	) {
		gameProp = gameProp || this._gameProp;
		sidebarTab = sidebarTab || this._sidebarTab;

		let entries = listItems.map(li => this._content[li.ix]);
		entries = await this._pFnPostProcessEntries(entries, optsPostProcessing);
		if (entries == null) return;

		await this._pDoPreCachePack({gameProp});

		await (
			isBackground
				? this._pImportListItems_background({entries, optsImportEntry})
				: this._pImportListItems_foreground({entries, optsImportEntry})
		);

		this.activateSidebarTab({sidebarTab});
		if (!this._actor && !this._table && !this._pack) game[gameProp].render();

		this._pHandleClickRunButton_doDumpPackCache();
	}

	async _pImportListItems_background ({entries, optsImportEntry}) {
		for (const entry of entries) {
			try {
				const importedMeta = await this.pImportEntry(entry, optsImportEntry);
				UtilApplications.doShowImportedNotification(importedMeta);
			} catch (e) {
				UtilApplications.doShowImportedNotification({entity: entry, status: ConstsTaskRunner.TASK_EXIT_FAILED});
				console.error(e);
			}
		}
	}

	async _pImportListItems_foreground ({entries, optsImportEntry}) {
		await (
			new AppTaskRunner({
				tasks: [
					...entries
						.map(entry => {
							return new TaskClosure({
								fnGetPromise: async ({taskRunner}) => this.pImportEntry(entry, {taskRunner, ...optsImportEntry}),
							});
						}),
				],
				titleInitial: "Importing...",
				titleComplete: "Import Complete",
			})
		).pRun();
	}

		async _renderInner_pInitFilteredList () {
				this._list = new List({
			$iptSearch: this._$iptSearch,
			$wrpList: this._$wrpList,
			fnSort: this._fnListSort,
			sortByInitial: this._listInitialSortBy,
			syntax: this._renderInner_getListSyntax(),
		});
		SortUtil.initBtnSortHandlers(this._$wrpBtnsSort, this._list);
		this._listSelectClickHandler = new ListSelectClickHandler({list: this._list});

		await this._pageFilter.pInitFilterBox({
			$iptSearch: this._$iptSearch,
			$btnReset: this._$btnReset,
			$btnOpen: this._$bntFilter,
			$btnToggleSummaryHidden: this._$btnToggleSummary,
			$wrpMiniPills: this._$wrpMiniPills,
			namespace: this._getFilterNamespace(),
		});

		this._content.forEach(it => this._pageFilter.addToFilters(it));

		this._renderInner_absorbListItems();
		this._list.init();

		this._pageFilter.trimState();
		this._pageFilter.filterBox.render();

		await this._pPostFilterRender();

		this._pageFilter.filterBox.on(
			FilterBox.EVNT_VALCHANGE,
			this._handleFilterChange.bind(this),
		);

		this._handleFilterChange();
	}

	_renderInner_getListSyntax () {
		return new ListUiUtil.ListSyntax({
			fnGetDataList: () => this._content,
			pFnGetFluff: this._pFnGetFluff,
		}).build();
	}

		async _pPostFilterRender () {}

	async _pPostRenderOrShow () {
		await super._pPostRenderOrShow();
		if (this._$iptSearch) this._$iptSearch.focus();
	}

	_renderInner_initList () {
				this._list = new List({
			$iptSearch: this._$iptSearch,
			$wrpList: this._$wrpList,
			fnSort: this._fnListSort,
		});
		SortUtil.initBtnSortHandlers(this._$wrpBtnsSort, this._list);

		this._listSelectClickHandler = new ListSelectClickHandler({list: this._list});

		this._renderInner_absorbListItems();
		this._list.init();
	}

		_renderInner_absorbListItems () {
		this._list.doAbsorbItems(
			this._content,
			{
				fnGetName: it => it.name,
								fnGetValues: this._renderInner_absorbListItems_fnGetValues.bind(this),
				fnGetData: UtilList2.absorbFnGetData,
				fnBindListeners: it => this._renderInner_absorbListItems_isRadio
					? UtilList2.absorbFnBindListenersRadio(this._listSelectClickHandler, it)
					: UtilList2.absorbFnBindListeners(this._listSelectClickHandler, it),
			},
		);
	}

		get _renderInner_absorbListItems_isRadio () { return !!this._isRadio; }

		_renderInner_absorbListItems_fnGetValues (it) {
		return {
			source: it.source,
			hash: UrlUtil.URL_TO_HASH_BUILDER[this._page](it),
		};
	}

	_handleFilterChange () {
		const f = this._pageFilter.filterBox.getValues();
		this._list.filter(li => this._pageFilter.toDisplay(f, this._content[li.ix]));
	}

	
	async pImportEntry (ent, importOpts, dataOpts) {
		return new ImportEntryManager({
			instance: this,
			ent,
			importOpts,
			dataOpts,
		}).pImportEntry();
	}

	
		async _pImportEntry (ent, importOpts, dataOpts) {
		importOpts = importOpts || {};

		console.log(...LGT, `Importing ${this._titleSearch} "${ent.name}" (from "${Parser.sourceJsonToAbv(ent.source)}")`);

		if (this.constructor._DataConverter.isStubEntity(ent)) return ImportSummary.completedStub();

		ent = await this._pGetCustomizedEntity({ent});

		Renderer.get().resetHeaderIndex();

		await this._pImportEntry_preImport({ent, importOpts, dataOpts});

		if (importOpts.isDataOnly) {
			return new ImportSummary({
				status: ConstsTaskRunner.TASK_EXIT_COMPLETE_DATA_ONLY,
				imported: [
					new ImportedDocument({
						document: await this.constructor._DataConverter.pGetDocumentJson(ent, {actor: this._actor, taskRunner: importOpts.taskRunner}),
						actor: this._actor,
					}),
				],
			});
		}

		if (importOpts.isTemp) return this._pImportEntry_pImportToDirectoryGeneric(ent, importOpts, dataOpts);
		if (this._actor) return this._pImportEntry_pImportToActor(ent, importOpts, dataOpts);
		return this._pImportEntry_pImportToDirectoryGeneric(ent, importOpts, dataOpts);
	}

	async _pGetCustomizedEntity ({ent}) {
		if (!ent._fvttCustomizerState) return ent;
		return this._ClsCustomizer.pGetAppliedCustomizations({ent});
	}

	async _pImportEntry_preImport ({ent, importOpts, dataOpts}) {
			}

	async _pImportEntry_pImportToActor (ent, importOpts, dataOpts) {
		await UtilActors.pAddActorItems(
			this._actor,
			[await this.constructor._DataConverter.pGetDocumentJson(ent, {isActorItem: true, actor: this._actor, taskRunner: importOpts.taskRunner}, dataOpts)],
		);

		if (this._actor.isToken) this._actor.sheet.render();

		return new ImportSummary({
			status: ConstsTaskRunner.TASK_EXIT_COMPLETE,
			imported: [
				new ImportedDocument({
					name: ent.name,
					actor: this._actor,
				}),
			],
		});
	}

	async pGetSources ({isApplyWorldDataSourceFilter = true} = {}) {
		return (await this._pGetSources())
			.filter(dataSource => !isApplyWorldDataSourceFilter || !UtilWorldDataSourceSelector.isFiltered(dataSource));
	}

	async _pGetSources () { throw new Error(`Unimplemented!`); }

	async pGetAllContent ({sources, uploadedFileMetas, customUrls, isBackground = false}) {
		const userData = await this.pGetChooseImporterUserDataForSources(sources);
		const cacheKeys = [];

		return UtilDataSource.pGetAllContent({
			sources,
			uploadedFileMetas,
			customUrls,
			isBackground,
			userData,
			cacheKeys,

			page: this._page,

			isDedupable: this._isDedupable,
			fnGetDedupedData: this._getDedupedData ? this._getDedupedData.bind(this) : null,

			fnGetBlocklistFilteredData: this._getBlocklistFilteredData ? this._getBlocklistFilteredData.bind(this) : null,
		});
	}

	async _pImportEntry_getUserVersion (entity) {
		if (entity._foundryIsIgnoreVersions) return entity;

		const versions = DataUtil.proxy.getVersions(entity.__prop, entity);
		if (!versions.length) return entity;

		const ix = await InputUiUtil.pGetUserEnum({
			values: versions,
			placeholder: "Select Version...",
			title: `Select the Version to Import`,
			fnDisplay: it => {
				if (it == null) return `(Base version)`;
				return `${it.name}${entity.source !== it.source ? ` (${Parser.sourceJsonToAbv(it.source)})` : ""}`;
			},
			isAllowNull: true,
		});

		if (ix == null) {
			const cpy = MiscUtil.copy(entity);
			cpy._foundryIsIgnoreVersions = true;
			return cpy;
		}
		return versions[ix];
	}

	async _pGetSourcesPrerelease (nxtOpts = {}) { return UtilDataSource.pGetSourcesPrerelease(this._dirsHomebrew, nxtOpts); }
	async _pGetSourcesBrew (nxtOpts = {}) { return UtilDataSource.pGetSourcesBrew(this._dirsHomebrew, nxtOpts); }

	getFolderPathMeta () {
		return {
			alpha: {
				label: "First Letter of Name",
				getter: it => it.name.slice(0, 1).toUpperCase(),
			},
			source: {
				label: "Source (Full)",
				getter: it => Parser.sourceJsonToFull(it.source),
			},
			sourceAbbreviation: {
				label: "Source (Abbreviation)",
				getter: it => Parser.sourceJsonToAbv(it.source),
			},
		};
	}

			async _pImportEntry_pGetFolderIdMeta (entry, opts) {
		opts = opts || {};

		let defaultOwnership = null;
		if (opts.defaultOwnership != null) defaultOwnership = opts.defaultOwnership;
		else if (opts.isAddDefaultOwnershipFromConfig && Config.has(this._configGroup, "ownership")) defaultOwnership = Config.get(this._configGroup, "ownership");

		return this._pGetCreateFoldersGetIdFromObject({
			folderType: opts.folderType || this.constructor.FOLDER_TYPE,
			obj: entry,
			sorting: opts.sorting,
			defaultOwnership,
			userOwnership: opts.userOwnership,
			isFoldersOnly: opts.isFoldersOnly,
		});
	}

	_getFilterNamespace () { return `importer_${this._actor ? `actor` : `directory`}_${this.propsNamespace}`; }

		_getDuplicateMeta (opts) {
		opts = opts || {};

		return new DuplicateMeta({
			mode: Config.get("import", "deduplicationMode"),
			existing: this._getDuplicateMeta_getExisting(opts),
		});
	}

	_getDuplicateMeta_getExisting (opts) {
		if (opts?.importOpts?.isTemp || opts?.importOpts?.isImportToTempDirectory) return null;

		const gameProp = opts.gameProp || this._gameProp;

				const pack = gameProp === this._gameProp ? this._pack : null;

		let existing = null;
		switch (gameProp) {
						case "actors":
			case "items": {
				if (!((opts.name != null && opts.source != null) || opts.entity)) throw new Error(`Either "name" and "source", or "entity", must be provided!`);

				const cleanName = (opts.name ?? UtilDataConverter.getNameWithSourcePart(opts.entity)).toLowerCase().trim();
				const cleanSource = (opts.source ?? UtilDataConverter.getSourceWithPagePart(opts.entity)).toLowerCase().trim();

				switch (gameProp) {
					case "actors": {
						if (pack) {
							const key = this._getDuplicateMeta_getEntityKey({name: cleanName, source: cleanSource});
							existing = (this._packCache || {})[key];
						} else {
							existing = game[gameProp].find(it => this.constructor._getDuplicateMeta_getCleanName(it) === cleanName && (!Config.get("import", "isStrictMatching") || (MiscUtil.get(it, "system", "details", "source") || "").toLowerCase().trim() === cleanSource));
						}
						break;
					}
					case "items": {
						if (pack) {
							const key = this._getDuplicateMeta_getEntityKey({name: cleanName, source: cleanSource});
							existing = (this._packCache || {})[key];
						} else {
							existing = game[gameProp].find(it => this.constructor._getDuplicateMeta_getCleanName(it) === cleanName && (!Config.get("import", "isStrictMatching") || (MiscUtil.get(it, "system", "source") || "").toLowerCase().trim() === cleanSource));
						}
						break;
					}
				}

				break;
			}
			
						case "journal":
			case "tables":
			case "scenes":
			case "cards": {
				const cleanName = opts.name.toLowerCase().trim();

				const isMatch = (docExisting) => {
					return this.constructor._getDuplicateMeta_getCleanName(docExisting) === cleanName
						&& this.constructor._getDuplicateMeta_isFlagMatch(opts.flags, docExisting);
				};

				if (pack) {
					existing = (this._packCacheFlat || []).find(it => isMatch(it));
				} else {
					existing = game[gameProp].find(it => isMatch(it));
				}
				break;
			}
			
			default: throw new Error(`Game property "${gameProp}" is not supported!`);
		}
		return existing;
	}

	_getDuplicateCheckFlags (docData) {
		return null;
	}

		_getDuplicateMetasSub (opts) {
		if (opts?.importOpts?.isTemp || opts?.importOpts?.isImportToTempDirectory) return null;

		const toCreates = [];
		const toUpdates = [];

		opts.children.forEach(child => {
			const cleanName = child.name.toLowerCase().trim();
			const existing = opts.parent.pages
				.find(it => this.constructor._getDuplicateMeta_getCleanName(it) === cleanName && this.constructor._getDuplicateMeta_isFlagMatch(child.flags, it));

			if (existing) child._id = existing.id;
			(existing ? toUpdates : toCreates).push(child);
		});

		return {toCreates, toUpdates};
	}

	static _getDuplicateMeta_getCleanName (it) {
		let out = (MiscUtil.get(it, "name") || "").toLowerCase().trim();

		out = out
			.replace(/\[[^\]]+]/g, "") 			.trim();

		return out;
	}

	static _getDuplicateMeta_isFlagMatch (flags, entity) {
		if (!flags) return true;
		if (!entity) return false;

		if (!entity.flags) return false;
		for (const [moduleKey, flagGroup] of Object.entries(flags)) {
			if (entity.flags[moduleKey] == null) return false;
			for (const [k, v] of Object.entries(flagGroup)) {
				if (!CollectionUtil.deepEquals(v, entity.flags[moduleKey]?.[k])) return false;
			}
		}
		return true;
	}

	_getDuplicateMeta_getEntityKey (obj) {
		return Object.entries(obj)
			.sort(([aK], [bK]) => SortUtil.ascSortLower(aK, bK))
			.map(([k, v]) => `${k}=${`${v}`.trim()}`.toLowerCase())
			.join("::");
	}

		async _pDoPreCachePack ({gameProp = null, taskRunner = null} = {}) {
		gameProp = gameProp || this._gameProp;

		if (!this._pack || Config.get("import", "deduplicationMode") === ConfigConsts.C_IMPORT_DEDUPE_MODE_NONE) return;

		this._packCache = {};
		this._packCacheFlat = [];
		const content = await UtilCompendium.pGetCompendiumData(this._pack, true, {taskRunner});

		content.forEach(ent => {
			switch (gameProp) {
				case "actors": {
					const cleanName = (MiscUtil.get(ent, "name") || "").toLowerCase().trim();
					const cleanSource = (MiscUtil.get(ent, "system", "details", "source") || "").toLowerCase().trim();

					const key = this._getDuplicateMeta_getEntityKey({name: cleanName, source: cleanSource});
					this._packCache[key] = ent;

					break;
				}
				case "items": {
					const cleanName = (MiscUtil.get(ent, "name") || "").toLowerCase().trim();
					const cleanSource = (MiscUtil.get(ent, "system", "source") || "").toLowerCase().trim();

					const key = this._getDuplicateMeta_getEntityKey({name: cleanName, source: cleanSource});
					this._packCache[key] = ent;

					break;
				}
				case "journal":
				case "tables":
				case "scenes":
				case "cards": {
					const cleanName = (MiscUtil.get(ent, "name") || "").toLowerCase().trim();

					const key = this._getDuplicateMeta_getEntityKey({name: cleanName});
					this._packCache[key] = ent;

					break;
				}
				default: throw new Error(`Game property "${gameProp}" is not supported!`);
			}

			this._packCacheFlat.push(ent);
		});
	}

	_pHandleClickRunButton_doDumpPackCache () {
		this._packCache = null;
		this._packCacheFlat = null;
	}

	async _pImportEntry_pDoUpdateExistingPackEntity (duplicateMeta, itemData) {
		await this._pCleanExistingDocumentCollections({document: duplicateMeta.existing});

		this._pImportEntry_pDoUpdateExisting_maintainImg({duplicateMeta, docData: itemData});

		await UtilDocuments.pUpdateDocument(duplicateMeta.existing, itemData);

		await this._pImportEntry_pAddToTargetTableIfRequired([duplicateMeta.existing], duplicateMeta);

		return new ImportSummary({
			status: ConstsTaskRunner.TASK_EXIT_COMPLETE_UPDATE_OVERWRITE_DUPLICATE,
			imported: [
				new ImportedDocument({
					isExisting: true,
					document: duplicateMeta.existing,
					pack: this._pack,
				}),
			],
		});
	}

	async _pImportEntry_pDoUpdateExistingDirectoryEntity (duplicateMeta, itemData) {
		await this._pCleanExistingDocumentCollections({document: duplicateMeta.existing});

		this._pImportEntry_pDoUpdateExisting_maintainImg({duplicateMeta, docData: itemData});

		await UtilDocuments.pUpdateDocument(duplicateMeta.existing, itemData);

		return new ImportSummary({
			status: ConstsTaskRunner.TASK_EXIT_COMPLETE_UPDATE_OVERWRITE_DUPLICATE,
			imported: [
				new ImportedDocument({
					isExisting: true,
					document: duplicateMeta.existing,
				}),
			],
		});
	}

		async _pCleanExistingDocumentCollections ({document}) {
		const fields = Object.values(document.constructor.schema.fields)
			.filter((v) => v instanceof foundry.data.fields.EmbeddedCollectionField);

		for (const field of fields) {
			const toDelete = document[field.element.metadata.collection].map(it => it.id);
			if (!toDelete.length) continue;
			await document.deleteEmbeddedDocuments(
				field.element.metadata.name,
				toDelete,
			);
		}
	}

	_pImportEntry_pDoUpdateExisting_maintainImg ({duplicateMeta, docData}) {
		if (!duplicateMeta?.isOverwrite) return;

		const prevImg = Config.get("import", "isDuplicateHandlingMaintainImage") ? duplicateMeta.existing.img : null;
		if (prevImg != null) docData.img = prevImg;
	}

	async _pImportEntry_pImportToDirectoryGeneric (toImport, importOpts, dataOpts = {}, {docData = null, isSkipDuplicateHandling = false} = {}) {
		docData = docData || await this._pImportEntry_pImportToDirectoryGeneric_pGetImportableData(
			toImport,
			{
				isAddDataFlags: true, 				filterValues: importOpts.filterValues,
				...dataOpts,
				isAddDefaultOwnershipFromConfig: importOpts.isAddDefaultOwnershipFromConfig ?? true,
				defaultOwnership: importOpts.defaultOwnership,
				userOwnership: importOpts.userOwnership,
			},
			importOpts,
		);

				const duplicateMeta = isSkipDuplicateHandling
			? null
			: this._getDuplicateMeta({
				name:
				docData.name,
				source: MiscUtil.get(docData, "system", "source"),
				flags: this._getDuplicateCheckFlags(docData),
				importOpts,
			});
		if (duplicateMeta?.isSkip) {
			return new ImportSummary({
				status: ConstsTaskRunner.TASK_EXIT_SKIPPED_DUPLICATE,
				imported: [
					new ImportedDocument({
						isExisting: true,
						document: duplicateMeta.existing,
					}),
				],
			});
		}

		const Clazz = this._getDocumentClass();

		if (importOpts.isTemp) {
			const imported = await UtilDocuments.pCreateDocument(Clazz, docData, {isTemporary: true});
			return new ImportSummary({
				status: ConstsTaskRunner.TASK_EXIT_COMPLETE,
				imported: [
					new ImportedDocument({
						document: imported,
					}),
				],
			});
		}

								if (this._pack) {
			if (duplicateMeta?.isOverwrite) return this._pImportEntry_pDoUpdateExistingPackEntity(duplicateMeta, docData);

			const instance = new Clazz(docData);
			const imported = await this._pack.importDocument(instance);

			await this._pImportEntry_pAddToTargetTableIfRequired([imported], duplicateMeta);

			return new ImportSummary({
				status: ConstsTaskRunner.TASK_EXIT_COMPLETE,
				imported: [
					new ImportedDocument({
						document: imported,
						pack: this._pack,
					}),
				],
			});
		}

		return this._pImportEntry_pImportToDirectoryGeneric_toDirectory({
			duplicateMeta,
			docData,
			toImport,
			isSkipDuplicateHandling,
			Clazz,
			importOpts,
		});
	}

	async _pImportEntry_pImportToDirectoryGeneric_toDirectory (
		{
			duplicateMeta,
			docData,
			toImport,
			isSkipDuplicateHandling = false,
			Clazz,
			folderType = null,
			importOpts,
		},
	) {
		if (duplicateMeta?.isOverwrite) return this._pImportEntry_pDoUpdateExistingDirectoryEntity(duplicateMeta, docData);

		const folderIdMeta = await this._pImportEntry_pImportToDirectoryGeneric_pGetFolderIdMeta({
			toImport,
			importOpts,
			folderType,
		});

		if (folderIdMeta?.parentDocumentId) {
						return this._pImportEntry_pImportToDirectoryGeneric_toDirectorySubEntities({
				parent: game.journal.get(folderIdMeta.parentDocumentId),
				folderIdMeta,
				isSkipDuplicateHandling,
				embeddedDocDatas: docData.pages,
				ClsEmbed: JournalEntryPage,
				importOpts,
			});
		}

		if (folderIdMeta?.folderId) docData.folder = folderIdMeta.folderId;

		const imported = await UtilDocuments.pCreateDocument(Clazz, docData, {isTemporary: false});

		return new ImportSummary({
			status: ConstsTaskRunner.TASK_EXIT_COMPLETE,
			imported: [
				new ImportedDocument({
					document: imported,
				}),
			],
		});
	}

	async _pImportEntry_pImportToDirectoryGeneric_pGetFolderIdMeta (
		{
			toImport,
			importOpts,
			folderType = null,
		},
	) {
		folderType = folderType || this.constructor.FOLDER_TYPE;

		return importOpts.isImportToTempDirectory
			? new FolderIdMeta({folderId: await UtilFolders.pCreateTempFolderGetId({folderType})})
			: importOpts.folderId !== undefined
				? new FolderIdMeta({folderId: importOpts.folderId})
				: this._pImportEntry_pGetFolderIdMeta(
					toImport,
					{
						isAddDefaultOwnershipFromConfig: importOpts.isAddDefaultOwnershipFromConfig ?? true,
						defaultOwnership: importOpts.defaultOwnership,
						userOwnership: importOpts.userOwnership,
						folderType,
					},
				);
	}

	async _pImportEntry_pImportToDirectoryGeneric_toDirectorySubEntities (
		{
			parent,
			isSkipDuplicateHandling,
			embeddedDocDatas,
			ClsEmbed,
			importOpts,
		},
	) {
		const duplicateMetasSub = isSkipDuplicateHandling
			? {toCreates: embeddedDocDatas, toUpdates: []}
			: this._getDuplicateMetasSub({parent, children: embeddedDocDatas, importOpts});

		const importedDocuments = [];

		if (duplicateMetasSub.toCreates.length) {
			const importedEmbeds = await UtilDocuments.pCreateEmbeddedDocuments(
				parent,
				duplicateMetasSub.toCreates,
				{
					ClsEmbed,
				},
			);

			importedDocuments.push(
				...importedEmbeds.map(it => new ImportedDocument({embeddedDocument: it?.document})),
			);
		}

				if (duplicateMetasSub.toUpdates.length) {
			const importedEmbeds = await UtilDocuments.pUpdateEmbeddedDocuments(
				parent,
				duplicateMetasSub.toUpdates,
				{
					ClsEmbed,
				},
			);

			importedDocuments.push(
				...importedEmbeds.map(it => new ImportedDocument({embeddedDocument: it?.document, isExisting: true})),
			);
		}

		return new ImportSummary({
			status: ConstsTaskRunner.TASK_EXIT_COMPLETE,
			imported: importedDocuments,
		});
	}

	_getDocumentClass () {
		switch (this._gameProp) {
			case "items": return CONFIG.Item.documentClass;
			case "journal": return CONFIG.JournalEntry.documentClass;
			case "tables": return CONFIG.RollTable.documentClass;
			case "scenes": return CONFIG.Scene.documentClass;
			case "cards": return CONFIG.Cards.documentClass;
		}
		throw new Error(`Unhandled game prop "${this._gameProp}"`);
	}

	async _pImportEntry_pAddToTargetTableIfRequired (fvttEntities, duplicateMeta) {
		if (!this._table) return;

				const isFilterRows = duplicateMeta?.mode === ConfigConsts.C_IMPORT_DEDUPE_MODE_SKIP
						|| duplicateMeta?.isOverwrite;

		fvttEntities = isFilterRows
			? fvttEntities.filter(fvttEntity => !this._table.results.some(it => it.data.resultId === fvttEntity.id))
			: fvttEntities;
		if (!fvttEntities.length) return;

		const rangeLowHigh = DataConverterTable.getMaxTableRange(this._table) + 1;
		await UtilDocuments.pCreateEmbeddedDocuments(
			this._table,
			await fvttEntities.pSerialAwaitMap(fvttEntity => DataConverterTable.pGetTableResult({
				type: CONST.TABLE_RESULT_TYPES.COMPENDIUM,
				text: fvttEntity.name,
				resultId: fvttEntity.id,
				collection: this._pack.collection,
				rangeExact: rangeLowHigh,
				img: fvttEntity.img,
			})),
			{
				propData: "results",
				ClsEmbed: TableResult,
			},
		);
	}

		_pImportEntry_pImportToDirectoryGeneric_pGetImportableData (it, getItemOpts, importOpts) {
		return this.constructor._DataConverter.pGetDocumentJson(it, {actor: this._actor, taskRunner: importOpts.taskRunner, ...getItemOpts});
	}

		async pGetChooseImporterUserDataForSources () {}

	_getAsTag (listItem) {
		const tag = Parser.getPropTag(this._content[listItem.ix].__prop);
		const ptId = DataUtil.generic.packUid(this._content[listItem.ix], tag);
		return `@${tag}[${ptId}]`;
	}
}
ImportList._STO_K_FOLDER_PATH_SPEC = "ImportList.folderKeyPathSpec";
ImportList._suppressCreateSheetItemHookTimeStart = null;

function MixinUserChooseImporter (ClsImportList) {
	class MixedUserChooseImporter extends ClsImportList {
				static get defaultOptions () {
			return mergeObject(super.defaultOptions, {title: `Select ${this.DISPLAY_NAME_TYPE_SINGLE}`});
		}

		_isNotDroppable = true;
		_titleButtonRun = "Select";
		_isAlwaysRadio = true;

		_isForceImportToTempDirectory = false;

		constructor (...arge) {
			super(...arge);

			this._isResolveOnClose = true;
			this._fnResolve = null;
			this._fnReject = null;
			this.pResult = null;
		}

		_getImportOpts () {
			return this._isForceImportToTempDirectory
				? {isImportToTempDirectory: true}
				: {isTemp: true, isDataOnly: true};
		}

		_isImportSuccess (importSummary) {
			return (!this._isForceImportToTempDirectory && importSummary.status === ConstsTaskRunner.TASK_EXIT_COMPLETE_DATA_ONLY)
				|| (this._isForceImportToTempDirectory && importSummary.status === ConstsTaskRunner.TASK_EXIT_COMPLETE);
		}

		async _pHandleClickRunButton () {
			if (!this._list) return;

			try {
				const selItem = this._list.items
					.find(it => it.data.cbSel.checked);

				if (!selItem) return ui.notifications.warn(`Please select something from the list!`);

				this._isResolveOnClose = false;

				this.close();

				let entries = [this._content[selItem.ix]];

				entries = await this._pFnPostProcessEntries(entries);
				if (entries == null) return;

				const importOpts = this._getImportOpts();

				const importSummary = await this.pImportEntry(entries[0], importOpts);
				if (this._isImportSuccess(importSummary)) this._fnResolve(importSummary?.imported?.[0]?.document);
				else this._fnReject(new Error(`Import exited with status "${importSummary.status.toString()}"`));

				selItem.data.cbSel.checked = false;
				selItem.ele.classList.remove("list-multi-selected");
			} catch (e) {
				this._fnReject(e);
			}
		}

		_renderInner_initPreviewImportButton (item, btnImport) {
			btnImport.addEventListener("click", async evt => {
				evt.stopPropagation();
				evt.preventDefault();

				try {
					let entries = [this._content[item.ix]];

					entries = await this._pFnPostProcessEntries(entries);
					if (entries == null) return;

					const importOpts = this._getImportOpts();

					const imported = await this.pImportEntry(entries[0], importOpts);
					if (this._isImportSuccess(imported)) this._fnResolve(imported?.imported?.[0]?.document);
					else this._fnReject(new Error(`Import exited with status "${imported.status.toString()}"`));

					this.close();
				} catch (e) {
					this._fnReject(e);
				}
			});
		}

		async close (...args) {
			await super.close(...args);
			if (this._isResolveOnClose) this._fnResolve(null);
		}

		async pPreRender (...preRenderArgs) {
			await super.pPreRender(...preRenderArgs);

			if (!preRenderArgs?.length) return;

			const [{fnResolve, fnReject, pResult}] = preRenderArgs;

			this._isResolveOnClose = true;
			this._fnResolve = fnResolve;
			this._fnReject = fnReject;
			this.pResult = pResult;
		}

				static async pGetUserChoice (mode, namespace) {
			const {ChooseImporter} = await Promise.resolve().then(function () { return ChooseImporter$1; });

			const importer = new this({});
			await importer.pInit();

			let fnResolve = null;
			let fnReject = null;
			const pResult = new Promise((resolve, reject) => {
				fnResolve = resolve;
				fnReject = reject;
			});

						const chooseImporter = new ChooseImporter(
				{
					mode: new ChooseImporter.Mode({
						...mode,
						importerInstance: importer,
					}),
					namespace,
					isAlwaysCloseWindow: true,
					isTemp: true,
					importerPreRenderArgs: {
						fnResolve,
						fnReject,
						pResult,
					},
				},
			);

			if (chooseImporter.isMaybeSkippable()) {
				if (await chooseImporter.pInitIsSubSkippable()) {
					chooseImporter.pDoQuickOpenUsingExistingSourceSelection({isSilent: true, isBackground: true}).then(null);
					return pResult;
				}
			}

			chooseImporter.render(true);
			return pResult;
		}
	}
	return MixedUserChooseImporter;
}

var ImportList$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ImportList: ImportList,
    MixinUserChooseImporter: MixinUserChooseImporter
});

class DataConverterFeature extends DataConverter {
	static _IMG_FALLBACK = `modules/${SharedConsts.MODULE_ID}/media/icon/mighty-force.svg`;

	static async pPreloadSideData () {
		this._SIDE_DATA = await this._pGetPreloadSideData();
		return this._SIDE_DATA;
	}

	static async _pGetPreloadSideData () { throw new Error("Unimplemented!"); }

	static _pGetGenericDescription (ent, configGroup) {
		return Config.get(configGroup, "isImportDescription")
			? UtilDataConverter.pGetWithDescriptionPlugins(() => `<div>${Renderer.get().setFirstSection(true).render({entries: ent.entries}, 2)}</div>`)
			: "";
	}

	static _getData_getConsume ({ent, actor}) {
		if (!ent?.consumes) return {};

		const sheetItem = DataConverter.getConsumedSheetItem({consumes: ent.consumes, actor});
		if (!sheetItem) return {};

		return {
			type: "charges",
			amount: ent.consumes.amount ?? 1,
			target: sheetItem.id,
		};
	}

	static async pGetSideLoadedMatch (ent, {propOpts = "_SIDE_LOAD_OPTS", isSilent = false} = {}) {
		return this._pGetSideLoadedMatch(ent, {...(this._getSideLoadOpts(ent) || this[propOpts]), isSilent});
	}

	static async pMutActorUpdateFeature (actor, actorUpdate, ent, dataBuilderOpts) {
		const sideData = await this.pGetSideLoadedMatch(ent);
		this.mutActorUpdate(actor, actorUpdate, ent, {sideData});
	}

	static async pGetDereferencedFeatureItem (feature) {
		return MiscUtil.copy(feature);
	}
}
DataConverterFeature._SIDE_DATA = null;

var DataConverterFeature$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DataConverterFeature: DataConverterFeature
});

class Charactermancer_Feature_Util {
		static addFauxOptionalFeatureEntries (featureList, optfeatList) {
		if (!featureList || !optfeatList) return;

		Object.values(featureList)
			.forEach(arr => {
				if (!(arr instanceof Array)) return;

				for (const feature of arr) {
					if (!feature.entries?.length || !feature.optionalfeatureProgression) continue;

					for (const optFeatProgression of feature.optionalfeatureProgression) {
						this._addFauxOptionalFeatureFeatures_handleFeatProgression(
							optfeatList,
							feature,
							optFeatProgression,
						);
					}
				}
			});
	}

	static _addFauxOptionalFeatureFeatures_handleFeatProgression (optfeatList, feature, optFeatProgression) {
				if (optFeatProgression.progression instanceof Array) return;

				if (!optFeatProgression.progression["*"]) return;

		const availOptFeats = optfeatList
			.filter(it => optFeatProgression.featureType instanceof Array && (optFeatProgression.featureType || []).some(ft => it.featureType.includes(ft)))
			.filter(it => !ExcludeUtil.isExcluded(
				UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_OPT_FEATURES](it),
				"optionalfeature",
				it.source,
				{isNoCount: true},
			));

		feature.entries.push({
			type: "options",
			count: optFeatProgression.progression["*"],
			entries: availOptFeats.map(it => ({
				type: "refOptionalfeature",
				optionalfeature: DataUtil.proxy.getUid("optionalfeature", it, {isMaintainCase: true}),
			})),
			data: {
				_plut_tmpOptionalfeatureList: true,
			},
		});
	}

	static getCleanedFeature_tmpOptionalfeatureList (feature) {
		const cpyFeature = MiscUtil.copy(feature);
		MiscUtil.getWalker()
			.walk(
				cpyFeature,
				{
					array: (arr) => {
						return arr.filter(it => it.data == null || !it.data._plut_tmpOptionalfeatureList);
					},
				},
			);
		return cpyFeature;
	}
}

class DataConverterFeat extends DataConverterFeature {
	static _SIDE_LOAD_OPTS = {
		propBrew: "foundryFeat",
		fnLoadJson: async () => this._pGetPreloadSideData(),
		propJson: "feat",
	};

	static _IMG_FALLBACK = `modules/${SharedConsts.MODULE_ID}/media/icon/mighty-force.svg`;

	static init () {
		PageFilterClassesFoundry.setImplSideData("feat", this);
	}

	static async pGetDereferencedFeatureItem (feature) {
				if (feature.entries) return MiscUtil.copy(feature);

		const hash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_FEATS](feature);
		return DataLoader.pCacheAndGet(UrlUtil.PG_FEATS, feature.source, hash, {isCopy: true});
	}

	static async pGetInitFeatureLoadeds (feature, {actor = null} = {}) {
		const uid = DataUtil.proxy.getUid("feat", feature, {isMaintainCase: true});
		const asFeatRef = {feat: uid};
						await PageFilterClassesFoundry.pInitFeatLoadeds({feat: asFeatRef, raw: feature, actor});
		return asFeatRef;
	}

		static async pGetDocumentJson (feat, opts) {
		opts = opts || {};
		if (opts.actor) opts.isActorItem = true;

		Renderer.get().resetHeaderIndex();

		const fluff = opts.fluff || await Renderer.feat.pGetFluff(feat);

		const cpyFeat = Charactermancer_Feature_Util.getCleanedFeature_tmpOptionalfeatureList(feat);

		const content = await UtilDataConverter.pGetWithDescriptionPlugins(() => {
			const fluffRender = fluff?.entries?.length
				? Renderer.get().setFirstSection(true).render({type: "entries", entries: fluff?.entries})
				: "";

			const prerequisite = Renderer.utils.prerequisite.getHtml(cpyFeat.prerequisite);
			const ptRepeatable = Renderer.utils.getRepeatableHtml(cpyFeat);
			Renderer.feat.initFullEntries(cpyFeat);
			const statsRender = `<div>
				${prerequisite ? `<p>${prerequisite}</p>` : ""}
				${ptRepeatable ? `<p>${ptRepeatable}</p>` : ""}
				${Renderer.get().setFirstSection(true).render({entries: cpyFeat._fullEntries || cpyFeat.entries}, 2)}
			</div>`;

			return `<div>${[fluffRender, statsRender].join("<hr>")}</div>`;
		});

		const img = await this._pGetSaveImagePath(cpyFeat, {propCompendium: "feat", fluff, taskRunner: opts.taskRunner});

		const additionalData = await this._pGetDataSideLoaded(cpyFeat);
		const additionalFlags = await this._pGetFlagsSideLoaded(cpyFeat);

		const effectsSideTuples = await this._pGetEffectsSideLoadedTuples({ent: cpyFeat, img, actor: opts.actor});
		effectsSideTuples.forEach(({effect, effectRaw}) => DataConverter.mutEffectDisabledTransfer(effect, "importFeat", UtilActiveEffects.getDisabledTransferHintsSideData(effectRaw)));

		const out = DataConverter.pGetItemActorPassive(
			feat,
			{
				mode: "player",
				img,
				fvttType: "feat",
				source: feat.source,
				actor: opts.actor,
				description: content,
				isSkipDescription: !Config.get("importFeat", "isImportDescription"),
				requirements: Renderer.utils.prerequisite.getHtml(cpyFeat.prerequisite, {isTextOnly: true, isSkipPrefix: true}),
				additionalData: additionalData,
				additionalFlags: additionalFlags,
				foundryFlags: this._getFeatFlags(cpyFeat, opts),
				effects: DataConverter.getEffectsMutDedupeId(effectsSideTuples.map(it => it.effect)),
			},
		);

		if (opts.defaultOwnership != null) out.ownership = {default: opts.defaultOwnership};
		else if (opts.isAddDefaultOwnershipFromConfig) out.ownership = {default: Config.get("importFeat", "ownership")};
		if (opts.userOwnership) Object.assign(out.ownership, opts.userOwnership);

		return out;
	}

	static _pGetImgCustom (feat) {
		return this.pGetIconImage("feat", feat);
	}

	static _getFeatFlags (feat, opts) {
		opts = opts || {};

		const out = {
			[SharedConsts.MODULE_ID]: {
				page: UrlUtil.PG_FEATS,
				source: feat.source,
				hash: UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_FEATS](feat),
			},
		};

		if (opts.isAddDataFlags) {
			out[SharedConsts.MODULE_ID].propDroppable = "feat";
			out[SharedConsts.MODULE_ID].filterValues = opts.filterValues;
		}

		return out;
	}

	static async _pGetPreloadSideData () {
		if (!this._SIDE_DATA) this._SIDE_DATA = await Vetools.pGetFeatSideData();
		return this._SIDE_DATA;
	}
}

var DataConverterFeat$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DataConverterFeat: DataConverterFeat
});

class AppFilter {
	constructor () {
		this._filterBox = null;
	}

	get filterBox () { return this._filterBox; }

	mutateAndAddToFilters (entity, isExcluded, opts) {
		this.constructor.mutateForFilters(entity, opts);
		this.addToFilters(entity, isExcluded, opts);
	}

	static mutateForFilters (entity, opts) { throw new Error("Unimplemented!"); }
	addToFilters (entity, isExcluded, opts) { throw new Error("Unimplemented!"); }
	toDisplay (values, entity) { throw new Error("Unimplemented!"); }
	async _pPopulateBoxOptions () { throw new Error("Unimplemented!"); }

	async pInitFilterBox (opts) {
		opts = opts || {};
		await this._pPopulateBoxOptions(opts);
		this._filterBox = new FilterBox(opts);
		await this._filterBox.pDoLoadState();
		return this._filterBox;
	}

	trimState () { return this._filterBox.trimState_(); }

	teardown () { this._filterBox.teardown(); }
}

class AppFilterBasic extends AppFilter {
	constructor () {
		super();

		this._miscFilter_hasFlags = `Has ${Config.get("ui", "isStreamerMode") ? SharedConsts.MODULE_TITLE_FAKE : SharedConsts.MODULE_TITLE} Flags`;

		this._typeFilter = new Filter({header: "Type"});
		this._miscFilter = new Filter({header: "Miscellaneous", items: [this._miscFilter_hasFlags]});
	}

	addToFilters (entity, isExcluded) {
		if (isExcluded) return;

		this._typeFilter.addItem(entity.type);
	}

	async _pPopulateBoxOptions (opts) {
		opts.filters = [
			this._typeFilter,
			this._miscFilter,
		];
	}

	_getMiscFilterValues (ent) {
		return [
			ent.hasPlutoniumFlags ? this._miscFilter_hasFlags : null,
		]
			.filter(Boolean);
	}

	toDisplay (values, ent) {
		return this._filterBox.toDisplay(
			values,
			ent.type,
			this._getMiscFilterValues(ent),
		);
	}
}

class AppFilterCompendiumList extends AppFilter {
	constructor () {
		super();

		this._entityTypeFilter = new Filter({header: "Entity Type"});
		this._packageFilter = new Filter({header: "Package Type"});
		this._systemFilter = new Filter({header: "System"});
	}

	addToFilters (entity, isExcluded) {
		if (isExcluded) return;

		this._entityTypeFilter.addItem(entity.entity);
		this._packageFilter.addItem(entity.packageType);
		this._systemFilter.addItem(entity.system);
	}

	async _pPopulateBoxOptions (opts) {
		opts.filters = [
			this._entityTypeFilter,
			this._packageFilter,
			this._systemFilter,
		];
	}

	toDisplay (values, ent) {
		return this._filterBox.toDisplay(
			values,
			ent.entity,
			ent.packageType,
			ent.system,
		);
	}
}

class AppSourceSelectorMulti extends Application {
		constructor (opts) {
		super({
			title: opts.title || "Select Sources",
			width: 800,
			template: `${SharedConsts.MODULE_LOCATION}/template/AppSourceSelectorMulti.hbs`,
			height: Util.getMaxWindowHeight(),
			resizable: true,
		});

		this._sourcesToDisplay = opts.sourcesToDisplay;
		this._savedSelectionKey = opts.savedSelectionKey;
		this._filterNamespace = opts.filterNamespace;
		this._props = opts.props;
		this._isRadio = !!opts.isRadio;

		this._list = null;
		this._pageFilter = null;

		this._$stgNone = null;
		this._$stgUpload = null;
		this._$stgUrl = null;
		this._$stgSpecial = null;

		this._comp = BaseComponent.fromObject({
			uploadedFileMetas: [],

			isShowCustomUrlForm: false,
			urlMetas: [],

			specialMetas: [],
		});

				this._isDedupable = !!opts.isDedupable;
		this._page = opts.page;
		this._fnGetDedupedData = opts.fnGetDedupedData;
		this._fnGetBlocklistFilteredData = opts.fnGetBlocklistFilteredData;

		this._resolve = null;
		this._reject = null;
		this._pUserInput = null;
			}

	get pageFilter () { return this._pageFilter; }
	get uploadedFileMetas () { return this._comp._state.uploadedFileMetas.map(it => it.data); }
	pGetSelectedSources () {
		if (!this._list) return this._pGetInitialSources();
		return this._list.items.filter(it => it.data.cbSel.checked).map(li => this._sourcesToDisplay[li.ix]);
	}

	async pGetElements ($wrpList, cbSourceChange) {
		return this._pGetElements_pGetListElements($wrpList, cbSourceChange);
	}

	_$getStageNone () {
		return $(`<div class="ve-flex-col mb-1 w-100">
			<div class="ve-flex-v-center"><i>Select a source to view import options</i></div>
			<hr class="hr-1">
		</div>`);
	}

		_$getStageUpload () {
		const $btnAddUpload = $(`<button class="btn btn-5et btn-default btn-xs">Add File</button>`)
			.click(() => {
				const nxt = {
					id: CryptUtil.uid(),
					data: {
						name: null,
						contents: null,
					},
				};
				this._comp._state.uploadedFileMetas = [...this._comp._state.uploadedFileMetas, nxt];

								const renderedCollection = this._comp._getRenderedCollection({prop: "uploadedFileMetas"});
				const renderedMeta = renderedCollection[nxt.id];
				renderedMeta.$btnUpload.click();
			});

		const $wrpUploadRows = $(`<div class="ve-flex-col w-100"></div>`);

		const $stgUpload = $$`<div class="ve-flex-col w-100 py-1">
			<div class="mb-1 split-v-center">
				<div>File Sources:</div>
				${$btnAddUpload}
			</div>
			${$wrpUploadRows}
			<hr class="hr-1">
		</div>`;

		const hkUploadFileMetas = () => {
			this._comp._renderCollection({
				prop: "uploadedFileMetas",
				fnUpdateExisting: (renderedMeta, uploadFileMeta) => {
					renderedMeta.comp._proxyAssignSimple("state", uploadFileMeta.data, true);
					if (!renderedMeta.$wrpRow.parent().is($wrpUploadRows)) renderedMeta.$wrpRow.appendTo($wrpUploadRows);
				},
				fnGetNew: uploadFileMeta => {
					const comp = BaseComponent.fromObject(uploadFileMeta.data, "*");
					comp._addHookAll("state", () => {
						uploadFileMeta.data = comp.toObject("*");
						this._comp._triggerCollectionUpdate("uploadedFileMetas");
					});

					const $dispName = $(`<div class="imp__disp-filename mr-1 ve-muted w-100"></div>`)
						.click(() => $btnUpload.click());
					const hkName = () => $dispName.text(comp._state.name || "Select file...").title(comp._state.name || "");
					comp._addHookBase("name", hkName);
					hkName();

					const $btnUpload = $(`<button class="btn btn-5et btn-xs mr-1">Upload File</button>`)
						.click(() => {
							const $ipt = $(`<input type="file" accept=".json" class="ve-hidden">`)
								.change(evt => {
									const input = evt.target;
									const files = $ipt[0].files;

									const reader = new FileReader();
									reader.onload = async () => {
										const file = (files[0] || {});

										try {
											const json = JSON.parse(reader.result);
											comp._proxyAssignSimple("state", {name: file.name, contents: json});
										} catch (e) {
											ui.notifications.error(`Failed to read file! ${VeCt.STR_SEE_CONSOLE}`);
											throw e;
										}
									};
									reader.readAsText(input.files[0]);
								})
								.click();
						});

					const $btnDelete = $(`<button class="btn btn-5et btn-xs btn-danger" title="Delete"><span class="glyphicon glyphicon-trash"></span></button>`)
						.click(() => this._comp._state.uploadedFileMetas = this._comp._state.uploadedFileMetas.filter(it => it !== uploadFileMeta));

					const $wrpRow = $$`<div class="ve-flex-v-center my-1 w-100">
						${$btnUpload}${$dispName}${$btnDelete}
					</div>`.appendTo($wrpUploadRows);

					return {
						comp,
						$wrpRow,
						$btnUpload,
					};
				},
			});
		};
		hkUploadFileMetas();
		this._comp._addHookBase("uploadedFileMetas", hkUploadFileMetas);

		return $stgUpload;
	}

	_$getStageUrl () {
		const $btnAddUrl = $(`<button class="btn btn-5et btn-default btn-xs">Add Custom</button>`)
			.click(() => {
				const nxt = {
					id: CryptUtil.uid(),
					data: {
						displayName: "Custom Url",
						isCustom: true,
						url: null,
					},
				};

				this._comp._state.urlMetas = [
					...this._comp._state.urlMetas,
					nxt,
				];

								const renderedCollection = this._comp._getRenderedCollection({prop: "urlMetas"});
				const renderedMeta = renderedCollection[nxt.id];
				renderedMeta.$iptUrl.focus();
			});
		const hkIsCustomUrls = () => $btnAddUrl.toggleVe(this._comp._state.isShowCustomUrlForm);
		this._comp._addHookBase("isShowCustomUrlForm", hkIsCustomUrls);
		hkIsCustomUrls();

		const $wrpUrlRows = $(`<div class="ve-flex-col w-100"></div>`);

		const $stgUrl = $$`<div class="ve-flex-col w-100 py-1">
			<div class="mb-1 split-v-center">
				<div>URL Sources:</div>
				${$btnAddUrl}
			</div>
			${$wrpUrlRows}
			<hr class="hr-1">
		</div>`;

		const hkUrlMetas = () => {
			this._comp._renderCollection({
				prop: "urlMetas",
				fnUpdateExisting: (renderedMeta, urlMeta) => {
					renderedMeta.comp._proxyAssignSimple("state", urlMeta.data, true);
					if (!renderedMeta.$wrpRow.parent().is($wrpUrlRows)) renderedMeta.$wrpRow.appendTo($wrpUrlRows);
				},
				fnGetNew: urlMeta => {
					const comp = BaseComponent.fromObject(urlMeta.data, "*");
					comp._addHookAll("state", () => {
						urlMeta.data = comp.toObject("*");
						this._comp._triggerCollectionUpdate("urlMetas");
					});

					const $iptUrl = ComponentUiUtil.$getIptStr(comp, "url");
					if (Config.get("ui", "isStreamerMode")) $iptUrl.addClass("text-sneaky");
					const hkDisplayNameUrl = () => {
						if (comp._state.isCustom) {
							$iptUrl.title("Enter JSON URL").placeholder("Enter JSON URL").val(comp._state.url);
						} else {
							$iptUrl.title("JSON URL").val(comp._state.displayName).disable();
						}
					};
					this._comp._addHookBase("url", hkDisplayNameUrl);
					this._comp._addHookBase("displayName", hkDisplayNameUrl);
					hkDisplayNameUrl();

					const $btnDelete = !comp._state.isCustom ? null : $(`<button class="btn btn-5et btn-xs btn-danger ml-2" title="Delete"><span class="glyphicon glyphicon-trash"></span></button>`)
						.click(() => this._comp._state.urlMetas = this._comp._state.urlMetas.filter(it => it !== urlMeta));

					const $wrpRow = $$`<div class="ve-flex-v-center my-1 w-100">
						${$iptUrl}${$btnDelete}
					</div>`.appendTo($wrpUrlRows);

					return {
						comp,
						$wrpRow,
						$iptUrl,
					};
				},
			});
		};
		hkUrlMetas();
		this._comp._addHookBase("urlMetas", hkUrlMetas);

		return $stgUrl;
	}

	_$getStageSpecial () {
		const $wrpSpecialRows = $(`<div class="ve-flex-col w-100"></div>`);

		const $stgSpecial = $$`<div class="ve-flex-col w-100 py-1">
			<div class="mb-1 ve-flex-v-center">
				<div>Pre-Compiled Sources:</div>
			</div>
			${$wrpSpecialRows}
			<hr class="hr-1">
		</div>`;

		const hkSpecialMetas = () => {
			this._comp._renderCollection({
				prop: "specialMetas",
				fnUpdateExisting: (renderedMeta, specialMeta) => {
					renderedMeta.comp._proxyAssignSimple("state", specialMeta.data, true);
					if (!renderedMeta.$wrpRow.parent().is($wrpSpecialRows)) renderedMeta.$wrpRow.appendTo($wrpSpecialRows);
				},
				fnGetNew: specialMetas => {
					const comp = BaseComponent.fromObject(specialMetas.data, "*");
					comp._addHookAll("state", () => {
						specialMetas.data = comp.toObject("*");
						this._comp._triggerCollectionUpdate("urlMetas");
					});

					const $dispName = $(`<div class="w-100 italic ${Config.get("ui", "isStreamerMode") ? "text-sneaky" : ""}"></div>`);
					const hkDisplayName = () => $dispName.text(comp._state.displayName);
					this._comp._addHookBase("displayName", hkDisplayName);
					hkDisplayName();

					const $wrpRow = $$`<div class="ve-flex-v-center my-1 w-100">${$dispName}</div>`
						.appendTo($wrpSpecialRows);

					return {
						comp,
						$wrpRow,
					};
				},
			});
		};
		hkSpecialMetas();
		this._comp._addHookBase("specialMetas", hkSpecialMetas);

		return $stgSpecial;
	}

	async _pGetInitialSources () {
		const initialSourceIds = await this._pGetInitialSourceIds();
		const initialSources = this._sourcesToDisplay.filter(it => initialSourceIds.has(it.identifier));
		if (!initialSources.length) initialSources.push(...this._sourcesToDisplay.filter(it => it.isDefault));
		return initialSources;
	}

	async _pGetInitialSourceIds () {
		if (this.isForceSelectAllSources()) {
			return new Set(this._sourcesToDisplay.map(it => it.identifier));
		}
		return new Set((await StorageUtil.pGet(this._savedSelectionKey)) || []);
	}

	isForceSelectAllSources () {
		if (this._isRadio) return false;
		if (game.user.isGM) return Config.get("dataSources", "isGmForceSelectAllowedSources");
		return Config.get("dataSources", "isPlayerForceSelectAllowedSources");
	}

	static $getFilterListElements ({isRadio = false, isForceSelectAll = false} = {}) {
		const $btnOpenFilter = $(`<button class="btn-5et veapp__btn-filter">Filter</button>`);
		const $btnToggleSummaryHidden = $(`<button class="btn btn-5et" title="Toggle Filter Summary Display"><span class="glyphicon glyphicon-resize-small"></span></button>`);
		const $iptSearch = $(`<input type="search" class="search w-100 form-control h-initial" placeholder="Find source...">`);
		const $btnReset = $(`<button class="btn-5et veapp__btn-list-reset">Reset</button>`)
			.click(() => $iptSearch.val(""));
		const $wrpMiniPills = $(`<div class="fltr__mini-view btn-group"></div>`);

		const isHideCbAll = isRadio || isForceSelectAll;

		const $cbAll = isHideCbAll ? null : $(`<input type="checkbox" class="no-events">`);
		const $lblCbAll = $$`<label class="btn btn-5et btn-xs col-0-5 ve-flex-vh-center" ${isHideCbAll ? "disabled" : ""}>${$cbAll}</label>`;

		const $wrpBtnsSort = $$`<div class="ve-flex-v-stretch input-group input-group--bottom mb-1 no-shrink">
			${$lblCbAll}
			<button class="btn-5et btn-xs col-11-5 sort" data-sort="name">Name</button>
		</div>`;
		const $list = $(`<div class="veapp__list mb-1 h-100 min-h-0"></div>`);

		const $wrpFilterControls = $$`<div class="ve-flex-v-stretch input-group input-group--top no-shrink">
			${$btnOpenFilter}
			${$btnToggleSummaryHidden}
			${$iptSearch}
			${$btnReset}
		</div>`;

		return {
			$cbAll,
			$wrpFilterControls,
			$wrpMiniPills,
			$wrpBtnsSort,
			$list,
			$btnOpenFilter,
			$iptSearch,
			$btnReset,
			$btnToggleSummaryHidden,
		};
	}

	static getListItem (
		{
			pageFilter,
			isRadio,
			list,
			listSelectClickHandler,
			src,
			srcI,
			fnOnClick,
			initialSources,
			isSelected,
			isForceSelectAll,
		},
	) {
		isSelected = isSelected === undefined && initialSources ? initialSources.includes(src) : !!isSelected;

		pageFilter.mutateAndAddToFilters(src);

		const eleCb = e_({
			outer: isRadio
				? `<input type="radio" name="radio" class="no-events mx-1">`
				: `<input type="checkbox" class="no-events mx-1">`,
		});
		if (isSelected) eleCb.checked = true;
		if (isForceSelectAll) eleCb.setAttribute("disabled", true);

		const eleWrpCb = e_({
			tag: "span",
			clazz: "col-0-5 ve-flex-vh-center",
			children: [
				eleCb,
			],
		});

		const eleLi = e_({
			tag: "label",
			clazz: `row imp-wiz__row veapp__list-row-hoverable ve-flex-v-center ${isSelected ? "list-multi-selected" : ""}`,
			children: [
				eleWrpCb,
				e_({
					tag: "span",
					clazz: "col-11-5",
					html: `${this._getFilterTypesIcon(src.filterTypes)}${src.name}`,
				}),
			],
		});

		const listItem = new ListItem(
			srcI,
			eleLi,
			src.name,
			{
				filterTypes: src.filterTypes,
				abbreviations: src.abbreviations || [],
			},
			{
				identifierWorld: src.identifierWorld,
				cbSel: eleCb,
			},
		);

		if (!isForceSelectAll) {
			eleLi.addEventListener("click", evt => {
				if (isRadio) listSelectClickHandler.handleSelectClickRadio(listItem, evt);
				else listSelectClickHandler.handleSelectClick(listItem, evt);
				if (fnOnClick) fnOnClick({list, listItem});
			});
		}

		return listItem;
	}

	async _pGetElements_pGetListElements ($wrpList, cbSourceChange = null) {
		this._$stgNone = this._$getStageNone();
		this._$stgUpload = this._$getStageUpload();
		this._$stgUrl = this._$getStageUrl();
		this._$stgSpecial = this._$getStageSpecial();

		const initialSources = await this._pGetInitialSources();

		const setSources = ({isSkipSave} = {}) => {
			const selSources = this._list.items.filter(it => it.data.cbSel.checked).map(li => this._sourcesToDisplay[li.ix]);

			const selSourceIdentifiers = selSources.map(source => source.identifier);
			if (!isSkipSave) StorageUtil.pSet(this._savedSelectionKey, selSourceIdentifiers);

			const isShowStageUpload = selSources.some(it => it.isFile);
			const isShowStageUrl = selSources.some(it => it.url != null);
			const isShowStageSpecial = selSources.some(it => it.url == null && !it.isFile);

			this._$stgNone.toggleVe(!isShowStageUpload && !isShowStageUrl && !isShowStageSpecial);
			this._$stgUpload.toggleVe(isShowStageUpload);
			this._$stgUrl.toggleVe(isShowStageUrl);
			this._$stgSpecial.toggleVe(isShowStageSpecial);

						if (isShowStageUrl) {
				this._comp._state.isShowCustomUrlForm = selSources.some(it => it.url === "");

				const customUrlMetas = this._comp._state.isShowCustomUrlForm
					? this._comp._state.urlMetas.filter(it => it.data.isCustom)
					: [];

				this._comp._state.urlMetas = [
					...selSources.filter(it => it.url).map(it => ({id: it.url, data: {isCustom: false, displayName: it.url}})),
					...customUrlMetas,
				];
			} else {
				this._comp._state.urlMetas = [];
			}

			if (isShowStageSpecial) {
				this._comp._state.specialMetas = [
					...selSources.filter(it => it.url == null && !it.isFile).map(it => ({id: it.cacheKey, data: {displayName: it.name}})),
				];
			} else {
				this._comp._state.specialMetas = [];
			}
			
						if (cbSourceChange) cbSourceChange(selSources);
		};

		if (this._pageFilter) this._pageFilter.teardown();
		this._pageFilter = new AppSourceSelectorMulti.AppSourceSelectorAppFilter();

		const isForceSelectAll = this.isForceSelectAllSources();

		const {
			$cbAll,
			$wrpFilterControls,
			$wrpMiniPills,
			$wrpBtnsSort,
			$list,
			$btnOpenFilter,
			$iptSearch,
			$btnReset,
			$btnToggleSummaryHidden,
		} = this.constructor.$getFilterListElements({isRadio: this._isRadio, isForceSelectAll});

		$$($wrpList)`
			${$wrpFilterControls}
			${$wrpMiniPills}
			${$wrpBtnsSort}
			${$list}
		`;

		this._list = new List({
			$iptSearch,
			$wrpList: $list,
			fnSort: UtilDataSource.sortListItems.bind(UtilDataSource),
		});
		const listSelectClickHandler = new ListSelectClickHandler({list: this._list});
		SortUtil.initBtnSortHandlers($wrpBtnsSort, this._list);
		if ($cbAll) {
			listSelectClickHandler.bindSelectAllCheckbox($cbAll);
			$cbAll.change(() => setSources());
		}

		await this._pageFilter.pInitFilterBox({
			$iptSearch,
			$btnReset,
			$btnOpen: $btnOpenFilter,
			$btnToggleSummaryHidden,
			$wrpMiniPills,
			namespace: this._filterNamespace,
		});

		this._sourcesToDisplay.forEach((src, srcI) => {
			const listItem = this.constructor.getListItem({
				pageFilter: this._pageFilter,
				list: this._list,
				listSelectClickHandler,
				isRadio: this._isRadio,
				src,
				srcI,
				fnOnClick: setSources,
				initialSources,
				isForceSelectAll,
			});
			this._list.addItem(listItem);
		});

		setSources({isSkipSave: true});

		this._list.init();

		this._pageFilter.trimState();
		this._pageFilter.filterBox.render();

		this._pageFilter.filterBox.on(
			FilterBox.EVNT_VALCHANGE,
			this._handleFilterChange.bind(this),
		);

		this._handleFilterChange();

		return {
			$stgNone: this._$stgNone,
			$stgUpload: this._$stgUpload,
			$stgUrl: this._$stgUrl,
			$stgSpecial: this._$stgSpecial,

			$iptSearch,
		};
	}

	_handleFilterChange () {
		const f = this._pageFilter.filterBox.getValues();
		this._list.filter(li => this._pageFilter.toDisplay(f, this._sourcesToDisplay[li.ix]));
	}

	static _getFilterTypesIcon (filterTypes) {
		if (filterTypes.includes(UtilDataSource.SOURCE_TYP_OFFICIAL_ALL) || filterTypes.includes(UtilDataSource.SOURCE_TYP_OFFICIAL_SINGLE)) {
			return `<i class="fab fa-d-and-d mr-1 source-category-site" title="${UtilDataSource.SOURCE_TYP_OFFICIAL_BASE}"></i>`;
		}

		if (filterTypes.includes(UtilDataSource.SOURCE_TYP_EXTRAS)) {
			return `<i class="fas fa-fw fa-scroll-old mr-1 source-category-extras" title="${UtilDataSource.SOURCE_TYP_EXTRAS}"></i>`;
		}

		if (filterTypes.includes(UtilDataSource.SOURCE_TYP_PRERELEASE_LOCAL)) {
			return `<i class="fas fa-fw fa-vial mr-1 source-category-spicy source-category-spicy--local" title="${UtilDataSource.SOURCE_TYP_PRERELEASE_LOCAL}"></i>`;
		}

		if (filterTypes.includes(UtilDataSource.SOURCE_TYP_PRERELEASE)) {
			return `<i class="fas fa-fw fa-vial mr-1 source-category-spicy" title="${UtilDataSource.SOURCE_TYP_PRERELEASE}"></i>`;
		}

		if (filterTypes.includes(UtilDataSource.SOURCE_TYP_BREW_LOCAL)) {
			return `<i class="fas fa-fw fa-beer mr-1 source-category-homebrew source-category-homebrew--local" title="${UtilDataSource.SOURCE_TYP_BREW_LOCAL}"></i>`;
		}

		if (filterTypes.includes(UtilDataSource.SOURCE_TYP_BREW)) {
			return `<i class="fas fa-fw fa-beer mr-1 source-category-homebrew" title="${UtilDataSource.SOURCE_TYP_BREW}"></i>`;
		}

		if (filterTypes.includes(UtilDataSource.SOURCE_TYP_CUSTOM)) {
			return `<i class="fas fa-fw fa-user ve-muted mr-1" title="${UtilDataSource.SOURCE_TYP_CUSTOM}"></i>`;
		}

		if (filterTypes.includes(UtilDataSource.SOURCE_TYP_UNKNOWN)) {
			return `<i class="fas fa-fw fa-question-circle ve-muted mr-1" title="${UtilDataSource.SOURCE_TYP_CUSTOM}"></i>`;
		}

		return "";
	}

		activateListeners ($html) {
		(async () => {
			const $ovrLoading = $(`<div class="veapp-loading__wrp-outer"><i>Loading...</i></div>`)
				.appendTo($html.empty());

			const $wrpList = $(`<div class="ve-flex-col w-100 h-100 min-h-0"></div>`);

			const {$iptSearch} = await this.pGetElements($wrpList);

			$iptSearch.keydown(evt => {
				if (evt.key === "Enter") $btnAccept.click();
			});

			const $btnAccept = $(`<button class="mt-auto btn btn-5et">Confirm</button>`)
				.click(() => this._pAcceptAndResolveSelection({$ovrLoading}));

			$$($html)`
			${$wrpList}
			<hr class="hr-1">
			<div class="ve-flex-col w-100 overflow-y-auto pr-1 max-h-40 imp__disp-import-from no-shrink">
				<h3 class="mb-1 b-0">Source</h3>
				${this._$stgNone}
				${this._$stgUpload}
				${this._$stgUrl}
				${this._$stgSpecial}
			</div>
			${$btnAccept}
			${$ovrLoading.hideVe()}`;

			$iptSearch.focus();
		})();
	}

	async _pAcceptAndResolveSelection ({$ovrLoading, isSilent = false, isBackground = false, isAutoSelectAll = false} = {}) {
		try {
			if ($ovrLoading) $ovrLoading.showVe();

			const sources = await this.pGetSelectedSources();
			if (!isSilent && !sources.length) {
				if ($ovrLoading) $ovrLoading.hideVe();
				return ui.notifications.error(`No sources selected!`);
			}

			if (!isSilent && sources.length > 10) {
				const isContinue = await InputUiUtil.pGetUserBoolean({
					title: `You have many sources selected, which may negatively impact performance. Do you want to continue?`,
					storageKey: "AppSourceSelectorMulti__massSelectionWarning",
					textYesRemember: "Continue and Remember",
					textYes: "Continue",
					textNo: "Cancel",
				});

				if (!isContinue) {
					if ($ovrLoading) $ovrLoading.hideVe();
					return;
				}
			}

			const out = await this._pGetOutputEntities(sources, {isBackground, isAutoSelectAll});
			if (!out) return; 
			if (!isSilent && !Object.values(out).some(it => it?.length)) {
				if ($ovrLoading) $ovrLoading.hideVe();
				return ui.notifications.warn(`No sources to be loaded! Please finish entering source details first.`);
			}

			this._resolve(out);
			this.close();
		} catch (e) {
			if ($ovrLoading) $ovrLoading.hideVe();
			ui.notifications.error(`Failed to load sources! ${VeCt.STR_SEE_CONSOLE}`);
			throw e;
		}
	}

	async _pGetOutputEntities (sources, {isBackground = false, isAutoSelectAll = false} = {}) {
		const allContentMeta = await UtilDataSource.pGetAllContent({
			sources,
			uploadedFileMetas: this.uploadedFileMetas,
			customUrls: this.getCustomUrls(),
			isBackground,

			page: this._page,

			isDedupable: this._isDedupable,
			fnGetDedupedData: this._fnGetDedupedData,

			fnGetBlocklistFilteredData: this._fnGetBlocklistFilteredData,

			isAutoSelectAll,
		});
		if (!allContentMeta) return null;
		return allContentMeta.dedupedAllContentMerged;
	}

	getCustomUrls () {
		return this._comp._state.urlMetas
			.filter(it => it.data.isCustom && it.data.url && it.data.url.trim())
			.map(it => it.data.url.trim());
	}

	handlePreClose () {
		this._comp._detachCollection("urlMetas");
		this._comp._detachCollection("uploadedFileMetas");
		this._comp._detachCollection("specialMetas");
	}

	handlePostClose () {
		if (this._pageFilter) this._pageFilter.teardown();
	}

	async close (...args) {
		this.handlePreClose();
		await super.close(...args);
		this.handlePostClose();
	}

	pWaitForUserInput ({isRenderApp = true} = {}) {
		const isSelectAll = this.isForceSelectAllSources();

		if (!isSelectAll && isRenderApp) this.render(true);

		this._pUserInput = new Promise((resolve, reject) => {
			this._resolve = resolve;
			this._reject = reject;
		});

		if (isSelectAll) this._pAcceptAndResolveSelection({isSilent: true, isBackground: true, isAutoSelectAll: isSelectAll}).then(null);

		return this._pUserInput;
	}
	
		async pLoadInitialSelection () {
		const initialSources = await this._pGetInitialSources();
		return this._pGetOutputEntities(initialSources);
	}
}

AppSourceSelectorMulti.AppSourceSelectorAppFilter = class extends AppFilter {
	static _sortTypeFilterItems (a, b) {
		a = a.item;
		b = b.item;

		const ixA = UtilDataSource.SOURCE_TYPE_ORDER__FILTER.indexOf(a);
		const ixB = UtilDataSource.SOURCE_TYPE_ORDER__FILTER.indexOf(b);

		return SortUtil.ascSort(ixA, ixB);
	}

	constructor () {
		super();

		this._typeFilter = new Filter({
			header: "Type",
			itemSortFn: AppSourceSelectorMulti.AppSourceSelectorAppFilter._sortTypeFilterItems,
		});
	}

	static mutateForFilters () {
			}

	addToFilters (entity, isExcluded) {
		if (isExcluded) return;

		this._typeFilter.addItem(entity.filterTypes);
	}

	async _pPopulateBoxOptions (opts) {
		opts.filters = [
			this._typeFilter,
		];
	}

	toDisplay (values, ent) {
		return this._filterBox.toDisplay(
			values,
			ent.filterTypes,
		);
	}
};

class Charactermancer_AdditionalFeatsSelect extends BaseComponent {
		static async pGetUserInput ({available, actor}) {
		if (!available?.length) return {isFormComplete: true, data: {}};

		if (UtilAdditionalFeats.isNoChoice(available)) {
			const comp = new this({available});
			return comp.pGetFormData();
		}

		const {ImportListFeat} = await Promise.resolve().then(function () { return ImportListFeat$1; });
		const ImportListFeatSources = await (new ImportListFeat()).pGetSources();
		const appSourceSelector = new AppSourceSelectorMulti({
			title: `Select Feat Sources`,
			filterNamespace: `Charactermancer_AdditionalFeatsSelect_filter`,
			savedSelectionKey: `Charactermancer_AdditionalFeatsSelect_savedSelection`,
			sourcesToDisplay: ImportListFeatSources,
			props: ["feat"],
			page: UrlUtil.PG_FEATS,
			isDedupable: true,
		});

		const allData = await appSourceSelector.pWaitForUserInput();
		if (allData == null) return null; 
		const modalFilterFeats = await this._pGetUserInput_pGetModalFilterFeats({allData});
		const modalFilterSpells = await this._pGetUserInput_pGetModalFilterSpells({allData});

		const comp = new this({
			available,
			actor,
			featDatas: allData.feat,
			modalFilterFeats,
			modalFilterSpells,
		});
		return UtilApplications.pGetImportCompApplicationFormData({
			comp,
			width: 800,
			height: 640,
		});
	}

	static async _pGetUserInput_pGetModalFilterFeats ({allData}) {
		const modalFilterFeats = new ModalFilterFeatsFvtt({
			namespace: "Charactermancer_AdditionalFeatsSelect.feats",
			isRadio: true,
			allData: allData.feat,
		});
		await modalFilterFeats.pPreloadHidden();
		return modalFilterFeats;
	}

	static async _pGetUserInput_pGetModalFilterSpells ({allData}) {
		const modalFilterSpells = new ModalFilterSpellsFvtt({
			namespace: "Charactermancer_AdditionalFeatsSelect.spells",
			isRadio: true,
			allData: allData.spell,
		});
		await modalFilterSpells.pPreloadHidden();
		return modalFilterSpells;
	}
	
		constructor (opts) {
		opts = opts || {};
		super();

		this._available = opts.available;
		this._actor = opts.actor;
		this._featDatas = opts.featDatas || [];
		this._modalFilterFeats = opts.modalFilterFeats;
		this._modalFilterSpells = opts.modalFilterSpells;
		this._featureSourceTracker = opts.featureSourceTracker;
		this._isFeatureSelect = !!opts.isFeatureSelect;

		this._featDatas.forEach(it => it._hash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_FEATS]({name: it.name, source: it.source}));
		this._compsFeatFeatureOptionsSelect = {};

		this._prevComp = opts.prevComp;
		this._cache_featFeatureLoadeds = opts.prevComp?._cache_featFeatureLoadeds || new Map();
	}

	get modalTitle () { return `Feats`; }

	get cntAny () {
		const featSet = this._available[this._state.ixSet];
		return featSet?.any || 0;
	}

	get ixSetAvailable () { return this._state.ixSet; }

	addHookIxSet (hk) { this._addHookBase("ixSet", hk); }

	addHookPulseFeats (hk) {
		this._addHookBase("pulse_feats", hk);
	}

	setStateFromStatgenFeatList_ (featList) {
		const featListChoose = featList
			.filter(it => it == null || it.type === "choose");

		let offsetIx = 0; 		const nxtState = {};
		const ixsStatgen = [];
		featListChoose
			.forEach((featMeta, ixRaw) => {
				if (!featMeta) return offsetIx++;
				ixsStatgen.push(ixRaw);

				const ix = ixRaw - offsetIx;

				const {type, ix: ixFeatRaw} = featMeta;
				const {propIxFeat} = this._getProps({ix, type});

				nxtState[propIxFeat] = ixFeatRaw === -1 ? null : ixFeatRaw;
			});

				nxtState.readonly_ixsStatgen = ixsStatgen;
		this._proxyAssignSimple("state", nxtState);
	}

	_getProps ({ix, type}) {
		return {
			propPrefixFeat: `feat_${ix}_${type}_`,
			propIxFeat: `feat_${ix}_${type}_ixFeat`,
		};
	}

	_getLocks ({ix, type}) {
		return {
			lockChangeFeat: `feat_${ix}_${type}_pHkChangeFeat`,
			lockRenderFeatureOptionsSelects: `feat_${ix}_${type}_renderFeatureOptionsSelects`,
		};
	}

	unregisterFeatureSourceTracking () {
		if (this._featureSourceTracker) this._featureSourceTracker.unregister(this);
		this._unregisterSubComps();
	}

	_unregisterSubComps () {
		if (!this._featureSourceTracker) return;

		Object.entries(this._compsFeatFeatureOptionsSelect)
			.forEach(([type, ixToArr]) => {
				Object.keys(ixToArr)
					.forEach(ix => {
																		(this._compsFeatFeatureOptionsSelect[type]?.[ix] || []).forEach(comp => comp.unregisterFeatureSourceTracking());
					});
			});
	}

	render ($wrp) {
		const $wrpLeft = $(`<div class="ve-flex-col w-100 h-100 min-h-0 overflow-y-auto"></div>`);
		const $wrpRight = $(`<div class="ve-flex-col w-100 h-100 min-h-0 overflow-y-auto"></div>`);

		this.renderTwoColumn({$wrpLeft, $wrpRight});

		$$($wrp)`<div class="ve-flex w-100 h-100 min-h-0">
			${$wrpLeft}
			<div class="vr-3"></div>
			${$wrpRight}
		</div>
		`;
	}

	renderTwoColumn ({$wrpLeft, $wrpRight}) {
		this._render_$getStgSelGroup({$wrpLeft});
		const $stgGroupLeft = $$`<div class="ve-flex-col"></div>`.appendTo($wrpLeft);
		const $stgGroupRight = $$`<div class="ve-flex-col"></div>`.appendTo($wrpRight);

		const lastMetas = [];
		const boundHkIxSet = this._hk_ixSet.bind(this, {$stgGroupLeft, $stgGroupRight, lastMetas});
		this._addHookBase("ixSet", boundHkIxSet);
		boundHkIxSet();
	}

	_render_$getStgSelGroup ({$wrpLeft}) {
		if (this._available.length <= 1) return;

		const {$sel: $selGroup} = UtilAdditionalFeats.getSelIxSetMeta({
			comp: this,
			prop: "ixSet",
			available: this._available,
		});

		return $$`<div class="w-100 mb-2 ve-flex-v-center">
			<div class="mr-2 no-shrink bold">Feat Set:</div>
			${$selGroup}
		</div>`.appendTo($wrpLeft);
	}

	_hk_ixSet ({$stgGroupLeft, $stgGroupRight, lastMetas}) {
		$stgGroupLeft.empty();
		$stgGroupRight.empty();
		lastMetas.splice(0, lastMetas.length).forEach(it => it.cleanup());
		const featSet = this._available[this._state.ixSet];
		this._hk_ixSet_renderPts({$stgGroupLeft, $stgGroupRight, featSet, lastMetas});
		this._state.pulse_feats = !this._state.pulse_feats;
	}

	_hk_ixSet_renderPts ({$stgGroupLeft, $stgGroupRight, featSet, lastMetas}) {
		const hasStatic = Object.keys(featSet).some(it => it !== "any");
		const hasChoose = !!featSet.any;

		if (hasStatic) this._render_renderPtStatic({$stgGroupLeft, $stgGroupRight, featSet});
		if (hasStatic && hasChoose) $stgGroupLeft.append(`<hr class="hr-2 mt-0 hr--dotted">`);
		if (hasChoose) this._render_renderPtChooseFromFilter({$stgGroupLeft, $stgGroupRight, featSet, lastMetas});
		if (hasStatic || hasChoose) $stgGroupLeft.append(`<hr class="hr-2>`);
	}

	_render_renderPtStatic ({$stgGroupLeft, $stgGroupRight, featSet}) {
		const type = "static";
		const uidsStatic = UtilAdditionalFeats.getUidsStatic(featSet);

		const rowMetas = uidsStatic.map((uid, ix) => {
						const {
				lockRenderFeatureOptionsSelects,
			} = this._getLocks({ix, type});
			
			const {name, source} = DataUtil.proxy.unpackUid("feat", uid, "feat");
			const hash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_FEATS]({name, source});
			const feat = this._featDatas.find(it => it._hash === hash);

			if (!feat) { 				console.warn(...LGT, `Could not find feat "${hash}" in loaded feat data!`);
				return null;
			}

			const $stgFeatureOptions = this._isFeatureSelect ? $(`<div class="ve-flex-col w-100"></div>`) : null;

			const $rowLeft = $$`<div class="mb-2">
				<div class="ve-flex-v-center">
					<div class="bold mr-2 no-shrink">Feat:</div>
					${Renderer.get().render(`{@feat ${feat.name}|${feat.source}}`)}
				</div>
				${$stgFeatureOptions}
			</div>`;

			const $rowRight = $(`<div class="ve-flex-col w-100"></div>`);
			this._render_displayFeat({$wrp: $rowRight, feat});

			if (this._isFeatureSelect) {
				this._feat_pGetFilteredFeatures(feat)
					.then(async filteredFeatures => {
						await this._feat_pRenderFeatureOptionsSelects({ix, type, $stgFeatureOptions, filteredFeatures, lockRenderFeatureOptionsSelects});
					});
			}

			return {
				$rowLeft,
				$rowRight,
			};
		}).filter(Boolean);

		$$`<div class="ve-flex-col w-100">
			${rowMetas.map(it => it.$rowLeft)}
		</div>`.appendTo($stgGroupLeft);

		$$`<div class="ve-flex-col w-100">
			${rowMetas.map(it => it.$rowRight)}
		</div>`.appendTo($stgGroupRight);
	}

	_render_displayFeat ({$wrp, feat}) {
		$wrp.empty();
		if (!feat) {
			$wrp.append(`<div class="ve-muted mb-2 italic ve-flex-vh-center">No feat selected.</div>`);
		} else {
									$wrp.append(Vetools.withUnpatchedDiceRendering(() => Renderer.hover.$getHoverContent_stats(UrlUtil.PG_FEATS, feat)));
		}
		$wrp.append(`<hr class="hr-0">`);
	}

		_render_renderPtChooseFromFilter ({$stgGroupLeft, $stgGroupRight, featSet, lastMetas}) {
		const type = "choose";

		const rowMetas = [...new Array(featSet.any)].map((_, ix) => {
						const {propIxFeat, propPrefixFeat} = this._getProps({ix, type});

			const {
				lockChangeFeat,
				lockRenderFeatureOptionsSelects,
			} = this._getLocks({ix, type});
			
			const {$sel: $selFeat, $btnFilter: $btnFilterForFeat, unhook} = Charactermancer_Util.getFilterSearchMeta({
				comp: this,
				prop: propIxFeat,
				data: this._featDatas,
				modalFilter: this._modalFilterFeats,
				title: "Feat",
			});
			lastMetas.push({cleanup: unhook});

			const $dispFeat = $(`<div class="ve-flex-col w-100"></div>`);

			const $stgFeatureOptions = this._isFeatureSelect ? $(`<div class="ve-flex-col w-100 mt-2"></div>`) : null;

			const $rowLeft = $$`<div class="ve-flex-col w-100">
				<div class="bold mb-2">Select a Feat</div>
				<div class="ve-flex-v-center btn-group w-100">${$btnFilterForFeat}${$selFeat}</div>
				${$stgFeatureOptions}
				<hr class="hr-1">
			</div>`;

			const _pHkChangeFeat = async () => {
								const nxtState = Object.keys(this.__state).filter(it => it.startsWith(propPrefixFeat) && it !== propIxFeat).mergeMap(it => ({[it]: null}));
				this._proxyAssignSimple("state", nxtState);

				const feat = this._featDatas[this._state[propIxFeat]];

				this._render_displayFeat({$wrp: $dispFeat, feat});

								if (this._isFeatureSelect) {
					const filteredFeatures = await this._feat_pGetFilteredFeatures(feat);

					await this._feat_pRenderFeatureOptionsSelects({ix, type, $stgFeatureOptions, filteredFeatures, lockRenderFeatureOptionsSelects});
				}
				
				this._state.pulse_feats = !this._state.pulse_feats;
			};
			const pHkChangeFeat = async (isLaterRun) => {
				try {
					await this._pLock(lockChangeFeat);
					await _pHkChangeFeat(isLaterRun);
				} finally {
					this._unlock(lockChangeFeat);
				}
			};
			this._addHookBase(propIxFeat, pHkChangeFeat);
			lastMetas.push({cleanup: () => this._removeHookBase(propIxFeat, pHkChangeFeat)});

			_pHkChangeFeat();

			return {
				$rowLeft,
				$rowRight: $dispFeat,
			};
		});

		$$`<div class="ve-flex-col w-100">
			${rowMetas.map(it => it.$rowLeft)}
		</div>`.appendTo($stgGroupLeft);

		$$`<div class="ve-flex-col w-100">
			${rowMetas.map(it => it.$rowRight)}
		</div>`.appendTo($stgGroupRight);
	}

		async _feat_pGetFilteredFeatures (feat) {
		if (!feat) return [];

		const feature = await this._feat_pGetFilteredFeatures_getCacheFeature(feat);

		return Charactermancer_Util.getFilteredFeatures(
			[feature],
			this._modalFilterFeats.pageFilter,
			this._modalFilterFeats.pageFilter.filterBox.getValues(),
		);
	}

		async _feat_pGetFilteredFeatures_getCacheFeature (feat) {
		const fromCache = this._cache_featFeatureLoadeds.get(feat);
		if (fromCache) return fromCache;

		const feature = await DataConverterFeat.pGetInitFeatureLoadeds(feat, {actor: this._actor});
		this._cache_featFeatureLoadeds.set(feat, feature);
		return feature;
	}

	async _feat_pRenderFeatureOptionsSelects (opts) {
		const {lockRenderFeatureOptionsSelects} = opts;

		try {
			await this._pLock(lockRenderFeatureOptionsSelects);
			await this._feat_pRenderFeatureOptionsSelects_(opts);
		} finally {
			this._unlock(lockRenderFeatureOptionsSelects);
		}
	}

	async _feat_pRenderFeatureOptionsSelects_ ({ix, type, filteredFeatures, $stgFeatureOptions}) {
		const prevCompsFeatures = this._compsFeatFeatureOptionsSelect[type]?.[ix]
			|| this._prevComp?._compsFeatFeatureOptionsSelect[type]?.[ix]
			|| [];

		$stgFeatureOptions.empty();

		const existingFeatureChecker = new Charactermancer_Class_Util.ExistingFeatureChecker(this._actor);

		const importableFeatures = Charactermancer_Util.getImportableFeatures(filteredFeatures);
		const cpyImportableFeatures = MiscUtil.copy(importableFeatures);
		Charactermancer_Util.doApplyFilterToFeatureEntries_bySource(
			cpyImportableFeatures,
			this._modalFilterFeats.pageFilter,
			this._modalFilterFeats.pageFilter.filterBox.getValues(),
		);
		const importableFeaturesGrouped = Charactermancer_Util.getFeaturesGroupedByOptionsSet(cpyImportableFeatures);

		this._feat_unregisterFeatureSourceTrackingFeatureComps(ix, type);

		for (const topLevelFeatureMeta of importableFeaturesGrouped) {
			const {topLevelFeature, optionsSets} = topLevelFeatureMeta;

			for (const optionsSet of optionsSets) {
				const compFeatureOptionsSelect = new Charactermancer_FeatureOptionsSelect({
					featureSourceTracker: this._featureSourceTracker,
					existingFeatureChecker,
					actor: this._actor,
					optionsSet,
					level: topLevelFeature.level,
					modalFilterSpells: this._modalFilterSpells,
					isSkipRenderingFirstFeatureTitle: true,
				});
				const tgt = MiscUtil.getOrSet(this._compsFeatFeatureOptionsSelect, type, ix, []);
				tgt.push(compFeatureOptionsSelect);
				compFeatureOptionsSelect.findAndCopyStateFrom(prevCompsFeatures);
			}
		}

		await this._feat_pRenderFeatureComps(ix, type, {$stgFeatureOptions});
	}

	_feat_unregisterFeatureSourceTrackingFeatureComps (ix, type) {
		(this._compsFeatFeatureOptionsSelect[type]?.[ix] || []).forEach(comp => comp.unregisterFeatureSourceTracking());
		delete this._compsFeatFeatureOptionsSelect[type]?.[ix];
	}

	async _feat_pRenderFeatureComps (ix, type, {$stgFeatureOptions}) {
		for (const compFeatureOptionsSelect of (this._compsFeatFeatureOptionsSelect[type]?.[ix] || [])) {
			if (await compFeatureOptionsSelect.pIsNoChoice() && !(await compFeatureOptionsSelect.pIsAvailable())) continue;

			if (!(await compFeatureOptionsSelect.pIsNoChoice()) || await compFeatureOptionsSelect.pIsForceDisplay()) {
				$stgFeatureOptions
					.showVe()
					.append(`${compFeatureOptionsSelect.modalTitle ? `<hr class="hr-2"><div class="mb-2 bold w-100">${compFeatureOptionsSelect.modalTitle}</div>` : ""}`);
			}
			compFeatureOptionsSelect.render($stgFeatureOptions);
		}
	}
	
		async pGetFormData () {
		const out = [];

		const ptrIsComplete = {_: true};

		const featSet = this._available[this._state.ixSet];
		await this._pGetFormData_static({out, featSet, ptrIsComplete});
		await this._pGetFormData_choose({out, featSet, ptrIsComplete});

		return {
			isFormComplete: ptrIsComplete._,
			data: out,
			ixsStatgen: this._state.readonly_ixsStatgen ? MiscUtil.copy(this._state.readonly_ixsStatgen) : null,
		};
	}

	async _pGetFormData_static ({out, featSet, ptrIsComplete}) {
		const uidsStatic = UtilAdditionalFeats.getUidsStatic(featSet);
		if (!uidsStatic?.length) return;

		const type = "static";

		for (let ix = 0; ix < uidsStatic.length; ++ix) {
			const outItem = this._getFormData_static_ix({uidsStatic, ix});
			if (outItem) out.push(outItem);

			if (!this._isFeatureSelect || !outItem) continue;

			const formDatasFeatureOptionsSelect = await (this._compsFeatFeatureOptionsSelect[type]?.[ix] || [])
				.filter(Boolean)
				.pSerialAwaitMap(it => it.pGetFormData());

			if (formDatasFeatureOptionsSelect.some(it => !it.isFormComplete)) ptrIsComplete._ = false;

			outItem.formDatasFeatureOptionsSelect = formDatasFeatureOptionsSelect;
		}
	}

	async _pGetFormData_choose ({out, featSet, ptrIsComplete}) {
		if (!featSet.any) return;

		const type = "choose";

		for (let ix = 0; ix < featSet.any; ++ix) {
			const outItem = this._getFormData_choose_ix({ix, ptrIsComplete});
			if (outItem) out.push(outItem);

			if (!this._isFeatureSelect || !outItem) continue;

			const formDatasFeatureOptionsSelect = await (this._compsFeatFeatureOptionsSelect[type]?.[ix] || [])
				.filter(Boolean)
				.pSerialAwaitMap(it => it.pGetFormData());

			if (formDatasFeatureOptionsSelect.some(it => !it.isFormComplete)) ptrIsComplete._ = false;

			outItem.formDatasFeatureOptionsSelect = formDatasFeatureOptionsSelect;
		}
	}

		getFormDataReduced () {
		const out = [];

		const ptrIsComplete = {_: true};

		const featSet = this._available[this._state.ixSet];
		this._getFormDataReduced_static({out, featSet});
		this._getFormDataReduced_choose({out, featSet, ptrIsComplete});

		return {
			isFormComplete: ptrIsComplete._,
			data: out,
			ixsStatgen: this._state.readonly_ixsStatgen ? MiscUtil.copy(this._state.readonly_ixsStatgen) : null,
		};
	}

	_getFormDataReduced_static ({out, featSet}) {
		const uidsStatic = UtilAdditionalFeats.getUidsStatic(featSet);
		if (!uidsStatic?.length) return;

		for (let ix = 0; ix < uidsStatic.length; ++ix) {
			const outItem = this._getFormData_static_ix({uidsStatic, ix});
			if (outItem) out.push(outItem);
		}
	}

	_getFormDataReduced_choose ({out, featSet, ptrIsComplete}) {
		if (!featSet.any) return;

		for (let ix = 0; ix < featSet.any; ++ix) {
			const outItem = this._getFormData_choose_ix({ix, ptrIsComplete});
			if (outItem) out.push(outItem);
		}
	}

	_getFormData_static_ix ({uidsStatic, ix}) {
		const uid = uidsStatic[ix];

		const {name, source} = DataUtil.proxy.unpackUid("feat", uid, "feat");
		const hash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_FEATS]({name, source});
		const ixFeat = this._featDatas.findIndex(it => it._hash === hash);
		const feat = this._featDatas[ixFeat];

		return {
			page: UrlUtil.PG_FEATS,
			source,
			hash,
			feat: MiscUtil.copy(feat, {isSafe: true}),
			ixFeat,
			type: "static",
			ix,
		};
	}

	_getFormData_choose_ix ({ix, ptrIsComplete}) {
		const {propIxFeat} = this._getProps({ix, type: "choose"});
		const ixFeat = this._state[propIxFeat];
		if (ixFeat == null || !~ixFeat) {
			ptrIsComplete._ = false;
			return;
		}

		const feat = this._featDatas[ixFeat];
		const hash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_FEATS](feat);

		return {
			page: UrlUtil.PG_FEATS,
			source: feat.source,
			hash,
			feat: MiscUtil.copy(feat, {isSafe: true}),
			ixFeat,
			type: "choose",
			ix,
		};
	}

	_getDefaultState () {
		return {
			ixSet: 0,

			pulse_feats: false,
			readonly_ixsStatgen: null,
		};
	}
}

class ImportListCharacter extends ImportList {
		async _pApplyAllAdditionalSpellsToActor ({entity, importOpts, dataBuilderOpts}) {
		const formData = await Charactermancer_AdditionalSpellsSelect.pGetUserInput({
			additionalSpells: entity.additionalSpells,
			sourceHintText: entity.name,
			modalFilterSpells: await Charactermancer_AdditionalSpellsSelect.pGetInitModalFilterSpells(),

						curLevel: 0,
			targetLevel: Consts.CHAR_MAX_LEVEL,
			spellLevelLow: 0,
			spellLevelHigh: 9,
		});

		if (formData == null) return dataBuilderOpts.isCancelled = true;
		if (formData === VeCt.SYM_UI_SKIP) return;

		await Charactermancer_AdditionalSpellsSelect.pApplyFormDataToActor(this._actor, formData, {taskRunner: importOpts.taskRunner});
	}

			async _pDoMergeAndApplyActorUpdate (actorUpdate) {
		if (!Object.keys(actorUpdate).length) return;

		this._doMergeExistingSkillToolData({actorUpdate, propActorData: "skills"});
		this._doMergeExistingSkillToolData({actorUpdate, propActorData: "tools"});
		this._doMergeExistingOtherProficiencyData({actorUpdate});
		this._doMergeExistingDiDrDvCiData({actorUpdate});
		await UtilDocuments.pUpdateDocument(this._actor, actorUpdate);
	}

	_doMergeExistingSkillToolData ({actorUpdate, prop}) {
		if (!actorUpdate?.system?.[prop]) return;
		Object.entries(actorUpdate.system[prop])
			.forEach(([abv, meta]) => {
				meta.value = Math.max(this._actor._source?.system?.[prop]?.[abv]?.value, meta.value, 0);
			});
	}

	_doMergeExistingOtherProficiencyData ({actorUpdate}) {
		const actorDataPaths = [
			["system", "traits", "languages"],
			["system", "traits", "weaponProf"],
			["system", "traits", "armorProf"],
		];
		return this._doMergeExistingGenericTraitsData({actorUpdate, actorDataPaths});
	}

	_doMergeExistingDiDrDvCiData ({actorUpdate}) {
		const actorDataPaths = [
			["system", "traits", "di"],
			["system", "traits", "dr"],
			["system", "traits", "dv"],
			["system", "traits", "ci"],
		];
		return this._doMergeExistingGenericTraitsData({actorUpdate, actorDataPaths});
	}

	_doMergeExistingGenericTraitsData ({actorUpdate, actorDataPaths}) {
		actorDataPaths.forEach(actorDataPath => {
			const actorUpdatePath = actorDataPath.slice(1);
			const fromActor = MiscUtil.get(this._actor, "_source", ...actorDataPath);
			const fromUpdate = MiscUtil.get(actorUpdate, ...actorUpdatePath);
			if (!fromActor && !fromUpdate) return;
			if (!fromActor && fromUpdate) return;
			if (fromActor && !fromUpdate) return MiscUtil.set(actorUpdate, ...actorUpdatePath, MiscUtil.copy(fromActor));

			if (fromActor.value && fromUpdate.value) {
				MiscUtil.set(actorUpdate, ...actorUpdatePath, "value", [...new Set([...fromActor.value, ...fromUpdate.value])]);
			} else {
				MiscUtil.set(actorUpdate, ...actorUpdatePath, "value", MiscUtil.copy(fromActor.value || fromUpdate.value));
			}

			if (fromActor.custom && fromActor.custom.trim().length && fromUpdate.custom && fromUpdate.custom.trim().length) {
				const allCustom = fromActor.custom.trim().split(";").map(it => it.trim()).filter(Boolean);
				fromUpdate.custom.trim().split(";")
					.map(it => it.trim())
					.filter(Boolean)
					.filter(it => !allCustom.some(ac => ac.toLowerCase() === it.toLowerCase()))
					.forEach(it => allCustom.push(it));

				MiscUtil.set(actorUpdate, ...actorUpdatePath, "custom", allCustom.join(";"));
			} else {
				MiscUtil.set(actorUpdate, ...actorUpdatePath, "custom", fromActor.custom || fromUpdate.custom);
			}
		});
	}
	
	async _pImportActorAdditionalFeats (ent, importOpts, dataBuilderOpts) {
		if (!ent.feats) return;

		const formData = await Charactermancer_AdditionalFeatsSelect.pGetUserInput({available: ent.feats, actor: this._actor});
		if (!formData) return dataBuilderOpts.isCancelled = true;
		if (formData === VeCt.SYM_UI_SKIP) return;

		if (!(formData.data || []).length) return;

		const {ImportListFeat} = await Promise.resolve().then(function () { return ImportListFeat$1; });
		const importListFeat = new ImportListFeat({actor: this._actor});
		await importListFeat.pInit();

		for (const {page, source, hash} of (formData.data || [])) {
			const feat = await DataLoader.pCacheAndGet(page, source, hash);
			await importListFeat.pImportEntry(feat, importOpts);
		}
	}

	static async _pPostLoad_pGetAllOptionalFeatures () {
		return {
			optionalfeature: [
				...(await DataUtil.loadJSON(Vetools.DATA_URL_OPTIONALFEATURES)).optionalfeature,
				...((await PrereleaseUtil.pGetBrewProcessed())?.optionalfeature || []),
				...((await BrewUtil2.pGetBrewProcessed())?.optionalfeature || []),
			],
		};
	}
}

ImportListCharacter.ImportEntryOpts = class {
	constructor (opts) {
		opts = opts || {};

		this.isCharactermancer = !!opts.isCharactermancer;

		this.isCancelled = false;

		this.items = [];
		this.effects = [];
		this.equipmentItemEntries = []; 	}
};

var ImportListCharacter$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ImportListCharacter: ImportListCharacter
});

function __variableDynamicImportRuntime0__(path) {
  switch (path) {
    case './ImportList.js': return Promise.resolve().then(function () { return ImportList$1; });
    case './ImportListAction.js': return Promise.resolve().then(function () { return ImportListAction$1; });
    case './ImportListActor.js': return Promise.resolve().then(function () { return ImportListActor$1; });
    case './ImportListAdventure.js': return Promise.resolve().then(function () { return ImportListAdventure$1; });
    case './ImportListAdventureBook.js': return Promise.resolve().then(function () { return ImportListAdventureBook$1; });
    case './ImportListBackground.js': return Promise.resolve().then(function () { return ImportListBackground$1; });
    case './ImportListBackgroundFeature.js': return Promise.resolve().then(function () { return ImportListBackgroundFeature$1; });
    case './ImportListBook.js': return Promise.resolve().then(function () { return ImportListBook$1; });
    case './ImportListCharacter.js': return Promise.resolve().then(function () { return ImportListCharacter$1; });
    case './ImportListCharCreationOption.js': return Promise.resolve().then(function () { return ImportListCharCreationOption$1; });
    case './ImportListClass.js': return Promise.resolve().then(function () { return ImportListClass$1; });
    case './ImportListClassFeature.js': return Promise.resolve().then(function () { return ImportListClassFeature$1; });
    case './ImportListConditionDisease.js': return Promise.resolve().then(function () { return ImportListConditionDisease$1; });
    case './ImportListCreature.js': return Promise.resolve().then(function () { return ImportListCreature$1; });
    case './ImportListCreatureFeature.js': return Promise.resolve().then(function () { return ImportListCreatureFeature$1; });
    case './ImportListCultBoon.js': return Promise.resolve().then(function () { return ImportListCultBoon$1; });
    case './ImportListDeck.js': return Promise.resolve().then(function () { return ImportListDeck$1; });
    case './ImportListDeity.js': return Promise.resolve().then(function () { return ImportListDeity$1; });
    case './ImportListFeat.js': return Promise.resolve().then(function () { return ImportListFeat$1; });
    case './ImportListFeature.js': return Promise.resolve().then(function () { return ImportListFeature$1; });
    case './ImportListHazard.js': return Promise.resolve().then(function () { return ImportListHazard$1; });
    case './ImportListItem.js': return Promise.resolve().then(function () { return ImportListItem$1; });
    case './ImportListJournal.js': return Promise.resolve().then(function () { return ImportListJournal$1; });
    case './ImportListLanguage.js': return Promise.resolve().then(function () { return ImportListLanguage$1; });
    case './ImportListMap.js': return Promise.resolve().then(function () { return ImportListMap$1; });
    case './ImportListObject.js': return Promise.resolve().then(function () { return ImportListObject$1; });
    case './ImportListOptionalFeature.js': return Promise.resolve().then(function () { return ImportListOptionalFeature$1; });
    case './ImportListPsionic.js': return Promise.resolve().then(function () { return ImportListPsionic$1; });
    case './ImportListRace.js': return Promise.resolve().then(function () { return ImportListRace$1; });
    case './ImportListRaceFeature.js': return Promise.resolve().then(function () { return ImportListRaceFeature$1; });
    case './ImportListRecipe.js': return Promise.resolve().then(function () { return ImportListRecipe$1; });
    case './ImportListReward.js': return Promise.resolve().then(function () { return ImportListReward$1; });
    case './ImportListRollableTable.js': return Promise.resolve().then(function () { return ImportListRollableTable$1; });
    case './ImportListSpell.js': return Promise.resolve().then(function () { return ImportListSpell$1; });
    case './ImportListTrap.js': return Promise.resolve().then(function () { return ImportListTrap$1; });
    case './ImportListVariantRule.js': return Promise.resolve().then(function () { return ImportListVariantRule$1; });
    case './ImportListVehicle.js': return Promise.resolve().then(function () { return ImportListVehicle$1; });
    case './ImportListVehicleUpgrade.js': return Promise.resolve().then(function () { return ImportListVehicleUpgrade$1; });
    default: return new Promise(function(resolve, reject) {
      (typeof queueMicrotask === 'function' ? queueMicrotask : setTimeout)(
        reject.bind(null, new Error("Unknown variable dynamic import: " + path))
      );
    })
   }
 }

class ImportListFeature extends ImportListCharacter {
		static init () {
		throw new Error(`Unimplemented!`);
	}
	
	constructor (...args) {
		super(...args);

		this._modalFilterSpells = new ModalFilterSpells({namespace: `${this.constructor.name}.spells`});
	}

	async pInit () {
		if (await super.pInit()) return true;

		await this._modalFilterSpells.pPreloadHidden();
	}

	static async _pGetSideData (actor, entity) {
		return this._DataConverter.pGetSideLoadedMatch(entity);
	}

	async _pMutActorUpdateFeature (entity, actUpdate, dataBuilderOpts) {
		await this.constructor._DataConverter.pMutActorUpdateFeature(this._actor, actUpdate, entity, dataBuilderOpts);
	}

	static async _pGetDereferencedFeatureItem (feature) {
		return this._DataConverter.pGetDereferencedFeatureItem(feature);
	}

	static async _pGetInitFeatureLoadeds (feature, {actor} = {}) {
		return this._DataConverter.pGetInitFeatureLoadeds(feature, {actor});
	}

	static async _pPostLoad_addFauxOptionalfeatures (data) {
		if (!data) return data;
		data = MiscUtil.copy(data);

		const out = {};

		Charactermancer_Feature_Util.addFauxOptionalFeatureEntries(
			data,
			(await this._pPostLoad_pGetAllOptionalFeatures()).optionalfeature,
		);

				for (const [k, arr] of Object.entries(data)) {
			if (!this.PROPS.includes(k)) continue;

			out[k] = (await arr
				.pSerialAwaitMap(async feature => {
					const loaded = await this._pGetInitFeatureLoadeds(feature);
					if (!loaded || loaded.isIgnored) return null;
					return feature;
				}))
				.filter(Boolean);
		}

		return out;
	}

		async _pImportEntry (feature, importOpts, dataOpts) {
		importOpts = importOpts || {};

				if (!this._actor) {
			const dereferenced = await this.constructor._pGetDereferencedFeatureItem(feature);
			return super._pImportEntry(dereferenced, importOpts, dataOpts);
		}

				if (importOpts.isLeaf) {
						if (importOpts.isSkippableLeaf && feature.entries?.[0]?.type === "options" && feature.entries?.length === 1) {
				return new ImportSummary({
					status: ConstsTaskRunner.TASK_EXIT_SKIPPED_OTHER,
				});
			}

			return super._pImportEntry(feature, importOpts, dataOpts);
		}

		const pageFilter = importOpts.isPreLoadedFeature
			? importOpts.featureEntriesPageFilter
			: this._pageFilter;
		const filterValues = importOpts.isPreLoadedFeature
			? (importOpts.featureEntriesPageFilterValues)
			: (importOpts.filterValues || (await this._pGetPageFilterValues()));

				let allFeatures;
		if (importOpts.isPreLoadedFeature) {
			allFeatures = [feature];
		} else {
			const wrappedFeature = await this.constructor._pGetInitFeatureLoadeds(feature, {actor: this._actor});
			allFeatures = [wrappedFeature];
		}

				allFeatures = Charactermancer_Util.getFilteredFeatures(
			allFeatures,
			pageFilter,
			filterValues,
		);

				if (!allFeatures.length) return ImportSummary.cancelled();

		allFeatures = Charactermancer_Util.getImportableFeatures(allFeatures);

		Charactermancer_Util.doApplyFilterToFeatureEntries_bySource(
			allFeatures,
			pageFilter,
			filterValues,
		);

		const allFeaturesGrouped = Charactermancer_Util.getFeaturesGroupedByOptionsSet(allFeatures);
		const actorUpdate = {};

		const importSummariesSub = [];

		for (const topLevelFeatureMeta of allFeaturesGrouped) {
			const {topLevelFeature, optionsSets} = topLevelFeatureMeta;

			for (let ixOptionSet = 0; ixOptionSet < optionsSets.length; ++ixOptionSet) {
				const optionsSet = optionsSets[ixOptionSet];

				const formDataOptionSet = await Charactermancer_FeatureOptionsSelect.pGetUserInput({
					actor: this._actor,
					optionsSet,
					level: topLevelFeature.level,
					existingFeatureChecker: importOpts.existingFeatureChecker,
					isSkipCharactermancerHandled: importOpts.isCharactermancer,
					modalFilterSpells: this._modalFilterSpells,
				});

				if (!formDataOptionSet) return ImportSummary.cancelled();
				if (formDataOptionSet === VeCt.SYM_UI_SKIP) continue;

				await Charactermancer_FeatureOptionsSelect.pDoApplyResourcesFormDataToActor({
					actor: this._actor,
					formData: formDataOptionSet,
				});

				await Charactermancer_FeatureOptionsSelect.pDoApplySensesFormDataToActor({
					actor: this._actor,
					actorUpdate,
					formData: formDataOptionSet,
					configGroup: this._configGroup,
				});

				for (const loaded of (formDataOptionSet.data?.features || [])) {
					const {entity, type} = loaded;

										const cpyEntity = MiscUtil.copy(entity);
					delete cpyEntity.additionalSpells;

					const isSkippableLeaf = ixOptionSet === 0 && optionsSets.length > 1;

					switch (type) {
						case "classFeature":
						case "subclassFeature": {
							const importResult = await this.pImportEntry(cpyEntity, {...importOpts, isLeaf: true, isSkippableLeaf});
							if (importResult?.status === ConstsTaskRunner.TASK_EXIT_CANCELLED) return importResult;
							importSummariesSub.push(importResult);
							break;
						}

						case "optionalfeature": {
							const importResult = await this._pImportEntry_pHandleGenericFeatureIndirect({
								ClassName: "ImportListOptionalFeature",
								propInstance: "_IMPORT_LIST_OPTIONAL_FEATURE",
								importOpts,
								cpyEntity,
								isSkippableLeaf,
							});
							if (importResult?.status === ConstsTaskRunner.TASK_EXIT_CANCELLED) return importResult;
							importSummariesSub.push(importResult);
							break;
						}

						case "feat": {
							const importResult = await this._pImportEntry_pHandleGenericFeatureIndirect({
								ClassName: "ImportListFeat",
								propInstance: "_IMPORT_LIST_FEAT",
								importOpts,
								cpyEntity,
								isSkippableLeaf,
							});
							if (importResult?.status === ConstsTaskRunner.TASK_EXIT_CANCELLED) return importResult;
							importSummariesSub.push(importResult);
							break;
						}

						case "reward": {
							const importResult = await this._pImportEntry_pHandleGenericFeatureIndirect({
								ClassName: "ImportListReward",
								propInstance: "_IMPORT_LIST_REWARD",
								importOpts,
								cpyEntity,
								isSkippableLeaf,
							});
							if (importResult?.status === ConstsTaskRunner.TASK_EXIT_CANCELLED) return importResult;
							importSummariesSub.push(importResult);
							break;
						}

						case "charoption": {
							const importResult = await this._pImportEntry_pHandleGenericFeatureIndirect({
								ClassName: "ImportListCharCreationOption",
								propInstance: "_IMPORT_LIST_CHAR_CREATION_OPTION",
								importOpts,
								cpyEntity,
								isSkippableLeaf,
							});
							if (importResult?.status === ConstsTaskRunner.TASK_EXIT_CANCELLED) return importResult;
							importSummariesSub.push(importResult);
							break;
						}

												default: {
							const importResult = await this._pImportEntry_pHandleGenericFeatureIndirect({
								ClassName: this.constructor.name,
								importOpts,
								cpyEntity,
								isSkippableLeaf,
							});
							if (importResult?.status === ConstsTaskRunner.TASK_EXIT_CANCELLED) return importResult;
							importSummariesSub.push(importResult);
							break;
						}
					}

										if (importOpts.existingFeatureChecker) importOpts.existingFeatureChecker.addImportFeature(loaded.page, loaded.source, loaded.hash);
				}

				await Charactermancer_FeatureOptionsSelect.pDoApplyProficiencyFormDataToActorUpdate(
					this._actor,
					actorUpdate,
					formDataOptionSet,
				);

				await Charactermancer_FeatureOptionsSelect.pDoApplyAdditionalSpellsFormDataToActor({
					taskRunner: importOpts.taskRunner,
					actor: this._actor,
					formData: formDataOptionSet,
					abilityAbv: importOpts.spellcastingAbilityAbv,
				});
			}
		}

		await this._pDoMergeAndApplyActorUpdate(actorUpdate);

		return new ImportSummary({
			status: ConstsTaskRunner.TASK_EXIT_COMPLETE,
			imported: [
				...importSummariesSub
					.filter(Boolean)
					.map(it => it.imported)
					.filter(Boolean)
					.flat(),
			],
		});
	}

	async _pImportEntry_pHandleGenericFeatureIndirect (
		{
			ClassName,
			propInstance,
			importOpts,
			cpyEntity,
			isSkippableLeaf,
		},
	) {
		const isDirectCall = this.constructor.name === ClassName;

		if (!isDirectCall && !propInstance) throw new Error(`Importer instance property must be specified for indirect calls! This is a bug!`);

		if (!isDirectCall && (!ImportListFeature[propInstance] || ImportListFeature[propInstance].actor !== this._actor)) {
						if (!ClassName.startsWith("ImportList")) throw new Error(`Expected importer to start with "ImportList"!`);
			const {[ClassName]: Clazz} = await __variableDynamicImportRuntime0__(`./ImportList${ClassName.replace(/^ImportList/, "")}.js`);
			
			ImportListFeature[propInstance] = new Clazz({actor: this._actor});
			await ImportListFeature[propInstance].pInit();
		}

		const importer = isDirectCall ? this : ImportListFeature[propInstance];

		const nxtOpts = {...importOpts, isLeaf: true, isSkippableLeaf};
		if (importer !== this) {
			delete nxtOpts.filterValues;
			delete nxtOpts.existingFeatureChecker;
		}

		return importer.pImportEntry(cpyEntity, nxtOpts);
	}

	async _pGetPageFilterValues () {
				if (!this._pageFilter.filterBox) await this._pageFilter.pInitFilterBox();
		return this._pageFilter.filterBox.getValues();
	}

	async _pImportEntry_pImportToActor (entity, importOpts) {
				const actUpdate = {system: {}};

		const dataBuilderOpts = new ImportListFeature.ImportEntryOpts({
			chosenAbilityScoreIncrease: entity._foundryChosenAbilityScoreIncrease,
			isCharactermancer: !!importOpts.isCharactermancer,
		});

		await this._pImportEntry_pImportToActor_fillFlags(entity, actUpdate, importOpts);
		await this._pImportEntry_pFillAbilities(entity, actUpdate, dataBuilderOpts);
		if (dataBuilderOpts.isCancelled) return ImportSummary.cancelled();

				const importedEmbeds = await this._pImportEntry_pFillItems(entity, actUpdate, importOpts, dataBuilderOpts);
		if (dataBuilderOpts.isCancelled) return ImportSummary.cancelled();

				if (Object.keys(actUpdate.system).length) await UtilDocuments.pUpdateDocument(this._actor, actUpdate);

						await this._pImportEntry_pAddSubEntities(entity, importOpts);
		
		if (this._actor.isToken) this._actor.sheet.render();

						const importedOut = importedEmbeds
			.filter(it => it.document)
			.map(it => new ImportedDocument({
				name: it.document.name,
				actor: this._actor,
				isExisting: it.isUpdate,
				embeddedDocument: it.document,
			}));
		if (!importedOut.length) {
			importedOut.push(new ImportedDocument({
				name: entity.name,
				actor: this._actor,
			}));
		}

		return new ImportSummary({
			status: ConstsTaskRunner.TASK_EXIT_COMPLETE,
			imported: importedOut,
		});
			}

	_pImportEntry_pImportToActor_fillFlags (feature, actor, importOpts) {
		const flags = {};
		const flagsDnd5e = {};

		this._doPopulateFlags({feature, actor, importOpts});

		if (Object.keys(flagsDnd5e).length) flags.dnd5e = flagsDnd5e;
		if (Object.keys(flags).length) actor.flags = flags;
	}

	_doPopulateFlags ({feature, actor, importOpts, flags, flagsDnd5e}) {  }

	async _pImportEntry_pFillAbilities (feature, actUpdate, dataBuilderOpts) {
		const formData = await Charactermancer_AbilityScoreSelect.pFillActorAbilityData(this._actor, feature.ability, actUpdate, dataBuilderOpts);
		if (dataBuilderOpts.isCancelled) return;

				if (formData == null) return;
		dataBuilderOpts.chosenAbilityScoreIncrease = formData.data;
	}

	async _pImportEntry_pFillItems (feature, actUpdate, importOpts, dataBuilderOpts) {
		await this._pMutActorUpdateFeature(feature, actUpdate, dataBuilderOpts);
		if (dataBuilderOpts.isCancelled) return;

		const spellHashToItemPosMap = {};

		await this._pImportEntry_pHandleAdditionalSpells(feature, actUpdate, importOpts, dataBuilderOpts, spellHashToItemPosMap);
		if (dataBuilderOpts.isCancelled) return;

		const tagHashItemIdMap = {};
		Object.entries(spellHashToItemPosMap)
			.forEach(([hash, id]) => MiscUtil.set(tagHashItemIdMap, "spell", hash, id));

		await UtilDataConverter.pGetWithDescriptionPlugins(
			async () => {
				const featureItem = await this.constructor._DataConverter.pGetDocumentJson(feature, {actor: this._actor, taskRunner: importOpts.taskRunner});
				dataBuilderOpts.items.push(featureItem);
				return featureItem;
			},
			{
				actorId: this._actor.id,
				tagHashItemIdMap,
			},
		);

		return UtilActors.pAddActorItems(this._actor, dataBuilderOpts.items);
	}

	async _pImportEntry_pHandleAdditionalSpells (feature, actUpdate, importOpts, dataBuilderOpts, spellHashToItemPosMap) {
		const maxAbilityScoreIncrease = Object.entries(dataBuilderOpts.chosenAbilityScoreIncrease || {})
			.sort(([, vA], [, vB]) => SortUtil.ascSort(vB, vA));
		const parentAbilityAbv = maxAbilityScoreIncrease?.[0]?.[0] || null;

		const formData = await Charactermancer_AdditionalSpellsSelect.pGetUserInput({
			additionalSpells: feature.additionalSpells,
			sourceHintText: feature.name,
			modalFilterSpells: await Charactermancer_AdditionalSpellsSelect.pGetInitModalFilterSpells(),

						curLevel: 0,
			targetLevel: Consts.CHAR_MAX_LEVEL,
			spellLevelLow: 0,
			spellLevelHigh: 9,
		});

		if (formData == null) return dataBuilderOpts.isCancelled = true;
		if (formData === VeCt.SYM_UI_SKIP) return;

		const totalClassLevels = UtilActors.getTotalClassLevels(this._actor);
		await Charactermancer_AdditionalSpellsSelect.pApplyFormDataToActor(
			this._actor,
			formData,
			{
				taskRunner: importOpts.taskRunner,
				parentAbilityAbv: parentAbilityAbv,
			},
		);
	}

	async _pImportEntry_pAddSubEntities (entity, importOpts) {
		await this.constructor._pGetClassSubclassFeatureAdditionalEntities(this._actor, entity, {taskRunner: importOpts.taskRunner});
	}

		static async _pGetClassSubclassFeatureAdditionalEntities (actor, entity, {taskRunner = null} = {}) {
		const sideData = await this._pGetSideData(actor, entity);
		if (!sideData) return [];
		if (!sideData.subEntities) return [];

		const {ChooseImporter} = await Promise.resolve().then(function () { return ChooseImporter$1; });

		for (const prop in sideData.subEntities) {
			if (!sideData.subEntities.hasOwnProperty(prop)) continue;

			const arr = sideData.subEntities[prop];
			if (!(arr instanceof Array)) continue;

			const importer = ChooseImporter.getImporter(prop, {actor});
			await importer.pInit();
			for (const ent of arr) {
				await importer.pImportEntry(
					ent,
					{
						taskRunner,
					},
				);
			}
		}
	}
}
ImportListFeature._IMPORT_LIST_FEAT = null;
ImportListFeature._IMPORT_LIST_OPTIONAL_FEATURE = null;
ImportListFeature._IMPORT_LIST_REWARD = null;
ImportListFeature._IMPORT_LIST_CHAR_CREATION_OPTION = null;

ImportListFeature.ImportEntryOpts = class extends ImportListCharacter.ImportEntryOpts {
	constructor (opts) {
		opts = opts || {};
		super(opts);

		this.chosenAbilityScoreIncrease = opts.chosenAbilityScoreIncrease;
	}
};

var ImportListFeature$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ImportListFeature: ImportListFeature
});

class ImportListFeat extends ImportListFeature {
		static init () {
		this._initCreateSheetItemHook({
			prop: "feat",
			importerName: "Feat",
		});
	}
	
	static get ID () { return "feats"; }
	static get DISPLAY_NAME_TYPE_SINGLE () { return "Feat"; }
	static get DISPLAY_NAME_TYPE_PLURAL () { return "Feats"; }
	static get PROPS () { return ["feat"]; }

	static _ = this.registerImpl(this);

	_dirsHomebrew = ["feat"];
	_titleSearch = "feat";
	_sidebarTab = "items";
	_gameProp = "items";
	_defaultFolderPath = ["Feats"];
	_pageFilter = new PageFilterFeats();
	_page = UrlUtil.PG_FEATS;
	_isPreviewable = true;
	_isDedupable = true;
	_configGroup = "importFeat";
	static _DataConverter = DataConverterFeat;

	async _pGetSources () {
		const argsShared = {pPostLoad: data => this.constructor._pPostLoad_addFauxOptionalfeatures(data)};
		return [
			new UtilDataSource.DataSourceUrl(
				Config.get("ui", "isStreamerMode") ? "SRD" : "5etools",
				Vetools.DATA_URL_FEATS,
				{
					...argsShared,
					filterTypes: [UtilDataSource.SOURCE_TYP_OFFICIAL_ALL],
					isDefault: true,
				},
			),
			...UtilDataSource.getSourcesCustomUrl({...argsShared}),
			...UtilDataSource.getSourcesUploadFile({...argsShared}),
			...(await this._pGetSourcesPrerelease({...argsShared})),
			...(await this._pGetSourcesBrew({...argsShared})),
		];
	}

	_colWidthName = 4;
	_colWidthSource = 1;

	_getData_cols_other () {
		return [
			{
				name: "Ability",
				width: 3,
				field: "ability",
			},
			{
				name: "Prerequisite",
				width: 3,
				field: "prerequisite",
			},
		];
	}

	_getData_row_mutGetAdditionalValues ({it, ix}) {
		return {
			ability: it._slAbility,
			prerequisite: it._slPrereq,
		};
	}

	_renderInner_absorbListItems_fnGetValues (it) {
		return {
			...super._renderInner_absorbListItems_fnGetValues(it),
			ability: it._slAbility,
			prerequisite: it._slPrereq,
		};
	}

	_doPopulateFlags ({feature: feat, actor, importOpts, flags, flagsDnd5e}) {
			}
}

ImportListFeat.UserChoose = class extends MixinUserChooseImporter(ImportListFeat) {};

var ImportListFeat$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ImportListFeat: ImportListFeat
});

class UtilItem {
	static getNameAsIdentifier (name) {
		return Util.Slugify.slugifyFast.call(name, {strict: true});
	}

	static getPrice ({cp}) {
		if (!UtilVersions.getSystemVersion().isVersionTwoOnePlus) return (cp || 0) / 100;

		const singleCurrency = CurrencyUtil.getAsSingleCurrency({cp});
		const [denomination, value] = Object.entries(singleCurrency)[0];

		return {
			value,
			denomination,
		};
	}

	
	static TYPE_WEAPON = "weapon";
	static TYPE_TOOL = "tool";
	static TYPE_CONSUMABLE = "consumable";
	static TYPE_EQUIPMENT = "equipment";
	static TYPE_BACKPACK = "backpack";
	static TYPE_LOOT = "loot";

	static TYPES_ITEM = new Set([
		this.TYPE_WEAPON,
		this.TYPE_TOOL,
		this.TYPE_CONSUMABLE,
		this.TYPE_EQUIPMENT,
		this.TYPE_BACKPACK,
		this.TYPE_LOOT,
	]);
}

class DataConverterItem extends DataConverter {
	static _SIDE_LOAD_OPTS = {
		propBrew: "foundryItem",
		fnLoadJson: Vetools.pGetItemSideData,
		propJson: "item",
	};

	static _SIDE_LOAD_OPTS_MAGICVARIANT = {
		propBrew: "foundryMagicvariant",
		fnLoadJson: Vetools.pGetItemSideData,
		propJson: "magicvariant",
	};

	static async pGetActionWeaponDetails ({size, action, damageParts, isSiegeWeapon, isMagical, isInfiniteAmmo, taskRunner = null}) {
		await Renderer.item.pPopulatePropertyAndTypeReference();

		await this._pGetActionWeaponDetails_initCaches({taskRunner});

		const out = {
			system: {
				"weaponType": "natural",
			},
		};

		const weaponLookupName = (action.name || "")
			.replace(/\(.*\)$/, "") 			.toLowerCase()
		;

		const weapon = DataConverterItem._WEAPON_DETAIL_CACHE[weaponLookupName] ? MiscUtil.copy(DataConverterItem._WEAPON_DETAIL_CACHE[weaponLookupName]) : null;

		if (weapon) {
			const itemData = await this.pGetDocumentJson(weapon, {size, isEquipped: true, quantity: 1, isActorItem: true, isInfiniteAmmo, taskRunner});
			Object.entries(itemData)
				.forEach(([prop, values]) => {
					if (["folder", "ownership", "sort"].includes(prop)) return;

					if (values == null) return out[prop] = values;
					if (typeof values !== "object") return out[prop] = MiscUtil.copy(values);

					out[prop] = out[prop] || {};
					Object.assign(out[prop], foundry.utils.flattenObject(values));
				});

						if (weapon._fvttImage) out.img = weapon._fvttImage;
		}

				if (damageParts.length > 1 && ((weapon && (weapon.property || []).includes("V")) || this._RE_IS_VERSATILE.test(JSON.stringify(action.entries || [])))) {
						const damageTypePrimary = damageParts[0][1];
			if (damageTypePrimary) {
				const ixDamagePartVersatile = damageParts.slice(1).findIndex(it => it[1] === damageTypePrimary);
				if (~ixDamagePartVersatile) {
					damageParts = MiscUtil.copy(damageParts);
										const cntVersatileParts = ixDamagePartVersatile + 1;
					const damagePartsVersatile = damageParts.splice(ixDamagePartVersatile + 1, cntVersatileParts);

																				out.system["damage.versatile"] = damagePartsVersatile[0][0];
					out.system["properties.ver"] = true;
				}
			}
		}
		
		if (isSiegeWeapon) out.system["weaponType"] = "siege";

				out.system["damage.parts"] = damageParts;

				if (isMagical) out.system["properties.mgc"] = true;
		
		return out;
	}

	static async _pGetActionWeaponDetails_initCaches ({taskRunner = null} = {}) {
		if (DataConverterItem._WEAPON_DETAIL_CACHE_INIT) return;

		await DataConverterItem._WEAPON_DETAIL_CACHE_LOCK.pLock();
		try {
			if (DataConverterItem._WEAPON_DETAIL_CACHE_INIT) return;

			console.log(...LGT, "Pre-caching item lookup...");

						const {item: items} = await Vetools.pGetItems();

			for (const item of items) {
				if (item.type === "GV") continue;

				const lowName = item.name.toLowerCase();
								const prefixBonusKey = lowName.replace(/^(.*?)( \+\d+$)/, (...m) => `${m[2].trim()} ${m[1].trim()}`);

				const itemKeys = [
					lowName,
					prefixBonusKey === lowName ? null : prefixBonusKey,
				].filter(Boolean);

				const cpy = MiscUtil.copy(item);
				const procFluff = await Renderer.item.pGetFluff(cpy);
				cpy._fvttImage = await this._pGetImagePath(cpy, {fluff: procFluff, propCompendium: "item", taskRunner});

				itemKeys.forEach(k => {
					if (!DataConverterItem._WEAPON_DETAIL_CACHE[k]) {
						DataConverterItem._WEAPON_DETAIL_CACHE[k] = cpy;
						return;
					}

										const existing = DataConverterItem._WEAPON_DETAIL_CACHE[k];
					if (
						!(existing.source === Parser.SRC_DMG || existing.source === Parser.SRC_PHB)
						&& SourceUtil.isNonstandardSource(existing.source)
					) {
						DataConverterItem._WEAPON_DETAIL_CACHE[k] = cpy;
					}
				});
			}

			console.log(...LGT, "Pre-caching complete.");

			DataConverterItem._WEAPON_DETAIL_CACHE_INIT = true;
		} finally {
			DataConverterItem._WEAPON_DETAIL_CACHE_LOCK.unlock();
		}
	}

		static async pGetDocumentJson (item, opts) {
		opts = opts || {};

		Renderer.get().resetHeaderIndex();

		await Renderer.item.pPopulatePropertyAndTypeReference();

		const entriesWithoutNotes = this._getEntriesWithoutNotes(item._fullEntries || item.entries);
		const entriesStr = entriesWithoutNotes ? JSON.stringify(entriesWithoutNotes) : "";

				if (item._isItemGroup) return this._pGetItemItem_loot(item, opts, entriesStr);

		const out = await this._pIsInSrd(item, opts)
			? await this._pGetItemItem_fromSrd(item, opts, entriesStr)
			: await this._pGetItemItem_notFromSrd(item, opts, entriesStr);

		if (opts.defaultOwnership != null) out.ownership = {default: opts.defaultOwnership};
		else if (opts.isAddDefaultOwnershipFromConfig) out.ownership = {default: Config.get("importItem", "ownership")};
		if (opts.userOwnership) Object.assign(out.ownership, opts.userOwnership);

				const replacementData = await UtilCompendium.getCompendiumEntity("item", item);

		if (replacementData) {
			[
				["system", "quantity"],
				["system", "attuned"],
				["system", "identified"],
				["system", "equipped"],
				["ownership"],
				["flags", SharedConsts.MODULE_ID],
			].forEach(path => {
				MiscUtil.getThenSetCopy(out, replacementData, ...path);
			});
			MiscUtil.set(replacementData, "system", "proficient", true);

			return replacementData;
		}
		
		return out;
	}

	static _getEntriesWithoutNotes (entries) {
		if (!entries?.length) return null;

		entries = MiscUtil.copyFast(entries);

		const walker = MiscUtil.getWalker();
		entries = walker
			.walk(
				entries,
				{
					string: (str) => {
						const tagSplit = Renderer.splitByTags(str);
						const len = tagSplit.length;
						let out = "";
						for (let i = 0; i < len; ++i) {
							const s = tagSplit[i];
							if (!s || s.startsWith("{@note ")) continue;
							out += s;
						}
						return out;
					},
				},
			);

		entries = walker
			.walk(
				entries,
				{
					array: (arr) => arr.filter(it => typeof it !== "string" || it.length),
				},
			);

		return entries;
	}

	static async _pGetItemImporterType (item) {
		const sideLoadedType = await this._pGetSideLoadedType(item);
		if (sideLoadedType != null) return sideLoadedType;

		if (
			item.type === "M"
			|| item.type === "R"
						|| item.dmg1
		) return UtilItem.TYPE_WEAPON;

		if (
			item.type === "AT" 			|| item.type === "T" 			|| item.type === "INS" 			|| item.type === "GS" 		) return UtilItem.TYPE_TOOL;

		if (
			item.type === "P" 			|| item.type === "SC" 			|| (item.type === "WD" && item.charges) 			|| (item.type === "RD" && item.charges) 			|| (item.type === "G" && item.charges) 			|| item.poison
			|| item.type === "A" 			|| item.type === "AF" 			|| item.type === "EXP"
		) return UtilItem.TYPE_CONSUMABLE;

		if (
			item.type === "HA" 			|| item.type === "MA" 			|| item.type === "LA" 			|| item.type === "S" 			|| item.bardingType 		) return UtilItem.TYPE_EQUIPMENT;

		if (item.containerCapacity) return UtilItem.TYPE_BACKPACK;

										if (
			item.bonusAc
			|| item.bonusSavingThrow
			|| item.bonusAbilityCheck
			|| item.bonusSpellAttack
			|| item.bonusSpellAttack
			|| item.bonusSpellSaveDc
			|| item.bonusProficiencyBonus
			|| item.ability
			|| item.wondrous
		) return UtilItem.TYPE_EQUIPMENT;

				if (this._ITEM_EQUIPMENT_NAME_RES.some(it => it.test(item.name))) return UtilItem.TYPE_EQUIPMENT;

				return UtilItem.TYPE_LOOT;
	}

	static async _pIsInSrd (item, {taskRunner = null} = {}) {
		const srdData = await UtilCompendium.getSrdCompendiumEntity("item", item, {fnGetAliases: ent => this._getCompendiumAliases(ent, {isStrict: true}), taskRunner});
		return !!srdData;
	}

		static _getCompendiumAliases (entity, {isStrict = false} = {}) {
		if (!entity.name) return [];

		const out = [];

						out.push(`${entity.name}s`);

		if (entity.name.toLowerCase().includes("feet")) out.push(entity.name.replace(/feet/g, "ft."));

										if (entity.name.includes(", ")) out.push(entity.name.replace(/, /g, " "));

				const mBrackets = /^([^(]+) \(([^)]+)\)$/.exec(entity.name.trim());
		if (mBrackets) out.push(`${mBrackets[2]} of ${mBrackets[1]}`);

				if (mBrackets) out.push(`${mBrackets[1]} ${mBrackets[2]}`);

				if (mBrackets) out.push(mBrackets[1]);

		if (!isStrict && entity.genericVariant) {
			out.push(entity.genericVariant.name);
			out.push(...this._getCompendiumAliases(entity.genericVariant));
		}

		if (!isStrict && entity.baseItem) {
			const [name, source] = entity.baseItem.split("|");
			out.push(name);
			out.push(...this._getCompendiumAliases({name, source: source || Parser.SRC_DMG}));
		}

		if (!isStrict && entity._baseName) {
			out.push(entity._baseName);
			out.push(...this._getCompendiumAliases({name: entity._baseName, source: entity._baseSource || entity.source}));
		}

		return out;
	}

	static getItemCompendiumAliases (ent, opts) { return this._getCompendiumAliases(ent, opts); }

	static _getItemFlags (item, opts) {
		opts = opts || {};

		const out = {
			[SharedConsts.MODULE_ID]: {
				page: UrlUtil.PG_ITEMS,
				source: item.source,
				hash: UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS](item),
			},
		};

		if (opts.isAddDataFlags) {
			out[SharedConsts.MODULE_ID].propDroppable = "item";
			out[SharedConsts.MODULE_ID].filterValues = opts.filterValues;
		}

		return out;
	}

	static async _pGetItemItem_notFromSrd (item, opts, entriesStr) {
		const importType = await this._pGetItemImporterType(item);

		switch (importType) {
			case UtilItem.TYPE_WEAPON: return this._pGetItemItem_weapon(item, opts, entriesStr);
			case UtilItem.TYPE_TOOL: return this._pGetItemItem_tool(item, opts, entriesStr);
			case UtilItem.TYPE_CONSUMABLE: return this._pGetItemItem_consumable(item, opts, entriesStr);
			case UtilItem.TYPE_EQUIPMENT: return this._pGetItemItem_equipment(item, opts, entriesStr);
			case UtilItem.TYPE_BACKPACK: return this._pGetItemItem_container(item, opts, entriesStr);
			case UtilItem.TYPE_LOOT: return this._pGetItemItem_loot(item, opts, entriesStr);
			default: throw new Error(`Unhandled importer type "${importType}"`);
		}
	}

	static async _pGetItemItem_fromSrd (item, opts = {}, entriesStr) {
		const srdData = await UtilCompendium.getSrdCompendiumEntity("item", item, {fnGetAliases: this._getCompendiumAliases.bind(this), taskRunner: opts.taskRunner});

		const {name: translatedName, description: translatedDescription, flags: translatedFlags} = this._getTranslationMeta({
			translationData: this._getTranslationData({srdData}),
			name: UtilApplications.getCleanEntityName(UtilDataConverter.getNameWithSourcePart(item, {isActorItem: opts.isActorItem})),
			description: await DataConverterItem._getItemItem_pGetItemDescription(item),
		});

		const rangeMeta = this._getWeaponRange(item, {srdData});
		const {weight, price, rangeShort, rangeUnits, rangeLong} = this._pGetItemItem_getWeightPriceRange(item, opts.size, rangeMeta);
		const {isAttuned, isIdentified, isEquipped, attunement} = await this._pGetItemItem_pGetAttunedIdentifiedEquipped(item, opts);
		const {consumeType, consumeTarget, consumeAmount} = this._pGetItemItem_getAmmoConsumeDetails(item, opts);
		const {acValue, maxDexBonus} = this._getItemAcMeta(item);

		const consume = {...(srdData.system.consume || {})};
		consume.type = consume.type || consumeType;
		consume.target = consume.target || consumeTarget;
		consume.amount = consume.amount || consumeAmount;

		const additionalData = await this._pGetDataSideLoaded(item);
		const additionalFlags = await this._pGetFlagsSideLoaded(item);

		const img = await this._pGetSaveImagePath(item, {fluff: await Renderer.item.pGetFluff(item), propCompendium: "item", taskRunner: opts.taskRunner});

		return {
			name: translatedName,
			type: item.foundryType || srdData.type,
			system: {
				...srdData.system,

				source: UtilDataConverter.getSourceWithPagePart(item),
				description: {value: translatedDescription, chat: "", unidentified: ""},

				proficient: true,
				quantity: opts.quantity != null ? opts.quantity : (item.quantity || 1),
				weight,
				price,
				attuned: isAttuned,
				identified: isIdentified,
				equipped: opts.isEquipped ?? isEquipped,
				rarity: this._getItemItem_getRarity(item),
				consume,
				range: {value: rangeShort, long: rangeLong, units: rangeUnits},

								"armor.value": acValue,
				"armor.dex": maxDexBonus,
				
				ability: opts.ability ?? srdData.system.ability,

				attunement,

				...(additionalData || {}),
			},
			img,
			ownership: {default: 0},
			flags: {
				...translatedFlags,
				...this._getItemFlags(item, opts),
				...additionalFlags,
			},
									effects: await this._pGetItemEffects(item, img, opts),
		};
	}

	static _pGetItemItem_getWeightPriceRange (item, size, {rangeShort, rangeLong, rangeUnits} = {}) {
		let weight = null;
		let price = null;
		let tmpValue = null;

		if (size == null || size === Parser.SZ_MEDIUM) {
			return {
				weight: Config.getMetricNumberWeight({configGroup: "importItem", originalValue: item.weight || 0, originalUnit: "lb"}),
				price: !isNaN(item.value) ? UtilItem.getPrice({cp: item.value}) : null,
				rangeShort: Config.getMetricNumberDistance({configGroup: "importItem", originalValue: rangeShort || 0, originalUnit: "ft"}),
				rangeLong: Config.getMetricNumberDistance({configGroup: "importItem", originalValue: rangeLong || 0, originalUnit: "ft"}),
				rangeUnits: Config.getMetricUnitDistance({configGroup: "importItem", originalUnit: rangeUnits}),
			};
		}

		const weightValueScalingMode = Config.get("importCreature", "itemWeightAndValueSizeScaling");

		switch (weightValueScalingMode) {
						case 1: {
				weight = item.weight || 0;
				tmpValue = item.value;
				break;
			}

						case 2: {
				const weightMult = DataConverterItem._SIZE_TO_ITEM_WEIGHT_MULT[size] || 1;
				const valueMult = DataConverterItem._SIZE_TO_ITEM_VALUE_MULT[size] || 1;

				if (item.weight && !isNaN(item.weight)) {
					weight = Number(item.weight) * weightMult;
				}

				if (item.value && !isNaN(item.value)) {
					tmpValue = item.value * valueMult;
				}

				break;
			}

						case 3: {
				const exponent = DataConverterItem._SIZE_TO_ITEM_WEIGHT_AND_VALUE_EXPONENT[size] || 1;

				if (item.weight && !isNaN(item.weight)) {
					weight = Math.floor(item.weight ** exponent);
				}

				if (item.value && !isNaN(item.value)) {
					const factor = item.value < 10 ? 1 : item.value < 100 ? 10 : 100;

										tmpValue = item.value / factor;

										tmpValue = Math.floor(tmpValue ** exponent);

										tmpValue *= factor;
				}

				break;
			}
		}

		if (tmpValue) price = UtilItem.getPrice({cp: tmpValue});

		return {
			weight: Config.getMetricNumberWeight({configGroup: "importItem", originalValue: weight || 0, originalUnit: "lb"}),
			price,

						rangeShort: Config.getMetricNumberDistance({configGroup: "importItem", originalValue: rangeShort || 0, originalUnit: "ft"}),
			rangeLong: Config.getMetricNumberDistance({configGroup: "importItem", originalValue: rangeLong || 0, originalUnit: "ft"}),
			rangeUnits: Config.getMetricUnitDistance({configGroup: "importItem", originalUnit: rangeUnits}),
		};
	}

		static async _pGetItemItem_pGetAttunedIdentifiedEquipped (item, opts) {
		opts = opts || {};

						const isMundane = item.rarity === "none" || item.rarity === "unknown" || item._category === "basic";
		const isAttuned = !isMundane && !!item.reqAttune;

		let isEquipped;
		const importType = await this._pGetItemImporterType(item);
		switch (importType) {
			case UtilItem.TYPE_WEAPON: isEquipped = true; break;
			case UtilItem.TYPE_TOOL: isEquipped = false; break;
			case UtilItem.TYPE_CONSUMABLE: isEquipped = false; break;
			case UtilItem.TYPE_EQUIPMENT: isEquipped = true; break;
			case UtilItem.TYPE_BACKPACK: isEquipped = false; break;
			case UtilItem.TYPE_LOOT: isEquipped = false; break;
			default: throw new Error(`Unhandled importer type "${importType}"`);
		}

		return {
			isAttuned,
						attunement: item.reqAttune
				? Config.get("importItem", opts.isActorItem ? "attunementTypeActor" : "attunementType")
				: CONFIG.DND5E.attunementTypes.NONE,
			isIdentified: !isMundane,
			isEquipped,
		};
	}

	static _getItemItem_pGetItemDescription (item) {
		if (!Config.get("importItem", "isImportDescription")) return "";

		return UtilDataConverter.pGetWithDescriptionPlugins(
			() => this._getItemItem_pGetItemDescription_(item),
		);
	}

	static _getItemItem_pGetItemDescription_ (item) {
				const [damage, damageType, propertiesTxt] = Renderer.item.getDamageAndPropertiesText(item);
		const [typeRarityText, subTypeText, tierText] = Renderer.item.getTypeRarityAndAttunementText(item);

		const headerPart = Config.get("importItem", "isImportDescriptionHeader")
			? `<div>
				${Renderer.item.getTypeRarityAndAttunementHtml(typeRarityText, subTypeText, tierText)}
					<div class="ve-flex w-100">
						<div class="col-4">${[Parser.itemValueToFull(item), Parser.itemWeightToFull(item)].filter(Boolean).join(", ").uppercaseFirst()}</div>
						<div class="col-8 text-right">${damage} ${damageType} ${propertiesTxt}</div>
					</div>
				</div>
			<hr>`
									: item.reqAttune && item.reqAttune !== true
				? `<div><i>${item._attunement}</i></div>`
				: "";

		const bodyPart = Renderer.item.getRenderedEntries(
			item,
			{
				isCompact: true,
				wrappedTypeAllowlist: Config.get("importItem", "isImportDescriptionHeader") ? null : new Set(["magicvariant"]),
			},
		);

		return `${headerPart}
		${bodyPart}`;
	}

	static _getItemItem_getItemUses (item) {
		let charges = null;

		if (item.charges) {
			if (isNaN(item.charges)) {
				const mDice = /{@dice (?<count>\d)+d(?<faces>\d+)\s*(?<bonus>[-+]\s*\d+)?}/i.exec(item.charges);
				if (mDice) {
					charges = (Number(mDice.groups.count) * Number(mDice.groups.faces)) + (mDice.groups.bonus ? Number(mDice.groups.bonus.replace(/\s*/g, "")) : 0);
				}
			} else charges = item.charges;
		}

		const usesPer = item.charges ? "charges" : UtilDataConverter.getFvttUsesPer(item.recharge);

		let usesRecovery = null;
		if (item.rechargeAmount) {
			if (typeof item.rechargeAmount === "number") {
				usesRecovery = item.rechargeAmount;
			} else {
				const mDice = /{@dice (?<formula>\d+d\d+\s*(?:[-+]\s*\d+)?)}/i.exec(item.rechargeAmount);
				if (mDice) {
					usesRecovery = mDice.groups.formula;
				}
			}
		}

		return {uses: charges, usesPer, usesRecovery};
	}

	static _getItemItem_getRarity (item) {
		const rawRarity = `${(item.rarity || "unknown")}`.toLowerCase().trim();

		switch (rawRarity) {
			case "common": return "common";
			case "uncommon": return "uncommon";
			case "rare": return "rare";
			case "very rare": return "veryRare";
			case "legendary": return "legendary";
			case "artifact": return "artifact";
			default: return "";
		}
	}

	static _getWeaponTypeBaseAndAbility (item) {
		let weaponType = "";
		let weaponAbility = "str";

		if (item.type === "A" || item.type === "AF") {
			weaponType = "ammo";
			weaponAbility = "dex";
		} else if (item.type === "M" || item.type === "R") {
			if ((item.weaponCategory || "").toLowerCase() === "martial") weaponType = `martial${item.type}`;
			else if ((item.weaponCategory || "").toLowerCase() === "simple") weaponType = `simple${item.type}`;
		}

		if (item.type === "R") weaponAbility = "dex";
		else if (item.property && item.property.includes("F")) weaponAbility = "dex"; 
		const weaponBaseItem = this._getBaseItem({item, weaponType});

		return {weaponType, weaponAbility, weaponBaseItem};
	}

	static _getBaseItem ({item, weaponType = null, armorType = null, toolType = null}) {
				
		let baseNameLower;
		let baseSourceLower;

		if (item.baseItem && typeof item.baseItem === "string") {
			let [name, source] = item.baseItem.toLowerCase().trim().split("|").map(it => it.trim());
			source = source || Parser.SRC_DMG.toLowerCase();

			baseNameLower = name;
			baseSourceLower = source;
		}

		if (item._baseName && item._baseSource) {
			baseNameLower = item._baseName.toLowerCase();
			baseSourceLower = item._baseSource.toLowerCase();
		}

				if (baseSourceLower !== Parser.SRC_PHB.toLowerCase() && baseSourceLower !== Parser.SRC_DMG.toLowerCase()) return null;

		if (weaponType) {
			const key = this._getWeaponIdKey({nameLower: baseNameLower});
			if (CONFIG.DND5E.weaponIds?.[key]) return key;
		} else if (armorType) {
			const key = this._getArmorShieldIdKey({nameLower: baseNameLower});
			if (CONFIG.DND5E.shieldIds?.[key] || CONFIG.DND5E.armorIds?.[key]) return key;
		} else if (toolType) {
			const key = this._getToolIdKey({nameLower: baseNameLower});
			if (CONFIG.DND5E.toolIds?.[key]) return key;
		}

		return null;
	}

	static _getWeaponRange (item, {srdData} = {}) {
		let rangeShort = 0;
		let rangeLong = 0;
		let rangeUnits = "ft";

		if (srdData) {
			rangeShort = MiscUtil.get(srdData, "system", "range", "value");
			rangeLong = MiscUtil.get(srdData, "system", "range", "long");
			rangeUnits = MiscUtil.get(srdData, "system", "range", "units") || rangeUnits;
		} else if (item.range) {
			const cleanRange = `${item.range}`.trim();
			const mRangeLong = /^(\d+)\/(\d+)$/i.exec(cleanRange);
			if (mRangeLong) {
				rangeShort = Number(mRangeLong[1]);
				rangeLong = Number(mRangeLong[2]);
			}

			const mRangeNum = /^(\d+)$/i.exec(cleanRange);
			if (mRangeNum) rangeShort = Number(mRangeNum[1]);
		} else if (item.property && item.property.includes("R")) { 			rangeShort = 10;
		} else { 			rangeShort = 5;
		}

		return {rangeShort, rangeLong, rangeUnits};
	}

	static _getWeaponProperties (item) {
		const out = item.property ? item.property.map(it => DataConverterItem._ITEM_PROP_MAP[it]).filter(Boolean).map(it => ({[it]: true})).reduce((a, b) => Object.assign(a, b), {}) : {};

		if (item._variantName === "Adamantine Weapon" || item._variantName === "Adamantine Armor" || item._variantName === "Adamantine Ammunition") out.ada = true; 		if (item.focus) out.foc = true; 		if (!Renderer.item.isMundane(item)) out.mgc = true; 		if (item._variantName === "Silvered Weapon" || item._variantName === "Silvered Ammunition") out.sil = true; 		if (item.firearm) out.fir = true; 
		return out;
	}

	static _getWeaponDamageAndFormula ({item, entriesStr}) {
		
		const parts = [];
		let formula = "";

		let dmg1 = "";
		if (item.dmg1) {
			dmg1 = item.dmg1;
			if (item.bonusWeapon) dmg1 = `${dmg1}${item.bonusWeapon}`;
			else if (item.bonusWeaponDamage) dmg1 = `${dmg1}${item.bonusWeaponDamage}`;
			dmg1 = `${dmg1}+@mod`;
			parts.push([
				dmg1,
				item.dmgType ? Parser.dmgTypeToFull(item.dmgType) : "",
			]);
		}

				const additionalMetas = [];
		entriesStr
			.replace(new RegExp(`(?:deals?|dealing|takes?) an extra {@(?:dice|damage) (?<dmg>[^}]+)}(?: (?<dmgType>${Parser.DMG_TYPES.join("|")}))? damage`, "g"), (...m) => {
				additionalMetas.push({
					dmg: m.last().dmg,
					dmgType: m.last().dmgType ? m.last().dmgType : "",
				});
			});

		if (Config.get("importItem", "isUseOtherFormulaFieldForExtraDamage")) {
			additionalMetas.forEach(({dmg, dmgType}) => {
				const op = formula && !/^[-+*/]/.test(dmg.trim()) ? " + " : "";
				formula += `${op}${dmg}${dmgType ? `[${dmgType}]` : ""}`;
			});
		} else {
			parts.push(...additionalMetas.map(({dmg, dmgType}) => [dmg, dmgType]));
		}
		
		let dmg2 = "";
		if (item.dmg2) {
			dmg2 = item.dmg2;
			if (item.bonusWeapon) dmg2 = `${dmg2}${item.bonusWeapon}`;
			else if (item.bonusWeaponDamage) dmg2 = `${dmg2}${item.bonusWeaponDamage}`;
			dmg2 = `${dmg2}+@mod`;
		}

		return {
			damage: {
				parts,
				versatile: dmg2,
			},
			formula,
		};
	}

	static async _pGetItemItem_weapon (item, opts, entriesStr) {
		const {weaponType, weaponAbility, weaponBaseItem} = this._getWeaponTypeBaseAndAbility(item);
		const rangeMeta = this._getWeaponRange(item);
		const {weight, price, rangeShort, rangeLong, rangeUnits} = this._pGetItemItem_getWeightPriceRange(item, opts.size, rangeMeta);
		const {isAttuned, isIdentified, isEquipped, attunement} = await this._pGetItemItem_pGetAttunedIdentifiedEquipped(item, opts);
		const {consumeType, consumeTarget, consumeAmount} = this._pGetItemItem_getAmmoConsumeDetails(item, opts);

				const itemProperties = this._getWeaponProperties(item);

		const {damage, formula} = this._getWeaponDamageAndFormula({item, entriesStr});

		const {uses, usesPer, usesRecovery} = this._getItemItem_getItemUses(item);

		const additionalData = await this._pGetDataSideLoaded(item);
		const additionalFlags = await this._pGetFlagsSideLoaded(item);

		const img = await this._pGetSaveImagePath(item, {fluff: await Renderer.item.pGetFluff(item), propCompendium: "item", taskRunner: opts.taskRunner});

		return {
			name: UtilApplications.getCleanEntityName(UtilDataConverter.getNameWithSourcePart(item, {isActorItem: opts.isActorItem})),
			type: item.foundryType || "weapon",
			system: {
				source: UtilDataConverter.getSourceWithPagePart(item),
				description: {value: await DataConverterItem._getItemItem_pGetItemDescription(item), chat: "", unidentified: ""},

				proficient: true,
				quantity: opts.quantity || item.quantity || 1,
				weight,
				price,
				attuned: isAttuned,
				identified: isIdentified,
				equipped: opts.isEquipped ?? isEquipped,
				rarity: this._getItemItem_getRarity(item),

				damage,
				range: {value: rangeShort, long: rangeLong, units: rangeUnits},
				weaponType: weaponType,
				baseItem: weaponBaseItem,
				ability: opts.ability ?? weaponAbility,
				properties: itemProperties,

				attunement,

				activation: {type: "action", cost: 1, condition: this._getItemItem_getActivationCondition({item, entriesStr})},
				duration: {value: 0, units: ""},
				target: {value: 0, units: "", type: ""},
				uses: {value: uses, max: uses, per: usesPer, recovery: usesRecovery},
				actionType: item.type === "R" ? "rwak" : "mwak",
				attackBonus: item.bonusWeapon || item.bonusWeaponAttack || null,
				chatFlavor: "",
				critical: {
					damage: item.bonusWeaponCritDamage ?? "",
					threshold: item.critThreshold ?? null,
				},

				formula,
				save: {ability: "", dc: 0, scaling: "spell"},
				consume: {type: consumeType, target: consumeTarget, amount: consumeAmount},

				hp: {value: 0, max: 0, dt: null, conditions: ""},
				speed: {value: null, conditions: ""},

				...(additionalData || {}),
			},
			img,
			ownership: {default: 0},
			flags: {
				...this._getItemFlags(item, opts),
				...additionalFlags,
			},
			effects: await this._pGetItemEffects(item, img, opts),
		};
	}

	static async _pGetItemItem_equipment (item, opts, entriesStr) {
		const {weight, price} = this._pGetItemItem_getWeightPriceRange(item, opts.size);
		const {isAttuned, isIdentified, isEquipped, attunement} = await this._pGetItemItem_pGetAttunedIdentifiedEquipped(item, opts);

		const {acValue, maxDexBonus} = this._getItemAcMeta(item);

		const {uses, usesPer, usesRecovery} = this._getItemItem_getItemUses(item);
		const armorType = DataConverterItem._ITEM_TYPE_TO_ARMOR_TYPE[item.bardingType ?? item.type] || "trinket";
		const baseItem = this._getBaseItem({item, armorType});

		const activationCondition = this._getItemItem_getActivationCondition({item, entriesStr});

		const additionalData = await this._pGetDataSideLoaded(item);
		const additionalFlags = await this._pGetFlagsSideLoaded(item);

		const img = await this._pGetSaveImagePath(item, {fluff: await Renderer.item.pGetFluff(item), propCompendium: "item", taskRunner: opts.taskRunner});

		return {
			name: UtilApplications.getCleanEntityName(UtilDataConverter.getNameWithSourcePart(item, {isActorItem: opts.isActorItem})),
			type: item.foundryType || "equipment",
			system: {
				source: UtilDataConverter.getSourceWithPagePart(item),
				description: {value: await DataConverterItem._getItemItem_pGetItemDescription(item), chat: "", unidentified: ""},

				proficient: true,
				quantity: opts.quantity || item.quantity || 1,
				weight,
				price,
				attuned: isAttuned,
				identified: isIdentified,
				equipped: opts.isEquipped ?? isEquipped,
				rarity: this._getItemItem_getRarity(item),

				ability: opts.ability,

				attunement,

				activation: {type: (activationCondition || uses || usesPer) ? "special" : "", cost: 0, condition: activationCondition},
				duration: {value: null, units: ""},
				target: {value: null, units: "", type: ""},
				range: {value: null, long: null, units: ""},
				uses: {value: uses, max: uses, per: usesPer, recovery: usesRecovery},
				actionType: "",
				attackBonus: null,
				chatFlavor: "",
				critical: {threshold: null, damage: ""},
				damage: {parts: [], versatile: ""},
				formula: "",
				save: {ability: "", dc: null, scaling: "spell"},
				armor: {
					type: armorType,
					value: acValue,
					dex: maxDexBonus,
				},
				strength: item.strength || null,
				stealth: !!item.stealth,
				consume: {type: "", target: null, amount: null},

				hp: {value: 0, max: 0, dt: null, conditions: ""},
				speed: {value: null, conditions: ""},

				baseItem,

				...(additionalData || {}),
			},
			img,
			ownership: {default: 0},
			flags: {
				...this._getItemFlags(item, opts),
				...additionalFlags,
			},
			effects: await this._pGetItemEffects(item, img, opts),
		};
	}

	static async _pGetItemItem_container (item, opts, entriesStr) {
		const {weight, price} = this._pGetItemItem_getWeightPriceRange(item, opts.size);
		const {isAttuned, isIdentified, isEquipped, attunement} = await this._pGetItemItem_pGetAttunedIdentifiedEquipped(item, opts);

		const capacityValue = !item.containerCapacity
			? 0
			: item.containerCapacity.weight
				? item.containerCapacity.weight.reduce((a, b) => a + b, 0)
				: Math.max(...item.containerCapacity.item.map(itemToCount => Math.max(...Object.values(itemToCount))));

		const additionalData = await this._pGetDataSideLoaded(item);
		const additionalFlags = await this._pGetFlagsSideLoaded(item);

		const img = await this._pGetSaveImagePath(item, {fluff: await Renderer.item.pGetFluff(item), propCompendium: "item", taskRunner: opts.taskRunner});

		return {
			name: UtilApplications.getCleanEntityName(UtilDataConverter.getNameWithSourcePart(item, {isActorItem: opts.isActorItem})),
			type: item.foundryType || "backpack",
			system: {
				source: UtilDataConverter.getSourceWithPagePart(item),
				description: {value: await DataConverterItem._getItemItem_pGetItemDescription(item), chat: "", unidentified: ""},

				quantity: opts.quantity || item.quantity || 1,
				weight,
				price,
				attuned: isAttuned,
				equipped: opts.isEquipped ?? isEquipped,
				identified: isIdentified,
				rarity: this._getItemItem_getRarity(item),
				capacity: {
					type: item.containerCapacity?.weight ? "weight" : "items",
					value: capacityValue,
					weightless: !!item.containerCapacity?.weightless,
				},

				ability: opts.ability,

				attunement,

				damage: {parts: []},

				...(additionalData || {}),
			},
			img,
			ownership: {default: 0},
			flags: {
				...this._getItemFlags(item, opts),
				...additionalFlags,
			},
			effects: await this._pGetItemEffects(item, img, opts),
		};
	}

	static async _pGetItemItem_consumable (item, opts, entriesStr) {
		const {weight, price} = this._pGetItemItem_getWeightPriceRange(item, opts.size);
		const {isAttuned, isIdentified, isEquipped, attunement} = await this._pGetItemItem_pGetAttunedIdentifiedEquipped(item, opts);

		const consType = (item.poison ? "poison" : DataConverterItem._ITEM_TYPE_TO_CONSUMABLE_TYPE[item.type]) || "";

		let rollOnCons = "";
		let autoDestroy = false;

		entriesStr.replace(/if you expend[^.]+last charge[^.]+roll[^.]+{@dice ([^}]+)}(?:[^.]+)?\.(?:[^.]+)on a[^.]+\d+[^.]+destroyed/ig, (...m) => {
			rollOnCons = m[1];
			autoDestroy = true;
		});
		if (item.type === "SC" || item.type === "P") autoDestroy = true;

				const actionType = ["A", "AF"].includes(item.type) ? "rwak" : null;
		let attackBonus = null;

		const dmgParts = [];
		if (["A", "AF"].includes(item.type) && (item.bonusWeapon || item.bonusWeaponDamage)) {
			attackBonus = Number(item.bonusWeapon || item.bonusWeaponAttack);

			dmgParts.push([
				Number(item.bonusWeapon || item.bonusWeaponDamage),
				null,
			]);
		}
		
		const {uses, usesPer, usesRecovery} = this._getItemItem_getItemUses(item);

		const additionalData = await this._pGetDataSideLoaded(item);
		const additionalFlags = await this._pGetFlagsSideLoaded(item);

		const img = await this._pGetSaveImagePath(item, {fluff: await Renderer.item.pGetFluff(item), propCompendium: "item", taskRunner: opts.taskRunner});

		return {
			name: UtilApplications.getCleanEntityName(UtilDataConverter.getNameWithSourcePart(item, {isActorItem: opts.isActorItem})),
			type: item.foundryType || "consumable",
			system: {
				source: UtilDataConverter.getSourceWithPagePart(item),
				description: {value: await DataConverterItem._getItemItem_pGetItemDescription(item), chat: "", unidentified: ""},

				quantity: opts.quantity || item.quantity || 1,
				weight,
				price,
				attuned: isAttuned,
				equipped: opts.isEquipped ?? isEquipped,
				identified: isIdentified,
				rarity: this._getItemItem_getRarity(item),

				consumableType: consType,

				ability: opts.ability,

				attunement,

				activation: {type: "action", cost: 1, condition: this._getItemItem_getActivationCondition({item, entriesStr})},
				duration: {value: null, units: ""},
				target: {value: null, units: "", type: ""},
				range: {value: null, long: null, units: ""},
				uses: {value: uses, max: uses, per: usesPer, recovery: usesRecovery, autoUse: true, autoDestroy: autoDestroy},
				actionType,
				attackBonus,
				chatFlavor: "",
				critical: {threshold: null, damage: ""},
				damage: {
					parts: dmgParts,
					versatile: "",
				},
				formula: rollOnCons, 				save: {ability: "", dc: null, scaling: "spell"},
				consume: {type: "", target: null, amount: null},
				hp: {value: 0, max: 0, dt: null, conditions: ""},
				speed: {value: null, conditions: ""},

				...(additionalData || {}),
			},
			img,
			ownership: {default: 0},
			flags: {
				...this._getItemFlags(item, opts),
				...additionalFlags,
			},
			effects: await this._pGetItemEffects(item, img, opts),
		};
	}

	static async _pGetItemItem_tool (item, opts, entriesStr) {
		const {weight, price} = this._pGetItemItem_getWeightPriceRange(item, opts.size);
		const {isAttuned, isIdentified, isEquipped, attunement} = await this._pGetItemItem_pGetAttunedIdentifiedEquipped(item, opts);

		let defaultAbil = DataConverterItem._ITEM_NAME_TO_DEFAULT_ABILITY[item.name] || "int";

		const toolType = DataConverterItem._ITEM_TYPE_TO_TOOL_TYPE[item.type] ?? "";
		const baseItem = this._getBaseItem({item, toolType});

		const additionalData = await this._pGetDataSideLoaded(item);
		const additionalFlags = await this._pGetFlagsSideLoaded(item);

		const img = await this._pGetSaveImagePath(item, {fluff: await Renderer.item.pGetFluff(item), propCompendium: "item", taskRunner: opts.taskRunner});

		return {
			name: UtilApplications.getCleanEntityName(UtilDataConverter.getNameWithSourcePart(item, {isActorItem: opts.isActorItem})),
			type: item.foundryType || "tool",
			system: {
				source: UtilDataConverter.getSourceWithPagePart(item),
				description: {value: await DataConverterItem._getItemItem_pGetItemDescription(item), chat: "", unidentified: ""},

				quantity: opts.quantity || item.quantity || 1,
				weight,
				price,
				attuned: isAttuned,
				equipped: opts.isEquipped ?? isEquipped,
				identified: isIdentified,
				rarity: this._getItemItem_getRarity(item),

				toolType,
				proficient: 1, 
				ability: opts.ability ?? defaultAbil,

				attunement,

				chatFlavor: "",
				damage: {parts: []},

				baseItem,

				...(additionalData || {}),
			},
			img,
			ownership: {default: 0},
			flags: {
				...this._getItemFlags(item, opts),
				...additionalFlags,
			},
			effects: await this._pGetItemEffects(item, img, opts),
		};
	}

	static async _pGetItemItem_loot (item, opts, entriesStr) {
		const {weight, price} = this._pGetItemItem_getWeightPriceRange(item, opts.size);
		const {isAttuned, isIdentified, isEquipped, attunement} = await this._pGetItemItem_pGetAttunedIdentifiedEquipped(item, opts);

		const additionalData = await this._pGetDataSideLoaded(item);
		const additionalFlags = await this._pGetFlagsSideLoaded(item);

		const img = await this._pGetSaveImagePath(item, {fluff: await Renderer.item.pGetFluff(item), propCompendium: "item", taskRunner: opts.taskRunner});

		return {
			name: UtilApplications.getCleanEntityName(UtilDataConverter.getNameWithSourcePart(item, {isActorItem: opts.isActorItem})),
			type: item.foundryType || "loot",
			system: {
				source: UtilDataConverter.getSourceWithPagePart(item),
				description: {value: await DataConverterItem._getItemItem_pGetItemDescription(item), chat: "", unidentified: ""},

				quantity: opts.quantity || item.quantity || 1,
				weight,
				price,
				attuned: isAttuned,
				equipped: opts.isEquipped ?? isEquipped,
				identified: isIdentified,
				rarity: this._getItemItem_getRarity(item),

				ability: opts.ability,

				attunement,

				damage: {parts: []},

				...(additionalData || {}),
			},
			img,
			ownership: {default: 0},
			flags: {
				...this._getItemFlags(item, opts),
				...additionalFlags,
			},
			effects: await this._pGetItemEffects(item, img, opts),
		};
	}

	static _getImgFallback (item) {
		if (item.staff) return `modules/${SharedConsts.MODULE_ID}/media/icon/orb-wand.svg`;
		return `modules/${SharedConsts.MODULE_ID}/media/icon/${DataConverterItem._ITEM_TYPE_TO_ICON[item.type] || "crossed-swords"}.svg`;
	}

	static _pGetItemItem_getAmmoConsumeDetails (item, opts) {
		let consumeType = "";
		let consumeTarget = "";
		let consumeAmount = null;

		if (item.ammoType && !opts.isInfiniteAmmo) {
			consumeType = "ammo";
			consumeAmount = 1;

			if (opts.sheetItemsAmmo) {
				const [ammoTypeName, ammoTypeSource] = item.ammoType.toLowerCase().split("|").map(it => it.trim()).filter(Boolean);
				const cleanAmmoTypeSource = (ammoTypeSource || Parser.SRC_DMG).toLowerCase();
				const cleanAmmoTypeName = ammoTypeName.replace(/s+$/g, ""); 
				const ammoTypeItems = opts.sheetItemsAmmo.filter(sheetItem => {
					const cleanSheetItemName = sheetItem.name.toLowerCase().trim().replace(/s+$/g, ""); 					return cleanSheetItemName === cleanAmmoTypeName
						&& (
							!Config.get("import", "isStrictMatching")
							|| (UtilDataConverter.getItemSource(sheetItem).source || "").toLowerCase() === cleanAmmoTypeSource
						);
				});

				if (ammoTypeItems.length) {
										consumeTarget = ammoTypeItems[0].id;
				}
			}
		}

		return {
			consumeType,
			consumeTarget,
			consumeAmount,
		};
	}

	static async _pGetImagePath_pGetCompendiumImage ({ent: item, propCompendium, taskRunner = null}) {
		const out = await super._pGetImagePath_pGetCompendiumImage({ent: item, propCompendium, taskRunner});
		if (out) return out;

				if (item._baseName) {
			const out = await UtilCompendium.pGetCompendiumImage(
				"item",
				{
					name: item._baseName,
					source: item._baseSource || item.source,
					srd: item._baseSrd,
				},
				{
					fnGetAliases: this._getCompendiumAliases.bind(this),
					taskRunner,
				},
			);
			if (out) return out;
		}

				if (item.baseItem && typeof item.baseItem === "string") {
			let [name, source] = item.baseItem.split("|");
			source = source || Parser.SRC_DMG;
			return UtilCompendium.pGetCompendiumImage(
				"item",
				{
					name: name,
					source: source,
					srd: true, 				},
				{
					fnGetAliases: this._getCompendiumAliases.bind(this),
					taskRunner,
				},
			);
		}
	}

	static _getItemAcMeta (item) {
		let acBonus = item.bonusAc ? Number(item.bonusAc) : 0;
		if (isNaN(acBonus)) acBonus = 0;

		const itemType = item.bardingType || item.type;

		const isArmorOrShield = itemType === "HA"
			|| itemType === "MA"
			|| itemType === "LA"
			|| itemType === "S";

		return {
			acValue: isArmorOrShield
				? (item.ac || 10) + acBonus
				: (acBonus || null), 			maxDexBonus: itemType === "MA"
				? item.dexterityMax !== undefined ? item.dexterityMax : 2
				: itemType === "HA" ? 0 : null,
			isTypeAutoCalculated: isArmorOrShield,
		};
	}

	
	static _getFauxGeneric (item) {
		return {name: item._variantName, source: item.source};
	}

	static async _pGetRootSideLoaded (ent, {propOpts = "_SIDE_LOAD_OPTS"} = {}) {
		const fromItem = await super._pGetRootSideLoaded(ent, {propOpts});

		if (!ent._variantName) return fromItem;

		const fromVariant = await super._pGetRootSideLoaded(this._getFauxGeneric(ent), {propOpts: "_SIDE_LOAD_OPTS_MAGICVARIANT"});
		if (!fromItem || !fromVariant) return fromVariant;

		return {
			...fromItem,
			...fromVariant,
		};
	}

	static async _pGetDataSideLoaded (ent, {propOpts = "_SIDE_LOAD_OPTS"} = {}) {
		const fromItem = await super._pGetDataSideLoaded(ent, {propOpts});

		if (!ent._variantName) return fromItem;

		const fromVariant = await super._pGetDataSideLoaded(this._getFauxGeneric(ent), {propOpts: "_SIDE_LOAD_OPTS_MAGICVARIANT"});
		if (!fromItem || !fromVariant) return fromVariant;

		return {
			...fromItem,
			...fromVariant,
		};
	}

	static async _pGetFlagsSideLoaded (ent, {propOpts = "_SIDE_LOAD_OPTS"} = {}) {
		const fromItem = await super._pGetFlagsSideLoaded(ent, {propOpts});

		if (!ent._variantName) return fromItem;

		const fromVariant = await super._pGetFlagsSideLoaded(this._getFauxGeneric(ent), {propOpts: "_SIDE_LOAD_OPTS_MAGICVARIANT"});
		if (!fromItem || !fromVariant) return fromVariant;

		return {
			...fromItem,
			...fromVariant,
		};
	}

	static async _pGetImgSideLoaded (ent, {propOpts = "_SIDE_LOAD_OPTS"} = {}) {
		const fromItem = await super._pGetImgSideLoaded(ent, {propOpts});
		if (fromItem || !ent._variantName) return fromItem;

		return super._pGetImgSideLoaded(this._getFauxGeneric(ent), {propOpts: "_SIDE_LOAD_OPTS_MAGICVARIANT"});
	}

	
	static _ITEM_EFFECTS_HINTS_SELF = {hintDisabled: false, hintTransfer: true};

	static async _pGetItemEffects (item, img, opts) {
		opts = opts || {};

		if (!Config.get("importItem", "isAddActiveEffects")) return [];

		const importType = await this._pGetItemImporterType(item);
		const isDisabled = importType === UtilItem.TYPE_CONSUMABLE || (opts.isEquipped != null && !opts.isEquipped);

		const out = [];

				if (await this.pHasItemSideLoadedEffects(null, item)) {
			const effectsSideTuples = await this._pGetItemItemEffectTuples(null, item, null, {img});
			effectsSideTuples.forEach(({effect, effectRaw}) => {
				out.push(DataConverter.mutEffectDisabledTransfer(
					effect,
					"importItem",
					UtilActiveEffects.getDisabledTransferHintsSideData(effectRaw),
				));
			});
		}
		
				const effectsAc = this._pGetItemEffects_getAcEffects(item, img, opts, {isDisabled});
		out.push(...DataConverter.mutEffectsDisabledTransfer(effectsAc, "importItem", this._ITEM_EFFECTS_HINTS_SELF));
		
				if (item.bonusSavingThrow) {
			const effect = this._pGetItemEffects_getGenericBonus({
				item,
				img,
				name: "Saving Throw Bonus",
				key: "system.bonuses.abilities.save",
				prop: "bonusSavingThrow",
				isDisabled,
			});
			if (effect) out.push(DataConverter.mutEffectDisabledTransfer(effect, "importItem", this._ITEM_EFFECTS_HINTS_SELF));
		}
		
				if (item.bonusAbilityCheck) {
			const effect = this._pGetItemEffects_getGenericBonus({
				item,
				img,
				name: "Ability Check Bonus",
				key: "system.bonuses.abilities.check",
				prop: "bonusAbilityCheck",
				isDisabled,
			});
			if (effect) out.push(DataConverter.mutEffectDisabledTransfer(effect, "importItem", this._ITEM_EFFECTS_HINTS_SELF));
		}
		
				if (item.bonusSpellAttack) {
			const effectMelee = this._pGetItemEffects_getGenericBonus({
				item,
				img,
				name: "Spell Attack Bonus (Melee)",
				key: "system.bonuses.msak.attack",
				prop: "bonusSpellAttack",
				isDisabled,
			});
			if (effectMelee) out.push(DataConverter.mutEffectDisabledTransfer(effectMelee, "importItem", this._ITEM_EFFECTS_HINTS_SELF));

			const effectRanged = this._pGetItemEffects_getGenericBonus({
				item,
				img,
				name: "Spell Attack Bonus (Ranged)",
				key: "system.bonuses.rsak.attack",
				prop: "bonusSpellAttack",
				isDisabled,
			});
			if (effectRanged) out.push(DataConverter.mutEffectDisabledTransfer(effectRanged, "importItem", this._ITEM_EFFECTS_HINTS_SELF));
		}
		
				if (item.bonusSpellAttack) {
			const effectMelee = this._pGetItemEffects_getGenericBonus({
				item,
				img,
				name: "Spell Damage Bonus (Melee)",
				key: "system.bonuses.msak.damage",
				prop: "bonusSpellDamage",
				isDisabled,
			});
			if (effectMelee) out.push(DataConverter.mutEffectDisabledTransfer(effectMelee, "importItem", this._ITEM_EFFECTS_HINTS_SELF));

			const effectRanged = this._pGetItemEffects_getGenericBonus({
				item,
				img,
				name: "Spell Damage Bonus (Ranged)",
				key: "system.bonuses.rsak.damage",
				prop: "bonusSpellDamage",
				isDisabled,
			});
			if (effectRanged) out.push(DataConverter.mutEffectDisabledTransfer(effectRanged, "importItem", this._ITEM_EFFECTS_HINTS_SELF));
		}
		
				if (item.bonusSpellSaveDc) {
			const effect = this._pGetItemEffects_getGenericBonus({
				item,
				img,
				name: "Spell Save DC Bonus",
				key: "system.bonuses.spell.dc",
				prop: "bonusSpellSaveDc",
				isDisabled,
			});
			if (effect) out.push(DataConverter.mutEffectDisabledTransfer(effect, "importItem", this._ITEM_EFFECTS_HINTS_SELF));
		}
		
				if (item.bonusProficiencyBonus) {
			const effect = this._pGetItemEffects_getGenericBonus({
				item,
				img,
				name: "Proficiency Bonus... Bonus?", 				key: "system.attributes.prof",
				prop: "bonusProficiencyBonus",
				isDisabled,
			});
			if (effect) out.push(DataConverter.mutEffectDisabledTransfer(effect, "importItem", this._ITEM_EFFECTS_HINTS_SELF));
		}
		
				if (item.ability) {
			if (item.ability.static) {
				Parser.ABIL_ABVS.forEach(ab => {
					if (item.ability.static[ab] == null) return;

					const effect = UtilActiveEffects.getGenericEffect({
						key: `system.abilities.${ab}.value`,
						value: item.ability.static[ab],
						mode: CONST.ACTIVE_EFFECT_MODES.UPGRADE,
						name: `Base ${Parser.attAbvToFull(ab)}`,
						icon: img,
						disabled: isDisabled,
						priority: UtilActiveEffects.PRIORITY_BASE,
					});
					out.push(DataConverter.mutEffectDisabledTransfer(effect, "importItem", this._ITEM_EFFECTS_HINTS_SELF));
				});
			}

			Parser.ABIL_ABVS.forEach(ab => {
				if (item.ability[ab] == null) return;

				const effect = UtilActiveEffects.getGenericEffect({
					key: `system.abilities.${ab}.value`,
					value: item.ability[ab],
					mode: CONST.ACTIVE_EFFECT_MODES.ADD,
					name: `Bonus ${Parser.attAbvToFull(ab)}`,
					icon: img,
					disabled: isDisabled,
					priority: UtilActiveEffects.PRIORITY_BONUS,
				});
				out.push(DataConverter.mutEffectDisabledTransfer(effect, "importItem", this._ITEM_EFFECTS_HINTS_SELF));
			});
		}
		
				const actorDataDrDiDvCi = DataConverter.getActorDamageResImmVulnConditionImm(item);
		const effectsDr = await this._pGetItemEffects_getDrDiDvCiEffects({img, name: "Damage Resistance", actProp: "dr", isDisabled, actorDataDrDiDvCi});
		const effectsDu = await this._pGetItemEffects_getDrDiDvCiEffects({img, name: "Damage Immunity", actProp: "di", isDisabled, actorDataDrDiDvCi});
		const effectsDv = await this._pGetItemEffects_getDrDiDvCiEffects({img, name: "Damage Vulnerability", actProp: "dv", isDisabled, actorDataDrDiDvCi});
		const effectsCi = await this._pGetItemEffects_getDrDiDvCiEffects({img, name: "Condition Immunity", actProp: "ci", isDisabled, actorDataDrDiDvCi});
		out.push(...DataConverter.mutEffectsDisabledTransfer(effectsDr, "importItem", this._ITEM_EFFECTS_HINTS_SELF));
		out.push(...DataConverter.mutEffectsDisabledTransfer(effectsDu, "importItem", this._ITEM_EFFECTS_HINTS_SELF));
		out.push(...DataConverter.mutEffectsDisabledTransfer(effectsDv, "importItem", this._ITEM_EFFECTS_HINTS_SELF));
		out.push(...DataConverter.mutEffectsDisabledTransfer(effectsCi, "importItem", this._ITEM_EFFECTS_HINTS_SELF));
		
				const speedChanges = [];
		if (item.modifySpeed?.multiply) {
			Object.entries(item.modifySpeed.multiply)
				.forEach(([speedMode, multiplier]) => {
					if (speedMode === "*") {
						Parser.SPEED_MODES.forEach(mode => {
							speedChanges.push(UtilActiveEffects.getGenericChange({
								key: `system.attributes.movement.${mode}`,
								value: multiplier,
								mode: CONST.ACTIVE_EFFECT_MODES.MULTIPLY,
								priority: UtilActiveEffects.PRIORITY_BONUS,
							}));
						});
						return;
					}

					speedChanges.push(UtilActiveEffects.getGenericChange({
						key: `system.attributes.movement.${speedMode}`,
						value: multiplier,
						mode: CONST.ACTIVE_EFFECT_MODES.MULTIPLY,
						priority: UtilActiveEffects.PRIORITY_BONUS,
					}));
				});
		}

		if (item.modifySpeed?.static) {
			Object.entries(item.modifySpeed.static)
				.forEach(([speedMode, value]) => {
					speedChanges.push(UtilActiveEffects.getGenericChange({
						key: `system.attributes.movement.${speedMode}`,
						value: value,
						mode: CONST.ACTIVE_EFFECT_MODES.UPGRADE,
						priority: UtilActiveEffects.PRIORITY_BASE,
					}));
				});
		}

		if (item.modifySpeed?.equal) {
			Object.entries(item.modifySpeed.equal)
				.forEach(([speedMode, otherSpeedMode]) => {
					speedChanges.push(UtilActiveEffects.getGenericChange({
						key: `system.attributes.movement.${speedMode}`,
						value: `@attributes.movement.${otherSpeedMode}`,
						mode: CONST.ACTIVE_EFFECT_MODES.UPGRADE,
						priority: UtilActiveEffects.PRIORITY_BASE,
					}));
				});
		}

		if (item.modifySpeed?.bonus) {
			Object.entries(item.modifySpeed.bonus)
				.forEach(([speedMode, bonus]) => {
										bonus = UiUtil.intToBonus(bonus);

					if (speedMode === "*") {
						Parser.SPEED_MODES.forEach(mode => {
							speedChanges.push(UtilActiveEffects.getGenericChange({
								key: `system.attributes.movement.${mode}`,
								value: bonus,
								mode: CONST.ACTIVE_EFFECT_MODES.ADD,
								priority: UtilActiveEffects.PRIORITY_BONUS,
							}));
						});
						return;
					}

					speedChanges.push(UtilActiveEffects.getGenericChange({
						key: `system.attributes.movement.${speedMode}`,
						value: bonus,
						mode: CONST.ACTIVE_EFFECT_MODES.ADD,
						priority: UtilActiveEffects.PRIORITY_BONUS,
					}));
				});
		}

		if (speedChanges.length) {
			const effect = UtilActiveEffects.getGenericEffect({
				name: `Speed Adjustment`,
				icon: img,
				disabled: isDisabled,
				changes: speedChanges,
			});
			out.push(DataConverter.mutEffectDisabledTransfer(effect, "importItem", this._ITEM_EFFECTS_HINTS_SELF));
		}
		
						
		return DataConverter.getEffectsMutDedupeId(out);
	}

	static _pGetItemEffects_getAcEffects (item, img, opts, {isDisabled}) {
		if (UtilCompat.isDaeGeneratingArmorEffects()) return [];

		const out = [];

		const acMeta = this._getItemAcMeta(item);
		if (acMeta.acValue != null && !acMeta.isTypeAutoCalculated) {
			out.push(UtilActiveEffects.getGenericEffect({
				key: "system.attributes.ac.bonus",
				value: acMeta.acValue,
				mode: CONST.ACTIVE_EFFECT_MODES.ADD,
				name: `Bonus AC`,
				icon: img,
				disabled: isDisabled,
				priority: UtilActiveEffects.PRIORITY_BONUS,
			}));
		}

		return out;
	}

	static _pGetItemEffects_getGenericBonus ({item, img, name, key, prop, isDisabled}) {
		const bonus = !isNaN(item[prop]) ? Number(item[prop]) : 0;
		if (!bonus) return null;

		return UtilActiveEffects.getGenericEffect({
			key,
						value: UiUtil.intToBonus(bonus),
			mode: CONST.ACTIVE_EFFECT_MODES.ADD,
			name,
			icon: img,
			disabled: isDisabled,
			priority: UtilActiveEffects.PRIORITY_BONUS,
		});
	}

	static _pGetItemEffects_getDrDiDvCiEffects ({img, name, actProp, isDisabled, actorDataDrDiDvCi}) {
		if (!actorDataDrDiDvCi[actProp]) return [];

		const out = [];

		if (actorDataDrDiDvCi[actProp].value) {
			actorDataDrDiDvCi[actProp].value.forEach(it => {
				out.push(UtilActiveEffects.getGenericEffect({
					key: `system.traits.${actProp}.value`,
					value: it,
					mode: CONST.ACTIVE_EFFECT_MODES.ADD,
					name,
					icon: img,
					disabled: isDisabled,
					priority: UtilActiveEffects.PRIORITY_BONUS,
				}));
			});
		}

		if (actorDataDrDiDvCi[actProp].custom?.length) {
			out.push(UtilActiveEffects.getGenericEffect({
				key: `system.traits.${actProp}.custom`,
				value: actorDataDrDiDvCi[actProp].custom,
				mode: CONST.ACTIVE_EFFECT_MODES.ADD,
				name,
				icon: img,
				disabled: isDisabled,
				priority: UtilActiveEffects.PRIORITY_BONUS,
			}));
		}

		return out;
	}

	static async _pGetSideLoadedType (item) {
		return DataConverter.pGetSideLoadedType_(item, {...this._SIDE_LOAD_OPTS, validTypes: new Set(DataConverterItem.VALID_FOUNDRY_ITEM_TYPES_IMPORT)});
	}

	static async pHasItemSideLoadedEffects (actor, item) {
		if ((await DataConverter._pGetEffectsRawSideLoaded_(item, this._SIDE_LOAD_OPTS))?.length > 0) return true;

		if (!item._variantName) return false;
		const fauxGeneric = {name: item._variantName, source: item.source};

		return (await DataConverter._pGetEffectsRawSideLoaded_(fauxGeneric, {propBrew: "foundryMagicvariant", fnLoadJson: Vetools.pGetItemSideData, propJson: "magicvariant"}))?.length > 0;
	}

	static async _pGetItemItemEffectTuples (actor, item, sheetItem, {img} = {}) {
		const effectsRaw = await DataConverter._pGetEffectsRawSideLoaded_(item, this._SIDE_LOAD_OPTS);
		const effects = UtilActiveEffects.getExpandedEffects(effectsRaw || [], {actor, sheetItem, parentName: item.name, img}, {isTuples: true});

		if (!item._variantName) return effects;
		const fauxGeneric = this._getFauxGeneric(item);

		const effectsRawVariant = await DataConverter._pGetEffectsRawSideLoaded_(fauxGeneric, {propBrew: "foundryMagicvariant", fnLoadJson: Vetools.pGetItemSideData, propJson: "magicvariant"});
		const effectsVariant = UtilActiveEffects.getExpandedEffects(effectsRawVariant || [], {actor, sheetItem, parentName: fauxGeneric.name, img}, {isTuples: true});

		return [...effects, ...effectsVariant];
	}

	static _getGenericIdKey ({nameLower}) { return nameLower.replace(/[^a-z]+/g, ""); }
	static _getWeaponIdKey ({nameLower}) { return this._getGenericIdKey({nameLower}); }
	static _getArmorShieldIdKey ({nameLower}) { return DataConverterItem._ITEM_NAME_TO_ARMOR_ID_KEY[nameLower] || this._getGenericIdKey({nameLower}); }
	static _getToolIdKey ({nameLower}) { return DataConverterItem._ITEM_NAME_TO_TOOL_ID_KEY[nameLower] || this._getGenericIdKey({nameLower}); }

	static _getItemItem_getActivationCondition ({item, entriesStr}) {
		entriesStr = entriesStr || JSON.stringify(item.entries || "");

		let out = "";

		entriesStr.replace(/command word|command phrase/gi, (...m) => {
			out = m[0];
		});

		return out.uppercaseFirst();
	}

			static async pGetCurrencyItem (currency, opts) {
		opts = opts || {};

		const weight = Config.getMetricNumberWeight({configGroup: "importItem", originalValue: this._getCurrencyWeight(currency), originalUnit: "lb"});
		const price = CurrencyUtil.getAsCopper(currency) / 100;

		const out = {
			name: "Currency",
			type: "loot",
			system: {
				description: {
					value: `<p>This collection of currency is made up of: ${Parser.getDisplayCurrency(currency)}</p>
						<hr class="hr-2">
						<p class="ve-muted italic">Drag-and-drop this item to an actor's sheet to add the currency to that actor.</p>`,
					chat: "",
					unidentified: "",
				},

				quantity: 1,
				weight,
				price,
			},
			img: "icons/commodities/currency/coins-assorted-mix-copper-silver-gold.webp",
			ownership: {default: 0},
			flags: {
				[SharedConsts.MODULE_ID]: {
					type: DataConverterItem.FLAG_TYPE__CURRENCY,
					currency: MiscUtil.copy(currency),
				},
			},
		};

		if (opts.defaultOwnership != null) out.ownership = {default: opts.defaultOwnership};
		else if (opts.isAddDefaultOwnershipFromConfig) out.ownership = {default: Config.get("importItem", "ownership")};
		if (opts.userOwnership) Object.assign(out.ownership, opts.userOwnership);

		return out;
	}

		static _getCurrencyWeight (currency) {
		return Object.entries(currency)
			.map(([coin, amount]) => 0.02 * (amount || 0))
			.reduce((a, b) => a + b, 0);
	}
	}

DataConverterItem._WEAPON_DETAIL_CACHE_INIT = false;
DataConverterItem._WEAPON_DETAIL_CACHE = {};
DataConverterItem._WEAPON_DETAIL_CACHE_LOCK = new VeLock();

DataConverterItem.VALID_FOUNDRY_ITEM_TYPES_IMPORT = [
	UtilItem.TYPE_WEAPON,
	UtilItem.TYPE_TOOL,
	UtilItem.TYPE_CONSUMABLE,
	UtilItem.TYPE_EQUIPMENT,
	UtilItem.TYPE_BACKPACK,
	UtilItem.TYPE_LOOT,
];

DataConverterItem.STACKABLE_FOUNDRY_ITEM_TYPES_IMPORT = [
	UtilItem.TYPE_CONSUMABLE,
	UtilItem.TYPE_LOOT,
];

DataConverterItem._ITEM_TYPE_TO_ARMOR_TYPE = {
	"HA": "heavy",
	"MA": "medium",
	"LA": "light",
	"S": "shield",
};
DataConverterItem._ITEM_TYPE_TO_CONSUMABLE_TYPE = {
	A: "ammo",
	AF: "ammo",
	P: "potion",
	SC: "scroll",
	WD: "wand",
	RD: "rod",
};
DataConverterItem._ITEM_TYPE_TO_TOOL_TYPE = {
	AT: "art",
	INS: "music",
	GS: "game",
};
DataConverterItem._ITEM_NAME_TO_DEFAULT_ABILITY = {
	"Alchemist's Supplies": "int",
	"Brewer's Supplies": "int",
	"Calligrapher's Supplies": "int",
	"Carpenter's Tools": "int",
	"Cartographer's Tools": "int",
	"Cobbler's Tools": "int",
	"Cook's Utensils": "wis",
	"Disguise Kit": "cha",
	"Forgery Kit": "int",
	"Glassblower's Tools": "int",
	"Herbalism Kit": "wis",
	"Jeweler's Tools": "int",
	"Leatherworker's Tools": "int",
	"Mason's Tools": "int",
	"Navigator's Tools": "wis",
	"Painter's Supplies": "int",
	"Poisoner's Kit": "wis",
	"Potter's Tools": "int",
	"Smith's Tools": "int",
	"Thieves' Tools": "dex",
	"Tinker's Tools": "int",
	"Weaver's Tools": "int",
	"Woodcarver's Tools": "int",
};
DataConverterItem._ITEM_TYPE_TO_ICON = {
	$: "cash", 	A: "quiver", 	AF: "quiver", 	AT: "toolbox", 	EM: "", 	EXP: "unlit-bomb", 	G: "backpack", 	GS: "rolling-dices", 	HA: "breastplate", 	INS: "guitar", 	LA: "leather-armor", 	M: "crossed-swords", 	MA: "scale-mail", 	MNT: "horse-head", 	GV: "", 	P: "potion-ball", 	R: "pocket-bow", 	RD: "crystal-wand", 	RG: "ring", 	S: "checked-shield", 	SC: "tied-scroll", 	SCF: "orb-wand", 	OTH: "battle-gear", 	T: "toolbox", 	TAH: "saddle", 	TG: "barrel", 	VEH: "old-wagon", 	SHP: "galleon", 	AIR: "air-balloon", 	SPC: "rocket-flight", 	WD: "fairy-wand", };

DataConverterItem._ITEM_PROP_MAP = {
	"A": "amm",
	"AF": "amm",
	"BF": "", 	"F": "fin",
	"H": "hvy",
	"L": "lgt",
	"LD": "lod",
	"R": "rch",
	"RLD": "rel",
	"S": "spc",
	"T": "thr",
	"2H": "two",
	"V": "ver",
};
DataConverterItem._ITEM_EQUIPMENT_NAME_RES = [
	"amulet of",
	"badge of",
	"band of",
	"belt of",
	"boots of",
	"bracelet of",
	"bracer of",
	"bracers of",
	"brooch of",
	"cape of",
	"circlet of",
	"clothes of",
	"crown of",
	"eyes of",
	"gauntlets of",
	"gloves of",
	"goggles of",
	"hat of",
	"headband of",
	"helm of",
	"mantle of",
	"mask of",
	"necklace of",
	"periapt of",
	"ring of",
	"rings of",
	"robe of",
	"slippers of",
].map(it => new RegExp(`(?:[ (]|^)${it}`, "i"));
DataConverterItem._SIZE_TO_ITEM_WEIGHT_MULT = {
	[Parser.SZ_FINE]: 0.5,
	[Parser.SZ_DIMINUTIVE]: 0.5,
	[Parser.SZ_TINY]: 0.5,
	[Parser.SZ_SMALL]: 1,
	[Parser.SZ_MEDIUM]: 1,
	[Parser.SZ_LARGE]: 2,
	[Parser.SZ_HUGE]: 4,
	[Parser.SZ_GARGANTUAN]: 8,
	[Parser.SZ_COLOSSAL]: 16,
	[Parser.SZ_VARIES]: 1,
};
DataConverterItem._SIZE_TO_ITEM_VALUE_MULT = {
	[Parser.SZ_FINE]: 0.25,
	[Parser.SZ_DIMINUTIVE]: 0.25,
	[Parser.SZ_TINY]: 0.25,
	[Parser.SZ_SMALL]: 1,
	[Parser.SZ_MEDIUM]: 1,
	[Parser.SZ_LARGE]: 4,
	[Parser.SZ_HUGE]: 16,
	[Parser.SZ_GARGANTUAN]: 64,
	[Parser.SZ_COLOSSAL]: 256,
	[Parser.SZ_VARIES]: 1,
};
DataConverterItem._SIZE_TO_ITEM_WEIGHT_AND_VALUE_EXPONENT = {
	[Parser.SZ_FINE]: 0.5,
	[Parser.SZ_DIMINUTIVE]: 0.5,
	[Parser.SZ_TINY]: 0.5,
	[Parser.SZ_SMALL]: 1,
	[Parser.SZ_MEDIUM]: 1,
	[Parser.SZ_LARGE]: 2,
	[Parser.SZ_HUGE]: 3,
	[Parser.SZ_GARGANTUAN]: 4,
	[Parser.SZ_COLOSSAL]: 5,
	[Parser.SZ_VARIES]: 1,
};

DataConverterItem._ITEM_NAME_TO_ARMOR_ID_KEY = {
	"half plate armor": "halfplate",
	"hide armor": "hide",
	"leather armor": "leather",
	"padded armor": "padded",
	"plate armor": "plate",
	"splint armor": "splint",
	"studded leather armor": "studded",
};
DataConverterItem._ITEM_NAME_TO_TOOL_ID_KEY = {
	"alchemist's supplies": "alchemist",
	"brewer's supplies": "brewer",
	"calligrapher's supples": "calligrapher",
	"playing card set": "card",
	"carpenter's tools": "carpenter",
	"cartographer's tools": "cartographer",
	"dragonchess set": "chess",
	"cobbler's tools": "cobbler",
	"cook's utensils": "cook",
	"dice set": "dice",
	"disguise kit": "disg",
	"forgery kit": "forg",
	"glassblower's tools": "glassblower",
	"herbalism kit": "herb",
	"jeweler's tools": "jeweler",
	"leatherworker's tools": "leatherworker",
	"mason's tools": "mason",
	"navigator's tools": "navg",
	"painter's supplies": "painter",
	"poisoner's kit": "pois",
	"potter's tools": "potter",
	"smith's tools": "smith",
	"thieves' tools": "thief",
	"tinker's tools": "tinker",
	"weaver's tools": "weaver",
	"woodcarver's tools": "woodcarver",
};

DataConverterItem.FLAG_TYPE__CURRENCY = "currency";

var DataConverterItem$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DataConverterItem: DataConverterItem
});

class UtilTokens {
	static getTokenDimensionsAndScale (size) {
		return {
			[Parser.SZ_TINY]: {dimensions: 0.5},
			[Parser.SZ_SMALL]: {dimensions: 1, scale: 0.8},
			[Parser.SZ_LARGE]: {dimensions: 2},
			[Parser.SZ_HUGE]: {dimensions: 3},
			[Parser.SZ_GARGANTUAN]: {dimensions: 4},
		}[size] || {};
	}
}

class ModelImportActorMeta {
	constructor (
		{
			duplicateMeta,
		},
	) {
		this.actor = null;
		this.isSkipFolder = false;
		this.duplicateMeta = duplicateMeta;
	}
}

class ImportListActor extends ImportList {
	static get FOLDER_TYPE () { return "Actor"; }

	_actorType = null;
	_threeDiTokenAdapter = null;

	async pInit () {
		if (await super.pInit()) return true;

		if (this._threeDiTokenAdapter) await this._threeDiTokenAdapter.pInit();
	}

	_postLoad_setHasTokenThreeDiFlag (data) {
		if (this._threeDiTokenAdapter) {
			this.constructor.PROPS
				.forEach(prop => {
					(data[prop] || [])
						.forEach(ent => ent.hasToken3d = !!this._threeDiTokenAdapter.getPrimaryMeta(ent));
				});
		}

		return data;
	}

			async _pImportEntry (imp, importOpts, dataOpts) {
		importOpts = importOpts || {};

		if ((importOpts.isTemp || importOpts.isDataOnly) && importOpts.isImportToTempDirectory) throw new Error(`Incompatible options "isTemp"/"isDataOnly" and "isImportToTempDirectory" supplied!`);
		if (this._pack && importOpts.isImportToTempDirectory) throw new Error(`Option "isImportToTempDirectory" cannot be used in conjunction with compendium imports!`);

		console.log(...LGT, `Importing ${imp.foundryType || this._actorType} "${imp.name}" (from "${Parser.sourceJsonToAbv(imp.source)}")`);

		Renderer.get().resetHeaderIndex();

		imp = await this._pGetCustomizedEntity({ent: imp});

		const model = new ModelImportActorMeta({
			duplicateMeta: importOpts.duplicateMeta || this._getDuplicateMeta({entity: imp, importOpts}),
		});

		if (model.duplicateMeta.isSkip) {
			return new ImportSummary({
				status: ConstsTaskRunner.TASK_EXIT_SKIPPED_DUPLICATE,
				imported: [
					new ImportedDocument({
						isExisting: true,
						document: model.duplicateMeta.existing,
					}),
				],
			});
		}

		await this._pImportEntry_pMutInitialModel({imp, model, importOpts});

		const {dataBuilderOpts, actorData} = await this._pImportEntry_pGetImportMetadata(model.actor, imp, importOpts, {isSkipFolder: model.isSkipFolder});

		const additionalData = this.constructor._DataConverter ? await this.constructor._DataConverter._pGetDataSideLoaded(imp) : null;
		if (additionalData) Object.assign(actorData.system || {}, additionalData);

		const additionalFlags = this.constructor._DataConverter ? await this.constructor._DataConverter._pGetFlagsSideLoaded(imp) : null;
		if (additionalFlags) Object.assign(actorData.flags || {}, additionalFlags);

		const imgEffects = actorData.img ?? actorData.prototypeToken?.texture?.src;

		if (importOpts.isTemp) return this._pImportEntry_pImportToTemp({imp, importOpts, dataOpts, model, actorData, dataBuilderOpts, imgEffects});
		else if (this._pack) return this._pImportEntry_pImportToPack({imp, importOpts, dataOpts, model, actorData, dataBuilderOpts, imgEffects});
		else return this._pImportEntry_pImportToDirOrDoc({imp, importOpts, dataOpts, model, actorData, dataBuilderOpts, imgEffects});
	}

	async _pImportEntry_pMutInitialModel ({imp, model, importOpts}) {
		if (model.duplicateMeta.isOverwrite) {
			model.isSkipFolder = true;
			model.actor = model.duplicateMeta.existing;
		} else if (this._pack) {
			model.actor = null;
		} else {
						model.actor = await Actor.create(
				{name: Consts.ACTOR_TEMP_NAME, type: imp.foundryType || this._actorType, flags: {[SharedConsts.MODULE_ID]: {isImporterTempActor: true}}},
				{renderSheet: !!importOpts.isTemp, temporary: !!importOpts.isTemp},
			);
		}
	}

	async _pImportEntry_pMutModelTempActor ({imp, importOpts, dataOpts, model, actorData, dataBuilderOpts, imgEffects}) {
		model.actor = await UtilDocuments.pCreateDocument(Actor, {...actorData, type: imp.foundryType || this._actorType}, {isTemporary: true});
		dataBuilderOpts.actor = model.actor;

		await this._pImportEntry_populateItemsAndEffects({
			imp,
			importOpts,
			duplicateMeta: model.duplicateMeta,
			actor: model.actor,
			actorData,
			dataBuilderOpts,
			imgEffects,
		});
	}

	async _pImportEntry_pImportToTemp ({imp, importOpts, dataOpts, model, actorData, dataBuilderOpts, imgEffects}) {
		await this._pImportEntry_pMutModelTempActor({imp, importOpts, dataOpts, model, actorData, dataBuilderOpts, imgEffects});

				await this._pImportEntry_pHandlePostItemItemUpdates(model.actor, importOpts, dataBuilderOpts);

		if (importOpts.isDataOnly) {
			return new ImportSummary({
				status: ConstsTaskRunner.TASK_EXIT_COMPLETE_DATA_ONLY,
				imported: [
					new ImportedDocument({
						document: model.actor,
					}),
				],
			});
		}

		return new ImportSummary({
			status: ConstsTaskRunner.TASK_EXIT_COMPLETE,
			imported: [
				new ImportedDocument({
					document: model.actor,
				}),
			],
		});
	}

	async _pImportEntry_pImportToPack ({imp, importOpts, dataOpts, model, actorData, dataBuilderOpts, imgEffects}) {
		if (model.duplicateMeta.isOverwrite) {
			dataBuilderOpts.actor = model.actor;

			await this._pImportEntry_populateItemsAndEffects({
				imp,
				importOpts,
				duplicateMeta: model.duplicateMeta,
				actor: model.actor,
				actorData,
				dataBuilderOpts,
				imgEffects,
			});

			await UtilDocuments.pUpdateDocument(model.actor, actorData);

						await this._pImportEntry_pHandlePostItemItemUpdates(model.actor, importOpts, dataBuilderOpts);

			await this._pImportEntry_pAddToTargetTableIfRequired([model.actor], model.duplicateMeta);

			return new ImportSummary({
				status: ConstsTaskRunner.TASK_EXIT_COMPLETE_UPDATE_OVERWRITE_DUPLICATE,
				imported: [
					new ImportedDocument({
						document: model.actor,
					}),
				],
			});
		}

		await this._pImportEntry_pMutModelTempActor({imp, importOpts, dataOpts, model, actorData, dataBuilderOpts, imgEffects});

		const actorImported = await this._pack.importDocument(model.actor);

				await this._pImportEntry_pHandlePostItemItemUpdates(actorImported, importOpts, dataBuilderOpts);

		await this._pImportEntry_pAddToTargetTableIfRequired([model.actor], model.duplicateMeta);

		return new ImportSummary({
			status: ConstsTaskRunner.TASK_EXIT_COMPLETE,
			imported: [
				new ImportedDocument({
					document: model.actor,
				}),
			],
		});
	}

	async _pImportEntry_pImportToDirOrDoc ({imp, importOpts, dataOpts, model, actorData, dataBuilderOpts, imgEffects}) {
		await this._pImportEntry_populateItemsAndEffects({
			imp,
			importOpts,
			duplicateMeta: model.duplicateMeta,
			actor: model.actor,
			actorData,
			dataBuilderOpts,
			imgEffects,
		});

				await UtilDocuments.pUpdateDocument(model.actor, actorData);

				await model.actor.update({
			flags: {
				[SharedConsts.MODULE_ID]: {
					[`-=isImporterTempActor`]: null,
				},
			},
		});

		await game.actors.set(model.actor.id, model.actor);

				await this._pImportEntry_pHandlePostItemItemUpdates(model.actor, importOpts, dataBuilderOpts);

		return new ImportSummary({
			status: model.duplicateMeta.isOverwrite
				? this._actor
					? ConstsTaskRunner.TASK_EXIT_COMPLETE_UPDATE_OVERWRITE
					: ConstsTaskRunner.TASK_EXIT_COMPLETE_UPDATE_OVERWRITE_DUPLICATE
				: ConstsTaskRunner.TASK_EXIT_COMPLETE,
			imported: [
				new ImportedDocument({
					isExisting: model.duplicateMeta.isOverwrite,
					document: model.actor,
				}),
			],
		});
	}

	async _pImportEntry_populateItemsAndEffects (
		{
			imp,
			importOpts,
			duplicateMeta,
			actor,
			actorData,
			dataBuilderOpts,
			imgEffects,
		},
	) {
		const additionalEffects = this.constructor._DataConverter ? await this.constructor._DataConverter._pGetEffectsSideLoadedTuples({ent: imp, actor: dataBuilderOpts.actor, img: imgEffects}) : null;
		if (additionalEffects?.length) dataBuilderOpts.effects.push(...additionalEffects.map(it => it.effect));

		const prevTokenImg = duplicateMeta.isOverwrite && Config.get("import", "isDuplicateHandlingMaintainImage") ? actor.prototypeToken.texture.src : null;
		const prevImg = duplicateMeta.isOverwrite && Config.get("import", "isDuplicateHandlingMaintainImage") ? actor.img : null;

						if (duplicateMeta?.isOverwrite) {
			await this._pCleanExistingDocumentCollections({document: actor});
		}

		await this._pImportEntry_pFillItems(imp, actorData, dataBuilderOpts, importOpts);
		await this._pImportEntry_pApplyEffects(dataBuilderOpts, importOpts);

		if (prevImg != null) actorData.img = prevImg;
		if (prevTokenImg != null) actorData.prototypeToken.texture.src = prevTokenImg;
	}

		async _pImportEntry_pApplyEffects (dataBuilderOpts, importOpts) {
		if (!dataBuilderOpts.effects?.length) return;
		const isTemporary = importOpts.isTemp || this._pack != null;
		await UtilActors.pAddActorEffects(
			dataBuilderOpts.actor,
			DataConverter.getEffectsMutDedupeId(dataBuilderOpts.effects),
			{isTemporary},
		);
	}

	async _pImportEntry_pHandlePostItemItemUpdates (actor, importOpts, dataBuilderOpts) {
		if (!dataBuilderOpts.postItemItemUpdates) return;

		for (const pFnUpdate of dataBuilderOpts.postItemItemUpdates) {
			await pFnUpdate({
				actor,
				isTemp: importOpts.isTemp,
				isPack: this._pack != null,
				pack: this._pack,
			});
		}
	}

		_pImportEntry_pGetImportMetadata () { throw new Error(`Unimplemented!`); }

	_pImportEntry_pFillItems () { throw new Error(`Unimplemented!`); }

	_pImportEntry_pHasTokenImage (it) { return this.constructor.PROPS.pSerialAwaitSome(prop => Vetools.pHasTokenUrl(prop, it)); }

	_pImportEntry_getTokenInfoGetters (ent, {taskRunner = null, isPreferFoundryOverride = null} = {}) {
		const getters = [
			this._pImportEntry_pGetTokenInfo_fromPlutonium.bind(this, ent, {taskRunner}),
			this._pImportEntry_pGetTokenInfo_fromFoundry.bind(this, ent, {taskRunner}),
		];
		if (isPreferFoundryOverride != null) {
			if (isPreferFoundryOverride) getters.reverse();
		} else {
			if (Config.get("import", "isPreferFoundryTokens")) getters.reverse();
		}

		return getters;
	}

	async _pImportEntry_pGetTokenInfo (imp, {taskRunner = null, isPreferFoundryOverride = null} = {}) {
		if (imp.tokenUrl) return {img: imp.tokenUrl};

		const getters = this._pImportEntry_getTokenInfoGetters(imp, {taskRunner, isPreferFoundryOverride});

		for (const getter of getters) {
			const url = await getter();
			if (url) return url;
		}

		return {
			img: Vetools.getBlankTokenUrl(),
		};
	}

	async _pImportEntry_pGetTokenInfo_fromPlutonium (it) {
		const prop = await this.constructor.PROPS.pSerialAwaitFind(prop => Vetools.pHasTokenUrl(prop, it));
		if (!prop) return null;
		return {
			img: await Vetools.pGetTokenUrl(prop, it),
		};
	}

	async _pImportEntry_pGetTokenInfo_fromFoundry (ent, {taskRunner = null} = {}) {
		return this._pGetCompendiumTokenInfo(ent, {taskRunner});
	}

	_getDuplicateMeta (...args) {
				if (this._actor) {
			return new DuplicateMeta({
				mode: ConfigConsts.C_IMPORT_DEDUPE_MODE_OVERWRITE,
				existing: this._actor,
			});
		}

		return super._getDuplicateMeta(...args);
	}
	
			async _pImportEntry_pFillBase (imp, act, fluff, opts) {
		opts = opts || {};

		act.name = this._getActorSheetName(imp);

		act.img = opts.img || (await Vetools.pOptionallySaveImageToServerAndGetUrl(
			await this._pImportEntry_pFillBase_pGetPortraitImagePath(imp, fluff, opts),
		));
		act.type = imp.foundryType || this._actorType;

		act.flags = this._getActorFlags(imp);

		act.ownership = {default: 0};
	}

	_pImportEntry_pFillBase_pGetPortraitImagePath_getPortraitImageGetters (imp, fluff, opts) {
		const getters = [
			this._pImportEntry_pFillBase_pGetPortraitImagePath_fromPlutonium.bind(this, imp, fluff, opts),
			this._pImportEntry_pFillBase_pGetPortraitImagePath_fromFoundry.bind(this, imp, opts),
		];
		if (Config.get("import", "isPreferFoundryImages")) getters.reverse();

		return getters;
	}

	async _pImportEntry_pFillBase_pGetPortraitImagePath (imp, fluff, opts = {}) {
		if (imp.foundryImg) return imp.foundryImg;

		const getters = this._pImportEntry_pFillBase_pGetPortraitImagePath_getPortraitImageGetters(imp, fluff, opts);

		for (const getter of getters) {
			const url = await getter();
			if (url) return url;
		}

						const tokenInfo = await this._pImportEntry_pGetTokenInfo(imp, {isPreferFoundryOverride: Config.get("import", "isPreferFoundryImages"), taskRunner: opts.taskRunner});
		return tokenInfo?.img;
	}

	async _pImportEntry_pFillBase_pGetPortraitImagePath_fromPlutonium (it, fluff, opts) {
		if (opts.isUseTokenImageAsPortrait) return null;
		return Vetools.pGetImageUrlFromFluff(fluff);
	}

	async _pImportEntry_pFillBase_pGetPortraitImagePath_fromFoundry (ent, opts) {
		if (opts.isUseTokenImageAsPortrait) return null;

		const compendiumImage = await this._pImportEntry_pFillBase_pGetCompendiumImage(ent, opts);
		const compendiumTokenInfo = await this._pGetCompendiumTokenInfo(ent, opts);

						if (compendiumImage === compendiumTokenInfo?.img) return null;
		return compendiumImage;
	}

	async _pImportEntry_pFillFolder (it, act, importOpts, importOptsEntity) {
		if (importOptsEntity?.isSkipFolder) return;

		if (importOpts.isImportToTempDirectory) {
			const folderId = await UtilFolders.pCreateTempFolderGetId({folderType: this.constructor.FOLDER_TYPE});
			if (folderId) act.folder = folderId;
			return;
		}

		if (importOpts.isTemp || this._pack) return;

		const folderId = (await this._pImportEntry_pGetFolderIdMeta(it))?.folderId;
		if (folderId) act.folder = folderId;
	}

	_getActorSheetName (it) {
		return UtilDataConverter.getNameWithSourcePart(it);
	}

	_getActorFlags (it) {
		return {
			[SharedConsts.MODULE_ID]: {
				page: this._page,
				source: it.source,
				hash: UrlUtil.URL_TO_HASH_BUILDER[this._page](it),
			},
		};
	}

	async _pImportEntry_pFillBase_pGetCompendiumImage (it, {taskRunner = null} = {}) {
		for (const prop of this.constructor.PROPS) {
			const fromCompendium = await UtilCompendium.pGetCompendiumImage(prop, it, {taskRunner});
						if (fromCompendium && !UtilImage.isDefaultActorImage(fromCompendium)) return fromCompendium;
		}
		return null;
	}

	async _pGetCompendiumTokenInfo (it, {taskRunner = null} = {}) {
		for (const prop of this.constructor.PROPS) {
			const dataFromCompendium = await UtilCompendium.getSrdCompendiumEntity(prop, it, {taskRunner});
			const tokenUrl = dataFromCompendium?.prototypeToken?.texture?.src;
						if (tokenUrl && !UtilImage.isDefaultActorImage(tokenUrl)) {
				const scale = dataFromCompendium?.prototypeToken?.texture?.scaleX;
				const dimensions = dataFromCompendium?.prototypeToken?.width;

				return {
					img: tokenUrl,
					scale: scale == null || scale === 1 ? null : scale,
					dimensions: dimensions == null || dimensions === 1 ? null : dimensions,
				};
			}
		}
		return null;
	}
	
		async _pImportEntry_pFillToken ({importable, actorData, img = null, size = null, flags = null, isLinkToken = false, taskRunner = null}) {
		size = size || [importable.size || Parser.SZ_MEDIUM].flat(2)[0] || Parser.SZ_MEDIUM;
		let {dimensions, scale} = UtilTokens.getTokenDimensionsAndScale(size);

		const {dataToken: tmpDataToken} = DataConverter.mutTokenSight({
			dataAttributesSenses: MiscUtil.get(actorData, "system", "attributes", "senses"),
			dataToken: {
				dimSight: 0,
				brightSight: 0,
			},
		});

		if (!img) {
			const tokenInfo = await this._pImportEntry_pGetTokenInfo(importable, {taskRunner});
			if (tokenInfo) {
				img = tokenInfo.img;
				if (tokenInfo.scale != null) scale = tokenInfo.scale;
				if (tokenInfo.dimensions != null) dimensions = tokenInfo.dimensions;
			}
		}

		const isWildcard = (img || "").trim().endsWith("*");

		actorData.prototypeToken = {
			...this.constructor._getMergedTokenData({
				configGroup: this._configGroup,
				maxDimSight: tmpDataToken.dimSight,
				maxBrightSight: tmpDataToken.brightSight,
			}),
			name: UtilApplications.getCleanEntityName(UtilEntity.getName(importable)),
			texture: {
				src: await Vetools.pOptionallySaveImageToServerAndGetUrl(
					img,
					{imageType: "token"},
				),
				scaleX: scale ?? 1,
				scaleY: scale ?? 1,
				offsetX: 0,
				offsetY: 0,
			},
			width: dimensions ?? 1,
			height: dimensions ?? 1,
			elevation: 0,
			rotation: 0,

			actorLink: isLinkToken,
			actorData: {},
			flags: {},
			effects: [],
			randomImg: isWildcard,
		};

				const baseFlags = {};

		const threeDiModel = this._pImportEntry_pFillToken_getThreeDiModel({ent: importable});
		if (threeDiModel) MiscUtil.set(baseFlags, UtilCompat.MODULE_LEVELS_3D_PREVIEW, "model3d", threeDiModel);

		if (Object.keys(baseFlags).length || flags) actorData.prototypeToken.flags = foundry.utils.mergeObject(baseFlags, flags);
			}

	_pImportEntry_pFillToken_getThreeDiModel ({ent}) {
		if (ent.tokenUrl3d) return ent.tokenUrl3d;
		if (!this._threeDiTokenAdapter) return null;
		return this._threeDiTokenAdapter.getPrimaryMeta(ent)?.path;
	}

	static _getMergedTokenData ({configGroup, maxDimSight, maxBrightSight}) {
		const out = UtilGameSettings.getSafe("core", "defaultToken") || {};

		if (Config.get(configGroup, "tokenNameDisplay") !== ConfigConsts.C_USE_GAME_DEFAULT) out.displayName = Config.get(configGroup, "tokenNameDisplay");

		if (Config.get(configGroup, "tokenIsAddVision") !== ConfigConsts.C_USE_GAME_DEFAULT) out.vision = Config.get(configGroup, "tokenIsAddVision") === ConfigConsts.C_BOOL_ENABLED;

		if (Config.get(configGroup, "tokenDisposition") !== ConfigConsts.C_USE_GAME_DEFAULT) out.disposition = Config.get(configGroup, "tokenDisposition");

		if (Config.get(configGroup, "tokenBarDisplay") !== ConfigConsts.C_USE_GAME_DEFAULT) out.displayBars = Config.get(configGroup, "tokenBarDisplay");
		if (Config.get(configGroup, "tokenBar1Attribute") !== ConfigConsts.C_USE_GAME_DEFAULT) MiscUtil.set(out, "bar1", "attribute", Config.get(configGroup, "tokenBar1Attribute"));
		if (Config.get(configGroup, "tokenBar2Attribute") !== ConfigConsts.C_USE_GAME_DEFAULT) MiscUtil.set(out, "bar2", "attribute", Config.get(configGroup, "tokenBar2Attribute"));

		if (Config.get(configGroup, "tokenDimSight") !== ConfigConsts.C_USE_GAME_DEFAULT) out.dimSight = maxDimSight;
		if (Config.get(configGroup, "tokenBrightSight") !== ConfigConsts.C_USE_GAME_DEFAULT) out.brightSight = maxBrightSight;

				if (Config.get(configGroup, "tokenScale") != null) out.scale = Config.get(configGroup, "tokenScale");
		
		
										
		
		return out;
	}
	
		_pImportEntry_fillData_Abilities (imp, data, dataBuilderOpts) {
		const out = {};

		Parser.ABIL_ABVS.forEach(ab => {
			const score = Renderer.monster.getSafeAbilityScore(imp, ab);

			const mod = Parser.getAbilityModNumber(score);

			const {profType, bonusSave} = this._pImportEntry_fillData_getAbilitySaveMeta({imp, dataBuilderOpts, score, ab});

			out[ab] = {
				value: score,
				proficient: profType ?? 0,
				mod,
				bonuses: {
					check: "",
					save: bonusSave ?? "",
				},
			};
		});

		data.abilities = out;
	}

	_pImportEntry_fillData_getAbilitySaveMeta ({imp, dataBuilderOpts, score, ab}) {
		if (!imp.save?.[ab]) return {profType: 0, bonusSave: 0};

		const mSave = /^\s*(?<number>[-+]?\s*\d+)\s*(?:[-+]|$)/.exec(`${imp.save[ab]}`);
		if (!mSave) return {profType: 0, bonusSave: 0};

		const saveNum = Number(mSave.groups.number.replace(/\s+/g, ""));

		const abMod = Parser.getAbilityModNumber(score);

				if (saveNum === abMod) return {profType: 0, bonusSave: 0};

		const profValue = abMod + dataBuilderOpts.getSheetPb();
		const expertValue = abMod + (2 * dataBuilderOpts.getSheetPb());

		if (profValue === saveNum) return {profType: 1, bonusSave: 0};
		if (expertValue === saveNum) return {profType: 2, bonusSave: 0};

						const profType = saveNum >= expertValue ? 2 : saveNum >= profValue ? 1 : 0;
		return {
			profType,
			bonusSave: profType === 0 ? saveNum : profType === 1 ? saveNum - profValue : saveNum - expertValue,
		};
			}
	
		async _pGetBiographyValue (entity, fluff, {isImportText, isImportImages, additionalHtml} = {}) {
		if (
			(!isImportText && !isImportImages && !additionalHtml)
			|| ![fluff?.entries && isImportText, fluff?.images && isImportImages, additionalHtml].some(Boolean)
		) return "";

		return UtilDataConverter.pGetWithDescriptionPlugins(() => {
			return [
				isImportImages && fluff?.images?.length
					? Renderer.get().setFirstSection(true).render({type: "entries", entries: [fluff.images[0]]})
					: null,
				isImportText && fluff?.entries?.length
					? Renderer.utils.getFluffTabContent({entity, fluff, isImageTab: false})
					: null,
				additionalHtml || null,
				isImportImages && fluff?.images && fluff?.images.length > 1
					? Renderer.get().setFirstSection(true).render({type: "entries", entries: [...fluff.images.slice(1)]})
					: null,
			].filter(Boolean).join("");
		});
	}
	
		_pImportEntry_fillConditionsDamage (ent, dataTraits) {
		Object.assign(dataTraits, DataConverter.getActorDamageResImmVulnConditionImm(ent));
	}
	
		async _pFillWeaponItem (
		entity,
		act,
		action,
		importOpts,
		dataBuilderOpts,
		{
			offensiveAbility,
			damageParts,
			formula,
			rangeShort,
			rangeLong,
			actionType,
			isProficient,
			description,
			saveAbility,
			saveDc,
			saveScaling,
			attackBonus,
			_foundryData,
			foundrySystem,
			_foundryFlags,
			foundryFlags,
			img,
			isSiegeWeapon,
			isMagical,
			isRecharge,
		},
	) {
		const itemDataAction = await DataConverter.pGetItemActorPassive(
			action,
			{
				mode: "creature",
				pb: dataBuilderOpts.getSheetPb(),
				entity: entity,
				source: entity.source,
				summonSpellLevel: entity._summonedBySpell_level ?? entity.summonedBySpellLevel,
				actor: {data: act}, 
				id: entity._foundryId,
				fvttType: isRecharge ? "feat" : "weapon",

				activationType: "action",
				activationCost: 1,

				ability: offensiveAbility,
				damageParts,
				formula,
				rangeShort,
				rangeLong,
				actionType,
				isProficient,
				description,
				saveAbility,
				saveDc,
				saveScaling,
				attackBonus,
				_foundryData,
				foundrySystem,
				_foundryFlags,
				foundryFlags,
				img,
			},
		);

				this.constructor._mutFlattenFoundryItemData(itemDataAction);

		const itemDataItem = await DataConverterItem.pGetActionWeaponDetails({size: entity.size, action, damageParts, isSiegeWeapon, isMagical, isInfiniteAmmo: true, taskRunner: importOpts.taskRunner});
		delete itemDataItem.effects; 
		this.constructor._mutFlattenFoundryItemData(itemDataItem);

				const itemDataMerged = foundry.utils.mergeObject(
			MiscUtil.copy(itemDataItem),
			MiscUtil.copy(itemDataAction),
		);

						if (itemDataItem.system["attunement"]) itemDataMerged.system["attunement"] = CONFIG.DND5E.attunementTypes.ATTUNED;
				if (itemDataItem.img) itemDataMerged.img = itemDataItem.img;
				[
			"critical.damage",
			"critical.threshold",
			"damage.parts",
			"damage.versatile",
			"formula",
		].forEach(prop => itemDataMerged.system[prop] = itemDataItem.system[prop]);

				itemDataMerged.img = await Vetools.pOptionallySaveImageToServerAndGetUrl(itemDataMerged.img);

		const itemDataMergedExpanded = foundry.utils.expandObject(itemDataMerged);

		dataBuilderOpts.items.push(itemDataMergedExpanded);

		return itemDataMergedExpanded;
	}

	static _mutFlattenFoundryItemData (itemData) {
		Object.entries(itemData)
			.forEach(([prop, values]) => {
				if (!values) return;

				if (typeof values !== "object" || values instanceof Array) {
					itemData[prop] = MiscUtil.copy(values);
					return;
				}

				itemData[prop] = foundry.utils.flattenObject(values);
			});
	}

	_getSavingThrowData (strEntries) {
		if (!strEntries) return MiscUtil.copy(ImportListActor._DEFAULT_SAVING_THROW_DATA);

		let isFoundParse = false;
		let {
			saveAbility,
			saveScaling,
			saveDc,
		} = MiscUtil.copy(ImportListActor._DEFAULT_SAVING_THROW_DATA);

		const mDc = /(?:{@dc (?<dc>\d+)}|DC\s*(?<dcAlt>\d+))\s*(?<ability>Strength|Dexterity|Constitution|Intelligence|Wisdom|Charisma)/i.exec(strEntries);

		if (mDc) {
			saveDc = Number(mDc.groups.dc || mDc.groups.dcAlt);
			saveAbility = mDc.groups.ability.toLowerCase().substring(0, 3);
			saveScaling = "flat";
			isFoundParse = true;
		}

		return {saveAbility, saveScaling, saveDc, isFoundParse};
	}
	}
ImportListActor._DEFAULT_SAVING_THROW_DATA = {
	saveAbility: undefined,
	saveScaling: undefined,
	saveDc: undefined,
};

ImportListActor.ImportEntryOpts = class {
	constructor (opts) {
		opts = opts || {};

		this.actor = opts.actor;
		this.fluff = opts.fluff;
		this.pb = opts.pb || 0;

		this.items = []; 		this.effects = []; 		this.postItemItemUpdates = []; 	}

	getSheetPb () {
				return Math.max(this.pb || 0, 2);
	}
};

var ImportListActor$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ImportListActor: ImportListActor
});

class DataConverterActor extends DataConverter {
	static _ActionEntryParseState = class {
		constructor () {
			this.isProficient = true;
			this.damageTuples = [];

			this.offensiveAbility = "str"; 			this.attackBonus = 0;
		}
	};

	static getParsedActionEntryData (entity, action, dataBuilderOpts, {mode = "creature", summonSpellLevel = null} = {}) {
		if (!(action.entries && action.entries[0] && typeof action.entries[0] === "string")) return;

		const state = new this._ActionEntryParseState();

		const str = action.entries[0];

		const {damageTupleMetas} = DataConverter.getDamageTupleMetas(str, {summonSpellLevel});
		const {damageParts, formula} = DataConverter.getDamagePartsAndOtherFormula(damageTupleMetas);

		state.damageTuples.push(...damageParts);

		const {rangeShort, rangeLong} = DataConverter.getAttackRange(str);

		this._getParsedActionEntryData_hit({entity, action, dataBuilderOpts, mode, state});

		const {isAttack, isRecharge, actionType, isMelee, isRanged, isSpell} = DataConverter.getAttackActionType(action.name, str);

		return {
			formula,
			isAttack,
			isRecharge,
			rangeShort,
			rangeLong,
			actionType,
			isMelee,
			isRanged,
			isSpell,
			damageTuples: state.damageTuples,
			offensiveAbility: state.offensiveAbility,
			isProficient: state.isProficient,
			attackBonus: state.attackBonus,
		};
	}

	static _getParsedActionEntryData_hit ({entity, action, dataBuilderOpts, mode, state}) {
		const str = action.entries[0];

		if (/{@hitYourSpellAttack}/gi.test(str)) {
			state.isProficient = true;
			state.offensiveAbility = null;
						state.attackBonus = `- @attributes.prof - @mod + @${SharedConsts.MODULE_ID_FAKE}.userchar.spellAttackRanged`;
			return;
		}

		const mHit = /{@hit (?<bonus>[^|}]+)(?:\|[^}]+)?}/gi.exec(str);
		if (!mHit) return;

		const {partsNonNumerical, totalNumerical: toHitNumerical} = this._getProfBonusExpressionParts(mHit.groups.bonus);

		const enchantmentPart = /\+(\d)/.exec(action.name || "");
		const enchBonus = enchantmentPart ? Number(enchantmentPart[0]) : 0;
		const hitBonusFromAbil = toHitNumerical - enchBonus - dataBuilderOpts.getSheetPb();

				const dmg1 = state.damageTuples.length ? state.damageTuples[0][0] || "" : "";

		const mDamageBonus = /\d+\s*([-+]\s*\d+)$/.exec(dmg1.trim());
		let damageBonusFromAbil;
		if (mDamageBonus) damageBonusFromAbil = Number(mDamageBonus[1].replace(/\s+/g, "")) - enchBonus;

						let assumedAbilMod = hitBonusFromAbil;
		if (damageBonusFromAbil != null && hitBonusFromAbil !== damageBonusFromAbil) {
			assumedAbilMod = damageBonusFromAbil;

						if (hitBonusFromAbil < damageBonusFromAbil) {
				state.isProficient = false;
			} else {
												state.attackBonus = hitBonusFromAbil - damageBonusFromAbil;
			}
		}

				let isFoundOffensiveAbility = false;
		for (const k of Parser.ABIL_ABVS) {
			if (entity[k] == null) continue;

			const mod = Parser.getAbilityModNumber(Renderer.monster.getSafeAbilityScore(entity, k));
			if (mod === assumedAbilMod) {
				state.offensiveAbility = k;
				isFoundOffensiveAbility = true;
				break;
			}
		}

		if (mode === "creature") {
															if (!isFoundOffensiveAbility && dataBuilderOpts.pb) {
												const curCalcBonus = dataBuilderOpts.pb + Parser.getAbilityModNumber(Renderer.monster.getSafeAbilityScore(entity, state.offensiveAbility)) + state.attackBonus;

				if (curCalcBonus !== toHitNumerical) {
					const delta = toHitNumerical - curCalcBonus;
					state.attackBonus += delta;
				}
			} 									else if (!state.isProficient) {
				const curCalcBonus = Parser.getAbilityModNumber(Renderer.monster.getSafeAbilityScore(entity, state.offensiveAbility)) + state.attackBonus;
				if (curCalcBonus !== toHitNumerical) {
					const delta = toHitNumerical - curCalcBonus;
					state.attackBonus += delta;
				}
			}
		}

						if (mode === "object") {
			state.attackBonus = toHitNumerical;
		}

						if (mode === "creature_altImplementation") {
			if (partsNonNumerical.some(it => /^\+?PB$/i.test(it))) {
								state.attackBonus += ` + @${SharedConsts.MODULE_ID_FAKE}.userchar.pb`;
								state.isProficient = false;
			}
		}
			}
}

var DataConverterActor$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DataConverterActor: DataConverterActor
});

class DataConverterCreature extends DataConverter {
	static _SIDE_LOAD_OPTS = {
		propBrew: "foundryMonster",
		fnLoadJson: Vetools.pGetCreatureSideData.bind(Vetools),
		propJson: "monster",
	};

		static async pGetParsedAction (mon, action, dataBuilderOpts, {taskRunner = null} = {}) {
		const {
			damageTuples,
			formula,
			offensiveAbility,
			isAttack,
			isRecharge,
			isMelee,
			isRanged,
			isSpell,
			rangeShort,
			rangeLong,
			actionType,
			isProficient,
			attackBonus,
		} = DataConverterActor.getParsedActionEntryData(mon, action, dataBuilderOpts, {mode: "creature", summonSpellLevel: mon._summonedBySpell_level ?? mon.summonedBySpellLevel});

		const img = await this._pGetParsedAction_getImg(mon, action, dataBuilderOpts, {isAttack, isMelee, isRanged, isSpell, taskRunner});

		const propChild = "monsterAction";

		return {
			damageTuples,
			formula,
			offensiveAbility,
			isAttack,
			isRecharge,
			rangeShort,
			rangeLong,
			actionType,
			isProficient,
			attackBonus,
			foundryFlags: {
				[SharedConsts.MODULE_ID]: {
					page: propChild,
					source: action.source || mon.source,
					hash: UrlUtil.URL_TO_HASH_BUILDER[propChild]({
						source: mon.source,
						...action,
						monsterName: mon.name,
						monsterSource: mon.source,
					}),
				},
			},
			_foundryData: action._foundryData,
			_foundryFlags: action._foundryFlags,
			img,
		};
	}

		static async _pGetParsedAction_getImg (mon, action, dataBuilderOpts, opts) {
		opts = opts || {};

		const imgFeature = await this._getFeatureImage(mon, action, dataBuilderOpts, opts);
		if (imgFeature) return imgFeature;

		if (action.name) {
			if (action.name.toLowerCase().startsWith("breath weapons")) return `icons/magic/fire/blast-jet-stream-embers-yellow.webp`;

			if (/^eye ray/i.test(action.name)) return `icons/commodities/biological/eye-tentacle-green-yellow.webp`;
		}

		if (opts.isAttack) {
			if (opts.isSpell) return `modules/${SharedConsts.MODULE_ID}/media/icon/fairy-wand.svg`;
			if (opts.isMelee) return `modules/${SharedConsts.MODULE_ID}/media/icon/sword-brandish.svg`;
			if (opts.isRanged) return `modules/${SharedConsts.MODULE_ID}/media/icon/pocket-bow.svg`;
		}
		return `modules/${SharedConsts.MODULE_ID}/media/icon/mailed-fist.svg`;
	}

		static async _getFeatureImage (mon, entFeature, dataBuilderOpts, opts) {
		opts = opts || {};

		const imgCustomIcon = await DataConverter.pGetIconImage("monsterFeature", entFeature);
		if (imgCustomIcon) return imgCustomIcon;

		const img = await UtilCompendium.pGetCompendiumImage(
			"monsterFeature",
			entFeature,
			{
				fnGetAliases: this._getFeatureSrdAliases.bind(this, {isAttack: opts.isAttack, isLegendary: opts.isLegendary}),
				isIgnoreSrd: true,
				taskRunner: opts.taskRunner,
			},
		);
		if (img) return img;

		const imgDeep = await UtilCompendium.pGetActorItemCompendiumImage(
			"monsterFeature",
			entFeature,
			{
				fnGetAliases: this._getFeatureSrdAliases.bind(this, {isAttack: opts.isAttack, isLegendary: opts.isLegendary}),
				taskRunner: opts.taskRunner,
			},
		);
		if (imgDeep) return imgDeep;

		return null;
	}

		static async pGetTraitReactionLegendaryImage (mon, ent, dataBuilderOpts, opts) {
		opts = opts || {};

		const imgFeature = await this._getFeatureImage(mon, ent, dataBuilderOpts, opts);
		if (imgFeature) return imgFeature;

		return `modules/${SharedConsts.MODULE_ID}/media/icon/mighty-force.svg`;
	}

		static async pGetLairActionImage (mon, ent, dataBuilderOpts, opts = {}) {
		const imgFeature = await this._getFeatureImage(mon, ent, dataBuilderOpts, opts);
		if (imgFeature) return imgFeature;

		return `modules/${SharedConsts.MODULE_ID}/media/icon/mountain-cave.svg`;
	}

		static async pGetSpellcastingImage (mon, ent, dataBuilderOpts, opts = {}) {
		const imgFeature = await this._getFeatureImage(mon, ent, dataBuilderOpts, opts);
		if (imgFeature) return imgFeature;

		return `modules/${SharedConsts.MODULE_ID}/media/icon/spell-book.svg`;
	}

		static async pGetVariantImage (mon, ent, dataBuilderOpts, opts = {}) {
		const imgFeature = await this._getFeatureImage(mon, ent, dataBuilderOpts, opts);
		if (imgFeature) return imgFeature;

		return `modules/${SharedConsts.MODULE_ID}/media/icon/archive-research.svg`;
	}

		static _getFeatureSrdAliases (options, entry) {
		if (!entry.name) return [];

		const out = [];

		const noBrackets = entry.name
			.replace(/\([^)]+\)/g, "")
			.replace(/\s+/g, " ")
			.trim();
		if (noBrackets !== entry.name) out.push(noBrackets);

		const noTags = entry.name
			.replace(/{@[^}]+}/g, "")
			.replace(/\s+/g, " ")
			.trim();
		if (noTags !== entry.name) out.push(noTags);

		if (options.isLegendary) out.push(`${entry.name} (Legendary)`);
		if (options.isAttack) out.push(`${entry.name} Attack`);

		const noAttack = entry.name.replace(/ Attack$/, "");
		if (noAttack !== entry.name) out.push(noAttack);

		return out;
	}

	static getDataSkills (mon, data, dataBuilderOpts) {
		const out = {};

		Object.entries(UtilActors.SKILL_ABV_TO_FULL).forEach(([abv, full]) => {
			const ab = Parser.skillToAbilityAbv(full);

			const {profType, bonusCheck} = this._getDataSkills_getSkillMeta({mon, dataBuilderOpts, full, ab});

			out[abv] = {
				value: profType,
				ability: ab,
				bonuses: {
					check: bonusCheck,
					passive: "",
				},
			};
		});

		return out;
	}

	static _getDataSkills_getSkillMeta ({mon, dataBuilderOpts, full, ab}) {
		if (!mon.skill?.[full]) return {profType: 0, bonusCheck: 0};

		const mSkill = /^\s*(?<number>[-+]?\s*\d+)\s*(?:[-+]|$)/.exec(`${mon.skill[full]}`);
		if (!mSkill) return {profType: 0, bonusCheck: 0};

		const skillNum = Number(mSkill.groups.number.replace(/\s+/g, ""));

		const abMod = Parser.getAbilityModNumber(Renderer.monster.getSafeAbilityScore(mon, ab));

				if (skillNum === abMod) return {profType: 0, bonusCheck: 0};

		const profValue = abMod + dataBuilderOpts.getSheetPb();
		const expertValue = abMod + (2 * dataBuilderOpts.getSheetPb());

		if (profValue === skillNum) return {profType: 1, bonusCheck: 0};
		if (expertValue === skillNum) return {profType: 2, bonusCheck: 0};

						const profType = skillNum >= expertValue ? 2 : skillNum >= profValue ? 1 : 0;
		return {
			profType,
			bonusCheck: profType === 0 ? skillNum : profType === 1 ? skillNum - profValue : skillNum - expertValue,
		};
			}

	static isSlotSpellcaster (mon) {
		return mon.spellcasting && mon.spellcasting.some(it => it.spells);
	}

	static getDataSpells (mon, data, monOpts) {
		const out = {};

		out.spell0 = {value: 0, max: 0};

		if (this.isSlotSpellcaster(mon)) {
			for (let i = 1; i < 10; ++i) {
				const kSpell = `spell${i}`;

				out[kSpell] = out[kSpell] || {
					value: 0,
					max: 0,
					override: null, 				};

								mon.spellcasting
					.filter(it => it.spells && it.spells[i] && it.spells[i].slots)
					.forEach(it => {
						const lvl = it.spells[i];

												if (lvl.lower) {
							out.pact = out.pact || {
								value: 0,
								max: 0, 								level: monOpts.spellLevel, 								override: 0, 							};
							out.pact.value += lvl.slots;
							out.pact.max += lvl.slots;
							out.pact.override += lvl.slots;
							return;
						}

						out[kSpell].value += lvl.slots;
						out[kSpell].max += lvl.slots;
					});
			}
		} else {
			for (let i = 1; i < 10; ++i) {
				out[`spell${i}`] = {
					value: 0,
					max: 0,
					override: null, 				};
			}
		}

		return out;
	}
}

var DataConverterCreature$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DataConverterCreature: DataConverterCreature
});

class DataConverterSpell extends DataConverter {
	static _SIDE_LOAD_OPTS = {
		propBrew: "foundrySpell",
		fnLoadJson: Vetools.pGetSpellSideData,
		propJson: "spell",
	};

	static _IMG_FALLBACK = `modules/${SharedConsts.MODULE_ID}/media/icon/scroll-unfurled.svg`;

	static _getConfigKeyIsSpellPoints (opts) {
		if (opts.isActorItemNpc) return Config.getSpellPointsKey({actorType: "npc"});
		return Config.getSpellPointsKey({actorType: opts.actor?.type});
	}

	static isAllowSpellPoints (spellLevel, opts) {
		return opts.target == null
			&& opts.vetConsumes == null
			&& spellLevel !== 0
			&& Config.get("importSpell", this._getConfigKeyIsSpellPoints(opts)) !== ConfigConsts.C_SPELL_POINTS_MODE__DISABLED;
	}

	static _PassiveEntryParseStateSpell = class extends this._PassiveEntryParseState {
		constructor ({entry, img}, opts) {
			super({entry, img}, opts);

			let {
				school,
				materials,
				preparationMode,
				isPrepared,

				ability,
			} = opts;

			this.school = school;
			this.materials = materials;

			this.preparationMode = preparationMode;
			this.isPrepared = isPrepared;

			if (ability !== undefined) this.saveScaling = ability;

			this.isCustomDamageParts = false; 		}
	};

		static async pGetDocumentJson (spell, opts) {
		opts = opts || {};

		Renderer.get().resetHeaderIndex();

		const state = new this._PassiveEntryParseStateSpell({entry: spell}, opts);
		await state.pInit({isSkipDescription: true, isSkipImg: true});

		const srdData = await UtilCompendium.getSrdCompendiumEntity("spell", spell, {taskRunner: opts.taskRunner});

		const {name: translatedName, description: translatedDescription, flags: translatedFlags} = this._getTranslationMeta({
			translationData: this._getTranslationData({srdData}),
			name: UtilApplications.getCleanEntityName(`${UtilDataConverter.getNameWithSourcePart(spell, {isActorItem: opts.isActorItem})}${opts.nameSuffix || ""}`),
			description: await this._pGetDescription(spell),
		});

		const entriesStr = JSON.stringify(spell.entries);

		this._pGetSpellItem_mutPreparationMode({spell, opts, state});
		this._pGetSpellItem_mutActionType({spell, opts, entriesStr, state});
		this._pGetSpellItem_mutSchool({spell, opts, state});
		this._pGetSpellItem_mutMaterials({spell, opts, state});
		this._pGetSpellItem_mutDuration({spell, opts, state});
		this._pGetSpellItem_mutRangeTarget({spell, opts, state});
		this._pGetSpellItem_mutDamageAndFormula({spell, opts, entriesStr, srdData, state});
		this._pGetSpellItem_mutSave({spell, opts, state});
		this._pGetSpellItem_mutConsumes({spell, opts, state});
		this._pGetSpellItem_mutActivation({spell, opts, state});

		const img = await this._pGetSaveImagePath(
			spell,
			{
				propCompendium: "spell",
				isAllowCustom: !spell.srd || Config.get("importSpell", "isUseCustomSrdIcons"),
				taskRunner: opts.taskRunner,
			},
		);

		this._pGetSpellItem_mut_srdData({spell, opts, srdData, state});

		const additionalData = await this._pGetDataSideLoaded(spell, {targetUnits: state.targetUnits});
		const additionalFlags = await this._pGetFlagsSideLoaded(spell);

		const out = {
			name: translatedName,
			type: "spell",
			system: {
				source: UtilDataConverter.getSourceWithPagePart(spell),
				description: {value: translatedDescription, chat: "", unidentified: ""},

				actionType: state.actionType,
				level: this._pGetSpellItem_getLevel(spell),
				school: state.school,
				components: {
					value: "",
					vocal: spell.components && spell.components.v,
					somatic: spell.components && spell.components.s,
					material: !!(spell.components && spell.components.m),
					ritual: spell.meta && spell.meta.ritual,
					concentration: !!MiscUtil.get(spell, "duration", "0", "concentration"),
				},
				materials: {
					value: state.materials,
					consumed: !!MiscUtil.get(spell, "components", "m", "consume"),
					cost: Math.round((MiscUtil.get(spell, "components", "m", "cost") || 0) / 100),
					supply: 0,
				},
				target: {value: state.targetValue, units: state.targetUnits, type: state.targetType},
				range: {value: state.rangeShort, units: state.rangeUnits, long: state.rangeLong},
				activation: {
					type: state.activationType,
					cost: state.activationCost,
					condition: state.activationCondition,
				},
				duration: {
					value: state.durationValue,
					units: state.durationUnit,
				},
				damage: {
					parts: state.damageParts,
					versatile: "",
				},
				scaling: {
					mode: state.cantripScaling ? "cantrip" : state.scaling ? "level" : "none",
					formula: state.cantripScaling || state.scaling || "",
				},
				save: {ability: state.saveAbility, dc: null, scaling: state.saveScaling},
				ability: state.ability,
				uses: {
					value: state.usesValue,
					max: state.usesMax,
					per: state.usesPer,
				},
				attackBonus: null,
				chatFlavor: "",
				critical: {threshold: null, damage: ""},
				formula: state.formula,
				preparation: {
					mode: state.preparationMode,
					prepared: !!state.isPrepared,
				},
				consume: {
					type: state.consumeType,
					target: state.consumeTarget,
					amount: state.consumeAmount,
				},
				...(additionalData || {}),
			},
			img,
			ownership: {default: 0},
			flags: {
				...translatedFlags,
				...this._getSpellFlags(spell, opts),
				...additionalFlags,
			},
			effects: await this._pGetSpellEffects(spell, srdData, img),
		};

		if (opts.defaultOwnership != null) out.ownership = {default: opts.defaultOwnership};
		else if (opts.isAddDefaultOwnershipFromConfig) out.ownership = {default: Config.get("importSpell", "ownership")};
		if (opts.userOwnership) Object.assign(out.ownership, opts.userOwnership);

				const replacementData = await UtilCompendium.getCompendiumEntity("spell", spell);

		if (replacementData) {
			[
				["system", "preparation"],
				["system", "uses"],
				["system", "consume"],
				["system", "ability"],
				["system", "save", "scaling"],
				["ownership"],
				["flags", SharedConsts.MODULE_ID],
			].forEach(path => {
				MiscUtil.getThenSetCopy(out, replacementData, ...path);
			});

			return replacementData;
		}
		
		return out;
	}

	static _pGetSpellItem_mutPreparationMode ({spell, opts, state}) {
				if (
			Config.get("importSpell", this._getConfigKeyIsSpellPoints(opts)) === ConfigConsts.C_SPELL_POINTS_MODE__ENABLED
			&& spell.level !== 0
			&& (!state.preparationMode || state.preparationMode === "prepared" || state.preparationMode === "always")
		) {
			state.preparationMode = "atwill";
		}

		if (state.preparationMode === undefined) state.preparationMode = "prepared";
				if (spell.level === 0) state.preparationMode = "always";

		if (state.isPrepared === undefined) state.isPrepared = spell.level === 0;
	}

	static _pGetSpellItem_mutActionType ({spell, opts, entriesStr, state}) {
		let actionType = "";
		if (spell.miscTags && spell.miscTags.includes("HL")) actionType = "heal";
		if (spell.savingThrow?.length) actionType = "save";
		if (entriesStr.toLowerCase().includes("melee spell attack")) actionType = "msak";
		if (entriesStr.toLowerCase().includes("ranged spell attack")) actionType = "rsak";
		if (state.actionType === undefined) state.actionType = actionType || "util";
	}

	static _pGetSpellItem_mutSchool ({spell, opts, state}) {
		state.school = UtilActors.VET_SPELL_SCHOOL_TO_ABV[spell.school] || "";
	}

	static _pGetSpellItem_mutMaterials ({spell, opts, state}) {
		state.materials = spell.components?.m
			? spell.components.m !== true
				? `${spell.components.m.text || spell.components.m}`
				: ""
			: "";
	}

	static _pGetSpellItem_mutDuration ({spell, opts, state}) {
		let durationValue = 0;
		let durationUnit = "";
		const duration0 = spell.duration[0];
		switch (duration0.type) {
			case "instant": durationUnit = "inst"; break;
			case "timed": {
				switch (duration0.duration.type) {
					case "turn": durationUnit = "turn"; durationValue = duration0.duration.amount; break;
					case "round": durationUnit = "round"; durationValue = duration0.duration.amount; break;
					case "minute": durationUnit = "minute"; durationValue = duration0.duration.amount; break;
					case "hour": durationUnit = "hour"; durationValue = duration0.duration.amount; break;
					case "day": durationUnit = "day"; durationValue = duration0.duration.amount; break;
					case "week": durationUnit = "day"; durationValue = duration0.duration.amount * 7; break;
					case "year": durationUnit = "year"; durationValue = duration0.duration.amount; break;
				}
				break;
			}
			case "permanent": durationUnit = "perm"; break;
			case "special": durationUnit = "spec"; break;
		}

		if (state.durationValue === undefined) state.durationValue = durationValue;
		if (state.durationUnit === undefined) state.durationUnit = durationUnit;
	}

	static _pGetSpellItem_mutRangeTarget ({spell, opts, state}) {
		let rangeShort = 0;
		let rangeUnits = "";
		let targetValue = 0;
		let targetUnits = "";
		let targetType = "";
		switch (spell.range.type) {
			case Parser.RNG_SPECIAL: rangeUnits = "spec"; break;
			case Parser.RNG_POINT: {
				const dist = spell.range.distance;
				switch (dist.type) {
					case Parser.RNG_SELF: {
						targetUnits = "self";
						targetType = "self";
						rangeUnits = "self";
						break;
					}
					case Parser.RNG_UNLIMITED:
					case Parser.RNG_UNLIMITED_SAME_PLANE:
					case Parser.RNG_SIGHT:
					case Parser.RNG_SPECIAL: {
						targetUnits = "spec";
						rangeUnits = "spec";
						break;
					}
					case Parser.RNG_TOUCH: {
						targetUnits = "touch";
						rangeUnits = "touch";
						break;
					}
					case Parser.UNT_YARDS: {
						rangeShort = Config.getMetricNumberDistance({configGroup: "importSpell", originalValue: dist.amount, originalUnit: Parser.UNT_YARDS});
						rangeUnits = Config.getMetricUnitDistance({configGroup: "importSpell", originalUnit: Parser.UNT_YARDS});
						break;
					}
					case Parser.UNT_MILES: {
						rangeShort = Config.getMetricNumberDistance({configGroup: "importSpell", originalValue: dist.amount, originalUnit: Parser.UNT_MILES});
						rangeUnits = Config.getMetricUnitDistance({configGroup: "importSpell", originalUnit: Parser.UNT_MILES});
						break;
					}
					case Parser.UNT_FEET:
					default: {
						rangeShort = Config.getMetricNumberDistance({configGroup: "importSpell", originalValue: dist.amount, originalUnit: Parser.UNT_FEET});
						rangeUnits = Config.getMetricUnitDistance({configGroup: "importSpell", originalUnit: Parser.UNT_FEET});
						break;
					}
				}
				break;
			}
			case Parser.RNG_LINE:
			case Parser.RNG_CUBE:
			case Parser.RNG_CONE:
			case Parser.RNG_RADIUS:
			case Parser.RNG_SPHERE:
			case Parser.RNG_HEMISPHERE:
			case Parser.RNG_CYLINDER: {
				targetValue = Config.getMetricNumberDistance({configGroup: "importSpell", originalValue: spell.range.distance.amount, originalUnit: spell.range.distance.type});

				targetUnits = Config.getMetricUnitDistance({configGroup: "importSpell", originalUnit: spell.range.distance.type});

				if (spell.range.type === Parser.RNG_HEMISPHERE) targetType = "sphere";
				else targetType = spell.range.type; 			}
		}

		state.rangeShort = rangeShort;
		state.rangeUnits = rangeUnits;

		state.targetValue = targetValue;
		state.targetUnits = targetUnits;
		state.targetType = targetType;
	}

	static _pGetSpellItem_mutDamageAndFormula ({spell, opts, entriesStr, srdData, state}) {
		let damageParts = [];
		let cantripScaling = null;
		let scaling = null;

		if (spell.scalingLevelDice) { 			const scalingLevelDice = [spell.scalingLevelDice].flat(); 
			const getLowestKey = scaling => Math.min(...Object.keys(scaling).map(k => Number(k)));
			const reDamageType = new RegExp(`(${UtilActors.VALID_DAMAGE_TYPES.join("|")})`, "i");

			damageParts.push(...scalingLevelDice.map(scl => {
				const lowKey = getLowestKey(scl.scaling);
				const lowDice = scl.scaling[lowKey];

				const mDamageType = reDamageType.exec(scl.label || "");

				return [
					(lowDice || "").replace(/{{spellcasting_mod}}/g, "@mod"),
					mDamageType ? mDamageType[1].toLowerCase() : null,
				];
			}));

						const firstScaling = scalingLevelDice[0];
			const lowKey = getLowestKey(firstScaling.scaling);
			cantripScaling = firstScaling.scaling[lowKey].replace(/{{spellcasting_mod}}/g, "@mod");
		} else {
			let damageTuples = []; 
			if (spell.damageInflict && spell.damageInflict.length) {
								if (entriesStr.toLowerCase().includes("when you reach 5th level")) {
					const diceTiers = [];
										entriesStr.replace(/\({@damage ([^}]+)}\)/g, (...m) => diceTiers.push(m[1]));
										if (diceTiers.length === 3) {
												const baseVal = /(?:^|[^(]){@damage ([^}]+)}(?:[^)]|$)/.exec(entriesStr);
						if (baseVal) cantripScaling = baseVal[1];
												else cantripScaling = diceTiers[0];
					}
				}

				this._pGetSpellItem_parseAndAddDamage(entriesStr, damageTuples);
			}

			if (spell.miscTags && spell.miscTags.some(str => str === "HL")) {
				const healingTuple = ["", "healing"];

								entriesStr.replace(this._getReDiceYourSpellcastingMod(), (...m) => {
					const [, dicePart, modPart] = m;

					healingTuple[0] = dicePart;
					if (modPart) healingTuple[0] = `${healingTuple[0]} + @mod`;
				});

				damageTuples.push(healingTuple);
			}

			const metaHigherLevel = this._pGetSpellItem_getHigherLevelMeta({spell, opts, damageTuples, isCustomDamageParts: state.isCustomDamageParts, scaling, preparationMode: state.preparationMode});
			if (metaHigherLevel) {
				damageTuples = metaHigherLevel.damageTuples;
				state.isCustomDamageParts = metaHigherLevel.isCustomDamageParts;
				scaling = metaHigherLevel.scaling;
			}

						if (!damageTuples.length) this._pGetSpellItem_parseAndAddDamage(entriesStr, damageTuples);

			damageParts.push(...damageTuples);
		}
		damageParts = damageParts.filter(Boolean);

		let formula = "";
				if (!damageParts.length && !state.isCustomDamageParts && !MiscUtil.get(srdData, "system", "damage", "parts")) {
			entriesStr.replace(this._getReDiceYourSpellcastingMod(), (...m) => {
				const [, dicePart, modPart] = m;

				formula = dicePart;
				if (modPart) formula = `${formula} + @mod`;
			});
		}

		if (state.damageParts === undefined) state.damageParts = damageParts;
		if (state.cantripScaling === undefined) state.cantripScaling = cantripScaling;
		if (state.scaling === undefined) state.scaling = scaling;

		if (state.formula === undefined) state.formula = formula;
	}

	static _pGetSpellItem_mutSave ({spell, opts, state}) {
		if (spell.savingThrow?.length) {
			state.saveAbility = spell.savingThrow[0].substring(0, 3).toLowerCase();
		}

		if (state.saveScaling === undefined) state.saveScaling = "spell";
	}

	static _pGetSpellItem_mutConsumes ({spell, opts, state}) {
		if (opts.vetConsumes) {
			const sheetItem = DataConverter.getConsumedSheetItem({consumes: opts.vetConsumes, actor: opts.actor});

			state.consumeType = "charges";
			state.consumeAmount = opts.vetConsumes.amount ?? 1;
			state.consumeTarget = sheetItem?.id;

			return;
		}

		if (!this.isAllowSpellPoints(spell.level, opts)) return;

		const resource = Config.getSpellPointsResource({isValueKey: true});
		const consumeAmount = Parser.spLevelToSpellPoints(spell.level);

		if (resource === ConfigConsts.C_SPELL_POINTS_RESOURCE__SHEET_ITEM) {
			if (state.consumeType === undefined) state.consumeType = "charges";
			if (state.consumeAmount === undefined) state.consumeAmount = consumeAmount;
			if (state.consumeTarget === undefined) state.consumeTarget = opts.spellPointsItemId;
			return;
		}

		if (state.consumeType === undefined) state.consumeType = "attribute";
		if (state.consumeAmount === undefined) state.consumeAmount = consumeAmount;
		if (state.consumeTarget === undefined) state.consumeTarget = resource;
	}

	static _pGetSpellItem_getLevel (spell) {
		if (!isNaN(spell.level) && spell.level >= 0 && spell.level <= 9) return Math.round(spell.level);
		if (!isNaN(spell.level)) return Math.clamped(Math.round(spell.level), 0, 9);
		return 0;
	}

	static _pGetSpellItem_mutActivation ({spell, opts, state}) {
		state.activationType = state.activationType || spell.time[0]?.unit;
		state.activationCost = state.activationCost || spell.time[0]?.number;
		state.activationCondition = state.activationCondition || Renderer.stripTags(spell.time[0]?.condition || "");

		if (!UtilCompat.isMidiQolActive() || state.activationType !== "reaction" || !state.activationCondition) return null;

		state.activationType = "reactionmanual";

		state.activationCondition
			.replace(/\bwhich you take when you take (?:[^?!.]+ )?damage\b/i, () => {
				state.activationType = "reactiondamage";
				return "";
			})
			.replace(/\bin response to being damaged\b/i, () => {
				state.activationType = "reactiondamage";
				return "";
			})

			.replace(/\bwhen you are hit\b/i, () => {
				state.activationType = "reaction";
				return "";
			})
			.replace(/\b(?:succeeds on|makes) an attack roll\b/i, () => {
				state.activationType = "reaction";
				return "";
			})
		;
	}

		static _pGetSpellItem_mut_srdData ({spell, opts, srdData, state}) {
		if (!srdData) return;

		state.targetValue = Config.getMetricNumberDistance({configGroup: "importSpell", originalValue: MiscUtil.get(srdData, "system", "target", "value"), originalUnit: MiscUtil.get(srdData, "system", "target", "units")}) || state.targetValue;
		state.targetUnits = Config.getMetricUnitDistance({configGroup: "importSpell", originalUnit: MiscUtil.get(srdData, "system", "target", "units")}) || state.targetUnits;
		state.targetType = MiscUtil.get(srdData, "system", "target", "type") || state.targetType;
		if (!state.isCustomDamageParts) state.damageParts = MiscUtil.get(srdData, "system", "damage", "parts") || state.damageParts;
		if (!state.cantripScaling && !state.scaling) state.scaling = MiscUtil.get(srdData, "system", "scaling", "formula");
	}

	static async _pGetImgCustom (spell) { return DataConverter.pGetIconImage("spell", spell); }

	static _getImgFallback (spell) {
		if (!Config.get("importSpell", "isUseDefaultSchoolImage")) return null;

		switch (spell.school) {
			case "A": return `icons/magic/defensive/shield-barrier-blue.webp`;
			case "C": return `icons/magic/unholy/silhouette-evil-horned-giant.webp`;
			case "D": return `icons/magic/perception/orb-eye-scrying.webp`;
			case "E": return `icons/magic/air/wind-vortex-swirl-purple.webp`;
			case "V": return `icons/magic/fire/projectile-fireball-orange-yellow.webp`;
			case "I": return `icons/magic/defensive/illusion-evasion-echo-purple.webp`;
			case "N": return `icons/magic/unholy/hand-fire-skeleton-pink.webp`;
			case "T": return `icons/magic/movement/abstract-ribbons-red-orange.webp`;
		}
	}

	static _getSpellFlags (
		spell,
		{
			parentClassName,
			parentClassSource,
			parentSubclassName,
			parentSubclassSource,
		} = {},
	) {
		const out = {
			[SharedConsts.MODULE_ID]: {
				page: UrlUtil.PG_SPELLS,
				source: spell.source,
				hash: UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_SPELLS](spell),
				propDroppable: "spell",
			},
		};

		if (!parentClassName && !parentClassSource && !parentSubclassName && !parentSubclassSource) return out;

		out[SharedConsts.MODULE_ID].parentClassName = parentClassName;
		out[SharedConsts.MODULE_ID].parentClassSource = parentClassSource;
		out[SharedConsts.MODULE_ID].parentSubclassName = parentSubclassName;
		out[SharedConsts.MODULE_ID].parentSubclassSource = parentSubclassSource;

		const identParentCls = UtilItem.getNameAsIdentifier(parentClassName);

				out[UtilCompat.MODULE_TIDY5E_SHEET] = {
						parentClass: [
				"artificer",
				"barbarian",
				"bard",
				"cleric",
				"druid",
				"fighter",
				"monk",
				"paladin",
				"ranger",
				"rogue",
				"sorcerer",
				"warlock",
				"wizard",
			].includes(identParentCls) ? identParentCls : "custom",
		};
		
		if (UtilCompat.isModuleMulticlassSpellbookFilterActive()) {
			out[UtilCompat.MODULE_MULTICLASS_SPELLBOOK_FILTER] = {parentClass: identParentCls};
		}

		return out;
	}

	static async _pGetSpellEffects (spell, srdData, img) {
		const out = [];

		const effectsSrd = await this._pIsIgnoreSrdEffectsSideLoaded(spell) ? [] : MiscUtil.copy(srdData?.effects || []);
		effectsSrd.forEach(effect => effect.icon = img);
		DataConverter.mutEffectsDisabledTransfer(effectsSrd, "importSpell", {hintTransfer: false, hintDisabled: false});
		out.push(...effectsSrd);

		if (await this.pHasSpellSideLoadedEffects(null, spell)) {
			const effectsSideTuples = await this.pGetSpellItemEffectTuples(null, spell, null, {img});
			effectsSideTuples.forEach(({effect, effectRaw}) => DataConverter.mutEffectDisabledTransfer(effect, "importSpell", UtilActiveEffects.getDisabledTransferHintsSideData(effectRaw)));
			out.push(...effectsSideTuples.map(it => it.effect));
		}

		return DataConverter.getEffectsMutDedupeId(out);
	}

	static _pGetSpellItem_parseAndAddDamage (entriesStr, damageTuples) {
				entriesStr.replace(/{@damage ([^}]+)} ([^ ]+)(, [^ ]+)*(,? or [^ ]+)? damage/ig, (...m) => {
									damageTuples.push([m[1], m[2]]);
		});
	}

	static _getReDiceYourSpellcastingMod () {
				return /{@dice ([^}]+)}(\s*\+\s*your\s+spellcasting\s+ability\s+modifier)?/i;
	}

	static _pGetSpellItem_getHigherLevelMeta (
		{
			spell,
			opts,
			damageTuples,
			isCustomDamageParts,
			scaling,
			preparationMode,
		},
	) {
		if (!spell.entriesHigherLevel) return;

		const out = {
			damageTuples: MiscUtil.copy(damageTuples),
			isCustomDamageParts,
			scaling,
		};

		const reHigherLevel = /{@(?:scaledice|scaledamage) ([^}]+)}/gi;
		const resAdditionalNumber = [
			/\badditional (?<addPerLevel>\d+) for each (?:slot )?level\b/gi,
			/\bincreases by (?<addPerLevel>\d+) for each (?:slot )?level\b/gi,
		];

		let fnStr = null;

				const ixsScaled = new Set(); 
		const fnStrInnate = str => {
			str
				.replace(reHigherLevel, (...m) => {
					const [base] = m[1].split("|").map(it => it.trim());

					const [tag, text] = Renderer.splitFirstSpace(m[0].slice(1, -1));
					const scaleOptions = Renderer.parseScaleDice(tag, text);

					const ixDamageTuple = out.damageTuples.findIndex(it => (it[0] || "").trim().toLowerCase() === base.toLowerCase());
					if (!ixsScaled.has(ixDamageTuple) && ~ixDamageTuple) {
						const diceAtLevel = scaleOptions?.prompt?.options?.[opts.castAtLevel];
						if (diceAtLevel) {
							ixsScaled.add(ixDamageTuple);
							out.damageTuples[ixDamageTuple][0] += `+ ${diceAtLevel}`;
							out.isCustomDamageParts = true;
						}
					}
				});

			resAdditionalNumber.forEach(re => {
				str
					.replace(re, (...m) => {
						if (!out.damageTuples.length) return;

						const toAdd = opts.castAtLevel * Number(m.last().addPerLevel);
												out.damageTuples[0][0] += `+ ${toAdd}`;
						out.isCustomDamageParts = true;
					});
			});
		};
		
								const fnStrStandard = str => {
			if (out.scaling) return;

			str
				.replace(reHigherLevel, (...m) => {
					if (out.scaling) return;

					const [, progression, addPerProgress] = m[1].split("|");

					const progressionParse = MiscUtil.parseNumberRange(progression, 1, 9);
					const [p1, p2] = [...progressionParse].sort(SortUtil.ascSort);
					const baseLevel = Math.min(...progressionParse);

					
					out.scaling = addPerProgress;
				});

			resAdditionalNumber.forEach(re => {
				str
					.replace(re, (...m) => {
						if (out.scaling) return;

												out.scaling = `(@item.level - ${spell.level}) * ${m.last().addPerLevel}`;
					});
			});
		};
		
						if (opts.castAtLevel != null && opts.castAtLevel !== spell.level && out.damageTuples.length && preparationMode === "innate") {
			fnStr = fnStrInnate;
		} else {
			fnStr = fnStrStandard;
		}

		MiscUtil.getWalker({isNoModification: true})
			.walk(
				spell.entriesHigherLevel,
				{
					string: str => fnStr(str),
				},
			);

		return out;
	}

	static _pGetDescription (spell) {
		if (!Config.get("importSpell", "isImportDescription")) return "";

		return UtilDataConverter.pGetWithDescriptionPlugins(async () => {
			const entries = await DataConverter.pGetEntryDescription(spell);
			const entriesHigherLevel = spell.entriesHigherLevel
				? await DataConverter.pGetEntryDescription(spell, {prop: "entriesHigherLevel"})
				: "";

			const stackPts = [entries, entriesHigherLevel];

			if (Config.get("importSpell", "isIncludeClassesInDescription")) {
				const fromClassList = Renderer.spell.getCombinedClasses(spell, "fromClassList");
				if (fromClassList?.length) {
					const [current] = Parser.spClassesToCurrentAndLegacy(fromClassList);
					stackPts.push(`<div><span class="bold">Classes: </span>${Parser.spMainClassesToFull(current, {isTextOnly: true})}</div>`);
				}
			}

			return stackPts.filter(Boolean).join("");
		});
	}

	static async _pGetDataSideLoaded (spell, {targetUnits} = {}) {
		const out = await super._pGetDataSideLoaded(spell);
		if (!out) return out;

				if (out["target.value"]) out["target.value"] = Config.getMetricNumberDistance({configGroup: "importSpell", originalValue: out["target.value"], originalUnit: out["target.units"] || targetUnits});
		if (out["target.units"]) out["target.units"] = Config.getMetricUnitDistance({configGroup: "importSpell", originalUnit: out["target.units"] || targetUnits});

		return out;
	}

	static getActorSpell (actor, name, source) {
		if (!name || !source) return null;
		return actor.items && actor.items.find(it =>
			(it.name || "").toLowerCase() === name.toLowerCase()
			&& (
				!Config.get("import", "isStrictMatching")
				|| (UtilDataConverter.getItemSource(it).source || "").toLowerCase() === source.toLowerCase()
			),
		);
	}

	static async pSetSpellItemIsPrepared (item, isPrepared) {
		if (!item) return;
		await UtilDocuments.pUpdateDocument(item, {system: {preparation: {prepared: isPrepared}}});
	}

	static async pHasSpellSideLoadedEffects (actor, spell) {
		return (await DataConverter._pGetEffectsRawSideLoaded_(spell, this._SIDE_LOAD_OPTS))?.length > 0;
	}

	static async pGetSpellItemEffectTuples (actor, spell, sheetItem, {img} = {}) {
		const effectsRaw = await DataConverter._pGetEffectsRawSideLoaded_(spell, this._SIDE_LOAD_OPTS);
		return UtilActiveEffects.getExpandedEffects(effectsRaw || [], {actor, sheetItem, parentName: spell.name, img}, {isTuples: true});
	}
}

var DataConverterSpell$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DataConverterSpell: DataConverterSpell
});

class ImportCustomizerBase extends Application {
	constructor (dataList, resolve, {title, template, titleSearch, isActor}) {
		super({
			title,
			template,
			width: 960,
			height: Util.getMaxWindowHeight(),
			resizable: true,
		});

		this._dataList = dataList;

		this._promise = new Promise(resolve => this._resolve = resolve);

		this._titleSearch = titleSearch;
		this._isActor = isActor;

		this._list = null;
		this._$btnReset = null;
	}

	async pInit () {  }

	async pGetCustomizedEntries () {
		await this.render(true);
		return this._promise;
	}

	
	getData () {
		return {
			titleSearch: this._titleSearch,
			isActor: this._isActor,
			rows: this._dataList.map((ent, ix) => this._getData_row({ent, ix})),
		};
	}

	_getData_row ({ent, ix}) {
		return {
			name: ent.name,
			source: ent.source,
			sourceShort: Parser.sourceJsonToAbv(ent.source),
			sourceLong: Parser.sourceJsonToFull(ent.source),
			sourceClassName: Parser.sourceJsonToColor(ent.source),
			sourceStyle: PrereleaseUtil.sourceJsonToStylePart(ent.source) || BrewUtil2.sourceJsonToStylePart(ent.source),
			ix,
			customizerState: ent._fvttCustomizerState,
		};
	}

	
	async close () {
		this._resolve(null);
		return super.close();
	}

	
	activateListeners ($html) {
		super.activateListeners($html);

		this._activateListeners_initList({$html});

		const $wrpBtnsSort = $html.find(`[data-name="wrp-btns-sort"]`);
		SortUtil.initBtnSortHandlers($wrpBtnsSort, this._list);

		this._activateListeners_bindControls({$html, $wrpBtnsSort});

				if (this._$btnReset) this._$btnReset.click();
	}

	_getListValueNames () { return ["name", "source", "ix"]; }

	_activateListeners_initList ({$html}) {
				this._list = new List({
			$iptSearch: $html.find(`.search`),
			$wrpList: $html.find(`.veapp__list`),
			valueNames: this._getListValueNames(),
		});

		this._list.doAbsorbItems(
			this._dataList,
			{
				fnGetName: it => it.name,
				fnGetValues: ent => this._getListItemValues({ent}),
				fnGetData: li => this._getListItemData({li}),
			},
		);
		this._list.init();
	}

	_getListItemValues ({ent}) {
		return {source: ent.source};
	}

		_getListItemData ({li}) { throw new Error(`Unimplemented`); }

	_activateListeners_bindControls ({$html, $wrpBtnsSort}) {
		this._$btnReset = $html.find(`[name="btn-reset"]`).click(() => {
			$html.find(`.search`).val("");
			if (this._list) this._list.reset();
		});

		$html.find(`[name="btn-run"]`).click(async () => {
			this._resolve(
				await this._list.items
					.pMap(async li => {
						const ent = this._dataList[li.ix];

						const customizerState = await this._pGetCustomizerState({li, ent});
						if (customizerState == null) return ent;

						const cpy = MiscUtil.copyFast(ent);
						cpy._fvttCustomizerState = customizerState.toJson();
						return cpy;
					}),
			);

			await this.close();
		});
	}

	
		async _pGetCustomizerState ({li, ent, state = null}) { throw new Error("Unimplemented!"); }

	
	static async pGetAppliedCustomizations ({ent, isInPlace = false}) {
		if (!ent._fvttCustomizerState) return ent;

		if (!isInPlace) ent = MiscUtil.copyFast(ent);

		const out = await this._pGetAppliedCustomizations({ent});
		delete ent._fvttCustomizerState;
		return out;
	}

		static async _pGetAppliedCustomizations ({ent}) { throw new Error("Unimplemented!"); }
}

class CustomizerStateSpell extends CustomizerStateBase {
	spellScroll = null;
	preparation = null;

	setSpellScroll (val) { this.spellScroll = val; return this; }
	setPreparation (val) { this.preparation = val; return this; }
}

class UtilEntitySpell {
	static getListDisplayLevel (it) { return `${Parser.spLevelToFull(it.level)}${it.meta && it.meta.ritual ? " (rit.)" : ""}${it.meta && it.meta.technomagic ? " (tec.)" : ""}`; }
}

class ImportCustomizerSpell extends ImportCustomizerBase {
		constructor (dataList, resolve, opts) {
		super(
			dataList,
			resolve,
			{
				...opts,
				title: "Customize Import",
				template: `${SharedConsts.MODULE_LOCATION}/template/ImportListSpellCustomizer.hbs`,
			},
		);
	}

	
	_getData_row ({ent, ix}) {
		return {
			...super._getData_row({ent, ix}),
			level: UtilEntitySpell.getListDisplayLevel(ent),
		};
	}

	
	_getListValueNames () { return [...super._getListValueNames(), "level", "ix"]; }

	_getListItemValues ({ent}) {
		return {
			...super._getListItemValues({ent}),
			level: ent.level,
		};
	}

	_getListItemData ({li}) {
		const $e = $(li.ele);
		return {
			$cbScroll: $e.find(`[name="cb-is-scroll"]`),
			$selIsPrepared: $e.find(`[name="sel-is-prepared"]`),
			$selPreparationMode: $e.find(`[name="sel-preparation-mode"]`),
		};
	}

	
	_activateListeners_bindControls ({$html, $wrpBtnsSort}) {
		super._activateListeners_bindControls({$html, $wrpBtnsSort});

		const $cbScrollAll = $wrpBtnsSort.find(`[name="cb-is-scroll-all"]`)
			.change(() => {
				const val = $cbScrollAll.prop("checked");
				this._list.items.forEach(li => li.data.$cbScroll.prop("checked", val));
			});
	}

	
	async _pGetCustomizerState ({li, ent, state = null}) {
		return (state || new CustomizerStateSpell())
			.setSpellScroll(this._pGetCustomizerState_spellScroll({li, ent}))
			.setPreparation(this._pGetCustomizerState_preparation({li, ent}));
	}

	_pGetCustomizerState_spellScroll ({li, ent}) {
		const isSpellScroll = li.data.$cbScroll.prop("checked");
		if (!isSpellScroll) return null;
		return {
			isSpellScroll,
		};
	}

	_pGetCustomizerState_preparation ({li, ent}) {
		const isPrepVal = li.data.$selIsPrepared.val();
		const prepModeVal = li.data.$selPreparationMode.val();

		const hasIsPrep = isPrepVal && isPrepVal !== "-1";
		const hasPrepMode = prepModeVal && prepModeVal !== "-1";

		return {
			isPrepVal,
			prepModeVal,
			hasIsPrep,
			hasPrepMode,
		};
	}

	
	static async _pGetAppliedCustomizations ({ent}) {
		ent = this._pGetAppliedCustomizations_spellScroll({ent});
		ent = this._pGetAppliedCustomizations_preparation({ent});
		return ent;
	}

	static _pGetAppliedCustomizations_spellScroll ({ent}) {
		const isSpellScroll = ent._fvttCustomizerState?.spellScroll?.isSpellScroll;
		if (!isSpellScroll) return ent;
		ent._foundryIsSpellScroll = true;
		return ent;
	}

	static _pGetAppliedCustomizations_preparation ({ent}) {
		const {hasIsPrep, hasPrepMode, isPrepVal, prepModeVal} = ent._fvttCustomizerState?.preparation || {};

		if (!hasIsPrep && !hasPrepMode) return ent;

		ent.foundrySystem = {};
		if (hasIsPrep) ent.foundrySystem["preparation.prepared"] = !!Number(isPrepVal);
		if (hasPrepMode) ent.foundrySystem["preparation.mode"] = prepModeVal;
		return ent;
	}
}

class ImportListSpell extends ImportList {
	static get ID () { return "spells"; }
	static get DISPLAY_NAME_TYPE_PLURAL () { return "Spells"; }
	static get PROPS () { return ["spell"]; }

	static _ = this.registerImpl(this);

	_dirsHomebrew = ["spell"];
	_titleSearch = "spell";
	_sidebarTab = "items";
	_gameProp = "items";
	_defaultFolderPath = ["Spells"];
	_pageFilter = new PageFilterSpells();
	_page = UrlUtil.PG_SPELLS;
	_isPreviewable = true;
	_isDedupable = true;
	_configGroup = "importSpell";
	_fnListSort = PageFilterSpells.sortSpells;
	_pFnGetFluff = Renderer.spell.pGetFluff.bind(Renderer.spell);
	_ClsCustomizer = ImportCustomizerSpell;
	static _DataConverter = DataConverterSpell;

	async pPreRender (...args) {
		await super.pPreRender(...args);

						Renderer.spell.populatePrereleaseLookup(await PrereleaseUtil.pGetBrewProcessed(), {isForce: true});
		Renderer.spell.populateBrewLookup(await BrewUtil2.pGetBrewProcessed(), {isForce: true});

		this._content.forEach(sp => {
			Renderer.spell.uninitBrewSources(sp);
			Renderer.spell.initBrewSources(sp);
		});
	}

	async _pGetSources () {
		return [
			new UtilDataSource.DataSourceSpecial(
				Config.get("ui", "isStreamerMode") ? "SRD" : "5etools",
				() => Vetools.pGetAllSpells(),
				{
					cacheKey: "5etools-spells",
					filterTypes: [UtilDataSource.SOURCE_TYP_OFFICIAL_ALL],
					isDefault: true,
				},
			),
			...UtilDataSource.getSourcesCustomUrl(),
			...UtilDataSource.getSourcesUploadFile(),
			...Object.keys(await DataUtil.spell.pLoadIndex()).map(src => new UtilDataSource.DataSourceSpecial(
				Parser.sourceJsonToFull(src),
				() => DataUtil.spell.pLoadSingleSource(src),
				{
					cacheKey: `5etools-spells-${src}`,
					filterTypes: UtilDataSource.getSourceFilterTypes(src),
					abbreviations: [Parser.sourceJsonToAbv(src)],
				},
			)),
			...(await this._pGetSourcesPrerelease()),
			...(await this._pGetSourcesBrew()),
		];
	}

	getFolderPathMeta () {
		return {
			...super.getFolderPathMeta(),
			level: {
				label: "Level",
				getter: it => `${Parser.spLevelToFull(it.level)}${it.level ? " level" : ""}`,
			},
			school: {
				label: "School",
				getter: it => Parser.spSchoolAndSubschoolsAbvsToFull(it.school, it.subschools),
			},
			spellPoints: {
				label: "Spell Points",
				getter: it => {
					const sp = (() => {
						switch (it.level) {
							case 1: return 2;
							case 2: return 3;
							case 3: return 5;
							case 4: return 6;
							case 5: return 7;
							case 6: return 8;
							case 7: return 10;
							case 8: return 11;
							case 9: return 13;
							case 0:
							default: return 0;
						}
					})();
					return `${sp} Spell Points`;
				},
			},
		};
	}

	async _pPostRenderOrShow () {
		await super._pPostRenderOrShow();

		if (!this._actor) return;

		if (!Config.get("importSpell", "isFilterOnOpen")) return;

		const currentValues = this._pageFilter.filterBox.getValues();
		const classNameLookup = Object.keys(currentValues.Class).filter(k => !k.startsWith("_")).mergeMap(it => ({[it.toLowerCase()]: it}));

						const cacheClassSubclassData = {};
		const subclassSheetItems = this._actor.items.filter(it => it.type === "subclass");
		const classMetas = (await this._actor.items
			.filter(it => it.type === "class")
			.filter(it => classNameLookup[it.name.toLowerCase().trim()])
			.pSerialAwaitMap(sheetItem => UtilDataConverter.pGetClassItemClassAndSubclass({sheetItem, subclassSheetItems, cache: cacheClassSubclassData})))
			.filter(it => it.matchingClasses?.length);

		if (!classMetas.length) {
			this._pageFilter.filterBox.setFromValues({
				"Class": {},
				"Subclass": {},
			});
			this._handleFilterChange();
			return;
		}

		if (classMetas.some(it => it.matchingSubclasses?.length)) {
			this._pageFilter.filterBox.setFromValues({
				"Class": classMetas.map(it => it.matchingClasses.map(it => it.name)).flat().mergeMap(it => ({[it]: 1})),
				"Subclass": classMetas.map(it => it.matchingSubclasses.map(it => `${it.className}: ${it.shortName}`)).flat().mergeMap(it => ({[it]: 1})),
			});
			this._handleFilterChange();
			return;
		}

		this._pageFilter.filterBox.setFromValues({
			"Class": classMetas.map(it => it.matchingClasses.map(it => it.name)).flat().mergeMap(it => ({[it]: 1})),
			"Subclass": {},
		});
		this._handleFilterChange();
	}

	_renderInner_getListSyntax () {
		return new ListSyntaxSpells({
			fnGetDataList: () => this._content,
			pFnGetFluff: this._pFnGetFluff,
		}).build();
	}

	_colWidthName = "3-2";
	_colWidthSource = 1;

	_getData_cols_other () {
		return [
			{
				name: "Level",
				width: 1,
				field: "level",
				rowClassName: "text-center",
			},
			{
				name: "Time",
				width: 2,
				field: "time",
				rowClassName: "text-center",
			},
			{
				name: "School",
				width: 1,
				field: "school",
				titleProp: "schoolLong",
				displayProp: "schoolShort",
				classNameProp: "schoolClassName",
				rowClassName: "text-center",
			},
			{
				name: "C.",
				width: "0-3",
				field: "concentration",
				rowClassName: "text-center",
				title: "Concentration",
			},
			{
				name: "Range",
				width: "2-5",
				field: "range",
				rowClassName: "text-right",
			},
		];
	}

	_getData_row_mutGetAdditionalValues ({it, ix}) {
		it._l_time = PageFilterSpells.getTblTimeStr(it.time[0]);
		it._l_school = Parser.spSchoolAbvToFull(it.school, it.subschools);

		return {
			level: UtilEntitySpell.getListDisplayLevel(it),
			time: it._l_time,
			range: Parser.spRangeToFull(it.range),

			school: it.school,
			schoolShort: Parser.spSchoolAndSubschoolsAbvsShort(it.school, it.subschools),
			schoolLong: it._l_school,
			schoolClassName: `sp__school-${it.school}`,

			concentration: it._isConc ? "×" : "",
		};
	}

	getData () {
		return {
			...super.getData(),
			buttonsAdditional: [
				{
					name: "btn-run-mods",
					text: "Customize and Import...",
				},
			],
		};
	}

	_renderInner_absorbListItems_fnGetValues (it) {
		return {
			...super._renderInner_absorbListItems_fnGetValues(it),
			level: it.level,
			time: it._l_time,
			normalisedTime: it._normalisedTime,
			normalisedRange: it._normalisedRange,
			school: it._l_school,
			concentration: it._isConc,
		};
	}

	async _pImportEntry_pImportToActor (spell, importOpts) {
		const isScrollImport = this.constructor._isSpellScrollImport(spell, importOpts);
		const isAllowSpellPoints = this._isAllowSpellPoints({spell, importOpts, isScrollImport});
		if (isAllowSpellPoints) await this._pAddActorSpellPointsSlotsEffect({importOpts});
		const spellPointsItemId = isAllowSpellPoints ? await this._pGetActorSpellPointsItemId() : null;

		const spellData = await DataConverterSpell.pGetDocumentJson(
			spell,
			{
				actor: this._actor,
				...(importOpts.opts_pGetSpellItem
					|| (await UtilActors.pGetActorSpellItemOpts({actor: this._actor, isAllowAutoDetectPreparationMode: true}))),
				spellPointsItemId,
				taskRunner: importOpts.taskRunner,
			},
		);

		let embeddedDocument;
		if (isScrollImport) {
			const scrollData = await this.constructor._pGetSpellScrollData(spellData);
			const importedMetas = await UtilActors.pAddActorItems(
				this._actor,
				[scrollData],
			);
			embeddedDocument = importedMetas[0]?.document;
		} else {
			const importedMetas = await UtilActors.pAddActorItems(
				this._actor,
				[spellData],
			);
			embeddedDocument = importedMetas[0]?.document;
		}

		if (this._actor.isToken) this._actor.sheet.render();

		return new ImportSummary({
			status: ConstsTaskRunner.TASK_EXIT_COMPLETE,
			imported: [
				new ImportedDocument({
					name: spell.name,
					actor: this._actor,
					embeddedDocument,
				}),
			],
		});
	}

	_isAllowSpellPoints ({spell, importOpts, isScrollImport}) {
		if (isScrollImport) return false;
		return DataConverterSpell.isAllowSpellPoints(spell.level, {actor: this._actor, ...importOpts?.opts_pGetSpellItem || {}});
	}

	async _pAddActorSpellPointsSlotsEffect ({importOpts}) {
		if (!this._actor) throw new Error(`Only applicable when importing to an actor!`);
		if (Config.get("importSpell", Config.getSpellPointsKey({actorType: this._actor?.type})) !== ConfigConsts.C_SPELL_POINTS_MODE__ENABLED_AND_UNLIMITED_SLOTS) return;
		await UtilActors.pGetCreateActorSpellPointsSlotsEffect({actor: this._actor, isTemporary: importOpts.isTemp});
	}

	async _pGetActorSpellPointsItemId () {
		if (!this._actor) throw new Error(`Only applicable when importing to an actor!`);
		const spellPointsItem = await UtilActors.pGetCreateActorSpellPointsItem({actor: this._actor});
		return spellPointsItem?.id;
	}

	async _pImportEntry_pImportToDirectoryGeneric_pGetImportableData (it, getItemOpts, importOpts) {
		const spellData = await super._pImportEntry_pImportToDirectoryGeneric_pGetImportableData(
			it,
			{
				...UtilActors.getSpellItemItemOpts(),
				...getItemOpts,
			},
			importOpts,
		);

		if (this.constructor._isSpellScrollImport(it, importOpts)) {
			return this.constructor._pGetSpellScrollData(spellData);
		}
		return spellData;
	}

	static _isSpellScrollImport (spell, importOpts) { return spell._foundryIsSpellScroll || importOpts.isSpellScroll; }

	static async _pGetSpellScrollData (spellData) {
				spellData.data = spellData.system;

		const scrollData = await CONFIG.Item.documentClass.createScrollFromSpell(spellData);
		return scrollData.toObject();
	}
}

var ImportListSpell$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ImportListSpell: ImportListSpell
});

const MixinPageFilterThreeDi = Base => class extends Base {
	static _STR_HAS_THREE_DI_MODEL = "Has 3D Model";

	static _isTokenThreeDi (mon) { return mon.tokenUrl3d || mon.hasToken3d; }

	static mutateForFilters (mon) {
		super.mutateForFilters(mon);
		if (this._isTokenThreeDi(mon)) mon._fMisc.push(this._STR_HAS_THREE_DI_MODEL);
	}

	addToFilters (mon, isExcluded) {
		super.addToFilters(mon, isExcluded);

		if (isExcluded) return;

				if (this.constructor._isTokenThreeDi(mon)) this._miscFilter.addItem(this.constructor._STR_HAS_THREE_DI_MODEL);
	}
};

class PageFilterBestiaryFvtt extends MixinPageFilterThreeDi(PageFilterBestiary) {}

class CreatureRenamer {
	static _WALKER_RENAME = null;

	static _PROPS_SUB = [
		"entries",
		"headerEntries",
	];

	static _RE_SHORTNAME_PT_VERB = `(?:is|can|starts|has|takes|targets|exhales|fails|makes|dies|regains|moves)`;
	static _RE_SHORTNAME_PT_NAME = `(?<name>[-a-z ]+?)`;
	static _RE_SHORTNAME__IF_THE = new RegExp(`\\b[Ii]f the ${this._RE_SHORTNAME_PT_NAME} ${this._RE_SHORTNAME_PT_VERB}\\b`);
	static _RE_SHORTNAME__THE = new RegExp(`\\b[Tt]he ${this._RE_SHORTNAME_PT_NAME} ${this._RE_SHORTNAME_PT_VERB}\\b`);
	static _RES_SHORTNAME = [
		this._RE_SHORTNAME__IF_THE,
		this._RE_SHORTNAME__THE,
	];

	static _RES_SHORTNAME_BLOCKLIST = [
		/^target$/i,
	];

	
		static _getLowercaseName (name) {
		return name === name.toTitleCase() ? name.toLowerCase() : name;
	}

	static _getPossibleMonShortName (mon) {
				if (mon.shortName === true) return null;

		if (mon.isNamedCreature) return Renderer.monster.getShortName(mon, {isTitleCase: true});
		if (mon.shortName) return mon.shortName;

		const shorNameStacks = {};

		DataUtil.generic.COPY_ENTRY_PROPS.forEach(prop => {
			if (!mon[prop]) return;

			mon[prop].forEach(it => {
				this._PROPS_SUB.forEach(propSub => {
					if (!it[propSub]) return;

					it[propSub] = this._WALKER_RENAME.walk(
						it[propSub],
						{
							string: (str) => {
								this._RES_SHORTNAME
									.forEach(re => {
										str.replace(re, (...m) => {
											const name = m.last().name;
											if (this._RES_SHORTNAME_BLOCKLIST.some(it => it.test(name))) return;

											shorNameStacks[name] ||= 0;
											shorNameStacks[name]++;
										});
									});

								return str;
							},
						},
					);
				});
			});
		});

		if (!Object.keys(shorNameStacks)) return null;

				return Object.entries(shorNameStacks)
			.sort(([, cntA], [, cntB]) => SortUtil.ascSort(cntA, cntB))
			.find(Boolean)[0];
	}

	
	static _isSkipReplace ({str, m, isNamedCreature}) {
		const ixStart = m[m.length - 2];
		if (isNamedCreature && /^ lycanthropy\b/.test(str.slice(ixStart + m[0].length))) return true;
		return false;
	}

	static _getRenamedObj (
		{
			entries,
			isNamedCreature,
			newNameShortLower,
			reName,
			rePossibleShortName,
		},
	) {
		return this._WALKER_RENAME.walk(
			entries,
			{
				string: (str) => {
					str = str.replace(reName, (...m) => {
						if (this._isSkipReplace({str, m, isNamedCreature})) return m[0];
						return newNameShortLower;
					});
					if (rePossibleShortName) {
						str = str.replace(rePossibleShortName, (...m) => {
							if (this._isSkipReplace({str, m, isNamedCreature})) return m[0];
							return newNameShortLower;
						});
					}
					return str;
				},
			},
		);
	}

	
	static getRenamed (mon, {newName, newNameShort, isNamedCreature, isInPlace = false}) {
		this._WALKER_RENAME = this._WALKER_RENAME || MiscUtil.getWalker();

		if (!isInPlace) mon = MiscUtil.copyFast(mon);

				mon._fvttRenameMeta = {
			original: {
				name: mon.name,
				isNamedCreature: mon.isNamedCreature,
				shortName: mon.shortName,
			},
			renamed: {},
		};

		let newNameShortSynth = newNameShort || newName;
		let newNameShortLower = (isNamedCreature || mon.isNamedCreature)
												? (newNameShort || newName)
			: this._getLowercaseName(newNameShortSynth);

		const possibleShortName = this._getPossibleMonShortName(mon);

		const reName = new RegExp(`\\b${isNamedCreature && !mon.isNamedCreature ? `the ` : ""}${mon.name.escapeRegexp()}\\b`, "gi");
		const rePossibleShortName = possibleShortName && (possibleShortName.trim() !== mon.name.toLowerCase().trim())
			? new RegExp(`\\b${isNamedCreature && !mon.isNamedCreature ? `the ` : ""}${possibleShortName.escapeRegexp()}\\b`, "gi")
			: null;

		DataUtil.generic.COPY_ENTRY_PROPS
			.forEach(prop => {
				if (!mon[prop]) return;

				mon[prop].forEach(it => {
					this._PROPS_SUB
						.forEach(propSub => {
							if (!it[propSub]) return;

							it[propSub] = this._getRenamedObj({
								entries: it[propSub],
								isNamedCreature,
								newNameShortLower,
								reName,
								rePossibleShortName,
							});
						});
				});
			});

		mon._displayName = isNamedCreature
			? newName
						: ((newName[0] === (newName[0] || "").toUpperCase()) ? newName : newName.toTitleCase());
		if (isNamedCreature) mon.isNamedCreature = true;

				mon._fvttRenameMeta.renamed = {
			newName,
			newNameShort,
			isNamedCreature,
			newNameShortLower,
			reName: reName.toString(),
			rePossibleShortName: rePossibleShortName?.toString(),
		};

		if (!newNameShort) mon._displayShortName = isNamedCreature ? true : newName;
		else mon._displayShortName = newNameShort;

		return mon;
	}

	
	static getRenamedEntries (entries, renameMeta) {
		if (!renameMeta) return entries;

		entries = MiscUtil.copyFast(entries);

		return this._getRenamedObj({
			entries: entries,
			isNamedCreature: renameMeta.renamed.isNamedCreature,
			newNameShortLower: renameMeta.renamed.newNameShortLower,
						reName: eval(renameMeta.renamed.reName),
						rePossibleShortName: eval(renameMeta.renamed.rePossibleShortName),
		});
	}
}

class ThreeDiTokenAdapterBase {
		static _getFilePath () { throw new Error("Unimplemented!"); }

	static _P_LOAD_THREE_DI_TOKEN_LOOKUP = null;
	static _THREE_DI_TOKEN_LOOKUP = {}; 	static async _pInitThreeDiTokenLookup () {
		if (!UtilCompat.isThreeDiTokensActive() || !Config.get("integrationThreeDiCanvas", "isSetThreeDiModels")) return;

		await (this._P_LOAD_THREE_DI_TOKEN_LOOKUP = this._P_LOAD_THREE_DI_TOKEN_LOOKUP || (async () => {
			this._THREE_DI_TOKEN_LOOKUP = await DataUtil.loadJSON(this._getFilePath());
		})());
	}

	async pInit () {
		await this.constructor._pInitThreeDiTokenLookup();
	}

		_getHash (ent) { throw new Error(`Unimplemented!`); }

	_getPathMeta (path) {
				const name = path
			.split("/")
			.pop()
			.replaceAll("%20", "_")
			.replaceAll("_", " ")
			.replace(".glb", "")
			.replace(/MZ4250\s*-\s*/, "")
			.replace(/MS4250\s*-\s*/g, "")
		;

		const previewPath = path.replace(/\..*?$/, ".webp");
		
		return {
			name,
			path,
			previewPath,
		};
	}

	getPrimaryMeta (ent) {
		const hash = this._getHash(ent);
		const fromData = this.constructor._THREE_DI_TOKEN_LOOKUP[hash];
		if (!fromData?.primary) return null;
		return this._getPathMeta(fromData.primary);
	}

	getSecondaryMetas (ent) {
		const hash = this._getHash(ent);
		const fromData = this.constructor._THREE_DI_TOKEN_LOOKUP[hash];
		if (!fromData?.secondary?.length) return [];
		return fromData.secondary.map(path => this._getPathMeta(path));
	}

	getAllMetas (ent) {
		return [
			this.getPrimaryMeta(ent),
			...this.getSecondaryMetas(ent),
		]
			.filter(Boolean);
	}
}

class ThreeDiTokenAdapterCreature extends ThreeDiTokenAdapterBase {
	static _getFilePath () { return Vetools.getModuleDataUrl(`bestiary/foundry-integration-3d-tokens.json`); }
	_getHash (ent) { return UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BESTIARY](ent); }
}

class UtilFilePicker {
	static _FP_DEFAULT_OPTIONS = {
		tileSize: true,
	};

	static pGetFile (
		{
			type,
			current,
		},
	) {
		return new Promise(resolve => {
			const fp = new FilePicker({
				...this._FP_DEFAULT_OPTIONS,
				type,
				current,
				callback: path => resolve(path),
			});
			fp.browse();
		});
	}

	static pGetThreeDiFile ({current}) {
		return new Promise(resolve => {
			const fp = new FilePicker({
				...this._FP_DEFAULT_OPTIONS,
				type: "any",
				current,
				callback: path => resolve(path),
			});

						fp.extensions = [".glb", ".GLB", ".gltf", ".GLTF", ".fbx", ".FBX"];

			fp.browse();
		});
	}
}

class CustomizerStateActor extends CustomizerStateBase {
	token = null;
	tokenThreeDi = null;

	setToken (val) { this.token = val; return this; }
	setTokenThreeDi (val) { this.tokenThreeDi = val; return this; }
}

class ImportCustomizerActor extends ImportCustomizerBase {
	_threeDiTokenAdapter = null;

		constructor (dataList, resolve, opts) {
		super(
			dataList,
			resolve,
			{
				...opts,
				title: "Customize Import",
			},
		);
	}

	async pInit () {
		if (this._threeDiTokenAdapter) await this._threeDiTokenAdapter.pInit();
	}

	
	_getAvailableAlternateTokens (ent) { return []; }

		_getAvailableTokensThreeDi (it) {
		return this._threeDiTokenAdapter
			.getSecondaryMetas(it)
			.map(({name}, ix) => ({name, ix}));
	}

	
	static _CONTEXT_CUSTOMIZE_TOKEN = {
		formNameSelToken: "sel-token",
		formNameBtnTokenCustom: "btn-token-custom",
		formNameStgTokenCustom: "stg-token-custom",
		formNameIptTokenCustom: "ipt-token-custom",

		name: "Token",
	};

	static _CONTEXT_CUSTOMIZE_TOKEN_THREE_DI = {
		formNameSelToken: "sel-token-3d",
		formNameBtnTokenCustom: "btn-token-3d-custom",
		formNameStgTokenCustom: "stg-token-3d-custom",
		formNameIptTokenCustom: "ipt-token-3d-custom",

		name: "3D Model",
	};

	
	_getData_row ({ent, ix}) {
		return {
			...super._getData_row({ent, ix}),

			contextCustomizeToken: {
				...this.constructor._CONTEXT_CUSTOMIZE_TOKEN,
				url: ent._fvttCustomizerState?.token?.url,
				availableTokens: this._getAvailableAlternateTokens(ent),
			},
			isTokensThreeDi: UtilCompat.isLevels3dPreviewActive(),
			contextCustomizeTokenThreeDi: {
				...this.constructor._CONTEXT_CUSTOMIZE_TOKEN_THREE_DI,
				url: ent._fvttCustomizerState?.tokenThreeDi?.url,
				availableTokens: this._getAvailableTokensThreeDi(ent),
			},
		};
	}

	
	_activateListeners_tokenBase (
		{
			$html,
			context,
			pFnGetFile,
		},
	) {
		const selectorSelToken = `select[name="${context.formNameSelToken}"]`;
		const selectorBtnTokenCustom = `button[name="${context.formNameBtnTokenCustom}"]`;
		const selectorStgTokenCustom = `[data-name="${context.formNameStgTokenCustom}"]`;
		const selectorIptTokenCustom = `[name="${context.formNameIptTokenCustom}"]`;

		$html
			.on("change", selectorSelToken, evt => {
				const $sel = $(evt.currentTarget);
				const $stgCustom = $sel.closest(".veapp__list-row").find(selectorStgTokenCustom);
				$stgCustom.toggleVe(Number($sel.val()) === -2);
			})
			.on("click", selectorBtnTokenCustom, async evt => {
				const $btn = $(evt.currentTarget);
				const $iptCustom = $btn.closest(".veapp__list-row").find(selectorIptTokenCustom);

				const path = await pFnGetFile({current: $iptCustom.val()});
				if (path) $iptCustom.val(path);
			})
		;
	}

	activateListeners ($html) {
		super.activateListeners($html);

		this._activateListeners_tokenBase({
			$html,
			context: this.constructor._CONTEXT_CUSTOMIZE_TOKEN,
			pFnGetFile: ({current}) => UtilFilePicker.pGetFile({type: "imagevideo", current}),
		});

		this._activateListeners_tokenBase({
			$html,
			context: this.constructor._CONTEXT_CUSTOMIZE_TOKEN_THREE_DI,
			pFnGetFile: ({current}) => UtilFilePicker.pGetThreeDiFile({current}),
		});
	}

	
	_getListItemValues ({ent}) {
		return {
			...super._getListItemValues({ent}),
			cr: Parser.monCrToFull(ent.cr),
		};
	}

	_getListItemData ({li}) {
		const $e = $(li.ele);
		return {
			$selToken: $e.find(`[name="${this.constructor._CONTEXT_CUSTOMIZE_TOKEN.formNameSelToken}"]`),
			$iptTokenCustom: $e.find(`[name="${this.constructor._CONTEXT_CUSTOMIZE_TOKEN.formNameIptTokenCustom}"]`),
			$selTokenThreeDi: $e.find(`[name="${this.constructor._CONTEXT_CUSTOMIZE_TOKEN_THREE_DI.formNameSelToken}"]`),
			$iptTokenThreeDiCustom: $e.find(`[name="${this.constructor._CONTEXT_CUSTOMIZE_TOKEN_THREE_DI.formNameIptTokenCustom}"]`),
		};
	}

	
		async _pGetCustomizerState ({li, ent, state = null}) {
		return (state || new CustomizerStateActor())
			.setToken(this._pGetCustomizerState_token({li, ent}))
			.setTokenThreeDi(this._pGetCustomizerState_tokenThreeDi({li, ent}));
	}

	_pGetCustomizerState_tokenBase ({li, ent, $selToken, fnGetFromPredefined}) {
		const ixToken = Number($selToken.val()) === -1 ? null : Number($selToken.val());
		if (ixToken == null) return null;

		const out = {
			url: null,
		};

		const tokenCustom = li.data.$iptTokenCustom.val();

		switch (ixToken) {
						case -1: break;

						case -2: {
				out.url = tokenCustom;
				break;
			}

						default: out.url = fnGetFromPredefined({ent, ixToken});
		}

		return Object.values(out).every(it => it == null) ? null : out;
	}

	_pGetCustomizerState_token ({li, ent}) {
		return this._pGetCustomizerState_tokenBase({
			li,
			ent,
			$selToken: li.data.$selToken,
			$iptTokenCustom: li.data.$iptTokenCustom,
			fnGetFromPredefined: ({ent, ixToken}) => {
				const altArt = ent.altArt[ixToken];
				return Renderer.monster.getTokenUrl({name: altArt.name, source: altArt.source, tokenUrl: altArt.tokenUrl});
			},
		});
	}

	_pGetCustomizerState_tokenThreeDi ({li, ent}) {
		if (!UtilCompat.isLevels3dPreviewActive()) return null;

		return this._pGetCustomizerState_tokenBase({
			li,
			ent,
			$selToken: li.data.$selTokenThreeDi,
			$iptTokenCustom: li.data.$iptTokenThreeDiCustom,
			fnGetFromPredefined: ({ent, ixToken}) => {
				return this._threeDiTokenAdapter.getSecondaryMetas(ent)[ixToken]?.path;
			},
		});
	}

	
	static async _pGetAppliedCustomizations ({ent}) {
		ent = await this._pGetAppliedCustomizations_pToken({ent});
		ent = await this._pGetAppliedCustomizations_pTokenThreeDi({ent});

		return ent;
	}

	static async _pGetAppliedCustomizations_pTokenBase ({ent, propTokenUrl, propCustomizerState}) {
		const url = ent?._fvttCustomizerState?.[propCustomizerState]?.url;
		if (!url) return ent;

		ent[propTokenUrl] = url;
		return ent;
	}

	static async _pGetAppliedCustomizations_pToken ({ent}) {
		return this._pGetAppliedCustomizations_pTokenBase({
			ent,
			propCustomizerState: "token",
			propTokenUrl: "tokenUrl",
		});
	}

	static async _pGetAppliedCustomizations_pTokenThreeDi ({ent}) {
		if (!UtilCompat.isLevels3dPreviewActive()) return ent;

		return this._pGetAppliedCustomizations_pTokenBase({
			ent,
			propCustomizerState: "tokenThreeDi",
			propTokenUrl: "tokenUrl3d",
		});
	}
}

class CustomizerStateCreature extends CustomizerStateActor {
	variant = null;
	scale = null;
	fvttType = null;

	setVariant (val) { this.variant = val; return this; }
	setScale (val) { this.scale = val; return this; }
	setFvttType (val) { this.fvttType = val; return this; }
}

class ImportCustomizerCreature extends ImportCustomizerActor {
	_threeDiTokenAdapter = new ThreeDiTokenAdapterCreature();

	get template () { return `${SharedConsts.MODULE_LOCATION}/template/ImportListCreatureCustomizer.hbs`; }

	_getAvailableAlternateTokens (ent) {
		if (!ent.altArt) return [];

		return ent.altArt
			.filter(alt => (alt.name && alt.source) || alt.tokenUrl)
			.map((alt, ix) => {
				if (alt.name && alt.source) {
					return {name: Renderer.monster.getRenderedAltArtEntry(alt, {isPlainText: true}), ix};
				}

				const nameRaw = `${alt.tokenUrl}`.split("/").last().split(".")[0].trim() || "(Unnamed)";
				let name;
				try {
					name = decodeURIComponent(nameRaw);
				} catch (e) {
					name = nameRaw;
				}

				return ({name: name, ix});
			});
	}

	_getData_row ({ent, ix}) {
		const variants = this._getData_getVariants(ent);

		return {
			...super._getData_row({ent, ix}),

			cr: ent._vCr,
			isAdjustableCr: Parser.crToNumber(ent.cr) < VeCt.CR_CUSTOM,
			isAdjustableSummonSpellLevel: ent.summonedBySpellLevel != null,
			availableSummonSpellLevels: ent.summonedBySpellLevel != null
				? [...Renderer.monster.getSelSummonSpellLevel(ent).options].map(it => Number(it.value)).filter(it => ~it)
				: null,
			isAdjustableSummonClassLevel: ent.summonedByClass != null,
			availableSummonClassLevels: ent.summonedByClass != null
				? [...new Array(VeCt.LEVEL_MAX)].map((_, i) => ({level: i + 1, className: ent.summonedByClass.split("|")[0].toTitleCase()}))
				: null,

			hasVariants: !!variants.length,
			availableVariants: variants,
		};
	}

	_getData_getVariants (mon) {
		return this.constructor._getAvailableVariants(mon)
			.map((it, ix) => ({ix, name: it.name}));
	}

	static _getAvailableVariants (mon) {
		if (
			!mon._versions?.length
			&& !(mon.variants || []).some(it => it?._version)
			&& !Renderer.monster.dragonCasterVariant.hasCastingColorVariant(mon)
		) return [];

		const dragonCasterMeta = Renderer.monster.dragonCasterVariant.hasCastingColorVariant(mon) ? Renderer.monster.dragonCasterVariant.getMeta(mon) : null;

		return [
			...DataUtil.proxy.getVersions(mon.__prop, mon),
			dragonCasterMeta?.exampleSpellsFtd?.length
				? {
					name: "Dragons as Innate Spellcasters (FTD)",
					fnApplyVariant: this._getVariant_dragonInnateSpellcaster_ftd.bind(this),
				}
				: null,
			dragonCasterMeta?.exampleSpellsUnofficial?.length
				? {
					name: "Dragons as Innate Spellcasters (MM)",
					fnApplyVariant: this._getVariant_dragonInnateSpellcaster_mm.bind(this),
				}
				: null,
		]
			.filter(Boolean);
	}

	static _getVariant_dragonInnateSpellcaster_ftd (mon) {
		mon = MiscUtil.copy(mon);
		mon.spellcasting = [
			...(mon.spellcasting || []),
			this._getCastingColorVariantSpellcastingTrait(mon, {propExampleSpells: "exampleSpellsUnofficial"}),
		];
		return mon;
	}

	static _getVariant_dragonInnateSpellcaster_mm (mon) {
		mon = MiscUtil.copy(mon);
		mon.spellcasting = [
			...(mon.spellcasting || []),
			this._getCastingColorVariantSpellcastingTrait(mon, {propExampleSpells: "exampleSpellsFtd"}),
		];
		return mon;
	}

	static _getCastingColorVariantSpellcastingTrait (mon, {propExampleSpells}) {
		const meta = Renderer.monster.dragonCasterVariant.getMeta(mon);
		const scEntry = Renderer.monster.dragonCasterVariant.getSpellcasterDetailsPart(meta);

		return {
			name: "Innate Spellcasting",
			headerEntries: [
				scEntry,
			],
			daily: {
				"1e": meta[propExampleSpells].map(it => `{@spell ${it}}`),
			},
			ability: "cha",
		};
	}

	_getListValueNames () { return [...super._getListValueNames(), "cr"]; }

	_getListItemData ({li}) {
		const $e = $(li.ele);
		return {
			...super._getListItemData({li}),
			$selCr: $e.find(`[name="sel-cr"]`),
			$selSummonSpellLevel: $e.find(`[name="sel-summon-spell-level"]`),
			$selSummonClassLevel: $e.find(`[name="sel-summon-class-level"]`),
			$selVariant: $e.find(`[name="sel-variant"]`),
			$iptRename: $e.find(`[name="ipt-rename"]`),
			$iptRenameShort: $e.find(`[name="ipt-rename-short"]`),
			$cbIsNamedCreature: $e.find(`[name="cb-is-named"]`),
			$cbIsCharacter: $e.find(`[name="cb-is-character"]`),
		};
	}

	
		async _pGetCustomizerState ({li, ent, state = null}) {
		return (await super._pGetCustomizerState({li, ent, state: state || new CustomizerStateCreature()}))
			.setVariant(this._pGetCustomizerState_variant({li, ent}))
			.setScale(this._pGetCustomizerState_scale({li, ent}))
			.setRename(this._pGetCustomizerState_rename({li, ent}))
			.setFvttType(this._pGetCustomizerState_fvttType({li, ent}));
	}

	_pGetCustomizerState_variant ({li, ent}) {
		const ixVariant = li.data.$selVariant.length
			? Number(li.data.$selVariant.val()) === -1 ? null : Number(li.data.$selVariant.val())
			: null;

		if (ixVariant == null) return null;

		return {ixVariant};
	}

	_pGetCustomizerState_scale ({li, ent}) {
		const targetCr = li.data.$selCr.length
			? Number(li.data.$selCr.val()) === -1 ? null : Number(li.data.$selCr.val())
			: null;
		const targetSpellLevel = li.data.$selSummonSpellLevel.length
			? Number(li.data.$selSummonSpellLevel.val()) === -1 ? null : Number(li.data.$selSummonSpellLevel.val())
			: null;
		const targetClassLevel = li.data.$selSummonClassLevel.length
			? Number(li.data.$selSummonClassLevel.val()) === -1 ? null : Number(li.data.$selSummonClassLevel.val())
			: null;

		if (targetCr == null && targetSpellLevel == null && targetClassLevel == null) return ent;

		return {
			targetCr,
			targetSpellLevel,
			targetClassLevel,
		};
	}

	_pGetCustomizerState_rename ({li, ent}) {
		const rename = li.data.$iptRename.val().trim();
		if (!rename) return null;

		const renameShort = li.data.$iptRenameShort.val().trim();
		const isNamedCreature = li.data.$cbIsNamedCreature.prop("checked");

		return {
			rename,
			renameShort,
			isNamedCreature,
		};
	}

	_pGetCustomizerState_fvttType ({li, ent}) {
		if (!li.data.$cbIsCharacter.prop("checked")) return null;
		return {
			foundryType: "character",
		};
	}

	
	static async _pGetAppliedCustomizations ({ent}) {
		ent = await super._pGetAppliedCustomizations({ent});

		ent = await this._pGetAppliedCustomizations_pVariant({ent});
		ent = await this._pGetAppliedCustomizations_pScale({ent});
		ent = await this._pGetAppliedCustomizations_pRename({ent});
		ent = await this._pGetAppliedCustomizations_pIsCharacter({ent});

		return ent;
	}

	static async _pGetAppliedCustomizations_pVariant ({ent}) {
		const ixVariant = ent?._fvttCustomizerState?.variant?.ixVariant;
		if (ixVariant == null) return ent;

		const variants = this._getAvailableVariants(ent);

		const variant = variants[ixVariant];
		if (variant.fnApplyVariant) return variant.fnApplyVariant(ent);
		else return variant;
	}

	static async _pGetAppliedCustomizations_pScale ({ent}) {
		const {targetCr, targetSpellLevel, targetClassLevel} = (ent?._fvttCustomizerState?.scale || {});

		if (targetCr != null && targetCr !== Parser.crToNumber(ent.cr)) return ScaleCreature.scale(ent, targetCr);
		else if (targetSpellLevel != null) return ScaleSpellSummonedCreature.scale(ent, targetSpellLevel);
		else if (targetClassLevel != null) return ScaleClassSummonedCreature.scale(ent, targetClassLevel);

		return ent;
	}

	static async _pGetAppliedCustomizations_pRename ({ent}) {
		const {rename, renameShort, isNamedCreature} = (ent?._fvttCustomizerState?.rename || {});
		if (!rename) return ent;
		return CreatureRenamer.getRenamed(ent, {newName: rename, newNameShort: renameShort, isNamedCreature, isInPlace: true});
	}

	static async _pGetAppliedCustomizations_pIsCharacter ({li, ent}) {
		if (ent?._fvttCustomizerState?.fvttType?.foundryType == null || ent?._fvttCustomizerState?.fvttType?.foundryType === "npc") return ent;

		ent.foundryType = ent._fvttCustomizerState.fvttType.foundryType;
		return ent;
	}
}

class ImportListCreature extends ImportListActor {
	static get ID () { return "creatures"; }
	static get DISPLAY_NAME_TYPE_SINGLE () { return "Creature"; }
	static get DISPLAY_NAME_TYPE_PLURAL () { return "Creatures"; }
	static get PROPS () { return ["monster"]; }

	static _ = this.registerImpl(this);

	_dirsHomebrew = ["creature"];
	_titleSearch = "creature";
	_sidebarTab = "actors";
	_gameProp = "actors";
	_defaultFolderPath = ["Creatures"];
	_pageFilter = new PageFilterBestiaryFvtt();
	_page = UrlUtil.PG_BESTIARY;
	_isPreviewable = true;
	_isDedupable = true;
	_configGroup = "importCreature";
	_fnListSort = PageFilterBestiaryFvtt.sortMonsters;
	_pFnGetFluff = Renderer.monster.pGetFluff.bind(Renderer.monster);
	_isActorRadio = true;
	_ClsCustomizer = ImportCustomizerCreature;
	static _DataConverter = DataConverterCreature;

	_actorType = "npc";
	_threeDiTokenAdapter = new ThreeDiTokenAdapterCreature();

	async pInit () {
		if (await super.pInit()) return true;

		await DataUtil.monster.pPreloadMeta();
	}

	async _pGetSources () {
		const optsBrew = {pPostLoad: this.constructor._postLoadBrew.bind(this.constructor)};

		return [
			new UtilDataSource.DataSourceSpecial(
				Config.get("ui", "isStreamerMode") ? "SRD" : "5etools",
				() => Vetools.pGetAllCreatures(),
				{
					cacheKey: "5etools-creatures",
					filterTypes: [UtilDataSource.SOURCE_TYP_OFFICIAL_ALL],
					isDefault: true,
					pPostLoad: this._postLoad_setHasTokenThreeDiFlag.bind(this),
				},
			),
			...UtilDataSource.getSourcesCustomUrl({...optsBrew}),
			...UtilDataSource.getSourcesUploadFile({...optsBrew}),
			...Object.keys(await DataUtil.monster.pLoadIndex()).map(src => new UtilDataSource.DataSourceSpecial(
				Parser.sourceJsonToFull(src),
				() => DataUtil.monster.pLoadSingleSource(src),
				{
					cacheKey: `5etools-creatures-${src}`,
					pPostLoad: this._postLoadVetools.bind(this, src),
					filterTypes: UtilDataSource.getSourceFilterTypes(src),
				},
			)),
			...(await this._pGetSourcesPrerelease({...optsBrew})),
			...(await this._pGetSourcesBrew({...optsBrew})),
		];
	}

	_postLoadVetools (src, data) {
		data = {...data};
		data.monster = data.monster.filter(it => it.source === src);
		return this._postLoad_setHasTokenThreeDiFlag(data);
	}

	static _postLoadBrew (data) {
		DataUtil.monster.populateMetaReference(data);
		return data;
	}

	async pGetChooseImporterUserDataForSources (sources) {
		return {
			isSingletonSource_officialAdventure: sources.length === 1 && sources[0].source && Parser.SOURCES_ADVENTURES.has(sources[0].source),
		};
	}

	async _pPostFilterRender () {
		if (!this._userData) return;

				const isSingletonSourceOfficialAdventure = this._userData.isSingletonSource_officialAdventure;
		this._userData = null;
		if (!isSingletonSourceOfficialAdventure) return;

		const KEY_MISC = "Miscellaneous";
		const miscValues = this._pageFilter.filterBox.getValues()[KEY_MISC];
		this._pageFilter.filterBox.setFromValues({
			[KEY_MISC]: {
				...Object.entries(miscValues)
					.filter(([k]) => !k.startsWith("_"))
					.mergeMap(([k, v]) => ({[k]: v})),
				"Adventure NPC": 0,
			},
		});
	}

	_renderInner_getListSyntax () {
		return new ListSyntaxBestiary({
			fnGetDataList: () => this._content,
			pFnGetFluff: this._pFnGetFluff,
		}).build();
	}

	_colWidthName = 4;
	_colWidthSource = 1;

	_getData_cols_other () {
		return [
			{
				name: "Type",
				width: 5,
				field: "type",
			},
			{
				name: "CR",
				width: 1,
				field: "cr",
				rowClassName: "text-center",
			},
		];
	}

	_getData_row_mutGetAdditionalValues ({it, ix}) {
				it._vCr = it._pCr || "\u2014";
		
		return {
			type: it._pTypes.asTextShort,
			cr: it._vCr,
		};
	}

	getData () {
		return {
			...super.getData(),
			buttonsAdditional: [
				{
					name: "btn-run-mods",
					text: "Customize and Import...",
				},
			],
		};
	}

	_renderInner_absorbListItems_fnGetValues (it) {
		return {
			...super._renderInner_absorbListItems_fnGetValues(it),
			type: it._pTypes.asTextShort,
			cr: it._vCr,
			group: it.group || "",
			alias: (it.alias || []).map(it => `"${it}"`).join(","),
		};
	}

	getFolderPathMeta () {
		return {
			...super.getFolderPathMeta(),
			cr: {
				label: "Challenge Rating",
				getter: it => this.constructor._getFolderCr(it),
			},
			type: {
				label: "Type",
				getter: it => this.constructor._getFolderType(it),
			},
			typeTags: {
				label: "Type (With Tags)",
				getter: it => this.constructor._getFolderTypeWithTags(it),
			},
		};
	}

	static _getFolderCr (it) { return it.cr ? (it.cr.cr || it.cr) : "Unknown CR"; }
	static _getFolderType (it) { return Parser.monTypeToFullObj(it.type).types.join("/").toTitleCase(); }
	static _getFolderTypeWithTags (it) { return Parser.monTypeToFullObj(it.type).asTextShort.toTitleCase(); }

	_pImportEntry_getTokenInfoGetters (ent, {taskRunner = null, isPreferFoundryOverride = null} = {}) {
		const getters = super._pImportEntry_getTokenInfoGetters(...arguments);

		if (
			Config.get("importCreature", "isUsePathfinderTokenPackBestiariesImages")
			&& UtilCompat.isPf2eTokensBestiaryActive()
		) {
			getters.unshift(
				async () => {
					const tokenInfo = await this._pGetCompendiumTokenInfo(ent, {taskRunner});
					if (tokenInfo?.img?.includes(`modules/${UtilCompat.MODULE_PF2E_TOKENS_BESTIARIES}/`)) return tokenInfo;

					const pfMeta = await this.constructor._pGetPathfinderTokenPackBestiariesMeta(ent);
					if (!pfMeta) return null;

					return {
						img: pfMeta.imgToken,
						scale: pfMeta.tokenScale,
					};
				},
			);
		}

		return getters;
	}

	_pImportEntry_pFillBase_pGetPortraitImagePath_getPortraitImageGetters (imp, fluff, opts) {
		const getters = super._pImportEntry_pFillBase_pGetPortraitImagePath_getPortraitImageGetters(...arguments);

		if (
			Config.get("importCreature", "isUsePathfinderTokenPackBestiariesImages")
			&& UtilCompat.isPf2eTokensBestiaryActive()
		) {
			getters.unshift(
				async () => {
					if (opts.isUseTokenImageAsPortrait) return null;

					const img = await this._pImportEntry_pFillBase_pGetPortraitImagePath_fromFoundry(imp, opts);
					if (img?.includes(`modules/${UtilCompat.MODULE_PF2E_TOKENS_BESTIARIES}/`)) return img;

					const pfMeta = await this.constructor._pGetPathfinderTokenPackBestiariesMeta(imp);
					if (!pfMeta) return null;

					return pfMeta.imgPortrait;
				},
			);
		}

		return getters;
	}

	static _P_LOAD_PATHFINDER_TOKEN_BESTIARIES = null;
	static async _pGetPathfinderTokenPackBestiariesMeta (imp) {
				const getLookupName = name => {
			return Util.Slugify.slugifyFast.call(name.toLowerCase(), {strict: true})
				.split("-")
				.map(it => it.trim())
				.filter(Boolean)
				.sort(SortUtil.ascSortLower)
				.join("-");
		};

		this._P_LOAD_PATHFINDER_TOKEN_BESTIARIES = this._P_LOAD_PATHFINDER_TOKEN_BESTIARIES || (async () => {
			const pathIndexArt = game.modules.get(UtilCompat.MODULE_PF2E_TOKENS_BESTIARIES).flags?.[UtilCompat.MODULE_PF2E_TOKENS_BESTIARIES]?.["pf2e-art"];

			const indexArt = await DataUtil.loadJSON(pathIndexArt);

			const out = {};

			Object.values(indexArt)
				.forEach(indexPack => {
					Object.values(indexPack)
						.forEach(({actor: actorInfo, token: tokenInfo}) => {
																					const actorInfoExpanded = actorInfo ? {path: actorInfo} : null;
							const tokenInfoExpanded = tokenInfo
								? {
									path: typeof tokenInfo === "string" ? tokenInfo : tokenInfo.img,
									scale: typeof tokenInfo !== "string" ? tokenInfo.scale : null,
								}
								: null;

							if (!actorInfoExpanded && !tokenInfoExpanded) return;

							const ptName = getLookupName((actorInfoExpanded || tokenInfoExpanded).path.split("/").last().split(".")[0]);

							out[ptName] = {
								imgToken: tokenInfoExpanded?.path,
								tokenScale: tokenInfoExpanded?.scale,
								imgPortrait: actorInfoExpanded?.path,
							};
						});
				});

			return out;
		})();

		const nameLookup = getLookupName(imp.name || "");

		return (await this._P_LOAD_PATHFINDER_TOKEN_BESTIARIES)[nameLookup];
	}

	_pGetPreCustomizedEntries (entries) {
		if (!this._actor) return entries;

		const customizerState = new CustomizerStateCreature()
			.setRename({
				rename: this._actor.name,
				isNamedCreature: true,
			});
		if (this._actor.type === "character") customizerState.setFvttType({foundryType: "character"});
		if (!UtilImage.isDefaultActorImage(this._actor.prototypeToken.texture.src)) customizerState.setToken({url: this._actor.prototypeToken.texture.src});

		const foundryImg = UtilImage.isDefaultActorImage(this._actor.img) ? null : this._actor.img;

		const actorObj = this._actor.toObject(true);

		const foundrySystem = {};
		Consts.USER_DATA_TRACKING_KEYS__ACTOR
			.forEach(k => {
				if (!k.startsWith("system.")) throw new Error("Unimplemented!");
				foundrySystem[k.replace("system.", "")] = foundry.utils.getProperty(actorObj, k);
			});

		return entries
			.map(ent => {
				ent = MiscUtil.copyFast(ent);

				ent._fvttCustomizerState = customizerState.toJson();
				ent.foundryImg = foundryImg;
				ent.foundrySystem = MiscUtil.copyFast(foundrySystem);

				return ent;
			});
	}

	async _pImportEntry_pGetImportMetadata (actor, mon, importOpts, importOptsEntity) {
		const act = {};

		const fluff = await Renderer.utils.pGetFluff({
			entity: mon,
			pFnPostProcess: Renderer.monster.postProcessFluff.bind(null, mon),
			fluffBaseUrl: `data/bestiary/`,
			fluffProp: "monsterFluff",
		});

		const dataBuilderOpts = new ImportListCreature.ImportEntryOpts({actor, mon, fluff});

		await this._pImportEntry_pFillBase(mon, act, dataBuilderOpts.fluff, {isUseTokenImageAsPortrait: Config.get(this._configGroup, "isUseTokenImageAsPortrait"), taskRunner: importOpts.taskRunner});

		act.system = {};

		await this._pImportEntry_pFillFolder(mon, act, importOpts, importOptsEntity);

		if (importOpts.defaultOwnership != null) act.ownership = {default: importOpts.defaultOwnership};
		else act.ownership = {default: Config.get(this._configGroup, "ownership")};
		if (importOpts.userOwnership) Object.assign(act.ownership, importOpts.userOwnership);

		this._pImportEntry_fillData_Abilities(mon, act.system, dataBuilderOpts);
		await this._pImportEntry_pFillData_Attributes(mon, act, dataBuilderOpts);
		await this._pImportEntry_pFillData_Details(mon, act.system, dataBuilderOpts);
		this._pImportEntry_fillData_Skills(mon, act.system, dataBuilderOpts);
		this._pImportEntry_fillData_Traits(mon, act.system, dataBuilderOpts);
		this._pImportEntry_fillData_Currency(mon, act.system, dataBuilderOpts);
		this._pImportEntry_fillData_Spells(mon, act.system, dataBuilderOpts);
		this._pImportEntry_fillData_Resources(mon, act.system, dataBuilderOpts);

		const additionalData = await this.constructor._DataConverter._pGetDataSideLoaded(mon);
		foundry.utils.mergeObject(act.system, additionalData);

		await this._pImportEntry_pFillToken({importable: mon, actorData: act, flags: this._getTokenFlags({mon}), isLinkToken: mon.isNpc, taskRunner: importOpts.taskRunner});

		return {dataBuilderOpts: dataBuilderOpts, actorData: act};
	}

	_getActorSheetName (it) {
		const out = [UtilDataConverter.getNameWithSourcePart(it)];

		const tagsToAdd = Config.get(this._configGroup, "nameTags");

		Object.entries(tagsToAdd)
			.filter(([, v]) => v)
			.forEach(([k]) => {
				switch (Number(k)) {
					case ConfigConsts.C_CREATURE_NAMETAGS_CR: out.push(`[${this.constructor._getFolderCr(it)}]`); break;
					case ConfigConsts.C_CREATURE_NAMETAGS_TYPE: out.push(`[${this.constructor._getFolderType(it)}]`); break;
					case ConfigConsts.C_CREATURE_NAMETAGS_TYPE_WITH_TAGS: out.push(`[${this.constructor._getFolderTypeWithTags(it)}]`); break;
				}
			});

		return out.join(" ");
	}

	_getActorFlags (mon) {
		const out = super._getActorFlags(mon);

		if (
			UtilCompat.isMonksLittleDetailsActive()
			&& Config.get("importCreature", "isAddSoundEffect")
			&& mon.soundClip
		) {
			out["monks-little-details"] = {"sound-effect": Renderer.utils.getMediaUrl(mon, "soundClip", "audio")};
		}

		return out;
	}

	async _pImportEntry_pFillData_Attributes (mon, act, monOpts) {
		const sys = act.system;

		const out = {};

		const acMeta = mon.ac && mon.ac.length ? (await this._pImportEntry_getAcMeta(mon, monOpts)) : null;

		out.ac = {
			flat: acMeta?.flat,
			min: 0,
			calc: acMeta?.calc || "default",
			formula: acMeta?.formula,
			value: acMeta?.value,
		};

		let hpMax = 0;
		let hpFormula = "";
		if (mon.hp) {
						if (mon.hp.special) {
				mon.hp.special.replace(/^(?<hp>\d+)\s*(?:[-+]|$)/, (...m) => {
					hpMax = Number(m.last().hp);
				});
			}

			if (mon.hp.average) hpMax = mon.hp.average;
			if (mon.hp.formula) hpFormula = mon.hp.formula;
		}

		out.hp = {
			value: hpMax,
			min: 0,
			max: hpMax,
			temp: 0,
			tempmax: 0,
			formula: hpFormula,
		};

		out.init = {
			value: 0,
			mod: 0,
			bonus: 0,
			total: Parser.getAbilityModNumber(Renderer.monster.getSafeAbilityScore(mon, "dex", {isDefaultTen: true})),
			prof: 0,
		};

		out.prof = monOpts.pb;

		out.movement = DataConverter.getMovement(mon.speed, {configGroup: "importCreature"});

		out.spellcasting = monOpts.spellAbility;

		out.spelldc = monOpts.spellDc;

		out.senses = {
			darkvision: 0,
			blindsight: 0,
			tremorsense: 0,
			truesight: 0,
			units: Config.getMetricUnitDistance({configGroup: "importCreature", configKey: "isTokenMetric", originalUnit: "ft"}),
			special: "",
		};

		out.senses.special = (mon.senses || [])
			.filter(sens => {
				sens = sens.replace(Parser._numberCleanRegexp, "");

				const mSense = /(blindsight|darkvision|tremorsense|truesight)\s*(\d+)/i.exec(sens);
				if (!mSense) return true;

																const num = Config.getMetricNumberDistance({configGroup: "importCreature", configKey: "isTokenMetric", originalValue: Number(mSense[2]), originalUnit: "feet"});
				switch (mSense[1]) {
					case "darkvision": out.senses.darkvision = num; break;
					case "blindsight": out.senses.blindsight = num; break;
					case "tremorsense": out.senses.tremorsense = num; break;
					case "truesight": out.senses.truesight = num; break;
				}
				return false;
			})
			.join(", ");

		sys.attributes = out;
	}

		async _pImportEntry_getAcMeta (mon, monOpts) {
		const ac0 = mon.ac[0];
		const acVal = this.constructor._pImportEntry_getAcMeta_getAcVal({ac0});

		if (Config.get("importCreature", "isUseStaticAc")) {
			const acValStatic = acVal == null ? 10 : acVal;
			return {calc: "custom", formula: `${acValStatic}`, value: acValStatic};
		}

		const acHashes = this.constructor._getItemHashesFromAcItem(ac0);

		if (!acHashes.length) {
			if (acVal == null || (10 + Parser.getAbilityModNumber(Renderer.monster.getSafeAbilityScore(mon, "dex", {isDefaultTen: true}))) === acVal) return {calc: "default", formula: null, value: null};
		}

		const {ac: acFromItemEffects, isDexIncluded: isDexAlreadyIncluded, isAnyItemIncluded} = await this._pImportEntry_pFillData_Attributes_Ac_getAcFromItems(mon, acHashes);

				if (acVal == null) return {calc: "default", formula: null, value: null};

		const delta = acVal - (acFromItemEffects + (isDexAlreadyIncluded ? 0 : Parser.getAbilityModNumber(Renderer.monster.getSafeAbilityScore(mon, "dex", {isDefaultTen: true}))));
				if (!delta) return {calc: "default", formula: null, value: null};

		if (!isAnyItemIncluded) {
						if (!Config.get("importCreature", "isUseCustomNaturalAc") && (ac0.from || []).some(it => /^natural armor$/i.test(`${it}`.trim()))) {
				return {calc: "natural", formula: null, value: null, flat: acVal};
			}

						return {calc: "custom", formula: `@attributes.ac.armor + @attributes.ac.dex ${UiUtil.intToBonus(delta)}`, value: null};
		}

				if (!Config.get("importItem", "isAddActiveEffects")) return {calc: "custom", formula: null, value: acVal};

																														monOpts.effects.push({
			label: "Other AC Bonus",
			icon: `modules/${SharedConsts.MODULE_ID}/media/icon/mighty-force.svg`,
			changes: [
				{
					key: "system.attributes.ac.bonus",
					value: delta,
					mode: CONST.ACTIVE_EFFECT_MODES.ADD,
					priority: UtilActiveEffects.PRIORITY_BONUS,
				},
			],
			disabled: false,
			duration: {
				startTime: null,
				seconds: null,
				rounds: null,
				turns: null,
				startRound: null,
				startTurn: null,
			},
			origin: null,
			tint: "",
			transfer: false,
			flags: {
				[SharedConsts.MODULE_ID]: {
					dedupeId: "otherAcBonus",
				},
			},
		});

		return {calc: "default", formula: null, value: null};
	}

	static _pImportEntry_getAcMeta_getAcVal ({ac0}) {
		if (ac0.ac != null) return ac0.ac;
		if (ac0.special == null) return typeof ac0 === "number" ? ac0 : null;
		const mSpecial = /^(?<number>\d+)\s*([-+]|plus|minus)/gi.exec(ac0.special);
		if (!mSpecial) return null;
		return Number(mSpecial.groups.number);
	}

	async _pImportEntry_pFillData_Attributes_Ac_getAcFromItems (mon, acHashes) {
		let isAnyItem = false;
		let acBase = 10;
		let acBonusShield = 0; 		let acBonusOther = 0;
		let isDexIncluded = false;

		for (const acHash of acHashes) {
			const item = await DataLoader.pCacheAndGetHash(UrlUtil.PG_ITEMS, acHash);
			if (!item) continue;

			let bonusAc = Number(item.bonusAc || 0);
			if (isNaN(bonusAc)) bonusAc = 0;

			switch (item.bardingType || item.type) {
				case "HA": { 					isAnyItem = true;
					acBase = Math.max(acBase, (item.ac || 10) + bonusAc);
					isDexIncluded = true;
					break;
				}

				case "MA": { 					isAnyItem = true;
					const maxDex = item.dexterityMax === null ? Number.MAX_SAFE_INTEGER : item.dexterityMax != null ? item.dexterityMax : 2;
					acBase = Math.max(acBase, (item.ac || 10) + Math.min(maxDex, Parser.getAbilityModNumber(Renderer.monster.getSafeAbilityScore(mon, "dex", {isDefaultTen: true}))) + bonusAc);
					isDexIncluded = true;
					break;
				}

				case "LA": { 					isAnyItem = true;
					acBase = Math.max(acBase, (item.ac || 10) + Parser.getAbilityModNumber(Renderer.monster.getSafeAbilityScore(mon, "dex", {isDefaultTen: true})) + bonusAc);
					isDexIncluded = true;
					break;
				}

				case "S": { 					isAnyItem = true;
					acBonusShield = Math.max(acBonusShield, 2 + bonusAc);
					break;
				}

				default: {
																									if (Config.get("importItem", "isAddActiveEffects")) {
						isAnyItem = true;
						acBonusOther += bonusAc;
					}
				}
			}
		}

		return {
			ac: acBase + acBonusShield + acBonusOther,
			isDexIncluded,
			isAnyItemIncluded: isAnyItem,
		};
	}

	async _pImportEntry_pFillData_Details (mon, sys, monOpts) {
		const out = {};

		out.alignment = mon.alignment ? Parser.alignmentListToFull(mon.alignment).toLowerCase() : "";

		out.biography = {
			value: await this._pGetBiographyValue(
				mon,
				monOpts.fluff,
				{
					isImportText: Config.get(this._configGroup, "isImportBio"),
					isImportImages: Config.get(this._configGroup, "isImportBioImages"),
					additionalHtml: Config.get(this._configGroup, "isImportBioVariants") ? Renderer.monster.getRenderedVariants(mon) : null,
				},
			),
		};

		if (monOpts.spellLevel || monOpts.spellClass) {
			out.class = {
				level: monOpts.spellLevel,
				name: monOpts.spellClass,
			};
		} else {
			out.class = {};
		}

		out.spellLevel = monOpts.spellLevel;

		out.race = "";

		ImportListCreature._CREATURE_TYPES = ImportListCreature._CREATURE_TYPES || new Set(Object.keys(CONFIG.DND5E.creatureTypes));

		const typeInfo = Parser.monTypeToFullObj(mon.type);
		if (typeInfo.types.length === 1 && ImportListCreature._CREATURE_TYPES.has(typeInfo.types[0])) {
			out.type = {
				value: typeInfo.types[0],
				subtype: typeInfo.tags.join(", "),
				swarm: typeInfo.swarmSize ? UtilActors.VET_SIZE_TO_ABV[typeInfo.swarmSize] : null,
			};
		} else {
			out.type = {
				custom: Parser.monTypeToFullObj(mon.type).asText,
			};
		}

		out.environment = mon.environment ? mon.environment.sort(SortUtil.ascSortLower).map(it => it.toTitleCase()).join(", ") : "";

		const crNum = Parser.crToNumber(mon.cr);
		out.cr = crNum >= VeCt.CR_CUSTOM ? 0 : crNum;

		out.xp = {
			value: mon.cr ? (Parser.crToXpNumber(mon.cr) || 0) : 0,
		};

		out.source = UtilDataConverter.getSourceWithPagePart(mon);

		sys.details = out;
	}

	_pImportEntry_fillData_Skills (mon, sys, dataBuilderOpts) {
		sys.skills = DataConverterCreature.getDataSkills(mon, sys, dataBuilderOpts);
	}

	_pImportEntry_fillData_Traits (mon, sys, dataBuilderOpts) {
		const out = {};

		out.size = UtilActors.VET_SIZE_TO_ABV[dataBuilderOpts.size] || "med";

		const allLangs = new Set();
		let customLangs = [];

		if (mon.languages) {
			mon.languages.forEach(l => {
				const lClean = l.toLowerCase().trim();
				const lMapped = UtilActors.VALID_LANGUAGES[lClean];

				if (lMapped) allLangs.add(lMapped);
				else if (lClean === "all") {
					Object.values(UtilActors.VALID_LANGUAGES).forEach(vl => allLangs.add(vl));
				} else {
					customLangs.push(l);
				}
			});
		}

										if (mon.languageTags) {
			mon.languageTags
				.map(lt => Parser.monLanguageTagToFull(lt))
				.map(fl => UtilActors.VALID_LANGUAGES[fl.toLowerCase()])
				.filter(Boolean)
				.forEach(ml => allLangs.add(ml));
		}

		out.languages = {
			value: [...allLangs],
			custom: customLangs.filter(Boolean).join("; "),
		};

		this._pImportEntry_fillConditionsDamage(mon, out);

		sys.traits = out;
	}

	_pImportEntry_fillData_Currency (mon, sys, monOpts) {
				sys.currency = {
			pp: 0,
			gp: 0,
			ep: 0,
			sp: 0,
			cp: 0,
		};
	}

	_pImportEntry_fillData_Spells (mon, sys, monOpts) {
		sys.spells = DataConverterCreature.getDataSpells(mon, sys, monOpts);

		if (
			!DataConverterCreature.isSlotSpellcaster(mon)
			|| Config.get("importSpell", "spellPointsModeNpc") !== ConfigConsts.C_SPELL_POINTS_MODE__ENABLED_AND_UNLIMITED_SLOTS
		) return;

		const {system: sysSpellPoints} = UtilActors.getActorSpellPointsSlotsUpdateSys();
		foundry.utils.mergeObject(sys, sysSpellPoints);

		if (!monOpts.spellLevel) return;

		monOpts.postItemItemUpdates.push(async ({actor}) => {
			await UtilActors.pGetCreateActorSpellPointsItem({actor: actor, totalSpellcastingLevels: monOpts.spellLevel});
		});
	}

	_pImportEntry_fillData_Resources (mon, sys, monOpts) {
		const out = {};

		let legAct = 0;
		if (mon.legendary || mon.mythic) legAct = mon.legendaryActions || 3;

		out.legact = {
			value: legAct,
			max: legAct,
		};

		let legRes = 0;
		if (mon.trait) {
			const legResTrait = mon.trait.find(it => /legendary resistance/gi.test(it.name || ""));
			if (legResTrait) {
				const m = /\((\d+)\/Day\)/i.exec(legResTrait.name);
				if (m) legRes = Number(m[1]);
			}
		}

		out.legres = {
			value: legRes,
			max: legRes,
		};

		out.lair = {
			value: !!(monOpts.legendaryMeta && monOpts.legendaryMeta.lairActions),
			initiative: 20, 		};

		sys.resources = out;
	}

	async _pImportEntry_pFillItems (mon, act, dataBuilderOpts, importOpts) {
		
		const isTemporary = importOpts.isTemp || this._pack != null;

				await this._pImportEntry_pFillItems_pResources(mon, act, dataBuilderOpts);
		dataBuilderOpts.importedSheetItems = await UtilActors.pAddActorItems(dataBuilderOpts.actor, dataBuilderOpts.items, {isTemporary});
		dataBuilderOpts.items = [];
		
				await this._pImportEntry_pFillItems_pActions(mon, act, importOpts, dataBuilderOpts);
		await this._pImportEntry_pFillItems_pTraitsReactionsLegendaries(
			mon,
			act,
			importOpts,
			dataBuilderOpts,
			{
				prop: "trait",
				fnPreProcess: trait => {
					if (!/legendary resistance/gi.test(trait.name || "")) return;
					trait._plut_isLegendaryResistance = true;
				},
			},
			{
				consumeType: trait => trait._plut_isLegendaryResistance ? "attribute" : null,
				consumeTarget: trait => trait._plut_isLegendaryResistance ? "resources.legres.value" : null,
				consumeAmount: trait => trait._plut_isLegendaryResistance ? 1 : null,
			},
		);
		await this._pImportEntry_pFillItems_pTraitsReactionsLegendaries(mon, act, importOpts, dataBuilderOpts, {prop: "bonus"}, {
			activationType: "bonus",
			activationCost: 1,
		});
		await this._pImportEntry_pFillItems_pTraitsReactionsLegendaries(mon, act, importOpts, dataBuilderOpts, {prop: "reaction"}, {
			activationType: "reaction",
			activationCost: 1,
		});
		const legendaryItems = await this._pImportEntry_pFillItems_pTraitsReactionsLegendaries(
			mon,
			act,
			importOpts,
			dataBuilderOpts,
			{
				prop: "legendary",
				fnPreProcess: legEnt => {
					this.constructor._mutLegendaryActionNameAndCost(legEnt);
				},
			},
			{
				activationType: "legendary",
				activationCost: legEnt => legEnt._plut_legActions,
				consumeType: "attribute",
				consumeTarget: "resources.legact.value",
				consumeAmount: legEnt => legEnt._plut_legActions,
			},
		);
		await this._pImportEntry_pFillItems_pLegendaryHeader(mon, act, importOpts, dataBuilderOpts, legendaryItems);
		const mythicItems = await this._pImportEntry_pFillItems_pTraitsReactionsLegendaries(
			mon,
			act,
			importOpts,
			dataBuilderOpts,
			{
				prop: "mythic",
				fnPreProcess: legEnt => {
					this.constructor._mutLegendaryActionNameAndCost(legEnt);
				},
			},
			{
				activationType: "legendary",
				activationCost: legEnt => legEnt._plut_legActions,
				consumeType: "attribute",
				consumeTarget: "resources.legact.value",
				consumeAmount: legEnt => legEnt._plut_legActions,
			},
		);
		await this._pImportEntry_pFillItems_pMythicHeader(mon, act, importOpts, dataBuilderOpts, mythicItems);
		await this._pImportEntry_pFillItems_pOtherHeaders(mon, act, dataBuilderOpts, mythicItems);
		await this._pImportEntry_pFillItems_pLairActions(mon, act, importOpts, dataBuilderOpts);
		await this._pImportEntry_pFillItems_pRegionalEffects(mon, act, importOpts, dataBuilderOpts);
		await this._pImportEntry_pFillItems_pVariants(mon, act, importOpts, dataBuilderOpts);

		await this._pImportEntry_pFillItems_pInventory(mon, act, importOpts, dataBuilderOpts);

				await this._pImportEntry_pFillItems_pFakeClass(mon, act, dataBuilderOpts);

				dataBuilderOpts.importedSheetItems = [
			...dataBuilderOpts.importedSheetItems,
			...(await UtilActors.pAddActorItems(dataBuilderOpts.actor, dataBuilderOpts.items, {isTemporary})),
		];

				const tempItems = dataBuilderOpts.items;
		dataBuilderOpts.items = [];

				await this._pImportEntry_pFillItems_pSpellcasting(mon, act, isTemporary, importOpts, dataBuilderOpts);
		const importedSheetItemsSpells = await UtilActors.pAddActorItems(dataBuilderOpts.actor, dataBuilderOpts.items, {isTemporary});

				dataBuilderOpts.importedSheetItems = [...dataBuilderOpts.importedSheetItems, ...importedSheetItemsSpells];
		dataBuilderOpts.items = [...tempItems, ...dataBuilderOpts.items];
	}

	static _mutLegendaryActionNameAndCost (legEnt) {
		if (!legEnt) return;

		legEnt._plut_legActions = legEnt._plut_legActions || 1;
		if (!legEnt.name) return;

		legEnt.name = legEnt.name.replace(/\(costs (\d+) actions?\)/i, (...m) => {
			legEnt._plut_legActions = Number(m[1]);
			return "";
		}).trim();
	}

		async _pImportEntry_pFillItems_pAddTextOnlyItem ({mon, dataBuilderOpts, act, entry, opts_getItem, prop, foundryFlags}) {
		foundryFlags = foundryFlags || {};

		if (prop) {
			const propChild = `monster${prop.uppercaseFirst()}`;

			const tgt = MiscUtil.getOrSet(foundryFlags, SharedConsts.MODULE_ID, {});
			Object.assign(
				tgt,
				{
					page: propChild,
					source: entry.source || mon.source,
					hash: UrlUtil.URL_TO_HASH_BUILDER[propChild]({
						source: mon.source,
						...entry,
						monsterName: mon.name,
						monsterSource: mon.source,
					}),
				},
			);
		}

		const item = await DataConverter.pGetItemActorPassive(
			entry,
			{
				...this._getFeatureResourceUsage(entry, dataBuilderOpts),
				...opts_getItem,
				mode: "creature",
				pb: dataBuilderOpts.getSheetPb(),
				entity: mon,
				source: mon.source,
				summonSpellLevel: mon._summonedBySpell_level ?? mon.summonedBySpellLevel,
				actor: {system: act}, 				foundryFlags,
			},
		);

		dataBuilderOpts.items.push(item);

		return item;
	}

	async _pImportEntry_pFillItems_pLegendaryHeader (mon, act, importOpts, dataBuilderOpts, legendaryItems) {
		return this._pImportEntry_pFillItems_pLegendaryMythicHeader({
			mon,
			act,
			importOpts,
			dataBuilderOpts,
			addedItems: legendaryItems,
			prop: "legendary",
			itemName: "Legendary Actions",
			renderedEntries: await UtilDataConverter.pGetWithDescriptionPlugins(() => Renderer.monster.getLegendaryActionIntro(mon, {isUseDisplayName: !!mon._fvttRenameMeta})),
			foundryFlags: {
				[SharedConsts.MODULE_ID]: {
					dedupeId: "legendaryActions",
				},
			},
		});
	}

	async _pImportEntry_pFillItems_pMythicHeader (mon, act, importOpts, dataBuilderOpts, mythicItems) {
		return this._pImportEntry_pFillItems_pLegendaryMythicHeader({
			mon,
			act,
			importOpts,
			dataBuilderOpts,
			addedItems: mythicItems,
			prop: "mythic",
			itemName: "Mythic Actions",
			renderedEntries: await UtilDataConverter.pGetWithDescriptionPlugins(() => Renderer.monster.getSectionIntro(mon, {prop: "mythic"})),
			foundryFlags: {
				[SharedConsts.MODULE_ID]: {
					dedupeId: "mythicActions",
				},
			},
		});
	}

	async _pImportEntry_pFillItems_pOtherHeaders (mon, act, dataBuilderOpts) {
		const propMetas = [
			{prop: "trait", name: "Traits"},
			{prop: "action", name: "Actions"},
			{prop: "bonus", name: "Bonus Actions"},
			{prop: "reaction", name: "Reactions"},
		];

		for (const {prop, name} of propMetas) {
			const noteKey = `${prop}Note`;
			if (!mon[noteKey]) continue;

			await this._pImportEntry_pFillItems_pAddTextOnlyItem({
				mon,
				dataBuilderOpts,
				act,
				entry: {
					name: `${name} \u2013 ${mon[noteKey]}`,
					entries: [],
				},
				opts_getItem: {
					img: "icons/sundries/books/book-red-exclamation.webp",
					description: "",
				},
				foundryFlags: {
					[SharedConsts.MODULE_ID]: {
						dedupeId: noteKey,
					},
				},
			});
		}

		for (const {prop, name} of propMetas) {
			const headerKey = `${prop}Header`;
			if (!mon[headerKey]) continue;

			await this._pImportEntry_pFillItems_pAddTextOnlyItem({
				mon,
				dataBuilderOpts,
				act,
				entry: {
					name: `${name} \u2013 Note`,
					entries: mon[headerKey],
				},
				opts_getItem: {
					img: "icons/sundries/books/book-red-exclamation.webp",
				},
				foundryFlags: {
					[SharedConsts.MODULE_ID]: {
						dedupeId: headerKey,
					},
				},
			});
		}
	}

	async _pImportEntry_pFillItems_pLegendaryMythicHeader (
		{
			mon,
			act,
			importOpts,
			dataBuilderOpts,
			addedItems,
			prop,
			itemName,
			renderedEntries,
			foundryFlags,
		},
	) {
		if (!mon[prop]) return;

		const legendaryItemTags = addedItems
			.map(it => `@UUID[Actor.${dataBuilderOpts.actor.id}.Item.${it._id}]{${it.name}}`);

		const description = `<div>
			<div>${renderedEntries}</div>
			${legendaryItemTags.length ? `<div>${Renderer.get().render({type: "list", items: legendaryItemTags})}</div>` : ""}
		</div>`;

		const img = await DataConverterCreature.pGetTraitReactionLegendaryImage(mon, {name: itemName}, dataBuilderOpts, {taskRunner: importOpts.taskRunner});

		dataBuilderOpts.items.push(await DataConverter.pGetItemActorPassive(
			{name: itemName},
			{
				description,
				mode: "creature",
				pb: dataBuilderOpts.getSheetPb(),
				entity: mon,
				source: mon.source,
				summonSpellLevel: mon._summonedBySpell_level ?? mon.summonedBySpellLevel,
				actor: {system: act}, 				img,
				foundryFlags,
			},
		));
	}

		async _pImportEntry_pFillItems_pTraitsReactionsLegendaries (mon, act, importOpts, dataBuilderOpts, opts, optsFoundryData) {
		optsFoundryData = optsFoundryData || {};

		if (!mon[opts.prop]) return;

		const out = [];

		for (let entry of mon[opts.prop]) {
			entry = MiscUtil.copy(entry);

						entry._foundryId = foundry.utils.randomID();

			if (opts.fnPreProcess) opts.fnPreProcess(entry);

			const {
				saveAbility,
				saveScaling,
				saveDc,
			} = this._getSavingThrowData(mon, dataBuilderOpts.getSheetPb(), dataBuilderOpts.spellAbility, JSON.stringify(entry));

			const nxtOpts = {
				saveAbility,
				saveScaling,
				saveDc,
			};

			Object.entries(optsFoundryData)
				.forEach(([k, v]) => {
					if (typeof v === "function") nxtOpts[k] = v(entry);
					else nxtOpts[k] = MiscUtil.copy(v);
				});

			const img = await DataConverterCreature.pGetTraitReactionLegendaryImage(mon, entry, dataBuilderOpts, {isLegendary: opts.prop === "legendary" || opts.prop === "mythic", taskRunner: importOpts.taskRunner});

			const addedItem = await this._pImportEntry_pFillItems_pAddTextOnlyItem({
				mon,
				dataBuilderOpts,
				act,
				entry,
				opts_getItem: {
					...nxtOpts,
					img,
				},
				prop: opts.prop,
			});

			out.push(addedItem);
		}

		return out;
	}

	static _getLairActionName (strEnt) {
		const stripped = Renderer.stripTags(strEnt);

		let truncatedName = "Lair: ";
		const spl = stripped.split(" ");
		for (const pt of spl) {
			if ((truncatedName.length + pt.length) < 50) {
				truncatedName += `${pt} `;
			} else break;
		}
		if (stripped.length > truncatedName.trim().length) truncatedName += "...";
		else truncatedName = truncatedName.trim();

		return truncatedName;
	}

	async _pImportEntry_pFillItems_pLairActions (mon, act, importOpts, dataBuilderOpts) {
		if (!dataBuilderOpts.legendaryMeta?.lairActions) return;

		const lairPart = CreatureRenamer.getRenamedEntries(dataBuilderOpts.legendaryMeta.lairActions, mon._fvttRenameMeta);

				const listItems = this._pImportEntry_pFillItems_lairActions_getListItems(lairPart);
		if (listItems.length) {
			for (const listItem of listItems) {
				const ent = this._pImportEntry_pFillItems_lairActions_getLairActionEntryFromListItem(listItem);
				await this._pImportEntry_pFillItems_lairActions_addLairAction(mon, act, importOpts, dataBuilderOpts, ent);
			}
			return;
		}

				const entry = this._pImportEntry_pFillItems_lairActions_getLairActionEntry(lairPart);
		await this._pImportEntry_pFillItems_lairActions_addLairAction(mon, act, importOpts, dataBuilderOpts, entry);
	}

	_pImportEntry_pFillItems_lairActions_getListItems (ent) {
		const out = [];
		MiscUtil.getWalker({isNoModification: true}).walk(
			ent,
			{
				object: obj => {
					if (obj.type !== "list") return;
					out.push(...(obj.items || []));
				},
			},
		);
		return out;
	}

	_pImportEntry_pFillItems_lairActions_getLairActionEntryFromListItem (ent) {
				if (typeof ent === "string") {
			return {
				type: "entries",
				name: this.constructor._getLairActionName(ent),
				entries: [
					ent,
				],
			};
		}

				if (ent.name && (ent.entry || ent.entries)) {
			const entries = ent.entries || [ent.entry];
			return {
				type: "entries",
				name: this.constructor._getLairActionName(ent.name.replace(/\s*[.?!]$/, "")),
				entries,
			};
		}

		throw new Error(`Unhandled lair action format!`);
	}

	_pImportEntry_pFillItems_lairActions_getLairActionEntry (ent) {
		if (typeof ent[0] === "string") {
			return {
				type: "entries",
				name: this.constructor._getLairActionName(ent[0]),
				entries: ent,
			};
		}

				return {
			type: "entries",
			name: `Lair Actions`,
			entries: ent,
		};
	}

	async _pImportEntry_pFillItems_lairActions_addLairAction (mon, act, importOpts, dataBuilderOpts, entry) {
		const strEntries = JSON.stringify(entry);

		const {
			saveAbility,
			saveScaling,
			saveDc,
		} = this._getSavingThrowData(mon, dataBuilderOpts.getSheetPb(), dataBuilderOpts.spellAbility, strEntries);

		const damageTuples = [];
		let formula = "";
		if (typeof entry.entries[0] === "string") {
			const {damageTupleMetas} = DataConverter.getDamageTupleMetas(entry.entries[0], {summonSpellLevel: mon._summonedBySpell_level ?? mon.summonedBySpellLevel});
			const {damageParts, formula: formula_} = DataConverter.getDamagePartsAndOtherFormula(damageTupleMetas);
			damageTuples.push(...damageParts);
			formula = formula_;
		}

		const damageParts = this._getDamageTuplesWithMod(damageTuples);

				const img = await DataConverterCreature.pGetLairActionImage(mon, {name: "Lair Actions"}, dataBuilderOpts, {taskRunner: importOpts.taskRunner});

		await this._pImportEntry_pFillItems_pAddTextOnlyItem({
			mon,
			dataBuilderOpts,
			act,
			entry,
			opts_getItem: {
				activationType: "lair",
				activationCost: 1,
				img,
				saveAbility,
				saveDc,
				saveScaling,
				damageParts,
				formula,
			},
			prop: "lairActions",
		});
	}

	async _pImportEntry_pFillItems_pRegionalEffects (mon, act, importOpts, dataBuilderOpts) {
		if (!dataBuilderOpts.legendaryMeta?.regionalEffects) return;

		const regionalEntry = {
			type: "entries",
			name: "Regional Effects",
			entries: MiscUtil.copy(
				CreatureRenamer.getRenamedEntries(
					dataBuilderOpts.legendaryMeta.regionalEffects, mon._fvttRenameMeta,
				),
			),
		};

		const img = await DataConverterCreature.pGetLairActionImage(mon, regionalEntry, dataBuilderOpts, {taskRunner: importOpts.taskRunner});

		await this._pImportEntry_pFillItems_pAddTextOnlyItem({
			mon,
			dataBuilderOpts,
			act,
			entry: regionalEntry,
			opts_getItem: {
				img,
			},
			prop: "regionalEffects",
		});
	}

	async _pImportEntry_pFillItems_pVariants (mon, act, importOpts, dataBuilderOpts) {
		if (!Config.get("importCreature", "isImportVariantsAsFeatures")) return;

		const dragonVariants = Renderer.monster.dragonCasterVariant.getVariantEntries(mon);

		const allVariants = [
			...(dragonVariants || []),
			...(mon.variant || []),
		];

		if (!allVariants.length) return;

		for (const variant of allVariants) {
			const img = await DataConverterCreature.pGetVariantImage(mon, variant, dataBuilderOpts, {taskRunner: importOpts.taskRunner});

			await this._pImportEntry_pFillItems_pAddTextOnlyItem({
				mon,
				dataBuilderOpts,
				act,
				entry: variant,
				opts_getItem: {
					img,
				},
				prop: "variant",
			});
		}
	}

	async _pImportEntry_pFillItems_pResources (mon, act, dataBuilderOpts) {
		if (!mon.resource?.length) return;

		for (const res of mon.resource) {
			const foundryId = foundry.utils.randomID();

			dataBuilderOpts.resourceSheetItemMetas.push({foundryId, name: res.name});

			await this._pImportEntry_pFillItems_pAddTextOnlyItem({
				mon,
				dataBuilderOpts,
				act,
				entry: {
					name: res.name,
					entries: [
						`{@note This item is used to track this creature's "${res.name}" resource.}`,
					],
				},
				opts_getItem: {
					id: foundryId,
					img: "icons/commodities/materials/glass-orb-blue.webp",
					description: "",
					activationType: "special",
					usesValue: res.value,
					usesMax: `${res.value}`,
					usesPer: "charges",
				},
				foundryFlags: {
					[SharedConsts.MODULE_ID]: {
						dedupeId: `resource-${Util.Slugify.slugifyFast.call(res.name, {strict: true})}`,
					},
				},
			});
		}
	}

	_getFeatureResourceUsage (ent, dataBuilderOpts) {
		if (!dataBuilderOpts.resourceSheetItemMetas.length) return {};
		if (!ent.name) return {};

		const outCost = dataBuilderOpts.resourceSheetItemMetas
			.map(({name, foundryId}) => {
								const nameSingle = Parser.getSingletonUnit(name);

				const re = new RegExp(`\\(Cost (?<charges>\\d+) (?:${name.escapeRegexp()}|${nameSingle.escapeRegexp()})\\)`, "i");
				const m = re.exec(ent.name);
				if (!m) return;

				return {
					consumeType: "charges",
					consumeTarget: foundryId,
					consumeAmount: Number(m.groups.charges),
				};
			})
			.find(Boolean);
		if (outCost) return outCost;

		return {};
	}

	async _pImportEntry_pFillItems_pActions (mon, act, importOpts, dataBuilderOpts) {
		if (!mon.action) return;
		for (const action of mon.action) {
									const subActions = this._pImportEntry_pFillItems_getSubActions(action, dataBuilderOpts);

			let img = null;
			for (let i = 0; i < subActions.length; ++i) {
				const subAction = subActions[i];
				const result = await this._pImportEntry_pFillItems_pAction(mon, act, subAction, importOpts, dataBuilderOpts, {img});

								if (i === 0) img = result?.img;
			}
		}
	}

	_pImportEntry_pFillItems_getSubActions (action, monOpts) {
		if (!action.name || !action.entries) return [action];

		const actorId = monOpts?.actor?.id ?? monOpts?.actor?._id;

				if (this.constructor._isActionBreathWeapon(action)) {
			const out = [];

			const breathActionPrimaryId = foundry.utils.randomID();

			const breathActions = action.entries[1].items.map(li => {
				const cleanName = li.name.replace(/\.\s*$/, "");
				const itemName = `Breath Weapons: ${cleanName}`;

				return {
					_foundryId: foundry.utils.randomID(),
					name: itemName,
					_plut_cleanName: cleanName,
					entries: li.entry ? [li.entry] : li.entries,
					_foundryData: {
						"consume.type": "charges",
						"consume.amount": 1,
						"consume.target": breathActionPrimaryId,
					},
				};
			});

			const breathActionPrimary = {
				_foundryId: breathActionPrimaryId,
				name: action.name,
				entries: [
					`${action.entries[0].trim().replace(/[.,!?:]$/, "")}: ${breathActions.map(it => actorId ? `@UUID[Actor.${actorId}.Item.${it._foundryId}]{${it._plut_cleanName}}` : it._plut_cleanName).joinConjunct(", ", " or ")}`,
				],
			};
			out.push(breathActionPrimary);

			breathActions.forEach(it => delete it._plut_cleanName);
			out.push(...breathActions);

			return out;
		}
		
				if (
			this.constructor._isActionEyeRay(action)
			|| this.constructor._isActionOtherChooseOneOrRandom(action)
		) {
			const out = [];

			const cpy = MiscUtil.copy(action);
			const ixList = action.entries.findIndex(it => it.type === "list" && this.constructor._isOptionsList(it));
			const lst = MiscUtil.copy(action.entries[ixList]);
			out.push(cpy);

			const nxtList = [];
			cpy.entries[ixList] = {
				type: "list",
				items: nxtList,
			};

			const ptParentNameClean = cpy.name.split(/[.,!:?({]/)[0];

			lst.items.forEach(it => {
				const ptNameClean = it.name.replace(/[.,!:?]\\s*$/, "");
				const entSub = {
					...it,
					_foundryId: foundry.utils.randomID(),
					type: "entries",
					name: `${ptParentNameClean}: ${ptNameClean}`,
				};

				if (entSub.entry) {
					entSub.entries = [entSub.entry];
					delete entSub.entry;
				}

				delete entSub.style;

				out.push(entSub);
				nxtList.push(actorId ? `@UUID[Actor.${actorId}.Item.${entSub._foundryId}]{${ptNameClean}}` : ptNameClean);
			});

			return out;
		}
		
				if (this.constructor._isActionMeleeOrRangedAttack(action)) {
			const cpyMelee = MiscUtil.copy(action);
			const cpyRanged = MiscUtil.copy(action);

			cpyMelee.name = `${cpyMelee.name} (Melee)`;
			cpyMelee.entries[0] = cpyMelee.entries[0]
				.replace(/{@atk (m[ws]),r[ws]}/, (...m) => `{@atk ${m[1]}}`)
				.replace(/((?:reach|range) \d+ ft\.) or range \d+(?:\/\d+)? ft\./, (...m) => m[1]);

			cpyRanged.name = `${cpyRanged.name} (Ranged)`;
			cpyRanged.entries[0] = cpyRanged.entries[0]
				.replace(/{@atk m[ws],(r[ws])}/, (...m) => `{@atk ${m[1]}}`)
				.replace(/(?:reach|range) \d+ ft\. or (range \d+(?:\/\d+)? ft\.)/, (...m) => m[1]);

			const actionsCondDamageMelee = this.constructor._getActionsConditionalDamageAttack(cpyMelee);
			const actionsCondDamageRanged = this.constructor._getActionsConditionalDamageAttack(cpyRanged);

			return [
				...(actionsCondDamageMelee || [cpyMelee]),
				...(actionsCondDamageRanged || [cpyRanged]),
			];
		}
		
				const actionsCondDamage = this.constructor._getActionsConditionalDamageAttack(action);
		if (actionsCondDamage) return actionsCondDamage;
		
		return [action];
	}

	static _isActionBreathWeapon (action) {
		return action.entries.length === 2
			&& typeof action.entries[0] === "string"
			&& action.entries[0].includes("following breath weapon")
			&& action.entries[1].type === "list"
			&& action.entries[1].items.every(li => li.name && (li.entry || li.entries));
	}

	static _isActionEyeRay (action) {
		return /^eye ray/gi.test(action.name) && action.entries.find(it => it.type === "list" && (it.items || []).every(li => li.type === "item"));
	}

	static _isActionOtherChooseOneOrRandom (action) {
				if (
			action.entries.length !== 2
			|| typeof action.entries[0] !== "string"
			|| action.entries[1].type !== "list"
		) return false;

		if (
			!/\bthe following\b/.test(action.entries[0])
			&& !/\bchoose one\b/.test(action.entries[0])
			&& !/\b(?:at|one) random\b/.test(action.entries[0])
		) return false;

		return this._isOptionsList(action.entries[1]);
	}

	static _isOptionsList (entry) {
		return entry?.items?.length && entry.items.every(li => li.name);
	}

	static _isActionMeleeOrRangedAttack (action) {
		if (!Config.get("importCreature", "isSplitMeleeRangedAttack")) return false;

		if (
			!action.entries.length
			|| typeof action.entries[0] !== "string"
		) return false;

		return /{@atk m[ws],r[ws]}/.test(action.entries[0])
			&& /(?:reach|range) \d+ ft\. or range \d+(?:\/\d+)? ft\./.test(action.entries[0]);
	}

	static _getActionsConditionalDamageAttack (action) {
		if (!Config.get("importCreature", "isSplitConditionalDamageAttack")) return null;

				const fromConditional = this._getActionsConditionalDamageAttack_conditional(action);
		const fromConditionalIfAdvantage = this._getActionsConditionalDamageAttack_conditionalIfAdvantage(action);
		const fromSwarm = this._getActionsConditionalDamageAttack_swarm(action);

		const out = [
			...(fromConditional || []),
			...(fromConditionalIfAdvantage || []),
			...(fromSwarm || []),
		];

		if (!out.length) return null;
		return out;
	}

	static _getActionsConditionalDamageAttack_conditional (action) {
		if (
			!action.entries.length
			|| typeof action.entries[0] !== "string"
		) return null;

		const withoutExtra = action.entries[0].replace(/, plus \d+(?: \([^)]+\))?(?: [a-zA-Z]+)? damage if [^.!?]+\./i, "");
		if (withoutExtra === action.entries[0]) return null;

		const cpyWithout = MiscUtil.copy(action);
		cpyWithout.name = `${cpyWithout.name} (Base)`;
		cpyWithout.entries[0] = withoutExtra;

		const cpyWith = MiscUtil.copy(action);
		cpyWith.name = `${cpyWith.name} (Full)`;

		return [cpyWithout, cpyWith];
	}

		static _getActionsConditionalDamageAttack_conditionalIfAdvantage (action) {
		if (
			!action.entries.length
			|| typeof action.entries[0] !== "string"
		) return null;

		const withoutExtra = action.entries[0].replace(/\. If the [^.]*? has advantage on the attack roll, the attack deals an extra \d+(?: \([^)]+\))?(?: [a-zA-Z]+)? damage\./i, ".");
		if (withoutExtra === action.entries[0]) return null;

		const cpyWithout = MiscUtil.copy(action);
		cpyWithout.name = `${cpyWithout.name} (Base)`;
		cpyWithout.entries[0] = withoutExtra;

		const cpyWith = MiscUtil.copy(action);
		cpyWith.name = `${cpyWith.name} (Advantage)`;

		return [cpyWithout, cpyWith];
	}

	static _getActionsConditionalDamageAttack_swarm (action) {
		if (
			!action.entries.length
			|| typeof action.entries[0] !== "string"
		) return null;

		const atFullHp = action.entries[0].replace(/, or \d+(?: \([^)]+\))?(?: [a-zA-Z]+)? damage if the swarm has half of its hit points [^.!?]+\./i, "");
		if (atFullHp === action.entries[0]) return null;

		const atHalfHp = action.entries[0].replace(/\{@h}\d+(?: \([^)]+\))?(?: [a-zA-Z]+)? damage, or /i, "{@h}");
		if (atHalfHp === action.entries[0]) return null;

		const cpyFullHp = MiscUtil.copy(action);
		cpyFullHp.entries[0] = atFullHp;

		const cpyHalfHp = MiscUtil.copy(action);
		cpyHalfHp.name = `${cpyHalfHp.name} (Half Hit Points)`;
		cpyHalfHp.entries[0] = atHalfHp;

		return [cpyFullHp, cpyHalfHp];
	}

		async _pImportEntry_pFillItems_pAction (mon, act, action, importOpts, dataBuilderOpts, opts) {
		if (!action.entries?.length) return console.warn(...LGT, `${mon.name} (${mon.source}) action "${action?.name}" had no entries!`);

		const description = await DataConverter.pGetEntryDescription(action, {summonSpellLevel: mon._summonedBySpell_level ?? mon.summonedBySpellLevel});
		const strEntries = action.entries ? JSON.stringify(action.entries) : null;

		const {
			damageTuples,
			formula,
			offensiveAbility,
			isAttack,
			isRecharge,
			rangeShort,
			rangeLong,
			actionType,
			isProficient,
			attackBonus,
			_foundryData,
			foundrySystem,
			_foundryFlags,
			foundryFlags,
			img,
		} = await DataConverterCreature.pGetParsedAction(mon, action, dataBuilderOpts, {taskRunner: importOpts.taskRunner});

		const damageParts = [];
		damageParts.push(
			...this._getDamageTuplesWithMod(
				damageTuples,
				Renderer.monster.getSafeAbilityScore(mon, offensiveAbility),
			),
		);

				const {
			saveAbility,
			saveScaling,
			saveDc,
		} = this._getSavingThrowData(mon, dataBuilderOpts.getSheetPb(), dataBuilderOpts.spellAbility, strEntries);
		
				if (isAttack) {
			return this._pFillWeaponItem(
				mon,
				act,
				action,
				importOpts,
				dataBuilderOpts,
				{
					offensiveAbility,
					damageParts,
					formula,
					rangeShort,
					rangeLong,
					actionType,
					isProficient,
					description: this._getAttackDescription({mon, action, description}),
					saveAbility,
					saveDc,
					saveScaling,
					attackBonus,
					_foundryData,
					foundrySystem,
					_foundryFlags,
					foundryFlags,
					img: opts?.img ?? img,
					isMagical: (mon.traitTags || []).includes("Magic Weapons"),
					isRecharge,
				},
			);
		}

		return this._pImportEntry_pFillItems_pAddTextOnlyItem({
			mon,
			dataBuilderOpts,
			act,
			entry: action,
			opts_getItem: {
				activationType: "action",
				activationCost: 1,
				description,
				saveAbility,
				saveDc,
				saveScaling,
				damageParts,
				formula,
				attackBonus,
				_foundryData,
				foundrySystem,
				_foundryFlags,
				foundryFlags,
				img: opts?.img ?? img,
			},
			prop: "action",
		});
	}

	_getAttackDescription ({mon, action, description}) {
		if (!Config.get(this._configGroup, "isSecretWrapAttacks")) return description;

		const shortName = Renderer.monster.getShortName(mon, {isSentenceCase: true, isUseDisplayName: !!mon._fvttRenameMeta});

		const actionNameClean = Renderer.stripTags(action.name)
						.replace(/ \(Recharge.*\)/g, "")
						.replace(/ \(\d+\/.*\)/g, "")
			.toLowerCase()
		;

		return `<section class="secret py-1">${description}</section>
		<p>${shortName} attacks with ${mon.isNamedCreature ? "their" : "its"} ${actionNameClean}.</p>`;
	}

	_getSavingThrowData (mon, assumedMonProf, spellcastingAbil, strEntries) {
		const out = super._getSavingThrowData(strEntries);

		if (!out.isFoundParse || !assumedMonProf) return out;

		if (Config.get("importCreature", "isPreferFlatSavingThrows")) return out;

		const {saveDc} = out;

		const fromAbil = saveDc - assumedMonProf - 8;

				if (spellcastingAbil) {
			const mod = Parser.getAbilityModNumber(Renderer.monster.getSafeAbilityScore(mon, spellcastingAbil));
			if (mod === fromAbil) return {...out, saveScaling: spellcastingAbil};
		}

								for (const abil of ["cha", "wis", "int", "str", "dex", "con"]) {
			const mod = Parser.getAbilityModNumber(Renderer.monster.getSafeAbilityScore(mon, abil));
			if (mod === fromAbil) return {...out, saveScaling: abil};
		}

		return out;
	}

	_getDamageTuplesWithMod (damageTuples, abilityScore) {
		if (!damageTuples.length) return [];

		damageTuples = MiscUtil.copy(damageTuples);

		if (abilityScore) {
						damageTuples.forEach(dmgTuple => {
				const abMod = Parser.getAbilityModNumber(abilityScore);
				const mBonus = /(\d+d\d+\s*)([-+]\s*\d+)([ -+].*)?$/.exec(dmgTuple[0]);
				if (!mBonus) return;

				const fromAbil = Number(mBonus[2].replace(/\s*/g, ""));
				if (fromAbil === abMod) dmgTuple[0] = `${mBonus[1]} + @mod${mBonus[3] || ""}`;
			});
		}

		return damageTuples.filter(it => it.length);
	}

	static _getItemHashesFromAcItem (ac) {
		const out = []; 
		if (!ac.from || !ac.from.length) return out;

		ac.from.forEach(from => {
			const hashes = this._getItemHashesFromString(from);
			hashes.forEach(hash => {
				if (!out.includes(hash)) out.push(hash);
			});
		});

		return out;
	}

	static _getItemHashesFromString (str) {
		const out = []; 
		str.replace(/{@item ([^}]+)}/gi, (...m) => {
			const [name, source] = m[1].trim().toLowerCase().split("|");

			const hash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS]({
				name,
				source: source || Parser.SRC_DMG,
			});

			if (!out.includes(hash)) out.push(hash);
		});

		return [...out];
	}

	async _pImportEntry_pFillItems_pInventory (mon, act, importOpts, dataBuilderOpts) {
		const itemHashes = new Set();
		const itemHashesEquipped = new Set();

		(mon.ac || [])
			.forEach((ac, i) => {
				const acHashes = this.constructor._getItemHashesFromAcItem(ac);
				acHashes.forEach(hash => itemHashes.add(hash));
				if (i === 0 && !Config.get("importCreature", "isUseStaticAc")) acHashes.forEach(hash => itemHashesEquipped.add(hash)); 			});

		for (const itemHash of itemHashes) {
			const ixExistingItem = dataBuilderOpts.getExistingItemItemIndex(itemHash);
			if (~ixExistingItem) {
				dataBuilderOpts.chargesItemsIxs[itemHash] = ixExistingItem;
				continue;
			}

			const item = await DataLoader.pCacheAndGetHash(UrlUtil.PG_ITEMS, itemHash);
			if (!item) continue;

			await this._pImportEntry_pFillItems_pAddItem(mon, act, item, importOpts, dataBuilderOpts, {isEquipped: itemHashesEquipped.has(itemHash)});
		}

		for (const spellcasting of (mon.spellcasting || [])) {
			if (!spellcasting.chargesItem) continue;

			const {name, source} = DataUtil.generic.unpackUid(spellcasting.chargesItem, "spell");
			const itemHash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS]({name, source});

			const ixExistingItem = dataBuilderOpts.getExistingItemItemIndex(itemHash);
			if (~ixExistingItem) {
				dataBuilderOpts.chargesItemsIxs[itemHash] = ixExistingItem;
				continue;
			}

			const item = await DataLoader.pCacheAndGetHash(UrlUtil.PG_ITEMS, itemHash);
			if (!item) continue;

			dataBuilderOpts.chargesItemsIxs[itemHash] = dataBuilderOpts.items.length - 1;

			await this._pImportEntry_pFillItems_pAddItem(mon, act, item, importOpts, dataBuilderOpts, {isEquipped: true});
		}

				const itemHashesFromTraits = (mon.trait || [])
			.filter(it => it.name && it.entries && /equipment/i.test(it.name.trim()))
			.map(it => this.constructor._getItemHashesFromString(JSON.stringify(it.entries)))
			.flat()
			.filter(hash => !itemHashes.has(hash));
		for (const itemHash of itemHashesFromTraits) {
			const ixExistingItem = dataBuilderOpts.getExistingItemItemIndex(itemHash);
			if (~ixExistingItem) {
				continue;
			}

			const item = await DataLoader.pCacheAndGetHash(UrlUtil.PG_ITEMS, itemHash);
			if (!item) continue;

						if (item.type === "S" || item.type === "R" || item.weaponCategory) continue;

			await this._pImportEntry_pFillItems_pAddItem(mon, act, item, importOpts, dataBuilderOpts, {isEquipped: true});
		}
	}

		async _pImportEntry_pFillItems_pAddItem (mon, act, item, importOpts, dataBuilderOpts, opts) {
		opts = opts || {};

		const fluff = await Renderer.item.pGetFluff(item);
		const itemData = await DataConverterItem.pGetDocumentJson(
			item,
			{
				isActorItem: true,
				fluff,
				size: dataBuilderOpts.size,
				isEquipped: opts.isEquipped,
				dexMod: Parser.getAbilityModNumber(Renderer.monster.getSafeAbilityScore(mon, "dex")),
				isInfiniteAmmo: true,
				taskRunner: importOpts.taskRunner,
			},
		);

		dataBuilderOpts.items.push(itemData);
	}

	async _pImportEntry_pFillItems_pSpellcasting (mon, act, isTemporary, importOpts, dataBuilderOpts) {
		if (!mon.spellcasting) return;

		const importListSpells = new ImportListSpell({actor: dataBuilderOpts.actor});
		await importListSpells.pInit();

		const hashToIdMap = {};

				const isPrepared = true;

		const spellcastingsUnknownProps = [];
		for (const spellcasting of mon.spellcasting) {
			const cpySpellcasting = MiscUtil.copy(spellcasting);

									delete cpySpellcasting.name;
			delete cpySpellcasting.type;
			delete cpySpellcasting.page;
			delete cpySpellcasting.id;
			delete cpySpellcasting.source;
			delete cpySpellcasting.data;

						delete cpySpellcasting.headerEntries;
			delete cpySpellcasting.hidden;
			delete cpySpellcasting.footerEntries;
			delete cpySpellcasting.displayAs;
			
						if (cpySpellcasting.spells) {
				const spellLevels = Object.keys(cpySpellcasting.spells);

				for (const spellLevel of spellLevels) {
					const levelMeta = cpySpellcasting.spells[spellLevel];

					const preparationMode = levelMeta.lower != null ? "pact" : "prepared";

					await this.constructor._pGetSpellHashToItemPosMapAndFillSpells(
						dataBuilderOpts.actor,
						JSON.stringify(levelMeta.spells),
						{
							taskRunner: importOpts.taskRunner,
							importListSpells,
							hashToIdMap,
							isTemporary,
							optsGetSpellItem: {
								ability: cpySpellcasting.ability || dataBuilderOpts.spellAbility,
								isPrepared,
								preparationMode,
							},
						},
					);
				}

				delete cpySpellcasting.spells;
			}
			
						if (cpySpellcasting.weekly) {
				await this._pImportEntry_pFillItems_pSpellcasting_recharge(
					dataBuilderOpts,
					cpySpellcasting,
					"weekly",
					{
						importOpts,
						importListSpells,
						hashToIdMap,
						isTemporary,
						isPrepared,
						usesPer: "charges", 					},
				);
			}

			if (cpySpellcasting.yearly) {
				await this._pImportEntry_pFillItems_pSpellcasting_recharge(
					dataBuilderOpts,
					cpySpellcasting,
					"yearly",
					{
						importOpts,
						importListSpells,
						hashToIdMap,
						isTemporary,
						isPrepared,
						usesPer: "charges", 					},
				);
			}

			if (cpySpellcasting.daily) {
				await this._pImportEntry_pFillItems_pSpellcasting_recharge(
					dataBuilderOpts,
					cpySpellcasting,
					"daily",
					{
						importOpts,
						importListSpells,
						hashToIdMap,
						isTemporary,
						isPrepared,
						usesPer: "day",
					},
				);
			}

			if (cpySpellcasting.rest) {
				await this._pImportEntry_pFillItems_pSpellcasting_recharge(
					dataBuilderOpts,
					cpySpellcasting,
					"daily",
					{
						importOpts,
						importListSpells,
						hashToIdMap,
						isTemporary,
						isPrepared,
						usesPer: "sr", 					},
				);
			}

			if (cpySpellcasting.charges) {
				const consumeTarget = this._getChargesSheetItem(cpySpellcasting, dataBuilderOpts);

				await this._pImportEntry_pFillItems_pSpellcasting_recharge(
					dataBuilderOpts,
					cpySpellcasting,
					"charges",
					{
						importOpts,
						importListSpells,
						hashToIdMap,
						isTemporary,
						isPrepared,
						preparationMode: "atwill",
						consumeType: "charges",
						consumeTarget,
						isConsumeAmount: true,
					},
				);

				delete cpySpellcasting.chargesItem;
				delete cpySpellcasting.charges;
			}

			if (cpySpellcasting.will) {
				await this.constructor._pGetSpellHashToItemPosMapAndFillSpells(
					dataBuilderOpts.actor,
					JSON.stringify(cpySpellcasting.will),
					{
						taskRunner: importOpts.taskRunner,
						importListSpells,
						hashToIdMap,
						isTemporary,
						optsGetSpellItem: {
							ability: cpySpellcasting.ability || dataBuilderOpts.spellAbility,
							isPrepared,
							preparationMode: "innate",
						},
					},
				);

				delete cpySpellcasting.will;
			}

			if (cpySpellcasting.constant) {
				await this.constructor._pGetSpellHashToItemPosMapAndFillSpells(
					dataBuilderOpts.actor,
					JSON.stringify(cpySpellcasting.constant),
					{
						taskRunner: importOpts.taskRunner,
						importListSpells,
						hashToIdMap,
						isTemporary,
						optsGetSpellItem: {
							ability: cpySpellcasting.ability || dataBuilderOpts.spellAbility,
							isPrepared,
							preparationMode: "innate",
														durationValue: null,
							durationUnit: "perm",
						},
					},
				);

				delete cpySpellcasting.constant;
			}

			if (cpySpellcasting.ritual) {
				await this.constructor._pGetSpellHashToItemPosMapAndFillSpells(
					dataBuilderOpts.actor,
					JSON.stringify(cpySpellcasting.ritual),
					{
						taskRunner: importOpts.taskRunner,
						importListSpells,
						hashToIdMap,
						isTemporary,
						optsGetSpellItem: {
							ability: cpySpellcasting.ability || dataBuilderOpts.spellAbility,
							isPrepared: false, 							preparationMode: "innate",
							nameSuffix: " (R)", 						},
					},
				);

				delete cpySpellcasting.ritual;
			}
			
			const remainingKeys = Object.keys(cpySpellcasting).filter(it => it !== "ability");
			if (remainingKeys.length) {
				console.warn(...LGT, `No handling defined for the following spellcasting properties: ${remainingKeys.map(it => `"${it}"`).join(", ")}. Spells belonging to these properties will be imported as generic "spell list" spells.`);
				spellcastingsUnknownProps.push(cpySpellcasting);
			}
		}

				for (const spellcastingUnknownProps of spellcastingsUnknownProps) {
			await this.constructor._pGetSpellHashToItemPosMapAndFillSpells(
				dataBuilderOpts.actor,
				JSON.stringify(spellcastingUnknownProps),
				{
					taskRunner: importOpts.taskRunner,
					importListSpells,
					hashToIdMap,
					isTemporary,
					optsGetSpellItem: {
						ability: spellcastingUnknownProps.ability || dataBuilderOpts.spellAbility,
					},
				},
			);
		}

				const tagHashItemIdMap = {};
		Object.entries(hashToIdMap)
			.forEach(([hash, id]) => MiscUtil.set(tagHashItemIdMap, "spell", hash, id));

		await UtilDataConverter.pGetWithDescriptionPlugins(
			async () => {
				const traits = [
					...Renderer.monster.getSpellcastingRenderedTraits(Renderer.get(), mon),
					...Renderer.monster.getSpellcastingRenderedTraits(Renderer.get(), mon, "action"),
				];
				for (const trait of traits) {
					const img = await DataConverterCreature.pGetSpellcastingImage(mon, trait, dataBuilderOpts, {taskRunner: importOpts.taskRunner});
					await this._pImportEntry_pFillItems_pAddTextOnlyItem({
						mon,
						dataBuilderOpts,
						act,
						entry: trait,
						opts_getItem: {
							img,
							description: trait.rendered,
						},
						prop: "spellcasting",
					});
				}
			},
			{
				actorId: dataBuilderOpts.actor.id,
				tagHashItemIdMap,
			},
		);
			}

	_getChargesSheetItem (spellcasting, dataBuilderOpts) {
		if (!spellcasting.chargesItem) return null;

		const {name, source} = DataUtil.generic.unpackUid(spellcasting.chargesItem, "spell");
		const itemHash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS]({name, source});

		const ix = dataBuilderOpts.chargesItemsIxs[itemHash];
		if (ix == null) return;

		const sheetItem = dataBuilderOpts.importedSheetItems[Number(ix)];
		if (!sheetItem?.document) return null;

		return sheetItem.document.id ?? sheetItem.document._id;
	}

	async _pImportEntry_pFillItems_pSpellcasting_recharge (monOpts, cpySpellcasting, prop, {importOpts, importListSpells, hashToIdMap, isTemporary, isPrepared, usesPer = null, preparationMode = "innate", consumeType = null, isConsumeAmount = false, consumeTarget = null}) {
		for (let uses = 1; uses <= 9; ++uses) {
			const keyEach = `${uses}e`;

									const allSpells = [
				...((cpySpellcasting[prop] || {})[uses] || []),
				...((cpySpellcasting[prop] || {})[keyEach] || []),
			];

			if (!allSpells.length) continue;

			const optsGetSpellItem = {
				ability: cpySpellcasting.ability || monOpts.spellAbility,
				isPrepared,
				preparationMode,
				consumeType,
				consumeTarget,
				usesPer,
			};

			if (isConsumeAmount) {
				optsGetSpellItem.consumeAmount = uses;
			} else {
				optsGetSpellItem.usesValue = uses;
				optsGetSpellItem.usesMax = uses;
			}

			await this.constructor._pGetSpellHashToItemPosMapAndFillSpells(
				monOpts.actor,
				JSON.stringify(allSpells),
				{
					taskRunner: importOpts.taskRunner,
					importListSpells,
					hashToIdMap,
					isTemporary,
					optsGetSpellItem,
				},
			);
		}

		delete cpySpellcasting[prop];
	}

	static _getCasterLevelFromEntry (casting) {
		let casterLevel = 0;
		if (casting.headerEntries) {
			JSON.stringify(casting.headerEntries).replace(/an? (\d+)[A-Za-z]+-level/i, (...m) => {
				const lvl = Number(m[1]);
				if (!isNaN(lvl)) casterLevel = lvl;
			});
		}
		return casterLevel;
	}

	static _getCasterClassFromEntry (casting) {
		let casterClass = "";
		if (casting.headerEntries) {
			JSON.stringify(casting.headerEntries).replace(/(?:^| )(artificer|bard|cleric|druid|paladin|ranger|sorcerer|warlock|wizard)(?:\W|$)?/i, (...m) => {
				casterClass = m[1].toLowerCase().trim();
			});
		}
		return casterClass;
	}

	static _getCasterProgressionFromEntry (casting, level, spellClass) {
		if (casting.spells) {
			if (Object.values(casting.spells).some(byLevel => byLevel.lower != null)) return "pact";

			const maxSpellLevel = Math.max(...Object.keys(casting.spells).map(it => Number(it)));
			if (!maxSpellLevel) return null;

						const casterTypeVe = Object.entries(UtilDataConverter.CASTER_TYPE_TO_PROGRESSION)
				.filter(([casterType]) => casterType !== "pact")
								.sort(([casterTypeA], [casterTypeB]) => {
					if (spellClass !== "artificer") return Number(casterTypeB !== "artificer") - Number(casterTypeA !== "artificer");
					return Number(casterTypeA !== "artificer") - Number(casterTypeB !== "artificer");
				})
				.find(([, progressions]) => {
					const progression = progressions[level - 1];
					if (!progression) return false; 
										if (progression[maxSpellLevel - 1] && !progression[maxSpellLevel]) return true;
				})?.[0];

			if (!casterTypeVe) return null;
			return UtilActors.getMappedCasterType(casterTypeVe);
		}

		return null;
	}

			static async _pGetSpellHashToItemPosMapAndFillSpells (actor, strEntries, {taskRunner, importListSpells, hashToIdMap, isTemporary, optsGetSpellItem} = {}) {
		const spellUids = new Set();
		strEntries.replace(/{@spell ([^}]+)}/gi, (...m) => {
			let [name, source] = m[1].toLowerCase().trim().split("|").map(it => it.trim());
			if (!source) source = Parser.SRC_PHB.toLowerCase();

			spellUids.add(`${name}|${source}`);
		});

		for (const uid of spellUids) {
			const [name, source] = uid.split("|");
			const hash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_SPELLS]({name, source});

			let spell;
			try {
				spell = await DataLoader.pCacheAndGet(UrlUtil.PG_SPELLS, source, hash);
			} catch (e) {
				console.error(...LGT, `Failed to import spell with hash "${hash}"!`, e);
				continue;
			}

			if (!spell) continue;

			const opts_pGetSpellItem = {
				...(await UtilActors.pGetActorSpellItemOpts({actor})),
				...(optsGetSpellItem || {}),
			};
						if (spell.level === 0) opts_pGetSpellItem.preparationMode = "always";

			const importSummary = await importListSpells.pImportEntry(
				spell,
				{
					taskRunner,
					opts_pGetSpellItem,
				},
			);

			const id = importSummary.imported[0]?.embeddedDocument?.id;

			if (id == null) continue;
			if (hashToIdMap[hash]) continue; 			hashToIdMap[hash] = id;
		}
	}
	
	async _pImportEntry_pFillItems_pFakeClass (mon, act, dataBuilderOpts) {
		if (mon.foundryType !== "character") return;
		if (!Config.get(this._configGroup, "isAddFakeClassToCharacter")) return;

		const validLevelMetas = [...new Array(Consts.CHAR_MAX_LEVEL)]
			.map((_, i) => i + 1)
			.map(level => ({level, pb: Parser.levelToPb(level)}))
			.filter(it => it.pb === dataBuilderOpts.pb);

		const levels = Math.max(validLevelMetas[0]?.level || 0, dataBuilderOpts.spellLevel || 0);

		const classData = {
			name: "Creature",
			type: "class",
			system: {
				identifier: "creature",
				description: {
					value: await UtilDataConverter.pGetWithDescriptionPlugins(
						() => Renderer.get()
							.setFirstSection(true)
							.render(`{@note This is an auto-generated placeholder class, which provides the creature's proficiency bonus and spellcasting progression.}`),
					),
				},
				source: UtilDataConverter.getSourceWithPagePart(mon),
				levels: levels,
				spellcasting: {
					progression: dataBuilderOpts.spellcasterProgression,
					ability: dataBuilderOpts.spellAbility,
				},
			},
			img: "icons/magic/death/skull-trio-badge-purple.webp",
		};

		dataBuilderOpts.items.push(classData);
	}

	static _CREATURE_TYPE_TO_BLOOD_COLOR = {
		[Parser.TP_ABERRATION]: "#5f377a",
		[Parser.TP_CELESTIAL]: "#a3f4ff",
		[Parser.TP_CONSTRUCT]: "#8c6b4a",
		[Parser.TP_DRAGON]: "#4f0000",
		[Parser.TP_ELEMENTAL]: "#756879",
		[Parser.TP_FEY]: "#25278b",
		[Parser.TP_FIEND]: "#130710",
		[Parser.TP_GIANT]: "#751010",
		[Parser.TP_MONSTROSITY]: "#ff1000",
		[Parser.TP_OOZE]: "#7da793",
		[Parser.TP_PLANT]: "#403e10",
		[Parser.TP_UNDEAD]: "#c7b7a0",
	};

	_getTokenFlags ({mon}) {
		if (!UtilCompat.isMonksBloodsplatsActive()) return null;

		const bloodColor = this.constructor._CREATURE_TYPE_TO_BLOOD_COLOR[mon?.type];
		if (!bloodColor) return;

		return {
			[UtilCompat.MODULE_MONKS_BLOODSPLATS]: {
				"bloodsplat-colour": bloodColor,
			},
		};
	}
}

ImportListCreature._CREATURE_TYPES = null;

ImportListCreature.ImportEntryOpts = class extends ImportListActor.ImportEntryOpts {
	constructor (opts) {
		opts = opts || {};
		super({
			pb: Parser.crToPb(opts.mon.cr),
			...opts,
		});
		this.mon = opts.mon;

		this.legendaryMeta = DataUtil.monster.getMetaGroup(this.mon);

		this.spellAbility = "";
		this.spellDc = 8;
		this.spellLevel = 0;
		this.spellClass = "";
		this.spellcasterProgression = null;
		this._initSpellcasterData(this.mon);

		this.size = null;
		this._initSize(this.mon);

		this.resourceSheetItemMetas = [];

		this.chargesItemsIxs = {};
		this.importedSheetItems = [];
	}

		_initSize (mon) {
		if (!mon.size) return this.size = Parser.SZ_MEDIUM;

				if (typeof mon.size === "string") return this.size = mon.size;

		if (!(mon.size instanceof Array)) return this.size = Parser.SZ_MEDIUM;
		if (mon.size.length === 1) return this.size = mon.size[0];

				if (mon.size.includes(Parser.SZ_MEDIUM)) return this.size = Parser.SZ_MEDIUM;

				this.size = [...mon.size].sort(SortUtil.ascSortSize)[0];
	}

	_initSpellcasterData (mon) {
		if (!mon.spellcasting) return;

		const withAbils = mon.spellcasting
			.filter(it => it.ability)
			.map(it => {
				if (Parser.ABIL_ABVS.includes(it.ability)) return it;

								const abv = it.ability.substring(0, 3);
				if (Parser.ABIL_ABVS.includes(abv)) {
					it.ability = abv;
					return it;
				}

				return null;
			})
			.filter(Boolean);

		if (withAbils.length) {
			let withAbil = withAbils[0];

									if (withAbils.length > 1) {
				switch (Config.get("importCreature", "spellcastingPrimaryTraitMode")) {
										case 1: {
						withAbil = withAbils.sort((a, b) => {
							const spellCountA = this.constructor._getSpellCount(a);
							const spellCountB = this.constructor._getSpellCount(b);
							return SortUtil.ascSort(spellCountB, spellCountA);
						})[0];

						break;
					}

										case 2: {
						withAbil = withAbils.sort((a, b) => SortUtil.ascSort(Renderer.monster.getSafeAbilityScore(mon, b.ability), Renderer.monster.getSafeAbilityScore(mon, a.ability)))[0];

						break;
					}
				}
			}

			const ab = withAbil.ability;
			const abMod = Parser.getAbilityModNumber(Renderer.monster.getSafeAbilityScore(mon, ab));

			this.spellAbility = ab;
			this.spellDc = abMod + this.pb;
		}

		this.spellLevel = mon.spellcasting.map(sc => ImportListCreature._getCasterLevelFromEntry(sc)).find(Boolean) || 0;
		this.spellClass = mon.spellcasting.map(sc => ImportListCreature._getCasterClassFromEntry(sc)).find(Boolean) || "";
		this.spellcasterProgression = mon.spellcasting.map(sc => ImportListCreature._getCasterProgressionFromEntry(sc, this.spellLevel, this.spellClass)).find(Boolean) || null;
	}

	static _getSpellCount (spellcastingItem) {
						let cnt = 0;
		JSON.stringify(spellcastingItem).replace(/{@spell [^}]+}/g, () => {
			cnt++;
			return "";
		});
		return cnt;
	}

	getExistingItemItemIndex (itemHash) {
		return this.items.findIndex(it => {
			if (!it?.flags?.[SharedConsts.MODULE_ID]) return false;
			return it.flags[SharedConsts.MODULE_ID].page === UrlUtil.PG_ITEMS
				&& it.flags[SharedConsts.MODULE_ID].hash === itemHash;
		});
	}
};

var ImportListCreature$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ImportListCreature: ImportListCreature
});

class CustomizerStateItem extends CustomizerStateBase {
	fvttType = null;

	setFvttType (val) { this.fvttType = val; return this; }
}

class ImportCustomizerItem extends ImportCustomizerBase {
		constructor (dataList, resolve, opts) {
		super(
			dataList,
			resolve,
			{
				...opts,
				title: "Customize Import",
				template: `${SharedConsts.MODULE_LOCATION}/template/ImportListItemCustomizer.hbs`,
			},
		);
	}

	
	_getData_row ({ent, ix}) {
		return {
			...super._getData_row({ent, ix}),

						foundryTypes: DataConverterItem.VALID_FOUNDRY_ITEM_TYPES_IMPORT.map((it, ix) => ({
				ix,
				type: it,
				displayName: game.i18n.localize(`ITEM.Type${it.capitalize()}`),
			})),
		};
	}

	
	_getListItemData ({li}) {
		const $e = $(li.ele);
		return {
			$selFoundryType: $e.find(`[name="sel-foundry-type"]`),
		};
	}

	
	async _pGetCustomizerState ({li, ent, state = null}) {
		return (state || new CustomizerStateItem())
			.setFvttType(this._pGetCustomizerState_fvttType({li, ent}));
	}

	_pGetCustomizerState_fvttType ({li, ent}) {
		const ixType = Number(li.data.$selFoundryType.val());
		if (!~ixType) return null;

		return {
			foundryType: DataConverterItem.VALID_FOUNDRY_ITEM_TYPES_IMPORT[ixType],
		};
	}

	
	static async _pGetAppliedCustomizations ({ent}) {
		ent = this._pGetAppliedCustomizations_fvttType({ent});
		return ent;
	}

	static _pGetAppliedCustomizations_fvttType ({ent}) {
		const foundryType = ent._fvttCustomizerState?.fvttType?.foundryType;
		if (foundryType == null) return ent;
		ent.foundryType = foundryType;
		return ent;
	}
}

class ImportListItem extends ImportList {
		static init () {
		this._initCreateSheetItemHook({
			prop: "item",
			importerName: "Item",
		});

		this._initCreateSheetItemHook_currency();
	}
	
	static get ID () { return "items"; }
	static get DISPLAY_NAME_TYPE_PLURAL () { return "Items"; }
	static get PROPS () { return ["item"]; }

	static _ = this.registerImpl(this);

	_dirsHomebrew = ["item", "baseitem", "magicvariant"];
	_titleSearch = "item";
	_sidebarTab = "items";
	_gameProp = "items";
	_defaultFolderPath = ["Items"];
	_pageFilter = new PageFilterItems({
		filterOpts: {
			"Category": {
				deselFn: (it) => it === "Generic Variant",
			},
		},
	});
	_page = UrlUtil.PG_ITEMS;
	_isPreviewable = true;
	_isDedupable = true;
	_configGroup = "importItem";
	_namespace = "item";
	_fnListSort = PageFilterItems.sortItems;
	_pFnGetFluff = Renderer.item.pGetFluff.bind(Renderer.item);
	_ClsCustomizer = ImportCustomizerItem;
	static _DataConverter = DataConverterItem;

	async _pGetSources () {
		const prereleaseOpts = {pPostLoad: async json => ({item: await Vetools.pGetPrereleaseItems(json)})};
		const brewOpts = {pPostLoad: async json => ({item: await Vetools.pGetBrewItems(json)})};

		return [
			new UtilDataSource.DataSourceSpecial(
				Config.get("ui", "isStreamerMode") ? "SRD" : "5etools",
				() => Vetools.pGetItems(),
				{
					cacheKey: "5etools-items",
					filterTypes: [UtilDataSource.SOURCE_TYP_OFFICIAL_ALL],
					isDefault: true,
				},
			),
			...UtilDataSource.getSourcesCustomUrl({...brewOpts}),
			...UtilDataSource.getSourcesUploadFile({...brewOpts}),
			...(await this._pGetSourcesPrerelease(prereleaseOpts)),
			...(await this._pGetSourcesBrew(brewOpts)),
		];
	}

	_colWidthName = 3;
	_colWidthSource = 1;

	_getData_cols_other () {
		return [
			{
				name: "Type",
				width: "3-2",
				field: "type",
			},
			{
				name: "Cost",
				width: "1-4",
				field: "cost",
				rowClassName: "text-center",
			},
			{
				name: "Weight",
				width: "1-4",
				field: "weight",
				rowClassName: "text-center",
			},
			{
				name: "A.",
				width: "0-5",
				field: "attunement",
				rowClassName: "text-center",
			},
			{
				name: "Rarity",
				width: "1-5",
				field: "rarity",
				rowClassName: "text-center",
			},
		];
	}

	_getData_row_mutGetAdditionalValues ({it, ix}) {
				it._vType = it._typeListText.join(", ").uppercaseFirst();
		
		return {
			type: it._vType,
			cost: it.value || it.valueMult ? Parser.itemValueToFull(it, {isShortForm: true}).replace(/ +/g, "\u00A0") : "\u2014",
			weight: Parser.itemWeightToFull(it, true) || "\u2014",
			rarity: (it.rarity || "Unknown").toTitleCase(),
			attunement: it._attunementCategory === "No" ? "" : "×",
		};
	}

	getData () {
		return {
			...super.getData(),
			buttonsAdditional: [
				{
					name: "btn-run-mods",
					text: "Customize and Import...",
				},
			],
		};
	}

	_renderInner_absorbListItems_fnGetValues (it) {
		return {
			...super._renderInner_absorbListItems_fnGetValues(it),
			type: it._vType,
			cost: it.value || 0,
			rarity: it.rarity,
			attunement: it._attunementCategory !== "No",
			weight: Parser.weightValueToNumber(it.weight),
		};
	}

	async pInit () {
		if (await super.pInit()) return true;

		await Renderer.item.pPopulatePropertyAndTypeReference();
	}

	getFolderPathMeta () {
		return {
			...super.getFolderPathMeta(),
			rarity: {
				label: "Rarity",
				getter: it => ((!it.rarity || it.rarity === "Unknown") ? "Unknown Rarity" : it.rarity).toTitleCase(),
			},
			type: {
				label: "Type",
				getter: it => {
					if (it.type) return Renderer.item.getItemTypeName(it.type).toTitleCase();
					else if (it.typeText) return it.typeText;
					else if (it.wondrous) return "Wondrous Item";
					else if (it.poison) return "Poison";
					else return "Unknown Type";
				},
			},
		};
	}

	async _pImportEntry_preImport ({ent, importOpts, dataOpts}) {
		await this._pImportEntry_pDoLoadPrereleaseMeta(ent);
		await this._pImportEntry_pDoLoadBrewMeta(ent);
	}

	async _pImportEntry_pDoLoadPrereleaseMeta (item) {
		return this._pImportEntry_pDoLoadPrereleaseBrewMeta({item, brewUtil: PrereleaseUtil, sourceIndex: Vetools.PRERELEASE_INDEX__SOURCE, configKey: "basePrereleaseUrl"});
	}

	async _pImportEntry_pDoLoadBrewMeta (item) {
		return this._pImportEntry_pDoLoadPrereleaseBrewMeta({item, brewUtil: BrewUtil2, sourceIndex: Vetools.BREW_INDEX__SOURCE, configKey: "baseBrewUrl"});
	}

		async _pImportEntry_pDoLoadPrereleaseBrewMeta ({item, brewUtil, sourceIndex, configKey}) {
		if (brewUtil.hasSourceJson(item.source)) return;
		if (SourceUtil.isSiteSource(item.source)) return;

		if (!sourceIndex[item.source]) return;
		const url = DataUtil.brew.getFileUrl(sourceIndex[item.source], Config.get("import", configKey));
		await brewUtil.pAddBrewFromUrl(url);

				await Renderer.item.pGetSiteUnresolvedRefItemsFromPrereleaseBrew({brewUtil, brew: await DataUtil.loadJSON(url)});
	}

	async _pImportEntry_pImportToDataOnly (item, importOpts, opts) {
		if (!this._actor || !this._isPackSplitImport(item)) return [await DataConverterItem.pGetDocumentJson(item, {taskRunner: importOpts.taskRunner})];
		const packItemsMetas = await this._pGetPackItemMetas(item, importOpts, opts);
		return packItemsMetas.map(({itemData}) => itemData);
	}

	_isPackSplitImport (item) {
		return item.packContents
			&& Config.get(this._configGroup, "isSplitPacksActor")
			&& (!item.atomicPackContents || Config.get(this._configGroup, "isSplitAtomicPacksActor"));
	}

	async _pImportEntry_pImportToActor (item, importOpts, opts) {
		opts = {...opts, isActorItem: true};

		opts.filterValues = importOpts.filterValues;

				opts.sheetItemsAmmo = this._pImportEntry_getSheetItemsAmmo(item);

		let embeddedDocuments;
		if (this._isPackSplitImport(item)) {
			embeddedDocuments = await this._pImportEntry_pImportToActor_pImportPackItem(item, importOpts, opts);
		} else {
			const itemData = await DataConverterItem.pGetDocumentJson(item, {...opts, ability: this._getAbilityScoreOverride_actorClass(item), taskRunner: importOpts.taskRunner});
			const embeddedDocument = await this._pImportEntry_pImportToActor_pAddItem({item, itemData});
			embeddedDocuments = [embeddedDocument];
		}

		if (this._actor.isToken) this._actor.sheet.render();

		return new ImportSummary({
			status: ConstsTaskRunner.TASK_EXIT_COMPLETE,
			imported: embeddedDocuments.map(it => new ImportedDocument({
				name: item.name,
				actor: this._actor,
				embeddedDocument: it,
			})),
		});
	}

	static _RE_ABILITY_SCORE_OVERRIDE_ACTOR_CLASS = /^(?<idClass>[^:]+):(?<nameItem>.*?):(?<ability>str|dex|con|int|wis|cha)$/i;

	_getAbilityScoreOverride_actorClass (item) {
		if (!this._actor) return null;

		const classKeys = new Set(Object.keys(this._actor.classes || {}));
		if (!classKeys.size) return null;

		const raw = Config.get("importItem", "altAbilityScoreByClass");
		if (!raw.length) return null;

		return raw
			.map(it => this.constructor._RE_ABILITY_SCORE_OVERRIDE_ACTOR_CLASS.exec(it))
			.filter(Boolean)
			.map(m => ({
				identifierCls: m.groups.idClass.toLowerCase().trim(),
				name: m.groups.nameItem.toLowerCase().trim(),
				ability: m.groups.ability,
			}))
			.filter(({identifierCls}) => classKeys.has(identifierCls))
			.mergeMap(({name, ability}) => ({[name]: ability}))[item.name.toLowerCase()];
	}

	async _pGetPackItemMetas (item, importOpts, opts) {
		const packErrors = [];

		const packContentsItems = await Promise.all(item.packContents.map(async it => {
			const quantity = it.quantity || 1;
			if (it.item || typeof it === "string") {
				let [name, source] = (it.item || it).split("|");
				if (!source) source = Parser.SRC_DMG;
				const hash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS]({name, source});

				const packItem = await DataLoader.pCacheAndGet(UrlUtil.PG_ITEMS, source, hash);

				return {
					item: packItem,
					itemData: await DataConverterItem.pGetDocumentJson(packItem, {filterValues: importOpts.filterValues, ...opts, quantity, ability: this._getAbilityScoreOverride_actorClass(item), taskRunner: importOpts.taskRunner}),
				};
			} else if (it.special) {
				const fauxItem = {
					name: it.special.toTitleCase(),
					type: "G",
					source: item.source,
					page: item.page,
					srd: item.srd,
				};
				Renderer.item.enhanceItem(fauxItem);

				return {
					item: fauxItem,
					itemData: await DataConverterItem.pGetDocumentJson(fauxItem, {filterValues: importOpts.filterValues, ...opts, quantity, ability: this._getAbilityScoreOverride_actorClass(item), taskRunner: importOpts.taskRunner}),
				};
			} else {
				packErrors.push(`Unhandled pack contents type "${JSON.stringify(it)}"`);
			}
		}));

		if (packErrors.length) {
			ui.notifications.error(`Item "${item.name}" (from "${Parser.sourceJsonToAbv(item.source)}") could not be broken down into constituent items! ${VeCt.STR_SEE_CONSOLE}`);
			console.error(...LGT, `Error(s) when breaking ${item.name} (${item.source}) into constituent items: ${packErrors.join("; ")}`);
		}

		return packContentsItems.filter(Boolean);
	}

	async _pImportEntry_pImportToActor_pImportPackItem (item, importOpts, opts) {
		const packItemMetas = await this._pGetPackItemMetas(item, importOpts, opts);

				return packItemMetas.pSerialAwaitMap(({item, itemData}) => this._pImportEntry_pImportToActor_pAddItem({item, itemData}));
	}

	async _pImportEntry_pImportToActor_pAddItem ({item, itemData}) {
		const embeddedDocument = await this._pImportEntry_pImportToActor_pAddOrUpdateItem({item, itemData});
		return this._pImportEntry_pImportToActor_pUpdateItemPostAdd({itemData, embeddedDocument});
	}

	async _pImportEntry_pImportToActor_pAddOrUpdateItem ({item, itemData}) {
		const existingItem = this._pImportEntry_pImportToActor_getExistingStackableItem({item, itemData});
		if (!existingItem) {
			return (await UtilActors.pAddActorItems(this._actor, [itemData]))[0].document;
		}

		const update = {
			_id: existingItem.id,
			system: {
				quantity: (existingItem.system.quantity || 0)
					+ (itemData.system.quantity || 0),
			},
		};

		return (await UtilDocuments.pUpdateEmbeddedDocuments(this._actor, [update], {ClsEmbed: Item}))[0].document;
	}

	_pImportEntry_pImportToActor_getExistingStackableItem ({item, itemData}) {
		if (Config.get("importItem", "inventoryStackingMode") === ConfigConsts.C_ITEM_ATTUNEMENT_NEVER) return null;

				const matchingItem = this._actor.items.contents.find(sheetItem => {
			if (sheetItem.type !== itemData.type) return;

			const isMatchingSource = !Config.get("import", "isStrictMatching")
				|| (UtilDataConverter.getItemSource(sheetItem).source || "").toLowerCase() === (UtilDataConverter.getItemSource(itemData).source || "").toLowerCase();
			if (!isMatchingSource) return false;

			if (sheetItem.name.toLowerCase().trim() === itemData.name.toLowerCase().trim()) return true;

			return DataConverterItem.getItemCompendiumAliases(item, {isStrict: true})
				.some(alias => alias.toLowerCase().trim() === sheetItem.name.toLowerCase().trim());
		});
		if (!matchingItem) return null;

		if (Config.get("importItem", "inventoryStackingMode") === ConfigConsts.C_ITEM_ATTUNEMENT_ALWAYS) return matchingItem;

		if (
			Config.get("importItem", "inventoryStackingMode") === ConfigConsts.C_ITEM_ATTUNEMENT_SMART
			&& (
				this._pImportEntry_pImportToActor_isThrowableItem({itemData})
				|| this._pImportEntry_pImportToActor_isSmartStackableItem({itemData})
			)
		) return matchingItem;

		return null;
	}

	_pImportEntry_pImportToActor_isThrowableItem ({itemData}) {
		const throwableSet = new Set((Config.get(this._configGroup, "throwables") || []).map(it => it.trim().toLowerCase()));
		return throwableSet.has((itemData.name || "").toLowerCase().trim());
	}

	_pImportEntry_pImportToActor_isSmartStackableItem ({itemData}) {
		return new Set(DataConverterItem.STACKABLE_FOUNDRY_ITEM_TYPES_IMPORT).has(itemData.type);
	}

	async _pImportEntry_pImportToActor_pUpdateItemPostAdd ({itemData, embeddedDocument}) {
		if (!embeddedDocument) return;

				if (this._pImportEntry_pImportToActor_isThrowableItem({itemData})) {
			await UtilDocuments.pUpdateEmbeddedDocuments(
				this._actor,
				[
					{
						_id: embeddedDocument.id,
						system: {
							consume: {
								type: "ammo",
								target: embeddedDocument.id,
								amount: 1,
							},
						},
					},
				],
				{
					propData: "items",
					ClsEmbed: Item,
				},
			);
		}

		return embeddedDocument;
	}

	_pImportEntry_getSheetItemsAmmo (item) {
		if (!item.ammoType) return null;
		if (!this._actor) return null;
		return this._actor.items.filter(it => it.type === "consumable" && it.system.consumableType === "ammo");
	}

	static sortEntries (a, b) {
						if (a.ammoType && !b.ammoType) return 1;
		if (!a.ammoType && b.ammoType) return -1;
		return SortUtil.ascSortLower(a.name, b.name) || SortUtil.ascSortLower(Parser.sourceJsonToFull(a.source), Parser.sourceJsonToFull(b.source));
	}

			async pImportCurrency (currency, importOpts) {
		importOpts = importOpts || {};

		console.log(...LGT, `Importing currency "${Parser.getDisplayCurrency(currency)}"`);

		const itemData = await DataConverterItem.pGetCurrencyItem(
			currency,
			{
				isAddDefaultOwnershipFromConfig: importOpts.isAddDefaultOwnershipFromConfig ?? !this._actor,
				defaultOwnership: importOpts.defaultOwnership,
				userOwnership: importOpts.userOwnership,
			},
		);

		const fauxItem = {name: "Currency", source: VeCt.STR_GENERIC};

		if (importOpts.isTemp) return this._pImportEntry_pImportToDirectoryGeneric(fauxItem, importOpts, null, {docData: itemData, isSkipDuplicateHandling: true});
		if (this._actor) return this._pImportEntry_pImportToActor(fauxItem, importOpts, null, {docData: itemData});
		return this._pImportEntry_pImportToDirectoryGeneric(fauxItem, importOpts, null, {docData: itemData, isSkipDuplicateHandling: true});
	}

	static _initCreateSheetItemHook_currency () {
		Hooks.on("preCreateItem", (item, itemData, options, itemId) => {
			if (item.parent?.documentName !== "Actor") return;

			const flags = itemData.flags?.[SharedConsts.MODULE_ID] || itemData.flags?.[SharedConsts.MODULE_ID];
			if (flags?.type !== DataConverterItem.FLAG_TYPE_CURRENCY || !flags?.currency) return;

			const actor = item.parent;

			UtilActors.pAddCurrencyToActor({currency: flags.currency, actor})
				.then(null)
				.catch(e => {
					ui.notifications.error(`Failed to apply currency to actor! ${VeCt.STORAGE_DMSCREEN_TEMP_SUBLIST}`);
					throw e;
				});

			return false;
		});
	}
	}

var ImportListItem$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ImportListItem: ImportListItem
});

class DataConverterRace extends DataConverter {
	static _SIDE_LOAD_OPTS = {
		propBrew: "foundryRace",
		fnLoadJson: Vetools.pGetRaceSideData.bind(Vetools),
		propJson: "race",
		propsMatch: ["source", "name"],
	};

	static _IMG_FALLBACK = `modules/${SharedConsts.MODULE_ID}/media/icon/family-tree.svg`;

			static async pGetDocumentJson (race, opts) {
		opts = opts || {};
		if (opts.actor) opts.isActorItem = true;

		Renderer.get().resetHeaderIndex();

		const img = await this._pGetSaveImagePath(race, {fluff: await Renderer.race.pGetFluff(race), propCompendium: "race", taskRunner: opts.taskRunner});

		const additionalData = await this._pGetDataSideLoaded(race);
		const additionalFlags = await this._pGetFlagsSideLoaded(race);

		const effectsSideTuples = await this._pGetEffectsSideLoadedTuples({ent: race, img, actor: opts.actor});
		effectsSideTuples.forEach(({effect, effectRaw}) => DataConverter.mutEffectDisabledTransfer(effect, "importRace", UtilActiveEffects.getDisabledTransferHintsSideData(effectRaw)));

		const out = {
			name: UtilApplications.getCleanEntityName(UtilDataConverter.getNameWithSourcePart(race)),
			type: "feat",
			system: {
				description: {
					value: await this._pGetRaceDescription(race, opts),
					chat: "",
					unidentified: "",
				},
				source: UtilDataConverter.getSourceWithPagePart(race),

								damage: {parts: []},
				activation: {type: "", cost: 0, condition: ""},
				duration: {value: null, units: ""},
				target: {value: null, units: "", type: ""},
				range: {value: null, long: null, units: ""},
				uses: {value: 0, max: 0, per: null},
				ability: null,
				actionType: "",
				attackBonus: null,
				chatFlavor: "",
				critical: {threshold: null, damage: ""},
				formula: "",
				save: {ability: "", dc: null},
				requirements: "",
				recharge: {value: null, charged: false},
				
				...additionalData,
			},
			flags: {
				...this._getRaceFlags(race, opts),
				...additionalFlags,
			},
			effects: DataConverter.getEffectsMutDedupeId([
				...await this._pGetSpeedEffects(race.speed, {actor: opts.actor, iconEntity: race, iconPropCompendium: "race", taskRunner: opts.taskRunner}),
				...effectsSideTuples.map(it => it.effect),
			]),
			img,
			ownership: {default: 0},
		};

		if (opts.defaultOwnership != null) out.ownership = {default: opts.defaultOwnership};
		else if (opts.isAddDefaultOwnershipFromConfig) out.ownership = {default: Config.get("importRace", "ownership")};
		if (opts.userOwnership) Object.assign(out.ownership, opts.userOwnership);

		return out;
	}

	static _pGetRaceDescription (race, opts) {
		if (!Config.get("importRace", "isImportDescription")) return "";

		return UtilDataConverter.pGetWithDescriptionPlugins(async () => {
			const ptSummary = `<table class="w-100 summary stripe-even">
				<tr>
					<th class="col-4 text-center">Ability Scores</th>
					<th class="col-4 text-center">Size</th>
					<th class="col-4 text-center">Speed</th>
				</tr>
				<tr>
					<td class="text-center">${Renderer.getAbilityData(race.ability).asText}</td>
					<td class="text-center">${(race.size || [Parser.SZ_VARIES]).map(sz => Parser.sizeAbvToFull(sz)).join("/")}</td>
					<td class="text-center">${Parser.getSpeedString(race, {isMetric: Config.isUseMetricDistance({configGroup: "importRace"})})}</td>
				</tr>
			</table>`;

			const ptFeatures = this._pGetRaceDescription_features(race, opts);

			const fluff = await Renderer.race.pGetFluff(race);
			let ptFluff = null;
			if (fluff) {
				ptFluff = Renderer.utils.getFluffTabContent({entity: race, isImageTab: false, fluff});
			}

			return `<div>
				${ptSummary}
				${ptFeatures}
				${ptFluff != null ? `<hr class="hr-1">${ptFluff}` : ""}
			</div>`;
		});
	}

	static _pGetRaceDescription_features (race, opts) {
				if (!opts.isActorItem) return Renderer.get().setFirstSection(true).render({type: "entries", entries: race.entries}, 1);

		if (!opts.actor || !opts.raceFeatureDataMetas?.length) return "";

		const ptsFeature = opts.raceFeatureDataMetas
			.map(({id, name}) => `@UUID[Actor.${opts.actor.id}.Item.${id}]{${name}}`);

		return `<div class="mt-2">${ptsFeature.map(f => `<p>${f}</p>`).join("")}</div>`;
	}

	static _getCompendiumAliases (race) {
		if (!race.name && !race._baseName) return [];

		const out = [];

				const invertedName = PageFilterRaces.getInvertedName(race.name);
		if (invertedName && invertedName !== race.name) out.push(invertedName);

				if (race._baseName) out.push(race._baseName);

		return out;
	}

	static _getRaceFlags (race, opts) {
		const out = {
			[SharedConsts.MODULE_ID]: {
				page: UrlUtil.PG_RACES,
				source: race.source,
				hash: UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_RACES](race),
				propDroppable: "race",
				filterValues: opts.filterValues,
			},
		};

		if (opts.isActorItem) out[SharedConsts.MODULE_ID].isDirectImport = true;

		return out;
	}

	static isStubEntity (race) {
		return race.name === DataConverterRace.STUB_RACE.name && race.source === DataConverterRace.STUB_RACE.source;
	}

	static getRaceStub () {
		return MiscUtil.copy(DataConverterRace.STUB_RACE);
	}
}
DataConverterRace.STUB_RACE = {
	name: "Unknown Race",
	source: Parser.SRC_PHB,
	_isStub: true,
};

var DataConverterRace$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DataConverterRace: DataConverterRace
});

class DataConverterRaceFeature extends DataConverterFeature {
	static _SIDE_LOAD_OPTS = {
		propBrew: "foundryRaceFeature",
		fnLoadJson: async () => this._pGetPreloadSideData(),
		propJson: "raceFeature",
		propsMatch: ["raceSource", "raceName", "source", "name"],
	};

	static _IMG_FALLBACK = `modules/${SharedConsts.MODULE_ID}/media/icon/family-tree.svg`;

	static async pGetInitFeatureLoadeds (feature, {actor = null} = {}) {
		const hash = UrlUtil.URL_TO_HASH_BUILDER["raceFeature"](feature);
		return {
			hash,
			loadeds: [
				{
					hash,
					page: "raceFeature",
					source: feature.source,
					entity: feature,
					type: "raceFeature",
				},
			],
			name: feature.name,
			raceFeature: `${feature.name}|${feature.raceName}|${feature.raceSource}|${feature.source}`,
			source: feature.source,
		};
	}

		static async pGetDocumentJson (raceFeature, opts = {}) {
		Renderer.get().resetHeaderIndex();

		const raceFeatureAlias = this._getFauxRaceFeaturesAlias(raceFeature);

		const srdData = await UtilCompendium.getSrdCompendiumEntity("raceFeature", raceFeature, {taskRunner: opts.taskRunner})
			|| (raceFeatureAlias ? (await UtilCompendium.getSrdCompendiumEntity("raceFeature", raceFeatureAlias, {taskRunner: opts.taskRunner})) : null);

		const img = await this._pGetCompendiumFeatureImage(raceFeature, opts);

		const additionalData = await this._pGetDataSideLoaded(raceFeature);
		const additionalFlags = await this._pGetFlagsSideLoaded(raceFeature);

		const additionalDataAlias = raceFeatureAlias ? await this._pGetDataSideLoaded(raceFeatureAlias) : null;
		const additionalFlagsAlias = raceFeatureAlias ? await this._pGetFlagsSideLoaded(raceFeatureAlias) : null;

		const srdEffects = await this._pIsIgnoreSrdEffectsSideLoaded(raceFeature) ? [] : MiscUtil.copy(srdData?.effects || []);
		DataConverter.mutEffectsDisabledTransfer(srdEffects, "importRaceFeature");

		const effectsSideTuples = await this._pGetEffectsSideLoadedTuples({ent: raceFeature, img, actor: opts.actor});
		effectsSideTuples.forEach(({effect, effectRaw}) => DataConverter.mutEffectDisabledTransfer(effect, "importRaceFeature", UtilActiveEffects.getDisabledTransferHintsSideData(effectRaw)));

		const effectsSideTuplesAlias = raceFeatureAlias ? await this._pGetEffectsSideLoadedTuples({ent: raceFeatureAlias, img, actor: opts.actor}) : [];
		effectsSideTuplesAlias.forEach(({effect, effectRaw}) => DataConverter.mutEffectDisabledTransfer(effect, "importRaceFeature", UtilActiveEffects.getDisabledTransferHintsSideData(effectRaw)));

		return DataConverter.pGetItemActorPassive(
			raceFeature,
			{
								id: foundry.utils.randomID(),
				mode: "player",
				img,
				effects: DataConverter.getEffectsMutDedupeId([
					...srdEffects,
					...effectsSideTuples.map(it => it.effect),
					...effectsSideTuplesAlias.map(it => it.effect),
				]),
				fvttType: "feat",
				source: raceFeature.source,
				actor: opts.actor,
				foundryFlags: {
					[SharedConsts.MODULE_ID]: {
						page: "raceFeature",
						source: raceFeature.source,
						hash: UrlUtil.URL_TO_HASH_BUILDER["raceFeature"](raceFeature),
					},
				},
				additionalData: {...additionalDataAlias, ...additionalData},
				additionalFlags: {...additionalFlags, ...additionalFlagsAlias},
				translationData: this._getTranslationData({srdData}),
			},
		);
	}

	static getFauxRaceFeature (race, entry) {
		return {
			source: entry.source || race.source,
			raceName: race.name,
			raceSource: race.source,
			_raceBaseName: race._baseName,
			_raceBaseSource: race._baseSource,
			srd: !!(race.srd || race._baseSrd),
			basicRules: !!race.basicRules,
			page: entry.page ?? race.page,
			...MiscUtil.copy(entry),
			__prop: "raceFeature",
		};
	}

		static _getFauxRaceFeaturesAlias (raceFeature) {
		if (!raceFeature._raceBaseName && !raceFeature._raceBaseSource) return null;

		const out = {
			...MiscUtil.copy(raceFeature),
			source: raceFeature._raceBaseSource,
			raceName: raceFeature._raceBaseName,
			raceSource: raceFeature._raceBaseSource,
		};

		delete out._raceBaseName;
		delete out._raceBaseSource;

		return out;
	}

	static async _pGetCompendiumFeatureImage (feature, {taskRunner = null} = {}) {
		const fromRaceFeature = await UtilCompendium.pGetCompendiumImage("raceFeature", feature, {fnGetAliases: this._getCompendiumFeatureAliases.bind(this), deepKeys: ["data.requirements"], taskRunner});
		if (fromRaceFeature) return fromRaceFeature;

		return this._pGetSaveImagePath(
			{name: feature.raceName, source: feature.raceSource, srd: feature.srd},
			{propCompendium: "race", taskRunner},
		);
	}

	static _getCompendiumFeatureAliases (feature) {
		if (!feature.raceName && !feature._raceBaseName) return [];
		if (!feature.name) return [];

		const out = [];

		out.push({
			name: feature.name,
			"system.requirements": feature.raceName,
		});

				const invertedName = PageFilterRaces.getInvertedName(feature.raceName);
		if (invertedName && invertedName !== feature.raceName) {
			out.push({
				name: feature.name,
				"system.requirements": invertedName,
			});
		}

				if (feature._raceBaseName) {
			out.push({
				name: feature.name,
				"system.requirements": feature._raceBaseName,
			});
		}

		return out;
	}

	static async _pGetPreloadSideData () {
		if (!this._SIDE_DATA) this._SIDE_DATA = await Vetools.pGetRaceSideData();
		return this._SIDE_DATA;
	}
}

var DataConverterRaceFeature$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DataConverterRaceFeature: DataConverterRaceFeature
});

class CustomizerStateRace extends CustomizerStateBase {
	version = null;

	setVersion (val) { this.version = val; return this; }
}

class ImportCustomizerRace extends ImportCustomizerBase {
		constructor (dataList, resolve, opts) {
		super(
			dataList,
			resolve,
			{
				...opts,
				title: "Customize Import",
				template: `${SharedConsts.MODULE_LOCATION}/template/ImportListRaceCustomizer.hbs`,
			},
		);
	}

	
	_getData_row ({ent, ix}) {
		return {
			...super._getData_row({ent, ix}),

			hasVersions: ent._versions?.length,
			availableVersions: DataUtil.proxy.getVersions(ent.__prop, ent).map((ver, ix) => ({ix, name: ver.name})),
		};
	}

	
	_getListItemData ({li}) {
		const $e = $(li.ele);
		return {
			$selVersion: $e.find(`[name="sel-version"]`),
		};
	}

	
	async _pGetCustomizerState ({li, ent, state = null}) {
		return (state || new CustomizerStateRace())
			.setVersion(this._pGetCustomizerState_version({li, ent}));
	}

	_pGetCustomizerState_version ({li, ent}) {
		const ixVersion = li.data.$selVersion.length
			? Number(li.data.$selVersion.val()) === -1 ? null : Number(li.data.$selVersion.val())
			: null;
		if (!~ixVersion) return null;

		return {
			ixVersion,
		};
	}

	
	static async _pGetAppliedCustomizations ({ent}) {
		ent = this._pGetAppliedCustomizations_version({ent});
		return ent;
	}

	static _pGetAppliedCustomizations_version ({ent}) {
		const ixVersion = ent._fvttCustomizerState?.version?.ixVersion;
		if (ixVersion == null) return ent;

		const versions = DataUtil.proxy.getVersions(ent?.__prop, ent);
		return versions[ixVersion];
	}
}

class ImportListRace extends ImportListCharacter {
		static init () {
		this._initCreateSheetItemHook({
			prop: "race",
			importerName: "Race",
		});
	}
	
	static get ID () { return "races-and-subraces"; }
	static get DISPLAY_NAME_TYPE_PLURAL () { return "Races & Subraces"; }
	static get PROPS () { return ["race"]; }

	static _ = this.registerImpl(this);

	_dirsHomebrew = ["race", "subrace"];
	_titleSearch = "race";
	_sidebarTab = "items";
	_gameProp = "items";
	_defaultFolderPath = ["Races"];
	_pageFilter = new PageFilterRaces();
	_page = UrlUtil.PG_RACES;
	_isPreviewable = true;
	_isDedupable = true;
	_configGroup = "importRace";
	_isActorRadio = true;
	_ClsCustomizer = ImportCustomizerRace;
	static _DataConverter = DataConverterRace;

	async _pPostLoad (fileData) {
		return Charactermancer_Race_Util.pPostLoadPrereleaseBrew(fileData);
	}

	async _pGetSources () {
		const nonVetoolsOpts = {pPostLoad: this._pPostLoad.bind(this)};

		return [
			new UtilDataSource.DataSourceSpecial(
				Config.get("ui", "isStreamerMode") ? "SRD" : "5etools",
				() => Vetools.pGetRaces(),
				{
					cacheKey: "5etools-races",
					filterTypes: [UtilDataSource.SOURCE_TYP_OFFICIAL_ALL],
					isDefault: true,
				},
			),
			...UtilDataSource.getSourcesCustomUrl({...nonVetoolsOpts}),
			...UtilDataSource.getSourcesUploadFile({...nonVetoolsOpts}),
			...(await this._pGetSourcesPrerelease(nonVetoolsOpts)),
			...(await this._pGetSourcesBrew(nonVetoolsOpts)),
		];
	}

	_colWidthName = 4;
	_colWidthSource = 1;

	_getData_cols_other () {
		return [
			{
				name: "Ability",
				width: 5,
				field: "ability",
			},
			{
				name: "Size",
				width: 1,
				field: "size",
			},
		];
	}

	_getData_row_mutGetAdditionalValues ({it, ix}) {
				it._vAbility = it.ability ? Renderer.getAbilityData(it.ability).asTextShort : "None";
		it._vSize = (it.size || [Parser.SZ_VARIES]).map(sz => Parser.sizeAbvToFull(sz)).join("/");
		
		return {
			ability: it._vAbility,
			size: it._vSize,
			isVersion: !!it._versionBase_isVersion,
		};
	}

	getData () {
		return {
			...super.getData(),
			buttonsAdditional: [
				this._content.some(it => it._versions) ? {
					name: "btn-run-mods",
					text: "Customize and Import...",
				} : null,
			].filter(Boolean),
		};
	}

	_renderInner_absorbListItems_fnGetValues (it) {
		return {
			...super._renderInner_absorbListItems_fnGetValues(it),
			ability: it._vAbility,
			size: it._vSize,
		};
	}

	async _pImportEntry_pImportToActor (race, importOpts) {
		race = await this._pImportEntry_getUserVersion(race);

				const actUpdate = {
			system: {
				details: {
					race: race.name,
				},
			},
			prototypeToken: {},
		};

		const level = MiscUtil.get(this._actor, "system", "details", "level") || 1;
		const dataBuilderOpts = new ImportListRace.ImportEntryOpts({
			isCharactermancer: importOpts.isCharactermancer,
			pb: Math.floor((level - 1) / 4) + 2,
		});

		this._pImportEntry_fillFlags(race, actUpdate, dataBuilderOpts);
		await this._pImportEntry_pFillAbilities(race, actUpdate, dataBuilderOpts);
		if (dataBuilderOpts.isCancelled) return ImportSummary.cancelled();
		this._pImportEntry_fillAttributes(race, actUpdate, dataBuilderOpts);
		await this._pImportEntry_pFillSkillsAndTraits(race, actUpdate.system, dataBuilderOpts);
		if (dataBuilderOpts.isCancelled) return ImportSummary.cancelled();

				await this._pImportEntry_pFillItems(race, actUpdate, importOpts, dataBuilderOpts);
		if (dataBuilderOpts.isCancelled) return ImportSummary.cancelled();

				await UtilDocuments.pUpdateDocument(this._actor, actUpdate);

		if (this._actor.isToken) this._actor.sheet.render();

				await this._pImportActorAdditionalFeats(race, importOpts, dataBuilderOpts);
		if (dataBuilderOpts.isCancelled) return ImportSummary.cancelled();

		return new ImportSummary({
			status: ConstsTaskRunner.TASK_EXIT_COMPLETE,
			imported: [
				new ImportedDocument({
					name: race.name,
					actor: this._actor,
				}),
			],
		});
	}

	_pImportEntry_fillFlags (race, act, dataBuilderOpts) {
		const flags = {};
		const flagsDnd5e = {};

		const hasPowerfulBuild = (race.traitTags && race.traitTags.includes("Powerful Build"))
			|| race.entries.some(it => it.name === "Powerful Build");
		if (hasPowerfulBuild) flagsDnd5e.powerfulBuild = true;

		if (race.entries.some(it => it.name === "Savage Attacks")) flagsDnd5e.savageAttacks = true;
		if (race.entries.some(it => it.name === "Lucky") && race._baseName === "Halfling") flagsDnd5e.halflingLucky = true;

		if (Object.keys(flagsDnd5e).length) flags.dnd5e = flagsDnd5e;
		if (Object.keys(flags).length) act.flags = flags;
	}

	async _pImportEntry_pFillAbilities (race, actUpdate, dataBuilderOpts) {
		await Charactermancer_AbilityScoreSelect.pFillActorAbilityData(this._actor, race.ability, actUpdate, dataBuilderOpts);
	}

	_pImportEntry_fillAttributes (race, actUpdate, dataBuilderOpts) {
		const out = actUpdate.system.attributes = {};

		if (race.speed != null) out.movement = DataConverter.getMovement(race.speed, {configGroup: "importRace", propAllowlist: new Set(["walk"])});

				const formDataSenses = Charactermancer_SenseSelect.getFormDataFromRace(race);
		DataConverter.doApplySensesFormDataToActorUpdate({
			existingSensesActor: MiscUtil.get(this._actor, "_source", "system", "attributes", "senses"),
			existingTokenActor: MiscUtil.get(this._actor, "_source", "prototypeToken"),
			formData: formDataSenses,
			actorData: actUpdate.system,
			actorToken: actUpdate.prototypeToken,
			configGroup: "importRace",
		});
	}

	async _pImportEntry_pFillSkillsAndTraits (race, sys, dataBuilderOpts) {
		sys.traits = {};

		await this._pImportEntry_pHandleSize(race, sys, dataBuilderOpts);
		if (dataBuilderOpts.isCancelled) return;

						await DataConverter.pFillActorSkillToolLanguageData(
			{
				existingProficienciesSkills: MiscUtil.get(this._actor, "_source", "system", "skills"),
				existingProficienciesTools: MiscUtil.get(this._actor, "_source", "system", "tools"),
				existingProficienciesLanguages: MiscUtil.get(this._actor, "_source", "system", "traits", "languages"),
				skillToolLanguageProficiencies: race.skillToolLanguageProficiencies,
				actorData: sys,
				importOpts: dataBuilderOpts,
			},
		);
		if (dataBuilderOpts.isCancelled) return;

		await DataConverter.pFillActorSkillData(
			MiscUtil.get(this._actor, "_source", "system", "skills"),
			race.skillProficiencies,
			sys,
			dataBuilderOpts,
		);
		if (dataBuilderOpts.isCancelled) return;

		await DataConverter.pFillActorLanguageData(
			MiscUtil.get(this._actor, "_source", "system", "traits", "languages"),
			race.languageProficiencies,
			sys,
			dataBuilderOpts,
		);
		if (dataBuilderOpts.isCancelled) return;

		await DataConverter.pFillActorToolProfData(
			MiscUtil.get(this._actor, "_source", "system", "tools"),
			race.toolProficiencies,
			sys,
			dataBuilderOpts,
		);
		if (dataBuilderOpts.isCancelled) return;

				await DataConverter.pFillActorArmorProfData(
			MiscUtil.get(this._actor, "_source", "system", "traits", "armorProf"),
			race.armorProficiencies,
			sys,
			dataBuilderOpts,
		);
		if (dataBuilderOpts.isCancelled) return;

		await DataConverter.pFillActorWeaponProfData(
			MiscUtil.get(this._actor, "_source", "system", "traits", "weaponProf"),
			race.weaponProficiencies,
			sys,
			dataBuilderOpts,
		);
		if (dataBuilderOpts.isCancelled) return;

		await DataConverter.pFillActorImmunityData(
			MiscUtil.get(this._actor, "_source", "system", "traits", "di"),
			race.immune,
			sys,
			dataBuilderOpts,
		);
		if (dataBuilderOpts.isCancelled) return;

		await DataConverter.pFillActorResistanceData(
			MiscUtil.get(this._actor, "_source", "system", "traits", "dr"),
			race.resist,
			sys,
			dataBuilderOpts,
		);
		if (dataBuilderOpts.isCancelled) return;

		await DataConverter.pFillActorVulnerabilityData(
			MiscUtil.get(this._actor, "_source", "system", "traits", "dv"),
			race.vulnerable,
			sys,
			dataBuilderOpts,
		);
		if (dataBuilderOpts.isCancelled) return;

		await DataConverter.pFillActorConditionImmunityData(
			MiscUtil.get(this._actor, "_source", "system", "traits", "ci"),
			race.conditionImmune,
			sys,
			dataBuilderOpts,
		);
		if (dataBuilderOpts.isCancelled) return;

		await DataConverter.pFillActorExpertiseData(
			{
				existingProficienciesSkills: MiscUtil.get(this._actor, "_source", "system", "skills"),
				existingProficienciesTools: MiscUtil.get(this._actor, "_source", "system", "tools"),
				expertise: race.expertise,
				actorData: sys,
				importOpts: dataBuilderOpts,
			},
		);
			}

	static _isSkippableFeature (ent) {
		if (typeof ent === "string") return true; 		if (!ent.name) return true; 		if (ent.name === "Size") return true; 		return false;
	}

	async _pImportEntry_pFillItems (race, actUpdate, importOpts, dataBuilderOpts) {
		const spellHashToItemPosMap = {};

		await this._pApplyAllAdditionalSpellsToActor({entity: race, dataBuilderOpts, importOpts, spellHashToItemPosMap});
		if (dataBuilderOpts.isCancelled) return;

				for (const ent of race.entries) {
			if (this.constructor._isSkippableFeature(ent)) continue;

			const fauxRaceFeature = DataConverterRaceFeature.getFauxRaceFeature(race, ent);
			await DataConverterRaceFeature.pMutActorUpdateFeature(this._actor, actUpdate, fauxRaceFeature, dataBuilderOpts);
			if (dataBuilderOpts.isCancelled) return;
		}

		const tagHashItemIdMap = {};
		Object.entries(spellHashToItemPosMap)
			.forEach(([hash, id]) => MiscUtil.set(tagHashItemIdMap, "spell", hash, id));

		const raceFeatureDataMetas = [];

		await UtilDataConverter.pGetWithDescriptionPlugins(
			async () => {
				for (const ent of race.entries) {
					if (this.constructor._isSkippableFeature(ent)) continue;

					const raceFeature = DataConverterRaceFeature.getFauxRaceFeature(race, ent);

					const raceFeatureItem = await DataConverterRaceFeature.pGetDocumentJson(raceFeature, {actor: this._actor, taskRunner: importOpts.taskRunner});
					raceFeatureDataMetas.push({id: raceFeatureItem._id, name: raceFeatureItem.name});
					dataBuilderOpts.items.push(raceFeatureItem);
				}
			},
			{
				actorId: this._actor.id,
				tagHashItemIdMap,
			},
		);
		
		const raceItem = await DataConverterRace.pGetDocumentJson(
			race,
			{
				fluff: await Renderer.race.pGetFluff(race),
				actor: this._actor,
				raceFeatureDataMetas,
				taskRunner: importOpts.taskRunner,
			},
		);
		dataBuilderOpts.items.unshift(raceItem);

		await UtilActors.pAddActorItems(this._actor, dataBuilderOpts.items);
	}

	async _pImportEntry_pHandleSize (race, actUpdate, dataBuilderOpts) {
		const formData = await Charactermancer_Race_SizeSelect.pGetUserInput({
			sizes: race.size,
		});

		if (formData == null) return dataBuilderOpts.isCancelled = true;
		if (formData === VeCt.SYM_UI_SKIP) return;

		actUpdate.traits.size = UtilActors.VET_SIZE_TO_ABV[formData.data || Parser.SZ_MEDIUM] || "med";
	}
}

ImportListRace.ImportEntryOpts = class extends ImportListCharacter.ImportEntryOpts {
	constructor (opts) {
		opts = opts || {};
		super(opts);

		this.pb = opts.pb;
	}
};

var ImportListRace$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ImportListRace: ImportListRace
});

class PageFilterRaceFeature extends PageFilter {
	constructor () {
		super();
		this._miscFilter = new Filter({
			header: "Miscellaneous",
			items: ["Generic Feature", "SRD", "Basic Rules"],
			deselFn: (it) => it === "Generic Feature",
			isMiscFilter: true,
		});
	}

	static _GENERIC_NAMES = new Set([
		"Age",
		"Alignment",
		"Creature Type",
		"Darkvision",
		"Language",
		"Languages",
		"Size",
		"Superior Darkvision",
	].map(it => it.toLowerCase()));
	static _isGenericName (name) {
		return name && this._GENERIC_NAMES.has(name.toLowerCase());
	}

	static mutateForFilters (ent) {
		ent._fMisc = ent.srd ? ["SRD"] : [];
		if (ent.basicRules) ent._fMisc.push("Basic Rules");
		if (this._isGenericName(ent.name)) ent._fMisc.push("Generic Feature");
	}

	addToFilters (it, isExcluded) {
		if (isExcluded) return;

		this._sourceFilter.addItem(it.source);
		this._miscFilter.addItem(it._fMisc);
	}

	async _pPopulateBoxOptions (opts) {
		opts.filters = [
			this._sourceFilter,
			this._miscFilter,
		];
	}

	toDisplay (values, it) {
		return this._filterBox.toDisplay(
			values,
			it.source,
			it._fMisc,
		);
	}
}

class ImportListRaceFeature extends ImportListFeature {
	static get ID () { return "race-and-subrace-features"; }
	static get DISPLAY_NAME_TYPE_PLURAL () { return "Race & Subrace Features"; }
	static get PROPS () { return ["raceFeature"]; }

	static _ = this.registerImpl(this);

	_dirsHomebrew = ["race"];
	_titleSearch = "race feature";
	_sidebarTab = "items";
	_gameProp = "items";
	_defaultFolderPath = ["Race Features"];
	_pageFilter = new PageFilterRaceFeature();
	_page = "raceFeature";
	_isPreviewable = true;
	_isDedupable = true;
	_configGroup = "importRaceFeature";
	static _DataConverter = DataConverterRaceFeature;

	static async _pPostLoad_getAllPrereleaseBrewFeaturesFromRaces (data) {
		const raceData = await Charactermancer_Race_Util.pPostLoadPrereleaseBrew(data);
		return this._pPostLoad_getFeaturesFromRaces(raceData);
	}

	static async _pPostLoad_getFeaturesFromRaces (data) {
		const out = {raceFeature: []};

		for (const race of data.race || []) {
						(race.entries || [])
				.filter(it => it.name && it.entries)
				.forEach(ent => out.raceFeature.push(DataConverterRaceFeature.getFauxRaceFeature(race, ent)));
		}

		return out;
	}

	async _pGetSources () {
		const nonVetoolsOpts = {pPostLoad: (data) => this.constructor._pPostLoad_getAllPrereleaseBrewFeaturesFromRaces(data)};
		return [
			new UtilDataSource.DataSourceSpecial(
				Config.get("ui", "isStreamerMode") ? "SRD" : "5etools",
				Vetools.pGetRaces.bind(Vetools),
				{
					pPostLoad: (data) => this.constructor._pPostLoad_getFeaturesFromRaces(data),
					cacheKey: "5etools-race-features",
					filterTypes: [UtilDataSource.SOURCE_TYP_OFFICIAL_ALL],
					isDefault: true,
				},
			),
			...UtilDataSource.getSourcesCustomUrl({...nonVetoolsOpts}),
			...UtilDataSource.getSourcesUploadFile({...nonVetoolsOpts}),
			...(await this._pGetSourcesPrerelease({...nonVetoolsOpts})),
			...(await this._pGetSourcesBrew({...nonVetoolsOpts})),
		];
	}

	_colWidthName = 5;
	_colWidthSource = 1;

	_getData_cols_other () {
		return [
			{
				name: "Race",
				width: 5,
				field: "raceName",
			},
		];
	}

	_getData_row_mutGetAdditionalValues ({it, ix}) {
		return {
			raceName: it.raceName,
		};
	}

	_renderInner_absorbListItems_fnGetValues (it) {
		return {
			...super._renderInner_absorbListItems_fnGetValues(it),
			raceName: it.raceName,
		};
	}
}

var ImportListRaceFeature$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ImportListRaceFeature: ImportListRaceFeature
});

class Charactermancer_Spell_Util {
		static getCasterProgressionMeta ({casterProgression, curLevel, targetLevel, isBreakpointsOnly = false}) {
		if (casterProgression == null || curLevel == null || targetLevel == null) return null;

		const progression = UtilDataConverter.CASTER_TYPE_TO_PROGRESSION[casterProgression];
		if (!progression) return null;

		const levelToSpellLevel = [];
		let lastSpellLevel = 0;
		progression.forEach(slots => {
			let isFound = false;
			for (let i = 0; i < slots.length; ++i) {
				const spellLevel = i + 1;
				if (slots[i] && spellLevel > lastSpellLevel) {
					levelToSpellLevel.push(spellLevel);
					lastSpellLevel = spellLevel;
					isFound = true;
					break;
				}
			}
			if (!isFound) {
				if (isBreakpointsOnly) levelToSpellLevel.push(null);
								else levelToSpellLevel.push(levelToSpellLevel.length ? levelToSpellLevel.last() : null);
			}
		});

		const spannedLevels = levelToSpellLevel.slice(curLevel, targetLevel).filter(Boolean);
		if (!spannedLevels.length) return null;

		const spellLevelLow = Math.min(...spannedLevels);
		const spellLevelHigh = Math.max(...spannedLevels);

		const deltaLevels = Math.max(0, targetLevel - curLevel);
		const deltaSpellLevels = spellLevelHigh - spellLevelLow;

		return {
			spellLevelLow,
			spellLevelHigh,
			deltaLevels,
			deltaSpellLevels,
		};
	}

	static getCasterCantripProgressionMeta ({cls, sc, curLevel, targetLevel}) {
		if (cls == null || curLevel == null || targetLevel == null) return null;

		const atCurLevel = curLevel === 0 ? 0 : this.getMaxLearnedCantrips({cls, sc, targetLevel: curLevel});
		const atTargetLevel = this.getMaxLearnedCantrips({cls, sc, targetLevel: targetLevel});
		if (atCurLevel == null || atTargetLevel == null) return null;

		const deltaLevels = Math.max(0, targetLevel - curLevel);
		const deltaMaxCantrips = atTargetLevel - atCurLevel;

		return {
			maxCantripsLow: atCurLevel,
			maxCantripsHigh: atTargetLevel,
			deltaLevels,
			deltaMaxCantrips,
		};
	}

	static getMaxLearnedCantrips ({cls, sc, targetLevel}) {
		if (!cls || targetLevel == null) return null;

		let cantripProgression = DataConverter.getMaxCantripProgression(cls.cantripProgression, sc?.cantripProgression);

				if (PrereleaseUtil.hasSourceJson(cls.source) || (sc && PrereleaseUtil.hasSourceJson(sc.source))) cantripProgression = cantripProgression || this._getApproximateCantripProgression({cls, sc});
		if (BrewUtil2.hasSourceJson(cls.source) || (sc && BrewUtil2.hasSourceJson(sc.source))) cantripProgression = cantripProgression || this._getApproximateCantripProgression({cls, sc});

		if (!cantripProgression) return null;

		return cantripProgression[targetLevel - 1];
	}

	static _getApproximateCantripProgression ({cls, sc}) {
		return this._getApproximateNumberCol({cls, sc, colNameLower: "cantrips known"});
	}

	static _getApproximateSpellsKnownProgression (cls, sc) {
		return this._getApproximateNumberCol({cls, sc, colNameLower: "spells known"});
	}

	static _getApproximateNumberCol ({cls, sc, colNameLower}) {
		const tableGroups = (PrereleaseUtil.hasSourceJson(cls.source) ? cls.classTableGroups : null)
			|| ((sc && PrereleaseUtil.hasSourceJson(sc.source)) ? sc?.subclassTableGroups : null)
			|| (BrewUtil2.hasSourceJson(cls.source) ? cls.classTableGroups : null)
			|| ((sc && BrewUtil2.hasSourceJson(sc.source)) ? sc?.subclassTableGroups : null);
		if (!tableGroups) return;
		for (const tblGroup of tableGroups) {
			const ixCol = (tblGroup.colLabels || []).findIndex(it => `${it}`.toLowerCase().includes(colNameLower));
			if (!~ixCol) continue;

			const numbers = (tblGroup.rowsSpellProgression || tblGroup.rows || []).map(row => row.filter((_, ixCell) => ixCell === ixCol)).flat();

			if (numbers.every(it => !isNaN(it))) return numbers.map(it => Number(it));
		}
	}

	static getFixedLearnedProgression ({cls, sc, targetLevel, isExistingClass, isDefault = false, formDataSlotSelectFromComp} = {}) {
		if (targetLevel == null) return null;

		const casterProgression = DataConverter.getMaxCasterProgression(cls.casterProgression, sc?.casterProgression);

		if (!casterProgression || !UtilDataConverter.CASTER_TYPE_TO_PROGRESSION[casterProgression]) return null;

		const totalKnownPerLevel = [...new Array(9)].map(() => 0);

		let isAnyData = false;

		const formDataSlotSelect = (isExistingClass || isDefault)
			? Charactermancer_Spell_SlotLevelSelect.getDefaultFormData({
				targetLevel,
				casterProgression,
								spellsKnownProgression: cls?.spellsKnownProgression || sc?.spellsKnownProgression,
								spellsKnownProgressionFixed: cls?.spellsKnownProgressionFixed || sc?.spellsKnownProgressionFixed,
			})
			: formDataSlotSelectFromComp;

		if (formDataSlotSelect) {
			isAnyData = isAnyData || formDataSlotSelect?.isAnyData;
			if (formDataSlotSelect?.data) formDataSlotSelect.data.forEach((it, i) => totalKnownPerLevel[i] += it);
		}

		if (cls.spellsKnownProgressionFixedByLevel) {
			isAnyData = true;

			Object.entries(cls.spellsKnownProgressionFixedByLevel)
				.forEach(([lvl, spellSummary]) => {
					if (Number(lvl) > targetLevel) return;

					Object.entries(spellSummary)
						.forEach(([lvlSpell, count]) => {
							lvlSpell = Number(lvlSpell);
							totalKnownPerLevel[lvlSpell - 1] += count;
						});
				});
		}

				if (!isAnyData) return null;

						return totalKnownPerLevel;
	}

	static getMaxPreparedSpells ({cls, sc, targetLevel, existingAbilityScores, abilityScoresFromComp} = {}) {
		if (!cls || targetLevel == null) return null;

		const casterProgression = DataConverter.getMaxCasterProgression(cls.casterProgression, sc?.casterProgression);

		if (!casterProgression || !UtilDataConverter.CASTER_TYPE_TO_PROGRESSION[casterProgression]) return null;

		const spellSlotsAtLevel = UtilDataConverter.CASTER_TYPE_TO_PROGRESSION[casterProgression][targetLevel - 1];
		if (!spellSlotsAtLevel) return null;

				if (!spellSlotsAtLevel.some(Boolean)) return null;

		if (cls.preparedSpellsProgression || sc?.preparedSpellsProgression) return this._getMaxPreparedSpells_preparedSpellsProgression({cls, sc, targetLevel, existingAbilityScores, abilityScoresFromComp});
		return this._getMaxPreparedSpells_preparedSpells({cls, sc, targetLevel});
	}

	static _getMaxPreparedSpells_preparedSpells ({cls, sc, targetLevel, existingAbilityScores, abilityScoresFromComp}) {
		let preparedSpellExpression = cls.preparedSpells;

		if (PrereleaseUtil.hasSourceJson(cls.source) || BrewUtil2.hasSourceJson(cls.source)) {
						preparedSpellExpression = preparedSpellExpression || this._getApproximatePreparedFormula(cls, sc);
		}

		if (!preparedSpellExpression) return null;

		const totalsAsi = abilityScoresFromComp;
		const preparedSpellExpressionEvaluable = preparedSpellExpression.replace(/<\$([^$]+)\$>/g, (...m) => {
			switch (m[1]) {
				case "level": return targetLevel;
				case "str_mod": return this._getMaxPreparedSpells_getAbilityScore({ability: "str", totalsAsi, existingAbilityScores});
				case "dex_mod": return this._getMaxPreparedSpells_getAbilityScore({ability: "dex", totalsAsi, existingAbilityScores});
				case "con_mod": return this._getMaxPreparedSpells_getAbilityScore({ability: "con", totalsAsi, existingAbilityScores});
				case "int_mod": return this._getMaxPreparedSpells_getAbilityScore({ability: "int", totalsAsi, existingAbilityScores});
				case "wis_mod": return this._getMaxPreparedSpells_getAbilityScore({ability: "wis", totalsAsi, existingAbilityScores});
				case "cha_mod": return this._getMaxPreparedSpells_getAbilityScore({ability: "cha", totalsAsi, existingAbilityScores});
				default: throw new Error(`Unknown variable "${m[1]}"`);
			}
		});

				const outRaw = eval(preparedSpellExpressionEvaluable);
		if (isNaN(outRaw)) {
			console.warn(...LGT, `Could not evaluate expression "${preparedSpellExpressionEvaluable}" (originally "${preparedSpellExpression}") as a number!`);
			return null;
		}

				return Math.max(1, Math.floor(outRaw));
	}

	static _getMaxPreparedSpells_preparedSpellsProgression ({cls, sc, targetLevel}) {
		const progression = sc?.preparedSpellsProgression || cls.preparedSpellsProgression;
		return progression[Math.max(0, targetLevel - 1)] || 0;
	}

	static getMaxPreparedSpellsFormula ({cls, sc} = {}) {
		if (!cls) return null;

		const casterProgression = DataConverter.getMaxCasterProgression(cls.casterProgression, sc?.casterProgression);

		if (!casterProgression || !UtilDataConverter.CASTER_TYPE_TO_PROGRESSION[casterProgression]) return null;

		let preparedSpellExpression = cls.preparedSpells;

		if (PrereleaseUtil.hasSourceJson(cls.source) || BrewUtil2.hasSourceJson(cls.source)) {
						preparedSpellExpression = preparedSpellExpression || this._getApproximatePreparedFormula(cls, sc);
		}

		if (!preparedSpellExpression) return null;

		const preparedSpellExpressionEvaluable = preparedSpellExpression.replace(/<\$([^$]+)\$>/g, (...m) => {
			switch (m[1]) {
				case "level": return `@classes.${Parser.stringToSlug(cls.name)}.levels`;
				case "str_mod":
				case "dex_mod":
				case "con_mod":
				case "int_mod":
				case "wis_mod":
				case "cha_mod": return `@abilities.${m[1].toLowerCase().slice(0, 3)}.mod`;
				default: throw new Error(`Unknown variable "${m[1]}"`);
			}
		});

				return `max(1, floor(${preparedSpellExpressionEvaluable}))`;
	}

	static _getMaxPreparedSpells_getAbilityScore ({totalsAsi, existingAbilityScores, ability}) {
		if (existingAbilityScores) return existingAbilityScores[ability] || 0;
		return Parser.getAbilityModNumber(totalsAsi?.totals?.[totalsAsi.mode]?.[ability] || 0);
	}

	static _getApproximatePreparedFormula (cls, sc) {
		if (!cls) return null;

		const casterProgression = DataConverter.getMaxCasterProgression(cls.casterProgression, sc?.casterProgression);

		if (!casterProgression || (!cls.classTableGroups && !sc?.subclassTableGroups) || casterProgression === "pact") return null;

		const hasSpellsKnown = [cls.classTableGroups, sc?.subclassTableGroups]
			.filter(Boolean)
			.some(tableGroups => {
				tableGroups.map(it => it.colLabels || [])
					.flat()
					.map(lbl => Renderer.stripTags(`${lbl}`.trim()))
					.some(it => {
						const parts = it.toLowerCase().split(/[^a-z0-9]/g).map(it => it.trim()).filter(Boolean);
						return parts.some(pt => pt === "spell" || pt === "spells") && parts.some(pt => pt === "known");
					});
			});

		if (hasSpellsKnown) return null;

				return `<$level$> ${casterProgression !== "full" ? `/ 2 ` : ""}+ ${cls.spellcastingAbility ? `<$${cls.spellcastingAbility}_mod$>` : "5"}`;
	}

	static getExistingCasterMeta ({cls, sc, actor, targetLevel, formDataSlotSelectFromComp = null, abilityScoresFromComp = null}) {
		if (!targetLevel) return null;

		const casterProgression = DataConverter.getMaxCasterProgression(cls?.casterProgression, sc?.casterProgression);
		const casterProgressionMeta = Charactermancer_Spell_Util.getCasterProgressionMeta({casterProgression, curLevel: 0, targetLevel: targetLevel});

		return {
			maxLearnedCantrips: this.getMaxLearnedCantrips({cls, sc, targetLevel}),
			fixedLearnedProgression: this.getFixedLearnedProgression({cls, sc, targetLevel, isExistingClass: true, formDataSlotSelectFromComp}),
			maxPreparedSpells: this.getMaxPreparedSpells({cls, sc, targetLevel, existingAbilityScores: Charactermancer_Util.getCurrentAbilityScores(actor), abilityScoresFromComp}),
			spellLevelLow: casterProgressionMeta?.spellLevelLow,
			spellLevelLowHigh: casterProgressionMeta?.spellLevelHigh,
		};
	}
}

class Charactermancer_Spell_SlotLevelSelect extends BaseComponent {
	constructor ({className, spellSlotLevelSelection}) {
		super();
		this._className = className;
		this._prevSpellSlotLevelSelection = spellSlotLevelSelection;
	}

	set curLevel (val) { this._state.curLevel = val; }
	set targetLevel (val) { this._state.targetLevel = val; }
	set spellsKnownProgression (val) { this._state.spellsKnownProgression = val; }
	set casterProgression (val) { this._state.casterProgression = val; }
	set spellsKnownProgressionFixed (val) { this._state.spellsKnownProgressionFixed = val; }
	set spellsKnownProgressionFixedAllowLowerLevel (val) { this._state.spellsKnownProgressionFixedAllowLowerLevel = val; }
	set spellsKnownProgressionFixedAllowHigherLevel (val) { this._state.spellsKnownProgressionFixedAllowHigherLevel = val; }

	isAnyChoice () { return this._isAnyChoice(); }

	getFlagsChoicesState () {
		return {
			...this._getFlagsChoicesState_namespace({namespace: "generic"}),
			...this._getFlagsChoicesState_namespace({namespace: "fixed"}),
		};
	}

	_getFlagsChoicesState_namespace ({namespace}) {
		const out = {};

		[...new Array(this._state.targetLevel)]
			.forEach((_, ixLvl) => {
				const lvl = ixLvl + 1;

				const {propCnt} = this.constructor._getPropsLevel(lvl, namespace);

				const numSpells = this._state[propCnt];
				for (let i = 0; i < numSpells; ++i) {
					const {propSpellLevel} = this.constructor._getPropsSpell(lvl, namespace, i);

					out[propSpellLevel] = this._state[propSpellLevel];
				}
			});

		return out;
	}

	addHookPulseFixedLearnedProgression (hk) { this._addHookBase("pulseFixedLearnedProgression", hk); }

	_doPulseFixedLearnedProgression () { this._state.pulseFixedLearnedProgression = !this._state.pulseFixedLearnedProgression; }

	render ($wrp) {
		const $wrpInner = $(`<div class="ve-flex-col w-100"></div>`).appendTo($wrp.empty());

		const hkIsVisible = () => $wrpInner.toggleVe(this._isAnyChoice());
		this._addHookBase("curLevel", hkIsVisible);
		this._addHookBase("targetLevel", hkIsVisible);
		this._addHookBase("casterProgression", hkIsVisible);
		this._addHookBase("spellsKnownProgressionFixed", hkIsVisible);
		this._addHookBase("spellsKnownProgressionFixedAllowLowerLevel", hkIsVisible);
		this._addHookBase("spellsKnownProgressionFixedAllowHigherLevel", hkIsVisible);
		this._addHookBase("spellsKnownProgression", hkIsVisible);
		hkIsVisible();

		const hkPopulateGenericKnownState = () => this._doPopulateGenericKnownState();
		this._addHookBase("curLevel", hkPopulateGenericKnownState);
		this._addHookBase("targetLevel", hkPopulateGenericKnownState);
		this._addHookBase("casterProgression", hkPopulateGenericKnownState);
		this._addHookBase("spellsKnownProgression", hkPopulateGenericKnownState);
		this._addHookBase("spellsKnownAllowLowerLevel", hkPopulateGenericKnownState);
		this._addHookBase("spellsKnownAllowHigherLevel", hkPopulateGenericKnownState);
		hkPopulateGenericKnownState();

		const hkPopulateFixedKnownState = () => this._doPopulateFixedKnownState();
		this._addHookBase("curLevel", hkPopulateFixedKnownState);
		this._addHookBase("targetLevel", hkPopulateFixedKnownState);
		this._addHookBase("casterProgression", hkPopulateFixedKnownState);
		this._addHookBase("spellsKnownProgressionFixed", hkPopulateFixedKnownState);
		this._addHookBase("spellsKnownProgressionFixedAllowLowerLevel", hkPopulateFixedKnownState);
		this._addHookBase("spellsKnownProgressionFixedAllowHigherLevel", hkPopulateFixedKnownState);
		hkPopulateFixedKnownState();

		const $btnToggle = $(`<div class="py-1 clickable ve-muted">[+]</div>`)
			.click(() => {
				$btnToggle.text($btnToggle.text() === "[+]" ? "[\u2012]" : "[+]");
				$stgBody.toggleVe();
			});

		const $rows = [...new Array(Consts.CHAR_MAX_LEVEL)].map((_, ixLvl) => {
			const lvl = ixLvl + 1;
			const $cellSpells = $(`<div class="col-9 ve-flex-v-center ve-flex-wrap"></div>`);

			const {propSpellLevelMax} = this.constructor._getPropsGeneral(lvl);
			const {propCnt: propCntGeneric} = this.constructor._getPropsLevel(lvl, "generic");
			const {propCnt: propCntFixed} = this.constructor._getPropsLevel(lvl, "fixed");

			const selMetasGeneric = [];
			const selMetasFixed = [];

			const $row = $$`<div class="ve-flex-v-center stripe-odd">
				<div class="col-3 text-center">${ixLvl + 1}</div>
				${$cellSpells}
			</div>`;

			const $dispNone = $(`<div>\u2014</div>`).appendTo($cellSpells);

			const hk = () => {
				let cntVisible = 0;

								cntVisible = cntVisible + this._hkRow_doAdjustElements({
					namespace: "generic",
					selMetas: selMetasGeneric,
					propCnt: propCntGeneric,
					propIsAllowLower: "spellsKnownAllowLowerLevel",
					propIsAllowHigher: "spellsKnownAllowHigherLevel",
					lvl,
					propSpellLevelMax,
					$cellSpells,
				});
				
								cntVisible = cntVisible + this._hkRow_doAdjustElements({
					namespace: "fixed",
					selMetas: selMetasFixed,
					propCnt: propCntFixed,
					propIsAllowLower: "spellsKnownProgressionFixedAllowLowerLevel",
					propIsAllowHigher: "spellsKnownProgressionFixedAllowHigherLevel",
					lvl,
					propSpellLevelMax,
					$cellSpells,
				});
				
				$dispNone.toggleVe(cntVisible === 0);

				$row.toggleVe((this._state.targetLevel ?? 0) >= lvl);
			};
			this._addHookBase(propCntFixed, hk);
			this._addHookBase(propCntGeneric, hk);
			this._addHookBase(propSpellLevelMax, hk);
			this._addHookBase("curLevel", hk);
			this._addHookBase("targetLevel", hk);
			this._addHookBase("spellsKnownAllowLowerLevel", hk);
			this._addHookBase("spellsKnownAllowHigherLevel", hk);
			this._addHookBase("spellsKnownProgressionFixedAllowLowerLevel", hk);
			this._addHookBase("spellsKnownProgressionFixedAllowHigherLevel", hk);
			hk();

			return $row;
		});

		const $stgBody = $$`<div class="ve-flex-col w-100">
			<div class="ve-muted italic ve-small mb-1">If you wish to swap out learned spell levels for lower/higher (for example, when you swap out a spell on gaining a level as a Bard), you may do so here. Note that your final choices are not validated, so swap with caution, and according to the rules!</div>
			<div class="ve-flex-v-center">
				<div class="col-3 text-center">${this._className} Level</div>
				<div class="col-9">Learned Spell Levels</div>
			</div>
			${$rows}
		</div>`.toggleVe();

		$$($wrpInner)`<div class="ve-flex-col w-100">
			<div class="split-v-center">
				<div class="bold">Learned Slot Level</div>
				${$btnToggle}
			</div>

			${$stgBody}
		</div>`;

		if (this._prevSpellSlotLevelSelection) this._proxyAssignSimple("state", {...this._prevSpellSlotLevelSelection});
	}

	_hkRow_doAdjustElements ({namespace, propCnt, selMetas, lvl, propSpellLevelMax, $cellSpells, propIsAllowLower, propIsAllowHigher}) {
		let cntVisible = 0;

		const numSpellsAtLevel = this._state[propCnt];
		for (let i = 0, len = Math.max(numSpellsAtLevel, selMetas.length); i < len; ++i) {
			let selMeta = selMetas[i];

			if (i > numSpellsAtLevel) {
				selMeta.$sel.hideVe();
				selMeta.$dispStatic.hideVe();
				continue;
			}

			const {propSpellLevel} = this.constructor._getPropsSpell(lvl, namespace, i);

			if (!selMetas[i]) {
				selMeta = ComponentUiUtil.$getSelEnum(
					this,
					propSpellLevel,
					{
						values: this._geSpellLevelSelValues(propIsAllowLower, propIsAllowHigher, propSpellLevelMax),
						asMeta: true,
						fnDisplay: it => this.constructor._getSpellLevelDisplay(it),
					},
				);
				selMeta.$sel
					.addClass("manc-sp__sel-slot-level text-center p-0 clickable")
					.appendTo($cellSpells);
				selMetas[i] = selMeta;

				const hkSelTitle = () => selMeta.$sel.title(`You have selected to learn a ${this._state[propSpellLevel]}-level spell at this level.`);
				this._addHookBase(propSpellLevel, hkSelTitle);
				hkSelTitle();

				this._addHookBase(propSpellLevel, () => this._doPulseFixedLearnedProgression());

								const $dispStatic = $(`<div class="ve-flex-vh-center manc-sp__sel-slot-level text-center ve-muted"></div>`).appendTo($cellSpells);
				const hkStatic = () => {
					$dispStatic.toggleVe(this._isShowStaticFixedValue(propIsAllowLower, propIsAllowHigher, propSpellLevelMax));
					$dispStatic
						.text(this.constructor._getSpellLevelDisplay(this._state[propSpellLevelMax]))
						.title(`This box indicates you will learn a ${this._state[propSpellLevelMax]}-level spell at this level.`);
				};
				this._addHookBase(propSpellLevel, hkStatic);
				this._addHookBase(propSpellLevelMax, hkStatic);
				this._addHookBase(propIsAllowLower, hkStatic);
				this._addHookBase(propIsAllowHigher, hkStatic);
				this._addHookBase("curLevel", hkStatic);
				this._addHookBase("targetLevel", hkStatic);
				hkStatic();

				selMeta.$dispStatic = $dispStatic;
				
				const hkMaxSpellLevel = () => {
					selMeta.setValues(this._geSpellLevelSelValues(propIsAllowLower, propIsAllowHigher, propSpellLevelMax));
				};
				this._addHookBase(propSpellLevelMax, hkMaxSpellLevel);
				this._addHookBase(propIsAllowLower, hkMaxSpellLevel);
				this._addHookBase(propIsAllowHigher, hkMaxSpellLevel);
				this._addHookBase("curLevel", hkMaxSpellLevel);
				this._addHookBase("targetLevel", hkMaxSpellLevel);
			}

			cntVisible++;

			const isShowStatic = this._isShowStaticFixedValue(propIsAllowLower, propIsAllowHigher, propSpellLevelMax);
			selMeta.$sel.toggleVe(!isShowStatic);
			selMeta.$dispStatic.toggleVe(isShowStatic);
		}

		return cntVisible;
	}

	static _getSpellLevelDisplay (lvl) { return `${Parser.getOrdinalForm(lvl)}-level sp.`; }

	static _getPropsSpell (lvl, namespace, ix) {
		return {
			propSpellLevel: `${lvl}_${namespace}_${ix}_spellLevel`,
		};
	}

	static _getPropsLevel (lvl, namespace) {
		return {
			propCnt: `${lvl}_${namespace}_cntFixed`,
		};
	}

	static _getPropsGeneral (lvl) {
		return {
			propSpellLevelMax: `${lvl}_spellLevelMax`,
		};
	}

	_isAnyChoice () {
		if (this._state.curLevel == null || this._state.targetLevel == null || this._state.casterProgression == null) return false;

		return !!(
			(this._state.spellsKnownProgressionFixed && (this._state.spellsKnownProgressionFixedAllowLowerLevel || this._state.spellsKnownProgressionFixedAllowHigherLevel))
			|| (this._state.spellsKnownProgression && (this._state.spellsKnownAllowLowerLevel || this._state.spellsKnownAllowHigherLevel))
		);
	}

	_geSpellLevelSelValues (propIsAllowLower, propIsAllowHigher, propSpellLevelMax) {
		const maxSpellLevel = Charactermancer_Spell_Util.getCasterProgressionMeta({
			casterProgression: this._state.casterProgression,
			curLevel: this._state.curLevel,
			targetLevel: this._state.targetLevel,
		})?.spellLevelHigh || 0;

		const min = this._state[propIsAllowLower] ? 1 : maxSpellLevel;
		const max = this._state[propIsAllowHigher] ? maxSpellLevel : this._state[propSpellLevelMax];

		const out = [];
		for (let i = min; i <= max; ++i) out.push(i);
		return out;
	}

	_doPopulateGenericKnownState () {
		[...new Array(Consts.CHAR_MAX_LEVEL)].forEach((_, ixLvl) => this._doPopulateGenericKnownState_forLevel(ixLvl + 1));

		this._doPulseFixedLearnedProgression();
	}

	_doPopulateGenericKnownState_forLevel (lvl) {
		if (this._doPopulateState_forLevel_isDoReset() || !this._state.spellsKnownProgression) {
			this._doPopulateState_forLevel_doReset({lvl, namespace: "generic"});
			return;
		}

		const prevCntSpells = this._state.spellsKnownProgression[lvl - 2] || 0;
		const curCntSpells = this._state.spellsKnownProgression[lvl - 1] || 0;
		const numSpells = curCntSpells - prevCntSpells;

		this._doPopulateState_forLevel_doPopulateForNumSpells({
			lvl,
			namespace: "generic",
			numSpells,
			propIsAllowLower: "spellsKnownAllowLowerLevel",
			propIsAllowHigher: "spellsKnownAllowHigherLevel",
		});
	}

	_doPopulateState_forLevel_isDoReset () {
		return this._state.curLevel == null || this._state.targetLevel == null || this._state.casterProgression == null || UtilDataConverter.CASTER_TYPE_TO_PROGRESSION[this._state.casterProgression] == null;
	}

	_doPopulateState_forLevel_doReset ({lvl, namespace}) {
		const {propCnt} = this.constructor._getPropsLevel(lvl, namespace);
		this._state[propCnt] = null;
	}

	_doPopulateState_forLevel_doPopulateForNumSpells ({lvl, namespace, numSpells, propIsAllowLower, propIsAllowHigher}) {
		const maxSpellLevel = Charactermancer_Spell_Util.getCasterProgressionMeta({
			casterProgression: this._state.casterProgression,
			curLevel: 0,
			targetLevel: lvl,
		})?.spellLevelHigh || 0;

		[...new Array(numSpells)].map((_, i) => {
			const {propSpellLevel} = this.constructor._getPropsSpell(lvl, namespace, i);

			if (this._state[propSpellLevel] == null) this._state[propSpellLevel] = maxSpellLevel;
			else {
				let nxtVal = this._state[propSpellLevel];

								if (!this._state[propIsAllowLower]) nxtVal = Math.max(nxtVal, maxSpellLevel);
				if (!this._state[propIsAllowHigher]) nxtVal = Math.min(nxtVal, maxSpellLevel);

				this._state[propSpellLevel] = nxtVal;
			}
		});

		const {propCnt} = this.constructor._getPropsLevel(lvl, namespace);
		this._state[propCnt] = numSpells;

		const {propSpellLevelMax} = this.constructor._getPropsGeneral(lvl);
		this._state[propSpellLevelMax] = maxSpellLevel;
	}

	_doPopulateFixedKnownState () {
		[...new Array(Consts.CHAR_MAX_LEVEL)].forEach((_, ixLvl) => this._doPopulateFixedKnownState_forLevel(ixLvl + 1));

		this._doPulseFixedLearnedProgression();
	}

	_doPopulateFixedKnownState_forLevel (lvl) {
		if (this._doPopulateState_forLevel_isDoReset() || !this._state.spellsKnownProgressionFixed) {
			this._doPopulateState_forLevel_doReset({lvl, namespace: "fixed"});
			return;
		}

		const numSpells = this._state.spellsKnownProgressionFixed[lvl - 1] || 0;
		this._doPopulateState_forLevel_doPopulateForNumSpells({
			lvl,
			namespace: "fixed",
			numSpells,
			propIsAllowLower: "spellsKnownProgressionFixedAllowLowerLevel",
			propIsAllowHigher: "spellsKnownProgressionFixedAllowHigherLevel",
		});
	}

	_isShowStaticFixedValue (propIsAllowLower, propIsAllowHigher, propSpellLevelMax) {
		const maxSpellLevel = Charactermancer_Spell_Util.getCasterProgressionMeta({
			casterProgression: this._state.casterProgression,
			curLevel: this._state.curLevel,
			targetLevel: this._state.targetLevel,
		})?.spellLevelHigh || 0;
		if (maxSpellLevel <= 1) return true;

		const isAllowLower = this._state[propIsAllowLower] && this._state[propSpellLevelMax] !== 1;
		const isAllowHigher = this._state[propIsAllowHigher] && this._state[propSpellLevelMax] !== 9;
		return !isAllowLower && !isAllowHigher;
	}

		static getDefaultFormData ({targetLevel, casterProgression, spellsKnownProgression, spellsKnownProgressionFixed}) {
		const out = [...new Array(9)].map(() => 0);
		let isAnyData = false;

		if (spellsKnownProgression && targetLevel != null && casterProgression) {
			isAnyData = true;
			this._getFormData_handleKnownProgressionGeneric_noChoice(out, {targetLevel, casterProgression, spellsKnownProgression});
		}

		if (spellsKnownProgressionFixed && targetLevel != null && casterProgression) {
			isAnyData = true;
			this._getFormData_handleKnownProgressionFixed_noChoice(out, {targetLevel, casterProgression, spellsKnownProgressionFixed});
		}

		return {
			isFormComplete: true,
			isAnyData,
			data: out,
		};
	}

	getFormData () {
		const out = [...new Array(9)].map(() => 0);
		let isAnyData = false;

		if (this._state.spellsKnownProgression && this._state.targetLevel != null && this._state.casterProgression) {
			isAnyData = true;
			this._getFormData_handleKnownProgressionGeneric(out);
		}

		if (this._state.spellsKnownProgressionFixed && this._state.targetLevel != null && this._state.casterProgression) {
			isAnyData = true;
			this._getFormData_handleKnownProgressionFixed(out);
		}

		return {
			isFormComplete: true,
			isAnyData,
			data: out,
		};
	}

	_getFormData_handleKnownProgressionGeneric (totalKnownPerLevel) {
		if (!this._state.spellsKnownAllowLowerLevel && !this._state.spellsKnownAllowHigherLevel) {
			this.constructor._getFormData_handleKnownProgressionGeneric_noChoice(
				totalKnownPerLevel,
				{
					targetLevel: this._state.targetLevel,
					casterProgression: this._state.casterProgression,
					spellsKnownProgression: this._state.spellsKnownProgression,
				},
			);
		} else this._getFormData_handleKnownProgressionGeneric_choice(totalKnownPerLevel);
	}

	_getFormData_handleKnownProgressionFixed (totalKnownPerLevel) {
		if (!this._state.spellsKnownProgressionFixedAllowLowerLevel && this._state.spellsKnownProgressionFixedAllowHigherLevel) {
			this.constructor._getFormData_handleKnownProgressionFixed_noChoice(
				totalKnownPerLevel,
				{
					targetLevel: this._state.targetLevel,
					casterProgression: this._state.casterProgression,
					spellsKnownProgressionFixed: this._state.spellsKnownProgressionFixed,
				},
			);
		} else this._getFormData_handleKnownProgressionFixed_choice(totalKnownPerLevel);
	}

	static _getFormData_handleKnownProgressionGeneric_noChoice (totalKnownPerLevel, {targetLevel, casterProgression, spellsKnownProgression}) {
		[...new Array(targetLevel)]
			.forEach((_, i) => {
				const maxSpellLevel = Charactermancer_Spell_Util.getCasterProgressionMeta({
					casterProgression: casterProgression,
					curLevel: 0,
					targetLevel: i + 1,
				})?.spellLevelHigh || 0;

				const ixLastSlot = maxSpellLevel - 1;
				if (ixLastSlot < 0) return;

				const prevCntSpells = spellsKnownProgression[i - 1] || 0;
				const curCntSpells = spellsKnownProgression[i] || 0;
				const numSpells = curCntSpells - prevCntSpells;

								totalKnownPerLevel[ixLastSlot] += numSpells;
			});
	}

	_getFormData_handleKnownProgressionGeneric_choice (totalKnownPerLevel) {
		this._getFormData_handleKnownProgression_choice({
			namespace: "generic",
			totalKnownPerLevel,
			propIsAllowLower: "spellsKnownAllowLowerLevel",
			propIsAllowHigher: "spellsKnownAllowHigherLevel",
		});
	}

	static _getFormData_handleKnownProgressionFixed_noChoice (totalKnownPerLevel, {targetLevel, casterProgression, spellsKnownProgressionFixed}) {
		spellsKnownProgressionFixed.slice(0, targetLevel)
			.forEach((lvlFixedValue, i) => {
				const maxSpellLevel = Charactermancer_Spell_Util.getCasterProgressionMeta({
					casterProgression: casterProgression,
					curLevel: 0,
					targetLevel: i + 1,
				})?.spellLevelHigh || 0;

				const ixLastSlot = maxSpellLevel - 1;
				if (ixLastSlot < 0) return;

								totalKnownPerLevel[ixLastSlot] += lvlFixedValue;
			});
	}

	_getFormData_handleKnownProgressionFixed_choice (totalKnownPerLevel) {
		this._getFormData_handleKnownProgression_choice({
			namespace: "fixed",
			totalKnownPerLevel,
			propIsAllowLower: "spellsKnownProgressionFixedAllowLowerLevel",
			propIsAllowHigher: "spellsKnownProgressionFixedAllowHigherLevel",
		});
	}

	_getFormData_handleKnownProgression_choice ({namespace, totalKnownPerLevel, propIsAllowLower, propIsAllowHigher}) {
		const maxOverallSpellLevel = Charactermancer_Spell_Util.getCasterProgressionMeta({
			casterProgression: this._state.casterProgression,
			curLevel: this._state.curLevel,
			targetLevel: this._state.targetLevel,
		})?.spellLevelHigh || 0;

		[...new Array(this._state.targetLevel)]
			.map((_, ixLvl) => {
				const lvl = ixLvl + 1;

				const maxSpellLevel = Charactermancer_Spell_Util.getCasterProgressionMeta({
					casterProgression: this._state.casterProgression,
					curLevel: 0,
					targetLevel: lvl,
				})?.spellLevelHigh || 0;

				const {propCnt} = this.constructor._getPropsLevel(lvl, namespace);

				const numSpells = this._state[propCnt];
				for (let i = 0; i < numSpells; ++i) {
					const {propSpellLevel} = this.constructor._getPropsSpell(lvl, namespace, i);

					let spellLevel = this._state[propSpellLevel];

										if (!this._state[propIsAllowLower]) spellLevel = Math.max(spellLevel, maxSpellLevel);
					if (!this._state[propIsAllowHigher]) spellLevel = Math.min(spellLevel, maxSpellLevel);

										spellLevel = Math.min(spellLevel, maxOverallSpellLevel);

					totalKnownPerLevel[spellLevel - 1]++;
				}
			});
	}

	_getDefaultState () {
		return {
			curLevel: null,
			targetLevel: null,

			casterProgression: null,

			spellsKnownProgression: null,
			spellsKnownAllowLowerLevel: true, 			spellsKnownAllowHigherLevel: true, 
			spellsKnownProgressionFixed: null,
			spellsKnownProgressionFixedAllowLowerLevel: false,
			spellsKnownProgressionFixedAllowHigherLevel: false,

			pulseFixedLearnedProgression: false,
		};
	}
}

class DataConverterClass extends DataConverter {
	static _SIDE_LOAD_OPTS = {
		propBrew: "foundryClass",
		fnLoadJson: async () => this.pPreloadSideData(),
		propJson: "class",
	};

	static _SIDE_LOAD_OPTS_SUBCLASS = {
		propBrew: "foundrySubclass",
		fnLoadJson: async () => this.pPreloadSideData(),
		propJson: "subclass",
		propsMatch: ["classSource", "className", "source", "name"],
	};

	static _IMG_FALLBACK = `modules/${SharedConsts.MODULE_ID}/media/icon/laurels.svg`;

	static init () {
		PageFilterClassesFoundry.setImplSideData("class", this);
		PageFilterClassesFoundry.setImplSideData("subclass", this);
	}

	static _getDoNotUseNote () {
		return UtilDataConverter.pGetWithDescriptionPlugins(() => `<p>${Renderer.get().render(`{@note Note: importing a class as an item is provided for display purposes only. If you wish to import a class to a character sheet, please use the importer on the sheet instead.}`)}</p>`);
	}

		static _getDataHitDice (cls) {
		if (cls.hd?.number !== 1) return null;
		if (!cls.hd?.faces) return null;

		const asString = `d${cls.hd.faces}`;
		if (!CONFIG.DND5E.hitDieTypes.includes(asString)) return null;
		return asString;
	}

	static _getDataSaves (cls) {
		return (cls.proficiency || [])
			.filter(it => Parser.ATB_ABV_TO_FULL[it]);
	}

	static async pGetClassImagePath (cls, {isReturnDefault = true, taskRunner = null} = {}) {
		if (cls.foundryImg) return cls.foundryImg;
		const fromCompendium = await UtilCompendium.pGetCompendiumImage("class", cls, {taskRunner});
		if (fromCompendium) return fromCompendium;
		return isReturnDefault ? `modules/${SharedConsts.MODULE_ID}/media/icon/laurels.svg` : null;
	}

	static async _pGetSubclassImagePath (cls, sc, {taskRunner = null} = {}) {
		if (sc.foundryImg) return sc.foundryImg;
		const fromCompendium = await UtilCompendium.pGetCompendiumImage("subclass", sc, {taskRunner});
		if (fromCompendium) return fromCompendium;
		if (Config.get("importClass", "isUseDefaultSubclassImage")) {
			const fromClass = await this.pGetClassImagePath(cls, {isReturnDefault: false, taskRunner});
			if (fromClass) return fromClass;
		}
		return `modules/${SharedConsts.MODULE_ID}/media/icon/laurels.svg`;
	}

		static async pGetClassItem (cls, opts) {
		opts = opts || {};
		if (opts.actor) opts.isActorItem = true;

		Renderer.get().resetHeaderIndex();

		const itemId = foundry.utils.randomID();

		if (!opts.isClsDereferenced) {
						cls = await DataLoader.pCacheAndGet("class", cls.source, UrlUtil.URL_TO_HASH_BUILDER["class"](cls), {isRequired: true});
		}

		if (opts.pageFilter?.filterBox && opts.filterValues) {
			cls = MiscUtil.copy(cls);

			Renderer.class.mutFilterDereferencedClassFeatures({
				cpyCls: cls,
				pageFilter: opts.pageFilter,
				filterValues: opts.filterValues,
			});
		}

		const srdData = await UtilCompendium.getSrdCompendiumEntity("class", cls, {taskRunner: opts.taskRunner});

		const {name: translatedName, description: translatedDescription, flags: translatedFlags} = this._getTranslationMeta({
			translationData: this._getTranslationData({srdData}),
			name: UtilApplications.getCleanEntityName(UtilDataConverter.getNameWithSourcePart(cls, {isActorItem: opts.isActorItem})),
			description: await this._pGetClassDescription(cls, opts),
		});

		const identifierCls = UtilItem.getNameAsIdentifier(cls.name);

		const img = await Vetools.pOptionallySaveImageToServerAndGetUrl(await this.pGetClassImagePath(cls, {taskRunner: opts.taskRunner}));

		const hitDice = this._getDataHitDice(cls);

		const advancement = [];
		if (
			hitDice != null
		) {
									if (opts.hpAdvancementValue) {
				advancement.push({
					type: "HitPoints",
					value: opts.hpAdvancementValue,
				});
			} else if (!opts.isActorItem) {
												advancement.push({type: "HitPoints"});
			}
		}

		const additionalData = await this._pGetDataSideLoaded(cls);
		const additionalFlags = await this._pGetFlagsSideLoaded(cls);
		const additionalAdvancement = await this._pGetAdvancementSideLoaded(cls);

		const effectsSideTuples = await this._pGetEffectsSideLoadedTuples({ent: cls, img, actor: opts.actor});
		effectsSideTuples.forEach(({effect, effectRaw}) => DataConverter.mutEffectDisabledTransfer(effect, "importClass", UtilActiveEffects.getDisabledTransferHintsSideData(effectRaw)));

		const out = {
			id: itemId,
			_id: itemId,
			name: translatedName,
			type: "class",
			system: {
				identifier: identifierCls,
				description: {value: translatedDescription, chat: "", unidentified: ""},
				source: UtilDataConverter.getSourceWithPagePart(cls),
				levels: opts.level ??
										1,
				hitDice,
				hitDiceUsed: 0,
				spellcasting: {
					progression: UtilActors.getMappedCasterType(cls.casterProgression) || cls.casterProgression,
					ability: cls.spellcastingAbility,
				},
				saves: opts.proficiencyImportMode === Charactermancer_Class_ProficiencyImportModeSelect.MODE_PRIMARY
					? this._getDataSaves(cls)
					: [],
				skills: {
					number: opts.proficiencyImportMode === Charactermancer_Class_ProficiencyImportModeSelect.MODE_MULTICLASS
						? (cls._cntStartingSkillChoicesMutliclass || 0)
						: (cls._cntStartingSkillChoices || 0),
					choices: opts.proficiencyImportMode === Charactermancer_Class_ProficiencyImportModeSelect.MODE_MULTICLASS
						? this._getAllSkillChoices((MiscUtil.get(cls, "multiclassing", "proficienciesGained", "skills") || []))
						: this._getAllSkillChoices((MiscUtil.get(cls, "startingProficiencies", "skills") || [])),
					value: opts.startingSkills,
				},
				advancement: [
					...(srdData?.system?.advancement || [])
						.filter(it => it.type === "ScaleValue"),
					...advancement,
					...(additionalAdvancement || []),
				],

				...additionalData,
			},
			ownership: {default: 0},
			flags: {
				...translatedFlags,
				...this._getClassSubclassFlags({
					cls,
															filterValues: opts.filterValues,
					proficiencyImportMode: opts.proficiencyImportMode,
					isActorItem: opts.isActorItem,
					spellSlotLevelSelection: opts.spellSlotLevelSelection,
				}),
				...additionalFlags,
			},
			effects: DataConverter.getEffectsMutDedupeId(
				[
					await this._pGetPreparedSpellsEffect({
						cls,
						actorId: opts.actor?.id,
						itemId,
						existing: this._getExistingPreparedSpellsEffect({actor: opts.actor}),
						taskRunner: opts.taskRunner,
					}),
					...effectsSideTuples.map(it => it.effect),
				]
					.filter(Boolean),
			),
			img,
		};

		if (opts.defaultOwnership != null) out.ownership = {default: opts.defaultOwnership};
		else if (opts.isAddDefaultOwnershipFromConfig) out.ownership = {default: Config.get("importClass", "ownership")};
		if (opts.userOwnership) Object.assign(out.ownership, opts.userOwnership);

		return out;
	}

	static async _pGetClassDescription (cls, opts) {
		const ptDoNotUse = !opts.isActorItem ? await this._getDoNotUseNote() : "";

		const ptTable = await UtilDataConverter.pGetWithDescriptionPlugins(() => this.pGetRenderedClassTable(cls));

		const ptFluff = cls?.fluff?.length
			? Renderer.get().setFirstSection(true).render({type: cls.fluff[0].type || "section", entries: cls.fluff[0].entries || []})
			: "";

		const ptFeatures = !opts.isActorItem
			? await UtilDataConverter.pGetWithDescriptionPlugins(() => Renderer.get().setFirstSection(true).render({type: "section", entries: cls.classFeatures.flat()}))
			: "";

				if (!Config.get("importClass", "isImportDescription")) return `<div class="mb-2 ve-flex-col">${ptDoNotUse}${ptTable}</div>`;

		return `<div class="mb-2 ve-flex-col">${ptDoNotUse}${ptTable}${ptFluff}${ptFeatures}</div>`;
	}

	static _getClassSubclassFlags ({cls, sc, filterValues, proficiencyImportMode, isActorItem, spellSlotLevelSelection}) {
		const out = {
			[SharedConsts.MODULE_ID]: {
				page: UrlUtil.PG_CLASSES,
				source: sc ? sc.source : cls.source,
				hash: sc ? UrlUtil.URL_TO_HASH_BUILDER["subclass"](sc) : UrlUtil.URL_TO_HASH_BUILDER["class"](cls),

				propDroppable: sc ? "subclass" : "class",
				filterValues,

				isPrimaryClass: proficiencyImportMode === Charactermancer_Class_ProficiencyImportModeSelect.MODE_PRIMARY,

				spellSlotLevelSelection,
			},
		};

		if (isActorItem) out[SharedConsts.MODULE_ID].isDirectImport = true;

		return out;
	}

	static _getAllSkillChoices (skillProfs) {
		const allSkills = new Set();

		skillProfs.forEach(skillProfGroup => {
			Object.keys(Parser.SKILL_TO_ATB_ABV)
				.filter(skill => skillProfGroup[skill])
				.forEach(skill => allSkills.add(skill));

			if (skillProfGroup.choose?.from?.length) {
				skillProfGroup.choose.from
					.filter(skill => Parser.SKILL_TO_ATB_ABV[skill])
					.forEach(skill => allSkills.add(skill));
			}
		});

		return Object.entries(UtilActors.SKILL_ABV_TO_FULL)
			.filter(([, vetKey]) => allSkills.has(vetKey))
			.map(([fvttKey]) => fvttKey);
	}

		static async pGetSubclassItem (cls, sc, opts) {
		opts = opts || {};
		if (opts.actor) opts.isActorItem = true;

		Renderer.get().resetHeaderIndex();

		const itemId = foundry.utils.randomID();

		if (!opts.isScDereferenced) {
						sc = await DataLoader.pCacheAndGet("subclass", sc.source, UrlUtil.URL_TO_HASH_BUILDER["subclass"](sc));
		}

		if (opts.pageFilter?.filterBox && opts.filterValues) {
			sc = MiscUtil.copy(sc);

			Renderer.class.mutFilterDereferencedSubclassFeatures({
				cpySc: sc,
				pageFilter: opts.pageFilter,
				filterValues: opts.filterValues,
			});
		}

		const srdData = await UtilCompendium.getSrdCompendiumEntity("subclass", sc, {taskRunner: opts.taskRunner});

		const {name: translatedName, description: translatedDescription, flags: translatedFlags} = this._getTranslationMeta({
			translationData: this._getTranslationData({srdData}),
			name: UtilApplications.getCleanEntityName(UtilDataConverter.getNameWithSourcePart(sc, {isActorItem: opts.isActorItem})),
			description: await this._pGetSubclassDescription(cls, sc, opts),
		});

		const identifierCls = UtilItem.getNameAsIdentifier(cls.name);
		const identifierSc = UtilItem.getNameAsIdentifier(sc.name);

				const img = await Vetools.pOptionallySaveImageToServerAndGetUrl(await this._pGetSubclassImagePath(cls, sc, {taskRunner: opts.taskRunner}));

		const additionalData = await this._pGetDataSideLoaded(sc, {propOpts: "_SIDE_LOAD_OPTS_SUBCLASS"});
		const additionalFlags = await this._pGetFlagsSideLoaded(sc, {propOpts: "_SIDE_LOAD_OPTS_SUBCLASS"});
		const additionalAdvancement = await this._pGetAdvancementSideLoaded(sc, {propOpts: "_SIDE_LOAD_OPTS_SUBCLASS"});

		const effectsSideTuples = await this._pGetEffectsSideLoadedTuples({ent: sc, img, actor: opts.actor}, {propOpts: "_SIDE_LOAD_OPTS_SUBCLASS"});
		effectsSideTuples.forEach(({effect, effectRaw}) => DataConverter.mutEffectDisabledTransfer(effect, "importClass", UtilActiveEffects.getDisabledTransferHintsSideData(effectRaw)));

		const out = {
			id: itemId,
			_id: itemId,
			name: translatedName,
			type: "subclass",
			system: {
				identifier: identifierSc,
				classIdentifier: identifierCls,
				description: {value: translatedDescription, chat: "", unidentified: ""},
				source: UtilDataConverter.getSourceWithPagePart(sc),
				spellcasting: {
					progression: UtilActors.getMappedCasterType(sc.casterProgression) || sc.casterProgression,
					ability: sc.spellcastingAbility,
				},
				advancement: [
					...(srdData?.system?.advancement || [])
						.filter(it => it.type === "ScaleValue"),
					...(additionalAdvancement || []),
				],

				...additionalData,
			},
			ownership: {default: 0},
			flags: {
				...translatedFlags,
				...this._getClassSubclassFlags({
					cls,
					sc,
					filterValues: opts.filterValues,
					proficiencyImportMode: opts.proficiencyImportMode,
					isActorItem: opts.isActorItem,
				}),
				...additionalFlags,
			},
			effects: DataConverter.getEffectsMutDedupeId(
				[
					await this._pGetPreparedSpellsEffect({
						cls,
						sc,
						actorId: opts.actor?.id,
						itemId,
						existing: this._getExistingPreparedSpellsEffect({actor: opts.actor}),
						taskRunner: opts.taskRunner,
					}),
					...effectsSideTuples.map(it => it.effect),
				]
					.filter(Boolean),
			),
			img,
		};

		if (opts.defaultOwnership != null) out.ownership = {default: opts.defaultOwnership};
		else if (opts.isAddDefaultOwnershipFromConfig) out.ownership = {default: Config.get("importClass", "ownership")};
		if (opts.userOwnership) Object.assign(out.ownership, opts.userOwnership);

		return out;
	}

	static async _pGetSubclassDescription (cls, sc, opts) {
		const ptDoNotUse = !opts.isActorItem ? await this._getDoNotUseNote() : "";

				const fluff = MiscUtil.copy(Renderer.findEntry(sc.subclassFeatures || {}));

		const cleanEntries = MiscUtil.getWalker({keyBlocklist: MiscUtil.GENERIC_WALKER_ENTRIES_KEY_BLOCKLIST})
			.walk(
				MiscUtil.copy(fluff.entries),
				{
					array: (arr) => {
						return arr.filter(it => !it?.data?.isFvttSyntheticFeatureLink);
					},
				},
			);

				const ptFluff = opts.isActorItem
			? Renderer.get().setFirstSection(true).render({type: "entries", entries: cleanEntries})
			: "";
		
		const ptFeatures = !opts.isActorItem
			? await UtilDataConverter.pGetWithDescriptionPlugins(() => Renderer.get().setFirstSection(true).render({type: "section", entries: sc.subclassFeatures.flat()}))
			: "";

				if (!Config.get("importClass", "isImportDescription")) return `<div class="mb-2 ve-flex-col">${ptDoNotUse}</div>`;

		return `<div class="mb-2 ve-flex-col">${ptDoNotUse}${ptFluff}${ptFeatures}</div>`;
	}

	static async pPreloadSideData () {
		if (!DataConverterClass._SIDE_DATA) DataConverterClass._SIDE_DATA = await Vetools.pGetClassSubclassSideData();
		return DataConverterClass._SIDE_DATA;
	}

	static async pGetSideLoadedMatch (entity, {prop, isSilent = false} = {}) {
		if (!entity) return null;

		const prerelease = await PrereleaseUtil.pGetBrewProcessed();
		const brew = await BrewUtil2.pGetBrewProcessed();

		switch (prop) {
			case "class": {
				let found = [
					...(MiscUtil.get(prerelease, "foundryClass") || []),
					...(MiscUtil.get(brew, "foundryClass") || []),
				]
					.find(it => it.name === entity.name && it.source === entity.source);

				if (!found) {
					const additionalData = await this.pPreloadSideData();
					found = (additionalData.class || []).find(it => it.name === entity.name && it.source === entity.source);
				}

				if (!found) return null;
				return found;
			}

			case "subclass": {
				let found = [
					...(MiscUtil.get(prerelease, "foundrySubclass") || []),
					...(MiscUtil.get(brew, "foundrySubclass") || []),
				]
					.find(it => it.name === entity.name && it.source === entity.source && it.className === entity.className && it.classSource === entity.classSource);

				if (!found) {
					const additionalData = await this.pPreloadSideData();
					found = (additionalData.subclass || []).find(it => it.name === entity.name && it.source === entity.source && it.className === entity.className && it.classSource === entity.classSource);
				}

				if (!found) return null;
				return found;
			}

			default: throw new Error(`Unhandled prop "${prop}"`);
		}
	}

		static async pGetRenderedClassTable (cls, sc, opts = {}) {
		if (!Config.get("importClass", "isImportClassTable")) return "";

		return UtilDataConverter.pGetWithDescriptionPlugins(async () => {
						cls = await DataLoader.pCacheAndGet("class", cls.source, UrlUtil.URL_TO_HASH_BUILDER["class"](cls));

			if (sc) {
				sc = await DataLoader.pCacheAndGet("subclass", sc.source, UrlUtil.URL_TO_HASH_BUILDER["subclass"](sc));
			}
			
			return this.getRenderedClassTableFromDereferenced(cls, sc, opts);
		});
	}

	static getRenderedClassTableFromDereferenced (cls, sc, {isAddHeader = false, isSpellsOnly = false} = {}) {
		if (!cls) return "";

		return Vetools.withUnpatchedDiceRendering(() => {
			Renderer.get().setFirstSection(true).resetHeaderIndex();

			const tblGroupHeaders = [];
			const tblHeaders = [];

			const renderTableGroupHeader = (tableGroup) => {
								let thGroupHeader;
				if (tableGroup.title) {
					thGroupHeader = `<th class="cls-tbl__col-group" colspan="${tableGroup.colLabels.length}">${tableGroup.title}</th>`;
				} else {
										thGroupHeader = `<th colspan="${tableGroup.colLabels.length}"></th>`;
				}
				tblGroupHeaders.push(thGroupHeader);

								tableGroup.colLabels.forEach(lbl => {
					tblHeaders.push(`<th class="cls-tbl__col-generic-center"><div class="cls__squash_header">${Renderer.get().render(lbl)}</div></th>`);
				});
			};

			if (cls.classTableGroups) {
				cls.classTableGroups.forEach(tableGroup => {
					if (isSpellsOnly) tableGroup = this._getRenderedClassTableFromDereferenced_getSpellsOnlyTableGroup(tableGroup);
					if (!tableGroup) return;
					renderTableGroupHeader(tableGroup);
				});
			}

			if (sc?.subclassTableGroups) {
				sc.subclassTableGroups.forEach(tableGroup => {
					if (isSpellsOnly) tableGroup = this._getRenderedClassTableFromDereferenced_getSpellsOnlyTableGroup(tableGroup);
					if (!tableGroup) return;
					renderTableGroupHeader(tableGroup);
				});
			}

			const tblRows = cls.classFeatures.map((lvlFeatures, ixLvl) => {
				const pb = Math.ceil((ixLvl + 1) / 4) + 1;

				const lvlFeaturesFilt = lvlFeatures
					.filter(it => it.name && it.type !== "inset"); 
				const dispsFeatures = lvlFeaturesFilt
					.map((it, ixFeature) => `<div class="inline-block">${it.name}${ixFeature === lvlFeaturesFilt.length - 1 ? "" : `<span class="mr-1">,</span>`}</div>`);

				const ptTableGroups = [];

				const renderTableGroupRow = (tableGroup) => {
					const row = (tableGroup.rowsSpellProgression || tableGroup.rows)[ixLvl] || [];
					const cells = row.map(cell => `<td class="cls-tbl__col-generic-center">${cell === 0 ? "\u2014" : Renderer.get().render(cell)}</td>`);
					ptTableGroups.push(...cells);
				};

				if (cls.classTableGroups) {
					cls.classTableGroups.forEach(tableGroup => {
						if (isSpellsOnly) tableGroup = this._getRenderedClassTableFromDereferenced_getSpellsOnlyTableGroup(tableGroup);
						if (!tableGroup) return;
						renderTableGroupRow(tableGroup);
					});
				}

				if (sc?.subclassTableGroups) {
					sc.subclassTableGroups.forEach(tableGroup => {
						if (isSpellsOnly) tableGroup = this._getRenderedClassTableFromDereferenced_getSpellsOnlyTableGroup(tableGroup);
						if (!tableGroup) return;
						renderTableGroupRow(tableGroup);
					});
				}

				return `<tr class="cls-tbl__stripe-odd">
					<td class="cls-tbl__col-level">${Parser.getOrdinalForm(ixLvl + 1)}</td>
					${isSpellsOnly ? "" : `<td class="cls-tbl__col-prof-bonus">+${pb}</td>`}
					${isSpellsOnly ? "" : `<td>${dispsFeatures.join("") || `\u2014`}</td>`}
					${ptTableGroups.join("")}
				</tr>`;
			});

						return `<table class="cls-tbl shadow-big w-100 mb-3">
				<tbody>
				<tr><th class="border" colspan="15"></th></tr>
				${isAddHeader ? `<tr><th class="cls-tbl__disp-name" colspan="15">${cls.name}</th></tr>` : ""}
				<tr>
					<th colspan="${isSpellsOnly ? "1" : "3"}"></th>
					${tblGroupHeaders.join("")}
				</tr>
				<tr>
					<th class="cls-tbl__col-level">Level</th>
					${isSpellsOnly ? "" : `<th class="cls-tbl__col-prof-bonus">Proficiency Bonus</th>`}
					${isSpellsOnly ? "" : `<th>Features</th>`}
					${tblHeaders.join("")}
				</tr>
				${tblRows.join("")}
				<tr><th class="border" colspan="15"></th></tr>
				</tbody>
			</table>`;
		});
	}

	static _getRenderedClassTableFromDereferenced_getSpellsOnlyTableGroup (tableGroup) {
		tableGroup = MiscUtil.copy(tableGroup);

		if (/spell/i.test(`${tableGroup.title || ""}`)) return tableGroup;

		if (!tableGroup.colLabels) return null;

		const ixsSpellLabels = new Set(tableGroup.colLabels
			.map((it, ix) => {
				const stripped = Renderer.stripTags(`${it || ""}`);
				return /cantrip|spell|slot level/i.test(stripped) ? ix : null;
			})
			.filter(ix => ix != null));

		if (!ixsSpellLabels.size) return null;

		tableGroup.colLabels = tableGroup.colLabels.filter((_, ix) => ixsSpellLabels.has(ix));
		if (tableGroup.rowsSpellProgression) tableGroup.rowsSpellProgression = tableGroup.rowsSpellProgression.map(row => row.filter((_, ix) => ixsSpellLabels.has(ix)));
		if (tableGroup.rows) tableGroup.rows = tableGroup.rows.map(row => row.filter((_, ix) => ixsSpellLabels.has(ix)));

		return tableGroup;
	}

	static _getExistingPreparedSpellsEffect ({actor}) {
		if (!actor) return null;
		return actor.effects.contents.find(it => (it.name || "").toLowerCase().trim() === "prepared spells");
	}

	static async _pGetPreparedSpellsEffect ({cls, sc, actorId, itemId, existing, taskRunner}) {
		if (existing) return null;
		if (sc && !sc.preparedSpells) return null;
		if (!sc && !cls.preparedSpells) return null;

				const spellsPreparedFormula = Charactermancer_Spell_Util.getMaxPreparedSpellsFormula({cls, sc});
		if (!spellsPreparedFormula) return null;

		return UtilActiveEffects.getGenericEffect({
			key: `flags.${UtilCompat.MODULE_TIDY5E_SHEET}.maxPreparedSpells`,
			value: spellsPreparedFormula,
									mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
			name: `Prepared Spells`,
			icon: await Vetools.pOptionallySaveImageToServerAndGetUrl(await this.pGetClassImagePath(cls, {taskRunner})),
			disabled: false,
			priority: UtilActiveEffects.PRIORITY_BASE,
			originActorId: actorId,
			originActorItemId: itemId,
		});
			}

	static isStubClass (cls) {
		if (!cls) return false;
		return cls.name === DataConverterClass.STUB_CLASS.name && cls.source === DataConverterClass.STUB_CLASS.source;
	}

	static isStubSubclass (sc) {
		if (!sc) return false;
		return sc.name === DataConverterClass.STUB_SUBCLASS.name && sc.source === DataConverterClass.STUB_SUBCLASS.source;
	}

	static getClassStub () {
		const out = MiscUtil.copy(DataConverterClass.STUB_CLASS);
		out.subclasses = [
			{
				...MiscUtil.copy(DataConverterClass.STUB_SUBCLASS),
				className: out.name,
				classSource: out.source,
			},
		];
		return out;
	}

	static getSubclassStub ({cls}) {
		const out = MiscUtil.copy(DataConverterClass.STUB_SUBCLASS);
		out.className = cls.name;
		out.classSource = cls.source;
		return out;
	}
}
DataConverterClass._SIDE_DATA = null;

DataConverterClass.STUB_CLASS = {
	name: "Unknown Class",
	source: Parser.SRC_PHB,
	classFeatures: [],
	_isStub: true,
};
DataConverterClass.STUB_SUBCLASS = {
	name: "Unknown Subclass",
	source: Parser.SRC_PHB,
	subclassFeatures: [],
	_isStub: true,
};

var DataConverterClass$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DataConverterClass: DataConverterClass
});

class DataConverterClassSubclassFeature extends DataConverterFeature {
	static _getSideLoadOpts (feature) {
		return {
			propBrew: this._getBrewProp(feature),
			fnLoadJson: Vetools.pGetClassSubclassSideData,
			propJson: this._getEntityType(feature),
			propsMatch: ["classSource", "className", "subclassSource", "subclassShortName", "level", "source", "name"],
		};
	}

	static init () {
		PageFilterClassesFoundry.setImplSideData("classFeature", this);
		PageFilterClassesFoundry.setImplSideData("subclassFeature", this);
	}

	static async pGetDereferencedFeatureItem (feature) {
		const type = this._getEntityType(feature);
		const hash = UrlUtil.URL_TO_HASH_BUILDER[type](feature);
						return DataLoader.pCacheAndGet(type, feature.source, hash, {isCopy: true});
	}

	static async pGetInitFeatureLoadeds (feature, {actor = null} = {}) {
		const isIgnoredLookup = await this._pGetInitFeatureLoadeds_getIsIgnoredLookup(feature);

		const type = this._getEntityType(feature);
		switch (type) {
			case "classFeature": {
				const uid = DataUtil.class.packUidClassFeature(feature);
				const asClassFeatureRef = {classFeature: uid};
				await PageFilterClassesFoundry.pInitClassFeatureLoadeds({classFeature: asClassFeatureRef, className: feature.className, actor, isIgnoredLookup});
				return asClassFeatureRef;
			}
			case "subclassFeature": {
				const uid = DataUtil.class.packUidSubclassFeature(feature);
				const asSubclassFeatureRef = {subclassFeature: uid};
				const subclassNameLookup = await DataUtil.class.pGetSubclassLookup();
				const subclassName = MiscUtil.get(subclassNameLookup, feature.classSource, feature.className, feature.subclassSource, feature.subclassShortName);
				await PageFilterClassesFoundry.pInitSubclassFeatureLoadeds({subclassFeature: asSubclassFeatureRef, className: feature.className, subclassName: subclassName, actor, isIgnoredLookup});
				return asSubclassFeatureRef;
			}
			default: throw new Error(`Unhandled feature type "${type}"`);
		}
	}

	static async _pGetInitFeatureLoadeds_getIsIgnoredLookup (feature) {
		if (!feature.entries) return {};

		const type = this._getEntityType(feature);
		switch (type) {
			case "classFeature": {
				return this.pGetClassSubclassFeatureIgnoredLookup({data: {classFeature: [feature]}});
			}
			case "subclassFeature": {
				return this.pGetClassSubclassFeatureIgnoredLookup({data: {subclassFeature: [feature]}});
			}
			default: throw new Error(`Unhandled feature type "${type}"`);
		}
	}

	static async pGetClassSubclassFeatureIgnoredLookup ({data}) {
		if (!data.classFeature?.length && !data.subclassFeature?.length) return {};

		const isIgnoredLookup = {};

		const allRefsClassFeature = new Set();
		const allRefsSubclassFeature = new Set();

		(data.classFeature || []).forEach(cf => {
			const {refsClassFeature, refsSubclassFeature} = Charactermancer_Class_Util.getClassSubclassFeatureReferences(cf.entries);

			refsClassFeature.forEach(ref => allRefsClassFeature.add((ref.classFeature || "").toLowerCase()));
			refsSubclassFeature.forEach(ref => allRefsSubclassFeature.add((ref.subclassFeature || "").toLowerCase()));
		});

		(data.subclassFeature || []).forEach(scf => {
			const {refsClassFeature, refsSubclassFeature} = Charactermancer_Class_Util.getClassSubclassFeatureReferences(scf.entries);

			refsClassFeature.forEach(ref => allRefsClassFeature.add((ref.classFeature || "").toLowerCase()));
			refsSubclassFeature.forEach(ref => allRefsSubclassFeature.add((ref.subclassFeature || "").toLowerCase()));
		});

		for (const uid of allRefsClassFeature) {
			if (await this._pGetIsIgnoredSideLoaded(DataUtil.class.unpackUidClassFeature(uid))) {
				isIgnoredLookup[uid] = true;
			}
		}

		for (const uid of allRefsSubclassFeature) {
			if (await this._pGetIsIgnoredSideLoaded(DataUtil.class.unpackUidSubclassFeature(uid))) {
				isIgnoredLookup[uid] = true;
			}
		}

		return isIgnoredLookup;
	}

		static async pGetDocumentJson (feature, opts) {
		opts = opts || {};
		if (opts.actor) opts.isActorItem = true;

		Renderer.get().resetHeaderIndex();

		const out = await this._pGetClassSubclassFeatureItem(feature, opts);

		const additionalData = await this._pGetDataSideLoaded(feature);
		Object.assign(out.system, additionalData);

		const additionalFlags = await this._pGetFlagsSideLoaded(feature);
		Object.assign(out.flags, additionalFlags);

		if (opts.defaultOwnership != null) out.ownership = {default: opts.defaultOwnership};
		else if (opts.isAddDefaultOwnershipFromConfig) out.ownership = {default: Config.get("importClassSubclassFeature", "ownership")};
		if (opts.userOwnership) Object.assign(out.ownership, opts.userOwnership);

		return out;
	}

	static async _pGetPreloadSideData () {
		if (!this._SIDE_DATA) this._SIDE_DATA = await Vetools.pGetClassSubclassSideData();
		return this._SIDE_DATA;
	}

	static _isUnarmoredDefense (feature) {
		const cleanLowerName = (feature.name || "").toLowerCase().trim();
		return /^unarmored defen[sc]e/.test(cleanLowerName);
	}

	static _getUnarmoredDefenseMeta (entity) {
		if (!entity.entries) return null;

		const attribs = new Set();

		JSON.stringify(entity.entries).replace(/(strength|dexterity|constitution|intelligence|wisdom|charisma|str|dex|con|int|wis|cha) modifier/gi, (fullMatch, ability) => {
			ability = ability.slice(0, 3).toLowerCase();
			attribs.add(ability);
		});

		const predefinedKey = CollectionUtil.setEq(DataConverterClassSubclassFeature._UNARMORED_DEFENSE_BARBARIAN, attribs) ? "unarmoredBarb" : CollectionUtil.setEq(DataConverterClassSubclassFeature._UNARMORED_DEFENSE_MONK, attribs) ? "unarmoredMonk" : null;

		return {
			formula: ["10", ...[...attribs].map(ab => `@abilities.${ab}.mod`)].join(" + "),
			abilities: [...attribs],
			predefinedKey,
		};
	}

	static async _pGetClassSubclassFeatureItem (feature, opts) {
		opts = opts || {};

		let {type = null, actor} = opts;
		type = type || this._getEntityType(feature);

		let pOut;
		if (await this._pIsInSrd(feature, type, opts)) {
			pOut = this._pGetClassSubclassFeatureItem_fromSrd(feature, type, actor, opts);
		} else {
			pOut = this._pGetClassSubclassFeatureItem_other(feature, type, actor, opts);
		}
		return pOut;
	}

	static _getEntityType (feature) {
		if (feature.subclassShortName) return "subclassFeature";
		if (feature.className) return "classFeature";
		return null;
	}

	static _getBrewProp (feature) {
		const type = this._getEntityType(feature);
		switch (type) {
			case "classFeature": return "foundryClassFeature";
			case "subclassFeature": return "foundrySubclassFeature";
			default: throw new Error(`Unhandled feature type "${type}"`);
		}
	}

	static async _pIsInSrd (feature, type, {taskRunner = null} = {}) {
		const srdData = await UtilCompendium.getSrdCompendiumEntity(type, feature, {fnGetAliases: this._getCompendiumAliases, taskRunner});
		return !!srdData;
	}

	static async _pGetClassSubclassFeatureItem_fromSrd (feature, type, actor, opts = {}) {
		const srdData = await UtilCompendium.getSrdCompendiumEntity(type, feature, {fnGetAliases: this._getCompendiumAliases, taskRunner: opts.taskRunner});

		const {name: translatedName, description: translatedDescription, flags: translatedFlags} = this._getTranslationMeta({
			translationData: this._getTranslationData({srdData}),
			name: UtilApplications.getCleanEntityName(UtilDataConverter.getNameWithSourcePart(feature, {isActorItem: actor != null})),
			description: await this.pGetEntryDescription(feature),
		});

		const img = await this._pGetSaveImagePath(feature, {propCompendium: type, taskRunner: opts.taskRunner});

		const dataConsume = this._getData_getConsume({ent: feature, actor: opts.actor});

		const srdEffects = await this._pIsIgnoreSrdEffectsSideLoaded(feature) ? [] : MiscUtil.copy(srdData.effects || []);
		DataConverter.mutEffectsDisabledTransfer(srdEffects, "importClassSubclassFeature");

		const effectsSideTuples = UtilActiveEffects.getExpandedEffects(feature.effectsRaw, {actor, img, parentName: feature.name}, {isTuples: true});
		effectsSideTuples.forEach(({effect, effectRaw}) => DataConverter.mutEffectDisabledTransfer(effect, "importClassSubclassFeature", UtilActiveEffects.getDisabledTransferHintsSideData(effectRaw)));

		return {
			name: translatedName,
			type: srdData.type,
			system: {
				...srdData.system,

				source: UtilDataConverter.getSourceWithPagePart(feature),
				description: {value: translatedDescription, chat: "", unidentified: ""},
				consume: dataConsume,

				...(feature.foundryAdditionalSystem || {}),
			},
			ownership: {default: 0},
			effects: DataConverter.getEffectsMutDedupeId([
				...srdEffects,
				...effectsSideTuples.map(it => it.effect),
			]),
			flags: {
				...translatedFlags,
				...this._getClassSubclassFeatureFlags(feature, type, opts),
				...(feature.foundryAdditionalFlags || {}),
			},
			img,
		};
	}

	static _getClassSubclassFeatureFlags (feature, type, opts) {
		opts = opts || {};

		const prop = this._getEntityType(feature);

		const out = {
			[SharedConsts.MODULE_ID]: {
				page: prop,
				source: feature.source,
				hash: UrlUtil.URL_TO_HASH_BUILDER[prop](feature),
			},
		};

		if (opts.isAddDataFlags) {
			out[SharedConsts.MODULE_ID].propDroppable = prop;
			out[SharedConsts.MODULE_ID].filterValues = opts.filterValues;
		}

		return out;
	}

	static async _pGetClassSubclassFeatureItem_other (feature, type, actor, opts) {
		const dataConsume = this._getData_getConsume({ent: feature, actor: opts.actor});

		const img = await this._pGetSaveImagePath(feature, {propCompendium: type, taskRunner: opts.taskRunner});

		const effectsSideTuples = UtilActiveEffects.getExpandedEffects(feature.effectsRaw, {actor, img, parentName: feature.name}, {isTuples: true});
		effectsSideTuples.forEach(({effect, effectRaw}) => DataConverter.mutEffectDisabledTransfer(effect, "importClassSubclassFeature", UtilActiveEffects.getDisabledTransferHintsSideData(effectRaw)));

		return this.pGetItemActorPassive(
			feature,
			{
				mode: "player",
				modeOptions: {
					isChannelDivinity: feature.className === "Cleric" && feature.name.toLowerCase().startsWith("channel divinity:"),
				},
				renderDepth: 0,
				fvttType: "feat",
				img,
				fvttSource: UtilDataConverter.getSourceWithPagePart(feature),
				requirements: [feature.className, feature.level, feature.subclassShortName ? `(${feature.subclassShortName})` : ""].filter(Boolean).join(" "),
				additionalData: feature.foundryAdditionalSystem,
				foundryFlags: this._getClassSubclassFeatureFlags(feature, type, opts),
				additionalFlags: feature.foundryAdditionalFlags,
				effects: DataConverter.getEffectsMutDedupeId(effectsSideTuples.map(it => it.effect)),
				actor,
				consumeType: dataConsume.type,
				consumeTarget: dataConsume.target,
				consumeAmount: dataConsume.amount,
			},
		);
	}

	static _getCompendiumAliases (entity) {
		if (!entity.name) return [];

		const out = [];

		const lowName = entity.name.toLowerCase().trim();

		const noBrackets = entity.name
			.replace(/\([^)]+\)/g, "")
			.replace(/\s+/g, " ")
			.trim();
		if (noBrackets !== entity.name) out.push(noBrackets);

		const splitColon = entity.name.split(":")[0].trim();
		const isSplitColonName = splitColon !== entity.name;
		if (isSplitColonName) {
			out.push(splitColon);

						if (DataConverterClassSubclassFeature._FEATURE_SRD_ASLIAS_WITH_CLASSNAME.has(splitColon.toLowerCase())) {
				out.push(`${splitColon} (${entity.className})`);
			}
		}

		if (DataConverterClassSubclassFeature._FEATURE_SRD_ASLIAS_WITH_CLASSNAME.has(lowName)) {
			out.push(`${entity.name} (${entity.className})`);
		}

		if (lowName.startsWith("mystic arcanum")) {
			out.push(`${noBrackets} (${((entity.level - 9) / 2) + 5}th-Level Spell)`);
		}

		if (!isSplitColonName) {
			out.push(`Channel Divinity: ${entity.name}`);
			out.push(`Ki: ${entity.name}`);
		}

		return out;
	}
}

DataConverterClassSubclassFeature._FEATURE_SRD_ASLIAS_WITH_CLASSNAME = new Set([
	"unarmored defense",
	"channel divinity",
	"expertise",
	"land's stride",
	"timeless body",
	"spellcasting",
]);

DataConverterClassSubclassFeature._UNARMORED_DEFENSE_BARBARIAN = new Set(["dex", "con"]);
DataConverterClassSubclassFeature._UNARMORED_DEFENSE_MONK = new Set(["dex", "wis"]);

var DataConverterClassSubclassFeature$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DataConverterClassSubclassFeature: DataConverterClassSubclassFeature
});

class Charactermancer_StartingEquipment extends Application {
		static prePreInit () {
		this._preInit_registerKeybinds();
	}

	static _preInit_registerKeybinds () {
		const doKeybindingOpenForCharacter = () => {
			const actor = UtilKeybinding.getPlayerActor({minRole: Config.get("equipmentShop", "minimumRole")});
			if (!actor) return true;
			this._pOpen({actor});
			return true;
		};

		const doKeybindingOpenForCurrentSheet = () => {
			const meta = UtilKeybinding.getCurrentImportableSheetDocumentMeta({isRequireActor: true, isRequireOwnership: true, minRole: Config.get("equipmentShop", "minimumRole")});
			if (!meta?.actor) return true;
			this._pOpen({...meta});
			return true;
		};

		game.keybindings.register(
			SharedConsts.MODULE_ID,
			"Charactermancer_StartingEquipment__openForCharacter",
			{
				name: "Open Equipment Shop Targeting Player Character",
				editable: [],
				onDown: () => doKeybindingOpenForCharacter(),
			},
		);

		game.keybindings.register(
			SharedConsts.MODULE_ID,
			"Charactermancer_StartingEquipment__openForCurrentSheet",
			{
				name: "Open Equipment Shop Targeting Current Sheet",
				editable: [],
				onDown: () => doKeybindingOpenForCurrentSheet(),
			},
		);
	}

	static init () {
						UtilHooks.on(UtilHooks.HK_CONFIG_UPDATE, async (diff) => {
			if (!diff) return;

			const prev = MiscUtil.get(diff, "previous", "equipmentShop");
			const curr = MiscUtil.get(diff, "current", "equipmentShop");

			if (!prev || !curr) return;

			if (CollectionUtil.deepEquals(prev, curr)) return;

			const toClose = Object.values(ui.windows)
				.filter(it => it.constructor === Charactermancer_StartingEquipment);
			if (!toClose.length) return;

			if (!await (InputUiUtil.pGetUserBoolean({
				title: `Existing Shop Windows`,
				htmlDescription: `You have ${toClose.length === 1 ? `an existing shop window` : `existing shop windows`} open, which will not be affected by your updated Equipment Shop config.<br>Would you like to close ${toClose.length === 1 ? "this window" : "these windows"}?`,
				textYes: "Yes",
				textNo: "No",
			}))) return;

			toClose.forEach(it => it.close());
		});
	}

	static async pHandleButtonClick (evt, app, $html, data) {
		return this._pOpen({actor: app.actor});
	}

	static async _pOpen ({actor}) {
		const instance = new this({
			actor,
			isStandalone: true,
		});

		const formData = await instance.pWaitForUserInput();

		if (!formData) return;
		if (formData === VeCt.SYM_UI_SKIP) return; 
		await this.pImportEquipmentItemEntries(actor, formData);
		await this.pUpdateActorCurrency(actor, formData);
	}

	static async pImportEquipmentItemEntries (actor, formData, {taskRunner = null} = {}) {
		if (!formData?.data?.equipmentItemEntries?.length) return;
		const {ImportListItem} = await Promise.resolve().then(function () { return ImportListItem$1; });
		const importListItem = new ImportListItem({actor: actor});
		await importListItem.pInit();
		for (const it of formData.data.equipmentItemEntries) {
			if (it.item && it.name == null && it.source == null) {
				await importListItem.pImportEntry(
					it.item,
					{taskRunner},
					{quantity: it.quantity || 1},
				);
			} else await importListItem.pImportEntry(it, {taskRunner});
		}
	}

	static async pUpdateActorCurrency (actor, formData) {
		if (!formData?.data?.currency) return;

		await UtilDocuments.pUpdateDocument(
			actor,
			{
				system: {
					currency: formData.data.currency,
				},
			},
		);
	}

		static getComponents (actor, opts) {
		opts = opts || {};

		const compCurrency = actor ? Charactermancer_StartingEquipment.Currency.fromActor(actor) : new Charactermancer_StartingEquipment.Currency();
		compCurrency.init();

		const compDefault = new Charactermancer_StartingEquipment.ComponentDefault({compCurrency, actor, fnDoShowShop: opts.fnDoShowShop});
		const compGold = new Charactermancer_StartingEquipment.ComponentGold({compCurrency, actor, itemDatas: opts.itemDatas});

		return {
			compCurrency,
			compDefault,
			compGold,
		};
	}
	
		constructor (opts) {
		opts = opts || {};

		const compCurrency = opts.actor
			? Charactermancer_StartingEquipment.Currency.fromActor(opts.actor, {isStandalone: !!opts.isStandalone})
			: new Charactermancer_StartingEquipment.Currency({isStandalone: !!opts.isStandalone});
		const compDefault = new Charactermancer_StartingEquipment.ComponentDefault({...opts, compCurrency, fnDoShowShop: () => { this._mode = "gold"; this._doHandleModeSwitch(); }});
		const compGold = new Charactermancer_StartingEquipment.ComponentGold({...opts, compCurrency});

				if (opts.startingEquipment) compCurrency.startingEquipment = opts.startingEquipment;
		if (opts.equiSpecialSource) compDefault.equiSpecialSource = opts.equiSpecialSource;
		if (opts.equiSpecialPage) compDefault.equiSpecialPage = opts.equiSpecialPage;
		
		super({
			title: `${compCurrency.rollableExpressionGold ? `Starting ` : ""}Equipment${opts.appSubTitle ? `\u2014${opts.appSubTitle}` : ""}${opts.actor ? ` (Actor "${opts.actor.name}")` : ""}`,
			template: `${SharedConsts.MODULE_LOCATION}/template/ImportListCharacterEquipment.hbs`,
			width: Util.getMaxWindowWidth(1000),
			height: Util.getMaxWindowHeight(),
			resizable: true,
		});

		this._compCurrency = compCurrency;
		this._compDefault = compDefault;
		this._compGold = compGold;

		this._isStandalone = opts.isStandalone;

		this._cntModesAvailable = Number(this._compDefault.isAvailable) + Number(this._compGold.isAvailable);

		if (this._cntModesAvailable) {
			this._resolve = null;
			this._reject = null;
			this._pUserInput = new Promise((resolve, reject) => {
				this._resolve = resolve;
				this._reject = reject;
			});
		}

		this._mode = null;
		this._$wrpTabs = null;
		this._$btnShowTabStandard = null;
		this._$btnShowTabGoldAlternative = null;
	}

	async _pResolveAndClose (resolveAs) {
		this._resolve(resolveAs);
		await this.close();
	}

	activateListeners ($html) {
		if (!this._cntModesAvailable) return; 
		const activeComps = [this._compDefault, this._compGold].filter(it => it.isAvailable);

		if (this._cntModesAvailable === 2) {
			this._mode = this._compCurrency.cpRolled ? "gold" : "default";

			this._$wrpTabs = activeComps.map(it => {
				const $wrpTab = $(`<div class="w-100 h-100 min-h-0 ve-flex-col"></div>`).hideVe();
				this._activateListeners_renderTab($wrpTab, it);
				return $wrpTab;
			});

			this._$btnShowTabStandard = $(`<button class="btn btn-default w-50 btn-5et">${this._compCurrency.rollableExpressionGold ? `Standard Starting Equipment` : `Starting Equipment`}</button>`)
				.click(() => {
					this._mode = "default";
					this._doHandleModeSwitch();
				});

			this._$btnShowTabGoldAlternative = $(`<button class="btn btn-default w-50 btn-5et">${this._compCurrency.rollableExpressionGold ? `Gold Alternative/Shop` : `Shop`}</button>`)
				.click(() => {
					this._mode = "gold";
					this._doHandleModeSwitch();
				});

			this._doHandleModeSwitch();

			$$($html)`<div class="ve-flex-col w-100 h-100">
				<div class="ve-flex no-shrink btn-group mb-1">${this._$btnShowTabStandard}${this._$btnShowTabGoldAlternative}</div>
				${this._$wrpTabs[0]}
				${this._$wrpTabs[1]}
			</div>`;

			return;
		}

		this._activateListeners_renderTab($html, activeComps[0]);
	}

	_doHandleModeSwitch () {
		this._$btnShowTabStandard.toggleClass("active", this._mode === "default");
		this._$btnShowTabGoldAlternative.toggleClass("active", this._mode === "gold");
		this._$wrpTabs[0].toggleVe(this._mode === "default");
		this._$wrpTabs[1].toggleVe(this._mode === "gold");
	}

	_activateListeners_renderTab ($html, comp) {
		comp.pRender($html)
			.then($wrpTabInner => {
				const $btnAccept = $(`<button class="btn btn-default btn-5et ${this._isStandalone ? "mr-3" : "mr-2"}">Confirm</button>`)
					.click(async () => {
						const activeComps = [this._compDefault, this._compGold].filter(it => it.isAvailable);

						const formDatas = await Promise.all(activeComps.map(comp => comp.pGetFormData()));

						for (const formData of formDatas) {
							if (
								!formData.isFormComplete
								&& !(await InputUiUtil.pGetUserBoolean({title: formData.messageInvalid}))
							) return;
						}

						const formDataCurrency = await this._compCurrency.pGetFormData();

												const combinedFormData = {
							isFormComplete: formDatas.every(it => it.isFormComplete),
							data: {
								equipmentItemEntries: formDatas.map(it => it.data?.equipmentItemEntries || []).flat(),
								currency: formDataCurrency?.data?.currency,
							},
						};

						await this._pResolveAndClose(combinedFormData);
					});

				const $btnSkip = this._isStandalone ? null : $(`<button class="btn btn-default mr-3">Skip</button>`)
					.click(() => this._pResolveAndClose(VeCt.SYM_UI_SKIP));

				$wrpTabInner.append(`<hr class=hr-1>`);
				$$`<div class="ve-flex-v-center ve-flex-h-right w-100">${$btnAccept}${$btnSkip}</div>`.appendTo($wrpTabInner);
			});
	}

	async close () {
		await super.close();
				if (this._resolve) this._resolve(null);
	}

	async pWaitForUserInput () {
		if (!this._cntModesAvailable) return VeCt.SYM_UI_SKIP;

		await this.render(true);
		return this._pUserInput;
	}
}

Charactermancer_StartingEquipment.Currency = class extends BaseComponent {
	static fromActor (actor, {isStandalone = false} = {}) {
		const initialCurrency = UtilActors.getActorCurrency({actor});
		const comp = new this({isStandalone});
		comp.init();
		comp.setCurrencyFromActor(initialCurrency);
		return comp;
	}

		constructor (opts) {
		super();

		opts = opts || {};

		this._isStandalone = !!opts.isStandalone;
		this._prevActorCurrency = null; 		this.__state.startingEquipment = opts.startingEquipment ? MiscUtil.copy(opts.startingEquipment) : null;
		this.__state.cpRolled = this._getInitialCpRolled();
	}

	init () {
		const hkStartingEquipment = () => {
						this._state.cpRolled = this._getInitialCpRolled();
			this._state.rollableExpressionGold = this.constructor._getRollableExpressionGold(this._state.startingEquipment);
		};
		this._addHookBase("startingEquipment", hkStartingEquipment);
		hkStartingEquipment();
	}

	static _getRollableExpressionGold (startingEquipment) {
		if (!startingEquipment?.goldAlternative) return null;
		const m = /{@dice ([^|]+)/.exec(startingEquipment.goldAlternative);
		if (m) return m[1].replace(/×/g, "*");
		if (!isNaN(`${startingEquipment.goldAlternative}`.trim())) return startingEquipment.goldAlternative.trim();
		return null;
	}

	get startingEquipment () { return this._state.startingEquipment; }
	set startingEquipment (val) { this._state.startingEquipment = val; }

	get isStandalone () { return this._isStandalone; }

	get rollableExpressionGold () { return this._state.rollableExpressionGold; }

	get cpSpent () { return this._state.cpSpent; }
	set cpSpent (val) { this._state.cpSpent = val; }

	get cpRolled () { return this._state.cpRolled; }
	set cpRolled (val) { this._state.cpRolled = val; }

	get hasShownGoldWarning () { return this._state.hasShownGoldWarning; }
	set hasShownGoldWarning (val) { this._state.hasShownGoldWarning = val; }

	set cpFromDefault (val) { this._state.cpFromDefault = val; }

	setCurrencyFromActor (startingCurrency) {
		this._prevActorCurrency = MiscUtil.copy(startingCurrency);

		const out = {};
		Parser.COIN_ABVS.forEach(k => out[k] = startingCurrency[k] || 0);
		this._proxyAssignSimple("state", out);
	}

	_getAvailableCp () {
		return (this._state.cpRolled || 0)
			+ (this._state.cpFromDefault || 0)
			+ CurrencyUtil.getAsCopper({cp: this._state.cp, sp: this._state.sp, gp: this._state.gp, ep: this._state.ep, pp: this._state.pp});
	}

	_getOriginalCurrency () {
		const out = Parser.COIN_ABVS.mergeMap(it => ({[it]: 0}));
		Object.entries(this._prevActorCurrency || {})
			.forEach(([coin, amount]) => out[coin] = (out[coin] || 0) + amount);

				const fromRolled = CurrencyUtil.doSimplifyCoins({cp: this._state.cpRolled || 0});
		Object.entries(fromRolled || {})
			.forEach(([coin, amount]) => out[coin] = (out[coin] || 0) + amount);

				const fromDefault = CurrencyUtil.doSimplifyCoins({cp: this._state.cpFromDefault || 0});
		Object.entries(fromDefault || {})
			.forEach(([coin, amount]) => out[coin] = (out[coin] || 0) + amount);

		return out;
	}

	isStandardStartingEquipmentActive () {
		return Object.keys(this.startingEquipment || {}).length && this.cpRolled == null;
	}

	async pGetFormData () {
		return {
			isFormComplete: true,
			data: {
				currency: CurrencyUtil.doSimplifyCoins(
					{
						cp: this.getRemainingCp(),
					},
					{
						originalCurrency: this._getOriginalCurrency(),
						isPopulateAllValues: true,
						currencyConversionTable: Parser.FULL_CURRENCY_CONVERSION_TABLE,
					},
				),
			},
		};
	}

	getRemainingCp () {
		return this._getAvailableCp() - this._state.cpSpent;
	}

	addHookCurrency (hk) { this._addHookAll("state", hk); }
	addHookCpRolled (hk) { this._addHookBase("cpRolled", hk); }
	addHookStartingEquipment (hk) { this._addHookBase("startingEquipment", hk); }
	addHookRollableExpressionGold (hk) { this._addHookBase("rollableExpressionGold", hk); }

	removeHookCpRolled (hk) { this._removeHookBase("cpRolled", hk); }

	_getInitialCpRolled () {
		if (this._isStandalone) return null;
		const startingGp = Config.get("equipmentShop", "startingGold");
		return startingGp ? CurrencyUtil.getAsCopper({gp: startingGp}) : null;
	}

	_getDefaultState () {
		return {
			startingEquipment: null,
			rollableExpressionGold: null,

			...Parser.COIN_ABVS.mergeMap(it => ({[it]: 0})),
			cpSpent: 0,
			cpRolled: this._getInitialCpRolled(),
			cpFromDefault: 0,

			hasShownGoldWarning: false,
		};
	}
};

Charactermancer_StartingEquipment.ComponentBase = class extends BaseComponent {
		constructor (opts) {
		super();
		this._compCurrency = opts.compCurrency;
		this._actor = opts.actor;
	}

	static _getHumanReadableCoinage (copper) {
		const asCoins = CurrencyUtil.doSimplifyCoins({cp: copper});
		return [...Parser.COIN_ABVS]
			.reverse().map(coin => asCoins[coin] ? `${asCoins[coin].toLocaleString()} ${coin}` : null)
			.filter(Boolean)
			.join(", ") || "0 gp";
	}

	async _pIsIgnoreGoldWarning () {
		if (!Object.keys(this._compCurrency.startingEquipment || {}).length || this._compCurrency.hasShownGoldWarning) return true;

		const isUseGold = await InputUiUtil.pGetUserBoolean({
			title: `Are you sure?`,
			htmlDescription: `Using gold to buy starting equipment is an alternative to standard starting equipment.<br>Are you sure you want to use gold?`,
			textYes: "Yes",
			textNo: "Cancel",
		});
		if (!isUseGold) return false;

		this._compCurrency.hasShownGoldWarning = true;
		return true;
	}

	_$getBtnRollStartingGold () {
		return $(`<button class="btn btn-default btn-xs btn-5et">Roll Starting Gold</button>`)
			.click(async () => {
				if (!(await this._pIsIgnoreGoldWarning())) return;

				const roll = new Roll(this._compCurrency.rollableExpressionGold);
				await roll.evaluate({async: true});
				this._compCurrency.cpRolled = roll.total * 100;

				const optsToMessage = {sound: null};
				if (this._actor) {
					optsToMessage.speaker = {actor: this._actor.id};
					optsToMessage.flavor = `<div>${this._actor.name} rolls starting gold!</div>`;
				}

				roll
					.toMessage(optsToMessage)
					.then(null);
			});
	}

	_$getBtnEnterStartingGold () {
		return $(`<button class="btn btn-default btn-xs btn-5et" title="Manually enter a starting gold amount, as an alternate to rolling.">Enter Starting Gold</button>`)
			.click(async () => {
				if (!(await this._pIsIgnoreGoldWarning())) return;

				const opts = {
					min: 0,
					title: "Enter Gold Amount",
					int: true,
				};
				if (this._compCurrency.cpRolled != null) opts.default = Math.round(this._compCurrency.cpRolled / 100);

				const amount = await InputUiUtil.pGetUserNumber(opts);
				if (amount == null) return;

				this._compCurrency.cpRolled = amount * 100;
			});
	}

	_$getDispRolledGold () {
		const $dispRolled = $(`<div></div>`);

		const hkRolled = () => {
			if (this._compCurrency.cpRolled == null && this._compCurrency.rollableExpressionGold != null) $dispRolled.html(`<i class="ve-muted">${this._compCurrency.rollableExpressionGold}</i>`);
			else $dispRolled.html(this.constructor._getHumanReadableCoinage(this._compCurrency.cpRolled || 0));
		};
		hkRolled();
		this._compCurrency.addHookRollableExpressionGold(hkRolled);
		this._compCurrency.addHookCpRolled(hkRolled);

		return $dispRolled;
	}

	_$getWrpRollOrManual ({$btnRoll, $dispRollOrManual, $btnManual, $dispRolled}) {
		const $stgDispRolled = $dispRolled ? $$`<div class="m-1"> = </div>${$dispRolled}` : null;
		return $$`<div class="ve-flex-v-center">${$btnRoll}${$dispRollOrManual}${$btnManual}${$stgDispRolled}</div>`;
	}

	_doBindRollableExpressionHooks ({$dispRollOrManual, $btnRoll, $btnManual, $spcRollOrManual, $wrpRollOrManual}) {
		const hkRollableExpressionGold = () => {
						$dispRollOrManual.toggleVe(this._compCurrency.rollableExpressionGold);
			$btnRoll
				.toggleVe(this._compCurrency.rollableExpressionGold)
				.title(`Rolling ${this._compCurrency.rollableExpressionGold}`);

						$btnManual.toggleVe(this._compCurrency.startingEquipment);

						if ($spcRollOrManual) $spcRollOrManual.toggleVe(!this._isPredefinedItemDatas && this._compCurrency.startingEquipment);
			$wrpRollOrManual.toggleVe(this._compCurrency.startingEquipment);
		};
		this._compCurrency.addHookStartingEquipment(hkRollableExpressionGold);
		this._compCurrency.addHookRollableExpressionGold(hkRollableExpressionGold);
		hkRollableExpressionGold();
	}
};

Charactermancer_StartingEquipment.ComponentDefault = class extends Charactermancer_StartingEquipment.ComponentBase {
		constructor (opts) {
		super(opts);

		opts = opts || {};

		this._equiSpecialSource = opts.equiSpecialSource;
		this._equiSpecialPage = opts.equiSpecialPage;
		this._fnDoShowShop = opts.fnDoShowShop;

		this._fnsUnhook = [];
	}

	set equiSpecialSource (val) { this._equiSpecialSource = val; }
	set equiSpecialPage (val) { this._equiSpecialPage = val; }

	get isAvailable () { return !!(this._compCurrency.startingEquipment?.defaultData?.length); }

	async pGetFormData () {
		const equipmentItemEntries = [];

		const itemDatasDefault = await this._pGetItemDatasDefault();
		if (itemDatasDefault) {
			equipmentItemEntries.push(...itemDatasDefault);
		}

		const isValid = this._isValid_standard();
		const messageInvalid = isValid ? null : `You have not made all available choices. Are you sure you want to continue?`;

		return {
			isFormComplete: isValid,
			messageInvalid: messageInvalid,
			data: {
				equipmentItemEntries,
			},
		};
	}

	static _getItemIdWithDisplayName (itemId, displayName) {
		if (!displayName) return itemId;

		const itemIdParts = itemId.split("|");

				while (itemIdParts.length > 2) itemIdParts.pop();
		while (itemIdParts.length < 2) itemIdParts.push("");

		itemIdParts.push(displayName);

		return itemIdParts.join("|");
	}

	async pRender ($wrpTab) {
		const $wrpTabInner = $(`<div class="ve-flex-col w-100 h-100 min-h-0"></div>`).appendTo($wrpTab);
		this._render_standard($wrpTabInner);
		return $wrpTabInner;
	}

		_iterChosenStartingEquipment (fnEqui) {
		const defaultData = (this._compCurrency.startingEquipment?.defaultData || []);

		for (let ixGroup = 0; ixGroup < defaultData.length; ++ixGroup) {
			const group = defaultData[ixGroup];
			const propGroup = `std__choice__${ixGroup}`;

			const choices = Object.entries(group);
			for (let ixChoice = 0; ixChoice < choices.length; ++ixChoice) {
				const [_, choice] = choices[ixChoice];

								if (this._state[propGroup] !== ixChoice) continue;

				for (let ixEqui = 0; ixEqui < choice.length; ++ixEqui) {
					const equi = choice[ixEqui];

					const out = fnEqui(ixGroup, ixChoice, equi);
					if (out !== undefined) return out;
				}
			}
		}
	}

	_render_standard ($wrpTabStandard) {
				const $btnRoll = this._$getBtnRollStartingGold();
		const $dispRollOrManual = $(`<i class="mx-1">\u2013 or \u2013</i>`);
		const $btnManual = this._$getBtnEnterStartingGold();

		const $wrpRollOrManual = this._$getWrpRollOrManual({$dispRollOrManual, $btnRoll, $btnManual});

		this._doBindRollableExpressionHooks({$dispRollOrManual, $btnRoll, $btnManual, $wrpRollOrManual});

		const $rowSkipToShop = $$`<div class="w-100 py-1 ve-flex-v-center">
			<div class="mr-1">Alternatively, </div>
			${$wrpRollOrManual}
			<div class="ml-1">to skip to the shop.</div>
		</div>`.appendTo($wrpTabStandard);

		const $btnResetStartingGold = $(`<button class="btn btn-default btn-xs btn-5et">Reset Starting Gold</button>`)
			.click(async () => {
				const isSure = await InputUiUtil.pGetUserBoolean({
					title: `Are you sure?`,
					htmlDescription: `This will discard your current starting gold roll or value.`,
				});
				if (!isSure) return;
				this._compCurrency.cpRolled = null;
			});
		const $rowHasCpRolled = $$`<div class="w-100 py-1 ve-flex-v-center">
			<div class="mr-2">You have rolled or entered a value for starting gold instead of using starting equipment.</div>
			${$btnResetStartingGold}
			<div class="ml-1">to use the equipment listed below.</div>
		</div>`.appendTo($wrpTabStandard);

		const hkCpRolled = () => {
			$rowSkipToShop.toggleVe(this._compCurrency.cpRolled == null);
			$rowHasCpRolled.toggleVe(this._compCurrency.cpRolled != null);
		};
		this._compCurrency.addHookCpRolled(hkCpRolled);
		hkCpRolled();

				if (this._fnDoShowShop) {
			const hkOnChangeCurrency = (prop, val, prevVal) => {
				if (prevVal == null && val != null) this._fnDoShowShop();
			};
			this._compCurrency.addHookCpRolled(hkOnChangeCurrency);
		}
		
		const $wrpRows = $$`<div class="ve-flex-col w-100 h-100 min-h-0 overflow-y-auto"></div>`.appendTo($wrpTabStandard);

		const hkStartingEquipment = () => {
			const defaultData = this._compCurrency.startingEquipment?.defaultData || [];

						this._fnsUnhook.forEach(fn => fn());
			this._fnsUnhook = [];
			Object.keys(this._state).filter(k => k.startsWith(`std__`)).forEach(k => delete this._state[k]);
			$wrpRows.empty();
			
			const $rows = defaultData.map((group, ixGroup) => {
				const isSingleOption = Object.keys(group).length === 1;
				const propGroup = `std__choice__${ixGroup}`;
				this._state[propGroup] = 0; 
				const choices = Object.entries(group);

				const $wrpsChoices = choices
					.map(([choiceName, choice], ixChoice) => {
						const children = [];
						choice.forEach((equi, ixEqui) => {
							if (typeof equi === "string") children.push(Renderer.get().render(`{@item ${equi}}`));
							else if (equi.item) {
								const itemId = this.constructor._getItemIdWithDisplayName(equi.item, equi.displayName);

								children.push(Renderer.get().render(`${equi.quantity ? `${equi.quantity}× ` : ""}{@item ${itemId}}${equi.containsValue ? ` containing ${this.constructor._getHumanReadableCoinage(equi.containsValue)}` : ""}`));
							} else if (equi.equipmentType) {
								const equiChoices = Charactermancer_StartingEquipment._EQUIPMENT_SETS[equi.equipmentType];
								if (!equiChoices) throw new Error(`Unhandled equipmentType "${equi.equipmentType}"`);

								const num = equi.quantity || 1;
								for (let i = 0; i < num; ++i) {
									const $dispEqui = $(`<div class="inline"></div>`);
									const propEqui = `std__equi__${ixGroup}__${ixChoice}__${i}`;

									const hkDispEqui = () => {
										if (!this._state[propEqui]) {
											$dispEqui.html(`<i class="ve-muted">(select an item)</i>`);
											return;
										}

										$dispEqui.html(Renderer.get().render(`{@item ${this._state[propEqui]}}`));
									};
									this._addHookBase(propEqui, hkDispEqui);
									this._fnsUnhook.push(() => this._removeHookBase(propEqui, hkDispEqui));
									hkDispEqui();

									const $btnPick = $(`<button class="btn btn-default btn-xxs" title="Choose an Item"><span class="fas fa-fw fa-search"></span></button>`)
										.click(async () => {
											const equiChoicesName = Charactermancer_StartingEquipment._EQUIPMENT_SET_NAMES[equi.equipmentType];
											const {$modalInner, doClose, doAutoResize: doAutoResizeModal} = await UtilApplications.pGetShowApplicationModal({
												title: `Choose Item${equiChoicesName ? ` \u2014 ${equiChoicesName}` : ""}`,
											});

											const $rows = equiChoices.map(itemUid => {
												const $btnChoose = $(`<button class="btn btn-xs btn-default mr-2"><span class="fas fa-fw fa-check"></span></button>`)
													.click(() => {
														this._state[propEqui] = itemUid;
														doClose(true);
																												this._state[propGroup] = ixChoice;
													});

												return $$`<div class="ve-flex-v-center py-1 stripe-even">${$btnChoose}${Renderer.get().render(`{@item ${itemUid.uppercaseFirst()}}`)}</div>`;
											});

											$$($modalInner)`<div class="ve-flex-col h-100">${$rows}</div>`;

											doAutoResizeModal();
										});

									children.push($$`<div class="inline">${$btnPick} ${$dispEqui}</div>`);

									if (i < num - 1) children.push(", ");
								}
							} else if (equi.special) {
								children.push(Renderer.get().render(`${equi.quantity ? `${equi.quantity}× ` : ""}${equi.special}${equi.containsValue ? ` containing ${this.constructor._getHumanReadableCoinage(equi.containsValue)}` : ""}${equi.worthValue ? `, worth ${this.constructor._getHumanReadableCoinage(equi.worthValue)}` : ""}`));
							} else if (equi.value != null) {
								children.push(this.constructor._getHumanReadableCoinage(equi.value));
							} else throw new Error(`Unknown equipment data format: ${JSON.stringify(equi)}`);

							if (ixEqui < choice.length - 1) children.push(", ");
						});

						const $btnSelGroup = $(`<button class="btn btn-default btn-sm no-shrink ve-flex-vh-center imp-cls__disp-equi-choice-key mr-2 bold" ${isSingleOption ? "" : `title="Select Equipment Group ${choiceName}"`}>${isSingleOption ? "&nbsp;" : `(${choiceName})`}</button>`)
							.click(async () => {
								if (this._compCurrency.cpRolled != null) {
									const isSure = await InputUiUtil.pGetUserBoolean({
										title: `Are you sure?`,
										htmlDescription: `You have already rolled or set gold for equipment!<br>Selecting default starting equipment will discard this roll or value.`,
									});
									if (!isSure) return;

									this._compCurrency.cpRolled = null;
								}

								if (isSingleOption) return;

								this._state[propGroup] = ixChoice;
							});

						const $wrpChildren = $$`<div class="w-100">${children}</div>`;

						const hkSelGroup = () => {
							$btnSelGroup.toggleClass("ve-muted", this._compCurrency.cpRolled != null);
							$wrpChildren.toggleClass("ve-muted", this._compCurrency.cpRolled != null);

							if (this._compCurrency.cpRolled != null) {
								$btnSelGroup.removeClass("active");
								$btnSelGroup.prop("disabled", false);
								return;
							}

							if (isSingleOption) $btnSelGroup.prop("disabled", true);

							if (this._state[propGroup] === ixChoice) $btnSelGroup.addClass("active");
							else $btnSelGroup.removeClass("active");
						};
						this._addHookBase(propGroup, hkSelGroup);
						this._compCurrency.addHookCpRolled(hkSelGroup);
						this._fnsUnhook.push(() => this._removeHookBase(propGroup, hkSelGroup));
						this._fnsUnhook.push(() => this._compCurrency.removeHookCpRolled(hkSelGroup));
						hkSelGroup();

						if (ixChoice < choices.length - 1) $btnSelGroup.addClass("mb-1");

						return $$`<div class="ve-flex-vh-center">
							${$btnSelGroup}
							${$wrpChildren}
						</div>`;
					});

				return $$`<div class="ve-flex-col w-100 p-1 my-1 imp-cls__wrp-equi-group">${$wrpsChoices}</div>`;
			});

			$rows.forEach($row => $wrpRows.append($row));

			if (!$rows.length) {
				$wrpRows.append(`<div class="ve-flex-vh-center w-100 h-100 italic ve-muted">No starting equipment available.</div>`);
			}
		};
		this._compCurrency.addHookStartingEquipment(hkStartingEquipment);
		hkStartingEquipment();

		const hkSetCoinsFromDefault = () => {
						if (Config.get("equipmentShop", "startingGold") != null) {
				this._compCurrency.cpFromDefault = 0;
				return;
			}

						let cpValue = 0;

			const fnEqui = (ixGroup, ixChoice, equi) => {
				if (equi.item) {
					if (equi.containsValue) cpValue += equi.containsValue;
				} else if (equi.special) {
					if (equi.containsValue) cpValue += equi.containsValue;
				} else if (equi.value) {
					cpValue += equi.value;
				}
			};

			this._iterChosenStartingEquipment(fnEqui);

			this._compCurrency.cpFromDefault = cpValue;
		};
		this._addHookAll("state", hkSetCoinsFromDefault);
		hkSetCoinsFromDefault();
	}

	_isValid_standard () {
		if (!this.isAvailable || this._compCurrency.cpRolled != null) return true;

		const fnEqui = (ixGroup, ixChoice, equi) => {
			if (equi.equipmentType) {
				const num = equi.quantity || 1;
				for (let i = 0; i < num; ++i) {
					const propEqui = `std__equi__${ixGroup}__${ixChoice}__${i}`;
					if (this._state[propEqui] == null) return false;
				}
			}
		};

		const out = this._iterChosenStartingEquipment(fnEqui);
		if (out !== undefined) return out;
		return true;
	}

	async _pGetItemDatasDefault () {
				if (this._compCurrency.cpRolled) return [];

		const outUidMetas = [];
		const outPreloaded = [];

				const addOutUidMeta = (itemUid, quantity) => {
			const existing = outUidMetas.find(it => it.itemUid === itemUid);
			if (existing) existing.quantity += quantity;
			else outUidMetas.push({itemUid, quantity: quantity});
		};

		const fnEqui = (ixGroup, ixChoice, equi) => {
			if (typeof equi === "string") addOutUidMeta(equi, 1);
			else if (equi.item) {
				addOutUidMeta(this.constructor._getItemIdWithDisplayName(equi.item, equi.displayName), equi.quantity || 1);
			} else if (equi.equipmentType) {
				const num = equi.quantity || 1;
				for (let i = 0; i < num; ++i) {
					const propEqui = `std__equi__${ixGroup}__${ixChoice}__${i}`;
					const itemUid = this._state[propEqui];
					if (itemUid != null) addOutUidMeta(itemUid, 1);
				}
			} else if (equi.special) {
								outPreloaded.push({
					item: {
						name: Renderer.stripTags(equi.special).toTitleCase(),
						source: this._equiSpecialSource,
						page: this._equiSpecialPage,
						type: "OTH",
						rarity: "unknown",
					},
					quantity: equi.quantity || 1,
				});
			}
		};

		this._iterChosenStartingEquipment(fnEqui);

				const loadedItems = [];
		for (const itemUidMeta of outUidMetas) {
			const [name, source, displayName] = itemUidMeta.itemUid.split("|");
			const hash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS]({name, source});

			const loadedItem = await DataLoader.pCacheAndGetHash(UrlUtil.PG_ITEMS, hash);
			if (!loadedItem) {
				console.warn(...LGT, `Failed to load item "${itemUidMeta.itemUid}"!`);
				continue;
			}

			if (displayName) loadedItem._displayName = Renderer.stripTags(displayName).toTitleCase();
			loadedItems.push({
				item: loadedItem,
				quantity: itemUidMeta.quantity,
			});
		}
		const {ImportListItem} = await Promise.resolve().then(function () { return ImportListItem$1; });
		const outFromUids = loadedItems.sort((a, b) => ImportListItem.sortEntries(a.item, b.item));

		return [...outFromUids, ...outPreloaded];
	}

	_getDefaultState () { return {}; }
};

Charactermancer_StartingEquipment.ComponentGold = class extends Charactermancer_StartingEquipment.ComponentBase {
		constructor (opts) {
		super(opts);
		this._isPredefinedItemDatas = !!opts.itemDatas;
		this._state.itemDatas = opts.itemDatas;

		this._modalFilter = null;
	}

	get isAvailable () { return true; }

	async pGetFormData () {
		const equipmentItemEntries = [];

		const itemDatas = await this._pGetItemEntries();
		if (itemDatas) {
			equipmentItemEntries.push(...itemDatas);
		}

		const isValid = await this._isValid_gold();
		const messageInvalid = isValid ? null : `You have spent more gold than you possess. Are you sure you want to go into debt?`;

		return {
			isFormComplete: isValid,
			messageInvalid,
			data: {
				equipmentItemEntries,
			},
		};
	}

	async pRender ($wrpTab) {
		const $wrpTabInner = $(`<div class="ve-flex-col w-100 h-100 min-h-0"><div class="ve-flex-vh-center w-100 h-100 italic">Loading...</div></div>`).appendTo($wrpTab);
		await this._render_pGoldAlternative($wrpTabInner);
		return $wrpTabInner;
	}

	async _render_pGoldAlternative ($wrpTabGoldAlternative) {
		await Renderer.item.pPopulatePropertyAndTypeReference();

		const {ImportListItem} = await Promise.resolve().then(function () { return ImportListItem$1; });
		const importListItemSources = await (new ImportListItem()).pGetSources();
		const appSourceSelector = new AppSourceSelectorMulti({
			title: `Select Item Sources`,
			filterNamespace: `ImportListCharacter_StartingEquipment_filter`,
			savedSelectionKey: `ImportListCharacter_StartingEquipment_savedSelection`,
			sourcesToDisplay: importListItemSources,
			page: UrlUtil.PG_ITEMS,
			isDedupable: true,
		});

		const $btnChooseSources = this._isPredefinedItemDatas ? null : $(`<button class="btn btn-xs btn-default btn-5et">Choose Item Sources</button>`)
			.click(async () => {
				const choices = await appSourceSelector.pWaitForUserInput();
				if (choices == null) return;

				this._state.itemDatas = choices;
			});

		if (!this._isPredefinedItemDatas) {
						appSourceSelector.pLoadInitialSelection()
				.then(choices => {
					if (!choices) return;
					this._state.itemDatas = choices;
				});
		}

		const $dispCurrencyRemaining = $(`<div class="ml-auto ve-flex-v-center"></div>`);
		const hkCurrency = () => {
			const remainingCp = this._compCurrency.getRemainingCp();
			$dispCurrencyRemaining.html(`
				<div title="The total cost of all items in the &quot;shopping basket,&quot; listed below.">
					<b class="mr-1">Total:</b>
					<span>${this.constructor._getHumanReadableCoinage(this._compCurrency.cpSpent)}</span>
				</div>
				<div class="vr-1"></div>
				<span>(</span>
				<div title="The total remaining gold available to this character. This amount is a combination of the currency on their sheet, plus any contextual modifiers (such as class starting gold when importing a class).">
					<b class="mr-1">Remaining:</b>
					<span ${remainingCp < 0 ? `class="veapp__msg-error bold"` : ""}>${this.constructor._getHumanReadableCoinage(remainingCp)}</span>
				</div>
				<span>)</span>
			`);
		};
		this._compCurrency.addHookCurrency(hkCurrency);
		hkCurrency();

		const $dispRollOrManual = $(`<i class="mx-1">\u2013 or \u2013</i>`);
		const $btnRoll = this._$getBtnRollStartingGold();
		const $btnManual = this._$getBtnEnterStartingGold();
		const $dispRolled = this._$getDispRolledGold();

		const $spcRollOrManual = $(`<div class="vr-1"></div>`);
		const $wrpRollOrManual = this._$getWrpRollOrManual({$dispRollOrManual, $btnRoll, $btnManual, $dispRolled}).addClass("mr-3");

		this._doBindRollableExpressionHooks({$dispRollOrManual, $btnRoll, $btnManual, $spcRollOrManual, $wrpRollOrManual});

		const isStandaloneGmInstance = game.user.isGM && this._compCurrency.isStandalone;
		const $btnEditPriceMultiplier = !isStandaloneGmInstance ? null : $(`<button class="btn btn-xs btn-default btn-5et">Edit Config</button>`)
			.click(evt => Config.pHandleButtonClick(evt, "equipmentShop"));
		const $wrpGmPriceMultiplier = !isStandaloneGmInstance ? null : $$`<div class="ml-auto">
			${$btnEditPriceMultiplier}
		</div>`;

		this._modalFilter = new Charactermancer_StartingEquipment.ModalFilterEquipment(this);

		const $wrpItemList = $(`<div class="ve-flex-col w-50 h-100 min-h-0"><div class="ve-flex-vh-center italic w-100 h-100">Loading...</div></div>`);

						this._modalFilter.pPopulateWrapper(
			$wrpItemList,
			{
				isBuildUi: true,
				$btnOpen: $(`<button class="btn-5et veapp__btn-filter" name="btn-filter">Filter</button>`),
				$btnToggleSummaryHidden: $(`<button class="btn btn-5et" title="Toggle Filter Summary Display" name="btn-toggle-summary"><span class="glyphicon glyphicon-resize-small"></span></button>`),
				$btnReset: $(`<button class="btn-5et veapp__btn-list-reset" name="btn-reset">Reset</button>`),
			},
		).then(meta => {
			const {list, $btnSendAllToRight} = meta;
			$btnSendAllToRight
				.addClass("btn-5et ve-grow")
				.click(async evt => {
					if (list.visibleItems.length > 10 && !(await InputUiUtil.pGetUserBoolean({title: `You are about to add ${list.visibleItems.length} items. Are you sure?`}))) return;

					const quantity = evt.shiftKey ? 5 : 1;
					list.visibleItems.forEach(it => this.addBoughtItem(`${it.name}|${it.values.source}`, {quantity, isTriggerUpdate: false}));
					this._triggerCollectionUpdate("itemPurchases");
				});

			hkItemDatas();
		});

		const $wrpBoughtList = $(`<div class="w-100 h-100 min-h-0 overflow-y-auto"></div>`);

		const hkGoldItemUids = () => {
			this._renderCollection({
				prop: "itemPurchases",
				fnUpdateExisting: (renderedMeta, itemPurchase) => {
					renderedMeta.comp._proxyAssignSimple("state", itemPurchase.data, true);
				},
				fnGetNew: (itemPurchase) => {
					const comp = BaseComponent.fromObject(itemPurchase.data);
					comp._addHookAll("state", () => {
						itemPurchase.data = comp.toObject();
						this._triggerCollectionUpdate("itemPurchases");
					});

					const [name, source] = itemPurchase.data.uid.split("|");
					DataLoader.pCacheAndGetHash(UrlUtil.PG_ITEMS, UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS]({name, source}))
						.then(item => {
							comp._state.name = item.name;
							comp._state.value = item.value * Config.get("equipmentShop", "priceMultiplier");
						});

					const hkNoQuantity = () => {
						if (comp._state.quantity > 0) return;
						this._state.itemPurchases = this._state.itemPurchases.filter(it => it !== itemPurchase);
					};
					comp._addHookBase("quantity", hkNoQuantity);

					const $btnSubtract = $(`<button class="btn btn-xxs btn-5et btn-danger" title="Remove One (SHIFT to remove  5)"><span class="glyphicon glyphicon-minus"></span></button>`)
						.click(evt => {
							if (evt.shiftKey) comp._state.quantity -= 5;
							else comp._state.quantity--;
						});

					const $btnAdd = $(`<button class="btn btn-xxs btn-5et btn-success" title="Add Another (SHIFT to add 5)"><span class="glyphicon glyphicon-plus"></span></button>`)
						.click(evt => {
							if (evt.shiftKey) comp._state.quantity += 5;
							else comp._state.quantity++;
						});

					const $dispQuantity = $(`<div class="text-center no-shrink imp-cls__disp-equi-count"></div>`);
					const hkQuantity = () => $dispQuantity.text(comp._state.quantity);
					comp._addHookBase("quantity", hkQuantity);
					hkQuantity();

					const $dispName = $(`<div class="w-100"></div>`);
					const hkName = () => $dispName.html(Renderer.get().render(`{@item ${comp._state.uid}|${comp._state.name || ""}}`));
					comp._addHookBase("name", hkName);
					hkName();

					const $dispCostIndividual = $(`<div class="no-shrink text-right imp-cls__disp-equi-cost px-1"></div>`);
					const hkCostIndividual = () => $dispCostIndividual.html(comp._state.isIgnoreCost ? `<span class="ve-muted" title="Cost Ignored">\u2014</span>` : this.constructor._getHumanReadableCoinage(comp._state.value));
					comp._addHookBase("value", hkCostIndividual);
					hkCostIndividual();

					const $dispCostTotal = $(`<div class="no-shrink text-right imp-cls__disp-equi-cost px-1"></div>`);
					const hkCostTotal = () => {
						if (comp._state.value == null || comp._state.quantity == null) return;
						$dispCostTotal.html(comp._state.isIgnoreCost ? `<span class="ve-muted" title="Cost Ignored">\u2014</span>` : this.constructor._getHumanReadableCoinage(comp._state.value * comp._state.quantity));
					};
					comp._addHookBase("value", hkCostTotal);
					comp._addHookBase("quantity", hkCostTotal);
					hkCostTotal();

					const $wrpRow = $$`<div class="py-1p my-0 veapp__list-row ve-flex-v-center w-100">
						<div class="btn-group ve-flex-vh-center no-shrink imp-cls__wrp-equi-btns">
							${$btnSubtract}
							${$btnAdd}
						</div>
						${$dispQuantity}
						${$dispName}
						${$dispCostIndividual}
						${$dispCostTotal}
					</div>`.appendTo($wrpBoughtList);

					return {
						comp,
						$wrpRow,
					};
				},
			});
		};
		this._addHookBase("itemPurchases", hkGoldItemUids);
		hkGoldItemUids();

		const pHkItemsPurchased = async () => {
			try {
				await this._pLock("pHkItemsPurchased");
								this._compCurrency.cpSpent = await this._pGetCpSpent();
			} finally {
				this._unlock("pHkItemsPurchased");
			}
		};
		this._addHookBase("itemPurchases", pHkItemsPurchased);
		pHkItemsPurchased();

		const hkItemDatas = () => {
			this._modalFilter.setDataList(this._state.itemDatas);
		};
		this._addHookBase("itemDatas", hkItemDatas);

		const $btnClearPurchases = $(`<button class="btn btn-xxs btn-5et btn-danger" title="Remove All Purchases"><span class="glyphicon glyphicon-minus"></span></button>`)
			.click(async () => {
				if (!(await InputUiUtil.pGetUserBoolean({title: `Are you sure you want to remove all purchased items from the list?`}))) return;
				this._state.itemPurchases = [];
			});

		$$($wrpTabGoldAlternative.empty())`
		<div class="ve-flex-v-center">
			<div class="w-50 ve-flex-v-center">
				${$btnChooseSources}
				${$spcRollOrManual}
				${$wrpRollOrManual}
				${$wrpGmPriceMultiplier}
			</div>

			<div class="vr-1"></div>

			<div class="w-50 split-v-center">
				${$dispCurrencyRemaining}
			</div>
		</div>

		<hr class="hr-1">

		<div class="ve-flex h-100 min-h-0 w-100">
			${$wrpItemList}

			<div class="vr-1"></div>

			<div class="w-50 min-h-0 ve-flex-col">
				<div class="ve-flex-v-center pb-1">
					<div class="imp-cls__wrp-equi-btns no-shrink ve-flex-vh-center">${$btnClearPurchases}</div>
					<div class="imp-cls__disp-equi-count no-shrink text-center" title="Quantity">Qt.</div>
					<div class="w-100">Name</div>
					<div class="imp-cls__disp-equi-cost no-shrink text-center">Cost</div>
					<div class="imp-cls__disp-equi-cost no-shrink text-center">Line Total</div>
				</div>

				${$wrpBoughtList}
			</div>
		</div>`;
	}

	_isValid_gold () {
		return this._compCurrency.getRemainingCp() >= 0; 	}

	async _pGetCpSpent () {
		const expenses = await Promise.all(this._state.itemPurchases.map(async itemMeta => {
			if (itemMeta.data.isIgnoreCost) return 0;

			const [name, source] = itemMeta.data.uid.split("|");
			const item = await DataLoader.pCacheAndGetHash(UrlUtil.PG_ITEMS, UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS]({name, source}));
			return item.value * Config.get("equipmentShop", "priceMultiplier") * (itemMeta.data.quantity || 1);
		}));
		return expenses.reduce((a, b) => a + b, 0);
	}

	async _pGetItemEntries () {
		if (!this._state.itemPurchases.length) return null;

		const combinedItems = {};

		for (const itemPurchase of this._state.itemPurchases) {
			combinedItems[itemPurchase.data.uid] = combinedItems[itemPurchase.data.uid] || 0;
			combinedItems[itemPurchase.data.uid] += itemPurchase.data.quantity || 1;
		}

		const out = [];
		const entries = Object.entries(combinedItems);
		for (const [uid, quantity] of entries) {
			const [name, source] = uid.split("|");
			const item = await DataLoader.pCacheAndGetHash(UrlUtil.PG_ITEMS, UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS]({name, source}));
			out.push({
				item,
				quantity,
			});
		}

		return out;
	}

		addBoughtItem (itemUid, opts) {
		opts = opts || {};
		opts.quantity = opts.quantity === undefined ? 1 : opts.quantity;
		opts.isTriggerUpdate = opts.isTriggerUpdate === undefined ? true : opts.isTriggerUpdate;
		opts.isIgnoreCost = opts.isIgnoreCost === undefined ? false : opts.isIgnoreCost;

		itemUid = itemUid.toLowerCase();
		const collectionId = `${itemUid}__${opts.isIgnoreCost}`;

		const existing = this._state.itemPurchases.find(it => it.id === collectionId);
		if (existing) {
			existing.data.quantity += opts.quantity;
		} else {
			this._state.itemPurchases.push({
				id: collectionId,
				data: {
					uid: itemUid,
					quantity: opts.quantity,
					isIgnoreCost: opts.isIgnoreCost,
				},
			});
		}

		if (opts.isTriggerUpdate) this._triggerCollectionUpdate("itemPurchases");
	}

	_getDefaultState () {
		return {
			itemPurchases: [],

			itemDatas: [],
		};
	}
};

Charactermancer_StartingEquipment.ModalFilterEquipment = class extends ModalFilter {
	static _$getFilterColumnHeaders (btnMeta) {
		return super._$getFilterColumnHeaders(btnMeta).map($btn => $btn.addClass(`btn-5et`));
	}

	constructor (compStartingEquipment) {
		super({
			pageFilter: new PageFilterEquipment(),
			namespace: "ImportListCharacter_modalFilterEquipment",
		});
		this._compParent = compStartingEquipment;
	}

	_$getColumnHeaders () {
		const btnMeta = [
			{sort: "name", text: "Name", width: "3-2"},
			{sort: "type", text: "Type", width: "3-2"},
			{sort: "cost", text: "Cost", width: "1-8"},
			{sort: "source", text: "Source", width: "1-8"},
		];
		return this.constructor._$getFilterColumnHeaders(btnMeta);
	}

	async _pLoadAllData () { return []; }

	_$getWrpList () { return $(`<div class="veapp__list mb-1 h-100 min-h-0"></div>`); }

	_$getColumnHeaderPreviewAll (opts) {
		return super._$getColumnHeaderPreviewAll(opts).addClass(["btn-5et", "ve-muted"]);
	}

	_getListItem (pageFilter, item, itI) {
		if (item.noDisplay) return null;

		Renderer.item.enhanceItem(item);
		pageFilter.mutateAndAddToFilters(item);

		const eleRow = document.createElement("div");
		eleRow.className = "px-0 w-100 veapp__list-row ve-flex-col no-shrink";

		const hash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS](item);
		const source = Parser.sourceJsonToAbv(item.source);
		const type = item._typeListText.join(", ");

		eleRow.innerHTML = `<div class="w-100 veapp__list-row-hoverable ve-flex-v-center">
			<div class="col-1 ve-flex-vh-center">
				<div class="ui-list__btn-inline" title="Toggle Preview (SHIFT to Toggle Info Preview)">${ListUiUtil.HTML_GLYPHICON_EXPAND}</div>
			</div>

			<span class="col-3-2">${item.name}</span>
			<span class="col-3-2">${item._typeListText.join(", ").toTitleCase()}</span>
			<span class="col-1-8 text-right px-1">${Parser.itemValueToFullMultiCurrency(item, {isShortForm: true, multiplier: Config.get("equipmentShop", "priceMultiplier")}).replace(/ +/g, "\u00A0")}</span>
			<span class="col-1-8 text-center ${Parser.sourceJsonToColor(item.source)} pr-0" title="${Parser.sourceJsonToFull(item.source)}" ${Parser.sourceJsonToStyle(item.source)}>${source}</span>
			<div class="col-1 ve-flex-vh-center"><button class="btn btn-xxs btn-default btn-5et" title="Add (SHIFT to add 5; CTRL to ignore price)"><span class="glyphicon glyphicon-arrow-right"></span></button></div>
		</div>`;

		const btnShowHidePreview = eleRow.firstElementChild.firstElementChild.firstElementChild;
		btnShowHidePreview.addEventListener("click", evt => {
			evt.stopPropagation();
			evt.preventDefault();

			const elePreviewWrp = ListUiUtil.getOrAddListItemPreviewLazy(listItem);

			ListUiUtil.handleClickBtnShowHideListPreview(
				evt,
				UrlUtil.PG_ITEMS,
				item,
				btnShowHidePreview,
				elePreviewWrp,
			);
		});

		const listItem = new ListItem(
			itI,
			eleRow,
			item.name,
			{
				hash,
				source,
				sourceJson: item.source,
				cost: (item.value || 0) * Config.get("equipmentShop", "priceMultiplier"),
				type,
			},
			{
				btnSendToRight: eleRow.firstElementChild.lastElementChild.lastElementChild,
				btnShowHidePreview,
			},
		);

		return listItem;
	}

	setDataList (allData) {
		this._list.removeAllItems();

		this._allData = (allData?.item || []).filter(it => it.value != null && it.type !== "$");

		this._allData.forEach((it, i) => {
			this._pageFilter.mutateAndAddToFilters(it);
			const filterListItem = this._getListItem(this._pageFilter, it, i);
			this._list.addItem(filterListItem);
			const itemUid = `${it.name}|${it.source}`;
			filterListItem.data.btnSendToRight.addEventListener("click", evt => {
				const isIgnoreCost = evt.ctrlKey;
				if (evt.shiftKey) this._compParent.addBoughtItem(itemUid, {quantity: 5, isIgnoreCost});
				else this._compParent.addBoughtItem(itemUid, {isIgnoreCost});
			});
		});

						this._pageFilter.sourceFilter.setFromValues({"Source": {}});

		this._pageFilter.filterBox.render();
		this._list.update();
	}
};

Charactermancer_StartingEquipment._EQUIPMENT_SET_NAMES = {
	weaponAny: "Weapon",
	weaponSimple: "Simple Weapon",
	weaponSimpleMelee: "Simple Melee Weapon",
	weaponMartial: "Martial Weapon",
	weaponMartialMelee: "Martial Melee Weapon",
	instrumentMusical: "Musical Instrument",
	armorLight: "Light Armor",
	armorMedium: "Medium Armor",
	armorHeavy: "Heavy Armor",
	weaponMelee: "Melee Weapon",
	weaponRanged: "Ranged Weapon",
	focusSpellcasting: "Spellcasting Focus",
	setGaming: "Gaming Set",
	toolArtisan: "Artisan's Tool",
};
Charactermancer_StartingEquipment._EQUIPMENT_SETS = {
	weapon: [
		...UtilDataConverter.WEAPONS_SIMPLE,
		...UtilDataConverter.WEAPONS_MARTIAL,
	],
	weaponSimple: [
		...UtilDataConverter.WEAPONS_SIMPLE,
	],
	weaponSimpleMelee: [
		"club|phb",
		"dagger|phb",
		"greatclub|phb",
		"handaxe|phb",
		"javelin|phb",
		"light hammer|phb",
		"mace|phb",
		"quarterstaff|phb",
		"sickle|phb",
		"spear|phb",
	],
	weaponMartial: [
		...UtilDataConverter.WEAPONS_MARTIAL,
	],
	weaponMartialMelee: [
		"battleaxe|phb",
		"flail|phb",
		"glaive|phb",
		"greataxe|phb",
		"greatsword|phb",
		"halberd|phb",
		"lance|phb",
		"longsword|phb",
		"maul|phb",
		"morningstar|phb",
		"pike|phb",
		"rapier|phb",
		"scimitar|phb",
		"shortsword|phb",
		"trident|phb",
		"war pick|phb",
		"warhammer|phb",
		"whip|phb",
	],
	instrumentMusical: [
		"bagpipes|phb",
		"drum|phb",
		"dulcimer|phb",
		"flute|phb",
		"horn|phb",
		"lute|phb",
		"lyre|phb",
		"pan flute|phb",
		"shawm|phb",
		"viol|phb",
	],
	armorLight: [
		"leather armor|phb",
		"padded armor|phb",
		"studded leather armor|phb",
	],
	armorMedium: [
		"hide armor|phb",
		"chain shirt|phb",
		"scale mail|phb",
		"breastplate|phb",
		"half plate armor|phb",
	],
	armorHeavy: [
		"ring mail|phb",
		"chain mail|phb",
		"splint armor|phb",
		"plate armor|phb",
	],
	weaponMelee: [
		"battleaxe|phb",
		"club|phb",
		"dagger|phb",
		"flail|phb",
		"glaive|phb",
		"greataxe|phb",
		"greatclub|phb",
		"greatsword|phb",
		"halberd|phb",
		"handaxe|phb",
		"javelin|phb",
		"lance|phb",
		"light hammer|phb",
		"longsword|phb",
		"mace|phb",
		"maul|phb",
		"morningstar|phb",
		"pike|phb",
		"quarterstaff|phb",
		"rapier|phb",
		"scimitar|phb",
		"shortsword|phb",
		"sickle|phb",
		"spear|phb",
		"staff|phb",
		"trident|phb",
		"war pick|phb",
		"warhammer|phb",
		"whip|phb",
	],
	weaponRanged: [
		"blowgun|phb",
		"dart|phb",
		"hand crossbow|phb",
		"heavy crossbow|phb",
		"light crossbow|phb",
		"longbow|phb",
		"net|phb",
		"shortbow|phb",
		"sling|phb",
	],
	focusSpellcasting: [
		"crystal|phb",
		"orb|phb",
		"rod|phb",
		"staff|phb",
		"wand|phb",
	],
	setGaming: [
		"dice set|phb",
		"dragonchess set|phb",
		"playing card set|phb",
		"three-dragon ante set|phb",
	],
	toolArtisan: [
		"alchemist's supplies|phb",
		"brewer's supplies|phb",
		"calligrapher's supplies|phb",
		"carpenter's tools|phb",
		"cartographer's tools|phb",
		"cobbler's tools|phb",
		"cook's utensils|phb",
		"glassblower's tools|phb",
		"jeweler's tools|phb",
		"leatherworker's tools|phb",
		"mason's tools|phb",
		"painter's supplies|phb",
		"potter's tools|phb",
		"smith's tools|phb",
		"tinker's tools|phb",
		"weaver's tools|phb",
		"woodcarver's tools|phb",
	],
};

class Charactermancer_Spell_SpellMeta {
	constructor ({ix, spell, isPrepared, isLearned, isUpdateOnly, existingItemId, preparationMode, usesValue, usesMax, usesPer}) {
		this.ix = ix;
		this.spell = spell; 		this.isPrepared = isPrepared;
		this.isLearned = isLearned;

				this.isUpdateOnly = isUpdateOnly; 		this.existingItemId = existingItemId;
		
				this.preparationMode = preparationMode;
		this.usesValue = usesValue;
		this.usesMax = usesMax;
		this.usesPer = usesPer;
			}
}

class Charactermancer_Spell extends BaseComponent {
	static async pApplyFormDataToActor (actor, formData, {cls, sc, taskRunner = null}) {
		const spells = formData?.data?.spells || [];
		for (let i = 0; i < spells.length; ++i) {
			const {
				spell,
				isPrepared,

				isUpdateOnly,
				existingItemId,

				preparationMode,
				usesValue,
				usesMax,
				usesPer,
				castAtLevel,
			} = spells[i];

			if (isUpdateOnly && existingItemId) {
				await DataConverterSpell.pSetSpellItemIsPrepared(actor.items.get(existingItemId), isPrepared);
				continue;
			}

			if (!Charactermancer_Spell._IMPORT_LIST_SPELL || Charactermancer_Spell._IMPORT_LIST_SPELL.actor !== actor) {
				const {ImportListSpell} = await Promise.resolve().then(function () { return ImportListSpell$1; });
				Charactermancer_Spell._IMPORT_LIST_SPELL = new ImportListSpell({actor: actor});
				await Charactermancer_Spell._IMPORT_LIST_SPELL.pInit();
			}

			await Charactermancer_Spell._IMPORT_LIST_SPELL.pImportEntry(
				spell,
				{
					taskRunner,
					isCharactermancer: true,
					opts_pGetSpellItem: {
						isActorItem: true,

						isPrepared: isPrepared,
						ability: sc?.spellcastingAbility || cls.spellcastingAbility,

						preparationMode,
						usesValue,
						usesMax,
						usesPer,
						castAtLevel,

						parentClassName: cls.name,
						parentClassSource: cls.source,
						parentSubclassName: sc?.name,
						parentSubclassShortName: sc?.shortName,
						parentSubclassSource: sc?.source,
					},
				},
			);
		}
	}

		constructor (opts) {
		opts = opts || {};
		super();

		this._actor = opts.actor;
		this._existingClass = opts.existingClass; 		this._existingCasterMeta = opts.existingCasterMeta;
		this._spellDatas = opts.spellDatas;
		this._className = opts.className;
		this._classSource = opts.classSource;
		this._subclassName = opts.subclassName;
		this._subclassShortName = opts.subclassShortName;
		this._subclassSource = opts.subclassSource;
		this._compsLevel = [...new Array(opts.maxLevel != null ? (opts.maxLevel + 1) : 10)]
			.map((_, i) => new Charactermancer_Spell_Level({spellDatas: opts.spellDatas, spellLevel: i, parent: this}));
		this._pageFilter = opts.pageFilter;
		this._$wrpsPreparedLearned = opts.$wrpsPreparedLearned;

		this._spellDataLookup = this._getSpellDataLookup();
		this._existingSpellLookup = this._getExistingSpellLookup();

		this._cacheSelectedListItem = null;
		this._cacheFilterValues = null;
		this._cacheBrewClassSpells = Charactermancer_Spell._getBrewClassSubclassSpellCache(opts.brewClassSpells, opts.brewSubclassSpells, opts.brewSubSubclassSpells);
	}

	_getSpellDataLookup () {
		const out = {hash: {}, slug: {}};
		this._spellDatas.forEach(sp => {
			MiscUtil.set(out, "hash", UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_SPELLS](sp), sp);
			MiscUtil.set(out, "slug", Parser.stringToSlug(Parser.sourceJsonToAbv(sp.source)), Parser.stringToSlug(sp.name), sp);
		});
		return out;
	}

	_getExistingSpellLookup () {
		if (!this._existingClass || !this._existingCasterMeta) return null;

		const spItems = this._actor.items
			.filter(it => it.type === "spell");

		const cntsSeenLearnedPerLevel = {};
		const cntsSeenPreparedPerLevel = {};

		const out = {};

		[...spItems]
						.sort((a, b) => {
				const flagsA = a.flags?.[SharedConsts.MODULE_ID];
				const flagsB = b.flags?.[SharedConsts.MODULE_ID];
				const a_ = flagsA?.parentClassName && flagsA?.parentClassSource ? 1 : 0;
				const b_ = flagsB?.parentClassName && flagsB?.parentClassSource ? 1 : 0;
				return b_ - a_;
			})
			.forEach(spItem => {
				const level = Number(spItem.system.level || 0);
				const lookupName = (spItem.name || "").trim().toLowerCase();
																const itemSourceMeta = UtilDataConverter.getItemSource(spItem);
				const lookupSource = (itemSourceMeta.source || "").toLowerCase();

				const flags = spItem.flags?.[SharedConsts.MODULE_ID];
				const parentClassName = flags?.parentClassName;
				const parentClassSource = flags?.parentClassSource;

				const isItemPrepared = spItem.system.preparation?.mode === "prepared" && spItem.system.preparation?.prepared;
				const isItemAlwaysPrepared = spItem.system.preparation?.mode === "always"
															|| level === 0;

								if (parentClassName && parentClassSource && parentClassName !== this._existingClass.name && parentClassSource !== this._existingClass.source) return;

								if (parentClassName && parentClassSource && parentClassName === this._existingClass.name && parentClassSource === this._existingClass.source) {
					const isLearned = level === 0 || (level !== 0 && this._existingCasterMeta.fixedLearnedProgression != null);
					const isPrepared = this._existingCasterMeta.maxPreparedSpells != null && isItemPrepared;

					if (isLearned) cntsSeenLearnedPerLevel[level] = (cntsSeenLearnedPerLevel[level] || 0) + 1;
					if (isPrepared) cntsSeenPreparedPerLevel[level] = (cntsSeenPreparedPerLevel[level] || 0) + 1;

					MiscUtil.set(out, level, lookupSource, lookupName, new Charactermancer_Spell.ExistingSpell({
						item: spItem,
						isLearned,
						isPrepared,
						isAlwaysPrepared: isItemAlwaysPrepared,
					}));

					return;
				}

								const isItemLearned = level === 0
										|| (spItem.system.preparation?.mode === "prepared" || spItem.system.preparation?.mode === "pact");

				const isLearned = level === 0
					? isItemLearned && this._existingCasterMeta.maxLearnedCantrips != null && ((cntsSeenLearnedPerLevel[level] || 0) < this._existingCasterMeta.maxLearnedCantrips)
					: isItemLearned && this._canLearnMoreFixedSpellsOfLevel({lvl: level, fixedLearnedProgression: this._existingCasterMeta.fixedLearnedProgression, cntSpellsKnown: cntsSeenLearnedPerLevel[level] || 0});

				const isPrepared = isItemPrepared
					&& this._existingCasterMeta.maxPreparedSpells != null
					&& (cntsSeenPreparedPerLevel[level] || 0) < this._existingCasterMeta.maxPreparedSpells;

				
								if (!this._getExistingSpellLookup_isOnSpellList(spItem)) return;

								if (!isLearned && this._isLearnedFixedSpellCasterAtLevel({lvl: level, fixedLearnedProgression: this._existingCasterMeta.fixedLearnedProgression})) return;

				if (isLearned) cntsSeenLearnedPerLevel[level] = (cntsSeenLearnedPerLevel[level] || 0) + 1;
				if (isPrepared) cntsSeenPreparedPerLevel[level] = (cntsSeenPreparedPerLevel[level] || 0) + 1;

				MiscUtil.set(out, level, lookupSource, lookupName, new Charactermancer_Spell.ExistingSpell({
					item: spItem,
					isLearned,
					isPrepared,
					isAlwaysPrepared: isItemAlwaysPrepared,
				}));
			});

		return out;
	}

		_getExistingSpellLookup_isOnSpellList (spItem) {
				const flags = spItem.flags?.[SharedConsts.MODULE_ID];

		if (flags?.page && flags?.source && flags?.hash) {
			const sp = this._spellDataLookup.hash[flags.hash];
			if (!sp) return false;
			return this.isAvailableClassSpell_(sp) || this.isAvailableSubclassSpell_(sp) || this.isAvailableExpandedSpell_(sp);
		}
		
				const itemSourceClean = UtilDataConverter.getItemSource(spItem).source || Parser.SRC_PHB;
		const itemNameClean = spItem.name.trim().replace(/\s+/g, " ").toLowerCase();
		const sp = MiscUtil.get(this._spellDataLookup.slug, Parser.stringToSlug(itemSourceClean), Parser.stringToSlug(itemNameClean));
		if (!sp) return false;
		return this.isAvailableClassSpell_(sp) || this.isAvailableSubclassSpell_(sp) || this.isAvailableExpandedSpell_(sp);
	}

	static _getBrewClassSubclassSpellCache (brewClassSpells, brewSubclassSpells, brewSubSubclassSpells) {
		const out = {};
		(brewClassSpells || []).forEach(it => this._getBrewClassSubclassSpellCache_addItem(out, it));
		(brewSubclassSpells || []).forEach(it => this._getBrewClassSubclassSpellCache_addItem(out, it));
		(brewSubSubclassSpells || []).forEach(it => this._getBrewClassSubclassSpellCache_addItem(out, it));
		return out;
	}

	static _getBrewClassSubclassSpellCache_addItem (out, it) {
		if (typeof it === "string") {
			const {name, source} = DataUtil.proxy.unpackUid("spell", it.trim(), "spell", {isLower: true});
			MiscUtil.set(out, "spell", source, name, true);
			return;
		}

		if (it.name) return MiscUtil.set(out, "spell", (it.source || Parser.SRC_PHB).trim().toLowerCase(), it.name.trim().toLowerCase(), true);

		if (it.className) {
			let prop = "class";
			const classSource = it.classSource || Parser.SRC_PHB;
			const path = [classSource, it.className];
			if (it.subclassName) {
				prop = "subclass";
				const subclassSource = it.subclassSource || classSource;
				path.push(subclassSource, it.subclassName);
				if (it.subSubclassName) {
					prop = "subSubclass";
					path.push(it.subSubclassName);
				}
			}
			MiscUtil.set(out, prop, ...path.map(it => it.trim().toLowerCase()), true);
		}
	}

	get pageFilter () { return this._pageFilter; }

	set subclassName (val) { this._subclassName = val; }
	set subclassShortName (val) { this._subclassShortName = val; }
	set subclassSource (val) { this._subclassSource = val; }

	get cacheSelectedListItem () { return this._cacheSelectedListItem; }
	set cacheSelectedListItem (val) { this._cacheSelectedListItem = val; }

	get isPreparedCaster () { return this._state.maxPrepared != null; }

	set spellLevelLow (val) { this._state.spellLevelLow = val; }
	get spellLevelLow () { return this._state.spellLevelLow; }

	set spellLevelHigh (val) { this._state.spellLevelHigh = val; }
	get spellLevelHigh () { return this._state.spellLevelHigh; }

	get ixViewedSpell () { return this._state.ixViewedSpell; }
	set ixViewedSpell (val) { this._state.ixViewedSpell = val; }

	get maxLearnedCantrips () { return this._state.maxLearnedCantrips; }
	set maxLearnedCantrips (val) { this._state.maxLearnedCantrips = val; }

	get fixedLearnedProgression () { return this._state.fixedLearnedProgression; }
	set fixedLearnedProgression (val) { this._state.fixedLearnedProgression = val; }

	get fixedLearnedProgressionDefault () { return this._state.fixedLearnedProgressionDefault; }
	set fixedLearnedProgressionDefault (val) { this._state.fixedLearnedProgressionDefault = val; }

	get pulseFixedLearned () { return this._state.pulseFixedLearned; }
	set pulseFixedLearned (val) { this._state.pulseFixedLearned = val; }

	set maxPrepared (val) {
		this._state.maxPrepared = val;
		if (val != null) this._state.maxLearned = null;
	}

	get cntLearnedSpells () { return this._state.cntLearnedSpells; }
	set cntLearnedSpells (val) { this._state.cntLearnedSpells = val; }

	get cntLearnedCantrips () { return this._state.cntLearnedCantrips; }
	set cntLearnedCantrips (val) { this._state.cntLearnedCantrips = val; }

	get cntPrepared () { return this._state.cntPrepared; }
	set cntPrepared (val) { this._state.cntPrepared = val; }

	get casterProgression () { return this._state.casterProgression; }
	set casterProgression (val) { this._state.casterProgression = val; }

	set isIncludeUaEtcSpellLists (val) { this._state.isIncludeUaEtcSpellLists = val; }

	addHookMaxLearnedCantrips (hk) { this._addHookBase("maxLearnedCantrips", hk); }
	addHookSpellLevelLow (hk) { this._addHookBase("spellLevelLow", hk); }
	addHookSpellLevelHigh (hk) { this._addHookBase("spellLevelHigh", hk); }
	addHookFixedLearnedProgression (hk) { this._addHookBase("fixedLearnedProgression", hk); }

	addHookIsPreparedCaster (hk) { this._addHookBase("maxPrepared", hk); }

	addHookIsMaxLearnedSpells (hk) {
		this._addHookBase("fixedLearnedProgression", hk);
		this._addHookBase("pulseFixedLearned", hk);
		this._addHookBase("spellLevelLow", hk);
		this._addHookBase("spellLevelHigh", hk);
	}

	addHookIsMaxLearnedCantrips (hk) {
		this._addHookBase("cntLearnedCantrips", hk);
		this._addHookBase("maxLearnedCantrips", hk);
	}

	addHookIsMaxPrepared (hk) {
		this._addHookBase("cntPrepared", hk);
		this._addHookBase("maxPrepared", hk);
	}

	isLearnedFixedSpellCasterAtLevel_ (lvl) {
						return this._isLearnedFixedSpellCasterAtLevel({lvl, fixedLearnedProgression: this._state.fixedLearnedProgressionDefault});
	}

	_isLearnedFixedSpellCasterAtLevel ({lvl, fixedLearnedProgression}) {
		return lvl > 0 && fixedLearnedProgression != null && fixedLearnedProgression[lvl - 1] > 0;
	}

	canLearnMoreFixedSpellsOfLevel_ (lvl) {
		return this._canLearnMoreFixedSpellsOfLevel({
			lvl,
			fixedLearnedProgression: this._state.fixedLearnedProgression,
			cntSpellsKnown: this._compsLevel[lvl].getSpellsKnown().length,
		});
	}

	_canLearnMoreFixedSpellsOfLevel ({lvl, fixedLearnedProgression, cntSpellsKnown}) {
		if (!fixedLearnedProgression) return false;
		if (!fixedLearnedProgression[lvl - 1]) return false;
		return cntSpellsKnown < fixedLearnedProgression[lvl - 1];
	}

	isOverLearnFixedSpellsLimitOfLevel_ (lvl) {
		if (!this._state.fixedLearnedProgression) return false;
		if (!this._state.fixedLearnedProgression[lvl - 1]) return false;
		const spellsKnown = this._compsLevel[lvl].getSpellsKnown();
		return spellsKnown.length > this._state.fixedLearnedProgression[lvl - 1];
	}

	canLearnMoreCantrips_ () { return this._state.cntLearnedCantrips < (this._state.maxLearnedCantrips || 0); }
	isOverLearnCantripsLimit_ () { return this._state.cntLearnedCantrips > (this._state.maxLearnedCantrips || 0); }

	canPrepareMore_ () { return this._state.cntPrepared < (this._state.maxPrepared || 0); }
	isOverPrepareLimit_ () { return this._state.cntPrepared > (this._state.maxPrepared || 0); }

	_getCntSpellsKnown () { return this._compsLevel.map(it => it.getSpellsKnown().length).sum(); }
	_getTotalSpellsKnown () { return (this._state.fixedLearnedProgression || []).sum(); }

	render ($wrp, $dispSpell) {
				const hkPreparedLearned = () => {
			const parts = [
				this._state.maxLearnedCantrips ? `Cantrips learned: ${this._state.cntLearnedCantrips}/${this._state.maxLearnedCantrips}` : null,
				this._state.fixedLearnedProgression ? `Spells learned: ${this._getCntSpellsKnown()}/${this._getTotalSpellsKnown()}` : null,
				this._state.maxPrepared ? `Prepared: ${this._state.cntPrepared}/${this._state.maxPrepared}` : null,
			].filter(Boolean);

			(this._$wrpsPreparedLearned || [])
				.forEach($it => {
					$it
						.toggleVe(parts.length)
						.html(parts.join(`<div class="mx-1">\u2014</div>`));
				});
		};
		this._addHookBase("cntPrepared", hkPreparedLearned);
		this._addHookBase("maxPrepared", hkPreparedLearned);
		this._addHookBase("fixedLearnedProgression", hkPreparedLearned);
		this._addHookBase("pulseFixedLearned", hkPreparedLearned);
		this._addHookBase("cntLearnedCantrips", hkPreparedLearned);
		this._addHookBase("maxLearnedCantrips", hkPreparedLearned);
		hkPreparedLearned();
		
				const hkAlwaysPreparedSpells = () => this._handleAlwaysPreparedSpells();
		this._addHookBase("alwaysPreparedSpellsRace", hkAlwaysPreparedSpells);
		this._addHookBase("alwaysPreparedSpellsBackground", hkAlwaysPreparedSpells);
		this._addHookBase("alwaysPreparedSpellsClass", hkAlwaysPreparedSpells);
		this._addHookBase("alwaysPreparedSpellsSubclass", hkAlwaysPreparedSpells);
		hkAlwaysPreparedSpells();
		
				const hkExpandedSpells = () => this.handleFilterChange();
		this._addHookBase("expandedSpellsRace", hkExpandedSpells);
		this._addHookBase("expandedSpellsBackground", hkExpandedSpells);
		this._addHookBase("expandedSpellsClass", hkExpandedSpells);
		this._addHookBase("expandedSpellsSubclass", hkExpandedSpells);

		this._addHookBase("isIncludeUaEtcSpellLists", hkExpandedSpells);
		hkExpandedSpells();
		
				const hkAlwaysKnownSpells = () => this._handleAlwaysKnownSpells();
		this._addHookBase("alwaysKnownSpellsRace", hkAlwaysKnownSpells);
		this._addHookBase("alwaysKnownSpellsBackground", hkAlwaysKnownSpells);
		this._addHookBase("alwaysKnownSpellsClass", hkAlwaysKnownSpells);
		this._addHookBase("alwaysKnownSpellsSubclass", hkAlwaysKnownSpells);
		hkAlwaysKnownSpells();
		
				this._compsLevel.forEach(it => it.render($wrp));
		
				const hkDisplaySpell = () => {
												$dispSpell.empty();
			const spell = this._spellDatas[this._state.ixViewedSpell];
			if (!spell) return $dispSpell.append(`<div class="ve-flex-vh-center w-100 h-100 italic">Select a spell to view</div>`);

			$dispSpell.append(Renderer.hover.$getHoverContent_stats(UrlUtil.PG_SPELLS, MiscUtil.copy(spell)));
		};
		this._addHookBase("ixViewedSpell", hkDisplaySpell);
		hkDisplaySpell();
			}

	_handleAlwaysPreparedSpells () { this._compsLevel.forEach(it => it.handleAlwaysPreparedSpells_()); }
	_handleAlwaysKnownSpells () { this._compsLevel.forEach(it => it.handleAlwaysKnownSpells_()); }

	handleFilterChange (f) {
		this._cacheFilterValues = f || this._cacheFilterValues;
		if (!this._cacheFilterValues) return; 		this._compsLevel.forEach(it => it.handleFilterChange(this._cacheFilterValues));
	}

	handleSearch (searchTerm) { this._compsLevel.forEach(it => it.handleSearch(searchTerm)); }

	getExistingSpellMeta_ (spell) {
		if (!this._existingCasterMeta || !this._existingSpellLookup) return null;
		const lookupName = spell.name.toLowerCase();
		const lookupSource = spell.source.toLowerCase();
		const lookupSourceAlt = Parser.sourceJsonToAbv(spell.source).toLowerCase();
		return this._existingSpellLookup[spell.level]?.[lookupSource]?.[lookupName]
			|| this._existingSpellLookup[spell.level]?.[lookupSourceAlt]?.[lookupName];
	}

	isAvailableClassSpell_ (sp) {
		if (!this._className || !this._classSource) return false;

		const fromClassList = Renderer.spell.getCombinedClasses(sp, "fromClassList");
		const fromClassListVariant = Renderer.spell.getCombinedClasses(sp, "fromClassListVariant")
			.filter(it => this._state.isIncludeUaEtcSpellLists ? true : !SourceUtil.isNonstandardSource(it.definedInSource));

		const {className, classSource} = this.constructor._getMappedClassDetails({className: this._className, classSource: this._classSource});

		if (
			!fromClassList.some(it => it.name === className && it.source === classSource)
			&& !fromClassListVariant.some(it => it.name === className && it.source === classSource)
			&& !this._hasBrewClassSpell(sp, fromClassList, fromClassListVariant)) return false;

		return true;
	}

	isAvailableSubclassSpell_ (sp) {
		if ((!this._subclassName && !this._subclassShortName) || !this._subclassSource) return false;

		const fromSubclassList = Renderer.spell.getCombinedClasses(sp, "fromSubclass");

		const scName = this._subclassShortName || this._subclassName;

		if (!fromSubclassList.some(it => it?.class.name === this._className && it?.class.source === this._classSource && (it?.subclass.shortName || it?.subclass.name) === scName && it?.subclass.source === this._subclassSource)
			&& !this._hasBrewSubclassSpell(sp, fromSubclassList)) return false;

		return true;
	}

	_hasBrewClassSpell (sp, fromClassList, fromClassListVariant) {
		if (MiscUtil.get(this._cacheBrewClassSpells, "spell", sp.source.toLowerCase(), sp.name.toLowerCase())) return true;
		if (fromClassList.some(it => MiscUtil.get(this._cacheBrewClassSpells, "class", it.source.toLowerCase(), it.name.toLowerCase()))) return true;
		if (fromClassListVariant.some(it => MiscUtil.get(this._cacheBrewClassSpells, "class", it.source.toLowerCase(), it.name.toLowerCase()))) return true;
		return false;
	}

	_hasBrewSubclassSpell (sp, fromSubclassList) {
		if (MiscUtil.get(this._cacheBrewClassSpells, "spell", sp.source.toLowerCase(), sp.name.toLowerCase())) return true;
		if (fromSubclassList.some(it => !it.subSubclass && MiscUtil.get(this._cacheBrewClassSpells, "subclass", it.class.source.toLowerCase(), it.class.name.toLowerCase(), it.subclass.source.toLowerCase(), it.subclass.name.toLowerCase()))) return true;
		if (fromSubclassList.some(it => it.subSubclass && MiscUtil.get(this._cacheBrewClassSpells, "subSubclass", it.class.source.toLowerCase(), it.class.name.toLowerCase(), it.subclass.source.toLowerCase(), it.subclass.name.toLowerCase(), it.subclass.subSubclass.toLowerCase()))) return true;
		return false;
	}

	isAlwaysPreparedSpell_ (sp) {
		const spellUid = this.constructor._getSpellUid(sp);
		if (this._state.alwaysPreparedSpellsRace.includes(spellUid)) return true;
		if (this._state.alwaysPreparedSpellsBackground.includes(spellUid)) return true;
		if (this._state.alwaysPreparedSpellsClass.includes(spellUid)) return true;
		if (this._state.alwaysPreparedSpellsSubclass.includes(spellUid)) return true;
				return false;
	}

	isAvailableExpandedSpell_ (sp) {
		const spellUid = this.constructor._getSpellUid(sp);
		if (this._state.expandedSpellsRace.includes(spellUid)) return true;
		if (this._state.expandedSpellsBackground.includes(spellUid)) return true;
		if (this._state.expandedSpellsClass.includes(spellUid)) return true;
		if (this._state.expandedSpellsSubclass.includes(spellUid)) return true;
				return false;
	}

	isAlwaysKnownSpell_ (sp) {
		const spellUid = this.constructor._getSpellUid(sp);
		if (this._state.alwaysKnownSpellsRace.includes(spellUid)) return true;
		if (this._state.alwaysKnownSpellsBackground.includes(spellUid)) return true;
		if (this._state.alwaysKnownSpellsClass.includes(spellUid)) return true;
		if (this._state.alwaysKnownSpellsSubclass.includes(spellUid)) return true;
				return false;
	}

	static _getSpellUid (sp) { return `${sp.name.toLowerCase()}|${sp.source.toLowerCase()}`; }

		set alwaysPreparedSpellsRace (val) { this._state.alwaysPreparedSpellsRace = val; }
	set alwaysPreparedSpellsBackground (val) { this._state.alwaysPreparedSpellsBackground = val; }
	set alwaysPreparedSpellsClass (val) { this._state.alwaysPreparedSpellsClass = val; }
	set alwaysPreparedSpellsSubclass (val) { this._state.alwaysPreparedSpellsSubclass = val; }
	
		set expandedSpellsRace (val) { this._state.expandedSpellsRace = val; }
	set expandedSpellsBackground (val) { this._state.expandedSpellsBackground = val; }
	set expandedSpellsClass (val) { this._state.expandedSpellsClass = val; }
	set expandedSpellsSubclass (val) { this._state.expandedSpellsSubclass = val; }
	
		set alwaysKnownSpellsRace (val) { this._state.alwaysKnownSpellsRace = val; }
	set alwaysKnownSpellsBackground (val) { this._state.alwaysKnownSpellsBackground = val; }
	set alwaysKnownSpellsClass (val) { this._state.alwaysKnownSpellsClass = val; }
	set alwaysKnownSpellsSubclass (val) { this._state.alwaysKnownSpellsSubclass = val; }
	
	async pGetFormData (filterValues) {
		return {
			isFormComplete: (this._state.cntLearnedCantrips === this._state.maxLearnedCantrips || 0)
				&& (this._state.cntPrepared === this._state.maxPrepared || 0),
			data: {
				spells: this._compsLevel.map(comp => comp.getFormSubData(filterValues)).flat(),
			},
		};
	}

	_getDefaultState () {
		return {
			spellLevelLow: null,
			spellLevelHigh: null,
			ixViewedSpell: null,

			cntLearnedCantrips: 0,
			maxLearnedCantrips: null,

			fixedLearnedProgression: null,
			pulseFixedLearned: false,

			cntPrepared: 0,
			maxPrepared: null,

			alwaysPreparedSpellsRace: [],
			alwaysPreparedSpellsBackground: [],
			alwaysPreparedSpellsClass: [],
			alwaysPreparedSpellsSubclass: [],
						alwaysPreparedSpellsFeat: {},
			
			expandedSpellsRace: [],
			expandedSpellsBackground: [],
			expandedSpellsClass: [],
			expandedSpellsSubclass: [],
						expandedSpellsFeat: {},
			
			alwaysKnownSpellsRace: [],
			alwaysKnownSpellsBackground: [],
			alwaysKnownSpellsClass: [],
			alwaysKnownSpellsSubclass: [],
						alwaysKnownSpellsFeat: {},
			
			casterProgression: null,

			isIncludeUaEtcSpellLists: false,
		};
	}

		static _getMappedClassDetails ({className, classSource}) {
		return Charactermancer_Spell._CLASS_MAP?.[classSource]?.[className] || {className, classSource};
	}
}
Charactermancer_Spell._IMPORT_LIST_SPELL = null;
Charactermancer_Spell._CLASS_MAP = {
	[Parser.SRC_UATRR]: {
		"Ranger (Revised)": {
			className: "Ranger",
			classSource: Parser.SRC_PHB,
		},
	},
};

Charactermancer_Spell.ExistingSpell = class {
	constructor ({item, isLearned, isPrepared, isAlwaysPrepared}) {
		this.item = item; 		this.isLearned = isLearned;
		this.isPrepared = isPrepared;
		this.isAlwaysPrepared = isAlwaysPrepared;
	}
};

class Charactermancer_Spell_Modal extends Charactermancer_Spell {
	constructor (opts) {
		opts.pageFilter = new PageFilterSpells();

		super(opts);
	}

	static pGetUserInput (opts) {
		const comp = new this(opts);
		comp.maxLearnedCantrips = opts.maxLearnedCantrips;

		return UtilApplications.pGetImportCompApplicationFormData({
			comp,
			width: Util.getMaxWindowWidth(1200),
			height: Util.getMaxWindowHeight(),
		});
	}

	get modalTitle () { return `Select Cantrips`; }

	pRender ($wrpModalInner) {
		const $wrpLhs = $(`<div class="ve-flex-col h-100 w-50"></div>`);
		const $wrpRhs = $(`<div class="ve-flex-col h-100 w-50"></div>`);

		const pRender = this._render_pFilterBox($wrpLhs);
		$wrpRhs.append(`<i class="ve-muted text-center">Select a spell to view it here.</i>`);

		$$`<div class="split w-100 h-100">
			${$wrpLhs}
			<div class="vr-1 h-100"></div>
			${$wrpRhs}
		</div>`.appendTo($wrpModalInner);

		super.render($wrpLhs, $wrpRhs);

		return pRender
			.then(() => {
				this.handleFilterChange(this._pageFilter.filterBox.getValues());
			});
	}

	_render_pFilterBox ($wrp) {
		const $btnFilter = $(`<button class="btn-5et veapp__btn-filter">Filter</button>`);
		const $btnToggleFilterSummary = $(`<button class="btn btn-5et" title="Toggle Filter Summary Display"><span class="glyphicon glyphicon-resize-small"></span></button>`);
		const $iptSearch = $(`<input type="search" class="search w-100 form-control h-initial" placeholder="Find spell...">`);
		const $btnReset = $(`<button class="btn-5et veapp__btn-list-reset">Reset</button>`)
			.click(() => $iptSearch.val("").keyup());

		const $wrpMiniPills = $(`<div class="fltr__mini-view btn-group"></div>`);

		$$($wrp)`
			<div class="ve-flex-v-stretch input-group input-group--top no-shrink">
				${$btnFilter}
				${$btnToggleFilterSummary}
				${$iptSearch}
				${$btnReset}
			</div>
			${$wrpMiniPills}
			<div class="ve-flex-v-stretch input-group input-group--bottom mb-1 no-shrink">
				<button class="btn-5et w-100" disabled></button>
			</div>
		`;

		return this._pageFilter.pInitFilterBox({
			$iptSearch: $iptSearch,
			$btnReset: $btnReset,
			$btnOpen: $btnFilter,
			$btnToggleSummaryHidden: $btnToggleFilterSummary,
			$wrpMiniPills: $wrpMiniPills,
			namespace: `Charactermancer_Spell_Modal.filter`,
		}).then(() => {
			this._spellDatas.forEach(it => this._pageFilter.mutateAndAddToFilters(it));

			this._pageFilter.trimState();
			this._pageFilter.filterBox.render();

			UiUtil.bindTypingEnd({
				$ipt: $iptSearch,
				fnKeyup: () => {
					const val = List.getCleanSearchTerm($iptSearch.val());
					if (this._lastSearchTermSpells === val) return;
					this._lastSearchTermSpells = val;

					this.handleSearch(val);
				},
			});

			this._pageFilter.filterBox.on(FilterBox.EVNT_VALCHANGE, () => {
				this.handleFilterChange(this._pageFilter.filterBox.getValues());
			});
		});
	}
}

class Charactermancer_Spell_Level extends BaseComponent {
		constructor (opts) {
		super();
		opts = opts || {};

		this._spellDatas = opts.spellDatas;
		this._spellLevel = opts.spellLevel;
		this._parent = opts.parent;

		this._$wrpRows = null;
		this._$dispNoRows = null;
		this._list = null;
	}

	_isAvailableSpell (sp) {
		return sp.level === this._spellLevel;
	}

	render ($wrp) {
		this._$wrpRows = $$`<div class="ve-flex-col manc__list mt-1 mb-3"></div>`;

		this._$dispNoRows = $(`<div class="ve-flex-vh-center italic ve-muted ve-small mt-1">No matching spells</div>`).hideVe();
		const doUpdateDispNoRows = () => {
			this._$dispNoRows.toggleVe(!this._list.visibleItems.length && $btnToggle.text() !== "[+]");
		};

		const $wrpBtnsSort = $(`<div class="ve-flex-v-stretch input-group no-shrink">
			<button class="btn-5et btn-xxs col-3-2 pr-1 sort" data-sort="name">Name</button>
			<button class="btn-5et btn-xxs col-1-2 px-1 sort" data-sort="time">Time</button>
			<button class="btn-5et btn-xxs col-1-2 px-1 sort" data-sort="school">School</button>
			<button class="btn-5et btn-xxs col-0-5 px-1 sort" data-sort="concentration" title="Concentration">C.</button>
			<button class="btn-5et btn-xxs col-0-5 px-1 sort" data-sort="ritual" title="Ritual">R.</button>
			<button class="btn-5et btn-xxs col-2-6 px-1 sort" data-sort="range">Range</button>
			<button class="btn-5et btn-xxs col-1-2 px-1 sort" data-sort="source">Source</button>
			<button class="btn-5et btn-xxs col-1-6 pl-1" disabled>&nbsp;</button>
		</div>`);

		this._list = new List({
			$wrpList: this._$wrpRows,
			fnSort: PageFilterSpells.sortSpells,
			fnSearch: (li, searchTerm) => {
				const {ixLearned, ixPrepared, ixAlwaysPrepared, ixAlwaysKnownSpell} = this.constructor._getProps(li.ix);

								if ([ixLearned, ixPrepared, ixAlwaysPrepared, ixAlwaysKnownSpell].some(k => this._state[k])) return true;

				return li.searchText.includes(searchTerm);
			},
		});
		SortUtil.initBtnSortHandlers($wrpBtnsSort, this._list);

		this._list.on("updated", () => doUpdateDispNoRows());

		const $btnToggle = $(`<div class="py-1 clickable ve-muted">[\u2012]</div>`)
			.click(() => {
				$btnToggle.text($btnToggle.text() === "[+]" ? "[\u2012]" : "[+]");
				this._$wrpRows.toggleVe();
				$wrpBtnsSort.toggleVe();
				doUpdateDispNoRows();
			});

		const $wrpInner = $$`<div class="ve-flex-col w-100">
			<div class="split-v-center">
				<div class="bold">${Parser.spLevelToFullLevelText(this._spellLevel)}</div>
				${$btnToggle}
			</div>
			${$wrpBtnsSort}
			${this._$dispNoRows}
			${this._$wrpRows}
		</div>`.appendTo($wrp);

		const len = this._spellDatas.length;
		for (let i = 0; i < len; ++i) {
			const sp = this._spellDatas[i];

			if (!this._isAvailableSpell(sp)) continue;

			const listItem = this._getListItem(sp, i);
			if (!listItem) continue;
			this._list.addItem(listItem);
		}

		this._list.init();

		const hkSpellLevel = () => {
			const isWithinRange = this._isWithinLevelRange();

			$wrpInner.toggleVe(isWithinRange);
			if (!isWithinRange) this._resetLevelSpells();
		};
		this._parent.addHookMaxLearnedCantrips(hkSpellLevel);
		this._parent.addHookSpellLevelLow(hkSpellLevel);
		this._parent.addHookSpellLevelHigh(hkSpellLevel);
		this._parent.addHookFixedLearnedProgression(hkSpellLevel);
		hkSpellLevel();

		if (this._spellLevel === 0) this._render_bindCantripHooks();
		else this._render_bindLevelledSpellHooks();
	}

	_render_bindCantripHooks () {
		const hkIsMaxLearnedCantrips = () => {
			this._$wrpRows.toggleClass("manc-sp__is-max-learned-cantrips", !this._parent.canLearnMoreCantrips_());
			this._$wrpRows.toggleClass("manc-sp__is-max-learned-cantrips--is-over-limit", this._parent.isOverLearnCantripsLimit_());
		};
		this._parent.addHookIsMaxLearnedCantrips(hkIsMaxLearnedCantrips);
		hkIsMaxLearnedCantrips();
	}

	_render_bindLevelledSpellHooks () {
		const hkIsPrepared = () => this._$wrpRows.toggleClass("manc-sp__is-prepared-caster", this._parent.isPreparedCaster);
		this._parent.addHookIsPreparedCaster(hkIsPrepared);
		hkIsPrepared();

		const hkIsMaxLearnedSpells = () => {
			const isLearnCaster = this._parent.isLearnedFixedSpellCasterAtLevel_(this._spellLevel);

			let isMaxLearnedSpells = true;
			let isOverMaxLearnedSpells = true;

			if (isLearnCaster) {
				if (this._parent.canLearnMoreFixedSpellsOfLevel_(this._spellLevel)) isMaxLearnedSpells = false;
				if (!this._parent.isOverLearnFixedSpellsLimitOfLevel_(this._spellLevel)) isOverMaxLearnedSpells = false;
			}

			this._$wrpRows.toggleClass("manc-sp__is-learn-caster", isLearnCaster);
			this._$wrpRows.toggleClass("manc-sp__is-max-learned-spells", isLearnCaster && isMaxLearnedSpells);
			this._$wrpRows.toggleClass("manc-sp__is-max-learned-spells--is-over-limit", isLearnCaster && isOverMaxLearnedSpells);
		};
		this._parent.addHookIsMaxLearnedSpells(hkIsMaxLearnedSpells);
		hkIsMaxLearnedSpells();

		const hkIsMaxPrepared = () => {
			this._$wrpRows.toggleClass("manc-sp__is-max-prepared-spells", !this._parent.canPrepareMore_());
			this._$wrpRows.toggleClass("manc-sp__is-max-prepared-spells--is-over-limit", this._parent.isOverPrepareLimit_());
		};
		this._parent.addHookIsMaxPrepared(hkIsMaxPrepared);
		hkIsMaxPrepared();
	}

	_isWithinLevelRange () {
				if (this._spellLevel !== 0 && this._parent.fixedLearnedProgression != null && this._parent.fixedLearnedProgression[this._spellLevel - 1]) return true;

		if (this._spellLevel === 0) {
						return !!this._parent.maxLearnedCantrips;
		}

		return this._spellLevel >= (this._parent.spellLevelLow ?? Number.MAX_SAFE_INTEGER)
			&& this._spellLevel <= (this._parent.spellLevelHigh ?? Number.MIN_SAFE_INTEGER);
	}

	_getListItem (spell, spI) {
		const {ixLearned, ixPrepared, ixAlwaysPrepared, ixAlwaysKnownSpell} = this.constructor._getProps(spI);

		const existingSpellMeta = this._parent.getExistingSpellMeta_(spell);
		if (existingSpellMeta) {
			if (existingSpellMeta.isLearned) {
				this._state[ixLearned] = true;
				if (spell.level === 0) this._parent.cntLearnedCantrips++;
			}

			if (existingSpellMeta.isPrepared && !existingSpellMeta.isAlwaysPrepared) {
				this._state[ixPrepared] = true;
				this._parent.cntPrepared++;
			}

			if (existingSpellMeta.isAlwaysPrepared) {
				this._state[ixAlwaysPrepared] = true;
			}
		}

		const eleRow = document.createElement("div");
		eleRow.className = `ve-flex-v-center manc__list-row clickable veapp__list-row veapp__list-row-hoverable`;
		eleRow.dataset.ix = spI;

		const source = Parser.sourceJsonToAbv(spell.source);
		const time = PageFilterSpells.getTblTimeStr(spell.time[0]);
		const school = Parser.spSchoolAndSubschoolsAbvsShort(spell.school, spell.subschools);
		const concentration = spell._isConc ? "×" : "";
		const ritual = spell.meta?.ritual ? "×" : "";
		const range = Parser.spRangeToFull(spell.range);

		const isLearnDisabled = existingSpellMeta || this._state[ixAlwaysKnownSpell];

		const isPrepareDisabledExistingSpell = existingSpellMeta
			&& (this._spellLevel === 0 || existingSpellMeta.isLearned);
		const isPrepareDisabled = isPrepareDisabledExistingSpell || this._state[ixAlwaysPrepared];

		eleRow.innerHTML = `
			<div class="col-3-2 pl-0">${spell.name}</div>
			<div class="col-1-2 text-center">${time}</div>
			<div class="col-1-2 sp__school-${spell.school} text-center" title="${Parser.spSchoolAndSubschoolsAbvsToFull(spell.school, spell.subschools)}" ${Parser.spSchoolAbvToStyle(spell.school)}>${school}</div>
			<div class="col-0-5 text-center bold imp-sp__disp-conc" title="Concentration">${concentration}</div>
			<div class="col-0-5 text-center bold imp-sp__disp-ritual" title="Ritual">${ritual}</div>
			<div class="col-2-6 text-right">${range}</div>
			<div class="col-1-2 text-center ${Parser.sourceJsonToColor(spell.source)}" title="${Parser.sourceJsonToFull(spell.source)}" ${Parser.sourceJsonToStyle(spell.source)}>${source}</div>

			<div class="ve-flex-vh-center col-1-6 pr-0">
				<button
					class="btn manc__list-row-button ${this._spellLevel === 0 ? "manc-sp__btn-learn-cantrip" : "manc-sp__btn-learn-spell"} ${this._state[ixLearned] || existingSpellMeta?.isLearned || this._state[ixAlwaysKnownSpell] ? "active" : ""}"
					name="${this._spellLevel === 0 ? "btn-learn-cantrip" : "btn-learn-spell"}"
					${isLearnDisabled ? `disabled` : ""}
					${existingSpellMeta ? `data-plut-is-existing-spell="true"` : ""}
					${existingSpellMeta ? `title="(Previously Learned Spell)"` : ""}
				>Learn</button>

				${this._spellLevel !== 0 ? `<button
					class="btn manc__list-row-button manc-sp__btn-prepare ${this._state[ixPrepared] || this._state[ixAlwaysPrepared] || existingSpellMeta?.isPrepared || existingSpellMeta?.isAlwaysPrepared ? "active" : ""}"
					name="btn-prepare"
					title="${isPrepareDisabledExistingSpell ? `(Previously Added Spell)` : `Prepare`}"
					${isPrepareDisabled ? `disabled` : ""}
					${isPrepareDisabledExistingSpell ? `data-plut-is-existing-spell="true"` : ""}
				>Prep.</button>` : ""}
			</div>
		`;

		const elesBtns = eleRow.querySelectorAll("button");
		const [btnLearn, btnPrepare] = elesBtns;

		const listItem = new ListItem(
			spI,
			eleRow,
			spell.name,
			{
				source,
				level: spell.level,
				time,
				school: Parser.spSchoolAbvToFull(spell.school),
				concentration,
				ritual,
				normalisedTime: spell._normalisedTime,
				normalisedRange: spell._normalisedRange,
			},
			{
				btnLearn,
				btnPrepare,
			},
		);

		elesBtns.forEach(btn => {
			btn.addEventListener("click", evt => {
				evt.stopPropagation();
				evt.preventDefault();

				const isActive = btn.classList.contains("active");

				switch (btn.name) {
					case "btn-learn-cantrip": {
						if (!isActive && !this._parent.canLearnMoreCantrips_()) return;

						btn.classList.toggle("active");
						this._state[ixLearned] = !this._state[ixLearned];
						if (this._state[ixLearned]) this._parent.cntLearnedCantrips++;
						else this._parent.cntLearnedCantrips--;

						break;
					}

					case "btn-learn-spell": {
						this._handleListItemBtnLearnClick_doFixed({btnLearn, btnPrepare, isActive, ixPrepared, ixLearned});
						break;
					}

					case "btn-prepare": {
						if (!isActive && !this._parent.canPrepareMore_()) return;

																		if (!isActive && this._parent.isLearnedFixedSpellCasterAtLevel_(this._spellLevel) && !this._state[ixLearned]) {
							const isLearned = this._handleListItemBtnLearnClick_doFixed({btnLearn, btnPrepare, isActive: this._state[ixLearned], ixPrepared, ixLearned});
							if (!isLearned) return;
						}

						btn.classList.toggle("active");
						this._state[ixPrepared] = !this._state[ixPrepared];
						if (this._state[ixPrepared]) this._parent.cntPrepared++;
						else this._parent.cntPrepared--;

						break;
					}

					default: throw new Error(`Unhandled button name: "${btn.name}"`);
				}
			});
		});

		eleRow.addEventListener("click", evt => {
			evt.stopPropagation();
			evt.preventDefault();

			if (this._parent.cacheSelectedListItem) this._parent.cacheSelectedListItem.ele.classList.remove("list-multi-selected");

			eleRow.classList.add("list-multi-selected");
			this._parent.ixViewedSpell = spI;
			this._parent.cacheSelectedListItem = listItem;
		});

		return listItem;
	}

	_handleListItemBtnLearnClick_do_doLearn ({btnLearn, btnPrepare, isActive, ixPrepared, ixLearned}) {
				if (isActive && this._parent.isPreparedCaster && this._state[ixPrepared]) {
			this._state[ixPrepared] = false;
			btnPrepare.classList.remove("active");
			this._parent.cntPrepared--;
		}

		btnLearn.classList.toggle("active");
		this._state[ixLearned] = !this._state[ixLearned];
	}

	_handleListItemBtnLearnClick_doFixed ({btnLearn, btnPrepare, isActive, ixPrepared, ixLearned}) {
		if (!isActive && !this._parent.canLearnMoreFixedSpellsOfLevel_(this._spellLevel)) return false;

		this._handleListItemBtnLearnClick_do_doLearn({btnLearn, btnPrepare, isActive, ixPrepared, ixLearned});
		this._parent.pulseFixedLearned = !this._parent.pulseFixedLearned;

		return true;
	}

	handleFilterChange (f) {
		if (!this._list) return;

		this._list.filter(it => {
			const sp = this._spellDatas[it.ix];

			if (!this._parent.isAvailableClassSpell_(sp) && !this._parent.isAvailableSubclassSpell_(sp) && !this._parent.isAvailableExpandedSpell_(sp)) return false;

			const {ixLearned, ixPrepared, ixAlwaysPrepared, ixAlwaysKnownSpell} = this.constructor._getProps(it.ix);

						if ([ixLearned, ixPrepared, ixAlwaysPrepared, ixAlwaysKnownSpell].some(k => this._state[k])) return true;

			return this._parent.pageFilter.toDisplay(f, sp);
		});
	}

	handleSearch (searchTerm) {
		this._list.search(searchTerm);
	}

	handleAlwaysPreparedSpells_ () {
		return this._handleAlwaysStateSpells_(
			{
				propIx: "ixPrepared",
				propParentCnt: "cntPrepared",
				propIxAlways: "ixAlwaysPrepared",
				propBtn: "btnPrepare",
				propExistingSpellMetaAlways: "isAlwaysPrepared",
				fnParentCheckAlways: this._parent.isAlwaysPreparedSpell_.bind(this._parent),
			},
		);
	}

	handleAlwaysKnownSpells_ () {
		return this._handleAlwaysStateSpells_(
			{
				propIx: "ixLearned",
				propParentCnt: this._spellLevel === 0 ? "cntLearnedCantrips" : "cntLearnedSpells",
				propIxAlways: "ixAlwaysKnownSpell",
				propBtn: "btnLearn",
				fnParentCheckAlways: this._parent.isAlwaysKnownSpell_.bind(this._parent),
			},
		);
	}

	_handleAlwaysStateSpells_ (
		{
			propIx,
			propParentCnt,
			propIxAlways,
			propBtn,
			propExistingSpellMetaAlways,
			fnParentCheckAlways,
			fnFilterSpell,
		},
	) {
		if (!this._list) return;

		this._list.items.forEach(it => {
			const sp = this._spellDatas[it.ix];

			if (fnFilterSpell && !fnFilterSpell(sp)) return;

			const existingSpellMeta = this._parent.getExistingSpellMeta_(sp);
			if (existingSpellMeta?.isLearned || existingSpellMeta?.isPrepared) return;

			const allProps = this.constructor._getProps(it.ix);
			const propIxProp = allProps[propIx];
			const propIxAlwaysProp = allProps[propIxAlways];

			const isAlways = (propExistingSpellMetaAlways && existingSpellMeta?.[propExistingSpellMetaAlways])
				|| fnParentCheckAlways(sp);

						if (isAlways) {
								if (this._state[propIxProp]) {
					this._state[propIxProp] = false;
					this._parent[propParentCnt]--;
				}

				if (!this._state[propIxAlwaysProp] && it.data[propBtn]) {
					it.data[propBtn].classList.add("active");
					it.data[propBtn].disabled = true;
				}
			} else {
				if (this._state[propIxAlwaysProp] && it.data[propBtn]) {
					it.data[propBtn].classList.remove("active");
					it.data[propBtn].disabled = false;
				}
			}

			this._state[propIxAlwaysProp] = isAlways;
		});
	}

	static _getProps (ix) {
		return {
			ixLearned: `ix_learned_${ix}`,
			ixPrepared: `ix_prepared_${ix}`,
			ixAlwaysPrepared: `ix_always_prepared_${ix}`,
			ixAlwaysKnownSpell: `ix_always_known_spell_${ix}`,
		};
	}

		_resetLevelSpells () {
		let numDeLearned = 0;
		let numDePrepared = 0;
		const nxtState = {};

		const len = this._spellDatas.length;
		for (let i = 0; i < len; ++i) {
			const sp = this._spellDatas[i];

			if (!this._isAvailableSpell(sp)) continue;

			const existingSpellMeta = this._parent.getExistingSpellMeta_(sp);
			if (existingSpellMeta) continue;

			const {ixLearned, ixPrepared, ixAlwaysPrepared, ixAlwaysKnownSpell} = this.constructor._getProps(i);

			if (this._state[ixLearned]) {
				nxtState[ixLearned] = false;
				numDeLearned++;
			}

			if (this._state[ixPrepared]) {
				nxtState[ixPrepared] = false;
				numDePrepared++;
			}

			if (this._state[ixAlwaysPrepared]) nxtState[ixAlwaysPrepared] = false;

			if (this._state[ixAlwaysKnownSpell]) nxtState[ixAlwaysKnownSpell] = false;
		}

		this._proxyAssignSimple("state", nxtState);

		if (numDeLearned) {
			if (this._spellLevel === 0) {
				this._parent.cntLearnedCantrips -= numDeLearned;
				this._$wrpRows[0].querySelectorAll(`.manc-sp__btn-learn-cantrip`).forEach(it => {
					if (it.dataset?.["plut-is-existing-spell"]) return;
					it.classList.remove("active");
				});
			} else {
				this._parent.cntLearnedSpells -= numDeLearned;
				this._$wrpRows[0].querySelectorAll(`.manc-sp__btn-learn-spell`).forEach(it => {
					if (it.dataset?.["plut-is-existing-spell"]) return;
					it.classList.remove("active");
				});
			}
		}

		if (numDePrepared) {
			this._parent.cntPrepared -= numDePrepared;
			this._$wrpRows[0].querySelectorAll(`.manc-sp__btn-prepare`).forEach(it => {
				if (it.dataset?.["plut-is-existing-spell"]) return;
				it.classList.remove("active");
			});
		}
	}

	getSpellsKnown () { 		if (!this._isWithinLevelRange() || this._spellLevel === 0) return [];

		const out = [];

		const len = this._spellDatas.length;
		for (let i = 0; i < len; ++i) {
			const sp = this._spellDatas[i];

			if (!this._isAvailableSpell(sp)) continue;
			if (!this._parent.isAvailableClassSpell_(sp) && !this._parent.isAvailableSubclassSpell_(sp) && !this._parent.isAvailableExpandedSpell_(sp)) continue;

			const {ixLearned} = this.constructor._getProps(i);

			if (!this._state[ixLearned]) continue;

			out.push({
				ix: i,
				spell: this._spellDatas[i],
			});
		}

		return out;
	}

	getFormSubData (filterValues) {
		if (!this._isWithinLevelRange()) return [];

		const out = [];

		const isLearnedAtLevel = this._parent.isLearnedFixedSpellCasterAtLevel_(this._spellLevel);

		const len = this._spellDatas.length;
		for (let i = 0; i < len; ++i) {
			const sp = this._spellDatas[i];

			if (!this._isAvailableSpell(sp)) continue;
			if (!this._parent.isAvailableClassSpell_(sp) && !this._parent.isAvailableSubclassSpell_(sp) && !this._parent.isAvailableExpandedSpell_(sp)) continue;

			const {ixLearned, ixPrepared, ixAlwaysPrepared, ixAlwaysKnownSpell} = this.constructor._getProps(i);

												if (this._state[ixAlwaysPrepared] || this._state[ixAlwaysKnownSpell]) continue;

			const isLearned = this._state[ixLearned];
			const isPrepared = this._state[ixPrepared] || (this._spellLevel === 0 && isLearned);

			if (this._spellLevel === 0 && !isLearned) continue;

			let isUpdatePrepared = false;
			const existingSpellMeta = this._parent.getExistingSpellMeta_(sp);
			if (existingSpellMeta) {
				if (this._spellLevel === 0) continue;
				if (isLearnedAtLevel) continue;
				isUpdatePrepared = existingSpellMeta.isPrepared !== isPrepared;
				if (!isUpdatePrepared) continue;
			}

									if (!isLearned && isLearnedAtLevel) continue;

						if (this._parent.isPreparedCaster && !isLearned && !isPrepared && !this._parent.pageFilter.toDisplay(filterValues, sp)) continue;

			const spellImportOpts = this._getFormSubData_getSpellImportOpts({isLearned});

			out.push(new Charactermancer_Spell_SpellMeta({
				...spellImportOpts,
				ix: i,
				spell: this._spellDatas[i],
				isPrepared,
				isLearned,
				isUpdateOnly: isUpdatePrepared,
				existingItemId: existingSpellMeta?.item?.id,
			}));
		}

		return out;
	}

	_getFormSubData_getSpellImportOpts ({isLearned}) {
		let preparationMode = "always";
		let usesValue = null;
		let usesMax = null;
		let usesPer = null;

		if (this._spellLevel === 0) {
			preparationMode = "always";
		} else if (this._parent.casterProgression === "pact") {
			if (isLearned) {
								if (this._spellLevel > UtilActors.PACT_CASTER_MAX_SPELL_LEVEL) {
					preparationMode = "atwill";
					usesValue = 1;
					usesMax = 1;
					usesPer = "lr";
				} else preparationMode = "pact";
			}
		} else {
			preparationMode = this._parent.isPreparedCaster ? "prepared" : "always";
		}

		return {preparationMode, usesValue, usesMax, usesPer};
	}
}

class UtilAdvancements {
	static _LevelledEmbeddedDocument = class {
		constructor ({embeddedDocument, level} = {}) {
			if (level == null) throw new Error(`Level must be defined!`);

			this.embeddedDocument = embeddedDocument;
			this.level = level;

			this.advancementId = null;
		}
	};

		static LevelledEmbeddedDocument_MinLevel0 = class extends this._LevelledEmbeddedDocument {
		constructor ({level = 0, ...rest}) {
			super({level, ...rest});
		}
	};

		static LevelledEmbeddedDocument_MinLevel1 = class extends this._LevelledEmbeddedDocument {
		constructor ({level = 1, ...rest}) {
			super({level, ...rest});
		}
	};

	static async pAddAdvancementLinks (
		{
			actor,
			parentEmbeddedDocument,
			childLevelledEmbeddedDocuments,
		},
	) {
		childLevelledEmbeddedDocuments = childLevelledEmbeddedDocuments.filter(it => it.embeddedDocument);

		if (!parentEmbeddedDocument || !childLevelledEmbeddedDocuments.length) return;

				const childrenByLevel = {};
		childLevelledEmbeddedDocuments.forEach(child => {
						(childrenByLevel[child.level] = (childrenByLevel[child.level] || [])).push(child);
		});

				const newAdvancement = Object.keys(childrenByLevel)
			.map(it => Number(it))
			.sort(SortUtil.ascSort)
			.map(level => {
				const _id = foundry.utils.randomID();
				const childrenAtLevel = childrenByLevel[level];
				childrenAtLevel.forEach(child => child.advancementId = _id);
				return {
					_id,
					type: "ItemGrant",
					level,
					title: "Features",
					icon: parentEmbeddedDocument.img,
																				configuration: {
						items: [],
					},
										value: {
						added: childrenAtLevel.mergeMap(it => ({[it.embeddedDocument.id]: ""})),
					},
				};
			});

				const existingAdvancement = MiscUtil.copy(parentEmbeddedDocument.system?.advancement || []);

				const advancementToAdd = newAdvancement.filter(newAdv => {
			const oldAdv = existingAdvancement.find(it => it.level === newAdv.level);
			if (!oldAdv) return true;

			if (newAdv?.value?.added) {
				const tgt = MiscUtil.getOrSet(oldAdv, "value", "added", {});
				Object.assign(tgt, newAdv.value.added);
			}

						childrenByLevel[newAdv.level].forEach(child => child.advancementId = oldAdv._id);

			return false;
		});

		const updatedMetas = await UtilDocuments.pUpdateEmbeddedDocuments(
			actor,
			[
				{
					_id: parentEmbeddedDocument.id,
					system: {
						advancement: [
							...existingAdvancement,
							...advancementToAdd,
						],
					},
				},
			],
			{
				propData: "items",
				ClsEmbed: Item,
			},
		);
		const updatedParentDoc = updatedMetas[0]?.document;
		if (!updatedParentDoc) return;

		await UtilDocuments.pUpdateEmbeddedDocuments(
			actor,
			childLevelledEmbeddedDocuments.map(child => ({
				_id: child.embeddedDocument.id,
				flags: {
					dnd5e: {
						advancementOrigin: `${updatedParentDoc.id}.${child.advancementId}`,
					},
				},
			})),
			{
				propData: "items",
				ClsEmbed: Item,
			},
		);
	}
}

class UtilDice {
		static _VALID_CHARS_ATTRIBUTE = `a-z.0-9_\\-`;

		static getReplacedCustomAttributes_class (str, {cls}) {
		const reHdNumberTicks = new RegExp(`\`@hd\\.number\``, "g");
		const reHdNumber = new RegExp(`(?:^|(?<![${this._VALID_CHARS_ATTRIBUTE}@]))@hd\\.number(?:(?![${this._VALID_CHARS_ATTRIBUTE}])|$)`, "g");

		const reHdFacesTicks = new RegExp(`\`@hd\\.faces\``, "g");
		const reHdFaces = new RegExp(`(?:^|(?<![${this._VALID_CHARS_ATTRIBUTE}@]))@hd\\.faces(?:(?![${this._VALID_CHARS_ATTRIBUTE}])|$)`, "g");

		return str
			.replace(reHdNumberTicks, `${cls.hd.number}`)
			.replace(reHdNumber, `${cls.hd.number}`)

			.replace(reHdFacesTicks, `${cls.hd.faces}`)
			.replace(reHdFaces, `${cls.hd.faces}`)
		;
	}
}

class ImportEntryManagerClass extends ImportEntryManager {
	async _pImportEntry_pDoImport () {
		return this._instance._pImportClass(this._ent, this._importOpts, this._dataOpts);
	}
}

class ImportEntryManagerSubclass extends ImportEntryManager {
	constructor ({cls, ...rest}) {
		super({...rest});
		this._cls = cls;
	}

	async _pImportEntry_pDoImport () {
		return this._instance._pImportSubclass(this._cls, this._ent, this._importOpts, this._dataOpts);
	}
}

class ImportListClass extends ImportListCharacter {
		static init () {
		const dropOpts = {
			isForce: true,
			fnGetSuccessMessage: ({ent}) => `Imported "${ent.className || ent.name}"${ent.subclassShortName ? ` (${ent.name})` : ""} via Class Importer`,
			fnGetFailedMessage: ({ent}) => `Failed to import "${ent.className || ent.name}"${ent.subclassShortName ? ` (${ent.name})` : ""}! ${VeCt.STR_SEE_CONSOLE}`,
		};
		this._initCreateSheetItemHook({
			...dropOpts,
			prop: "class",
			importerName: "Class",
		});
		this._initCreateSheetItemHook({
			...dropOpts,
			prop: "subclass",
			importerName: "Subclass",
		});

				Hooks.on("dropActorSheetData", (actor, actorSheet, data) => {
			if (!Config.get("importClass", "isSuppressAdvancementsOnImportedDrop")) return;
			if (data?.type !== "Item") return;

			const item = data.id
				? game.items.get(data.id)
				: data.uuid && data.type === "Item" && !UtilDragDrop.isCustomUuid(data.uuid) ? game.items.get(data.uuid.split(".")[1])
					: null;
			if (!item) return;

			const propDroppable = item.getFlag(SharedConsts.MODULE_ID, "propDroppable");
			if (!["class", "subclass"].includes(propDroppable)) return;

			const isDisabled = game.settings.get("dnd5e", "disableAdvancements");
			if (isDisabled) return;

			GameStorage.setOverride("dnd5e", "disableAdvancements", true);
			setTimeout(() => {
				GameStorage.unsetOverride("dnd5e", "disableAdvancements");
			}, 200);
		});
		
		ImportListClass.SheetLevelUpButtonAdapter.init();
	}
	
	static get ID () { return "classes-subclasses"; }
	static get DISPLAY_NAME_TYPE_PLURAL () { return "Classes & Subclasses"; }
	static get PROPS () { return ["class", "subclass"]; }

	static _ = this.registerImpl(this);

		static get defaultOptions () {
		return mergeObject(super.defaultOptions, {
			template: `${SharedConsts.MODULE_LOCATION}/template/ImportListClass.hbs`,
		});
	}

	_isSkipContentFlatten = true;
	_dirsHomebrew = ["class", "subclass"];
	_sidebarTab = "items";
	_gameProp = "items";
	_defaultFolderPath = ["Classes"];
	_pageFilter = new PageFilterClassesFoundry();
	_page = UrlUtil.PG_CLASSES;
	_isDedupable = true;
	_namespace = "class_subclass";
	_configGroup = "importClass";
	static _DataConverter = DataConverterClass;

	constructor (...args) {
		super(...args);

		this._cachedData = null;
	}

	async pSetContent (val) {
		await super.pSetContent(val);
		this._cachedData = null;
	}

	static async pPostLoad (data, {actor} = {}) {
		const isIgnoredLookup = await DataConverterClassSubclassFeature.pGetClassSubclassFeatureIgnoredLookup({data});
		const out = await PageFilterClassesFoundry.pPostLoad(data, {actor, isIgnoredLookup});
		Charactermancer_Class_Util.addFauxOptionalFeatureFeatures(
			out.class,
			(await this._pPostLoad_pGetAllOptionalFeatures()).optionalfeature,
		);
		return out;
	}

	async _pGetSources () {
		return [
			new UtilDataSource.DataSourceSpecial(
				Config.get("ui", "isStreamerMode") ? "SRD" : "5etools",
				Vetools.pGetClasses,
				{
					cacheKey: "5etools-classes",
					pPostLoad: (data) => this.constructor.pPostLoad(data, {actor: this._actor}),
					filterTypes: [UtilDataSource.SOURCE_TYP_OFFICIAL_ALL],
					isDefault: true,
				},
			),
			...UtilDataSource.getSourcesCustomUrl({pPostLoad: (data) => this.constructor.pPostLoad(data, {actor: this._actor})}),
			...UtilDataSource.getSourcesUploadFile({pPostLoad: (data) => this.constructor.pPostLoad(data, {actor: this._actor})}),
			...(await this._pGetSourcesPrerelease({pPostLoad: (data) => this.constructor.pPostLoad(data, {actor: this._actor})})),
			...(await this._pGetSourcesBrew({pPostLoad: (data) => this.constructor.pPostLoad(data, {actor: this._actor})})),
		];
	}

	isInvalidatedByConfigChange (configDiff) {
		const isHideSubclassRows = !!Config.get("importClass", "isHideSubclassRows");

		return this._cachedData && !!this._cachedData.isHideSubclassRows !== isHideSubclassRows;
	}

	getData () {
				if (this._cachedData && (this._cachedData.isRadio !== !!this._actor)) this._cachedData = null;

				const isHideSubclassRows = !!Config.get("importClass", "isHideSubclassRows");
		if (this._cachedData && (!!this._cachedData.isHideSubclassRows !== !!isHideSubclassRows)) this._cachedData = null;

		this._cachedData = this._cachedData || {
			titleButtonRun: this._titleButtonRun,
			titleSearch: this._titleSearch,
			rows: this._content.class
				.sort((a, b) => SortUtil.ascSortLower(a.name, b.name) || SortUtil.ascSortLower(Parser.sourceJsonToFull(a.source || Parser.SRC_PHB), Parser.sourceJsonToFull(b.source || Parser.SRC_PHB)))
				.map((cls, ixClass) => {
					this._pageFilter.constructor.mutateForFilters(cls);

					return {
						name: cls.name,
						source: cls.source,
						sourceShort: Parser.sourceJsonToAbv(cls.source),
						sourceLong: Parser.sourceJsonToFull(cls.source),
						sourceClassName: Parser.sourceJsonToColor(cls.source),
						sourceStyle: PrereleaseUtil.sourceJsonToStylePart(cls.source) || BrewUtil2.sourceJsonToStylePart(cls.source),
						ixClass,
						disabled: !cls.classFeatures,
						subRows: isHideSubclassRows
							? []
							: (cls.subclasses || [])
								.map((sc, ixSubclass) => ({
									name: sc.name,
									source: sc.source || cls.source,
									sourceShort: Parser.sourceJsonToAbv(sc.source || cls.source),
									sourceLong: Parser.sourceJsonToFull(sc.source || cls.source),
									sourceClassName: Parser.sourceJsonToColor(sc.source || cls.source),
									sourceStyle: PrereleaseUtil.sourceJsonToStylePart(sc.source || cls.source) || BrewUtil2.sourceJsonToStylePart(sc.source || cls.source),
									ixSubclass,
								})),
					};
				}),
		};

		if (this._actor) this._cachedData.isRadio = true;
		if (isHideSubclassRows) this._cachedData.isHideSubclassRows = true;

		return this._cachedData;
	}

	_getDedupedData ({allContentMerged}) {
		return ImportListClass.Utils.getDedupedData({allContentMerged});
	}

	_getBlocklistFilteredData ({dedupedAllContentMerged}) {
		return ImportListClass.Utils.getBlocklistFilteredData({dedupedAllContentMerged});
	}

	_renderInner_initRunButton () {
		this._$btnRun.click(async () => {
			if (!this._list) return;

			const listItems = this._actor
				? this._list.items
					.filter(it => it.data.tglSel && it.data.tglSel.classList.contains("active"))
				: this._list.items
					.filter(it => it.data.cbSel.checked);

			if (!listItems.length) return ui.notifications.warn(`Please select something to import!`);

			this.close();

			await this._pImportListItems({listItems});

			this._$cbAll.prop("checked", false).change();
		});
	}

	async _pImportListItems ({listItems, isBackground}) {
		const selIds = listItems.map(it => ({ixClass: it.data.ixClass, ixSubclass: it.data.ixSubclass}));

		const mapped = selIds.map(({ixClass, ixSubclass}) => {
						const cls = MiscUtil.copy(this._content.class[ixClass]);
			return {ixClass, cls, ixSubclass, sc: ixSubclass != null ? cls.subclasses[ixSubclass] : null};
		});
				mapped.filter(it => !it.sc).forEach(it => it.cls.subclasses = []);
				mapped.sort((a, b) => !!a.sc - !!b.sc);

		const classes = [];
		const looseSubclasses = [];
		mapped.forEach(it => {
			if (it.sc) {
				const cls = classes.find(cls =>
					cls.name.toLowerCase() === it.sc.className.toLowerCase()
					&& cls.source.toLowerCase() === it.sc.classSource.toLowerCase(),
				);

				if (cls) cls.subclasses.push(it.sc);
				else looseSubclasses.push({cls: it.cls, sc: it.sc});
			} else classes.push(it.cls);
		});

		if (classes.length || looseSubclasses.length) await this._pDoPreCachePack();

		await (
			isBackground
				? this._pImportListItems_background({classes, looseSubclasses})
				: this._pImportListItems_foreground({classes, looseSubclasses})
		);

		this.activateSidebarTab();
		if (!this._actor) game[this._gameProp].render();
	}

	async _pImportListItems_background ({classes, looseSubclasses}) {
		for (const cls of classes) {
			try {
				const importedMeta = await this.pImportClass(cls);
				UtilApplications.doShowImportedNotification(importedMeta);
			} catch (e) {
				UtilApplications.doShowImportedNotification({entity: cls, status: ConstsTaskRunner.TASK_EXIT_FAILED});
				console.error(e);
			}
		}

		for (const {cls, sc} of looseSubclasses) {
			try {
				const importedMeta = await this.pImportSubclass(cls, sc);
				UtilApplications.doShowImportedNotification(importedMeta);
			} catch (e) {
				UtilApplications.doShowImportedNotification({entity: sc, status: ConstsTaskRunner.TASK_EXIT_FAILED});
				console.error(e);
			}
		}
	}

	async _pImportListItems_foreground ({classes, looseSubclasses}) {
		await (
			new AppTaskRunner({
				tasks: [
					...classes
						.map(cls => {
							return new TaskClosure({
								fnGetPromise: async ({taskRunner}) => this.pImportClass(cls, {taskRunner}),
							});
						}),
					...looseSubclasses
						.map(({cls, sc}) => {
							return new TaskClosure({
								fnGetPromise: async ({taskRunner}) => this.pImportSubclass(cls, sc, {taskRunner}),
							});
						}),
				],
				titleInitial: "Importing...",
				titleComplete: "Import Complete",
			})
		).pRun();
	}

	async _renderInner_pInitFilteredList () {
				this._list = new List({
			$iptSearch: this._$iptSearch,
			$wrpList: this._$wrpList,
			fnSort: (a, b, opts) => {
				if (opts.sortDir === "desc" && a.data.ixClass === b.data.ixClass && (a.data.ixSubclass != null || b.data.ixSubclass != null)) {
					return a.data.ixSubclass != null ? -1 : 1;
				}

				return SortUtil.ascSortLower(a.values.sortName, b.values.sortName);
			},
		});
		SortUtil.initBtnSortHandlers(this._$wrpBtnsSort, this._list);
		this._listSelectClickHandler = new ListSelectClickHandler({list: this._list});

		const flatListItems = this._cachedData.rows.map(r => {
			const fromClass = {...r};
			delete fromClass.subRows;

			if (Config.get("importClass", "isHideSubclassRows")) return [fromClass];

			const fromSubclass = r.subRows.map(sr => ({
				...sr,
				ixClass: r.ixClass,
				className: r.name,
				classSource: r.source,
				classSourceLong: r.sourceLong,
				classSourceClassName: r.sourceClassName,
			}));
			return [fromClass, ...fromSubclass];
		}).flat();

		await this._pageFilter.pInitFilterBox({
			$iptSearch: this._$iptSearch,
			$btnReset: this._$btnReset,
			$btnOpen: this._$bntFilter,
			$btnToggleSummaryHidden: this._$btnToggleSummary,
			$wrpMiniPills: this._$wrpMiniPills,
			namespace: this._getFilterNamespace(),
		});

		this._content.class.forEach(it => this._pageFilter.addToFilters(it));

		const optsListAbsorb = {
			fnGetName: it => it.name,
						fnGetValues: it => {
				if (it.ixSubclass != null) {
					return {
						sortName: `${it.className} SOURCE ${it.classSourceLong} SUBCLASS ${it.name} SOURCE ${it.sourceLong}`,
						source: it.source,
						hash: UrlUtil.URL_TO_HASH_BUILDER["subclass"](it),
					};
				}

				return {
					sortName: `${it.name} SOURCE ${it.sourceLong}`,
					source: it.source,
					hash: UrlUtil.URL_TO_HASH_BUILDER[this._page](it),
				};
			},
			fnGetData: (li, it) => {
				const out = this._actor
					? {tglSel: li.ele.firstElementChild.firstElementChild}
					: UtilList2.absorbFnGetData(li);

				if (it.ixSubclass != null) {
					return {
						...out,
						ixClass: it.ixClass,
						ixSubclass: it.ixSubclass,
					};
				}

				return {
					...out,
					ixClass: it.ixClass,
				};
			},
		};

		if (this._actor) { 			optsListAbsorb.fnBindListeners = listItem => {
				listItem.ele.addEventListener("click", () => {
					const isScItem = listItem.data.ixSubclass != null;
					const clsListItem = isScItem ? this._list.items.find(it => it.data.ixClass === listItem.data.ixClass && it.data.ixSubclass == null) : null;

										const actives = this._list.items.filter(it => it.data.tglSel.classList.contains("active"));
					if (!actives.length) {
						listItem.data.tglSel.classList.add("active");
						listItem.ele.classList.add("list-multi-selected");

						if (isScItem) {
							clsListItem.data.tglSel.classList.add("active");
							clsListItem.ele.classList.add("list-multi-selected");
						}

						return;
					}
					
										if (listItem.data.tglSel.classList.contains("active")) {
						listItem.data.tglSel.classList.remove("active");
						listItem.ele.classList.remove("list-multi-selected");

						if (isScItem) { 							clsListItem.data.tglSel.classList.remove("active");
							clsListItem.ele.classList.remove("list-multi-selected");
						} else { 							actives.forEach(li => {
								li.data.tglSel.classList.remove("active");
								li.ele.classList.remove("list-multi-selected");
							});
						}

						return;
					}
					
										actives.forEach(li => {
						li.data.tglSel.classList.remove("active");
						li.ele.classList.remove("list-multi-selected");
					});

					listItem.data.tglSel.classList.add("active");
					listItem.ele.classList.add("list-multi-selected");

					if (isScItem) {
						clsListItem.data.tglSel.classList.add("active");
						clsListItem.ele.classList.add("list-multi-selected");
					}
									});
			};
		} else {
			optsListAbsorb.fnBindListeners = it => UtilList2.absorbFnBindListeners(this._listSelectClickHandler, it);
		}

		this._list.doAbsorbItems(flatListItems, optsListAbsorb);
		this._list.init();

		this._pageFilter.trimState();
		this._pageFilter.filterBox.render();

		this._pageFilter.filterBox.on(
			FilterBox.EVNT_VALCHANGE,
			this._handleFilterChange.bind(this),
		);

		this._handleFilterChange();
	}

	_renderInner_getListSyntax () {
		return null;
	}

	_renderInner_initFeelingLuckyButton () {
		if (!this._actor) return super._renderInner_initFeelingLuckyButton();

		this._$btnFeelingLucky.click(() => {
			if (!this._list || !this._list.visibleItems.length) return;

			const listItem = RollerUtil.rollOnArray(this._list.visibleItems);
			if (!listItem) return;

			listItem.ele.click();
			listItem.ele.scrollIntoView({block: "center"});
		});
	}

	_handleFilterChange () {
		return ModalFilterClasses.handleFilterChange({
			pageFilter: this._pageFilter,
			list: this._list,
			allData: this._content.class,
		});
	}

	async _pEnsureFilterBoxInit () {
		if (this._pageFilter.filterBox) return;
		await this._pageFilter.pInitFilterBox({
			namespace: this._getFilterNamespace(),
		});
	}

		async _pImportEntry (cls, importOpts, dataOpts) {
		importOpts = importOpts || {};

		await this._pEnsureFilterBoxInit();

						let clsRaw = null;
		let scRaw = null;
		if (cls?.subclassFeatures?.every(it => it == null || it instanceof Array)) {
			scRaw = await DataLoader.pCacheAndGet("raw_subclass", cls.source, UrlUtil.URL_TO_HASH_BUILDER["subclass"](cls), {isCopy: true});
			clsRaw = await DataLoader.pCacheAndGet("raw_class", scRaw.classSource, UrlUtil.URL_TO_HASH_BUILDER["class"]({name: scRaw.className, source: scRaw.classSource}), {isCopy: true});
		}

				if (cls?.classFeatures?.every(it => it == null || it instanceof Array)) {
			clsRaw = await DataLoader.pCacheAndGet("raw_class", cls.source, UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES](cls), {isCopy: true});
		}

				if (clsRaw || scRaw) {
			const toLoad = {class: [clsRaw]};

			if (scRaw) {
				toLoad.subclass = [scRaw];
			}

			const data = await this.constructor.pPostLoad(toLoad);
			cls = data.class[0];

			if (scRaw) {
				const sc = cls.subclasses[0];
				cls.subclasses = [];
				return this._pImportSubclass(cls, sc, importOpts, dataOpts);
			}
		}
		
		return this._pImportClass(cls, importOpts, dataOpts);
	}

	async pImportClass (cls, importOpts, dataOpts) {
		return new ImportEntryManagerClass({
			instance: this,
			ent: cls,
			importOpts,
			dataOpts,
		}).pImportEntry();
	}

		async _pImportClass (cls, importOpts, dataOpts) {
		importOpts = importOpts || {};

		console.log(...LGT, `Importing class "${cls.name}" (from "${Parser.sourceJsonToAbv(cls.source)}")`);

		if (DataConverterClass.isStubClass(cls)) return ImportSummary.completedStub();

		if (importOpts.isTemp) return this._pImportClass_pImportToItems(cls, importOpts, dataOpts);
		if (this._actor) return this._pImportClass_pImportToActor(cls, importOpts, dataOpts);
		return this._pImportClass_pImportToItems(cls, importOpts, dataOpts);
	}

		async _pImportClass_pImportToActor (cls, importOpts, dataOpts) {
		const dataBuilderOpts = new ImportListClass.ImportEntryOpts({
			isClassImport: true,
			isCharactermancer: importOpts.isCharactermancer,
		});

				let allFeatures;

		if (!cls._foundryAllFeatures) {
			allFeatures = Charactermancer_Class_Util.getAllFeatures(cls);

			this.constructor._tagFirstSubclassLoaded(cls, allFeatures);

						allFeatures = Charactermancer_Util.getFilteredFeatures(allFeatures, this._pageFilter, importOpts.filterValues || this._pageFilter.filterBox.getValues());
		} else {
			this.constructor._tagFirstSubclassLoaded(cls);
		}
		
		const sc = cls.subclasses?.length ? cls.subclasses[0] : null;

		return this._pImportClassSubclass_pImportToActor({cls, sc, importOpts, dataBuilderOpts, allFeatures});
	}

		static _tagFirstSubclassLoaded (cls, allFeatures = null) {
		let subclassLoadeds;
		if (allFeatures) {
			const group = allFeatures.find(it => it.subclassFeature);
			if (!group?.loadeds.length) return;
			subclassLoadeds = group.loadeds;
		} else {
			subclassLoadeds = cls._foundryAllFeatures.filter(it => it.type === "subclassFeature");
		}

		if (!subclassLoadeds.length) return;

		const expectedFirstSubclassFeatureLevel = cls.classFeatures.find(it => it.gainSubclassFeature)?.level;

						if (subclassLoadeds[0]?.entity?.level !== expectedFirstSubclassFeatureLevel) return;

				if (
			BrewUtil2.hasSourceJson(subclassLoadeds[0]?.entity?.source)
			&& [
				"skillProficiencies",
				"languageProficiencies",
				"toolProficiencies",
				"armorProficiencies",
				"weaponProficiencies",
				"savingThrowProficiencies",
				"immune",
				"resist",
				"vulnerable",
				"conditionImmune",
				"expertise",
			].some(prop => subclassLoadeds[0].entity[prop])
		) {
			return;
		}

		subclassLoadeds[0]._foundryIsIgnoreFeature = true;
	}

	async _pImportClassSubclass_pImportToActor ({cls, sc, importOpts, dataBuilderOpts, allFeatures}) {
		const selectedLevelIndices = await this._pGetSelectedLevelIndices(cls, importOpts, allFeatures, dataBuilderOpts, sc != null);
		if (dataBuilderOpts.isCancelled) return ImportSummary.cancelled();

		await this._pValidateUserLevelIndices(selectedLevelIndices, dataBuilderOpts);
		if (dataBuilderOpts.isCancelled) return ImportSummary.cancelled();

		dataBuilderOpts.targetLevel = Math.max(...selectedLevelIndices) + 1;
		dataBuilderOpts.numLevels = dataBuilderOpts.targetLevel - Math.min(...selectedLevelIndices);
		dataBuilderOpts.numLevelsPrev = UtilActors.getTotalClassLevels(this._actor);
		dataBuilderOpts.isIncludesLevelOne = cls != null 			&& selectedLevelIndices.includes(0);
		const {proficiencyImportMode, shouldBeMulticlass} = await this._pImportClass_pGetProficiencyImportMode(cls, dataBuilderOpts);
		dataBuilderOpts.proficiencyImportMode = proficiencyImportMode;
		dataBuilderOpts.shouldBeMulticlass = shouldBeMulticlass;
		if (dataBuilderOpts.isCancelled) return ImportSummary.cancelled();
		const hpIncreaseMeta = await this._pImportClass_pGetHpImportMode(cls, dataBuilderOpts);
		if (dataBuilderOpts.isCancelled) return ImportSummary.cancelled();
		dataBuilderOpts.hpIncreaseMode = hpIncreaseMeta.mode;
		dataBuilderOpts.hpIncreaseCustomRollFormula = hpIncreaseMeta.customFormula;

		const actUpdate = {
			system: {},
		};

				const hpIncreasePerLevel = await this._pImportEntry_pDoUpdateCharacterHp({actUpdate, cls, dataBuilderOpts});

		const curLevelMetaAndExistingClassItem = await this._pImportEntry_pGetCurLevelFillClassData({
			actUpdate,
			cls,
			sc,
			importOpts,
			dataBuilderOpts,
			hpIncreasePerLevel,
		});
		if (dataBuilderOpts.isCancelled) return ImportSummary.cancelled();
		const {curLevel, existingClassItem, existingSubclassItem} = curLevelMetaAndExistingClassItem;

		this._pImportEntry_setActorFlags(actUpdate, cls, sc, curLevel, dataBuilderOpts);

		await this._pImportEntry_pDoUpdateCharacter(actUpdate, cls, sc, curLevel, existingClassItem, existingSubclassItem, dataBuilderOpts);
		if (dataBuilderOpts.isCancelled) return ImportSummary.cancelled();

		await this._pImportCasterCantrips(cls, sc, curLevel, importOpts, dataBuilderOpts);

		await this._pImportEntry_pFillItemArrayAdditionalSpells(cls, cls.subclasses, curLevel, importOpts, dataBuilderOpts);
		if (dataBuilderOpts.isCancelled) return ImportSummary.cancelled();

		if (
			(cls.preparedSpells && !cls.spellsKnownProgressionFixed)
			|| (cls.preparedSpellsProgression && !cls.spellsKnownProgressionFixed)
		) await this._pImportPreparedCasterSpells(cls, sc, curLevel, importOpts, dataBuilderOpts);

		await this._pImportEntry_pAddUpdateClassItem(cls, sc, dataBuilderOpts);

		await this._pImportEntry_pHandleFeatures(cls, sc, allFeatures, selectedLevelIndices, importOpts, dataBuilderOpts);
		if (dataBuilderOpts.isCancelled) return ImportSummary.cancelled();

		await this._pImportEntry_pAddUnarmedStrike({importOpts});

		await this._pImportEntry_pAddAdvancements(dataBuilderOpts);

		await this._pImportEntry_pFinalise(importOpts, dataBuilderOpts);

		if (this._actor.isToken) this._actor.sheet.render();

		return new ImportSummary({
			status: ConstsTaskRunner.TASK_EXIT_COMPLETE,
			imported: [
				new ImportedDocument({
					name: `${cls.name}${sc ? ` (${sc.name})` : ""}`,
					actor: this._actor,
				}),
			],
		});
	}

	async _pGetSelectedLevelIndices (cls, importOpts, allFeatures, dataBuilderOpts, isSubclass) {
		if (cls._foundrySelectedLevelIndices) return cls._foundrySelectedLevelIndices;

				if (importOpts.levels) return importOpts.levels.map(it => it - 1).filter(it => it >= 0);

		const indicesFormData = await Charactermancer_Class_LevelSelect.pGetUserInput({
			features: allFeatures,
			isSubclass,
			maxPreviousLevel: this._pImportEntry_getApproxPreviousMaxLevel(cls),
		});
		if (indicesFormData == null) return dataBuilderOpts.isCancelled = true;

		return indicesFormData.data;
	}

		_pImportEntry_getApproxPreviousMaxLevel (cls) {
		const existingClassItems = this._getExistingClassItems(cls);
		if (!existingClassItems.length) return 0;
		return Math.max(...existingClassItems.map(it => it.system.levels || 0));
	}

	_pImportEntry_setActorFlags (actUpdate, cls, sc, curLevel, dataBuilderOpts) {
		const flags = {dnd5e: {}};

		
		if (Object.keys(flags.dnd5e).length) actUpdate.flags = flags;
	}

	async _pImportClass_pGetProficiencyImportMode (cls, dataBuilderOpts) {
		const existingClassItems = this._actor.items.filter(it => it.type === "class");

		if (!dataBuilderOpts.isClassImport || !dataBuilderOpts.isIncludesLevelOne || !existingClassItems.length) {
			return {
				proficiencyImportMode: Charactermancer_Class_ProficiencyImportModeSelect.MODE_PRIMARY,
				shouldBeMulticlass: false,
			};
		}

				if (cls._foundryStartingProficiencyMode != null) {
			return {
				proficiencyImportMode: cls._foundryStartingProficiencyMode,
								shouldBeMulticlass: cls._foundryStartingProficiencyMode === Charactermancer_Class_ProficiencyImportModeSelect.MODE_MULTICLASS,
			};
		}

				const identifierCls = UtilItem.getNameAsIdentifier(cls.name);
		const shouldBeMulticlass = existingClassItems.every(clsItem => clsItem.system.identifier !== identifierCls);

		const out = await Charactermancer_Class_ProficiencyImportModeSelect.pGetUserInput();
		if (out == null) dataBuilderOpts.isCancelled = true;

		return {
			proficiencyImportMode: out?.data,
			shouldBeMulticlass: shouldBeMulticlass && out != null,
		};
	}

	async _pImportClass_pGetHpImportMode (cls, dataBuilderOpts) {
		if (!Charactermancer_Class_HpIncreaseModeSelect.isHpAvailable(cls)) return {mode: ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__DO_NOT_INCREASE};

				if (cls._foundryHpIncreaseMode != null || cls._foundryHpIncreaseCustomFormula != null) return {mode: cls._foundryHpIncreaseMode, customFormula: cls._foundryHpIncreaseCustomFormula};

		const out = await Charactermancer_Class_HpIncreaseModeSelect.pGetUserInput();
		if (out == null) return dataBuilderOpts.isCancelled = true;
		if (out === VeCt.SYM_UI_SKIP) return {mode: ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__DO_NOT_INCREASE};
		return out.data;
	}

	async _pImportClass_pImportToItems (cls, importOpts, dataOpts) {
		const duplicateMeta = this._getDuplicateMeta({entity: cls, importOpts});
		if (duplicateMeta.isSkip) {
			return new ImportSummary({
				status: ConstsTaskRunner.TASK_EXIT_SKIPPED_DUPLICATE,
				imported: [
					new ImportedDocument({
						isExisting: true,
						document: duplicateMeta.existing,
					}),
				],
			});
		}

		const clsData = await DataConverterClass.pGetClassItem(
			cls,
			{
				filterValues: importOpts.filterValues || this._pageFilter.filterBox.getValues(),
				...dataOpts,
				isAddDefaultOwnershipFromConfig: importOpts.isAddDefaultOwnershipFromConfig ?? true,
				defaultOwnership: importOpts.defaultOwnership,
				userOwnership: importOpts.userOwnership,
				pageFilter: this._pageFilter,
				taskRunner: importOpts.taskRunner,
			},
		);

		const Clazz = this._getDocumentClass();

		if (importOpts.isTemp) {
			const clsItem = await UtilDocuments.pCreateDocument(Item, clsData, {isTemporary: true});
			const scItems = await (cls.subclasses || []).pSerialAwaitMap(sc => this.pImportSubclass(cls, sc, importOpts, dataOpts));

			return new ImportSummary({
				status: ConstsTaskRunner.TASK_EXIT_COMPLETE,
				imported: [
					clsItem,
					...scItems,
				].map(it => new ImportedDocument({document: it, actor: this._actor})),
			});
		} else if (this._pack) {
			if (duplicateMeta.isOverwrite) {
				const clsItem = await this._pImportEntry_pDoUpdateExistingPackEntity(duplicateMeta, clsData);
				const scItems = await (cls.subclasses || []).pSerialAwaitMap(sc => this.pImportSubclass(cls, sc, importOpts, dataOpts));

				return new ImportSummary({
					status: ConstsTaskRunner.TASK_EXIT_COMPLETE_UPDATE_OVERWRITE_DUPLICATE,
					imported: [
						clsItem,
						...scItems,
					].map(it => new ImportedDocument({isExisting: true, document: it, actor: this._actor})),
				});
			}

			const clsItem = new Clazz(clsData);
			await this._pack.importDocument(clsItem);
			const scItems = await (cls.subclasses || []).pSerialAwaitMap(sc => this.pImportSubclass(cls, sc, importOpts, dataOpts));

			await this._pImportEntry_pAddToTargetTableIfRequired([clsItem], duplicateMeta);

			return new ImportSummary({
				status: ConstsTaskRunner.TASK_EXIT_COMPLETE,
				imported: [
					clsItem,
					...scItems,
				].map(it => new ImportedDocument({document: it, actor: this._actor})),
			});
		}

		return this._pImportClass_pImportToItems_toDirectory({
			duplicateMeta,
			cls,
			clsData,
			importOpts,
		});
	}

	async _pImportClass_pImportToItems_toDirectory (
		{
			duplicateMeta,
			cls,
			clsData,
			importOpts,
		},
	) {
		if (duplicateMeta?.isOverwrite) {
			const clsItem = await this._pImportEntry_pDoUpdateExistingDirectoryEntity(duplicateMeta, clsData);
			const scItems = await (cls.subclasses || []).pSerialAwaitMap(sc => this.pImportSubclass(cls, sc, importOpts));

			return new ImportSummary({
				status: ConstsTaskRunner.TASK_EXIT_COMPLETE_UPDATE_OVERWRITE_DUPLICATE,
				imported: [
					clsItem,
					...scItems,
				].map(it => new ImportedDocument({isExisting: true, document: it, actor: this._actor})),
			});
		}

		const folderIdMeta = await this._pImportEntry_pImportToDirectoryGeneric_pGetFolderIdMeta({
			toImport: cls,
			importOpts,
		});
		if (folderIdMeta?.folderId) clsData.folder = folderIdMeta.folderId;

		const clsItem = await Item.create(clsData, {renderSheet: false, temporary: false});

		await game.items.set(clsItem.id, clsItem);

		const scItems = await (cls.subclasses || [])
			.pSerialAwaitMap(sc => this.pImportSubclass(
				cls,
				sc,
				{
					...importOpts,
					folderId: folderIdMeta?.folderId || importOpts.folderId,
				},
			));

		return new ImportSummary({
			status: ConstsTaskRunner.TASK_EXIT_COMPLETE,
			imported: [
				clsItem,
				...scItems,
			].map(it => new ImportedDocument({document: it, actor: this._actor})),
		});
	}

	async pImportSubclass (cls, sc, importOpts, dataOpts) {
		return new ImportEntryManagerSubclass({
			instance: this,
			ent: sc,
			cls,
			importOpts,
			dataOpts,
		}).pImportEntry();
	}

		async _pImportSubclass (cls, sc, importOpts, dataOpts) {
		importOpts = importOpts || {};

		console.log(...LGT, `Importing subclass "${sc.name}" (from "${Parser.sourceJsonToAbv(sc.source)}")`);

		if (DataConverterClass.isStubClass(cls)) return ImportSummary.completedStub();
		if (DataConverterClass.isStubSubclass(sc)) return ImportSummary.completedStub();

		if (importOpts.isTemp) return this._pImportSubclass_pImportToItems(cls, sc, importOpts, dataOpts);
		if (this._actor) return this._pImportSubclass_pImportToActor(cls, sc, importOpts, dataOpts);
		return this._pImportSubclass_pImportToItems(cls, sc, importOpts, dataOpts);
	}

	async _pImportSubclass_pImportToActor (cls, sc, importOpts, dataOpts) {
		const dataBuilderOpts = new ImportListClass.ImportEntryOpts({
			isClassImport: false,
			isCharactermancer: importOpts.isCharactermancer,
		});

				const existingClassItems = this._actor.items.filter(it => it.type === "class");
		if (!existingClassItems.length) {
			const isImportSubclassOnly = await InputUiUtil.pGetUserBoolean({
				title: "Import Class?",
				htmlDescription: "You have selected a subclass to import, but have no class levels. Would you like to import the class too?",
				textYes: "Import Class and Subclass",
				textNo: "Import Only Subclass",
			});

			if (isImportSubclassOnly == null) {
				dataBuilderOpts.isCancelled = true;
				return ImportSummary.cancelled();
			}

						if (isImportSubclassOnly === true) {
				const cpyCls = MiscUtil.copy(cls);
				cpyCls.subclasses = [sc];
				return this.pImportClass(cpyCls, importOpts);
			}
		}
		
				let allFeatures = MiscUtil.copy(sc.subclassFeatures);

		this.constructor._tagFirstSubclassLoaded(cls, allFeatures);

		allFeatures = Charactermancer_Util.getFilteredFeatures(allFeatures, this._pageFilter, importOpts.filterValues || this._pageFilter.filterBox.getValues());
		
		return this._pImportClassSubclass_pImportToActor({cls, sc, importOpts, dataBuilderOpts, allFeatures});
	}

		async _pImportSubclass_pImportToItems (cls, sc, importOpts, dataOpts = {}) {
		const scData = await DataConverterClass.pGetSubclassItem(
			cls,
			sc,
			{
				filterValues: importOpts.filterValues || this._pageFilter.filterBox.getValues(),
				...dataOpts,
				isAddDefaultOwnershipFromConfig: importOpts.isAddDefaultOwnershipFromConfig ?? true,
				defaultOwnership: importOpts.defaultOwnership,
				userOwnership: importOpts.userOwnership,
				pageFilter: this._pageFilter,
				taskRunner: importOpts.taskRunner,
			},
		);

		const duplicateMeta = this._getDuplicateMeta({name: scData.name, source: scData.system.source, importOpts});
		if (duplicateMeta.isSkip) {
			return new ImportSummary({
				status: ConstsTaskRunner.TASK_EXIT_SKIPPED_DUPLICATE,
				imported: [
					new ImportedDocument({
						isExisting: true,
						document: duplicateMeta.existing,
					}),
				],
			});
		}

		const Clazz = this._getDocumentClass();

		if (importOpts.isTemp) {
			const imported = await UtilDocuments.pCreateDocument(Item, scData, {isTemporary: true});

			return new ImportSummary({
				status: ConstsTaskRunner.TASK_EXIT_COMPLETE,
				imported: [
					new ImportedDocument({
						document: imported,
					}),
				],
			});
		} else if (this._pack) {
			if (duplicateMeta.isOverwrite) return this._pImportEntry_pDoUpdateExistingPackEntity(duplicateMeta, scData);

			const scItem = new Clazz(scData);
			await this._pack.importDocument(scItem);

			await this._pImportEntry_pAddToTargetTableIfRequired([scItem], duplicateMeta);

			return new ImportSummary({
				status: ConstsTaskRunner.TASK_EXIT_COMPLETE,
				imported: [
					new ImportedDocument({
						document: scItem,
					}),
				],
			});
		}

		return this._pImportEntry_pImportToDirectoryGeneric_toDirectory({
			duplicateMeta,
			docData: scData,
			toImport: sc,
			Clazz,
			importOpts,
		});
	}

	async _pImportEntry_pDoUpdateCharacter (actUpdate, cls, sc, curLevel, existingClassItem, existingSubclassItem, dataBuilderOpts) {
						const otherExistingClassItems = this._actor.items
			.filter(it => it.type === "class")
			.filter(it => it !== existingClassItem);

				const otherExistingSubclassItems = this._actor.items
			.filter(it => it.type === "subclass")
			.filter(it => it !== existingSubclassItem);

		await this._pImportEntry_pDoUpdateCharacter_xp({actUpdate, dataBuilderOpts, otherExistingClassItems});
		await this._pImportEntry_pDoUpdateCharacter_profBonus({actUpdate, dataBuilderOpts});
		await this._pImportEntry_pDoUpdateCharacter_spellcasting({actUpdate, cls, sc, dataBuilderOpts, otherExistingClassItems, otherExistingSubclassItems});
		await this._pImportEntry_pDoUpdateCharacter_psionics({actUpdate, cls, sc, dataBuilderOpts, otherExistingClassItems, otherExistingSubclassItems});
		await this._pImportEntry_pDoUpdateCharacter_languages({actUpdate, cls, dataBuilderOpts});
		if (dataBuilderOpts.isCancelled) return;

		if (Object.keys(actUpdate.system).length) await UtilDocuments.pUpdateDocument(this._actor, actUpdate);
	}

	async _pImportEntry_pDoUpdateCharacter_xp ({actUpdate, dataBuilderOpts, otherExistingClassItems}) {
		if (Config.get("importClass", "isSetXp")) return;

		const totalLevel = otherExistingClassItems
			.map(it => it.system.levels || 0)
			.reduce((a, b) => a + b, 0)
			+ (dataBuilderOpts.targetLevel || 0);

		if (totalLevel <= 0) return;

		const xpObj = ((actUpdate.system.details = actUpdate.system.details || {}).xp = actUpdate.system.details.xp || {});
		const curXp = MiscUtil.get(this._actor, "system", "details", "xp", "value") || 0;
		const tgtXp = Parser.LEVEL_XP_REQUIRED[totalLevel - 1];
		const nxtXp = Parser.LEVEL_XP_REQUIRED[Math.min(totalLevel, 19)];
		if (curXp < tgtXp) {
			xpObj.pct = 0;
			xpObj.value = tgtXp;
		} else {
			xpObj.pct = (curXp / nxtXp) * 100;
		}
		xpObj.max = nxtXp;
	}

	async _pImportEntry_pDoUpdateCharacter_profBonus ({actUpdate, dataBuilderOpts}) {
				const curProfBonus = MiscUtil.get(this._actor, "system", "attributes", "prof");
		const targetProf = Math.floor((dataBuilderOpts.targetLevel - 1) / 4) + 2;
		if (curProfBonus < targetProf) (actUpdate.system.attributes = actUpdate.system.attributes || {}).prof = targetProf;
	}

	async _pImportEntry_pDoUpdateCharacter_spellcasting ({actUpdate, cls, sc, dataBuilderOpts, otherExistingClassItems, otherExistingSubclassItems}) {
		const progressionMeta = Charactermancer_Class_Util.getCasterProgression(cls, sc, {targetLevel: dataBuilderOpts.targetLevel, otherExistingClassItems, otherExistingSubclassItems});

		const isAnySlotMod = this._pImportEntry_pDoUpdateCharacter_spellcasting_slots({actUpdate, dataBuilderOpts, progressionMeta});
		if (!isAnySlotMod) {
			delete actUpdate.data?.spells;
			delete dataBuilderOpts.postItemActorUpdate?.data?.spells;
		}

		const {spellAbility, totalSpellcastingLevels} = progressionMeta;
		if (spellAbility) (actUpdate.system.attributes = actUpdate.system.attributes || {}).spellcasting = spellAbility;

				await this._pImportEntry_pDoUpdateCharacter_spellcasting_spellPoints({actUpdate, totalSpellcastingLevels});
	}

	_pImportEntry_pDoUpdateCharacter_spellcasting_slots ({actUpdate, dataBuilderOpts, progressionMeta}) {
		const {casterProgression, totalSpellcastingLevels, maxPactCasterLevel} = progressionMeta;

		if (!totalSpellcastingLevels && casterProgression !== "pact") return;

		let isAnyMod = false;
		actUpdate.system.spells = actUpdate.system.spells || {};
						const postDataSpells = MiscUtil.getOrSet(dataBuilderOpts.postItemActorUpdate, "system", "spells", {});

		if (totalSpellcastingLevels) {
						const spellSlots = UtilDataConverter.CASTER_TYPE_TO_PROGRESSION.full;
			let maxLevelSpells = spellSlots[totalSpellcastingLevels - 1] || spellSlots.last();

			maxLevelSpells.forEach((slots, i) => {
				if (slots === 0) return;
				const lvlProp = `spell${i + 1}`;

				const existingMax = MiscUtil.get(this._actor, "system", "spells", lvlProp, "max");
				const existingValue = MiscUtil.get(this._actor, "system", "spells", lvlProp, "value");
				if (existingMax != null) {
					if (existingMax < slots) {
						isAnyMod = true;

						const delta = slots - existingMax;

						actUpdate.system.spells[lvlProp] = {max: slots, value: existingValue + delta};
						postDataSpells[lvlProp] = {max: slots, value: existingValue + delta};
					}
				} else {
					isAnyMod = true;
					actUpdate.system.spells[lvlProp] = {max: slots, value: slots};
					postDataSpells[lvlProp] = {max: slots, value: slots};
				}
			});

			return isAnyMod;
		}

		if (casterProgression === "pact") {
			const existingMax = MiscUtil.get(this._actor, "system", "spells", "pact", "max");
			const existingValue = MiscUtil.get(this._actor, "system", "spells", "pact", "value");

			const slots = UtilDataConverter.CASTER_TYPE_TO_PROGRESSION.pact[maxPactCasterLevel - 1].find(Boolean);

			if (existingMax != null) {
				if (existingMax < slots) {
					isAnyMod = true;

					const delta = slots - existingMax;

					actUpdate.system.spells.pact = {max: slots, value: existingValue + delta};
					postDataSpells.pact = {max: slots, value: existingValue + delta};
				}
			} else {
				isAnyMod = true;
				actUpdate.system.spells.pact = {max: slots, value: slots};
				postDataSpells.pact = {max: slots, value: slots};
			}

			return isAnyMod;
		}

		return false;
	}

	async _pImportEntry_pDoUpdateCharacter_spellcasting_spellPoints ({actUpdate, totalSpellcastingLevels}) {
		if (
			!totalSpellcastingLevels
			|| Config.get("importSpell", Config.getSpellPointsKey({actorType: this._actor?.type})) === ConfigConsts.C_SPELL_POINTS_MODE__DISABLED
		) return;
		return Config.get("importSpell", "spellPointsResource") === ConfigConsts.C_SPELL_POINTS_RESOURCE__SHEET_ITEM
			? UtilActors.pGetCreateActorSpellPointsItem({actor: this._actor, totalSpellcastingLevels})
			: this._pImportEntry_pDoUpdateCharacter_spellcasting_spellPsiPoints_resource({
				actUpdate,
				amount: UtilDataConverter.getSpellPointTotal({totalSpellcastingLevels}),
				label: "Spell Points",
				resource: Config.getSpellPointsResource(),
			});
	}

	async _pImportEntry_pDoUpdateCharacter_spellcasting_spellPsiPoints_resource ({actUpdate, amount, label, resource}) {
		const propPathResource = (resource || "").trim().split(".");

		if (!propPathResource.length) {
			const msg = `Could not update ${label} total\u2014resource "${resource}" was not valid!`;
			console.warn(...LGT, msg);
			ui.notifications.warn(msg);
			return;
		}

		const propPathValue = [...propPathResource, "value"];
		const propPathMax = [...propPathResource, "max"];

		const actorData = (this._actor.system._source || this._actor.system);
		const curVal = MiscUtil.get(actorData, "system", ...propPathValue) || 0;
		const curMax = MiscUtil.get(actorData, "system", ...propPathMax) || 0;

		if (amount > curMax) {
			const deltaCur = (amount - curMax);
			MiscUtil.set(actUpdate, "system", ...propPathValue, curVal + deltaCur);
			MiscUtil.set(actUpdate, "system", ...propPathMax, amount);

			const propPathLabel = [...propPathResource, "label"];
			if (!MiscUtil.get(actorData, "system", ...propPathLabel)) {
				MiscUtil.set(actUpdate, "system", ...propPathLabel, label);
			}
		}
	}

	async _pImportEntry_pDoUpdateCharacter_psionics ({actUpdate, cls, sc, dataBuilderOpts, otherExistingClassItems, otherExistingSubclassItems}) {
		const {totalMysticLevels} = Charactermancer_Class_Util.getMysticProgression({cls, targetLevel: dataBuilderOpts.targetLevel, otherExistingClassItems, otherExistingSubclassItems});

				await this._pImportEntry_pDoUpdateCharacter_psionics_psiPoints({actUpdate, totalMysticLevels});
	}

	async _pImportEntry_pDoUpdateCharacter_psionics_psiPoints ({actUpdate, totalMysticLevels}) {
		if (!totalMysticLevels) return;
		return Config.get("importPsionic", "psiPointsResource") === ConfigConsts.C_SPELL_POINTS_RESOURCE__SHEET_ITEM
			? UtilActors.pGetCreateActorPsiPointsItem({actor: this._actor, totalMysticLevels})
			: this._pImportEntry_pDoUpdateCharacter_spellcasting_spellPsiPoints_resource({
				actUpdate,
				amount: UtilDataConverter.getPsiPointTotal({totalMysticLevels}),
				label: "Psi Points",
				resource: Config.getPsiPointsResource(),
			});
	}

	async _pImportEntry_pDoUpdateCharacterHp ({actUpdate, cls, dataBuilderOpts}) {
		if (!dataBuilderOpts.isClassImport || !Charactermancer_Class_HpIncreaseModeSelect.isHpAvailable(cls)) return;

		const conMod = Parser.getAbilityModNumber(Charactermancer_Util.getCurrentAbilityScores(this._actor).con); 
								const isFirstHpGain = dataBuilderOpts.isIncludesLevelOne && dataBuilderOpts.proficiencyImportMode !== Charactermancer_Class_ProficiencyImportModeSelect.MODE_MULTICLASS;

		let hpIncrease = isFirstHpGain ? (cls.hd.number * cls.hd.faces) + conMod : 0;

		const numLevels = isFirstHpGain ? dataBuilderOpts.numLevels - 1 : dataBuilderOpts.numLevels;

		let hpIncreasePerLevel = null;
		if (isFirstHpGain) {
			hpIncreasePerLevel = {
				"1": "max",
			};
		}

		switch (dataBuilderOpts.hpIncreaseMode) {
			case ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__TAKE_AVERAGE: {
				const avg = Math.ceil(cls.hd.number * ((cls.hd.faces + 1) / 2));
				hpIncrease += numLevels * Math.max((avg + conMod), 1);

				hpIncreasePerLevel = hpIncreasePerLevel || {};
				for (
					let lvl = dataBuilderOpts.currentLevelThisClass + (isFirstHpGain ? 2 : 1);
					lvl <= dataBuilderOpts.targetLevelThisClass;
					++lvl
				) {
					hpIncreasePerLevel[`${lvl}`] = "avg";
				}

				break;
			}

			case ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__MIN:
			case ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__MAX: {
				const val = dataBuilderOpts.hpIncreaseMode === ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__MIN
					? cls.hd.number
					: (cls.hd.number * cls.hd.faces);
				hpIncrease += numLevels * Math.max((val + conMod), 1);

				hpIncreasePerLevel = hpIncreasePerLevel || {};
				for (
					let lvl = dataBuilderOpts.currentLevelThisClass + (isFirstHpGain ? 2 : 1);
					lvl <= dataBuilderOpts.targetLevelThisClass;
					++lvl
				) {
					hpIncreasePerLevel[`${lvl}`] = val;
				}

				break;
			}

			case ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL:
			case ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL_CUSTOM: {
				const formulaRaw = dataBuilderOpts.hpIncreaseMode === ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__ROLL
					? `${cls.hd.number}d${cls.hd.faces} + ${conMod}`
					: `${(dataBuilderOpts.hpIncreaseCustomRollFormula || "0")} + ${conMod}`;

								const formula = UtilDice.getReplacedCustomAttributes_class(formulaRaw, {cls});

				const rollData = this._actor.getRollData();

								try {
					const rollTest = new Roll(formula, rollData);
					await rollTest.evaluate({async: true});
				} catch (e) {
					hpIncrease = 0;
					hpIncreasePerLevel = null;
					ui.notifications.error(`Failed to evaluate HP increase formula "${formula}" ("${formulaRaw}")! ${VeCt.STR_SEE_CONSOLE}`);
					setTimeout(() => { throw e; });
					break;
				}

				hpIncreasePerLevel = hpIncreasePerLevel || {};
				try {
					for (
						let lvl = dataBuilderOpts.currentLevelThisClass + (isFirstHpGain ? 2 : 1);
						lvl <= dataBuilderOpts.targetLevelThisClass;
						++lvl
					) {
						const roll = new Roll(formula, rollData);
						await roll.evaluate({async: true});
						const hpIncreaseLvl = Math.max(roll.total, 1);
						hpIncrease += hpIncreaseLvl;
												await roll.toMessage({
							flavor: `HP Increase (Level ${lvl})`,
							sound: null,
							speaker: {
								actor: this._actor.id,
								alias: this._actor.name,
								scene: null,
								token: null,
							},
						});

												hpIncreasePerLevel[`${lvl}`] = hpIncreaseLvl - conMod;
					}
				} catch (e) {
					hpIncrease = 0;
					hpIncreasePerLevel = null;
					ui.notifications.error(`Failed to evaluate HP increase formula "${formula}" ("${formulaRaw}")! ${VeCt.STR_SEE_CONSOLE}`);
					setTimeout(() => { throw e; });
				}

				break;
			}

			case ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__DO_NOT_INCREASE: {
				hpIncrease = 0;
				hpIncreasePerLevel = null;
				break;
			}

			default: throw new Error(`Unhandled Hit Points increase mode "${dataBuilderOpts.hpIncreaseMode}"`);
		}

		if (hpIncrease) {
			const {value: curValue, max: curMax} = Charactermancer_Util.getBaseHp(this._actor);

			switch (dataBuilderOpts.proficiencyImportMode) {
				case Charactermancer_Class_ProficiencyImportModeSelect.MODE_MULTICLASS: {
					const hpCurNxt = curValue + hpIncrease;
					const hpMaxNxt = curMax == null ? null : curMax + hpIncrease;

					const isSetMaxHp = UtilActors.isSetMaxHp({actor: this._actor})
						|| (
														dataBuilderOpts.hpIncreaseMode !== ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__TAKE_AVERAGE
							|| !dataBuilderOpts.shouldBeMulticlass
						);

					MiscUtil.set(actUpdate, "system", "attributes", "hp", "value", hpCurNxt);
					if (isSetMaxHp) MiscUtil.set(actUpdate, "system", "attributes", "hp", "max", hpMaxNxt);

					break;
				}

				case Charactermancer_Class_ProficiencyImportModeSelect.MODE_PRIMARY: {
					const hpCurNxt = (isFirstHpGain ? 0 : curValue) + hpIncrease;
					const hpMaxNxt = curMax == null ? null : (isFirstHpGain ? 0 : curMax) + hpIncrease;

					const isSetMaxHp = UtilActors.isSetMaxHp({actor: this._actor})
						|| (
														dataBuilderOpts.hpIncreaseMode !== ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__TAKE_AVERAGE
							|| dataBuilderOpts.shouldBeMulticlass
						);

					MiscUtil.set(actUpdate, "system", "attributes", "hp", "value", hpCurNxt);
					if (isSetMaxHp) MiscUtil.set(actUpdate, "system", "attributes", "hp", "max", hpMaxNxt);

					break;
				}

				case Charactermancer_Class_ProficiencyImportModeSelect.MODE_NONE: break;

				default: throw new Error(`Unknown proficiency import mode "${dataBuilderOpts.proficiencyImportMode}"`);
			}
		}

		return hpIncreasePerLevel;
	}

	async _pImportEntry_pDoUpdateCharacter_languages ({actUpdate, cls, dataBuilderOpts}) {
		await DataConverter.pFillActorLanguageData(
			MiscUtil.get(this._actor, "_source", "system", "traits", "languages"),
			cls.languageProficiencies,
			actUpdate.system,
			dataBuilderOpts,
		);
	}

	async _pImportEntry_pDoUpdateCharacter_pPopulateLevelOneProficienciesAndEquipment (actUpdate, cls, sc, dataBuilderOpts) {
		const out = {
			chosenProficiencies: {},
		};

				out.chosenProficiencies = await this._pImportEntry_pDoUpdateCharacter_pPopulateProficienciesFrom(actUpdate, cls.startingProficiencies, cls.proficiency, Charactermancer_Class_ProficiencyImportModeSelect.MODE_PRIMARY, dataBuilderOpts);
		if (dataBuilderOpts.isCancelled) return;
		
				await this._pImportEntry_pDoUpdateCharacter_pPopulateEquipment(cls, dataBuilderOpts);
		if (dataBuilderOpts.isCancelled) return;
		
		return out;
	}

	async _pImportEntry_pDoUpdateCharacter_pPopulateProficienciesFrom (actUpdate, profs, savingThrowProfs, mode, dataBuilderOpts) {
		const out = {
			skills: {},
		};

				if (profs?.skills) {
			const skills = await DataConverter.pFillActorSkillData(
				MiscUtil.get(this._actor, "_source", "system", "skills"),
				profs.skills,
				actUpdate.system,
				dataBuilderOpts,
			);

			if (dataBuilderOpts.isCancelled) return out;

			out.skills = skills; 		}
		
				const toolProficiencies = Charactermancer_Class_Util.getToolProficiencyData(profs);
		if (toolProficiencies?.length) {
			await DataConverter.pFillActorToolData(
				MiscUtil.get(this._actor, "_source", "system", "tools"),
				toolProficiencies,
				actUpdate.system,
				dataBuilderOpts,
			);
			if (dataBuilderOpts.isCancelled) return out;
		}
		
				const formDataOtherProfs = await Charactermancer_Class_StartingProficiencies.pGetUserInput({
			mode,
			primaryProficiencies: mode === Charactermancer_Class_ProficiencyImportModeSelect.MODE_PRIMARY ? profs : null,
			multiclassProficiencies: mode === Charactermancer_Class_ProficiencyImportModeSelect.MODE_MULTICLASS ? profs : null,
			savingThrowsProficiencies: savingThrowProfs,
			existingProficienciesFvttArmor: MiscUtil.get(this._actor, "_source", "system", "traits", "armorProf"),
			existingProficienciesFvttWeapons: MiscUtil.get(this._actor, "_source", "system", "traits", "weaponProf"),
			existingProficienciesFvttSavingThrows: Charactermancer_Class_StartingProficiencies.getExistingProficienciesFvttSavingThrows(this._actor),
		});
		if (formDataOtherProfs == null) return dataBuilderOpts.isCancelled = true;
		if (formDataOtherProfs === VeCt.SYM_UI_SKIP) return;

		Charactermancer_Class_StartingProficiencies.applyFormDataToActorUpdate(actUpdate, formDataOtherProfs);
		
		return out;
	}

	async _pImportEntry_pDoUpdateCharacter_pPopulateMulticlassProficiencies (actUpdate, cls, sc, dataBuilderOpts) {
		const out = {
			chosenProficiencies: {},
		};

		if (cls.multiclassing && cls.multiclassing.proficienciesGained) {
			out.chosenProficiencies = await this._pImportEntry_pDoUpdateCharacter_pPopulateProficienciesFrom(actUpdate, cls.multiclassing.proficienciesGained, null, Charactermancer_Class_ProficiencyImportModeSelect.MODE_MULTICLASS, dataBuilderOpts);
			if (dataBuilderOpts.isCancelled) return;
		}

		return out;
	}

	_getExistingClassItems (cls) { return Charactermancer_Class_Util.getExistingClassItems(this._actor, cls); }
	_getExistingSubclassItems (cls, sc) { return Charactermancer_Class_Util.getExistingSubclassItems(this._actor, cls, sc); }

	static _CurLevelMeta = class {
		constructor ({curLevel = 0, existingCLassItem = null, existingSubclassItem = null} = {}) {
			this.curLevel = curLevel;
			this.existingClassItem = existingCLassItem;
			this.existingSubclassItem = existingSubclassItem;
		}
	};

	async _pImportEntry_pGetCurLevelFillClassData (
		{actUpdate, cls, sc, importOpts, dataBuilderOpts, hpIncreasePerLevel},
	) {
		const outCurLevelMeta = new this.constructor._CurLevelMeta();

		const proficiencyMeta = await this._pGetProficiencyMeta({actUpdate, cls, sc, dataBuilderOpts});
		if (dataBuilderOpts.isCancelled) return;

		const {existingClassItem, existingSubclassItem} = await this._pImportEntry_pGetUserExistingClassSubclassItem({cls, sc, dataBuilderOpts});
		if (dataBuilderOpts.isCancelled) return;

		dataBuilderOpts.classItem = existingClassItem;
		dataBuilderOpts.subclassItem = existingSubclassItem;
		outCurLevelMeta.existingClassItem = existingClassItem;
		outCurLevelMeta.existingSubclassItem = existingSubclassItem;

		await this._pImportEntry_pFillClassData({cls, sc, proficiencyMeta, outCurLevelMeta, importOpts, dataBuilderOpts, hpIncreasePerLevel});
		await this._pImportEntry_pFillSubclassData({cls, sc, proficiencyMeta, outCurLevelMeta, importOpts, dataBuilderOpts});

		return outCurLevelMeta;
	}

	async _pGetProficiencyMeta ({actUpdate, cls, sc, dataBuilderOpts}) {
		if (!dataBuilderOpts.isClassImport || !dataBuilderOpts.isIncludesLevelOne) return {};

		switch (dataBuilderOpts.proficiencyImportMode) {
			case Charactermancer_Class_ProficiencyImportModeSelect.MODE_MULTICLASS: {
				return this._pImportEntry_pDoUpdateCharacter_pPopulateMulticlassProficiencies(actUpdate, cls, sc, dataBuilderOpts);
			}
			case Charactermancer_Class_ProficiencyImportModeSelect.MODE_PRIMARY: {
				return this._pImportEntry_pDoUpdateCharacter_pPopulateLevelOneProficienciesAndEquipment(actUpdate, cls, sc, dataBuilderOpts);
			}
			case Charactermancer_Class_ProficiencyImportModeSelect.MODE_NONE: {
				return {};
			}
			default: throw new Error(`Unknown proficiency import mode "${dataBuilderOpts.proficiencyImportMode}"`);
		}
	}

		async _pImportEntry_pGetUserExistingClassSubclassItem ({cls, sc, dataBuilderOpts}) {
		const existingClassItems = this._getExistingClassItems(cls);
		const existingSubclassItems = this._getExistingSubclassItems(cls, sc);

		if (!existingClassItems.length && !existingSubclassItems.length) return {};

		const isChooseClass = cls && existingClassItems.length > 1;
		const isChooseSubclass = sc && existingSubclassItems.length > 1;

		if (isChooseClass && isChooseSubclass) {
			const [isDataEntered, classSubclassItemSelection] = await this._pGetUserClassSubclassItems({cls, sc, existingClassItems, existingSubclassItems});
			if (!isDataEntered) {
				dataBuilderOpts.isCancelled = true;
				return {};
			}
			return classSubclassItemSelection;
		}

		if (isChooseClass) {
			return {
				existingClassItem: await this._pGetUserClassSubclassItem({dataBuilderOpts, clsOrSc: cls, existingItems: existingClassItems, nameUnnamed: "(Unnamed Class)"}),
				existingSubclassItem: existingSubclassItems[0],
			};
		}

		if (isChooseSubclass) {
			return {
				existingClassItem: existingClassItems[0],
				existingSubclassItem: await this._pGetUserClassSubclassItem({dataBuilderOpts, clsOrSc: sc, existingItems: existingSubclassItems, nameUnnamed: "(Unnamed Subclass)"}),
			};
		}

		return {
			existingClassItem: existingClassItems[0],
			existingSubclassItem: existingSubclassItems[0],
		};
	}

	async _pImportEntry_pFillClassData ({cls, sc, proficiencyMeta, outCurLevelMeta, importOpts, dataBuilderOpts, hpIncreasePerLevel}) {
		const {existingClassItem} = outCurLevelMeta;

		const classItemData = await DataConverterClass.pGetClassItem(
			cls,
			{
				sc,
				filterValues: importOpts.filterValues || this._pageFilter.filterBox.getValues(),
				startingSkills: proficiencyMeta.chosenProficiencies && proficiencyMeta.chosenProficiencies.skills
					? Object.keys(proficiencyMeta.chosenProficiencies.skills)
					: [],
				proficiencyImportMode: dataBuilderOpts.proficiencyImportMode,
				level: dataBuilderOpts.targetLevel,
				isClsDereferenced: true,
				actor: this._actor,
				spellSlotLevelSelection: importOpts.spellSlotLevelSelection,
				hpAdvancementValue: this._pImportEntry_pFillClassData_getHpAdvancementValue({dataBuilderOpts, hpIncreasePerLevel}),
				taskRunner: importOpts.taskRunner,
			},
		);

		if (existingClassItem) {
			let isUpdate = false;
			const update = {_id: existingClassItem.id};

			const description = classItemData.system.description.value;
			if (description && !(existingClassItem.system.description?.value || "").trim()) {
				isUpdate = true;
				MiscUtil.set(update, "system", "description", "value", description);
			}

			let curLevel = existingClassItem.system.levels;
			if (curLevel) {
				if (dataBuilderOpts.targetLevel > curLevel) {
					isUpdate = true;
					MiscUtil.set(update, "system", "levels", dataBuilderOpts.targetLevel);
				}
			}

						this._pImportEntry_pFillClassData_mutAdvancements({existingClassItem, update, classItemData});

						update.flags = {
				...existingClassItem.flags,
				[SharedConsts.MODULE_ID]: {
					...existingClassItem.flags?.[SharedConsts.MODULE_ID],
					...classItemData.flags?.[SharedConsts.MODULE_ID],
				},
			};

			dataBuilderOpts.classItemUpdate = update;
			dataBuilderOpts.isPersistClassItemUpdate = dataBuilderOpts.isPersistClassItemUpdate || isUpdate;

			outCurLevelMeta.curLevel = curLevel || 0;
			outCurLevelMeta.existingClassItem = existingClassItem;
			return;
		}

				dataBuilderOpts.classItemToCreate = classItemData;
	}

	_pImportEntry_pFillClassData_getHpAdvancementValue ({dataBuilderOpts, hpIncreasePerLevel}) {
		if (dataBuilderOpts.hpIncreaseMode === ConfigConsts.C_IMPORT_CLASS_HP_INCREASE_MODE__DO_NOT_INCREASE) return null;

		return hpIncreasePerLevel;
	}

	_pImportEntry_pFillClassData_mutAdvancements ({existingClassItem, update, classItemData}) {
		if (!classItemData.system.advancement?.length) return;
		if (!existingClassItem._source.system.advancement?.length) return;

		const advsHp = classItemData.system.advancement.filter(it => it.type === "HitPoints");
		if (!advsHp.length) return;
		if (advsHp.length > 1) return console.warn(...LGT, `Multiple "HitPoints"-type advancements found in class item data! This should never occur!`);
		const advHp = advsHp[0];

		const advsHpExisting = existingClassItem._source.system.advancement.filter(it => it.type === "HitPoints");
		if (!advsHpExisting.length) return;
		if (advsHpExisting.length > 1) return console.warn(...LGT, `Multiple "HitPoints"-type advancements found in existing class item data! This should never occur!`);
		const advHpExisting = advsHpExisting[0];

		const out = existingClassItem._source.system.advancement
			.filter(it => it.type !== "HitPoints");

		const cpyAdvHpExisting = MiscUtil.copy(advHpExisting);
		Object.entries(advHp.value || {})
			.forEach(([k, v]) => {
				cpyAdvHpExisting.value[k] = v;
			});
		out.push(cpyAdvHpExisting);

		MiscUtil.set(update, "system", "advancement", out);
	}

	async _pImportEntry_pFillSubclassData ({cls, sc, proficiencyMeta, outCurLevelMeta, importOpts, dataBuilderOpts}) {
		if (!sc) return;

		const {existingSubclassItem} = outCurLevelMeta;

		const subclassItemData = await DataConverterClass.pGetSubclassItem(
			cls,
			sc,
			{
				filterValues: importOpts.filterValues || this._pageFilter.filterBox.getValues(),
				proficiencyImportMode: dataBuilderOpts.proficiencyImportMode,
				isScDereferenced: true,
				actor: this._actor,
				taskRunner: importOpts.taskRunner,
			},
		);

		if (existingSubclassItem) {
			let isUpdate = false;
			const update = {_id: existingSubclassItem.id};

			const description = subclassItemData.system.description.value;
			if (description && !(existingSubclassItem.system.description?.value || "").trim()) {
				isUpdate = true;
				MiscUtil.set(update, "system", "description", "value", description);
			}

			dataBuilderOpts.subclassItemUpdate = update;
			dataBuilderOpts.isPersistSubclassItemUpdate = dataBuilderOpts.isPersistSubclassItemUpdate || isUpdate;

			return;
		}

		dataBuilderOpts.subclassItemToCreate = subclassItemData;
	}

	async _pGetUserClassSubclassItem ({dataBuilderOpts, clsOrSc, existingItems, nameUnnamed}) {
		const titlePart = clsOrSc.name || nameUnnamed;

		const ix = await InputUiUtil.pGetUserEnum({
			values: existingItems,
			placeholder: "Select Existing Item...",
			title: `Select Existing Item to Import ${titlePart} Levels To`,
			fnDisplay: fvIt => {
				if (fvIt == null) return `(Create New Item)`;
				return fvIt.name || nameUnnamed;
			},
			isAllowNull: true,
		});

		if (ix == null) {
			dataBuilderOpts.isCancelled = true;
			return null;
		}

		return existingItems[ix];
	}

	async _pGetUserClassSubclassItems ({cls, sc, existingClassItems, existingSubclassItems}) {
		const titlePart = `${cls.name || "(Unnamed class)"} (${sc.name || "(Unnamed subclass)"})`;

		const {$modalInner, doClose, pGetResolved, doAutoResize: doAutoResizeModal} = await UtilApplications.pGetShowApplicationModal({
			title: `Select Existing Items to Import ${titlePart} Levels To`,
		});
		const comp = BaseComponent.fromObject({ixItemClass: null, ixItemSubclass: null}, "*");

		const $btnOk = $(`<button class="btn btn-primary mr-2">OK</button>`)
			.click(async () => {
				const out = {
					existingClassItem: existingClassItems[comp._state.ixItemSubclass],
					existingSubclassItem: existingSubclassItems[comp._state.ixItemSubclass],
				};

				return doClose(true, out);
			});
		const $btnCancel = $(`<button class="btn btn-default">Cancel</button>`)
			.click(() => doClose(false));

		const $selClass = ComponentUiUtil.$getSelEnum(
			comp,
			"ixItemClass",
			{
				values: existingClassItems,
				fnDisplay: fvIt => fvIt == null ? `(Create New Item)` : (fvIt.name || "(Unnamed class)"),
				displayNullAs: "(Create New Item)",
				isAllowNull: true,
				isSetIndexes: true,
			},
		);

		const $selSubclass = ComponentUiUtil.$getSelEnum(
			comp,
			"ixItemSubclass",
			{
				values: existingSubclassItems,
				fnDisplay: fvIt => fvIt == null ? `(Create New Item)` : (fvIt.name || "(Unnamed subclass)"),
				displayNullAs: "(Create New Item)",
				isAllowNull: true,
				isSetIndexes: true,
			},
		);

		$$($modalInner)`<div class="ve-flex-col">
			<label class="split-v-center mb-2"><div class="no-shrink mr-2 w-100p text-right">Class item</div>${$selClass}</label>
			<label class="split-v-center"><div class="no-shrink mr-2 w-100p text-right">Subclass item</div>${$selSubclass}</label>
		</div>`;
		$$`<div class="ve-flex-v-center ve-flex-h-right no-shrink pb-1 pt-1 px-1">${$btnOk}${$btnCancel}</div>`.appendTo($modalInner);
		$selClass.focus();

		doAutoResizeModal();

		return pGetResolved();
	}

	async _pImportCasterCantrips (cls, sc, curLevel, importOpts, dataBuilderOpts) {
		if (cls._foundryIsSkipImportCantrips) return;

		const cantripProgressionMeta = Charactermancer_Spell_Util.getCasterCantripProgressionMeta({cls, sc, curLevel, targetLevel: dataBuilderOpts.targetLevel});
		if (!cantripProgressionMeta) return;

		const {maxCantripsHigh, deltaMaxCantrips} = cantripProgressionMeta;
		if (!deltaMaxCantrips || !maxCantripsHigh) return;

		const formData = await Charactermancer_Spell_Modal.pGetUserInput({
			actor: this._actor,
			existingClass: dataBuilderOpts.classItemUpdate ? cls : null,
			existingCasterMeta: Charactermancer_Spell_Util.getExistingCasterMeta({cls, sc, actor: this._actor, targetLevel: dataBuilderOpts.targetLevel}),
			spellDatas: (await Vetools.pGetAllSpells({isIncludeLoadedBrew: true, isIncludeLoadedPrerelease: true, isApplyBlocklist: true})).spell,
			className: cls.name,
			classSource: cls.source,
			brewClassSpells: cls.classSpells,
			subclassName: sc?.name,
			subclassSource: sc?.source,
			brewSubclassSpells: sc?.subclassSpells,
			brewSubSubclassSpells: sc?.subSubclassSpells,

			maxLevel: 0,
			maxLearnedCantrips: maxCantripsHigh,
		});
		if (!formData) return importOpts.isCancelled = true;
		if (formData === VeCt.SYM_UI_SKIP) return;

		await Charactermancer_Spell.pApplyFormDataToActor(this._actor, formData, {cls, sc, taskRunner: importOpts.taskRunner});
	}

	async _pImportPreparedCasterSpells (cls, sc, curLevel, importOpts, dataBuilderOpts) {
		if (cls._foundryIsSkipImportPreparedSpells) return;

		const casterProgressionMeta = Charactermancer_Spell_Util.getCasterProgressionMeta({
			casterProgression: DataConverter.getMaxCasterProgression(cls.casterProgression, sc?.casterProgression),
			curLevel,
			targetLevel: dataBuilderOpts.targetLevel,
			isBreakpointsOnly: true,
		});
		if (!casterProgressionMeta) return;

		const {spellLevelLow, spellLevelHigh, deltaLevels} = casterProgressionMeta;

		const doImport = await InputUiUtil.pGetUserBoolean({
			title: `Populate Spellbook`,
			htmlDescription: `<p>Do you want to populate the spellbook for this class (for class level${deltaLevels === 1 ? "" : "s"} ${deltaLevels === 1 ? dataBuilderOpts.targetLevel : `${curLevel + 1}-${dataBuilderOpts.targetLevel}`})?</p>`,
			textYes: "Yes",
			textNo: "No",
		});

		if (!doImport) return;

		const isPrereleaseSource = sc ? PrereleaseUtil.hasSourceJson(sc.source) : PrereleaseUtil.hasSourceJson(cls.source);
		const isBrewSource = sc ? BrewUtil2.hasSourceJson(sc.source) : BrewUtil2.hasSourceJson(cls.source);
		const isUaSource = !isBrewSource && (isPrereleaseSource || (sc ? SourceUtil.isNonstandardSource(sc.source) : SourceUtil.isNonstandardSource(cls.source)));

		const allSpells = (await Vetools.pGetAllSpells({
			isFilterNonStandard: !isUaSource,
			additionalSourcesBrew: isPrereleaseSource
				? this._getPrereleaseSpellSources(cls, sc)
				: isBrewSource
					? this._getBrewSpellSources(cls, sc)
					: null,
			isApplyBlocklist: true,
		})).spell;

		const spellsToImport = await Charactermancer_Class_Util.pGetPreparableSpells(allSpells, cls, spellLevelLow, spellLevelHigh);
		if (!spellsToImport.length) return;

		const {ImportListSpell} = await Promise.resolve().then(function () { return ImportListSpell$1; });
		const importListSpell = new ImportListSpell({actor: this._actor});
		await importListSpell.pInit();

		for (const spell of spellsToImport) {
			const existingSpell = DataConverterSpell.getActorSpell(this._actor, spell.name, spell.source);
			if (existingSpell) continue;

			await importListSpell.pImportEntry(
				spell,
				{
					taskRunner: importOpts.taskRunner,
					opts_pGetSpellItem: {
						...(await UtilActors.pGetActorSpellItemOpts()),
						ability: dataBuilderOpts.spellcastingAbility,
					},
				},
			);
		}
	}

	_getPrereleaseSpellSources (cls, sc) { return this._getPrereleaseBrewSpellSources({cls, sc}); }
	_getBrewSpellSources (cls, sc) { return this._getPrereleaseBrewSpellSources({cls, sc}); }

	_getPrereleaseBrewSpellSources ({cls, sc}) {
		const out = new Set();

		if (!Parser.SOURCE_JSON_TO_ABV[cls.source]) out.add(cls.source);
		if (sc && !Parser.SOURCE_JSON_TO_ABV[sc.source]) out.add(sc.source);

		if (cls.classSpells) {
			cls.classSpells
				.filter(it => it.source && !Parser.SOURCE_JSON_TO_ABV[it.source])
				.forEach(({source}) => out.add(source));
		}
		if (sc && sc.subclassSpells) {
			sc.subclassSpells
				.filter(it => it.source && !Parser.SOURCE_JSON_TO_ABV[it.source])
				.forEach(({source}) => out.add(source));
		}

		return [...out];
	}

	async _pImportEntry_pFillItemArrayAdditionalSpells (cls, subclasses, curLevel, importOpts, dataBuilderOpts) {
				const casterProgressionMeta = Charactermancer_Spell_Util.getCasterProgressionMeta({casterProgression: cls.casterProgression, curLevel, targetLevel: dataBuilderOpts.targetLevel});

		const formData = await Charactermancer_AdditionalSpellsSelect.pGetUserInput({
			additionalSpells: cls.additionalSpells,
			sourceHintText: cls.name,
			modalFilterSpells: await Charactermancer_AdditionalSpellsSelect.pGetInitModalFilterSpells(),
			curLevel: curLevel,
			targetLevel: dataBuilderOpts.targetLevel,
			spellLevelLow: casterProgressionMeta ? casterProgressionMeta.spellLevelLow : null,
			spellLevelHigh: casterProgressionMeta ? casterProgressionMeta.spellLevelHigh : null,
			isStandalone: true,
		});

		if (formData == null) return dataBuilderOpts.isCancelled = true;
		if (formData !== VeCt.SYM_UI_SKIP) {
			await Charactermancer_AdditionalSpellsSelect.pApplyFormDataToActor(
				this._actor,
				formData,
				{
					taskRunner: importOpts.taskRunner,
					abilityAbv: cls.spellcastingAbility,
				},
			);
		}
		
				for (const sc of subclasses) {
			const casterProgressionMeta = Charactermancer_Spell_Util.getCasterProgressionMeta({casterProgression: sc?.casterProgression || cls.casterProgression, curLevel, targetLevel: dataBuilderOpts.targetLevel});

			const formData = await Charactermancer_AdditionalSpellsSelect.pGetUserInput({
				additionalSpells: sc.additionalSpells,
				sourceHintText: sc.name,
				modalFilterSpells: await Charactermancer_AdditionalSpellsSelect.pGetInitModalFilterSpells(),
				curLevel: curLevel,
				targetLevel: dataBuilderOpts.targetLevel,
				spellLevelLow: casterProgressionMeta ? casterProgressionMeta.spellLevelLow : null,
				spellLevelHigh: casterProgressionMeta ? casterProgressionMeta.spellLevelHigh : null,
				isStandalone: true,
			});

			if (formData == null) return dataBuilderOpts.isCancelled = true;
			if (formData === VeCt.SYM_UI_SKIP) continue;

			await Charactermancer_AdditionalSpellsSelect.pApplyFormDataToActor(
				this._actor,
				formData,
				{
					taskRunner: importOpts.taskRunner,
					abilityAbv: sc.spellcastingAbility,
				},
			);
		}
			}

	async _pImportEntry_pHandleFeatures (cls, sc, allFeatures, selectedLevelIndices, importOpts, dataBuilderOpts) {
		if (cls._foundryAllFeatures) {
			await this._pImportEntry_pFillItemArrayPredefinedFeatures({
				allPreloadedFeatures: cls._foundryAllFeatures,
				cls,
				sc,
				importOpts,
				dataBuilderOpts,
			});
			this._pImportEntry_handleConDifference({
				conInitial: cls._foundryConInitial,
				conFinal: cls._foundryConFinal,
				isConPreApplied: true,
				dataBuilderOpts,
			});
			return;
		}

		const allChosenFeatures = allFeatures.filter(f => selectedLevelIndices.includes(f.level - 1));
		const fillMeta = await this._pImportEntry_pFillItemArrayFeatures(allChosenFeatures, importOpts, dataBuilderOpts);
		if (dataBuilderOpts.isCancelled) return;
		this._pImportEntry_handleConDifference({
			conInitial: fillMeta.conInitial,
			conFinal: fillMeta.conFinal,
			dataBuilderOpts,
		});
	}

	async _pImportEntry_pFillItemArrayPredefinedFeatures (
		{
			allPreloadedFeatures,
			cls,
			sc,
			importOpts,
			dataBuilderOpts,
		},
	) {
		const {ImportListClassFeature} = await Promise.resolve().then(function () { return ImportListClassFeature$1; });
		const {ImportListOptionalFeature} = await Promise.resolve().then(function () { return ImportListOptionalFeature$1; });

		const importListClassFeature = new ImportListClassFeature({actor: this._actor});
		await importListClassFeature.pInit();

		const importListOptionalFeature = new ImportListOptionalFeature({actor: this._actor});
		await importListOptionalFeature.pInit();

		for (const loaded of allPreloadedFeatures) {
			if (loaded._foundryIsIgnoreFeature) continue;

			switch (loaded.type) {
				case "optionalfeature": {
					const importSummary = await importListOptionalFeature.pImportEntry(
						loaded.entity,
						{
							taskRunner: importOpts.taskRunner,
							isCharactermancer: true,
							isLeaf: true,
						},
					);

					const importMetasWrapped = this.constructor._getLevelledEmbeddedDocuments({importSummary, level: loaded.entity.level});
					const tgt = loaded.entity?.ancestorSubclassName
						? dataBuilderOpts.importedSubclassFeatureLevelledEmbeddedDocuments
						: dataBuilderOpts.importedClassFeatureLevelledEmbeddedDocuments;
					tgt.push(...importMetasWrapped);

					break;
				}
				case "classFeature": {
					const importSummary = await importListClassFeature.pImportEntry(
						loaded.entity,
						{
							taskRunner: importOpts.taskRunner,
							isCharactermancer: true,
							isLeaf: true,
							spellcastingAbilityAbv: cls.spellcastingAbility,
						},
					);
					dataBuilderOpts.importedClassFeatureLevelledEmbeddedDocuments.push(
						...this.constructor._getLevelledEmbeddedDocuments({importSummary, level: loaded.entity.level}),
					);
					break;
				}
				case "subclassFeature": {
					const importSummary = await importListClassFeature.pImportEntry(
						loaded.entity,
						{
							taskRunner: importOpts.taskRunner,
							isCharactermancer: true,
							isLeaf: true,
							spellcastingAbilityAbv: sc?.spellcastingAbility,
						},
					);
					dataBuilderOpts.importedSubclassFeatureLevelledEmbeddedDocuments.push(
						...this.constructor._getLevelledEmbeddedDocuments({importSummary, level: loaded.entity.level}),
					);
					break;
				}
				default: throw new Error(`Unhandled feature type "${loaded.type}"`);
			}
		}
	}

	async _pImportEntry_pFillItemArrayFeatures (allFeatures, importOpts, dataBuilderOpts) {
		const conInitial = Charactermancer_Util.getCurrentAbilityScores(this._actor).con;

		const existingFeatureChecker = new Charactermancer_Class_Util.ExistingFeatureChecker(this._actor);

		const {ImportListClassFeature} = await Promise.resolve().then(function () { return ImportListClassFeature$1; });
		const importListClassFeature = new ImportListClassFeature({actor: this._actor});
		await importListClassFeature.pInit();

		for (const feature of allFeatures) {
			const lowName = (feature.name || "").toLowerCase().trim();
			if (lowName === "ability score improvement") {
				const abilityScoreIncrease = new ImportListClass.AbilityScoreIncrease(this._actor, feature.level, dataBuilderOpts);
				abilityScoreIncrease.render(true);

				const feat = await abilityScoreIncrease.pWaitForUserInput(); 				if (feat) {
					const importListFeat = new ImportListFeat({actor: this._actor});
					await importListFeat.pImportEntry(
						feat,
						{
							taskRunner: importOpts.taskRunner,
							isCharactermancer: importOpts.isCharactermancer,
						},
					);
				}
				continue;
			}

			if (feature.loadeds?.length) {
				feature.loadeds = feature.loadeds.filter(it => !it?._foundryIsIgnoreFeature);
				if (!feature.loadeds.length) continue;
			}

			const importSummary = await importListClassFeature.pImportEntry(
				feature,
				{
					taskRunner: importOpts.taskRunner,
					isCharactermancer: importOpts.isCharactermancer,
					isPreLoadedFeature: true,
					featureEntriesPageFilter: this._pageFilter,
					featureEntriesPageFilterValues: importOpts.filterValues || this._pageFilter.filterBox.getValues(),
					existingFeatureChecker,
					spellcastingAbilityAbv: dataBuilderOpts.spellcastingAbility,
				},
			);
			const importMetasWrapped = this.constructor._getLevelledEmbeddedDocuments({importSummary, level: feature.level});

			if (feature.classFeature) {
				dataBuilderOpts.importedClassFeatureLevelledEmbeddedDocuments.push(...importMetasWrapped);
			} else if (feature.subclassFeature) {
				dataBuilderOpts.importedSubclassFeatureLevelledEmbeddedDocuments.push(...importMetasWrapped);
			} else {
				console.warn(...LGT, `Class/subclass feature had neither "classFeature" nor "subclassFeature" set! This should never occur!`);
			}
		}

		if (dataBuilderOpts.isCancelled) return;

		const conFinal = Charactermancer_Util.getCurrentAbilityScores(this._actor).con;
		return {conInitial, conFinal};
	}

	static _getLevelledEmbeddedDocuments ({importSummary, level}) {
		return importSummary.imported
			.filter(importMeta => importMeta.embeddedDocument)
			.map(importMeta => new UtilAdvancements.LevelledEmbeddedDocument_MinLevel1({
				embeddedDocument: importMeta.embeddedDocument,
				level: level,
			}));
	}

	_pImportEntry_handleConDifference ({conInitial, conFinal, dataBuilderOpts, isConPreApplied}) {
		if (conInitial == null || conFinal == null || conFinal === conInitial) return;

		const modOld = Parser.getAbilityModNumber(conInitial);
		const modNew = Parser.getAbilityModNumber(conFinal);
		const hpIncrease = (dataBuilderOpts.numLevelsPrev + (isConPreApplied ? 0 : dataBuilderOpts.numLevels)) * (modNew - modOld);

		const {value: curValue, max: curMax} = Charactermancer_Util.getBaseHp(this._actor);

		const hpCurNxt = curValue + hpIncrease;
		const hpMaxNxt = curMax == null ? null : curMax + hpIncrease;

		MiscUtil.set(dataBuilderOpts.actorUpdate, "system", "attributes", "hp", "value", hpCurNxt);
		if (UtilActors.isSetMaxHp({actor: this._actor})) MiscUtil.set(dataBuilderOpts.actorUpdate, "system", "attributes", "hp", "max", hpMaxNxt);
	}

	async _pImportEntry_pAddUpdateClassItem (cls, sc, dataBuilderOpts) {
		for (const {dataBuilderProp, dataBuilderPropOut} of [
			{
				dataBuilderProp: "classItemToCreate",
				dataBuilderPropOut: "classItem",
			},
			{
				dataBuilderProp: "subclassItemToCreate",
				dataBuilderPropOut: "subclassItem",
			},
		]) {
			if (!dataBuilderOpts[dataBuilderProp]) continue;

			const importedEmbeds = await UtilActors.pAddActorItems(this._actor, [dataBuilderOpts[dataBuilderProp]]);
			dataBuilderOpts[dataBuilderPropOut] = DataConverter.getImportedEmbed(importedEmbeds, dataBuilderOpts[dataBuilderProp])?.document;
		}

		const toPersistClassSubclassItemUpdates = [
			dataBuilderOpts.isPersistClassItemUpdate ? dataBuilderOpts.classItemUpdate : null,
			dataBuilderOpts.isPersistSubclassItemUpdate ? dataBuilderOpts.subclassItemUpdate : null,
		].filter(Boolean);

		if (toPersistClassSubclassItemUpdates.length) {
			await UtilDocuments.pUpdateEmbeddedDocuments(
				this._actor,
				toPersistClassSubclassItemUpdates,
				{
					propData: "items",
					ClsEmbed: Item,
				},
			);
		}
	}

	async _pImportEntry_pAddUnarmedStrike ({importOpts}) {
		if (!Config.get(this._configGroup, "isAddUnarmedStrike")) return;

		const actorItems = MiscUtil.get(this._actor, "items") || [];
				const isExisting = actorItems.some(it => it.name.split("(")[0].trim().toLowerCase() === ImportListClass._ITEM_NAME_UNARMED_STRIKE.toLowerCase());
		if (isExisting) return;

		const dataUnarmed = {
			name: "Unarmed Strike",
			source: Parser.SRC_PHB,
			page: 149,
			srd: true,
			type: "M",
			rarity: "none",
			weaponCategory: "simple",
			foundrySystem: {
				"equipped": true,
				"damage.parts": [
					[
						"1 + @mod",
						"bludgeoning",
					],
				],
				"ability": "str",
			},
		};

		const {ChooseImporter} = await Promise.resolve().then(function () { return ChooseImporter$1; });
		const importer = ChooseImporter.getImporter("item", {actor: this._actor});
		await importer.pInit();
		await importer.pImportEntry(
			dataUnarmed,
			{
				taskRunner: importOpts.taskRunner,
			},
		);
	}

	async _pImportEntry_pAddAdvancements (dataBuilderOpts) {
		if (dataBuilderOpts.importedClassFeatureLevelledEmbeddedDocuments.length) {
			await UtilAdvancements.pAddAdvancementLinks({
				actor: this._actor,
				parentEmbeddedDocument: dataBuilderOpts.classItem,
				childLevelledEmbeddedDocuments: dataBuilderOpts.importedClassFeatureLevelledEmbeddedDocuments,
			});
		}

		if (dataBuilderOpts.importedSubclassFeatureLevelledEmbeddedDocuments.length) {
			await UtilAdvancements.pAddAdvancementLinks({
				actor: this._actor,
				parentEmbeddedDocument: dataBuilderOpts.subclassItem,
				childLevelledEmbeddedDocuments: dataBuilderOpts.importedSubclassFeatureLevelledEmbeddedDocuments,
			});
		}
	}

	async _pImportEntry_pFinalise (importOpts, dataBuilderOpts) {
				if (dataBuilderOpts.formDataEquipment?.data?.currency) MiscUtil.set(dataBuilderOpts.actorUpdate, "system", "currency", dataBuilderOpts.formDataEquipment.data.currency);

		await this._pDoMergeAndApplyActorUpdate(dataBuilderOpts.actorUpdate);

				await Charactermancer_StartingEquipment.pImportEquipmentItemEntries(this._actor, dataBuilderOpts.formDataEquipment, {taskRunner: importOpts.taskRunner});

				if (dataBuilderOpts.effects.length) throw new Error(`Class active effects should be populated on the class itself! This is a bug!`);

				if (
			Config.get("importSpell", Config.getSpellPointsKey({actorType: this._actor?.type})) === ConfigConsts.C_SPELL_POINTS_MODE__ENABLED_AND_UNLIMITED_SLOTS
		) {
			if (!UtilActors.hasActorSpellPointSlotEffect({actor: this._actor})) {
				await UtilActors.pAddActorEffects(this._actor, UtilActors.getActorSpellPointsSlotsEffectData({actor: this._actor, sheetIem: dataBuilderOpts.classItem}));
			}
			Object.assign(
				dataBuilderOpts.postItemActorUpdate,
				foundry.utils.flattenObject(UtilActors.getActorSpellPointsSlotsUpdateSys()),
			);
		}

				Util.trimObject(dataBuilderOpts.postItemActorUpdate);
		if (Object.keys(dataBuilderOpts.postItemActorUpdate).length) await UtilDocuments.pUpdateDocument(this._actor, dataBuilderOpts.postItemActorUpdate);

				await UtilActors.pLinkTempUuids({actor: this._actor});
	}

		async _pValidateUserLevelIndices (indices, dataBuilderOpts) {
				if (indices.length > 1) return;

				if (indices[0] === 0) return;

				const existingClassItems = this._actor.items.filter(it => it.type === "class");
		if (existingClassItems.length) return;

		const singleLevel = indices[0] + 1;
		const isSelectMissing = await InputUiUtil.pGetUserBoolean({
			title: "Import Lower Levels?",
			htmlDescription: `You have selected a single level to import (level ${singleLevel}). Would you like to import level${singleLevel === 2 ? "" : "s"} ${singleLevel === 2 ? "1" : `1-${singleLevel - 1}`} too?`,
			textYes: `Import Levels 1-${singleLevel}`,
			textNo: `Import Level ${singleLevel}`,
		});

		if (isSelectMissing == null) {
			dataBuilderOpts.isCancelled = true;
			return;
		}

		if (isSelectMissing) {
			const maxIndex = indices[0];
			for (let i = 0; i <= maxIndex; ++i) {
				indices[i] = i;
			}
		}
	}

	async _pImportEntry_pDoUpdateCharacter_pPopulateEquipment (cls, dataBuilderOpts) {
		if (!cls.startingEquipment) return;

		const startingEquipment = new Charactermancer_StartingEquipment({
			actor: this._actor,
			startingEquipment: cls.startingEquipment,
			appSubTitle: cls.name,
			equiSpecialSource: cls.source,
			equiSpecialPage: cls.page,
		});
		const formData = await startingEquipment.pWaitForUserInput();
		if (formData == null) return dataBuilderOpts.isCancelled = true;
		if (formData === VeCt.SYM_UI_SKIP) return;

		dataBuilderOpts.formDataEquipment = formData;
	}

	static _DEFAULT_FILTER_VALUES = null;

	static async pGetDefaultFilterValues () {
		if (this._DEFAULT_FILTER_VALUES) return MiscUtil.copy(this._DEFAULT_FILTER_VALUES);
		const modalFilterClasses = new ModalFilterClasses({namespace: `${ModalFilterClasses.name}.default`});
		await modalFilterClasses.pPreloadHidden();
		this._DEFAULT_FILTER_VALUES = modalFilterClasses.pageFilter.filterBox.getValues();
		return MiscUtil.copy(this._DEFAULT_FILTER_VALUES);
	}

	_getAsTag (listItem) {
		const cls = this._content.class[listItem.data.ixClass];
		const sc = cls.subclasses[listItem.data.ixSubclass];

		const ptId = DataUtil.generic.packUid(cls, "class");
		return `@class[${ptId}]`;

																	}
}
ImportListClass._AE_LABEL_BASE_AC = "Base/Unarmored AC";
ImportListClass._ITEM_NAME_UNARMED_STRIKE = "Unarmed Strike";

ImportListClass.ImportEntryOpts = class extends ImportListCharacter.ImportEntryOpts {
		constructor (opts) {
		super(opts);
		opts = opts || {};

		this.isClassImport = !!opts.isClassImport;

		this.actorUpdate = {}; 		this.postItemActorUpdate = {}; 
		this.classItemToCreate = null;
		this.classItemUpdate = null;
		this.isPersistClassItemUpdate = false;

		this.subclassItemToCreate = null;
		this.subclassItemUpdate = null;
		this.isPersistSubclassItemUpdate = false;

		this.classItem = null;
		this.subclassItem = null;

		this.formDataEquipment = null;

		this.targetLevel = null; 		this.numLevels = null; 		this.numLevelsPrev = null; 		this.isIncludesLevelOne = null;
		this.proficiencyImportMode = null;
		this.shouldBeMulticlass = null; 		this.hpIncreaseMode = null;
		this.hpIncreaseCustomRollFormula = null;

		this.importedClassFeatureLevelledEmbeddedDocuments = [];
		this.importedSubclassFeatureLevelledEmbeddedDocuments = [];
	}

	get currentLevelThisClass () {
		return this.targetLevel - this.numLevels;
	}

	get targetLevelThisClass () {
		return this.targetLevel;
	}
};

ImportListClass.Utils = class {
	static getDedupedData ({allContentMerged}) {
		allContentMerged = MiscUtil.copy(allContentMerged);

		Object.entries(allContentMerged)
			.forEach(([k, arr]) => {
				if (k !== "class") return;
				if (!(arr instanceof Array)) return;

				const out = [];
				const seen = new Set();
				arr.forEach(cls => {
					const hash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES](cls);

										if (seen.has(hash)) {
						if (cls.subclasses?.length) {
							const existingCls = out.find(it => UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES](it) === hash);
							(existingCls.subclasses = existingCls.subclasses || []).push(...cls.subclasses);
						}
						return;
					}

					seen.add(hash);
					out.push(cls);
				});

				allContentMerged[k] = out;
			});

		return allContentMerged;
	}

	static getBlocklistFilteredData ({dedupedAllContentMerged}) {
		dedupedAllContentMerged = {...dedupedAllContentMerged};
		Object.entries(dedupedAllContentMerged)
			.forEach(([k, arr]) => {
				if (k !== "class") return;
				if (!(arr instanceof Array)) return;

				const out = arr.filter(cls => {
					if (cls.source === VeCt.STR_GENERIC) return false;

					return !ExcludeUtil.isExcluded(
						UrlUtil.URL_TO_HASH_BUILDER["class"](cls),
						"class",
						cls.source,
						{isNoCount: true},
					);
				});

				out.forEach(cls => {
					if (!cls.classFeatures) return;

					cls.classFeatures = cls.classFeatures.filter(cf => !ExcludeUtil.isExcluded(
						cf.hash,
						"classFeature",
						cf.source,
						{isNoCount: true},
					));
				});

				out.forEach(cls => {
					if (!cls.subclasses) return;

					cls.subclasses = cls.subclasses.filter(sc => {
						if (sc.source === VeCt.STR_GENERIC) return false;

						return !ExcludeUtil.isExcluded(
							UrlUtil.URL_TO_HASH_BUILDER["subclass"](sc),
							"subclass",
							sc.source,
							{isNoCount: true},
						);
					});

					cls.subclasses.forEach(sc => {
						if (!sc.subclassFeatures) return;

						sc.subclassFeatures = sc.subclassFeatures.filter(scf => !ExcludeUtil.isExcluded(
							scf.hash,
							"subclassFeature",
							scf.source,
							{isNoCount: true},
						));
					});
				});

				dedupedAllContentMerged[k] = out;
			});
		return dedupedAllContentMerged;
	}
};

ImportListClass.AbilityScoreIncrease = class extends Application {
	constructor (actor, level, dataBuilderOpts) {
		super({
			title: `Ability Score Improvement\u2014Level ${level}`,
			template: `${SharedConsts.MODULE_LOCATION}/template/ImportListClassAbilityScoreIncrease.hbs`,
			width: 640,
			resizable: true,
		});

		this._dataBuilderOpts = dataBuilderOpts;

		this._resolve = null;
		this._reject = null;
		this._pUserInput = new Promise((resolve, reject) => {
			this._resolve = resolve;
			this._reject = reject;
		});

		this._comp = new ImportListClass.AbilityScoreIncrease.Component(
			actor,
			dataBuilderOpts,
			this.close.bind(this),
		);
	}

	activateListeners ($html) {
		this._comp.render($html);
	}

	async close () {
		await super.close();
		if (!this._comp.isDataEntered) this._dataBuilderOpts.isCancelled = true;
		this._resolve(this._comp.getFeat());
	}

	pWaitForUserInput () { return this._pUserInput; }
};
ImportListClass.AbilityScoreIncrease.Component = class extends BaseComponent {
	constructor (actor, dataBuilderOpts, fnClose) {
		super();
		this._actor = actor;
		this._dataBuilderOpts = dataBuilderOpts;
		this._fnClose = fnClose;

		this._isDataEntered = false;

		Object.assign(
			this.__state,
			Charactermancer_Util.getBaseAbilityScores(this._actor),
		);
	}

	get isDataEntered () { return this._isDataEntered; }

	render ($html) {
		const $btnShowTabAsi = $(`<button class="btn btn-default w-50 btn-5et">Ability Score Improvement</button>`)
			.click(() => this._state.mode = "ability");
		const $btnShowTabFeat = $(`<button class="btn btn-default w-50 btn-5et">Feat</button>`)
			.click(() => this._state.mode = "feat");

		const $wrpTabAsi = $(`<div class="ve-flex-col w-100 h-100"></div>`);
		const $wrpTabFeat = $(`<div class="ve-flex-col w-100 h-100"></div>`);

		const hkMode = () => {
			const isAbilityMode = this._state.mode === "ability";
			$btnShowTabAsi.toggleClass("active", isAbilityMode);
			$btnShowTabFeat.toggleClass("active", !isAbilityMode);
			$wrpTabAsi.toggleVe(isAbilityMode);
			$wrpTabFeat.toggleVe(!isAbilityMode);
		};
		hkMode();
		this._addHookBase("mode", hkMode);

		this._render_ability($wrpTabAsi);
		this._render_feat($wrpTabFeat);

		$$($html)`<div class="ve-flex-col w-100 h-100">
			<div class="ve-flex no-shrink btn-group mb-1">${$btnShowTabAsi}${$btnShowTabFeat}</div>
			${$wrpTabAsi}
			${$wrpTabFeat}
		</div>`;
	}

	_render_ability ($wrpTabAsi) {
		const rowMetas = [
			"str",
			"dex",
			"con",
			"int",
			"wis",
			"cha",
		].map(abil => {
			const $dispCur = $(`<div class="col-2 text-center"></div>`);
			const $dispCurMod = $(`<div class="col-2 text-center"></div>`);
			const hkBase = () => {
				$dispCur.text(this._state[abil]);
				$dispCurMod.text(Parser.getAbilityModifier(this._state[abil]));
			};
			this._addHookBase(abil, hkBase);
			hkBase();

			const propBonus = `${abil}Bonus`;
			const {$wrp: $wrpBonus, $ipt: $iptBonus} = ComponentUiUtil.$getIptNumber(
				this,
				propBonus,
				0,
				{
					min: 0,
					fallbackOnNaN: 0,
					html: `<input type="text" class="text-center" placeholder="0">`,
					asMeta: true,
					decorationRight: "ticker",
					decorationLeft: "spacer",
				},
			);
			$iptBonus.click(() => $iptBonus.select());

			const $dispTotal = $(`<div class="col-2 text-center"></div>`);
			const $dispTotalMod = $(`<div class="col-2 text-center"></div>`);
			const hkBonus = () => {
				const scoreTotal = this._state[abil] + this._state[propBonus];
				$dispTotal.text(scoreTotal);
				$dispTotalMod.text(Parser.getAbilityModifier(scoreTotal));
				$dispTotal.toggleClass("veapp__msg-error", scoreTotal > 20).title(scoreTotal > 20 ? `You can't increase an ability score above 20 using this feature.` : "");
			};
			this._addHookBase(propBonus, hkBonus);
			hkBonus();

			const $row = $$`<div class="ve-flex w-100 my-1">
				<div class="col-1 text-right bold">${abil.toUpperCase()}</div>
				${$dispCur}
				${$dispCurMod}
				<div class="col-2">${$wrpBonus}</div>
				<div class="col-1 text-center">=</div>
				${$dispTotal}
				${$dispTotalMod}
			</div>`;

			return {
				$row,
				$iptBonus,
			};
		});

		const $dispRemain = $(`<div class="text-center" title="Remaining"></div>`);

		const hkBonuses = () => {
			const totalBonuses = [
				"strBonus",
				"dexBonus",
				"conBonus",
				"intBonus",
				"wisBonus",
				"chaBonus",
			].map(prop => this._state[prop]).reduce((a, b) => a + b, 0);

			const isInvalid = totalBonuses > 2;

			$dispRemain.text(`Remaining: ${2 - totalBonuses}`).toggleClass("veapp__msg-error", isInvalid);
			rowMetas.forEach(it => it.$iptBonus.toggleClass("form-control--error", isInvalid));
		};
		[
			"strBonus",
			"dexBonus",
			"conBonus",
			"intBonus",
			"wisBonus",
			"chaBonus",
		].forEach(prop => this._addHookBase(prop, hkBonuses));
		hkBonuses();

		const $btnAcceptAsi = $(`<button class="btn btn-primary mr-2">Confirm</button>`)
			.click(async () => {
				const total = [
					this._state.strBonus,
					this._state.dexBonus,
					this._state.conBonus,
					this._state.intBonus,
					this._state.wisBonus,
					this._state.chaBonus,
				].reduce((a, b) => a + b, 0);
				if (total !== 2) return ui.notifications.error(`Please enter a combination of ability score changes which adds up to two!`);

				await this._pDoResolve(true);
			});

		const $btnSkipAsi = $(`<button class="btn btn-default mr-3">Skip</button>`)
			.click(() => this._pDoResolve(VeCt.SYM_UI_SKIP));

		$$($wrpTabAsi)`
		<div class="ve-flex w-100 my-1 bold">
			<div class="text-center col-1"></div>
			<div class="text-center col-2">Current</div>
			<div class="text-center col-2 ve-muted">Mod</div>
			<div class="text-center col-2 text-center">${$dispRemain}</div>
			<div class="text-center col-1"></div>
			<div class="text-center col-2">Result</div>
			<div class="text-center col-2 ve-muted">Mod</div>
		</div>
		<div class="ve-flex-col w-100 h-100">
			${rowMetas.map(it => it.$row)}
		</div>
		<div class="ve-flex-v-center ve-flex-h-right w-100">${$btnAcceptAsi}${$btnSkipAsi}</div>
		`;
	}

	_render_feat ($wrpTabFeat) {
		const $btnSelectFeat = $(`<button class="btn btn-default btn-5et w-100 mr-2">Choose Feat</button>`)
			.click(async () => {
				const featData = await ImportListFeat.UserChoose.pGetUserChoice(
					{
						id: "feats-classAbilityScoreIncrease",
						name: "Feats",
						singleName: "Feat",

						wizardTitleWindow: "Select Source",
						wizardTitlePanel3: "Configure and Open List",
						wizardTitleButtonOpenImporter: "Open List",
					},
					"classAbilityScoreIncrease",
				);
				if (!featData) return;

				const {page, source, hash} = MiscUtil.get(featData, "flags", SharedConsts.MODULE_ID) || {};
				if (!page || !source || !hash) return;

				this._state.feat = await DataLoader.pCacheAndGet(page, source, hash);
			});

		const $dispFeat = $(`<div></div>`);
		const hkFeat = () => {
			$dispFeat.empty();

			if (!this._state.feat) return;
			$dispFeat.html(`<hr class="hr-1"><h3 class="mb-2 mt-0 b-0">Selected: ${this._state.feat.name}</h3>`);

			$dispFeat.empty();
			$$($dispFeat)`<hr class="hr-1">
			${Vetools.withUnpatchedDiceRendering(() => Renderer.hover.$getHoverContent_stats(UrlUtil.PG_FEATS, MiscUtil.copy(this._state.feat)))}`;
		};
		hkFeat();
		this._addHookBase("feat", hkFeat);

		const $btnAcceptFeat = $(`<button class="btn btn-primary btn-5et">Confirm</button>`)
			.click(async () => {
				if (!this._state.feat) return ui.notifications.error(`Please select a feat!`);
				await this._pDoResolve(true);
			});

		const $btnSkipFeat = $(`<button class="btn btn-default btn-5et">Skip</button>`)
			.click(() => this._pDoResolve(VeCt.SYM_UI_SKIP));

		$$($wrpTabFeat)`
		<div class="ve-flex-col h-100">
			<div class="ve-flex-v-center mb-1">
				${$btnSelectFeat}
				<div class="ve-flex-v-center btn-group">${$btnAcceptFeat}${$btnSkipFeat}</div>
			</div>
			${$dispFeat}
		</div>
		`;
	}

	async _pDoResolve (isOutput) {
		if (!isOutput) return this._fnClose();

		if (isOutput === VeCt.SYM_UI_SKIP) {
			this._isDataEntered = true;
			return this._fnClose();
		}

		const actUpdate = this._getActorUpdate();
		if (actUpdate) {
			this._isDataEntered = true;
			await UtilDocuments.pUpdateDocument(this._actor, actUpdate);
		}

		if (this.getFeat()) {
			this._isDataEntered = true;
		}

		this._fnClose();
	}

	_getActorUpdate () {
		if (this._state.mode !== "ability") return null;
		return {
			system: {
				abilities: {
					str: {value: this._state.str + this._state.strBonus},
					dex: {value: this._state.dex + this._state.dexBonus},
					con: {value: this._state.con + this._state.conBonus},
					int: {value: this._state.int + this._state.intBonus},
					wis: {value: this._state.wis + this._state.wisBonus},
					cha: {value: this._state.cha + this._state.chaBonus},
				},
			},
		};
	}

	getFeat () {
		if (this._state.mode !== "feat") return null;
		return MiscUtil.copy(this._state.feat);
	}

	_getDefaultState () {
		return {
			mode: "ability",

			str: 0,
			dex: 0,
			con: 0,
			int: 0,
			wis: 0,
			cha: 0,
			strBonus: 0,
			dexBonus: 0,
			conBonus: 0,
			intBonus: 0,
			wisBonus: 0,
			chaBonus: 0,

			feat: null,
		};
	}
};

ImportListClass.SheetLevelUpButtonAdapter = class {
	static init () {
		Hooks.on("renderActorSheet", (app, $html, data) => {
			this._pHandleRenderSheet(app, $html, data).then(null);
		});
	}

	static async _pHandleRenderSheet (app, $html, data) {
		if (!Config.get("importClass", "isAddLevelUpButton")) return;
		if (!data.owner) return;
		if (!data.isCharacter) return;

		const sheetAdapter = ImportListClass.SheetLevelUpButtonAdapter._SUPPORTED_SHEETS[app.constructor.name];

		if (!sheetAdapter) return;

		const minRole = Config.get("import", "minimumRole");
		if (game.user.role < minRole) return;

		const existingClassItems = app.actor.items.filter(it => it.type === "class");
		if (!existingClassItems.length) return;
		const existingSubclassItems = app.actor.items.filter(it => it.type === "subclass");

		const existingClassSubclassItemTuples = Charactermancer_Class_Util.getClassSubclassItemTuples({classItems: existingClassItems, subclassItems: existingSubclassItems});

		const availableClassesMetas = await existingClassSubclassItemTuples.pSerialAwaitMap(tuple => this._pGetAvailableClassSubclass(tuple));

		const $btnLevelUp = !availableClassesMetas.some(it => !it.errors) ? this._$getBtnLevelUp_errors({availableClassesMetas}) : this._$getBtnLevelUp({app, availableClassesMetas});

		sheetAdapter.addButton(app.form, $btnLevelUp);
	}

	static _$getBtn () {
		return $(`<button class="btn btn-5et btn-xxs ml-1 imp-cls__btn-sheet-level-up ve-flex-vh-center" type="button"><i class="fas fa-fw fa-arrow-alt-circle-up mx-auto pl-1p"></i></button>`);
	}

	static _$getBtnLevelUp_errors ({availableClassesMetas}) {
		const ptErrors = availableClassesMetas.map(it => it.errors).filter(Boolean).flat().join("; ");

		return this._$getBtn()
			.prop("disabled", true)
			.title(`Cannot Level Up\u2014no known classes found.${availableClassesMetas.length ? ` Errors were: ${ptErrors}.` : ""}`);
	}

	static _$getBtnLevelUp ({app, availableClassesMetas}) {
		const isGlowing = !UtilGameSettings.getSafe(game.system.id, "disableExperienceTracking") && UtilActors.isLevelUp(app.actor);

		return this._$getBtn()
			.toggleClass("btn-pulse", !!isGlowing)
			.title(`Level Up`)
			.click(async evt => {
				return this._pHandleClick_levelUpLegacy({app, availableClassesMetas});
			});
	}

	static async _pHandleClick_levelUpLegacy ({app, availableClassesMetas}) {
		const {$modalInner, doClose, doAutoResize: doAutoResizeModal} = await UtilApplications.pGetShowApplicationModal({
			title: `Level Up`,
			isMaxWidth640p: true,
			isMinHeight0: true,
		});

		const $rows = availableClassesMetas.map(({errors, existingClassItem, existingSubclassItem, cls, sc, filterValues}) => {
			if (errors) {
				return $$`<div class="ve-flex-col stripe-even py-1 ve-muted">
					<p>${(existingClassItem.name || "").qq()}${existingSubclassItem?.name ? ` (${existingSubclassItem.name.qq()})` : ""} was not available for level up:</p>${errors.map(it => `<p><i>${it.qq()}</i></p>`).join("")}
				</div>`;
			}

			const $btnChoose = $(`<button class="btn btn-5et btn-sm no-wrap" title="Level up this class"><i class="fas fa-fw fa-arrow-alt-circle-up"></i> Level ${existingClassItem.system.levels} &#8594; Level ${existingClassItem.system.levels + 1}</button>`)
				.click(async () => {
					doClose();

					const targetLevel = Number(existingClassItem.system.levels) + 1;

					if (!sc) {
						const minSubclassLevel = Math.min(...cls.classFeatures
							.filter(it => it.gainSubclassFeature && it.classFeature)
							.map(it => DataUtil.class.unpackUidClassFeature(it.classFeature).level));
						if (targetLevel >= minSubclassLevel) {
							const isSelectSubclass = await InputUiUtil.pGetUserBoolean({
								title: `Choose Subclass?`,
								htmlDescription: `Would you like to choose a subclass to include in the level up?`,
								textYes: "Yes",
								textNo: "No",
							});

							if (isSelectSubclass) {
								const modalFilterClasses = new ModalFilterClasses({namespace: `${ModalFilterClasses.name}.selectSubclass`});
								const selected = await modalFilterClasses.pGetUserSelection({ 									selectedClass: cls,
									isClassDisabled: true,
								});
								if (selected) sc = selected.subclass;
							}
						}
					}

					const importList = new ImportListClass({actor: app.actor});
					await importList.pInit();

					cls = MiscUtil.copy(cls);
					delete cls.subclasses; 
					const importableClassData = await ImportListClass.pPostLoad(
						{class: [cls], subclass: [sc].filter(Boolean)},
						{actor: app.actor},
					);
					await importList.pImportClass(importableClassData.class[0], {levels: [targetLevel], filterValues});

					ui.notifications.info(`Level up complete!`);
				});

			return $$`<div class="ve-flex-v-center stripe-even py-1">
				<div class="w-100 mr-2">${existingClassItem.name}${sc && existingSubclassItem ? ` (${existingSubclassItem.name})` : ""}</div>
				<div>${$btnChoose}</div>
			</div>`;
		});

		const $btnAddNewLevel = $(`<button class="btn btn-5et btn-sm no-wrap"><i class="fas fa-fw fa-plus-circle"></i> Add New Class (Multiclass)</button>`)
			.click(async () => {
				doClose();

				const importListClassSources = await (new ImportListClass()).pGetSources();
				const appSourceSelector = new AppSourceSelectorMulti({
					title: `Select Class Sources`,
					filterNamespace: `ImportListClass_SheetLevelUpButtonAdapter_filter`,
					savedSelectionKey: `ImportListClass_SheetLevelUpButtonAdapter_savedSelection`,
					sourcesToDisplay: importListClassSources,
					fnGetDedupedData: ImportListClass.Utils.getDedupedData.bind(ImportListClass.Utils),
					fnGetBlocklistFilteredData: ImportListClass.Utils.getBlocklistFilteredData.bind(ImportListClass.Utils),
				});

				const allData = await appSourceSelector.pWaitForUserInput();
				if (allData == null) return;

				const modalFilterClasses = new ModalFilterClassesFvtt({
					namespace: `${ModalFilterClasses.name}.selectSubclass`,
					allData: allData.class,
				});
				const selected = await modalFilterClasses.pGetUserSelection({});
				if (!selected?.class) return;

				const importList = new ImportListClass({actor: app.actor});
				await importList.pInit();

				const clsRaw = await DataLoader.pCacheAndGet("raw_class", selected.class.source, UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES]({name: selected.class.name, source: selected.class.source}), {isCopy: true});
				const scRaw = selected.subclass ? await DataLoader.pCacheAndGet("raw_subclass", selected.subclass.source, UrlUtil.URL_TO_HASH_BUILDER["subclass"]({name: selected.subclass.name, shortName: selected.subclass.shortName, source: selected.subclass.source, className: selected.subclass.className, classSource: selected.subclass.classSource}), {isCopy: true}) : null;

				delete clsRaw.subclasses; 
				const importableClassData = await ImportListClass.pPostLoad(
					{class: [clsRaw], subclass: [scRaw].filter(Boolean)},
					{actor: app.actor},
				);

				const clsOut = importableClassData.class[0];
				clsOut._foundryStartingProficiencyMode = Charactermancer_Class_ProficiencyImportModeSelect.MODE_MULTICLASS;

				await importList.pImportClass(importableClassData.class[0], {levels: [1], filterValues: (await ImportListClass.pGetDefaultFilterValues())});

				ui.notifications.info(`Level up complete!`);
			});

		$$`<div class="ve-flex-col h-100 w-100 mt-2">
			<div class="mb-1">Your current classes are listed below.</div>
			<div class="mb-1">If you level a class which does not have a subclass, and is eligible for one, you will be prompted to choose a subclass.</div>
			<div>${Renderer.get().render(`Alternatively, you may gain a level in a new class, if your DM allows {@variantrule multiclassing|phb}.`)}</div>
			<hr class="hr-2">
			<div class="w-100">
				${$rows}
			</div>
			<hr class="hr-1 hr--dotted">
			<div class="mt-1 mb-2 ve-flex-h-right">${$btnAddNewLevel}</div>
		</div>`.appendTo($modalInner);

		doAutoResizeModal();
	}

	static async _pCacheClassData () {
		ImportListClass.SheetLevelUpButtonAdapter._P_LOADING_CLASS_DATA = ImportListClass.SheetLevelUpButtonAdapter._P_LOADING_CLASS_DATA || (async () => {
			ImportListClass.SheetLevelUpButtonAdapter._CACHE_CLASS_DATA = await DataUtil.class.loadRawJSON();
		})();
		await ImportListClass.SheetLevelUpButtonAdapter._P_LOADING_CLASS_DATA;
	}

	static async _pGetAvailableClassSubclass (itemTuple) {
		const {classItem: existingClassItem, subclassItem: existingSubclassItem} = itemTuple;

		const levelNumber = Number(existingClassItem.system.levels);
		if (isNaN(levelNumber)) return {existingClassItem, existingSubclassItem, errors: [`Class item "${existingClassItem.name}" (${existingClassItem.id}) did not have a valid "levels" value!`]};

		const flagsCls = existingClassItem?.flags?.[SharedConsts.MODULE_ID];
		const flagsSc = existingSubclassItem?.flags?.[SharedConsts.MODULE_ID];

		const filterValues = await this._pGetFilterValues(flagsSc || flagsCls); 
		const isClassDefinedInFlags = flagsCls && flagsCls.page && flagsCls.source && flagsCls.hash && !this._isLikelySubclassHash(flagsCls.hash);
		if (!isClassDefinedInFlags) return this._pGetAvailableClassSubclassFromName({itemTuple, filterValues});

		const cls = await DataLoader.pCacheAndGet("raw_class", flagsCls.source, flagsCls.hash, {isCopy: true});
		if (!cls) return {existingClassItem, existingSubclassItem, errors: [`Failed to find and/or load class "${flagsCls.hash}" (${flagsCls.source}) from flags`]};

		if (!existingSubclassItem) return {existingClassItem, existingSubclassItem, cls, filterValues};

		const isSubclassDefinedInFlags = flagsSc && flagsSc.page && flagsSc.source && flagsSc.hash && this._isLikelySubclassHash(flagsSc.hash);
		if (!isSubclassDefinedInFlags) return this._pGetAvailableClassSubclassFromName({itemTuple, filterValues, cls});

		const sc = await DataLoader.pCacheAndGet("raw_subclass", flagsSc.source, flagsSc.hash, {isCopy: true});
		if (!sc) return {existingClassItem, existingSubclassItem, cls, errors: [`Failed to find and/or load subclass "${flagsSc.hash}" (${flagsSc.source}) from flags`]};

		return {existingClassItem, existingSubclassItem, cls, sc, filterValues};
	}

		static _isLikelySubclassHash (hash) { return hash.includes(`,state:sub-`); }

	static async _pGetAvailableClassSubclassFromName ({itemTuple, filterValues, cls}) {
		const {classItem: existingClassItem, subclassItem: existingSubclassItem} = itemTuple;

		await this._pCacheClassData();

		cls = cls || Charactermancer_Class_Util.getClassFromExistingClassItem(existingClassItem, ImportListClass.SheetLevelUpButtonAdapter._CACHE_CLASS_DATA.class);

		if (!cls) return {existingClassItem, errors: [`Failed to find and/or load class "${existingClassItem.name}" (${UtilDataConverter.getItemSource(existingClassItem).source}) by name`]};

		const sc = existingSubclassItem
			? Charactermancer_Class_Util.getSubclassFromExistingSubclassItem(existingSubclassItem, cls, ImportListClass.SheetLevelUpButtonAdapter._CACHE_CLASS_DATA.subclass)
			: null;

		if (existingSubclassItem && sc == null) return {existingClassItem, errors: [`Failed to find and/or load subclass "${existingSubclassItem.name}" by name`]};

		return {existingClassItem, existingSubclassItem, cls, sc, filterValues};
	}

	static async _pGetFilterValues (flags) {
		if (flags?.filterValues) return flags.filterValues;

						return ImportListClass.pGetDefaultFilterValues();
	}

	static registerSupportedSheet (sheetName, ClassAdapter) {
		ImportListClass.SheetLevelUpButtonAdapter._SUPPORTED_SHEETS[sheetName] = ClassAdapter;
	}
};
ImportListClass.SheetLevelUpButtonAdapter._P_LOADING_CLASS_DATA = null;
ImportListClass.SheetLevelUpButtonAdapter._CACHE_CLASS_DATA = null;

ImportListClass.SheetLevelUpButtonAdapter._SUPPORTED_SHEETS = {};

ImportListClass.SheetLevelUpButtonAdapter.SheetAdapter = class {
	static addButton (form, $btn) { throw new Error(`Unimplemented!`); }

		static _removeExistingButton (tgt) { $(tgt).find(`.imp-cls__btn-sheet-level-up`).remove(); }
};

ImportListClass.SheetLevelUpButtonAdapter.SheetAdapterActorSheet5eCharacter = class extends ImportListClass.SheetLevelUpButtonAdapter.SheetAdapter {
	static addButton (form, $btn) {
		if (!this._INDEX_PATH) {
			const $ele = $(form).find(`.charlevel`);
			this._INDEX_PATH = ElementUtil.getIndexPathToParent(form, $ele[0]);
		}

		const tgt = ElementUtil.getChildByIndexPath(form, this._INDEX_PATH);
		$btn.css({fontSize: 10.5});
		this._removeExistingButton(tgt);
		$(tgt).append($btn);
	}
};
ImportListClass.SheetLevelUpButtonAdapter.SheetAdapterActorSheet5eCharacter._INDEX_PATH = null;
ImportListClass.SheetLevelUpButtonAdapter.registerSupportedSheet(
	"ActorSheet5eCharacter",
	ImportListClass.SheetLevelUpButtonAdapter.SheetAdapterActorSheet5eCharacter,
);

ImportListClass.SheetLevelUpButtonAdapter.Tidy5eSheet = class extends ImportListClass.SheetLevelUpButtonAdapter.SheetAdapter {
	static addButton (form, $btn) {
		if (!this._INDEX_PATH) {
			const $ele = $(form).find(`.level-information`);
			this._INDEX_PATH = ElementUtil.getIndexPathToParent(form, $ele[0]);
		}

		const tgt = ElementUtil.getChildByIndexPath(form, this._INDEX_PATH);
		$btn.addClass("ml-2 ve-self-flex-center b-0");
		this._removeExistingButton(tgt);
		$(tgt).prepend($btn);
	}
};
ImportListClass.SheetLevelUpButtonAdapter.Tidy5eSheet._INDEX_PATH = null;
ImportListClass.SheetLevelUpButtonAdapter.registerSupportedSheet(
	"Tidy5eSheet",
	ImportListClass.SheetLevelUpButtonAdapter.Tidy5eSheet,
);

var ImportListClass$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ImportListClass: ImportListClass
});

class PageFilterClassFeatures extends PageFilter {
		static sortClassFeatures (a, b, o) {
		switch (o.sortBy) {
			case "name": return SortUtil.compareListNames(a, b) || SortUtil.ascSort(a.values.className, b.values.className) || SortUtil.ascSort(a.values.subclassShortName, b.values.subclassShortName) || SortUtil.ascSort(a.values.level, b.values.level);
			case "className": return SortUtil.ascSort(a.values.className, b.values.className) || SortUtil.ascSort(a.values.subclassShortName, b.values.subclassShortName) || SortUtil.ascSort(a.values.level, b.values.level) || SortUtil.compareListNames(a, b);
			case "subclassShortName": return SortUtil.ascSort(a.values.subclassShortName, b.values.subclassShortName) || SortUtil.ascSort(a.values.className, b.values.className) || SortUtil.ascSort(a.values.level, b.values.level) || SortUtil.compareListNames(a, b);
			case "level": return SortUtil.ascSort(a.values.level, b.values.level) || SortUtil.ascSort(a.values.className, b.values.className) || SortUtil.ascSort(a.values.subclassShortName, b.values.subclassShortName) || SortUtil.compareListNames(a, b);
			case "source": return SortUtil.ascSort(a.values.source, b.values.source) || SortUtil.ascSort(a.values.className, b.values.className) || SortUtil.ascSort(a.values.subclassShortName, b.values.subclassShortName) || SortUtil.ascSort(a.values.level, b.values.level) || SortUtil.compareListNames(a, b);
		}
	}
	
	constructor () {
		super();

		this._classFilter = new Filter({
			header: "Class",
			groupFn: it => it.userData.group,
		});
		this._subclassFilter = new Filter({
			header: "Subclass",
			nests: {},
			groupFn: it => it.userData.group,
		});
		this._levelFilter = new Filter({
			header: "Level",
			displayFn: it => `Level ${it}`,
		});
		this._miscFilter = new Filter({header: "Miscellaneous", items: ["SRD", "Basic Rules"], isMiscFilter: true});
	}

	static mutateForFilters (feature) {
		feature._fClass = this._getClassFilterItem({
			className: feature.className,
			classSource: feature.classSource,
		});
		if (feature.subclassShortName && feature.subclassSource) {
			feature._fSubclass = this._getSubclassFilterItem({
				className: feature.className,
				classSource: feature.classSource,
				subclassShortName: feature.subclassShortName,
				subclassSource: feature.subclassSource,
			});
		}
		feature._fMisc = feature.srd ? ["SRD"] : [];
		if (feature.basicRules) feature._fMisc.push("Basic Rules");
	}

	addToFilters (feature, isExcluded) {
		if (isExcluded) return;

		this._sourceFilter.addItem(feature.source);
		this._classFilter.addItem(feature._fClass);
		if (feature._fSubclass) {
			this._subclassFilter.addNest(feature._fSubclass.nest, {isHidden: true});
			this._subclassFilter.addItem(feature._fSubclass);
		}
		this._levelFilter.addItem(feature.level);
	}

	async _pPopulateBoxOptions (opts) {
		opts.filters = [
			this._sourceFilter,
			this._classFilter,
			this._subclassFilter,
			this._levelFilter,
			this._miscFilter,
		];
	}

	toDisplay (values, ft) {
		return this._filterBox.toDisplay(
			values,
			ft.source,
			ft._fClass,
			ft._fSubclass,
			ft.level,
			ft._fMisc,
		);
	}
}

class ImportListClassFeature extends ImportListFeature {
		static init () {
		this._initCreateSheetItemHook({
			prop: "classFeature",
			importerName: "Class Feature",
		});
		this._initCreateSheetItemHook({
			prop: "subclassFeature",
			importerName: "Subclass Feature",
		});
	}
	
	static get ID () { return "classes-subclasses-features"; }
	static get DISPLAY_NAME_TYPE_SINGLE () { return "Class or Subclass Feature"; }
	static get DISPLAY_NAME_TYPE_PLURAL () { return "Class & Subclass Features"; }
	static get PROPS () { return ["classFeature", "subclassFeature"]; }

	static _ = this.registerImpl(this);

	_dirsHomebrew = ["classFeature", "subclassFeature"];
	_titleSearch = "class and subclass feature";
	_sidebarTab = "items";
	_gameProp = "items";
	_defaultFolderPath = ["Class & Subclass Features"];
	_pageFilter = new PageFilterClassFeatures();
	_page = UrlUtil.PG_CLASS_SUBCLASS_FEATURES;
	_listInitialSortBy = "className";
	_isPreviewable = true;
	_isDedupable = true;
	_configGroup = "importClassSubclassFeature";
	_fnListSort = PageFilterClassFeatures.sortClassFeatures;
	static _DataConverter = DataConverterClassSubclassFeature;

	constructor (...args) {
		super(...args);

		this._contentDereferenced = null;
	}

	async _pGetSources () {
		return [
			new UtilDataSource.DataSourceSpecial(
				Config.get("ui", "isStreamerMode") ? "SRD" : "5etools",
				Vetools.pGetClassSubclassFeatures,
				{
					cacheKey: "5etools-class-subclass-features",
					filterTypes: [UtilDataSource.SOURCE_TYP_OFFICIAL_ALL],
					isDefault: true,
					pPostLoad: loadedData => this.constructor._pPostLoad(loadedData),
				},
			),
			...UtilDataSource.getSourcesCustomUrl({pPostLoad: loadedData => this.constructor._pPostLoad(loadedData)}),
			...UtilDataSource.getSourcesUploadFile({pPostLoad: loadedData => this.constructor._pPostLoad(loadedData)}),
			...(await this._pGetSourcesPrerelease({pPostLoad: loadedData => this.constructor._pPostLoad(loadedData)})),
			...(await this._pGetSourcesBrew({pPostLoad: loadedData => this.constructor._pPostLoad(loadedData)})),
		];
	}

	static async _pPostLoad (loadedData) {
		const out = {};

		for (let [k, arr] of Object.entries(loadedData)) {
			if (!this.PROPS.includes(k)) continue;

			arr = arr.filter(it => it.name.toLowerCase() !== "ability score improvement");

						const outArr = [];
			for (const feature of arr) {
				const loaded = await this._pGetInitFeatureLoadeds(feature);
				if (!loaded || loaded.isIgnored) continue;
				outArr.push(feature);
			}

			out[k] = outArr;
		}

		return out;
	}

	_colWidthName = 5;
	_colWidthSource = 1;

	_getData_cols_other () {
		return [
			{
				name: "Class",
				width: 2,
				field: "className",
			},
			{
				name: "Subclass",
				width: 2,
				field: "subclassShortName",
			},
			{
				name: "Level",
				width: 1,
				field: "level",
				rowClassName: "text-center",
			},
		];
	}

	_getData_row_mutGetAdditionalValues ({it, ix}) {
		return {
			className: it.className,
			subclassShortName: it.subclassShortName || "\u2014",
			level: it.level,
		};
	}

	_renderInner_absorbListItems_fnGetValues (it) {
		return {
			...super._renderInner_absorbListItems_fnGetValues(it),
			className: it.className,
			subclassShortName: it.subclassShortName || "",
			level: it.level,
		};
	}

	async pSetContent (val) {
		await super.pSetContent(val);
		this._contentDereferenced = await this._content
			.pMap(feature => DataConverterClassSubclassFeature.pGetDereferencedFeatureItem(feature));
	}

	_renderInner_initPreviewButton (item, btnShowHidePreview) {
		ListUiUtil.bindPreviewButton(this._page, this._contentDereferenced, item, btnShowHidePreview);
	}

	_getAsTag (listItem) {
		const tag = Parser.getPropTag(this._content[listItem.ix].__prop);
		const ptUid = this._getUid(this._content[listItem.ix]);
		return `@${tag}[${ptUid}]`;
	}

	_getUid (feature) {
		switch (feature.__prop) {
			case "classFeature": return DataUtil.class.packUidClassFeature(feature);
			case "subclassFeature": return DataUtil.class.packUidSubclassFeature(feature);
			default: throw new Error(`Unhandled feature prop "${feature.__prop}"`);
		}
	}
}

ImportListClassFeature.UserChoose = class extends MixinUserChooseImporter(ImportListClassFeature) {};

var ImportListClassFeature$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ImportListClassFeature: ImportListClassFeature
});

class DataConverterBackground extends DataConverter {
	static _SIDE_LOAD_OPTS = {
		propBrew: "foundryBackground",
		fnLoadJson: async () => this._pGetPreloadSideData(),
		propJson: "background",
	};

	static _IMG_FALLBACK = `modules/${SharedConsts.MODULE_ID}/media/icon/farmer.svg`;

	static _getCompendiumAliases (ent) {
		if (!ent.name) return [];
				return [];
	}

		static async pGetDocumentJson (bg, opts) {
		opts = opts || {};
		if (opts.actor) opts.isActorItem = true;

		Renderer.get().resetHeaderIndex();

		const fluff = opts.fluff || await Renderer.background.pGetFluff(bg);

		const description = Config.get("importBackground", "isImportDescription")
			? await UtilDataConverter.pGetWithDescriptionPlugins(() => {
				const rendered = [
					fluff?.entries?.length ? Renderer.get().setFirstSection(true).render({type: "entries", entries: fluff?.entries}) : "",
					Renderer.get().setFirstSection(true).render({type: "entries", entries: bg.entries}),
				].filter(Boolean);
				return `<div>${rendered.join("<hr>")}</div>`;
			})
			: "";

		const img = await this._pGetSaveImagePath(bg, {propCompendium: "background", fluff, taskRunner: opts.taskRunner});

		const additionalData = await this._pGetDataSideLoaded(bg);
		const additionalFlags = await this._pGetFlagsSideLoaded(bg);
		const additionalAdvancement = await this._pGetAdvancementSideLoaded(bg);

		const effectsSideTuples = await this._pGetEffectsSideLoadedTuples({ent: bg, img, actor: opts.actor});
		effectsSideTuples.forEach(({effect, effectRaw}) => DataConverter.mutEffectDisabledTransfer(effect, "importBackground", UtilActiveEffects.getDisabledTransferHintsSideData(effectRaw)));

		const out = {
			name: UtilApplications.getCleanEntityName(UtilDataConverter.getNameWithSourcePart(bg)),
			type: "background",
			system: {
				description: {value: description, chat: "", unidentified: ""},
				source: UtilDataConverter.getSourceWithPagePart(bg),

								damage: {parts: []},
				activation: {type: "", cost: 0, condition: ""},
				duration: {value: null, units: ""},
				target: {value: null, units: "", type: ""},
				range: {value: null, long: null, units: ""},
				uses: {value: 0, max: 0, per: null},
				ability: null,
				actionType: "",
				attackBonus: null,
				chatFlavor: "",
				critical: {threshold: null, damage: ""},
				formula: "",
				save: {ability: "", dc: null},
				requirements: "",
				recharge: {value: null, charged: false},
				consume: {type: "", target: "", amount: null},
				
				advancement: [
					...(additionalAdvancement || []),
				],

				...additionalData,
			},
			ownership: {default: 0},
			flags: {
				...this._getBackgroundFlags(bg, opts),
				...additionalFlags,
			},
			effects: DataConverter.getEffectsMutDedupeId(effectsSideTuples.map(it => it.effect)),
			img,
		};

		if (opts.defaultOwnership != null) out.ownership = {default: opts.defaultOwnership};
		else if (opts.isAddDefaultOwnershipFromConfig) out.ownership = {default: Config.get("importBackground", "ownership")};
		if (opts.userOwnership) Object.assign(out.ownership, opts.userOwnership);

		return out;
	}

	static _getBackgroundFlags (bg, opts) {
		const out = {
			[SharedConsts.MODULE_ID]: {
				page: UrlUtil.PG_BACKGROUNDS,
				source: bg.source,
				hash: UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BACKGROUNDS](bg),
				propDroppable: "background",
				filterValues: opts.filterValues,
			},
		};

		if (opts.isActorItem) out[SharedConsts.MODULE_ID].isDirectImport = true;

		return out;
	}

	static async _pGetPreloadSideData () {
		if (!this._SIDE_DATA) this._SIDE_DATA = await Vetools.pGeBackgroundSideData();
		return this._SIDE_DATA;
	}

	static getBackgroundStub () {
		return MiscUtil.copy(DataConverterBackground.STUB_BACKGROUND);
	}
}

DataConverterBackground.STUB_BACKGROUND = {
	name: "Unknown Background",
	source: Parser.SRC_PHB,
	_isStub: true,
};

var DataConverterBackground$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DataConverterBackground: DataConverterBackground
});

class Charactermancer_Background_Characteristics extends BaseComponent {
		static async pGetUserInput ({entries} = {}) {
		if (!entries || !entries.length) return {isFormComplete: true, data: {}};

		const comp = new this({entries});
		return UtilApplications.pGetImportCompApplicationFormData({
			comp,
			width: Util.getMaxWindowWidth(640),
			height: Util.getMaxWindowHeight(),
		});
	}

	static async pFillActorCharacteristicsData (entries, actUpdate, opts) {
		if (!entries || !entries.length) return;

		const formData = await this.pGetUserInput({entries});
		if (!formData) return opts.isCancelled = true;
		if (formData === VeCt.SYM_UI_SKIP) return;

		this.applyFormDataToActorUpdate(actUpdate, formData);
	}

	static applyFormDataToActorUpdate (actUpdate, formData) {
		MiscUtil.getOrSet(actUpdate, "system", "details", {});
		Charactermancer_Background_Characteristics._PROP_METAS.forEach(propMeta => {
			const propDetails = Charactermancer_Background_Characteristics._PROP_TO_ACTOR_DETAILS_PROP[propMeta.prop];
			actUpdate.system.details[propDetails] = [
				(actUpdate.system.details[propDetails] || "").trim(),
				...[...new Array(propMeta.count || 1)]
					.map((_, i) => {
						const {propValue} = this._getProps(propMeta.prop, i);
						if (!formData.data[propValue]) return null;
						return formData.data[propValue];
					}),
			]
				.filter(Boolean)
				.join("\n\n");
		});
	}

	static applyExistingActorDataToActorUpdate (actUpdate, actor) {
		const tgt = MiscUtil.getOrSet(actUpdate, "system", "details", {});

		Object.keys(Charactermancer_Background_Characteristics._PROP_TO_ACTOR_DETAILS_PROP)
			.forEach(propDetails => {
				tgt[propDetails] = MiscUtil.get(actor, "system", "details", propDetails);
			});
	}
	
		constructor (opts) {
		opts = opts || {};
		super();
		this._tables = Charactermancer_Background_Characteristics._getCharacteristicTables(opts.entries);
		this._$wrpHeaderControls = opts.$wrpHeaderControls;

				Object.assign(
			this.__state,
			Charactermancer_Background_Characteristics._PROP_METAS
				.mergeMap(propMeta => ({[Charactermancer_Background_Characteristics._getProps(propMeta.prop).propMode]: this._tables[propMeta.prop] != null ? "standard" : "custom"})),
		);
	}

	static _getProps (prop, ix) {
		return {
			propValue: `${prop}_${ix}_value`,
			propMode: `${prop}_mode`,
		};
	}

	static _getCpyTableCell (tbl, ixRow) {
		const cell = tbl.rows[ixRow]?.[1];
		if (!cell) {
			ui.notifications.error(`No cell found for row ${ixRow}!`);
			return null;
		}
		return Renderer.stripTags(MiscUtil.copy(cell));
	}

	get modalTitle () { return `Characteristics`; }

	render ($wrp) {
		const $wrpsProp = Charactermancer_Background_Characteristics._PROP_METAS.map((propMeta, ixPt) => {
			const count = propMeta.count || 1;
			const {propMode} = this.constructor._getProps(propMeta.prop);

			let $stgToggleMode;
			let $stgStandard;
			if (this._tables[propMeta.prop]) {
				const $btnToggleMode = $(`<button class="btn btn-default btn-xs" title="Show/Hide Table">View Table</button>`)
					.click(() => this._state[propMode] = this._state[propMode] === "custom" ? "standard" : "custom");

				$stgToggleMode = $$`<div class="ve-flex-v-center">
					${$btnToggleMode}
				</div>`;

				const tbl = this._tables[propMeta.prop];

				const $rendered = Vetools.withCustomDiceRenderingPatch(
					() => {
						const $rendered = $(`${Renderer.get().render(tbl)}`);
						$rendered.find(`[data-plut-temp-dice]`).each((i, e) => {
							const $e = $(e);

							const $btnsRoller = [...new Array(count)].map((_, i) => {
								return $(`<button class="btn btn-xs btn-default">Roll${count > 1 ? ` ${Parser.getOrdinalForm(i + 1)}` : ""}</button>`)
									.click(async () => {
										const {propValue} = this.constructor._getProps(propMeta.prop, i);
										const headerRowMetas = Renderer.table.getHeaderRowMetas(tbl);

										let roll;
										try {
											roll = new Roll(Renderer.stripTags(headerRowMetas.last()[0]));
											await roll.evaluate({async: true});
											roll.toMessage({sound: null});
										} catch (e) {
											return ui.notifications.error(`Failed to roll dice! ${VeCt.STR_SEE_CONSOLE}`);
										}

										const cell = tbl.rows[roll.total - 1]?.[1];
										if (!cell) return ui.notifications.error(`No result found for roll of ${roll.total}!`);

										this._state[propValue] = Renderer.stripTags(MiscUtil.copy(cell));
									});
							});

							const $wrpBtnsRoller = $$`<div class="ve-flex-vh-center btn-group">${$btnsRoller}</div>`;

							$e.replaceWith($wrpBtnsRoller);
						});

						$rendered.find(`[data-roll-min]`).each((i, e) => {
							const $e = $(e);
							const html = $e.html();
							$(`<div class="render-roller">${html}</div>`)
								.click(evt => {
									const {propValue} = this.constructor._getProps(propMeta.prop, evt.ctrlKey ? 1 : 0);
									this._state[propValue] = this.constructor._getCpyTableCell(tbl, i);
								})
								.title(count > 1 ? `Left-click to set the first field; CTRL-click to set the second field.` : null)
								.appendTo($e.empty());
						});

						return $rendered;
					},
					() => {
												return `<span data-plut-temp-dice="true"></span>`;
					},
				);

				$stgStandard = $$`<div class="ve-flex-col w-100 ve-small">
					${$rendered}
				</div>`;

				const hkMode = () => {
					$btnToggleMode.toggleClass("active", this._state[propMode] === "standard");
					$stgStandard.toggleVe(this._state[propMode] === "standard");
				};
				this._addHookBase(propMode, hkMode);
				hkMode();
			}

			const $iptsText = [...new Array(count)]
				.map((_, i) => ComponentUiUtil.$getIptEntries(this, this.constructor._getProps(propMeta.prop, i).propValue).addClass("resize-vertical"));

						if (count !== 1) {
				const iptsText = $iptsText.map(it => it[0]);
				const resizeObserver = new ResizeObserver(entries => {
					if (entries.length !== 1) return; 					const eleResized = entries[0].target;
					iptsText.filter(ipt => ipt !== eleResized).forEach(ipt => ipt.style.height = eleResized.style.height);
				});
				iptsText.forEach(ipt => resizeObserver.observe(ipt));
			}

			return $$`<div class="ve-flex-col ${ixPt < Charactermancer_Background_Characteristics._PROP_METAS.length - 1 ? `mb-2` : ""}">
				<div class="split-v-center mb-1">
					<div>${Charactermancer_Background_Characteristics._PROP_TO_FULL[propMeta.prop]}:</div>
					${$stgToggleMode}
				</div>

				${$stgStandard}

				<div class="ve-flex">${$iptsText}</div>
			</div>`;
		});

		const hasAnyTable = !!Object.keys(this._tables).length;
		let $btnToggleAllTables;
		if (hasAnyTable) {
			$btnToggleAllTables = $(`<button class="btn btn-default btn-xs">Hide Tables</button>`)
				.click(() => {
					const isDoHide = $btnToggleAllTables.text() === "Hide Tables";

					this._proxyAssignSimple(
						"state",
						Charactermancer_Background_Characteristics._PROP_METAS
							.mergeMap(propMeta => ({[Charactermancer_Background_Characteristics._getProps(propMeta.prop).propMode]: this._tables[propMeta.prop] != null && !isDoHide ? "standard" : "custom"})),
					);

					$btnToggleAllTables.text(isDoHide ? "Show Tables" : "Hide Tables");
				});

						const hkAllHidden = () => {
				const allModes = Charactermancer_Background_Characteristics._PROP_METAS
					.filter(propMeta => this._tables[propMeta.prop])
					.map(propMeta => this._state[Charactermancer_Background_Characteristics._getProps(propMeta.prop).propMode] === "custom");

				if (allModes.every(Boolean)) $btnToggleAllTables.text("Show Tables");
				else if (allModes.every(it => !it)) $btnToggleAllTables.text("Hide Tables");
			};
			Charactermancer_Background_Characteristics._PROP_METAS
				.map(propMeta => Charactermancer_Background_Characteristics._getProps(propMeta.prop).propMode)
				.forEach(propMode => this._addHookBase(propMode, hkAllHidden));
			hkAllHidden();
					}

		let $stgHeaderControls;
		if (!this._$wrpHeaderControls && hasAnyTable) {
			$stgHeaderControls = $$`<div class="mb-2 ve-flex-h-right">${$btnToggleAllTables}</div>`;
		} else if (this._$wrpHeaderControls && hasAnyTable) {
			this._$wrpHeaderControls.append($btnToggleAllTables);
		}

		$$($wrp)`
			${$stgHeaderControls}
			${$wrpsProp}
		`;
	}

	pGetFormData () {
		const rendered = Charactermancer_Background_Characteristics._PROP_METAS
			.map(propMeta => [...new Array(propMeta.count || 1)].map((_, i) => this.constructor._getProps(propMeta.prop, i).propValue))
			.flat()
			.mergeMap(propValue => ({[propValue]: UiUtil.getEntriesAsText(this._state[propValue])}));

		return {
			isFormComplete: Object.values(rendered).every(txt => txt.trim()),
			data: rendered,
		};
	}

	_getDefaultState () {
		return Charactermancer_Background_Characteristics._PROP_METAS
			.map(propMeta => [...new Array(propMeta.count || 1)].map((_, i) => this.constructor._getProps(propMeta.prop, i).propValue))
			.flat()
			.mergeMap(propValue => ({[propValue]: ""}));
	}

	static _getCharacteristicTables (entries) {
		if (!entries) return {};

		const out = {};

				UtilDataConverter.WALKER_READONLY_GENERIC.walk(
			entries,
			{
				object: (obj) => {
					if (obj.type !== "table") return;

					const headerRowMetas = Renderer.table.getHeaderRowMetas(obj);
					if (
						headerRowMetas?.last()?.length !== 2
						|| Renderer.table.getAutoConvertedRollMode(obj) !== RollerUtil.ROLL_COL_STANDARD
					) return;

					const captionFlat = headerRowMetas.last()[1].toLowerCase().replace(/\s+/g, "");
					const mCaption = /^(personalitytrait|ideal|bond|flaw)s?$/i.exec(captionFlat);
					if (!mCaption) return;

					out[captionFlat] = MiscUtil.copy(obj);
				},
			},
		);

		return out;
	}
}
Charactermancer_Background_Characteristics._PROP_METAS = [
	{prop: "personalitytrait", count: 2},
	{prop: "ideal"},
	{prop: "bond"},
	{prop: "flaw"},
];
Charactermancer_Background_Characteristics._PROP_TO_FULL = {
	"personalitytrait": "Personality Traits",
	"ideal": "Ideal",
	"bond": "Bond",
	"flaw": "Flaw",
};
Charactermancer_Background_Characteristics._PROP_TO_ACTOR_DETAILS_PROP = {
	"personalitytrait": "trait",
	"ideal": "ideal",
	"bond": "bond",
	"flaw": "flaw",
};

class Charactermancer_Background_Features extends BaseComponent {
	static async pGetUserInput ({background, modalFilter, ...opts} = {}) {
		const comp = new this({background, modalFilter});
		return UtilApplications.pGetImportCompApplicationFormData({
			comp,
			width: Util.getMaxWindowWidth(640),
			height: Util.getMaxWindowHeight(480),
			...opts,
		});
	}

		constructor (opts) {
		opts = opts || {};
		super();

		this._background = opts.background;

		this._modalFilter = opts.modalFilter;
	}

	static getFeatureEntries (bg) {
		return (bg?.entries || [])
			.filter(it => it.data?.isFeature)
			.map(ent => {
								const cpyEnt = MiscUtil.copy(ent);
				if (cpyEnt.name) cpyEnt.name = cpyEnt.name.replace(/^.*?:\s*/, "");
				cpyEnt.source = cpyEnt.source || bg.source;
				cpyEnt.backgroundName = bg.name;
				cpyEnt.backgroundSource = bg.source;
				cpyEnt.srd = !!bg.srd;
				cpyEnt.basicRules = !!bg.basicRules;
				cpyEnt.page = bg.page;
				cpyEnt.__prop = "backgroundFeature";
				return cpyEnt;
			});
	}

	get modalTitle () { return `Customize Background: Features`; }

	get mode () { return this._state.mode; }

	get ixBackgroundOther () { return this._state.ixBackgroundOther; }

	addHookPulseFeatures (hk) { this._addHookBase("pulseFeatures", hk); }

	render ($wrp) {
		const $selMode = ComponentUiUtil.$getSelEnum(
			this,
			"mode",
			{
				values: [
					Charactermancer_Background_Features._MODE_DEFAULT,
					Charactermancer_Background_Features._MODE_OTHER_BACKGROUND,
					Charactermancer_Background_Features._MODE_MANUAL,
				],
				fnDisplay: v => Charactermancer_Background_Features._MODE_TO_FULL[v],
			},
		);
		this._addHookBase("mode", () => this._state.pulseFeatures = !this._state.pulseFeatures);

		const $btnAddManual = $(`<button class="btn btn-xs btn-5et ml-1"><span class="glyphicon glyphicon-plus"></span> Add Feature</button>`)
			.click(() => {
				const nxt = this._getDefaultState_manualEntryMeta();
				this._state.manualEntryMetas = [...this._state.manualEntryMetas, nxt];
			});
		const hkMode = () => $btnAddManual.toggleVe(this._state.mode === Charactermancer_Background_Features._MODE_MANUAL);
		this._addHookBase("mode", hkMode);
		hkMode();

		const $stgDefault = this._render_default();
		const $stgOther = this._render_other();
		const $stgManual = this._render_manual();

		$$($wrp)`
			<div class="ve-flex-v-center mb-1">
				${$selMode}
				${$btnAddManual}
			</div>
			${$stgDefault}
			${$stgOther}
			${$stgManual}
		`;
	}

	_render_default () {
		const $stg = $$`<div class="ve-flex-col mt-1">
			<div class="w-100">${Vetools.withUnpatchedDiceRendering(() => Renderer.get().render({type: "entries", entries: this.constructor.getFeatureEntries(this._background)}))}</div>
		</div>`;

		const hkMode = () => $stg.toggleVe(this._state.mode === Charactermancer_Background_Features._MODE_DEFAULT);
		this._addHookBase("mode", hkMode);
		hkMode();

		return $stg;
	}

	_getOtherBackground () { return this._modalFilter.allData[this._state.ixBackgroundOther]; }

	_render_other () {
		const $btnSelect = $(`<button class="btn btn-default btn-5et w-100 mr-2 mb-2">Choose Background</button>`)
			.click(async () => {
				const selecteds = await this._modalFilter.pGetUserSelection();
				if (selecteds == null || !selecteds.length) return;

				this._state.ixBackgroundOther = selecteds[0]?.ix;
			});

		const $dispOther = $(`<div class="w-100"></div>`);
		const hkOther = () => {
			const otherBackground = this._getOtherBackground();
			if (!otherBackground) {
				$dispOther.html(`<i class="ve-muted">Select an alternate background, whose feature(s) will replace your current background's feature(s).</i>`);
				return;
			}

			const otherBackgroundFeatureEntries = this.constructor.getFeatureEntries(otherBackground);
			$dispOther.html(Vetools.withUnpatchedDiceRendering(() => Renderer.get().render(otherBackgroundFeatureEntries?.length ? {type: "entries", entries: otherBackgroundFeatureEntries} : {type: "entries", entries: ["{@note (No feature(s)).}"]})));
			this._state.pulseFeatures = !this._state.pulseFeatures;
		};
		this._addHookBase("ixBackgroundOther", hkOther);
		hkOther();

		const $stg = $$`<div class="ve-flex-col mt-1">
			${$btnSelect}
			${$dispOther}
		</div>`;

		const hkMode = () => $stg.toggleVe(this._state.mode === Charactermancer_Background_Features._MODE_OTHER_BACKGROUND);
		this._addHookBase("mode", hkMode);
		hkMode();

		return $stg;
	}

	_render_manual () {
		const $dispNoRows = $(`<div class="italic text-center ve-muted my-1">No features.</div>`);
		const $wrpRows = $(`<div class="ve-flex-col"></div>`);

		const hkManualMetas = () => {
			this._renderCollection({
				prop: "manualEntryMetas",
				fnDeleteExisting: () => {
					this._state.pulseFeatures = !this._state.pulseFeatures;
				},
				fnUpdateExisting: (renderedMeta, featureMeta) => {
					renderedMeta.comp._proxyAssignSimple("state", featureMeta.data, true);
					this._state.pulseFeatures = !this._state.pulseFeatures;
				},
				fnGetNew: featureMeta => {
					const comp = BaseComponent.fromObject(featureMeta.data, "*");
					comp._addHookAll("state", () => {
						featureMeta.data = comp.toObject("*");
						this._triggerCollectionUpdate("manualEntryMetas");
					});

					const $iptName = ComponentUiUtil.$getIptStr(comp, "name");

					const $iptText = ComponentUiUtil.$getIptEntries(comp, "entries");

					const $btnDelete = $(`<button class="btn btn-5et btn-xs btn-danger ml-1" title="Delete"><span class="glyphicon glyphicon-trash"></span></button>`)
						.click(() => this._state.manualEntryMetas = this._state.manualEntryMetas.filter(it => it !== featureMeta));

					const $wrpRow = $$`<div class="ve-flex-col py-1 w-100 stripe-even">
						<div class="split-v-center mb-1">
							<label class="ve-flex-v-center w-100"><div class="mr-1 text-right pr-1 no-shrink w-50p">Name</div>${$iptName}</label>
							${$btnDelete}
						</div>
						<label class="ve-flex-v-center w-100"><div class="mr-1 text-right pr-1 no-shrink w-50p">Text</div>${$iptText}</label>
					</div>`.appendTo($wrpRows);

					return {
						comp,
						$wrpRow,
					};
				},
			});

			$dispNoRows.toggleVe(!this._state.manualEntryMetas?.length);
		};
		hkManualMetas();
		this._addHookBase("manualEntryMetas", hkManualMetas);

		const $stg = $$`<div class="ve-flex-col">
			<hr class="hr-1">
			${$dispNoRows}
			${$wrpRows}
		</div>`;

		const hkMode = () => $stg.toggleVe(this._state.mode === Charactermancer_Background_Features._MODE_MANUAL);
		this._addHookBase("mode", hkMode);
		hkMode();

		return $stg;
	}

	getFormData () {
		let isComplete = true;
		const entries = [];
		const background = MiscUtil.copy(this._background);

		const fromFeature = Object.entries(background.fromFeature || {}).filter(([, v]) => v).map(([k]) => k);

		switch (this._state.mode) {
			case Charactermancer_Background_Features._MODE_DEFAULT: {
				entries.push(...this.constructor.getFeatureEntries(this._background));
				break;
			}
			case Charactermancer_Background_Features._MODE_OTHER_BACKGROUND: {
				const otherBackground = this._getOtherBackground();

				if (!otherBackground) {
					isComplete = false;
					fromFeature.forEach(k => delete background[k]);
					break;
				}

				entries.push(...this.constructor.getFeatureEntries(otherBackground));

				this._getFormData_doMergeOtherBackground({background, otherBackground, fromFeature});

				break;
			}
			case Charactermancer_Background_Features._MODE_MANUAL: {
				const ents = this._state.manualEntryMetas
					.filter(({data}) => data.entries && data.entries.length)
					.map(({data}) => {
						data = MiscUtil.copy(data);
						data.name = data.name || "(Unnamed Feature)"; 						data.type = "entries";
						return data;
					});

				if (!ents.length) isComplete = false;

				entries.push(...ents);

				fromFeature.forEach(k => delete background[k]);

				break;
			}
		}

		return {
			isFormComplete: isComplete,
			data: {
				entries,
				isCustomize: this._state.mode !== Charactermancer_Background_Features._MODE_DEFAULT,
				background,
			},
		};
	}

	_getFormData_doMergeOtherBackground ({background, otherBackground, fromFeature}) {
		fromFeature.forEach(k => {
			if (!otherBackground[k]) return delete background[k];
			background[k] = MiscUtil.copy(otherBackground[k]);
		});

		const fromFeatureOtherBackground = Object.entries(otherBackground.fromFeature || {}).filter(([, v]) => v).map(([k]) => k);
		fromFeatureOtherBackground.forEach(prop => {
			if (!otherBackground[prop]) return; 
			if (!background[prop]) {
				background[prop] = MiscUtil.copy(otherBackground[prop], {isSafe: true});
				return;
			}

						switch (prop) {
				default: {
					const typeA = typeof background[prop];
					const typeB = typeof otherBackground[prop];

										if (
						typeA !== typeB
						|| (typeA === "object" && (Array.isArray(background[prop]) !== Array.isArray(otherBackground[prop])))
					) {
						return;
					}

										if (typeA !== "object") return;

										if (Array.isArray(background[prop])) {
						this._getFormData_doMergeOtherBackground_array({background, otherBackground, prop});
						return;
					}

										this._getFormData_doMergeOtherBackground_object({background, otherBackground, prop});
				}
			}
		});
	}

	_getFormData_doMergeOtherBackground_array ({background, otherBackground, prop}) {
		switch (prop) {
			case "additionalSpells": {
								if (background[prop].length !== 1 || background[prop].length !== otherBackground[prop].length) return;

				Object.entries(otherBackground[prop][0])
					.forEach(([addSpellK, addSpellV]) => {
						if (!["innate", "known", "prepared", "expanded"].includes(addSpellK)) {
							console.warn(...LGT, `Could not merge additionalSpell property "${addSpellK}"--no merge strategy defined!`);
							return;
						}

						if (!background[prop][0][addSpellK]) background[prop][0][addSpellK] = {};

						Object.entries(addSpellV)
							.forEach(([kLevel, spellList]) => {
								background[prop][0][addSpellK][kLevel] = background[prop][0][addSpellK][kLevel] || [];
								background[prop][0][addSpellK][kLevel].push(...spellList);
							});
					});

				break;
			}

			case "feats": {
								if (background[prop].length !== 1 || background[prop].length !== otherBackground[prop].length) return;

				const out = {};
								Object.entries(background[prop][0])
					.forEach(([k, v]) => out[k] = (out[k] || 0) + Number(v));
				Object.entries(otherBackground[prop][0])
					.forEach(([k, v]) => out[k] = (out[k] || 0) + Number(v));
				background[prop][0] = out;

				break;
			}

			default: {
				background[prop] = [...background[prop], ...otherBackground[prop]].unique();
			}
		}
	}

	_getFormData_doMergeOtherBackground_object ({background, otherBackground, prop}) {
		switch (prop) {
			default: Object.assign(background[prop], otherBackground[prop]);
		}
	}

	pGetFormData () { return this.getFormData(); }

	_getDefaultState_manualEntryMeta () {
		return {
			id: CryptUtil.uid(),
			data: {
				name: "",
				entries: [],
			},
		};
	}

	_getDefaultState () {
		return {
			mode: Charactermancer_Background_Features._MODE_DEFAULT,

			ixBackgroundOther: null,

			manualEntryMetas: [this._getDefaultState_manualEntryMeta()],

			pulseFeatures: false,
		};
	}
}
Charactermancer_Background_Features._MODE_DEFAULT = 0;
Charactermancer_Background_Features._MODE_OTHER_BACKGROUND = 1;
Charactermancer_Background_Features._MODE_MANUAL = 2;

Charactermancer_Background_Features._MODE_TO_FULL = {
	[Charactermancer_Background_Features._MODE_DEFAULT]: "Add Features from This Background",
	[Charactermancer_Background_Features._MODE_OTHER_BACKGROUND]: "Customize your Background: Add Feature(s) from Another Background",
	[Charactermancer_Background_Features._MODE_MANUAL]: "Customize your Background: Add Custom Feature(s)",
};

class DataConverterBackgroundFeature extends DataConverterFeature {
	static _SIDE_LOAD_OPTS = {
		propBrew: "foundryBackgroundFeature",
		fnLoadJson: async () => this._pGetPreloadSideData(),
		propJson: "backgroundFeature",
		propsMatch: ["backgroundSource", "backgroundName", "source", "name"],
	};

	static _IMG_FALLBACK = `modules/${SharedConsts.MODULE_ID}/media/icon/farmer.svg`;

	static async pGetInitFeatureLoadeds (feature, {actor = null} = {}) {
		const hash = UrlUtil.URL_TO_HASH_BUILDER["backgroundFeature"](feature);
		return {
			hash,
			loadeds: [
				{
					hash,
					page: "backgroundFeature",
					source: feature.source,
					entity: feature,
					type: "backgroundFeature",
				},
			],
			name: feature.name,
			backgroundFeature: `${feature.name}|${feature.backgroundName}|${feature.backgroundSource}|${feature.source}`,
			source: feature.source,
		};
	}

		static async pGetDocumentJson (featureEntry, opts) {
		opts = opts || {};
		Renderer.get().resetHeaderIndex();

		const img = await this._pGetCompendiumFeatureImage(featureEntry, opts);

		const effectsSideTuples = await this._pGetEffectsSideLoadedTuples({ent: featureEntry, img, actor: opts.actor});
		effectsSideTuples.forEach(({effect, effectRaw}) => DataConverter.mutEffectDisabledTransfer(effect, "importBackground", UtilActiveEffects.getDisabledTransferHintsSideData(effectRaw)));

		return DataConverter.pGetItemActorPassive(
			featureEntry,
			{
				mode: "player",
				img,
				fvttType: "feat",
				source: featureEntry.source,
				actor: opts.actor,
				requirements: featureEntry.backgroundName,
				additionalData: await this._pGetDataSideLoaded(featureEntry),
				additionalFlags: await this._pGetFlagsSideLoaded(featureEntry),
				foundryFlags: {
					[SharedConsts.MODULE_ID]: {
						page: "backgroundFeature",
						source: featureEntry.source,
						hash: UrlUtil.URL_TO_HASH_BUILDER["backgroundFeature"](featureEntry),
					},
				},
				effects: DataConverter.getEffectsMutDedupeId(effectsSideTuples.map(it => it.effect)),
			},
		);
	}

	static async _pGetCompendiumFeatureImage (feature, {taskRunner = null} = {}) {
		const fromFeature = await UtilCompendium.pGetCompendiumImage("backgroundFeature", feature, {fnGetAliases: this._getCompendiumFeatureAliases.bind(this), deepKeys: ["system.requirements"], taskRunner});
		if (fromFeature) return fromFeature;

		return this._pGetSaveImagePath(
			{name: feature.backgroundName, source: feature.backgroundSource, srd: feature.srd},
			{propCompendium: "background", taskRunner},
		);
	}

	static _getCompendiumFeatureAliases (feature) {
		if (!feature.backgroundName || !feature.name) return [];

		const out = [];

		out.push({
			name: feature.name,
			"system.requirements": feature.backgroundName,
		});

		const nameNoPrefix = feature.name.replace(/^Feature:?\s*/i, "").trim();
		if (nameNoPrefix !== feature.name) {
			out.push({
				name: nameNoPrefix,
				"system.requirements": feature.backgroundName,
			});
		}

		return out;
	}

	static async _pGetPreloadSideData () {
		if (!this._SIDE_DATA) this._SIDE_DATA = await Vetools.pGeBackgroundSideData();
		return this._SIDE_DATA;
	}
}

var DataConverterBackgroundFeature$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DataConverterBackgroundFeature: DataConverterBackgroundFeature
});

class ImportListBackground extends ImportListCharacter {
		static init () {
		this._initCreateSheetItemHook({
			prop: "background",
			importerName: "Background",
		});
	}
	
	static get ID () { return "backgrounds"; }
	static get DISPLAY_NAME_TYPE_PLURAL () { return "Backgrounds"; }
	static get PROPS () { return ["background"]; }

	static _ = this.registerImpl(this);

	_dirsHomebrew = ["background"];
	_titleSearch = "background";
	_sidebarTab = "items";
	_gameProp = "items";
	_defaultFolderPath = ["Backgrounds"];
	_pageFilter = new PageFilterBackgrounds();
	_page = UrlUtil.PG_BACKGROUNDS;
	_isPreviewable = true;
	_isDedupable = true;
	_configGroup = "importBackground";
	_pFnGetFluff = Renderer.background.pGetFluff.bind(Renderer.background);
	_isActorRadio = true;
	static _DataConverter = DataConverterBackground;

	constructor (...args) {
		super(...args);

		this._modalFilterBackgrounds = null;
	}

	async _pGetSources () {
		return [
			new UtilDataSource.DataSourceUrl(
				Config.get("ui", "isStreamerMode") ? "SRD" : "5etools",
				Vetools.DATA_URL_BACKGROUNDS,
				{
					filterTypes: [UtilDataSource.SOURCE_TYP_OFFICIAL_ALL],
					isDefault: true,
				},
			),
			...UtilDataSource.getSourcesCustomUrl(),
			...UtilDataSource.getSourcesUploadFile(),
			...(await this._pGetSourcesPrerelease()),
			...(await this._pGetSourcesBrew()),
		];
	}

	_colWidthName = 4;
	_colWidthSource = 1;

	_getData_cols_other () {
		return [
			{
				name: "Skills",
				width: 6,
				field: "skills",
			},
		];
	}

	_getData_row_mutGetAdditionalValues ({it, ix}) {
		return {
			skills: it._skillDisplay,
		};
	}

	get _renderInner_absorbListItems_isRadio () { return !!this._actor; }

	_renderInner_absorbListItems_fnGetValues (it) {
		return {
			...super._renderInner_absorbListItems_fnGetValues(it),
			skills: it._skillDisplay,
			normalisedTime: it._normalisedTime,
			normalisedRange: it._normalisedRange,
		};
	}

	async pSetContent (val) {
		await super.pSetContent(val);

				this._modalFilterBackgrounds = new ModalFilterBackgroundsFvtt({
			namespace: "ImportListBackground.customFeatures",
			isRadio: true,
			allData: this._content.background,
		});
		await this._modalFilterBackgrounds.pPreloadHidden();
	}

	async _pImportEntry_pImportToActor (bg, importOpts) {
				const actUpdate = {system: {}};

		const dataBuilderOpts = new ImportListBackground.ImportEntryOpts({
			fluff: await Renderer.background.pGetFluff(bg),
		});

		await this._pImportEntry_pImportToActor_pLoadModalFilter({bg, dataBuilderOpts});
		if (dataBuilderOpts.isCancelled) return ImportSummary.cancelled();

		const formDataFeatures = bg._foundryFormDataFeatures ??
			await Charactermancer_Background_Features.pGetUserInput({
				background: bg,
				modalFilter: this._modalFilterBackgrounds,
				isUnskippable: true,
			});
		if (!formDataFeatures) return ImportSummary.cancelled();
		const {data: {background: bgCustomized}} = formDataFeatures;

		await this._pImportEntry_pFillProficiencies(bgCustomized, actUpdate.system, dataBuilderOpts);
		if (dataBuilderOpts.isCancelled) return ImportSummary.cancelled();
		await this._pImportEntry_pFillAbilities(bgCustomized, actUpdate, dataBuilderOpts);
		if (dataBuilderOpts.isCancelled) return ImportSummary.cancelled();
		await this._pImportEntry_pFillDetails(bgCustomized, actUpdate, dataBuilderOpts);
		if (dataBuilderOpts.isCancelled) return ImportSummary.cancelled();
		await this._pApplyAllAdditionalSpellsToActor({entity: bgCustomized, importOpts, dataBuilderOpts});
		if (dataBuilderOpts.isCancelled) return ImportSummary.cancelled();
		await this._pImportEntry_pFillItems(bgCustomized, actUpdate, formDataFeatures, importOpts, dataBuilderOpts);
		if (dataBuilderOpts.isCancelled) return ImportSummary.cancelled();

				const formDataEquipment = await this._pImportEntry_pImportToActor_pImportStartingEquipment(bg, dataBuilderOpts);
		if (dataBuilderOpts.isCancelled) return ImportSummary.cancelled();

				if (formDataEquipment?.data?.currency) MiscUtil.set(actUpdate, "system", "currency", formDataEquipment.data.currency);

				await UtilDocuments.pUpdateDocument(this._actor, actUpdate);

				await Charactermancer_StartingEquipment.pImportEquipmentItemEntries(this._actor, formDataEquipment, {taskRunner: importOpts.taskRunner});

				await this._pImportActorAdditionalFeats(bgCustomized, importOpts, dataBuilderOpts);
		if (dataBuilderOpts.isCancelled) return ImportSummary.cancelled();

		if (this._actor.isToken) this._actor.sheet.render();

		return new ImportSummary({
			status: ConstsTaskRunner.TASK_EXIT_COMPLETE,
			imported: [
				new ImportedDocument({
					name: bg.name,
					actor: this._actor,
				}),
			],
		});
	}

	async _pImportEntry_pImportToActor_pLoadModalFilter ({bg, dataBuilderOpts}) {
		if (this._modalFilterBackgrounds) return;
		if (bg._foundryFormDataFeatures) return;

						const importListBackgroundSources = await this.pGetSources();
		const appSourceSelector = new AppSourceSelectorMulti({
			title: `Select Background Sources for Customizing Features`,
			filterNamespace: `ImportListBackground_filter`,
			savedSelectionKey: `ImportListBackground_savedSelection`,
			sourcesToDisplay: importListBackgroundSources,
			props: this.constructor.PROPS,
			page: this._page,
			isDedupable: this._isDedupable,
		});

		const allData = await appSourceSelector.pWaitForUserInput();
		if (allData == null) return dataBuilderOpts.isCancelled = true;

		this._modalFilterBackgrounds = new ModalFilterBackgroundsFvtt({
			namespace: "ImportListBackground.customFeatures",
			isRadio: true,
			allData: allData.background,
		});
		await this._modalFilterBackgrounds.pPreloadHidden();
	}

	async _pImportEntry_pImportToActor_pImportStartingEquipment (bg, opts) {
		if (!bg.startingEquipment) return;

		const clsStyleData = {
			defaultData: bg.startingEquipment,
		};
		const startingEquipment = new Charactermancer_StartingEquipment({
			actor: this._actor,
			startingEquipment: clsStyleData,
			appSubTitle: bg.name,
			equiSpecialSource: bg.source,
			equiSpecialPage: bg.page,
		});
		const formData = await startingEquipment.pWaitForUserInput();
		if (formData == null) {
			opts.isCancelled = true;
			return null;
		}
		return formData;
	}

	async _pImportEntry_pFillProficiencies (bg, sys, dataBuilderOpts) {
		const isCustomizeSkills = !bg._foundryIsSkipCustomizeSkills && await InputUiUtil.pGetUserBoolean({
			title: `Customize Background: Skills`,
			htmlDescription: `<div class="w-640p">${Renderer.get().render(`Would you like to {@book customize your skill selection|phb|4|backgrounds|customizing a background}?<br>This allows you to choose any two skills to gain from your background, rather than gaining the defaults.`)}</div>`,
			textNo: "Use Default",
			textYes: "Customize",
		});
		dataBuilderOpts.isCustomize = dataBuilderOpts.isCustomize || !!isCustomizeSkills;

		if (isCustomizeSkills) {
			await DataConverter.pFillActorSkillData(
				MiscUtil.get(this._actor, "_source", "system", "skills"),
				UtilActors.BG_SKILL_PROFS_CUSTOMIZE,
				sys,
				dataBuilderOpts,
			);
		} else {
			await DataConverter.pFillActorSkillData(
				MiscUtil.get(this._actor, "_source", "system", "skills"),
				bg.skillProficiencies,
				sys,
				dataBuilderOpts,
			);
		}
		if (dataBuilderOpts.isCancelled) return;

		const isCustomizeLangsTools = !bg._foundryIsSkipCustomizeLanguagesTools && await InputUiUtil.pGetUserBoolean({
			title: `Customize Background: Languages & Tools`,
			htmlDescription: `<div class="w-640p">${Renderer.get().render(`Would you like to {@book customize your language and tool selection|phb|4|backgrounds|customizing a background}?<br>This allows you to choose a total of any two languages and/or tool proficiencies to gain from your background, rather than gaining the defaults.`)}</div>`,
			textNo: "Use Default",
			textYes: "Customize",
		});
		dataBuilderOpts.isCustomize = dataBuilderOpts.isCustomize || !!isCustomizeLangsTools;

		if (isCustomizeLangsTools) {
			await DataConverter.pFillActorLanguageOrToolData(
				MiscUtil.get(this._actor, "_source", "system", "traits", "languages"),
				MiscUtil.get(this._actor, "_source", "system", "tools"),
				UtilActors.LANG_TOOL_PROFS_CUSTOMIZE,
				sys,
				dataBuilderOpts,
			);
		} else {
			await DataConverter.pFillActorLanguageData(
				MiscUtil.get(this._actor, "_source", "system", "traits", "languages"),
				bg.languageProficiencies,
				sys,
				dataBuilderOpts,
			);
			if (dataBuilderOpts.isCancelled) return;

			dataBuilderOpts.isCancelled = await DataConverter.pFillActorToolProfData(
				MiscUtil.get(this._actor, "_source", "system", "tools"),
				bg.toolProficiencies,
				sys,
				dataBuilderOpts,
			);
			if (dataBuilderOpts.isCancelled) return;
		}

						await DataConverter.pFillActorArmorProfData(
			MiscUtil.get(this._actor, "_source", "system", "traits", "armorProf"),
			bg.armorProficiencies,
			sys,
			dataBuilderOpts,
		);
		if (dataBuilderOpts.isCancelled) return;

		await DataConverter.pFillActorWeaponProfData(
			MiscUtil.get(this._actor, "_source", "system", "traits", "weaponProf"),
			bg.weaponProficiencies,
			sys,
			dataBuilderOpts,
		);
		if (dataBuilderOpts.isCancelled) return;

		await DataConverter.pFillActorImmunityData(
			MiscUtil.get(this._actor, "_source", "system", "traits", "di"),
			bg.immune,
			sys,
			dataBuilderOpts,
		);
		if (dataBuilderOpts.isCancelled) return;

		await DataConverter.pFillActorResistanceData(
			MiscUtil.get(this._actor, "_source", "system", "traits", "dr"),
			bg.resist,
			sys,
			dataBuilderOpts,
		);
		if (dataBuilderOpts.isCancelled) return;

		await DataConverter.pFillActorVulnerabilityData(
			MiscUtil.get(this._actor, "_source", "system", "traits", "dv"),
			bg.vulnerable,
			sys,
			dataBuilderOpts,
		);
		if (dataBuilderOpts.isCancelled) return;

		await DataConverter.pFillActorConditionImmunityData(
			MiscUtil.get(this._actor, "_source", "system", "traits", "ci"),
			bg.conditionImmune,
			sys,
			dataBuilderOpts,
		);
		if (dataBuilderOpts.isCancelled) return;

		await DataConverter.pFillActorExpertiseData(
			{
				existingProficienciesSkills: MiscUtil.get(this._actor, "_source", "system", "skills"),
				existingProficienciesTools: MiscUtil.get(this._actor, "_source", "system", "tools"),
				expertise: bg.expertise,
				actorData: sys,
				importOpts: dataBuilderOpts,
			},
		);
			}

	async _pImportEntry_pFillAbilities (background, actUpdate, dataBuilderOpts) {
		await Charactermancer_AbilityScoreSelect.pFillActorAbilityData(this._actor, background.ability, actUpdate, dataBuilderOpts);
	}

	async _pImportEntry_pFillDetails (bg, actUpdate, opts) {
		if (bg._foundryIsSkipImportCharacteristics) return;

				Charactermancer_Background_Characteristics.applyExistingActorDataToActorUpdate(actUpdate, this._actor);

		if (bg._foundryFormDataCharacteristics) return Charactermancer_Background_Characteristics.applyFormDataToActorUpdate(actUpdate, bg._foundryFormDataCharacteristics);
		await Charactermancer_Background_Characteristics.pFillActorCharacteristicsData(bg.entries, actUpdate, opts);
	}

	async _pImportEntry_pFillItems (bg, data, formDataFeatures, importOpts, dataBuilderOpts) {
		await UtilDataConverter.pGetWithDescriptionPlugins(
			async () => {
				dataBuilderOpts.isCustomize = dataBuilderOpts.isCustomize || formDataFeatures.data?.isCustomize;

				dataBuilderOpts.items.push(
					await DataConverterBackground.pGetDocumentJson(
						bg,
						{
							actor: this._actor,
							fluff: dataBuilderOpts.fluff,
							taskRunner: importOpts.taskRunner,
						},
					),
				);

				for (const entry of formDataFeatures?.data?.entries || []) {
					dataBuilderOpts.items.push(await DataConverterBackgroundFeature.pGetDocumentJson(
						entry,
						{
							actor: this._actor,
							taskRunner: importOpts.taskRunner,
						},
					));
				}
			},
			{
				actorId: this._actor.id,
			},
		);

		if (dataBuilderOpts.isCancelled) return;

		const importedMetas = await UtilActors.pAddActorItems(this._actor, dataBuilderOpts.items);
		const [importedMetaBackground, ...importedMetasFeatures] = importedMetas;

		await UtilAdvancements.pAddAdvancementLinks({
			actor: this._actor,
			parentEmbeddedDocument: importedMetaBackground.document,
			childLevelledEmbeddedDocuments: importedMetasFeatures
				.map(importedMeta => new UtilAdvancements.LevelledEmbeddedDocument_MinLevel0({
					embeddedDocument: importedMeta.document,
				})),
		});
	}
}

ImportListBackground.ImportEntryOpts = class extends ImportListCharacter.ImportEntryOpts {
	constructor (opts) {
		opts = opts || {};
		super(opts);

		this.fluff = opts.fluff;
		this.isCustomize = false;
	}
};

var ImportListBackground$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ImportListBackground: ImportListBackground
});

class PageFilterBackgroundFeature extends PageFilter {
	constructor () {
		super();
		this._miscFilter = new Filter({
			header: "Miscellaneous",
			items: ["SRD", "Basic Rules"],
			isMiscFilter: true,
		});
	}

	static mutateForFilters (ent) {
		ent._fMisc = ent.srd ? ["SRD"] : [];
		if (ent.basicRules) ent._fMisc.push("Basic Rules");
	}

	addToFilters (it, isExcluded) {
		if (isExcluded) return;

		this._sourceFilter.addItem(it.source);
		this._miscFilter.addItem(it._fMisc);
	}

	async _pPopulateBoxOptions (opts) {
		opts.filters = [
			this._sourceFilter,
			this._miscFilter,
		];
	}

	toDisplay (values, it) {
		return this._filterBox.toDisplay(
			values,
			it.source,
			it._fMisc,
		);
	}
}

class ImportListBackgroundFeature extends ImportListFeature {
	static get ID () { return "background-features"; }
	static get DISPLAY_NAME_TYPE_PLURAL () { return "Background Features"; }
	static get PROPS () { return ["backgroundFeature"]; }

	static _ = this.registerImpl(this);

	_dirsHomebrew = ["background"];
	_titleSearch = "background feature";
	_sidebarTab = "items";
	_gameProp = "items";
	_defaultFolderPath = ["Background Features"];
	_pageFilter = new PageFilterBackgroundFeature();
	_page = "backgroundFeature";
	_isPreviewable = true;
	_isDedupable = true;
	_configGroup = "importBackgroundFeature";
	static _DataConverter = DataConverterBackgroundFeature;

	static async _pPostLoad_getFeaturesFromBackgrounds (data) {
		const out = {backgroundFeature: []};

		for (const bg of data.background || []) {
						const features = Charactermancer_Background_Features.getFeatureEntries(bg);
			out.backgroundFeature.push(...features);
		}

		return out;
	}

	async _pGetSources () {
		const argsShared = {pPostLoad: (data) => this.constructor._pPostLoad_getFeaturesFromBackgrounds(data)};
		return [
			new UtilDataSource.DataSourceUrl(
				Config.get("ui", "isStreamerMode") ? "SRD" : "5etools",
				Vetools.DATA_URL_BACKGROUNDS,
				{
					...argsShared,
					filterTypes: [UtilDataSource.SOURCE_TYP_OFFICIAL_ALL],
					isDefault: true,
				},
			),
			...UtilDataSource.getSourcesCustomUrl({...argsShared}),
			...UtilDataSource.getSourcesUploadFile({...argsShared}),
			...(await this._pGetSourcesPrerelease({...argsShared})),
			...(await this._pGetSourcesBrew({...argsShared})),
		];
	}

	_colWidthName = 5;
	_colWidthSource = 1;

	_getData_cols_other () {
		return [
			{
				name: "Background",
				width: 5,
				field: "backgroundName",
			},
		];
	}

	_getData_row_mutGetAdditionalValues ({it, ix}) {
		return {
			backgroundName: it.backgroundName,
		};
	}

	_renderInner_absorbListItems_fnGetValues (it) {
		return {
			...super._renderInner_absorbListItems_fnGetValues(it),
			backgroundName: it.backgroundName,
		};
	}
}

var ImportListBackgroundFeature$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ImportListBackgroundFeature: ImportListBackgroundFeature
});

class DataConverterVariantRule extends DataConverterJournal {
	static get _CONFIG_GROUP () { return "importRule"; }

		static async pGetDocumentJson (rule, opts) {
		opts = opts || {};

		Renderer.get().resetHeaderIndex();

		const cpy = MiscUtil.copy(rule);
		delete cpy.name;
		delete cpy.page;
		delete cpy.source;

		const content = await this._pGetWithJournalDescriptionPlugins(() => `<div>${Renderer.get().setFirstSection(true).render(cpy)}</div>`);

		const imgMeta = await this._pGetSaveImagePathMeta(rule, {taskRunner: opts.taskRunner});

		const name = UtilApplications.getCleanEntityName(UtilDataConverter.getNameWithSourcePart(rule));
		const out = {
			name,
			pages: this._getPages({name, content, img: imgMeta?.isFallback ? null : imgMeta?.img}),
			ownership: {default: 0},
			flags: {
				...this._getVariantRuleFlags(rule, opts),
			},
		};

		this._mutOwnership(out, opts);

		return out;
	}
	static _getVariantRuleFlags (rule) {
		return {
			[SharedConsts.MODULE_ID]: {
				page: UrlUtil.PG_VARIANTRULES,
				source: rule.source,
				hash: UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_VARIANTRULES](rule),
			},
		};
	}
}

var DataConverterVariantRule$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DataConverterVariantRule: DataConverterVariantRule
});

class ImportListJournal extends ImportList {
	_pImportEntry_pImportToActor (ent, importOpts) {
		throw new Error(`Cannot import journal content to actor!`);
	}
}

var ImportListJournal$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ImportListJournal: ImportListJournal
});

class ImportListVariantRule extends ImportListJournal {
	static get ID () { return "optional-and-variant-rules"; }
	static get DISPLAY_NAME_TYPE_PLURAL () { return "Optional & Variant Rules"; }
	static get PROPS () { return ["variantrule"]; }

	static _ = this.registerImpl(this);

	static get FOLDER_TYPE () { return "JournalEntry"; }

	_dirsHomebrew = ["variantrule"];
	_titleSearch = "variant or optional rule";
	_sidebarTab = "journal";
	_gameProp = "journal";
	_defaultFolderPath = ["Variant & Optional Rules"];
	_pageFilter = new PageFilterVariantRules();
	_page = UrlUtil.PG_VARIANTRULES;
	_isPreviewable = true;
	_isDedupable = true;
	_configGroup = "importRule";
	static _DataConverter = DataConverterVariantRule;

	async _pGetSources () {
		return [
			new UtilDataSource.DataSourceUrl(
				Config.get("ui", "isStreamerMode") ? "SRD" : "5etools",
				Vetools.DATA_URL_VARIANTRULES,
				{
					filterTypes: [UtilDataSource.SOURCE_TYP_OFFICIAL_ALL],
					isDefault: true,
				},
			),
			...UtilDataSource.getSourcesCustomUrl(),
			...UtilDataSource.getSourcesUploadFile(),
			...(await this._pGetSourcesPrerelease()),
			...(await this._pGetSourcesBrew()),
		];
	}
}

var ImportListVariantRule$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ImportListVariantRule: ImportListVariantRule
});

class DataConverterLanguage extends DataConverterJournal {
	static get _CONFIG_GROUP () { return "importLanguage"; }

		static async pGetDocumentJson (ent, opts) {
		opts = opts || {};

		Renderer.get().resetHeaderIndex();

		const content = await this._pGetWithJournalDescriptionPlugins(() => `<div>${Renderer.language.getRenderedString(ent, {isSkipNameRow: true})}</div>`);

		const fluff = await Renderer.utils.pGetFluff({
			entity: ent,
			fluffUrl: `data/fluff-languages.json`,
			fluffProp: "languageFluff",
		});

		const imgMeta = await this._pGetSaveImagePathMeta(ent, {fluff, taskRunner: opts.taskRunner});

		const name = UtilApplications.getCleanEntityName(UtilDataConverter.getNameWithSourcePart(ent));
		const out = {
			name,
			pages: this._getPages({name, content, img: imgMeta?.isFallback ? null : imgMeta?.img}),
			ownership: {default: 0},
			flags: {
				...this._getLanguageFlags(ent, opts),
			},
		};

		this._mutOwnership(out, opts);

		return out;
	}

	static _getLanguageFlags (ent) {
		return {
			[SharedConsts.MODULE_ID]: {
				page: UrlUtil.PG_LANGUAGES,
				source: ent.source,
				hash: UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_LANGUAGES](ent),
			},
		};
	}
}

var DataConverterLanguage$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DataConverterLanguage: DataConverterLanguage
});

class ImportListLanguage extends ImportListJournal {
	static get ID () { return "languages"; }
	static get DISPLAY_NAME_TYPE_PLURAL () { return "Languages"; }
	static get PROPS () { return ["language"]; }

	static _ = this.registerImpl(this);

	static get FOLDER_TYPE () { return "JournalEntry"; }

	_dirsHomebrew = ["language"];
	_titleSearch = "language";
	_sidebarTab = "journal";
	_gameProp = "journal";
	_defaultFolderPath = ["Languages"];
	_pageFilter = new PageFilterLanguages();
	_page = UrlUtil.PG_LANGUAGES;
	_isPreviewable = true;
	_isDedupable = true;
	_configGroup = "importLanguage";
	static _DataConverter = DataConverterLanguage;

	async _pGetSources () {
		return [
			new UtilDataSource.DataSourceUrl(
				Config.get("ui", "isStreamerMode") ? "SRD" : "5etools",
				Vetools.DATA_URL_LANGUAGES,
				{
					filterTypes: [UtilDataSource.SOURCE_TYP_OFFICIAL_ALL],
					isDefault: true,
				},
			),
			...UtilDataSource.getSourcesCustomUrl(),
			...UtilDataSource.getSourcesUploadFile(),
			...(await this._pGetSourcesPrerelease()),
			...(await this._pGetSourcesBrew()),
		];
	}

	_colWidthName = 5;

	_getData_cols_other () {
		return [
			{
				name: "Type",
				width: 2,
				field: "type",
				rowClassName: "text-center",
			},
			{
				name: "Script",
				width: 2,
				field: "script",
				rowClassName: "text-center",
			},
		];
	}

	_getData_row_mutGetAdditionalValues ({it, ix}) {
		it._lType = (it.type || "\u2014").uppercaseFirst();
		it._lScript = (it.script || "\u2014").toTitleCase();

		return {
			type: it._lType,
			script: it._lScript,
		};
	}

	_renderInner_absorbListItems_fnGetValues (it) {
		return {
			...super._renderInner_absorbListItems_fnGetValues(it),
			type: it._lType,
			script: it._lScript,
		};
	}
}

var ImportListLanguage$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ImportListLanguage: ImportListLanguage
});

class ImportListRollableTable extends ImportList {
	static get ID () { return "tables"; }
	static get DISPLAY_NAME_TYPE_PLURAL () { return "Tables"; }
	static get PROPS () { return ["table", "tableGroup"]; }

	static _ = this.registerImpl(this);

	static get FOLDER_TYPE () { return "RollTable"; }

	_dirsHomebrew = ["table"];
	_titleSearch = "table";
	_sidebarTab = "tables";
	_gameProp = "tables";
	_defaultFolderPath = ["Tables"];
	_pageFilter = new PageFilterTables();
	_page = UrlUtil.PG_TABLES;
	_isPreviewable = true;
	_isDedupable = true;
	_configGroup = "importTable";
	static _DataConverter = DataConverterTable;

	async _pGetSources () {
		return [
			new UtilDataSource.DataSourceSpecial(
				Config.get("ui", "isStreamerMode") ? "SRD" : "5etools",
				Vetools.pGetRollableTables.bind(Vetools),
				{
					cacheKey: "5etools-rollable-tables",
					filterTypes: [UtilDataSource.SOURCE_TYP_OFFICIAL_ALL],
					isDefault: true,
				},
			),
			...UtilDataSource.getSourcesCustomUrl(),
			...UtilDataSource.getSourcesUploadFile(),
			...(await this._pGetSourcesPrerelease()),
			...(await this._pGetSourcesBrew()),
		];
	}

	_renderInner_getListSyntax () {
		return new ListSyntaxTables({
			fnGetDataList: () => this._content,
		}).build();
	}

	getData () {
		return {
			...super.getData(),
			buttonsAdditional: [
				{
					name: "btn-run-journal-entries",
					text: "Import as Journal Entries",
				},
			],
		};
	}

	_renderInner_initRunButtonsAdditional () {
		super._renderInner_initRunButtonsAdditional();

		this._$btnsRunAdditional["btn-run-journal-entries"].click(() => {
			return this._pHandleClickRunButton({
				gameProp: "journal",
				sidebarTab: "journal",
				optsImportEntry: {
					isImportAsJournalEntry: true,
				},
			});
		});
	}

	_pImportEntry_getTablesFromGroup (tbl) {
		const tg = MiscUtil.copy(tbl);

		tg.tables.forEach((t, i) => {
			if (tg.name) t.name = t.name || `${tg.name}, Table ${i + 1}`;
			t.source = t.source || tg.source;
		});

		return tg.tables;
	}

	async _pImportTableGroup (tg, importOpts) {
		if (tg.__prop !== "tableGroup") return null;

		console.log(...LGT, `Importing table group "${tg.name || tg.caption}" (from "${Parser.sourceJsonToAbv(tg.source)}")`);

		const tables = this._pImportEntry_getTablesFromGroup(tg);
		const rollableTables = [];

		let cntSkipped = 0;
		for (const tbl of tables) {
			const importSummary = await this.pImportEntry(tbl, importOpts);
			if (importSummary.imported) rollableTables.push(...importSummary.imported.map(it => it.document).filter(Boolean));
			else if (importSummary.existing) cntSkipped++;
		}

		if (!rollableTables.length && cntSkipped) {
			return new ImportSummary({status: ConstsTaskRunner.TASK_EXIT_SKIPPED_DUPLICATE});
		}

		const journalData = DataConverterTable.getTableGroupJournal(
			tg,
			rollableTables,
			{
				isAddDefaultOwnershipFromConfig: importOpts.isAddDefaultOwnershipFromConfig ?? true,
				defaultOwnership: importOpts.defaultOwnership,
				userOwnership: importOpts.userOwnership,
			},
		);

				const isTemp = importOpts.isTemp || !!this._pack;

		if (isTemp) {
			const imported = await UtilDocuments.pCreateDocument(JournalEntry, journalData, {isTemporary: true});

			return new ImportSummary({
				status: ConstsTaskRunner.TASK_EXIT_COMPLETE,
				imported: [
					new ImportedDocument({
						document: imported,
					}),
				],
			});
		}

		return this._pImportEntry_pImportToDirectoryGeneric_toDirectory({
			duplicateMeta: this._getDuplicateMeta({name: journalData.name, gameProp: "journal", importOpts}),
			docData: journalData,
			toImport: tg,
			Clazz: JournalEntry,
			folderType: "JournalEntry",
			importOpts,
		});
	}

		async _pImportEntry (tbl, importOpts, dataOpts) {
		importOpts = importOpts || {};

		const importSummaryGroup = await this._pImportTableGroup(tbl, importOpts, dataOpts);
		if (importSummaryGroup != null) return importSummaryGroup;

		console.log(...LGT, `Importing table "${tbl.name || tbl.caption}" (from "${Parser.sourceJsonToAbv(tbl.source)}")`);

		if (this._actor) throw new Error(`Cannot import table to actor!`);

		if (importOpts.isImportAsJournalEntry) {
			const importListJournal = new ImportListRollableTableJournal();
			await importListJournal.pInit();
			const nxtImportOpts = MiscUtil.copy(importOpts);
			delete nxtImportOpts.isImportAsJournalEntry;
			return importListJournal._pImportEntry(tbl, nxtImportOpts, dataOpts);
		}

		return this._pImportEntry_pImportToDirectoryGeneric(tbl, importOpts, dataOpts);
	}
}

class ImportListRollableTableJournal extends ImportListRollableTable {
	static get FOLDER_TYPE () { return "JournalEntry"; }

	_sidebarTab = "journal";
	_gameProp = "journal";

		get _folderPathSpecKeyConstructorName () { return "ImportListRollableTable"; }

	_pImportEntry_pImportToDirectoryGeneric_pGetImportableData (it, getItemOpts, importOpts) {
		return super._pImportEntry_pImportToDirectoryGeneric_pGetImportableData(
			it,
			{
				isImportAsJournalEntry: true,
				...getItemOpts,
			},
			importOpts,
		);
	}
}

var ImportListRollableTable$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ImportListRollableTable: ImportListRollableTable
});

class DataConverterPsionic extends DataConverter {
	static _SIDE_LOAD_OPTS = {
		propBrew: "foundryPsionic",
		fnLoadJson: Vetools.pGetPsionicsSideData,
		propJson: "psionic",
	};

		static _SIDE_DATA_DISCIPLINE_FOCUS_OPTS = {
		propBrew: "foundryPsionicDisciplineFocus",
		fnLoadJson: Vetools.pGetPsionicsSideData,
		propJson: "psionicDisciplineFocus",
	};

	static _SIDE_DATA_DISCIPLINE_ACTIVE_OPTS = {
		propBrew: "foundryPsionicDisciplineActive",
		fnLoadJson: Vetools.pGetPsionicsSideData,
		propJson: "psionicDisciplineActive",
		propsMatch: ["psionicSource", "psionicName", "source", "name"],
	};
	
	static _IMG_FALLBACK = `modules/${SharedConsts.MODULE_ID}/media/icon/brain.svg`;

		static async pGetPsionicItems (psi, opts) {
		opts = opts || {};

		Renderer.get().resetHeaderIndex();

		return [
			await this._getPsionicItems_pGetTalentItem(psi, opts),
			await this._getPsionicItems_pGetDisciplineFocusItem(psi, opts),
			...(await this._getPsionicItems_pGetDisciplineActiveItems(psi, opts)),
		].filter(Boolean);
	}

	static _getPsionicFlags (psi, opts) {
		opts = opts || {};

		const out = {
			[SharedConsts.MODULE_ID]: {
				page: UrlUtil.PG_PSIONICS,
				source: psi.source,
				hash: UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_PSIONICS](psi),
			},
		};

		if (opts.isAddDataFlags) {
			out[SharedConsts.MODULE_ID].propDroppable = "psionic";
			out[SharedConsts.MODULE_ID].filterValues = opts.filterValues;
		}

		return out;
	}

	static async _getPsionicItems_pGetTalentItem (psi, opts) {
		if (psi.type !== "T") return null;

				const strEntries = JSON.stringify(psi.entries);

		let damageDice = "";
		let cantripScaling = null;
		const diceTiers = [];
				strEntries.replace(/\({@damage ([^}]+)}\)/g, (...m) => diceTiers.push(m[1]));
				const baseVal = /(?:^|[^(]){@dice ([^}]+)}(?:[^)]|$)/.exec(strEntries);
				if (diceTiers.length === 3) {
			if (baseVal) cantripScaling = baseVal[1];
						else cantripScaling = diceTiers[0];
		}
		if (baseVal) damageDice = baseVal[1];
		else if (diceTiers.length) damageDice = diceTiers[0];

		if (!Config.get("importPsionic", "isImportAsSpell")) {
						if (damageDice && cantripScaling) {
				damageDice = `${damageDice} + (max(sign(floor((@details.level + 1) / 6)), 0) * (${cantripScaling})) + (max(sign(floor((@details.level - 5) / 6)), 0) * (${cantripScaling})) + (max(sign(floor((@details.level - 11) / 6)), 0) * (${cantripScaling}))`;
			}
		}

		const damageType = this._getPsionicItems_getDamageTypeFromString(strEntries);
		const damage = damageDice ? [damageDice, damageType].filter(Boolean) : null;
		
		const img = await this._pGetImagePath(psi, {taskRunner: opts.taskRunner});

		const additionalData = await this._pGetDataSideLoaded(psi);
		const additionalFlags = await this._pGetFlagsSideLoaded(psi);

		const effectsSideTuples = await this._pGetEffectsSideLoadedTuples({ent: psi, img, actor: opts.actor});
		effectsSideTuples.forEach(({effect, effectRaw}) => DataConverter.mutEffectDisabledTransfer(effect, "importPsionic", UtilActiveEffects.getDisabledTransferHintsSideData(effectRaw)));

		const out = await DataConverter.pGetItemActorPassive(
			psi,
			{
				mode: "player",
				actor: opts.actor,
				img,
				additionalData,
				additionalFlags,
				effects: DataConverter.getEffectsMutDedupeId(effectsSideTuples.map(it => it.effect)),
				description: Config.get("importPsionic", "isImportDescription")
					? await UtilDataConverter.pGetWithDescriptionPlugins(() => `<div>${Renderer.psionic.getBodyText(psi, Renderer.get())}</div>`)
					: "",
				damageParts: [damage].filter(Boolean),
				formula: "", 				ability: "int",
				foundryFlags: this._getPsionicFlags(psi, opts),
			},
		);

		if (Config.get("importPsionic", "isImportAsSpell")) {
			out.type = "spell";

			Object.assign(
				out.system,
				{
					level: 0,
					school: "evo",
					components: {value: "", vocal: false, somatic: false, material: false, ritual: false, concentration: false},
					materials: {value: "", consumed: false, cost: 0, supply: 0},
					scaling: {
						mode: cantripScaling ? "cantrip" : "none",
						formula: cantripScaling || "",
					},
					preparation: {mode: "always", prepared: true},
				},
			);
		}

		return out;
	}

	static async _getPsionicItems_pGetDisciplineFocusItem (psi, opts) {
		if (psi.type !== "D") return null;

		const img = await this._pGetImagePath(psi, {taskRunner: opts.taskRunner});

		const additionalData = await this._pGetDataSideLoaded(psi, {propOpts: "_SIDE_DATA_DISCIPLINE_FOCUS_OPTS"});
		const additionalFlags = await this._pGetFlagsSideLoaded(psi, {propOpts: "_SIDE_DATA_DISCIPLINE_FOCUS_OPTS"});

		const effectsSideTuples = await this._pGetEffectsSideLoadedTuples({ent: psi, img, actor: opts.actor}, {propOpts: "_SIDE_DATA_DISCIPLINE_FOCUS_OPTS"});
		effectsSideTuples.forEach(({effect, effectRaw}) => DataConverter.mutEffectDisabledTransfer(effect, "importPsionic", UtilActiveEffects.getDisabledTransferHintsSideData(effectRaw)));

		const out = await DataConverter.pGetItemActorPassive(
			psi,
			{
				displayName: `${psi.name} - Focus`,
				actionType: "other",
				activationType: "bonus",
				activationCost: 1,
				activationCondition: "Only one focus may be active at a time",
				mode: "player",
				actor: opts.actor,
				img,
				additionalData,
				additionalFlags,
				effects: DataConverter.getEffectsMutDedupeId(effectsSideTuples.map(it => it.effect)),
				description: Config.get("importPsionic", "isImportDescription")
					? await UtilDataConverter.pGetWithDescriptionPlugins(() => `<div>${Renderer.get().setFirstSection(true).render({entries: [psi.focus]})}</div>`)
					: "",
				ability: "int",
				foundryFlags: this._getPsionicFlags(psi, opts),
			},
		);

		if (Config.get("importPsionic", "isImportAsSpell")) {
			out.type = "spell";

			Object.assign(
				out.system,
				{
					level: 0,
					school: "evo",
					components: {value: "", vocal: false, somatic: false, material: false, ritual: false, concentration: false},
					materials: {value: "", consumed: false, cost: 0, supply: 0},
					scaling: {mode: "none", formula: ""},
					preparation: {mode: "always", prepared: true},
				},
			);
		}

		return out;
	}

	static async _getPsionicItems_pGetDisciplineActiveItems (psi, opts) {
		if (psi.type === "T") return [];

		const out = [];
		for (const psiMode of psi.modes) {
			Renderer.psionic.enhanceMode(psiMode);

			const subFeature = await this._getPsionicItems_pGetDisciplineActiveItem(psi, psiMode, opts);
			out.push(subFeature);

			if (psiMode.submodes) {
				for (const psiSubMode of psiMode.submodes) {
					const subSubFeature = await this._getPsionicItems_pGetDisciplineActiveItem(
						psi,
						psiSubMode,
						opts,
						{
							parentModeName: psiMode.name,
							actionType: subFeature.system.actionType,
						},
					);
					out.push(subSubFeature);
				}
			}
		}

		return out;
	}

	static async _getPsionicItems_pGetDisciplineActiveItem (psi, psiMode, opts, {parentModeName, actionType} = {}) {
		const getCostPart = (it) => it.cost ? ` (${it.cost.min === it.cost.max ? it.cost.min : `${it.cost.min}-${it.cost.max}`}psi)` : "";

		const submodePart = psiMode.submodes
			? Renderer.get().setFirstSection(true).render(
				{
					type: "list",
					style: "list-hang-notitle",
					items: psiMode.submodes.map(it => ({
						type: "item",
						name: `${it.name}${getCostPart(it)}`,
						entry: it.entries.join("<br>"),
					})),
				},
				2)
			: "";
		const description = Config.get("importPsionic", "isImportDescription")
			? await UtilDataConverter.pGetWithDescriptionPlugins(() => `<div>
					${Renderer.get().setFirstSection(true).render({entries: psiMode.entries}, 2)}
					${submodePart}
				</div>`)
			: "";

				const strEntries = JSON.stringify(psiMode.entries);

		let scaling = null;
		const damageList = [];
				const damageType = this._getPsionicItems_getDamageTypeFromString(strEntries);
				strEntries.replace(/{@(?:scaledice|scaledamage) ([^}]+)}/, (...m) => {
			const [baseDamage, _, addPerProgress] = m[1].split("|");
			damageList.push(baseDamage);
			scaling = addPerProgress;
		});

				if (!damageList.length) {
			strEntries.replace(/{@damage ([^}]+)}/g, (...m) => damageList.push(m[1]));
		}

		const damageParts = damageList.map(dmg => [dmg, damageType].filter(Boolean));
		
		const level = psiMode.cost ? psiMode.cost.min : psiMode.submodes ? MiscUtil.get(psiMode.submodes.find(it => it.cost), "cost", "min") || 1 : 1;

		const durationValue = psiMode.concentration ? psiMode.concentration.duration : 0;
		const durationUnits = (psiMode.concentration ? DataConverterPsionic._PSI_DURATION_MAP[psiMode.concentration.unit] : "") || "";

		const {consumeType, consumeTarget, consumeAmount} = this._getPsionicItems_getConsume({psi, psiMode, opts, level});

		const displayName = `${psi.name} - ${parentModeName ? `${parentModeName}; ` : ""}${psiMode.name}`;
		const entFauxSideData = {name: psiMode.name, source: psi.source, psionicName: psi.name, psionicSource: psi.source};

		const img = await this._pGetImagePath(psi, {taskRunner: opts.taskRunner});

		const additionalData = await this._pGetDataSideLoaded(entFauxSideData, {propOpts: "_SIDE_DATA_DISCIPLINE_ACTIVE_OPTS"});
		const additionalFlags = await this._pGetFlagsSideLoaded(entFauxSideData, {propOpts: "_SIDE_DATA_DISCIPLINE_ACTIVE_OPTS"});

		const effectsSideTuples = await this._pGetEffectsSideLoadedTuples({ent: psi, img, actor: opts.actor}, {propOpts: "_SIDE_DATA_DISCIPLINE_ACTIVE_OPTS"});
		effectsSideTuples.forEach(({effect, effectRaw}) => DataConverter.mutEffectDisabledTransfer(effect, "importPsionic", UtilActiveEffects.getDisabledTransferHintsSideData(effectRaw)));

		const out = await DataConverter.pGetItemActorPassive(
			psiMode,
			{
				displayName,
				page: psi.page,
				source: psi.source,
				mode: "player",
				actor: opts.actor,
				img,
				additionalData,
				additionalFlags,
				effects: DataConverter.getEffectsMutDedupeId(effectsSideTuples.map(it => it.effect)),
				description,
				damageParts,
				formula: "", 				durationValue,
				durationUnits,
				consumeType,
				consumeTarget,
				consumeAmount,
				ability: "int",
				actionType: actionType === "other" ? undefined : actionType,
				foundryFlags: this._getPsionicFlags(psi, opts),
			},
		);

		if (Config.get("importPsionic", "isImportAsSpell")) {
			out.type = "spell";

			Object.assign(
				out.system,
				{
					level: level,
					school: "evo",
					components: {value: "", vocal: false, somatic: false, material: false, ritual: false, concentration: !!psiMode.concentration},
					materials: {value: "", consumed: false, cost: 0, supply: 0},
					scaling: {mode: scaling ? "level" : "none", formula: scaling || ""},
					critical: {threshold: null, damage: ""},
					preparation: {mode: "always", prepared: true},
				},
			);
		}

		return out;
	}

		static _getPsionicItems_getConsume ({opts, level}) {
		let consumeType = opts.consumeType ?? "";
		let consumeTarget = opts.consumeTarget ?? null;
		let consumeAmount = opts.consumeAmount ?? null;

		if (opts.consumeTarget != null) return {consumeType, consumeTarget, consumeAmount};

		const resource = Config.getPsiPointsResource({isValueKey: true});
		consumeAmount = level;

		if (resource === ConfigConsts.C_SPELL_POINTS_RESOURCE__SHEET_ITEM) {
			consumeType = "charges";
			consumeTarget = opts.psiPointsItemId;
		} else {
			consumeType = "attribute";
			consumeTarget = resource;
		}

		return {consumeType, consumeTarget, consumeAmount};
	}

	static _getPsionicItems_getDamageTypeFromString (strEntries) {
		const msDamageTypes = Parser.DMG_TYPES.map(typ => (new RegExp(`(${typ})[^.]+damage`, "ig")).exec(strEntries));
		const damageTypes = msDamageTypes.filter(Boolean).map(it => it[1].toLowerCase());
		return damageTypes[0] || null;
	}
	
			static async pGetDocumentJson (psi, opts) {
		opts = opts || {};

		Renderer.get().resetHeaderIndex();

		const typeOrderStr = Renderer.psionic.getTypeOrderString(psi);
		const desc = `<p><i>${typeOrderStr}</i></p>${Renderer.psionic.getBodyText(psi, Renderer.get().setFirstSection(true))}`;

		const img = await this._pGetSaveImagePath(psi, {taskRunner: opts.taskRunner});

		const additionalData = await this._pGetDataSideLoaded(psi);
		const additionalFlags = await this._pGetFlagsSideLoaded(psi);

		const effectsSideTuples = await this._pGetEffectsSideLoadedTuples({ent: psi, img, actor: opts.actor});
		effectsSideTuples.forEach(({effect, effectRaw}) => DataConverter.mutEffectDisabledTransfer(effect, "importPsionic", UtilActiveEffects.getDisabledTransferHintsSideData(effectRaw)));

		const out = {
			name: UtilApplications.getCleanEntityName(UtilDataConverter.getNameWithSourcePart(psi)),
			type: "feat",
			system: {
				description: {
					value: Config.get("importPsionic", "isImportDescription")
						? await UtilDataConverter.pGetWithDescriptionPlugins(() => `<div>${desc}</div>`)
						: "",
					chat: "",
					unidentified: "",
				},
				source: UtilDataConverter.getSourceWithPagePart(psi),

								damage: {parts: []},
				activation: {type: "", cost: 0, condition: ""},
				duration: {value: null, units: ""},
				target: {value: null, units: "", type: ""},
				range: {value: null, long: null, units: ""},
				uses: {value: 0, max: 0, per: null},
				ability: null,
				actionType: "",
				attackBonus: null,
				chatFlavor: "",
				critical: {threshold: null, damage: ""},
				formula: "",
				save: {ability: "", dc: null},
				requirements: "",
				recharge: {value: null, charged: false},
				
				...additionalData,
			},
			flags: {
				...this._getPsionicFlags(psi, opts),
				...additionalFlags,
			},
			effects: DataConverter.getEffectsMutDedupeId(effectsSideTuples.map(it => it.effect)),
			img,
			ownership: {default: 0},
		};

		if (opts.defaultOwnership != null) out.ownership = {default: opts.defaultOwnership};
		else if (opts.isAddDefaultOwnershipFromConfig) out.ownership = {default: Config.get("importPsionic", "ownership")};
		if (opts.userOwnership) Object.assign(out.ownership, opts.userOwnership);

		return out;
	}
}

DataConverterPsionic._PSI_DURATION_MAP = {
	"min": "minute",
	"hr": "hour",
	"rnd": "round",
};

var DataConverterPsionic$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DataConverterPsionic: DataConverterPsionic
});

class ImportListPsionic extends ImportList {
		static init () {
		this._initCreateSheetItemHook({
			prop: "psionic",
			importerName: "Psionic",
		});
	}
	
	static get ID () { return "psionics"; }
	static get DISPLAY_NAME_TYPE_PLURAL () { return "Psionics"; }
	static get PROPS () { return ["psionic"]; }

	static _ = this.registerImpl(this);

	_dirsHomebrew = ["psionic"];
	_titleSearch = "psionic";
	_sidebarTab = "items";
	_gameProp = "items";
	_defaultFolderPath = ["Psionics"];
	_pageFilter = new PageFilterPsionics();
	_page = UrlUtil.PG_PSIONICS;
	_isPreviewable = true;
	_isDedupable = true;
	_configGroup = "importPsionic";
	static _DataConverter = DataConverterPsionic;

	async _pGetSources () {
		return [
			new UtilDataSource.DataSourceUrl(
				Config.get("ui", "isStreamerMode") ? "SRD" : "5etools",
				Vetools.DATA_URL_PSIONICS,
				{
					filterTypes: [UtilDataSource.SOURCE_TYP_OFFICIAL_ALL],
					isDefault: true,
				},
			),
			...UtilDataSource.getSourcesCustomUrl(),
			...UtilDataSource.getSourcesUploadFile(),
			...(await this._pGetSourcesPrerelease()),
			...(await this._pGetSourcesBrew()),
		];
	}

	_renderInner_getListSyntax () {
		return new ListSyntaxPsionics({
			fnGetDataList: () => this._content,
		}).build();
	}

	_colWidthName = 4;
	_colWidthSource = 1;

	_getData_cols_other () {
		return [
			{
				name: "Type",
				width: 3,
				field: "type",
			},
			{
				name: "Order",
				width: 3,
				field: "order",
			},
		];
	}

	_getData_row_mutGetAdditionalValues ({it, ix}) {
		return {
			type: Parser.psiTypeToMeta(it.type).short,
			order: it._fOrder,
		};
	}

	_renderInner_absorbListItems_fnGetValues (it) {
		return {
			...super._renderInner_absorbListItems_fnGetValues(it),
			type: Parser.psiTypeToMeta(it.type).full,
			order: it._fOrder,
		};
	}

	async _pImportEntry_pImportToActor (psi, importOpts) {
		const psiPointsItemId = await this._pGetActorPsiPointsItemId();

		const allItems = await DataConverterPsionic.pGetPsionicItems(psi, {filterValues: importOpts.filterValues, psiPointsItemId, actor: this._actor, taskRunner: importOpts.taskRunner});
		await UtilActors.pAddActorItems(this._actor, allItems);
		if (this._actor.isToken) this._actor.sheet.render();

		return new ImportSummary({
			status: ConstsTaskRunner.TASK_EXIT_COMPLETE,
			imported: [
				new ImportedDocument({
					name: psi.name,
					actor: this._actor,
				}),
			],
		});
	}

	async _pGetActorPsiPointsItemId () {
		if (!this._actor) throw new Error(`Only applicable when importing to an actor!`);
		const psiPointsItem = await UtilActors.pGetCreateActorPsiPointsItem({actor: this._actor});
		return psiPointsItem?.id;
	}
}

var ImportListPsionic$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ImportListPsionic: ImportListPsionic
});

class DataConverterOptionalfeature extends DataConverterFeature {
	static _SIDE_LOAD_OPTS = {
		propBrew: "foundryOptionalfeature",
		fnLoadJson: async () => this._pGetPreloadSideData(),
		propJson: "optionalfeature",
	};

	static _IMG_FALLBACK = `modules/${SharedConsts.MODULE_ID}/media/icon/skills.svg`;

	static init () {
		PageFilterClassesFoundry.setImplSideData("optionalfeature", this);
	}

	static async pGetDereferencedFeatureItem (feature) {
				if (feature.entries) return MiscUtil.copy(feature);

		const hash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_OPT_FEATURES](feature);
		return DataLoader.pCacheAndGet(UrlUtil.PG_OPT_FEATURES, feature.source, hash, {isCopy: true});
	}

	static async pGetInitFeatureLoadeds (feature, {actor = null} = {}) {
		const uid = DataUtil.proxy.getUid("optionalfeature", feature, {isMaintainCase: true});
		const asFeatRef = {optionalfeature: uid};
						await PageFilterClassesFoundry.pInitOptionalFeatureLoadeds({optionalfeature: asFeatRef, raw: feature, actor});
		return asFeatRef;
	}

		static async pGetDocumentJson (optFeature, opts) {
		opts = opts || {};
		if (opts.actor) opts.isActorItem = true;

		Renderer.get().resetHeaderIndex();

		const cpyOptFeature = Charactermancer_Feature_Util.getCleanedFeature_tmpOptionalfeatureList(optFeature);

		let pOut;
		if (await this._pIsInSrd(cpyOptFeature, opts)) {
			pOut = this._pGetOptionalFeatureItem_fromSrd(cpyOptFeature, opts);
		} else {
			pOut = this._pGetOptionalFeatureItem_other(cpyOptFeature, opts);
		}
		return pOut;
	}

	static async _pIsInSrd (optFeature, {taskRunner = null} = {}) {
		const srdData = await UtilCompendium.getSrdCompendiumEntity("optionalfeature", optFeature, {fnGetAliases: this._getCompendiumAliases, taskRunner});
		return !!srdData;
	}

	static async _pGetOptionalFeatureItem_fromSrd (optFeature, opts = {}) {
		const srdData = await UtilCompendium.getSrdCompendiumEntity("optionalfeature", optFeature, {fnGetAliases: this._getCompendiumAliases, taskRunner: opts.taskRunner});

		const {name: translatedName, description: translatedDescription, flags: translatedFlags} = this._getTranslationMeta({
			translationData: this._getTranslationData({srdData}),
			name: UtilApplications.getCleanEntityName(UtilDataConverter.getNameWithSourcePart(optFeature, {isActorItem: opts.isActorItem})),
			description: await this._pGetDescriptionValue(optFeature),
		});

		const dataConsume = this._getData_getConsume({ent: optFeature, actor: opts.actor});

				const activationType = dataConsume?.type && !srdData.system?.activation?.type ? "special" : srdData.system?.activation?.type;

		const additionalData = await this._pGetDataSideLoaded(optFeature);
		const additionalFlags = await this._pGetFlagsSideLoaded(optFeature);

		const effects = [
			...(await this._pIsIgnoreSrdEffectsSideLoaded(optFeature) ? [] : MiscUtil.copy(srdData.effects || [])),
		];
		DataConverter.mutEffectsDisabledTransfer(effects, "importOptionalFeature");

		const effectsSideTuples = (await this._pGetEffectsSideLoadedTuples({ent: optFeature, img: srdData.img, actor: opts.actor}) || []);
		effectsSideTuples.forEach(({effect, effectRaw}) => DataConverter.mutEffectDisabledTransfer(effect, "importOptionalFeature", UtilActiveEffects.getDisabledTransferHintsSideData(effectRaw)));

		const out = {
			name: translatedName,
			type: srdData.type,
			system: {
				...srdData.system,

				activation: {type: activationType},

				source: UtilDataConverter.getSourceWithPagePart(optFeature),
				description: {value: translatedDescription, chat: "", unidentified: ""},
				requirements: this._getRequirementsString(optFeature),
				consume: dataConsume,

				...additionalData,
			},
			ownership: {default: 0},
			img: await this._pGetSaveImagePath(optFeature, {propCompendium: "optionalfeature", taskRunner: opts.taskRunner}),
			flags: {
				...translatedFlags,
				...this._getOptionalFeatureFlags(optFeature, opts),
				...additionalFlags,
			},
			effects: DataConverter.getEffectsMutDedupeId([
				...effects,
				...effectsSideTuples.map(it => it.effect),
			]),
		};

		if (opts.defaultOwnership != null) out.ownership = {default: opts.defaultOwnership};
		else if (opts.isAddDefaultOwnershipFromConfig) out.ownership = {default: Config.get("importOptionalFeature", "ownership")};
		if (opts.userOwnership) Object.assign(out.ownership, opts.userOwnership);

		return out;
	}

	static async _pGetOptionalFeatureItem_other (optFeature, opts) {
		const descriptionValue = await this._pGetDescriptionValue(optFeature);
		const dataConsume = this._getData_getConsume({ent: optFeature, actor: opts.actor});

		const img = await this._pGetSaveImagePath(optFeature, {propCompendium: "optionalfeature", taskRunner: opts.taskRunner});

		const additionalData = await this._pGetDataSideLoaded(optFeature);
		const additionalFlags = await this._pGetFlagsSideLoaded(optFeature);

		const effectsSideTuples = await this._pGetEffectsSideLoadedTuples({ent: optFeature, img, actor: opts.actor});
		effectsSideTuples.forEach(({effect, effectRaw}) => DataConverter.mutEffectDisabledTransfer(effect, "importOptionalFeature", UtilActiveEffects.getDisabledTransferHintsSideData(effectRaw)));

		const out = {
			name: UtilApplications.getCleanEntityName(UtilDataConverter.getNameWithSourcePart(optFeature, {isActorItem: opts.isActorItem})),
			system: {
				source: UtilDataConverter.getSourceWithPagePart(optFeature),
				description: {value: descriptionValue, chat: "", unidentified: ""},

				activation: {type: dataConsume?.type ? "special" : "", cost: null, condition: ""},
				duration: {value: 0, units: ""},
				target: {value: 0, units: "", type: ""},
				range: {value: 0, long: 0, units: null},
				uses: {value: 0, max: 0, per: ""},
				ability: "",
				actionType: "",
				attackBonus: null,
				chatFlavor: "",
				critical: {threshold: null, damage: ""},
				damage: {parts: [], versatile: ""},
				formula: "",
				save: {ability: "", dc: null},
				requirements: this._getRequirementsString(optFeature),
				consume: dataConsume,
				recharge: {value: 0, charged: true},

				...additionalData,
			},
			ownership: {default: 0},
			type: "feat",
			img,
			flags: {
				...this._getOptionalFeatureFlags(optFeature, opts),
				...additionalFlags,
			},
			effects: effectsSideTuples.map(it => it.effect),
		};

		if (opts.defaultOwnership != null) out.ownership = {default: opts.defaultOwnership};
		else if (opts.isAddDefaultOwnershipFromConfig) out.ownership = {default: Config.get("importOptionalFeature", "ownership")};
		if (opts.userOwnership) Object.assign(out.ownership, opts.userOwnership);

		return out;
	}

	static _pGetDescriptionValue (optFeature) {
		if (!Config.get("importOptionalFeature", "isImportDescription")) return "";

		return UtilDataConverter.pGetWithDescriptionPlugins(() => {
			const prerequisite = Renderer.utils.prerequisite.getHtml(optFeature.prerequisite);
			return `<div>
				${prerequisite ? `<p>${prerequisite}</p>` : ""}
				${Renderer.get().setFirstSection(true).render({entries: optFeature.entries}, 2)}
			</div>`;
		});
	}

	static _getRequirementsString (optFeature) {
		return optFeature._foundryData?.requirements 			|| Renderer.utils.prerequisite.getHtml(optFeature.prerequisite, {isTextOnly: true, isSkipPrefix: true});
	}

	static _getOptionalFeatureFlags (optFeature, opts) {
		opts = opts || {};

		const out = {
			[SharedConsts.MODULE_ID]: {
				page: UrlUtil.PG_OPT_FEATURES,
				source: optFeature.source,
				hash: UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_OPT_FEATURES](optFeature),
			},
		};

		if (opts.isAddDataFlags) {
			out[SharedConsts.MODULE_ID].propDroppable = "optionalfeature";
			out[SharedConsts.MODULE_ID].filterValues = opts.filterValues;
		}

		return out;
	}

	static async _pGetPreloadSideData () {
		if (!this._SIDE_DATA) this._SIDE_DATA = await Vetools.pGetOptionalFeatureSideData();
		return this._SIDE_DATA;
	}

	static _getCompendiumAliases (entity) {
		if (!entity.name || !entity.srd) return [];

		const out = [];

		for (const [featureTypeSet, fnGetName] of DataConverterOptionalfeature._FEATURE_TYPES.entries()) {
			if (entity.featureType.some(it => featureTypeSet.has(it))) out.push(fnGetName(entity));
		}

		return out;
	}
}

DataConverterOptionalfeature._FEATURE_TYPES = new Map();
DataConverterOptionalfeature._FEATURE_TYPES.set(new Set(["EI"]), entity => `Invocation: ${entity.name}`);
DataConverterOptionalfeature._FEATURE_TYPES.set(new Set(["MM"]), entity => `Metamagic: ${entity.name}`);
DataConverterOptionalfeature._FEATURE_TYPES.set(new Set(["FS:F", "FS:B", "FS:P", "FS:R"]), entity => `Fighting Style: ${entity.name}`);

var DataConverterOptionalfeature$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DataConverterOptionalfeature: DataConverterOptionalfeature
});

class ImportListOptionalFeature extends ImportListFeature {
		static init () {
		this._initCreateSheetItemHook({
			prop: "optionalfeature",
			importerName: "Other Option or Feature",
		});
	}
	
	static get ID () { return "other-options-and-features"; }
	static get DISPLAY_NAME_TYPE_SINGLE () { return "Other Option or Feature"; }
	static get DISPLAY_NAME_TYPE_PLURAL () { return "Other Options & Features"; }
	static get PROPS () { return ["optionalfeature"]; }

	static _ = this.registerImpl(this);

	_dirsHomebrew = ["optionalfeature"];
	_titleSearch = "options and feature";
	_sidebarTab = "items";
	_gameProp = "items";
	_defaultFolderPath = ["Other Options and Features"];
	_pageFilter = new PageFilterOptionalFeatures();
	_page = UrlUtil.PG_OPT_FEATURES;
	_isPreviewable = true;
	_isDedupable = true;
	_configGroup = "importOptionalFeature";
	_fnListSort = PageFilterOptionalFeatures.sortOptionalFeatures;
	static _DataConverter = DataConverterOptionalfeature;

	async _pGetSources () {
		const argsShared = {pPostLoad: loadedData => this.constructor._pPostLoad_addFauxOptionalfeatures(loadedData)};
		return [
			new UtilDataSource.DataSourceUrl(
				Config.get("ui", "isStreamerMode") ? "SRD" : "5etools",
				Vetools.DATA_URL_OPTIONALFEATURES,
				{
					...argsShared,
					filterTypes: [UtilDataSource.SOURCE_TYP_OFFICIAL_ALL],
					isDefault: true,
				},
			),
			...UtilDataSource.getSourcesCustomUrl({...argsShared}),
			...UtilDataSource.getSourcesUploadFile({...argsShared}),
			...(await this._pGetSourcesPrerelease({...argsShared})),
			...(await this._pGetSourcesBrew({...argsShared})),
		];
	}

	_colWidthName = 4;
	_colWidthSource = 1;

	_getData_cols_other () {
		return [
			{
				name: "Type",
				width: 2,
				field: "type",
				rowClassName: "text-center",
			},
			{
				name: "Prerequisite",
				width: 3,
				field: "prerequisite",
				rowClassName: "text-center",
			},
			{
				name: "Level",
				width: 1,
				field: "level",
				rowClassName: "text-center",
			},
		];
	}

	_getData_row_mutGetAdditionalValues ({it, ix}) {
				it._vPrerequisite = Renderer.utils.prerequisite.getHtml(it.prerequisite, {isSkipPrefix: true, isListMode: true, blocklistKeys: new Set(["level"])});
		it._vLevel = Renderer.optionalfeature.getListPrerequisiteLevelText(it.prerequisite);
		
		return {
			type: it._lFeatureType,
			prerequisite: it._vPrerequisite,
			level: it._vLevel,
		};
	}

	_renderInner_absorbListItems_fnGetValues (it) {
		return {
			...super._renderInner_absorbListItems_fnGetValues(it),
			prerequisite: it._vPrerequisite,
			level: it._vLevel,
			type: it._lFeatureType,
		};
	}
}

ImportListOptionalFeature.UserChoose = class extends MixinUserChooseImporter(ImportListOptionalFeature) {};

var ImportListOptionalFeature$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ImportListOptionalFeature: ImportListOptionalFeature
});

class DataConverterConditionDisease extends DataConverter {
	static _getSideLoadOpts (conDis) {
		return {
			propBrew: conDis.__prop === "disease" ? "foundryDisease" : "foundryCondition",
			fnLoadJson: Vetools.pGetConditionDiseaseSideData,
			propJson: conDis.__prop,
		};
	}

		static async pGetDocumentJson (conDis, opts) {
		opts = opts || {};

		Renderer.get().resetHeaderIndex();

		const content = Config.get("importConditionDisease", "isImportDescription")
			? await UtilDataConverter.pGetWithDescriptionPlugins(() => `<div>${Renderer.get().setFirstSection(true).render({entries: conDis.entries}, 2)}</div>`)
			: "";

		const img = await this._pGetSaveImagePath(conDis, {taskRunner: opts.taskRunner});

		const additionalData = await this._pGetDataSideLoaded(conDis);
		const additionalFlags = await this._pGetFlagsSideLoaded(conDis);

		const effectsSideTuples = await this._pGetEffectsSideLoadedTuples({ent: conDis, img, actor: opts.actor});
		effectsSideTuples.forEach(({effect, effectRaw}) => DataConverter.mutEffectDisabledTransfer(effect, "importConditionDisease", UtilActiveEffects.getDisabledTransferHintsSideData(effectRaw)));

		const out = {
			name: UtilApplications.getCleanEntityName(UtilDataConverter.getNameWithSourcePart(conDis, {isActorItem: opts.isActorItem})),
			system: {
				source: UtilDataConverter.getSourceWithPagePart(conDis),
				description: {
					value: content,
					chat: "",
					unidentified: "",
				},

				activation: {type: "", cost: 0, condition: ""},
				duration: {value: 0, units: ""},
				target: {value: 0, units: "", type: ""},
				range: {value: 0, long: 0, units: null},
				uses: {value: 0, max: 0, per: ""},
				ability: "",
				actionType: "",
				attackBonus: null,
				chatFlavor: "",
				critical: {threshold: null, damage: ""},
				damage: {parts: [], versatile: ""},
				formula: "",
				save: {ability: "", dc: null},
				requirements: "",
				recharge: {value: 0, charged: true},

				...additionalData,
			},
			ownership: {default: 0},
			type: "feat",
			img,
			flags: {
				[SharedConsts.MODULE_ID]: {
					page: UrlUtil.PG_CONDITIONS_DISEASES,
					source: conDis.source,
					hash: UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CONDITIONS_DISEASES](conDis),
					propDroppable: conDis.__prop,
				},
				...additionalFlags,
			},
			effects: DataConverter.getEffectsMutDedupeId(effectsSideTuples.map(it => it.effect)),
		};

		if (opts.defaultOwnership != null) out.ownership = {default: opts.defaultOwnership};
		else if (opts.isAddDefaultOwnershipFromConfig) out.ownership = {default: Config.get("importConditionDisease", "ownership")};
		if (opts.userOwnership) Object.assign(out.ownership, opts.userOwnership);

		return out;
	}

	static _getImgFallback (conDis) {
		return `modules/${SharedConsts.MODULE_ID}/media/icon/${conDis.__prop === "disease" ? "parmecia.svg" : "knockout.svg"}`;
	}
}

var DataConverterConditionDisease$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DataConverterConditionDisease: DataConverterConditionDisease
});

class ImportListConditionDisease extends ImportList {
	static get ID () { return "conditions-diseases"; }
	static get DISPLAY_NAME_TYPE_PLURAL () { return "Conditions & Diseases"; }
	static get PROPS () { return ["condition", "disease", "status"]; }

	static _ = this.registerImpl(this);

	_dirsHomebrew = ["condition", "disease", "status"];
	_titleSearch = "condition or disease";
	_sidebarTab = "items";
	_gameProp = "items";
	_defaultFolderPath = ["Conditions & Diseases"];
	_pageFilter = new PageFilterConditionsDiseases();
	_page = UrlUtil.PG_CONDITIONS_DISEASES;
	_isPreviewable = true;
	_isDedupable = true;
	_configGroup = "importConditionDisease";
	static _DataConverter = DataConverterConditionDisease;

	async _pGetSources () {
		return [
			new UtilDataSource.DataSourceUrl(
				Config.get("ui", "isStreamerMode") ? "SRD" : "5etools",
				Vetools.DATA_URL_CONDITIONSDISEASES,
				{
					filterTypes: [UtilDataSource.SOURCE_TYP_OFFICIAL_ALL],
					isDefault: true,
				},
			),
			...UtilDataSource.getSourcesCustomUrl(),
			...UtilDataSource.getSourcesUploadFile(),
			...(await this._pGetSourcesPrerelease()),
			...(await this._pGetSourcesBrew()),
		];
	}

	_colWidthName = 7;

	_getData_cols_otherPre () {
		return [
			{
				name: "Type",
				width: 2,
				field: "type",
				rowClassName: "text-center",
			},
		];
	}

	_getData_row_mutGetAdditionalValues ({it, ix}) {
		it._lType = it.__prop.toTitleCase();

		return {
			type: it._lType,
		};
	}

	_renderInner_absorbListItems_fnGetValues (it) {
		return {
			...super._renderInner_absorbListItems_fnGetValues(it),
			type: it.__prop,
		};
	}

	getFolderPathMeta () {
		return {
			...super.getFolderPathMeta(),
			type: {
				label: "Type",
				getter: it => it._lType,
			},
		};
	}
}

var ImportListConditionDisease$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ImportListConditionDisease: ImportListConditionDisease
});

class DataConverterCultBoon extends DataConverter {
	static _getSideLoadOpts (ent) {
		return {
			propBrew: ent.__prop === "cult" ? "foundryCult" : "foundryBoon",
			fnLoadJson: Vetools.pGetCultBoonSideData,
			propJson: ent.__prop,
		};
	}

	static _IMG_FALLBACK = `modules/${SharedConsts.MODULE_ID}/media/icon/diablo-skull.svg`;

		static async pGetDocumentJson (ent, opts) {
		opts = opts || {};

		Renderer.get().resetHeaderIndex();

		const content = Config.get("importCultBoon", "isImportDescription")
			? await UtilDataConverter.pGetWithDescriptionPlugins(() => `<div>${Renderer.get().setFirstSection(true).render({entries: ent.entries}, 2)}</div>`)
			: "";

		const img = await this._pGetSaveImagePath(ent, {taskRunner: opts.taskRunner});

		const additionalData = await this._pGetDataSideLoaded(ent);
		const additionalFlags = await this._pGetFlagsSideLoaded(ent);

		const effectsSideTuples = await this._pGetEffectsSideLoadedTuples({ent, img, actor: opts.actor});
		effectsSideTuples.forEach(({effect, effectRaw}) => DataConverter.mutEffectDisabledTransfer(effect, "importCultBoon", UtilActiveEffects.getDisabledTransferHintsSideData(effectRaw)));

		const out = {
			name: UtilApplications.getCleanEntityName(UtilDataConverter.getNameWithSourcePart(ent, {isActorItem: opts.isActorItem})),
			system: {
				source: UtilDataConverter.getSourceWithPagePart(ent),
				description: {
					value: content,
					chat: "",
					unidentified: "",
				},

				activation: {type: "", cost: 0, condition: ""},
				duration: {value: 0, units: ""},
				target: {value: 0, units: "", type: ""},
				range: {value: 0, long: 0, units: null},
				uses: {value: 0, max: 0, per: ""},
				ability: "",
				actionType: "",
				attackBonus: null,
				chatFlavor: "",
				critical: {threshold: null, damage: ""},
				damage: {parts: [], versatile: ""},
				formula: "",
				save: {ability: "", dc: null},
				requirements: "",
				recharge: {value: 0, charged: true},

				...additionalData,
			},
			ownership: {default: 0},
			type: "feat",
			img,
			flags: {
				[SharedConsts.MODULE_ID]: {
					page: UrlUtil.PG_CULTS_BOONS,
					source: ent.source,
					hash: UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CULTS_BOONS](ent),
					propDroppable: ent.__prop,
				},
				...additionalFlags,
			},
			effects: DataConverter.getEffectsMutDedupeId(effectsSideTuples.map(it => it.effect)),
		};

		if (opts.defaultOwnership != null) out.ownership = {default: opts.defaultOwnership};
		else if (opts.isAddDefaultOwnershipFromConfig) out.ownership = {default: Config.get("importCultBoon", "ownership")};
		if (opts.userOwnership) Object.assign(out.ownership, opts.userOwnership);

		return out;
	}
}

var DataConverterCultBoon$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DataConverterCultBoon: DataConverterCultBoon
});

class ImportListCultBoon extends ImportList {
	static get ID () { return "cults-boons"; }
	static get DISPLAY_NAME_TYPE_PLURAL () { return "Cults & Supernatural Boons"; }
	static get PROPS () { return ["cult", "boon"]; }

	static _ = this.registerImpl(this);

	_dirsHomebrew = ["cult", "boon"];
	_titleSearch = "cult or supernatural boon";
	_sidebarTab = "items";
	_gameProp = "items";
	_defaultFolderPath = ["Cults & Supernatural Boons"];
	_pageFilter = new PageFilterCultsBoons();
	_page = UrlUtil.PG_CULTS_BOONS;
	_isPreviewable = true;
	_isDedupable = true;
	_configGroup = "importCultBoon";
	static _DataConverter = DataConverterCultBoon;

	async _pGetSources () {
		return [
			new UtilDataSource.DataSourceUrl(
				Config.get("ui", "isStreamerMode") ? "SRD" : "5etools",
				Vetools.DATA_URL_CULTSBOONS,
				{
					filterTypes: [UtilDataSource.SOURCE_TYP_OFFICIAL_ALL],
					isDefault: true,
				},
			),
			...UtilDataSource.getSourcesCustomUrl(),
			...UtilDataSource.getSourcesUploadFile(),
			...(await this._pGetSourcesPrerelease()),
			...(await this._pGetSourcesBrew()),
		];
	}

	_colWidthName = 5;

	_getData_cols_otherPre () {
		return [
			{
				name: "Type",
				width: 2,
				field: "type",
				rowClassName: "text-center",
			},
			{
				name: "Subtype",
				width: 2,
				field: "subtype",
				rowClassName: "text-center",
			},
		];
	}

	_getData_row_mutGetAdditionalValues ({it, ix}) {
		it._lType = it.__prop.toTitleCase();
		it._lSubType = it.type || "\u2014";

		return {
			type: it._lType,
			subtype: it._lSubType,
		};
	}

	_renderInner_absorbListItems_fnGetValues (it) {
		return {
			...super._renderInner_absorbListItems_fnGetValues(it),
			type: it.__prop,
			subtype: it.type,
		};
	}

	getFolderPathMeta () {
		return {
			...super.getFolderPathMeta(),
			type: {
				label: "Type",
				getter: it => it._lType,
			},
			subtype: {
				label: "Subtype",
				getter: it => it._lSubType,
			},
		};
	}
}

var ImportListCultBoon$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ImportListCultBoon: ImportListCultBoon
});

class DataConverterAction extends DataConverter {
	static _SIDE_LOAD_OPTS = {
		propBrew: "foundryAction",
		fnLoadJson: Vetools.pGetActionSideData,
		propJson: "action",
	};

	static _IMG_FALLBACK = `modules/${SharedConsts.MODULE_ID}/media/icon/jump-across.svg`;

		static async pGetDocumentJson (ent, opts) {
		opts = opts || {};

		Renderer.get().resetHeaderIndex();

		const content = Config.get("importAction", "isImportDescription")
			? await UtilDataConverter.pGetWithDescriptionPlugins(() => `<div>${Renderer.get().setFirstSection(true).render({entries: ent.entries}, 2)}</div>`)
			: "";

		let activationType = "special";
		let activationCost = 0;
		if (ent.time?.length && typeof ent.time[0] !== "string") {
			const time0 = ent.time[0];
			activationType = time0.unit || "special";
			activationCost = time0.number ?? 0;
		}

		const img = await this._pGetSaveImagePath(ent, {taskRunner: opts.taskRunner});

		const additionalData = await this._pGetDataSideLoaded(ent);
		const additionalFlags = await this._pGetFlagsSideLoaded(ent);

		const effectsSideTuples = await this._pGetEffectsSideLoadedTuples({ent, img, actor: opts.actor});
		effectsSideTuples.forEach(({effect, effectRaw}) => DataConverter.mutEffectDisabledTransfer(effect, "importAction", UtilActiveEffects.getDisabledTransferHintsSideData(effectRaw)));

		const out = {
			name: UtilApplications.getCleanEntityName(UtilDataConverter.getNameWithSourcePart(ent, {isActorItem: opts.isActorItem})),
			system: {
				source: UtilDataConverter.getSourceWithPagePart(ent),
				description: {
					value: content,
					chat: "",
					unidentified: "",
				},

				activation: {type: activationType, cost: activationCost, condition: ""},
				duration: {value: 0, units: ""},
				target: {value: 0, units: "", type: ""},
				range: {value: 0, long: 0, units: null},
				uses: {value: 0, max: 0, per: ""},
				ability: "",
				actionType: "",
				attackBonus: null,
				chatFlavor: "",
				critical: {threshold: null, damage: ""},
				damage: {parts: [], versatile: ""},
				formula: "",
				save: {ability: "", dc: null},
				requirements: "",
				recharge: {value: 0, charged: true},

				...additionalData,
			},
			ownership: {default: 0},
			type: "feat",
			img,
			flags: {
				...this._getActionFlags(ent),
				...additionalFlags,
			},
			effects: DataConverter.getEffectsMutDedupeId(effectsSideTuples.map(it => it.effect)),
		};

		if (opts.defaultOwnership != null) out.ownership = {default: opts.defaultOwnership};
		else if (opts.isAddDefaultOwnershipFromConfig) out.ownership = {default: Config.get("importAction", "ownership")};
		if (opts.userOwnership) Object.assign(out.ownership, opts.userOwnership);

		return out;
	}

	static _getActionFlags (action) {
		return {
			[SharedConsts.MODULE_ID]: {
				page: UrlUtil.PG_ACTIONS,
				source: action.source,
				hash: UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ACTIONS](action),
				propDroppable: "action",
			},
		};
	}
}

var DataConverterAction$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DataConverterAction: DataConverterAction
});

class ImportListAction extends ImportList {
	static get ID () { return "actions"; }
	static get DISPLAY_NAME_TYPE_PLURAL () { return "Actions"; }
	static get PROPS () { return ["action"]; }

	static _ = this.registerImpl(this);

	_dirsHomebrew = ["action"];
	_titleSearch = "action";
	_sidebarTab = "items";
	_gameProp = "items";
	_defaultFolderPath = ["Actions"];
	_pageFilter = new PageFilterActions();
	_page = UrlUtil.PG_ACTIONS;
	_isPreviewable = true;
	_isDedupable = true;
	_configGroup = "importAction";
	static _DataConverter = DataConverterAction;

	async _pGetSources () {
		return [
			new UtilDataSource.DataSourceUrl(
				Config.get("ui", "isStreamerMode") ? "SRD" : "5etools",
				Vetools.DATA_URL_ACTIONS,
				{
					filterTypes: [UtilDataSource.SOURCE_TYP_OFFICIAL_ALL],
					isDefault: true,
				},
			),
			...UtilDataSource.getSourcesCustomUrl(),
			...UtilDataSource.getSourcesUploadFile(),
			...(await this._pGetSourcesPrerelease()),
			...(await this._pGetSourcesBrew()),
		];
	}

	_colWidthName = 6;

	_getData_cols_other () {
		return [
			{
				name: "Time",
				width: 3,
				field: "time",
				rowClassName: "text-center",
			},
		];
	}

	_getData_row_mutGetAdditionalValues ({it, ix}) {
		it._lTime = it.time ? it.time.map(tm => PageFilterActions.getTimeText(tm)).join("/") : "\u2014";

		return {
			time: it._lTime,
		};
	}

	_renderInner_absorbListItems_fnGetValues (it) {
		return {
			...super._renderInner_absorbListItems_fnGetValues(it),
			time: it._lTime,
		};
	}

	getFolderPathMeta () {
		return {
			...super.getFolderPathMeta(),
			type: {
				label: "Time",
				getter: it => it._lTime,
			},
		};
	}
}

var ImportListAction$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ImportListAction: ImportListAction
});

class DataConverterVehicle extends DataConverter {
	static _SIDE_LOAD_OPTS = {
		propBrew: "foundryVehicle",
		fnLoadJson: Vetools.pGetVehicleSideData.bind(Vetools),
		propJson: "vehicle",
	};

	static _SIDE_LOAD_OPTS_WEAPON = {
		propBrew: "foundryVehicleWeapon",
		fnLoadJson: Vetools.pGetVehicleSideData.bind(Vetools),
		propJson: "vehicleWeapon",
		propsMatch: ["vehicleSource", "vehicleName", "source", "name"],
	};

		static getShipMovement (veh) {
		switch (veh.vehicleType) {
			case "SHIP": return this._getShipMovement_ship(veh);
			case "INFWAR": return this._getShipMovement_infwar(veh);
			case "SPELLJAMMER": return this._getShipMovement_spelljammer(veh);
			default: throw new Error(`Unhandled vehicle type "${veh.vehicleType}"`);
		}
	}

	static _getShipMovement_ship (veh) {
		const out = {};

		(veh.movement || []).forEach(move => {
			this._doPopulateMovementToSpeedMap(move, "locomotion", out);
			this._doPopulateMovementToSpeedMap(move, "speed", out);
		});

		if (!Object.keys(out).length && veh.pace && typeof veh.pace === "number" && veh.terrain?.length) {
			veh.terrain.forEach(ter => {
				const speedProp = this._getMovementTypeFromTerrain(ter);
				out[speedProp] = Config.getMetricNumberDistance({configGroup: "importVehicle", originalUnit: Parser.UNT_MILES, originalValue: veh.pace});
			});
			out.units = Config.getMetricUnitDistance({configGroup: "importVehicle", originalUnit: "mi"});
		}

				if (!out.walk) out.walk = 0;

		return out;
	}

	static _getMovementTypeFromTerrain (ter) {
		switch (ter) {
			case "air": return "fly";
			case "land": return "walk";
			case "sea": return "swim";
			case "space": return "fly";
			default: throw new Error(`Unhandled terrain type "${ter}"`);
		}
	}

	static _doPopulateMovementToSpeedMap (move, prop, out) {
		if (!move[prop]) return;

		move[prop].forEach(spd => {
			if (!spd.entries || !spd.entries.length) return;

			const speedProp = this._getSpeedTypeFromMovementMode(spd.mode);

						if (speedProp == null) {
				UtilDataConverter.WALKER_READONLY_GENERIC.walk(
					spd.entries,
					{
						string: (str) => {
							str.split(",").map(it => it.trim()).filter(Boolean).forEach(pt => {
								pt.replace(/^(?:(burrow|climb|swim|fly) )?(\d+) ft\./g, (...m) => {
									const speedType = m[1].toLowerCase().trim();
									const speed = Config.getMetricNumberDistance({configGroup: "importVehicle", originalUnit: Parser.UNT_FEET, originalValue: Number(m[2])});
									out[speedType] = Math.max(speed, out[speedType] || 0);
								});
							});

							if (str.toLowerCase().includes("(hover)")) out.hover = true;
						},
					},
				);

				return;
			}

			UtilDataConverter.WALKER_READONLY_GENERIC.walk(
				spd.entries,
				{
					string: (str) => {
						str.replace(/speed (\d+) ft\./g, (...m) => {
							const speed = Config.getMetricNumberDistance({configGroup: "importVehicle", originalUnit: Parser.UNT_FEET, originalValue: Number(m[1])});
							out[speedProp] = Math.max(speed, out[speedProp] || 0);
						});

						if (str.toLowerCase().includes("(hover)")) out.hover = true;
					},
				},
			);
		});
	}

	static _getSpeedTypeFromMovementMode (mode) {
		switch (mode) {
			case "air": return "fly";
			case "water": return "swim";
			case "magical": return null;
			default: throw new Error(`Unhandled locomotion mode "${mode}"`);
		}
	}

	static _getShipMovement_infwar (veh) {
		return this._getShipMovement_fromStandardSpeed(veh);
	}

	static _getShipMovement_spelljammer (veh) {
		return this._getShipMovement_fromStandardSpeed(veh);
	}

	static _getShipMovement_fromStandardSpeed (veh) {
		return this.getMovement(veh.speed, {configGroup: "importVehicle"});
	}
	
	static async pGetShipEquipmentItem (veh, equi, prop) {
		Renderer.get().resetHeaderIndex();

		let description = await DataConverter.pGetEntryDescription(equi);

		if (prop === "movement") {
			if (equi.speed) {
				const parts = equi.speed
					.map(it => Renderer.vehicle.ship.getSpeedEntries(it))
					.map(ents => `<div>${Renderer.get().setFirstSection(true).render(ents)}</div>`);
				description += parts.join("");
			}

			if (equi.locomotion) {
				const parts = equi.locomotion
					.map(loc => Renderer.vehicle.ship.getLocomotionEntries(loc))
					.map(ents => `<div>${Renderer.get().setFirstSection(true).render(ents)}</div>`);
				description += parts.join("");
			}
		}

		const out = {
			name: equi.name,
			type: "equipment",
			system: {
				description: {value: description, chat: "", unidentified: ""},
				source: UtilDataConverter.getSourceWithPagePart(veh),
				quantity: 1,
				weight: 0,
				price: 0,
				attuned: false,
				equipped: true,
				rarity: "",
				identified: true,
				activation: {type: "", cost: 0, condition: ""},
				duration: {value: null, units: ""},
				target: {value: null, width: null, units: "", type: ""},
				range: {value: null, long: null, units: ""},
				uses: {value: 0, max: 0, per: null},
				consume: {type: "", target: null, amount: null},
				ability: null,
				actionType: "",
				attackBonus: null,
				chatFlavor: "",
				critical: {threshold: null, damage: ""},
				damage: {parts: [], versatile: ""},
				formula: "",
				save: {ability: "", dc: null, scaling: "spell"},
				armor: {value: equi.ac || 0, type: "vehicle", dex: null},
				hp: {value: equi.hp || 0, max: equi.hp || 0, dt: equi.dt, conditions: equi.hpNote ? Renderer.stripTags(equi.hpNote) : ""},
				speed: {value: null, conditions: ""},
				strength: 0,
				stealth: false,
				proficient: true,
			},
			flags: {
				...this.getVehicleChildFlags({veh, entry: equi, prop}),
			},
			img: await Vetools.pOptionallySaveImageToServerAndGetUrl(
				`modules/${SharedConsts.MODULE_ID}/media/icon/ship-wheel.svg`,
			),
		};

												if (prop === "movement") {
			if (equi.speed) {
				const metas = this._getSpeedMetas(equi);
				if (metas.length) {
					const primaryMeta = metas[0];
					out.system.speed.value = primaryMeta.speed;
					out.system.speed.conditions = primaryMeta.condition;
				}
			}

			if (equi.locomotion) {
				const metas = this._getLocomotionMetas(equi);
				if (metas.length) {
					const primaryMeta = metas[0];
					out.system.speed.value = primaryMeta.speed;
					out.system.speed.conditions = primaryMeta.condition;
				}
			}
		}

		return out;
	}

	static _getSpeedMetas (equi) {
		if (!equi.speed || !equi.speed.length) return [];

		return equi.speed
			.map(spd => {
				if (!spd.entries || !spd.entries.length || typeof spd.entries[0] !== "string") return null;

				const parts = spd.entries[0].split(";").map(it => it.trim()).filter(Boolean);
				return parts.map(it => {
					const mSpeed = /^((?:fly|swim|burrow|climb) )?(\d+)\s*ft\.(.*?)$/.exec(it);
					if (!mSpeed) return null;
					const out = {speed: Config.getMetricNumberDistance({configGroup: "importVehicle", originalUnit: Parser.UNT_FEET, originalValue: Number(mSpeed[2])})};
					if (mSpeed[3]) {
						const conditionClean = mSpeed[3].trim().replace(/^,\s*/, "");
						if (conditionClean) out.condition = conditionClean;
					}
					return out;
				});
			})
			.filter(Boolean)
			.flat();
	}

	static _getLocomotionMetas (equi) {
		if (!equi.locomotion || !equi.locomotion.length) return [];

		return equi.locomotion
			.map(loc => {
				if (!loc.entries || !loc.entries.length || typeof loc.entries[0] !== "string") return null;

				const mSpeed = /^(.*?), speed (\d+)\s*ft\.(.*?)$/i.exec(loc.entries[0]);
				if (!mSpeed) return null;

				let [_, subMode, baseSpeed, conditionOrOtherSpeeds] = mSpeed;
				subMode = subMode.trim(); 				baseSpeed = baseSpeed.trim();
				conditionOrOtherSpeeds = conditionOrOtherSpeeds.trim();

				const otherPartsRaw = conditionOrOtherSpeeds.split(";").map(it => it.trim()).filter(Boolean);
				const [conditionPart, ...otherParts] = conditionOrOtherSpeeds.includes(";")
					? ["", ...otherPartsRaw]
					: otherPartsRaw;

				const outPrimary = {
					speed: Config.getMetricNumberDistance({configGroup: "importVehicle", originalUnit: Parser.UNT_FEET, originalValue: Number(baseSpeed)}),
				};
				if (conditionPart) outPrimary.condition = conditionPart;

				const outSecondaries = [];
				otherParts.forEach(part => {
					const mSpeed = /^(\d+)\s*ft\.(.*?)$/.exec(part);
					if (!mSpeed) return;
					outSecondaries.push({
						speed: Config.getMetricNumberDistance({configGroup: "importVehicle", originalUnit: Parser.UNT_FEET, originalValue: Number(mSpeed[1])}),
						condition: mSpeed[2],
					});
				});

				return [outPrimary, ...outSecondaries];
			})
			.filter(Boolean)
			.flat();
	}

	static _getFauxVehicleWeapon (veh, weap) {
		return {
			source: veh.source,
			backgroundName: veh.name,
			backgroundSource: veh.source,
			srd: veh.srd,
			...MiscUtil.copy(weap),
		};
	}

	static async pGetShipWeaponItems (veh, weap, prop, opts) {
		opts = opts || {};
		const {fvttType = null} = opts;

		Renderer.get().resetHeaderIndex();

		if (weap.action?.length) return this._pGetShipWeaponParentChildItems(veh, weap, prop, opts);

		const description = await DataConverter.pGetEntryDescription(weap);

		const state = new this._PassiveEntryParseState(
			{
				entry: weap,
				name: UtilApplications.getCleanEntityName(UtilDataConverter.getNameWithSourcePart(weap, {displayName: opts.displayName, isActorItem: true})),
			},
			opts,
		);
		await state.pInit();

		const {
			damageTupleMetas,
			isAttack,
			isRecharge,
			rangeShort,
			rangeLong,
			actionType,
			attackBonus,
		} = DataConverter.getParsedWeaponEntryData(veh, weap);

		if (isAttack) {
			if (state.activationType === undefined) state.activationType = "action";
			if (state.activationCost === undefined) state.activationCost = 1;
		}

		const {damageParts, formula} = DataConverter.getDamagePartsAndOtherFormula(damageTupleMetas);

		const img = await Vetools.pOptionallySaveImageToServerAndGetUrl(
			`modules/${SharedConsts.MODULE_ID}/media/icon/pirate-cannon.svg`,
		);

		const fauxEnt = this._getFauxVehicleWeapon(veh, weap);

		const additionalData = await this._pGetDataSideLoaded(fauxEnt, {propOpts: "_SIDE_LOAD_OPTS_WEAPON"});
		const additionalFlags = await this._pGetFlagsSideLoaded(fauxEnt, {propOpts: "_SIDE_LOAD_OPTS_WEAPON"});

		const effectsSideTuples = await this._pGetEffectsSideLoadedTuples({ent: fauxEnt, img, actor: opts.actor}, {propOpts: "_SIDE_LOAD_OPTS_WEAPON"});
		effectsSideTuples.forEach(({effect, effectRaw}) => DataConverter.mutEffectDisabledTransfer(effect, "importVehicle", UtilActiveEffects.getDisabledTransferHintsSideData(effectRaw)));

		const out = {
			name: weap.name,
			type: fvttType || (isRecharge ? "feat" : "weapon"),
			system: {
				description: {value: description, chat: "", unidentified: ""},
				source: UtilDataConverter.getSourceWithPagePart(veh),
				quantity: weap.count || 1,
				weight: 0,
				price: 0,
				attuned: false,
				equipped: true,
				rarity: "",
				identified: true,
				activation: {
					type: state.activationType,
					cost: state.activationCost,
					condition: state.activationCondition,
				},
				duration: {value: null, units: ""},
				target: {value: null, width: null, units: "", type: ""},
				range: {value: rangeShort || 0, long: rangeLong || 0, units: "ft"},
				uses: {value: 0, max: 0, per: null},
				consume: {type: "", target: null, amount: null},
				ability: "",
				actionType: actionType || "other",
				attackBonus: attackBonus || null,
				chatFlavor: "",
				critical: {threshold: null, damage: ""},
				damage: {parts: damageParts || [], versatile: ""},
				formula,
				save: {ability: "", dc: null, scaling: "spell"},
				armor: {value: weap.ac || 0},
				hp: {value: weap.hp || 0, max: weap.hp || 0, dt: weap.dt, conditions: ""},
				weaponType: "siege",
				properties: {},
				proficient: true,

				...additionalData,
			},
			flags: {
				...this.getVehicleChildFlags({veh, entry: weap, prop}),
				...additionalFlags,
			},
			img,
			effects: DataConverter.getEffectsMutDedupeId(effectsSideTuples.map(it => it.effect)),
		};

		return [out];
	}

	static async _pGetShipWeaponParentChildItems (veh, weap, prop, opts) {
		opts = opts || {};

		let actionCount;
		if (weap.entries) {
			const walker = MiscUtil.getWalker({
				keyBlocklist: MiscUtil.GENERIC_WALKER_ENTRIES_KEY_BLOCKLIST,
				isBreakOnReturn: true,
				isNoModification: true,
			});
			walker.walk(
				weap.entries,
				{
					string: (str) => {
																								str.replace(/\b(?<actions>\d+) action(s)?\b/g, (...m) => {
							const numActions = Number(m.last().actions);
							if (actionCount == null) actionCount = numActions;
							else actionCount += numActions;
						});

						if (actionCount != null) return true;
					},
				},
			);
		}

		const subOpts = {...opts, fvttType: "feat"};
		if (actionCount) {
			subOpts.activationType = "action";
			subOpts.activationCost = actionCount;
		}
		const subs = (await weap.action.pSerialAwaitMap(act => this.pGetShipWeaponItems(veh, act, prop, subOpts)))
			.flat();

		const costMax = (weap.costs || [])
			.filter(it => it.cost && !isNaN(it.cost))
			.sort((a, b) => SortUtil.ascSort(b.cost, a.cost))
			.map(it => it.cost)[0];

		let description = await DataConverter.pGetEntryDescription(weap);
		description = Renderer.vehicle.spelljammer.getSectionHpCostPart_(Renderer.get(), weap) + description;

				const parent = {
			name: weap.name,
			type: "equipment",
			system: {
				description: {value: description, chat: "", unidentified: ""},
				source: UtilDataConverter.getSourceWithPagePart(veh),
				quantity: weap.count,
				weight: 0,
				price: costMax != null ? UtilItem.getPrice({cp: costMax}) : null,
				attuned: false,
				equipped: true,
				rarity: "",
				identified: true,
				activation: {type: "", cost: 0, condition: ""},
				duration: {value: null, units: ""},
				target: {value: null, width: null, units: "", type: ""},
				range: {value: null, long: null, units: ""},
				uses: {value: 0, max: 0, per: null},
				consume: {type: "", target: null, amount: null},
				ability: null,
				actionType: "",
				attackBonus: null,
				chatFlavor: "",
				critical: {threshold: null, damage: ""},
				damage: {parts: [], versatile: ""},
				formula: "",
				save: {ability: "", dc: null, scaling: "spell"},
				armor: {value: weap.ac || 0, type: "vehicle", dex: null},
				hp: {value: weap.hp || 0, max: weap.hp || 0, dt: weap.dt},
				speed: {value: null, conditions: ""},
				strength: 0,
				stealth: false,
				proficient: true,
			},
			flags: {
				...this.getVehicleChildFlags({veh, entry: weap, prop}),
			},
			img: await Vetools.pOptionallySaveImageToServerAndGetUrl(
				`modules/${SharedConsts.MODULE_ID}/media/icon/pirate-cannon.svg`,
			),
		};

		return [parent, ...subs];
	}

	static async pGetShipOtherItem (veh, ent, prop) {
		const description = await DataConverter.pGetEntryDescription(ent);

		if (/^Actions?$/i.test(ent.name || "")) {
			return {
				name: ent.name,
				type: "feat",
				system: {
					description: {value: description, chat: "", unidentified: ""},
					source: UtilDataConverter.getSourceWithPagePart(veh),
					activation: {type: "crew", cost: 1, condition: ""},
					duration: {value: null, units: ""},
					target: {value: null, width: null, units: "", type: ""},
					range: {value: null, long: null, units: ""},
					uses: {value: 0, max: 0, per: ""},
					consume: {type: "", target: "", amount: null},
					ability: null,
					actionType: "",
					attackBonus: null,
					chatFlavor: "",
					critical: {threshold: null, damage: ""},
					damage: {parts: [], versatile: ""},
					formula: "",
					save: {ability: "", dc: null, scaling: "spell"},
					requirements: "",
					recharge: {value: null, charged: false},
					cover: null,
				},
				flags: {
					...this.getVehicleChildFlags({veh, entry: ent, prop}),
				},
				img: await Vetools.pOptionallySaveImageToServerAndGetUrl(
					`modules/${SharedConsts.MODULE_ID}/media/icon/ship-wheel.svg`,
				),
			};
		}

		return {
			name: ent.name,
			type: "feat",
			system: {
				description: {value: description, chat: "", unidentified: ""},
				source: UtilDataConverter.getSourceWithPagePart(veh),
				activation: {type: "", cost: 0, condition: ""},
				duration: {value: null, units: ""},
				target: {value: null, width: null, units: "", type: ""},
				range: {value: null, long: null, units: ""},
				uses: {value: 0, max: 0, per: null},
				consume: {type: "", target: null, amount: null},
				ability: null,
				actionType: "",
				attackBonus: null,
				chatFlavor: "",
				critical: {threshold: null, damage: ""},
				damage: {parts: [], versatile: ""},
				formula: "",
				save: {ability: "", dc: null, scaling: "spell"},
				requirements: "",
				recharge: {value: null, charged: false},
			},
			flags: {
				...this.getVehicleChildFlags({veh, entry: ent, prop}),
			},
			img: await Vetools.pOptionallySaveImageToServerAndGetUrl(
				`modules/${SharedConsts.MODULE_ID}/media/icon/ship-wheel.svg`,
			),
		};
	}

	static async pGetShipActionItems (veh, actionEnts, prop) {
		const ixActionList = actionEnts.findIndex(it => it.type === "list" && it.items.every(it => it.type === "item"));

		const templateOut = {
			name: "",
			type: "feat",
			system: {
				description: {value: "", chat: "", unidentified: ""},
				source: UtilDataConverter.getSourceWithPagePart(veh),
				activation: {type: "crew", cost: 1, condition: ""},
				duration: {value: null, units: ""},
				target: {value: null, width: null, units: "", type: ""},
				range: {value: null, long: null, units: ""},
				uses: {value: 0, max: 0, per: ""},
				consume: {type: "", target: "", amount: null},
				ability: null,
				actionType: "",
				attackBonus: null,
				chatFlavor: "",
				critical: {threshold: null, damage: ""},
				damage: {parts: [], versatile: ""},
				formula: "",
				save: {ability: "", dc: null, scaling: "spell"},
				requirements: "",
				recharge: {value: null, charged: false},
				cover: null,
			},
			flags: {},
			img: await Vetools.pOptionallySaveImageToServerAndGetUrl(
				`modules/${SharedConsts.MODULE_ID}/media/icon/ship-wheel.svg`,
			),
		};

		if (!~ixActionList) {
			templateOut.name = "Actions";
			templateOut.system.description.value = await DataConverter.pGetEntryDescription({entries: actionEnts});
			templateOut.flags = {
				...this.getVehicleChildFlags({veh, entry: {name: "Actions", source: veh.source, entries: actionEnts}, prop}),
			};
			return [templateOut];
		}

		actionEnts = MiscUtil.copy(actionEnts);
		const actionList = actionEnts[ixActionList];
		actionEnts.splice(ixActionList, 1);

		return actionList.items.pSerialAwaitMap(async li => {
			const subName = li.name.replace(/\.$/i, "");

			const fauxEntries = MiscUtil.copy(actionEnts);
			if (typeof fauxEntries[0] === "string") fauxEntries[0] = fauxEntries[0].replace(/, choosing from the options below[.:]/ig, ".");
			fauxEntries.unshift({type: "entries", name: subName, entries: li.entries || [li.entry]});

			const description = await DataConverter.pGetEntryDescription({entries: fauxEntries});

			const subOut = MiscUtil.copy(templateOut);
			subOut.name = subName;
			subOut.system.description.value = description;
			subOut.flags = {
				...this.getVehicleChildFlags({veh, entry: {name: subName, source: li.source || veh.source, entries: fauxEntries}, prop}),
			};
			return subOut;
		});
	}

	static async pGetInfWarActionItem (veh, action, prop) {
		const description = await DataConverter.pGetEntryDescription(action);

		const {
			damageTupleMetas,
			isAttack,
			isRecharge,
			rangeShort,
			rangeLong,
			actionType,
			attackBonus,
		} = DataConverter.getParsedWeaponEntryData(veh, action);

		const {damageParts, formula} = DataConverter.getDamagePartsAndOtherFormula(damageTupleMetas);

		let coverType = 0;
		(action.name || "").replace(/(Grants Half Cover|Grants Three-Quarters Cover|Grants Total Cover)/ig, (...m) => {
			const low = m[1].toLowerCase().trim();
			switch (low) {
				case "grants half cover": coverType = 0.5; break;
				case "grants three-quarters cover": coverType = 0.75; break;
				case "grants total cover": coverType = 1; break;
				default: throw new Error(`Unknown cover type ""${low}`);
			}
		});

		return {
			name: action.name,
			type: "feat",
			system: {
				description: {value: description, chat: "", unidentified: ""},
				source: UtilDataConverter.getSourceWithPagePart(veh),
				activation: {type: "crew", cost: 1, condition: ""},
				duration: {value: null, units: ""},
				target: {value: null, width: null, units: "", type: ""},
				range: {value: rangeShort, long: rangeLong, units: "ft"},
				uses: {value: 0, max: 0, per: ""},
				consume: {type: "", target: "", amount: null},
				ability: "",
				actionType: actionType || "other",
				attackBonus: attackBonus || null,
				chatFlavor: "",
				critical: {threshold: null, damage: ""},
				damage: {parts: damageParts || [], versatile: ""},
				formula,
				save: {ability: "", dc: null, scaling: "spell"},
				requirements: "",
				recharge: {value: null, charged: false},
				cover: coverType,
			},
			flags: {
				...this.getVehicleChildFlags({veh, entry: action, prop}),
			},
			img: await Vetools.pOptionallySaveImageToServerAndGetUrl(
				`modules/${SharedConsts.MODULE_ID}/media/icon/gears.svg`,
			),
		};
	}

	static getVehicleChildFlags ({veh, entry, prop}) {
		const outProp = `vehicle${prop.uppercaseFirst()}`;

		return {
			[SharedConsts.MODULE_ID]: {
				page: outProp,
				source: entry.source || veh.source,
				hash: UrlUtil.URL_TO_HASH_BUILDER[outProp]({
					source: veh.source,
					...entry,
					objectName: veh.name,
					objectSource: veh.source,
				}),
			},
		};
	}
}

var DataConverterVehicle$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DataConverterVehicle: DataConverterVehicle
});

class DataConverterObject extends DataConverter {
	static _SIDE_LOAD_OPTS = {
		propBrew: "foundryObject",
		fnLoadJson: Vetools.pGetObjectSideData.bind(Vetools),
		propJson: "object",
	};

	static _IMG_FALLBACK = `modules/${SharedConsts.MODULE_ID}/media/icon/mailed-fist.svg`;

	static async pGetParsedAction (obj, action, dataBuilderOpts, {taskRunner = null} = {}) {
		const {
			damageTuples,
			formula,
			offensiveAbility,
			isAttack,
			isRecharge,
			rangeShort,
			rangeLong,
			actionType,
			isProficient,
			attackBonus,
		} = DataConverterActor.getParsedActionEntryData(obj, action, dataBuilderOpts, {mode: "object"});

		const img = await this._pGetSaveImagePath({...obj, _isAttack: isAttack}, {taskRunner});

		const propChild = "objectActionEntries";

		return {
			damageTuples,
			formula,
			offensiveAbility,
			isAttack,
			isRecharge,
			rangeShort,
			rangeLong,
			actionType,
			isProficient,
			attackBonus,
			foundryFlags: {
				[SharedConsts.MODULE_ID]: {
					page: propChild,
					source: action.source || obj.source,
					hash: UrlUtil.URL_TO_HASH_BUILDER[propChild]({
						source: obj.source,
						...action,
						objectName: obj.name,
						objectSource: obj.source,
					}),
				},
			},
			_foundryData: action._foundryData,
			_foundryFlags: action._foundryFlags,
			img,
		};
	}

	static _getImgFallback (obj) {
		if (obj._isAttack) return `modules/${SharedConsts.MODULE_ID}/media/icon/crossed-swords.svg`;
	}
}

var DataConverterObject$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DataConverterObject: DataConverterObject
});

class ImportListObject extends ImportListActor {
	static get ID () { return "objects"; }
	static get DISPLAY_NAME_TYPE_PLURAL () { return "Objects"; }
	static get PROPS () { return ["object"]; }

	static _ = this.registerImpl(this);

	_dirsHomebrew = ["object"];
	_titleSearch = "object";
	_sidebarTab = "actors";
	_gameProp = "actors";
	_defaultFolderPath = ["Objects"];
	_pageFilter = new PageFilterObjects();
	_page = UrlUtil.PG_OBJECTS;
	_isPreviewable = true;
	_isDedupable = true;
	_configGroup = "importObject";
	_pFnGetFluff = Renderer.object.pGetFluff.bind(Renderer.object);
	static _DataConverter = DataConverterObject;

	_actorType = "vehicle";

	async _pGetSources () {
		return [
			new UtilDataSource.DataSourceUrl(
				Config.get("ui", "isStreamerMode") ? "SRD" : "5etools",
				Vetools.DATA_URL_OBJECTS,
				{
					filterTypes: [UtilDataSource.SOURCE_TYP_OFFICIAL_ALL],
					isDefault: true,
				},
			),
			...UtilDataSource.getSourcesCustomUrl(),
			...UtilDataSource.getSourcesUploadFile(),
			...(await this._pGetSourcesPrerelease()),
			...(await this._pGetSourcesBrew()),
		];
	}

	_renderInner_getListSyntax () {
		return new ListSyntaxObjects({
			fnGetDataList: () => this._content,
			pFnGetFluff: this._pFnGetFluff,
		}).build();
	}

	async _pImportEntry_pGetMergedFluff (obj) {
		const fluffBase = Config.get(this._configGroup, "isImportBio") ? await Renderer.object.pGetFluff(obj) : null;
		if (!obj.entries?.length) return fluffBase;

		const out = fluffBase ? MiscUtil.copy(fluffBase) : {};

		out.entries = out.entries || [];
		out.entries.push({type: "entries", entries: obj.entries});

		return out;
	}

	async _pImportEntry_pGetImportMetadata (actor, obj, importOpts, importOptsEntity) {
		const act = {};

		const fluff = await this._pImportEntry_pGetMergedFluff(obj);

		const dataBuilderOpts = new ImportListObject.ImportEntryOpts({actor, fluff});

		await this._pImportEntry_pFillBase(obj, act, dataBuilderOpts.fluff, {isUseTokenImageAsPortrait: Config.get(this._configGroup, "isUseTokenImageAsPortrait"), taskRunner: importOpts.taskRunner});

		act.system = {};

		await this._pImportEntry_pFillFolder(obj, act, importOpts, importOptsEntity);

		if (importOpts.defaultOwnership != null) act.ownership = {default: importOpts.defaultOwnership};
		else act.ownership = {default: Config.get(this._configGroup, "ownership")};
		if (importOpts.userOwnership) Object.assign(act.ownership, importOpts.userOwnership);

		this._pImportEntry_fillData_Abilities(obj, act.system, dataBuilderOpts);
		this._pImportEntry_fillData_Attributes(obj, act.system, dataBuilderOpts);
		await this._pImportEntry_pFillData_Details(obj, act.system, dataBuilderOpts);
		this._pImportEntry_fillData_Traits(obj, act.system, dataBuilderOpts);
		this._pImportEntry_fillData_Currency(obj, act.system, dataBuilderOpts);
		this._pImportEntry_fillData_Cargo(obj, act.system, dataBuilderOpts);

		const additionalData = await this.constructor._DataConverter._pGetDataSideLoaded(obj);
		foundry.utils.mergeObject(act.system, additionalData);

		await this._pImportEntry_pFillToken({importable: obj, actorData: act, flags: this._getTokenFlags({obj}), taskRunner: importOpts.taskRunner});

		return {dataBuilderOpts: dataBuilderOpts, actorData: act};
	}

	_pImportEntry_fillData_Attributes (obj, sys) {
		const out = {};

		out.init = {
			value: 0,
			bonus: 0,
			mod: 0,
			prof: 0,
			total: 0,
		};

		out.spelldc = null;

		if (obj.speed != null) out.movement = DataConverter.getMovement(obj.speed, {configGroup: "importObject"});
		else out.movement = {walk: 0};

		if (typeof obj.ac === "number") {
			out.ac = {flat: obj.ac, motionless: `${obj.ac}`};
		}

		if (typeof obj.hp === "number") {
			out.hp = {
				value: obj.hp,
				min: 0,
				max: obj.hp,
				temp: 0,
				tempmax: 0,
				dt: 0,
				mt: 0,
			};
		}

		if (obj.capCrew != null || obj.capPassenger != null || obj.capCargo != null) {
			out.capacity = {
				creature: Renderer.vehicle.getShipCreatureCapacity(obj),
				cargo: typeof obj.capCargo === "string" ? 0 : obj.capCargo,
			};
		}

		sys.attributes = out;
	}

	async _pImportEntry_pFillData_Details (obj, sys, dataBuilderOpts) {
		const out = {};

		out.biography = {
			value: await this._pGetBiographyValue(obj, dataBuilderOpts.fluff, {isImportText: true, isImportImages: Config.get(this._configGroup, "isImportBioImages")}),
		};

		out.source = UtilDataConverter.getSourceWithPagePart(obj);

		sys.details = out;
	}

	_pImportEntry_fillData_Traits (obj, sys) {
		const out = {};

		out.size = UtilActors.VET_SIZE_TO_ABV[obj.size] || "med";

		this._pImportEntry_fillConditionsDamage(obj, out);

		sys.traits = out;
	}

	_pImportEntry_fillData_Currency (obj, sys) {
				sys.currency = {
			pp: 0,
			gp: 0,
			ep: 0,
			sp: 0,
			cp: 0,
		};
	}

	async _pImportEntry_pFillItems (obj, act, dataBuilderOpts, importOpts) {
		if (obj.actionEntries?.length) {
			for (const actionEntry of obj.actionEntries) await this._pImportEntry_pFillItems_pActionEntry(obj, act, actionEntry, importOpts, dataBuilderOpts);
		}

		const isTemporary = importOpts.isTemp || this._pack != null;
		await UtilActors.pAddActorItems(dataBuilderOpts.actor, dataBuilderOpts.items, {isTemporary});
	}

	async _pImportEntry_pFillItems_pActionEntry (obj, act, ent, importOpts, dataBuilderOpts) {
		if (ent.type === "actions") {
			for (const action of ent.entries) {
				if (typeof action === "object") {
										const cpyAction = MiscUtil.copy(action);

					cpyAction.name = cpyAction.name || ent.name;
					if (action.type === "attack" && cpyAction.attackEntries?.length === 1 && cpyAction.hitEntries?.length === 1 && typeof cpyAction.attackEntries[0] === "string" && typeof cpyAction.hitEntries[0] === "string") {
						cpyAction.entries = [
							`{@atk ${action.attackType.toLowerCase()}} ${cpyAction.attackEntries[0]} {@h}${cpyAction.hitEntries[0]}`,
						];

						delete cpyAction.attackEntries;
						delete cpyAction.hitEntries;
					}

					await this._pImportEntry_pFillItems_pActionEntry(obj, act, cpyAction, importOpts, dataBuilderOpts);
				} else {
					await this._pImportEntry_pFillItems_pActionEntry(obj, act, action, importOpts, dataBuilderOpts);
				}
			}
			return;
		}

		ent = typeof ent === "object" ? ent : {name: "Unnamed Action", entries: [ent]};

		const description = await DataConverter.pGetEntryDescription(ent);
		const strEntries = ent.entries ? JSON.stringify(ent.entries) : null;

		const {
			damageTuples,
			formula,
			isAttack,
			isRecharge,
			rangeShort,
			rangeLong,
			actionType,
			isProficient,
			attackBonus,
			_foundryData,
			foundrySystem,
			_foundryFlags,
			foundryFlags,
			img,
		} = await DataConverterObject.pGetParsedAction(obj, ent, dataBuilderOpts, {taskRunner: importOpts.taskRunner});

		const damageParts = damageTuples;

				const {
			saveAbility,
			saveScaling,
			saveDc,
		} = this._getSavingThrowData(strEntries);
		
				if (isAttack) {
			await this._pFillWeaponItem(
				obj,
				act,
				ent,
				importOpts,
				dataBuilderOpts,
				{
					damageParts,
					formula,
					rangeShort,
					rangeLong,
					actionType,
					isProficient,
					description,
					saveAbility,
					saveDc,
					saveScaling,
					attackBonus,
					_foundryData,
					foundrySystem,
					_foundryFlags,
					foundryFlags,
					img,
					isSiegeWeapon: obj.objectType === "SW",
					isRecharge,
				},
			);
		} else {
			dataBuilderOpts.items.push(await DataConverter.pGetItemActorPassive(
				ent,
				{
					mode: "creature",
					fvttType: "feat",
					activationType: "action",
					activationCost: 1,
					description,
					saveAbility,
					saveDc,
					saveScaling,
					damageParts,
					formula,
					attackBonus,
					_foundryData,
					foundrySystem,
					_foundryFlags,
					foundryFlags,
					img,
					entity: obj,
					source: obj.source,
					actor: {system: act}, 				},
			));
		}
	}

	_pImportEntry_fillData_Cargo (obj, sys) {
				sys.cargo = {
			crew: [],
			passengers: [],
		};
	}

	_getTokenFlags ({obj}) {
		if (!UtilCompat.isMonksLittleDetailsActive()) return null;
		return {[UtilCompat.MODULE_MONKS_BLOODSPLATS]: {"bloodsplat-colour": "#00000000"}};
	}
}

ImportListObject.ImportEntryOpts = class extends ImportListActor.ImportEntryOpts {};

var ImportListObject$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ImportListObject: ImportListObject
});

class PageFilterVehiclesFvtt extends MixinPageFilterThreeDi(PageFilterVehicles) {}

class ThreeDiTokenAdapterVehicle extends ThreeDiTokenAdapterBase {
	static _getFilePath () { return Vetools.getModuleDataUrl(`foundry-vehicles-integration-3d-tokens.json`); }
	_getHash (ent) { return UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_VEHICLES](ent); }
}

class ImportCustomizerVehicle extends ImportCustomizerActor {
	_threeDiTokenAdapter = new ThreeDiTokenAdapterVehicle();

	get template () { return `${SharedConsts.MODULE_LOCATION}/template/ImportListVehicleCustomizer.hbs`; }
}

class ImportListVehicle extends ImportListActor {
	static get ID () { return "vehicles"; }
	static get DISPLAY_NAME_TYPE_PLURAL () { return "Vehicles"; }
	static get PROPS () { return ["vehicle"]; }

	static _ = this.registerImpl(this);

	_dirsHomebrew = ["vehicle"];
	_titleSearch = "vehicle";
	_sidebarTab = "actors";
	_gameProp = "actors";
	_defaultFolderPath = ["Vehicles"];
	_pageFilter = new PageFilterVehiclesFvtt();
	_page = UrlUtil.PG_VEHICLES;
	_isPreviewable = true;
	_isDedupable = true;
	_configGroup = "importVehicle";
	_pFnGetFluff = Renderer.vehicle.pGetFluff.bind(Renderer.vehicle);
	_ClsCustomizer = ImportCustomizerVehicle;
	static _DataConverter = DataConverterVehicle;

	_actorType = "vehicle";
	_threeDiTokenAdapter = new ThreeDiTokenAdapterVehicle();

	_renderInner_getListSyntax () {
		return new ListSyntaxVehicles({
			fnGetDataList: () => this._content,
			pFnGetFluff: this._pFnGetFluff,
		}).build();
	}

	async _pGetSources () {
		return [
			new UtilDataSource.DataSourceUrl(
				Config.get("ui", "isStreamerMode") ? "SRD" : "5etools",
				Vetools.DATA_URL_VEHICLES,
				{
					filterTypes: [UtilDataSource.SOURCE_TYP_OFFICIAL_ALL],
					isDefault: true,
					pPostLoad: this._postLoad_setHasTokenThreeDiFlag.bind(this),
				},
			),
			...UtilDataSource.getSourcesCustomUrl(),
			...UtilDataSource.getSourcesUploadFile(),
			...(await this._pGetSourcesPrerelease()),
			...(await this._pGetSourcesBrew()),
		];
	}

	getData () {
		return {
			...super.getData(),
			buttonsAdditional: [
				{
					name: "btn-run-mods",
					text: "Customize and Import...",
				},
			],
		};
	}

	async _pImportEntry_pGetImportMetadata (actor, veh, importOpts, importOptsEntity) {
		const act = {};

		const fluff = await Renderer.vehicle.pGetFluff(veh);

		const vehOpts = new ImportListVehicle.ImportEntryOpts({actor, fluff});

		await this._pImportEntry_pFillBase(veh, act, vehOpts.fluff, {isUseTokenImageAsPortrait: Config.get(this._configGroup, "isUseTokenImageAsPortrait"), taskRunner: importOpts.taskRunner});

		act.system = {};

		await this._pImportEntry_pFillFolder(veh, act, importOpts, importOptsEntity);

		if (importOpts.defaultOwnership != null) act.ownership = {default: importOpts.defaultOwnership};
		else act.ownership = {default: Config.get(this._configGroup, "ownership")};
		if (importOpts.userOwnership) Object.assign(act.ownership, importOpts.userOwnership);

		act.system.vehicleType = this._pImportEntry_getVehicleType(veh);

		this._pImportEntry_fillData_Abilities(veh, act.system, vehOpts);
		this._pImportEntry_fillData_Attributes(veh, act.system, vehOpts);
		await this._pImportEntry_pFillData_Details(veh, act.system, vehOpts);
		this._pImportEntry_fillData_Traits(veh, act.system, vehOpts);
		this._pImportEntry_fillData_Currency(veh, act.system, vehOpts);
		this._pImportEntry_fillData_Cargo(veh, act.system, vehOpts);

		const additionalData = await this.constructor._DataConverter._pGetDataSideLoaded(veh);
		foundry.utils.mergeObject(act.system, additionalData);

		await this._pImportEntry_pFillToken({importable: veh, actorData: act, size: this._getSize(veh), flags: this._getTokenFlags({veh}), taskRunner: importOpts.taskRunner});

		return {dataBuilderOpts: vehOpts, actorData: act};
	}

	_pImportEntry_getVehicleType (veh) {
		if (veh.terrain?.length) {
			const terr = veh.terrain[0];
			switch (terr) {
				case "land": return "land";
				case "sea": return "water";
				case "air": return "air";
				case "space": return "space";
				default: console.warn(...LGT, `Unknown vehicle terrain type "${terr}"`);
			}
		}

		switch (veh.vehicleType) {
			case "INFWAR": return "land";
			case "SHIP": return "sea";
			case "SPELLJAMMER": return "space";
			default: throw new Error(`Unhandled vehicle type "${veh.vehicleType}"`);
		}
	}

		async _pImportEntry (veh, importOpts, dataOpts) {
		importOpts = importOpts || {};

		if (veh.vehicleType === "CREATURE") {
			const importerCreature = new ImportListCreature({});
			await importerCreature.pInit();
			await importerCreature.pSyncStateFrom(this);
									veh = MiscUtil.copy(veh);
			veh.tokenUrl = await Vetools.pGetTokenUrl("vehicle", veh);
			return importerCreature._pImportEntry(veh, importOpts, dataOpts);
		} else if (veh.vehicleType === "OBJECT") {
			const objectImporter = new ImportListObject({});
			await objectImporter.pInit();
			await objectImporter.pSyncStateFrom(this);
									veh = MiscUtil.copy(veh);
			veh.tokenUrl = await Vetools.pGetTokenUrl("object", veh);
			return objectImporter._pImportEntry(veh, importOpts, dataOpts);
		}

		return super._pImportEntry(veh, importOpts, dataOpts);
	}

	_pImportEntry_fillData_Attributes (veh, sys) {
		const out = {};

		out.init = {
			value: 0,
			bonus: 0,
			mod: 0,
			prof: 0,
			total: 0,
		};

		out.spelldc = null;

		out.movement = DataConverterVehicle.getShipMovement(veh);

		switch (veh.vehicleType) {
			case "INFWAR": {
				const dexMod = Parser.getAbilityModNumber(veh.dex);
				out.ac = {
					flat: 19 + dexMod,
					motionless: "19",
				};

				out.hp = {
					value: MiscUtil.get(veh, "hp", "hp") || 0,
					min: 0,
					max: MiscUtil.get(veh, "hp", "hp") || 0,
					temp: 0,
					tempmax: 0,
					dt: MiscUtil.get(veh, "hp", "dt") || 0,
					mt: MiscUtil.get(veh, "hp", "mt") || 0,
				};

				out.actions = {
					stations: true,
					value: 0,
					thresholds: {
						0: 0,
						1: 0,
						2: 0,
					},
				};

				out.capacity = {
					creature: Renderer.vehicle.getInfwarCreatureCapacity(veh),
					cargo: typeof veh.capCargo === "string" ? 0 : veh.capCargo,
				};

				break;
			}

			case "SHIP":
			case "SPELLJAMMER": {
				out.ac = {
					flat: MiscUtil.get(veh, "hull", "ac") || null,
					motionless: "",
				};

				out.hp = {
					value: MiscUtil.get(veh, "hull", "hp") || null,
					min: null,
					max: MiscUtil.get(veh, "hull", "hp") || null,
					temp: null,
					tempmax: null,
					dt: MiscUtil.get(veh, "hull", "dt") || null,
					mt: null,
				};

				let actionsValue = 0;
				const actionThresholds = {
					0: 0,
					1: 0,
					2: 0,
				};
				if (veh.actionThresholds) {
					Object.entries(veh.actionThresholds)
						.sort(([ka], [kb]) => SortUtil.ascSort(Number(kb), Number(ka)))
						.slice(0, 3) 						.forEach(([actions, crew], i) => {
							actionThresholds[i] = crew;
						});
				}

				out.actions = {
					stations: false,
					value: actionsValue,
					thresholds: actionThresholds,
				};

				out.capacity = {
					creature: Renderer.vehicle.getShipCreatureCapacity(veh),
					cargo: typeof veh.capCargo === "string" ? 0 : veh.capCargo,
				};

				break;
			}

			default: throw new Error(`Unhandled vehicle type "${veh.vehicleType}"`);
		}

		sys.attributes = out;
	}

	async _pImportEntry_pFillData_Details (veh, sys, vehOpts) {
		const out = {};

		out.biography = {
			value: await this._pGetBiographyValue(veh, vehOpts.fluff, {isImportText: Config.get(this._configGroup, "isImportBio"), isImportImages: Config.get(this._configGroup, "isImportBioImages")}),
		};

		out.source = UtilDataConverter.getSourceWithPagePart(veh);

		sys.details = out;
	}

	_pImportEntry_fillData_Traits (veh, sys) {
		const out = {};

		out.size = UtilActors.VET_SIZE_TO_ABV[this._getSize(veh)];

		switch (veh.vehicleType) {
			case "INFWAR": {
				out.dimensions = `${veh.weight.toLocaleString()} lb.`;
				break;
			}

			case "SHIP":
			case "SPELLJAMMER": {
				out.dimensions = veh.dimensions ? veh.dimensions.join(" by ") : "";
				break;
			}

			default: throw new Error(`Unhandled vehicle type "${veh.vehicleType}"`);
		}

		this._pImportEntry_fillConditionsDamage(veh, out);

		sys.traits = out;
	}

	_getSize (veh) {
		if (veh.size) return veh.size;
		return this._getSizeFromDimensions(veh.dimensions) || Parser.SZ_MEDIUM;
	}

	_getSizeFromDimensions (dimensions) {
		if (!dimensions?.length) return null;

		const dimensionVals = dimensions
			.map(it => {
				const mFt = /^(?<feet>\d+) (?:ft\.|feet|foot)/i.exec(it);
				if (!mFt) return null;
				return Number(mFt.groups.feet);
			})
			.filter(Boolean);

		if (!dimensionVals.length) return null;

		const biggestD = Math.max(...dimensionVals);

		if (biggestD >= 20) return Parser.SZ_GARGANTUAN;
		if (biggestD >= 15) return Parser.SZ_HUGE;
		if (biggestD >= 10) return Parser.SZ_LARGE;
		if (biggestD >= 5) return Parser.SZ_MEDIUM;
		if (biggestD >= 2) return Parser.SZ_SMALL;
		return Parser.SZ_TINY;
	}

	_pImportEntry_fillData_Currency (veh, sys) {
				sys.currency = {
			pp: 0,
			gp: 0,
			ep: 0,
			sp: 0,
			cp: 0,
		};
	}

	async _pImportEntry_pFillItems (veh, act, vehOpts, importOpts) {
		await this._pImportEntry_pFillItems_ship(veh, act, vehOpts, importOpts);
		await this._pImportEntry_pFillItems_infWar(veh, act, vehOpts, importOpts);

		const isTemporary = importOpts.isTemp || this._pack != null;
		await UtilActors.pAddActorItems(vehOpts.actor, vehOpts.items, {isTemporary});
	}

	async _pImportEntry_pFillItems_ship (veh, act, vehOpts, importOpts) {
		if (veh.control) { 			await veh.control.pSerialAwaitMap(it => this._pAddShipEquipment(veh, act, vehOpts, importOpts, it, "control"));
		}

		if (veh.movement) { 			await veh.movement.pSerialAwaitMap(it => this._pAddShipEquipment(veh, act, vehOpts, importOpts, it, "movement"));
		}

		if (veh.weapon) { 			await veh.weapon.pSerialAwaitMap(it => this._pAddShipWeapon(veh, act, vehOpts, importOpts, it, "weapon"));
		}

		if (veh.other) { 			await veh.other.pSerialAwaitMap(it => this._pAddShipOther(veh, act, vehOpts, importOpts, it, "other"));
		}

		if (veh.action) { 			await this._pAddShipAction(veh, act, vehOpts, importOpts, veh.action, "action");
		}
	}

	async _pAddShipEquipment (veh, act, vehOpts, importOpts, equipment, prop) {
		const equipmentItem = await DataConverterVehicle.pGetShipEquipmentItem(veh, equipment, prop);
		if (!equipmentItem) return;
		vehOpts.items.push(equipmentItem);
	}

	async _pAddShipWeapon (veh, act, vehOpts, importOpts, weap, prop) {
		const weaponItems = await DataConverterVehicle.pGetShipWeaponItems(veh, weap, prop);
		if (!weaponItems?.length) return;
		vehOpts.items.push(...weaponItems);
	}

	async _pAddShipOther (veh, act, vehOpts, importOpts, ent, prop) {
		const otherItem = await DataConverterVehicle.pGetShipOtherItem(veh, ent, prop);
		if (!otherItem) return;
		vehOpts.items.push(otherItem);
	}

	async _pAddShipAction (veh, act, vehOpts, importOpts, actionEnts, prop) {
		const actionItems = await DataConverterVehicle.pGetShipActionItems(veh, actionEnts, prop);
		if (!actionItems || !actionItems.length) return;
		vehOpts.items.push(...actionItems);
	}

	async _pImportEntry_pFillItems_infWar (veh, act, vehOpts, importOpts) {
		if (veh.trait) { 			await veh.trait.pSerialAwaitMap(it => this._pAddInfWarTrait(veh, act, vehOpts, importOpts, it));
		}

		if (veh.actionStation) { 			await veh.actionStation.pSerialAwaitMap(it => this._pAddInfWarActionStation(veh, act, vehOpts, importOpts, it, "actionStation"));
		}

		if (veh.reaction) { 			await veh.reaction.pSerialAwaitMap(it => this._pAddInfWarReaction(veh, act, vehOpts, importOpts, it));
		}
	}

	async _pAddInfWarTrait (veh, act, vehOpts, importOpts, trait) {
		const traitItem = await DataConverter.pGetItemActorPassive(
			trait,
			{
				fvttType: "feat",
				mode: "vehicle",
				entity: veh,
				source: veh.source,
				actor: {system: act}, 				img: `modules/${SharedConsts.MODULE_ID}/media/icon/gears.svg`,
				foundryFlags: DataConverterVehicle.getVehicleChildFlags({
					veh,
					prop: "trait",
					entry: trait,
				}),
			},
		);
		vehOpts.items.push(traitItem);
	}

	async _pAddInfWarActionStation (veh, act, vehOpts, importOpts, action, prop) {
		const actionStationItem = await DataConverterVehicle.pGetInfWarActionItem(veh, action, prop);
		if (!actionStationItem) return;
		vehOpts.items.push(actionStationItem);
	}

	async _pAddInfWarReaction (veh, act, vehOpts, importOpts, reaction) {
		const reactionItem = await DataConverter.pGetItemActorPassive(
			reaction,
			{
				activationType: "reaction",
				activationCost: 1,
				fvttType: "feat",
				mode: "vehicle",
				entity: veh,
				source: veh.source,
				actor: {system: act}, 				img: `modules/${SharedConsts.MODULE_ID}/media/icon/gears.svg`,
				foundryFlags: DataConverterVehicle.getVehicleChildFlags({
					veh,
					prop: "reaction",
					entry: reaction,
				}),
			},
		);
		vehOpts.items.push(reactionItem);
	}

	_pImportEntry_fillData_Cargo (veh, sys) {
				sys.cargo = {
			crew: [],
			passengers: [],
		};
	}

	_getTokenFlags ({veh}) {
		if (!UtilCompat.isMonksLittleDetailsActive()) return null;
		return {[UtilCompat.MODULE_MONKS_BLOODSPLATS]: {"bloodsplat-colour": "#00000000"}};
	}
}

ImportListVehicle.ImportEntryOpts = class extends ImportListActor.ImportEntryOpts {};

var ImportListVehicle$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ImportListVehicle: ImportListVehicle
});

class DataConverterVehicleUpgrade extends DataConverterFeature {
	static _SIDE_LOAD_OPTS = {
		propBrew: "foundryVehicleUpgrade",
		fnLoadJson: async () => this._pGetPreloadSideData(),
		propJson: "vehicleUpgrade",
	};

	static _IMG_FALLBACK = `modules/${SharedConsts.MODULE_ID}/media/icon/gears.svg`;

	static init () {
		PageFilterClassesFoundry.setImplSideData("vehicleUpgrade", this);
	}

	static async pGetDereferencedFeatureItem (feature) {
				if (feature.entries) return MiscUtil.copy(feature);

		const hash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_VEHICLES](feature);
		return DataLoader.pCacheAndGet(UrlUtil.PG_VEHICLES, feature.source, hash, {isCopy: true});
	}

	static async pGetInitFeatureLoadeds (feature, {actor = null} = {}) {
		const asFeatRef = {vehicleUpgrade: `${feature.name}|${feature.source}`};
				await PageFilterClassesFoundry.pInitVehicleUpgradeLoadeds({vehicleUpgrade: asFeatRef, raw: feature, actor});
		return asFeatRef;
	}

		static async pGetDocumentJson (vehUpgrade, opts) {
		opts = opts || {};
		if (opts.actor) opts.isActorItem = true;

		Renderer.get().resetHeaderIndex();

		return this._pGetVehicleUpgradeItem_other(vehUpgrade, opts);
	}

	static async _pGetVehicleUpgradeItem_other (vehUpgrade, opts) {
		const descriptionValue = await this._pGetDescriptionValue(vehUpgrade);

		const tempAdditionalData = vehUpgrade._foundryData || {};
		const additionalData = await this._pGetDataSideLoaded(vehUpgrade);
		const additionalFlags = await this._pGetFlagsSideLoaded(vehUpgrade);
		const img = await this._pGetSaveImagePath(vehUpgrade, {taskRunner: opts.taskRunner});

		const effectsSideTuples = await this._pGetEffectsSideLoadedTuples({en: vehUpgrade, img, actor: opts.actor});
		effectsSideTuples.forEach(({effect, effectRaw}) => DataConverter.mutEffectDisabledTransfer(effect, this._configGroup, UtilActiveEffects.getDisabledTransferHintsSideData(effectRaw)));

		const out = {
			name: UtilApplications.getCleanEntityName(UtilDataConverter.getNameWithSourcePart(vehUpgrade, {isActorItem: opts.isActorItem})),
			system: {
				source: UtilDataConverter.getSourceWithPagePart(vehUpgrade),
				description: {value: descriptionValue, chat: "", unidentified: ""},

				activation: {type: "", cost: 0, condition: ""},
				duration: {value: 0, units: ""},
				target: {value: 0, units: "", type: ""},
				range: {value: 0, long: 0, units: null},
				uses: {value: 0, max: 0, per: ""},
				ability: "",
				actionType: "",
				attackBonus: null,
				chatFlavor: "",
				critical: {threshold: null, damage: ""},
				damage: {parts: [], versatile: ""},
				formula: "",
				save: {ability: "", dc: null},
				requirements: tempAdditionalData.requirements || "",
				recharge: {value: 0, charged: true},

				...additionalData,
			},
			ownership: {default: 0},
			type: "feat",
			img,
			flags: {
				...this._getVehicleUpgradeFlags(vehUpgrade, opts),
				...additionalFlags,
			},
			effects: DataConverter.getEffectsMutDedupeId(effectsSideTuples.map(it => it.effect)),
		};

		if (opts.defaultOwnership != null) out.ownership = {default: opts.defaultOwnership};
		else if (opts.isAddDefaultOwnershipFromConfig) out.ownership = {default: Config.get("importVehicleUpgrade", "ownership")};
		if (opts.userOwnership) Object.assign(out.ownership, opts.userOwnership);

		return out;
	}

	static _pGetDescriptionValue (vehUpgrade) {
		if (!Config.get("importVehicleUpgrade", "isImportDescription")) return "";

		return UtilDataConverter.pGetWithDescriptionPlugins(() => {
			return `<div>
				<p><i>${Renderer.vehicle.getUpgradeSummary(vehUpgrade)}</i></div></p>
				${Renderer.get().setFirstSection(true).render({entries: vehUpgrade.entries}, 1)}
			</div>`;
		});
	}

	static _getVehicleUpgradeFlags (vehUpgrade, opts) {
		opts = opts || {};

		const out = {
			[SharedConsts.MODULE_ID]: {
				page: UrlUtil.PG_VEHICLES,
				source: vehUpgrade.source,
				hash: UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_VEHICLES](vehUpgrade),
			},
		};

		if (opts.isAddDataFlags) {
			out[SharedConsts.MODULE_ID].propDroppable = "vehicleUpgrade";
			out[SharedConsts.MODULE_ID].filterValues = opts.filterValues;
		}

		return out;
	}

	static async _pGetPreloadSideData () {
		if (!this._SIDE_DATA) this._SIDE_DATA = await Vetools.pGetVehicleUpgradeSideData();
		return this._SIDE_DATA;
	}
}

var DataConverterVehicleUpgrade$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DataConverterVehicleUpgrade: DataConverterVehicleUpgrade
});

class ImportListVehicleUpgrade extends ImportListFeature {
		static init () {
		this._initCreateSheetItemHook({
			prop: "vehicleUpgrade",
			importerName: "Vehicle Upgrades",
		});
	}
	
	static get ID () { return "vehicle-upgrades"; }
	static get DISPLAY_NAME_TYPE_PLURAL () { return "Vehicle Upgrades"; }
	static get PROPS () { return ["vehicleUpgrade"]; }

	static _ = this.registerImpl(this);

	_dirsHomebrew = ["vehicleUpgrade"];
	_titleSearch = "vehicle upgrade";
	_sidebarTab = "items";
	_gameProp = "items";
	_defaultFolderPath = ["Vehicles Upgrades"];
	_pageFilter = new PageFilterVehicles();
	_page = UrlUtil.PG_VEHICLES;
	_isPreviewable = true;
	_isDedupable = true;
	_configGroup = "importVehicleUpgrade";
	_pFnGetFluff = Renderer.vehicle.pGetFluff.bind(Renderer.vehicle);
	static _DataConverter = DataConverterVehicleUpgrade;

	async _pGetSources () {
		return [
			new UtilDataSource.DataSourceUrl(
				Config.get("ui", "isStreamerMode") ? "SRD" : "5etools",
				Vetools.DATA_URL_VEHICLES,
				{
					filterTypes: [UtilDataSource.SOURCE_TYP_OFFICIAL_ALL],
					isDefault: true,
				},
			),
			...UtilDataSource.getSourcesCustomUrl(),
			...UtilDataSource.getSourcesUploadFile(),
			...(await this._pGetSourcesPrerelease()),
			...(await this._pGetSourcesBrew()),
		];
	}

	_renderInner_getListSyntax () {
		return new ListSyntaxVehicles({
			fnGetDataList: () => this._content,
			pFnGetFluff: this._pFnGetFluff,
		}).build();
	}

	_colWidthName = 8;
	_colWidthSource = 1;

	_getData_cols_otherPre () {
		return [
			{
				name: "Type",
				width: 2,
				field: "type",
				rowClassName: "text-center",
			},
		];
	}

	_getData_row_mutGetAdditionalValues ({it, ix}) {
		it._lTime = it.time ? it.time.map(tm => PageFilterActions.getTimeText(tm)).join("/") : "\u2014";

		return {
			type: it.upgradeType,
		};
	}

	_renderInner_absorbListItems_fnGetValues (it) {
		return {
			...super._renderInner_absorbListItems_fnGetValues(it),
			type: it.upgradeType,
		};
	}
}

var ImportListVehicleUpgrade$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ImportListVehicleUpgrade: ImportListVehicleUpgrade
});

class UtilAdventureBook {
	static doProcessNode_mutAddMaps (
		{
			availableMaps,
			entryIdToMap,
			entryIdToName,
			entry,
			entryStack,
			source,
			chapterInfo,
		},
	) {
		if (entry.id && entry.name) entryIdToName[entry.id] = entry.name;

		if (entry.type !== "image" || !UtilAdventureBook._IMPORTABLE_IMAGE_TYPES__MAP.has(entry.imageType)) return;

		const url = Vetools.getImageUrl(entry);
		if (!url) return; 

		const mapEntry = MiscUtil.getOrSet(availableMaps, entry.imageType, url, MiscUtil.copy(entry));
		mapEntry.title = mapEntry.title || entry.title;

		mapEntry._url = url;

		
		mapEntry.source = mapEntry.source || source;

		
		if (chapterInfo) {
			mapEntry._chapterName = `${Parser.bookOrdinalToAbv(chapterInfo.ordinal)}${chapterInfo.name || "(Unnamed Chapter)"}`;
		}

		
		if (entryStack?.length) {
			mapEntry._tmp_parentEntryName = [...entryStack].reverse().find(it => it.name)?.name;
		}

		if (entry.id) entryIdToMap[entry.id] = MiscUtil.copy(entry);
	}

	
	static mutMapNames ({availableMaps, entryIdToMap, entryIdToName}) {
		Object.values(availableMaps)
			.forEach(urlToEntry => {
				Object.values(urlToEntry)
					.forEach(entry => {
						this._mutMapNames_entry({entryIdToMap, entryIdToName, entry});
					});
			});
	}

	static _mutMapNames_entry ({entryIdToMap, entryIdToName, entry}) {
		
		if (entry.mapRegions) {
			entry.mapRegions.forEach(it => {
				it.name = it.name || entryIdToName[it.area];
			});
		}
		

		const parentEntry = entry.mapParent?.id ? entryIdToMap[entry.mapParent.id] : null;
		if (parentEntry) this._mutMapNames_entry({entryIdToMap, entryIdToName, entry: parentEntry});

		
		entry.name = this._getMapName({entry, parentEntry});

		
		entry._parentEntry = parentEntry;
	}

	static _getMapName ({entry, parentEntry}) {
		if (entry.mapName) return entry.mapName;

		const cleanTitle = Renderer.stripTags(entry.title);

		const name = cleanTitle
			
			|| (entry._tmp_parentEntryName ? `${entry._tmp_parentEntryName}\u2013Map` : UtilAdventureBook._DEFAULT_MAP_NAME);

		if (!parentEntry || !parentEntry.title) return name;

		const cleanParentTitle = Renderer.stripTags(parentEntry.title);

		
		const entryTitleClean = (cleanTitle || "").replace(/[^a-zA-Z]+/g, "");
		if (!/^player(?:version)?$/i.test(entryTitleClean)) return name;

		return `${cleanParentTitle} (Player Version)`;
	}
}
UtilAdventureBook._IMPORTABLE_IMAGE_TYPES__MAP = new Set(["map", "mapPlayer"]);
UtilAdventureBook._DEFAULT_MAP_NAME = "(Unnamed Map)";

class ImportListAdventureBook extends ImportList {
	static get FOLDER_TYPE () { return "JournalEntry"; }

		static get defaultOptions () {
		return mergeObject(super.defaultOptions, {
			template: `${SharedConsts.MODULE_LOCATION}/template/ImportListAdventureBook.hbs`,
			width: 480,
			height: Util.getMaxWindowHeight(640),
			resizable: true,
			title: `Import ${this.DISPLAY_NAME_TYPE_SINGLE}`,
		});
	}

	_sidebarTab = "journal";
	_gameProp = "journal";
	_isNonCacheableInstance = true;

	_fnGetIndex;
	_dataProp;
	_brewDataProp;
	_title;

	constructor (...args) {
		super(...args);

				this._availableEntities = null;
		this._availableInlineData = null;
		this._$cbText = null;
		this._tagCbMetas = null;
		this._imageGroupCbMetas = null;
		this._availableMaps = {};
		this._entryIdToMap = {};
		this._entryIdToName = {};
	}

		get isRadio () { return true; }

	async _pGetSources () {
		const index = await this._fnGetIndex();

		const data = index[this._dataProp]
			.sort((a, b) => SortUtil.ascSortDate(b._pubDate, a._pubDate) || SortUtil.ascSortLower(a.name, b.name));

		return [
			...data.map(it => new UtilDataSource.DataSourceUrl(
				it.name,
				it._url,
				{
					pPostLoad: this._postLoadVetools.bind(this),
					userData: it,
					filterTypes: SourceUtil.isNonstandardSource(it.source)
						? [UtilDataSource.SOURCE_TYP_EXTRAS]
						: [UtilDataSource.SOURCE_TYP_OFFICIAL_SINGLE],
					source: it.source,
				}),
			),
			...UtilDataSource.getSourcesCustomUrl({pPostLoad: this._pPostLoadOther.bind(this)}),
			...UtilDataSource.getSourcesUploadFile({pPostLoad: this._pPostLoadOther.bind(this)}),
			...(await this._pGetSourcesPrerelease({pPostLoad: this._pPostLoadOther.bind(this)})),
			...(await this._pGetSourcesBrew({pPostLoad: this._pPostLoadOther.bind(this)})),
		];
	}

	_postLoadVetools (data, userData) {
		data = MiscUtil.copy(data);
		data._contentMetadata = MiscUtil.copy(userData);
		return data;
	}

	async _pPostLoadOther (data) {
		if (!data[this._dataProp] || !data[this._brewDataProp]) {
			ui.notifications.error(`File did not contain importable data\u2014one of "${this._dataProp}" and "${this._brewDataProp}" was missing!`);
			return null;
		}

		data = MiscUtil.copy(data);

		const importableTuples = data[this._dataProp].map(head => {
			const body = data[this._brewDataProp].find(it => it.id === head.id);
			if (!body) return null;
			return {
				head,
				body: body.data,
			};
		}).filter(Boolean);

		if (!importableTuples.length) {
			ui.notifications.error(`File did not contain importable data\u2014could not link any "${this._dataProp}" and "${this._brewDataProp}" items together!`);
			return null;
		}

		let chosenTuple;
		if (importableTuples.length === 1) chosenTuple = importableTuples[0];
		else {
			const chosenId = await InputUiUtil.pGetUserEnum({
				values: importableTuples.map(it => it.head.id),
				fnDisplay: value => {
					const indexItem = importableTuples.find(it => it.head.id === value);
					return `${indexItem.head.name} (${Parser.sourceJsonToAbv(indexItem.head.source)})`;
				},
				title: `Choose ${this._title}`,
				default: 0,
				isAllowNull: false,
				isResolveItem: true,
			});

			if (chosenId == null) return null;

			chosenTuple = importableTuples.find(it => it.head.id === chosenId);
		}

		const headContents = MiscUtil.get(chosenTuple, "head", "contents");
		const bodyData = MiscUtil.get(chosenTuple, "body");
		if (!headContents || !bodyData) {
			ui.notifications.error(`Could not import\u2014one of "${this._dataProp}[].contents" and "${this._brewDataProp}[].data" was missing!`);
			return null;
		}

		if (headContents.length !== bodyData.length) {
			ui.notifications.error(`Could not import\u2014header and chapter counts differed!`);
			return null;
		}

		return {
			_contentMetadata: chosenTuple.head,
			data: chosenTuple.body,
		};
	}

	getFolderPathMeta () {
		return {
			name: {
				label: "Name",
				getter: it => it.name,
			},
			...super.getFolderPathMeta(),
			published: {
				label: "Publication Date (Full)",
				getter: it => {
					if (!it.published) return "\u2014";
					const date = new Date(it.published);
					return DatetimeUtil.getDateStr({date});
				},
			},
			publishedFull: {
				label: "Publication Date (Short)",
				getter: it => {
					if (!it.published) return "\u2014";
					return it.published;
				},
			},
			publishedYear: {
				label: "Publication Year",
				getter: it => {
					if (!it.published) return "\u2014";
					return new Date(it.published).getFullYear();
				},
			},
		};
	}

	getData () {
		try {
			return this._getData();
		} catch (e) {
			ui.notifications.error(`Failed to pre-process data! ${VeCt.STR_SEE_CONSOLE}`);
			throw e;
		}
	}

	_getData () {
		this._content = MiscUtil.copy(this._content);

		this._availableEntities = {};
		this._availableInlineData = {};

		const tagWalker = MiscUtil.getWalker({
			keyBlocklist: ImportListAdventureBook._TAG_WALKER_BLOCKLIST,
		});

				const fromInline = {};

		const source = this._content._contentMetadata.source || this._content._contentMetadata.id;

				Object.values(ImportListAdventureBook._IMPORTABLE_TAGS)
			.filter(it => it.fnGetInlineData && it.fnGetInlineHash)
			.forEach(importable => {
				const pack = {
					[this._dataProp]: this._content._contentMetadata,
					[this._brewDataProp]: {data: this._content.data},
				};
				const nxtOpts = {
					headProp: this._dataProp,
					bodyProp: this._brewDataProp,
				};

				const hashes = new Set();
				this._availableInlineData[importable.tag] = importable.fnGetInlineData(pack, nxtOpts)
					.sort((a, b) => {
						return SortUtil.ascSortLower(a.name, b.name)
							|| SortUtil.ascSortLower(Parser.sourceJsonToFull(a.source || source), Parser.sourceJsonToFull(b.source || source));
					})
					.filter(it => {
						const hash = importable.fnGetInlineHash(it);
																								hashes.add(hash);
						return true;
					});

				fromInline[importable.tag] = hashes;
			});
		
				this._content.data.forEach((chapter, ixChapter) => {
			const handlers = {
				string: (str) => {
					const tagSplit = Renderer.splitByTags(str);
					const len = tagSplit.length;
					for (let i = 0; i < len; ++i) {
						const s = tagSplit[i];
						if (!s) continue;
						if (!s.startsWith("{@")) continue;

						const [tag, text] = Renderer.splitFirstSpace(s.slice(1, -1));
						const importableTag = ImportListAdventureBook._IMPORTABLE_TAGS[tag];
						if (!importableTag) continue;

						const extractedTag = importableTag._extractTag(text);
						if (!extractedTag) continue;

						if (fromInline[tag] && fromInline[tag].has(extractedTag.hash)) continue;

						(this._availableEntities[tag] = this._availableEntities[tag] || {})[extractedTag.source] =
							this._availableEntities[tag][extractedTag.source] || new Set();
						this._availableEntities[tag][extractedTag.source].add(extractedTag.hash);
					}
					return str;
				},
				object: (obj, lastKey, stack) => {
					UtilAdventureBook.doProcessNode_mutAddMaps({
						availableMaps: this._availableMaps,
						entryIdToMap: this._entryIdToMap,
						entryIdToName: this._entryIdToName,
						entry: obj,
						entryStack: stack,
						source,
						chapterInfo: this._content._contentMetadata.contents?.[ixChapter],
					});
					return obj;
				},
			};

			tagWalker.walk(chapter, handlers, undefined, []);
		});
		
				UtilAdventureBook.mutMapNames({availableMaps: this._availableMaps, entryIdToMap: this._entryIdToMap, entryIdToName: this._entryIdToName});

		Object.values(ImportListAdventureBook._IMPORTABLE_TAGS)
			.forEach(importable => {
				const additionalContent = this._getAdditionalContentForTag(importable.tag);
				if (!additionalContent?.length) return;

				additionalContent.forEach(({source, hash}) => {
					source = source.toLowerCase();
					const tgt = MiscUtil.getOrSet(this._availableEntities, importable.tag, source, new Set());
					tgt.add(hash);
				});
			});

		const tagSections = Object.entries(ImportListAdventureBook._IMPORTABLE_TAGS)
			.map(([tag, importableMeta]) => {
				const sourceMetas = this._availableEntities[tag];
				const inlineData = this._availableInlineData[tag];

				const out = {
					displayName: importableMeta.displayName,
					tag,
					sources: [],
				};

				if (sourceMetas) {
					out.sources.push(
						...Object.entries(sourceMetas)
							.map(([src, set]) => {
								return {
									sourceLong: Parser.sourceJsonToFull(src),
									sourceShort: Parser.sourceJsonToAbv(src),
									sourceClassName: Parser.sourceJsonToColor(src),
									sourceStyle: PrereleaseUtil.sourceJsonToStylePart(src) || BrewUtil2.sourceJsonToStylePart(src),
									source: src,
									count: set.size,
								};
							}),
					);
				}

				if (inlineData && inlineData.length) {
					const existingSource = out.sources.find(it => it.source.toLowerCase() === source.toLowerCase());

					if (existingSource) existingSource.count += inlineData.length;
					else {
						out.sources.push({
							sourceLong: Parser.sourceJsonToFull(source),
							sourceShort: Parser.sourceJsonToAbv(source),
							sourceClassName: Parser.sourceJsonToColor(source),
							sourceStyle: PrereleaseUtil.sourceJsonToStylePart(source) || BrewUtil2.sourceJsonToStylePart(source),
							source,
							count: inlineData.length,
						});
					}
				}

				out.sources.sort((a, b) => SortUtil.ascSortLower(a.sourceLong, b.sourceLong));

				return out;
			})
			.filter(it => it.sources.length);

		const imageGroupSections = Object.values(ImportListAdventureBook._IMPORTABLE_IMAGE_TYPES)
			.map(it => it.group)
			.unique()
			.map(group => {
				const importableImageTypes = Object.values(ImportListAdventureBook._IMPORTABLE_IMAGE_TYPES)
					.filter(it => it.group === group);
				if (!importableImageTypes.length) return null;

				const imageTypeMetas = importableImageTypes
					.map(({imageType, displayName}) => {
						const count = Object.values(this._availableMaps[imageType] || {}).length;
						if (!count) return null;

						return {
							imageType,
							displayName,
							count,
						};
					})
					.filter(Boolean);
				if (!imageTypeMetas.length) return null;

				return {
					group,
					groupNamePlural: importableImageTypes[0].groupNamePlural,
					imageTypeMetas,
				};
			})
			.filter(Boolean);

		return {
			name: this._content._contentMetadata.name,
			titleSearch: this._titleSearch,
			tagSections,
			imageGroupSections,
		};
	}

	async _renderInner_custom ($html) {
		this._renderInner_initCheckboxes($html);
		this._renderInner_initConfigButtons($html);
		this._renderInner_initRunButton($html);
	}

	_renderInner_initCheckboxes ($html) {
		this._$cbText = $html.find(`[name="cb-journal-entries"]`);

		this._tagCbMetas = {};
		this._imageGroupCbMetas = {};

						$html.find(`input[data-tag][data-source]`).each((i, e) => {
			const $cb = $(e);

			const tag = $cb.data("tag");
			const source = $cb.data("source");

			(this._tagCbMetas[tag] = this._tagCbMetas[tag] || []).push({
				source,
				$cb,
			});
		});

				const $cbsAllTag = $html.find(`input[data-tag][data-type="all"]`).map((i, e) => {
			const $cb = $(e);
			const tag = $cb.data("tag");
			$cb.change(() => {
				const toVal = $cb.prop("checked");
				this._tagCbMetas[tag].forEach(meta => meta.$cb.prop("checked", toVal));
			});
			return $cb;
		}).get();
		
						$html.find(`input[data-image-group][data-image-type]`).each((i, e) => {
			const $cb = $(e);

			const imageGroup = $cb.data("image-group");
			const imageType = $cb.data("image-type");

			(this._imageGroupCbMetas[imageGroup] = this._imageGroupCbMetas[imageGroup] || []).push({
				imageType,
				$cb,
			});
		});

		const $cbsAllImageGroup = $html.find(`input[data-image-group][data-type="all"]`).map((i, e) => {
			const $cb = $(e);
			const imageGroup = $cb.data("image-group");
			$cb.change(() => {
				const toVal = $cb.prop("checked");
				this._imageGroupCbMetas[imageGroup].forEach(meta => meta.$cb.prop("checked", toVal));
			});
			return $cb;
		}).get();
		
				const $cbGod = $html.find(`input[data-type="god"]`);
		$cbGod.change(() => {
			const toVal = $cbGod.prop("checked");
			$cbsAllTag.forEach($cb => $cb.prop("checked", toVal).change());
			$cbsAllImageGroup.forEach($cb => $cb.prop("checked", toVal).change());
		});
	}

	_renderInner_initConfigButtons ($html) {
		const doBindConfigButtons = ({dataType, dataProp, lookup, pFnGetImporter}) => {
			$html.find(`button[data-type="${dataType}"]`).each((i, e) => {
				const $btn = $(e);
				const key = $btn.data(dataProp);

				$btn.click(async () => {
					const importer = pFnGetImporter ? await pFnGetImporter() : lookup[key].importer;
					await importer.pInit();
					await importer.pHandleEditFolderPathClick();
				});
			});
		};

				doBindConfigButtons({
			dataType: "configure-tag",
			dataProp: "tag",
			lookup: ImportListAdventureBook._IMPORTABLE_TAGS,
		});

		doBindConfigButtons({
			dataType: "configure-image",
			pFnGetImporter: () => this.constructor._getImportListMap(),
		});
	}

	_renderInner_initRunButton ($html) {
		$html.find(`[name="btn-run"]`).click(async () => this._pHandleRunButtonClick());
	}

	async _pHandleRunButtonClick () {
		this.close();

		console.log(...LGT, `Importing ${this._dataProp} "${this._content._contentMetadata.name}"`);

		const runInfo = new ImportListAdventureBook._RunInfo();

		const preloadedTagMetas = await this._pHandleRunButtonClick_pDoPreImport({runInfo});
		if (runInfo.isCancelled) return;
		await this._pHandleRunButtonClick_pDoMainImport({preloadedTagMetas, runInfo});
	}

	async _pHandleRunButtonClick_pDoPreImport ({runInfo}) {
		const loadedEntityInfos = {};

		const taskListTags = await this._pHandleRunButtonClick_pGetTaskListTags({loadedEntityInfos});

		if (!taskListTags.length) return loadedEntityInfos;

		const runResult = await (
			new AppTaskRunner({
				tasks: taskListTags,
				titleInitial: "Importing...",
				titleComplete: "Import Complete",
								isForceClose: true,
			})
		).pRun();
		if (runResult === ConstsTaskRunner.TASK_EXIT_CANCELLED) runInfo.isCancelled = true;

		return loadedEntityInfos;
	}

	async _pHandleRunButtonClick_pGetTaskListTags ({loadedEntityInfos}) {
		const toImportTagSources = {};

		Object.entries(this._tagCbMetas).forEach(([tag, metas]) => {
			const activeSources = metas.filter(meta => meta.$cb.prop("checked")).map(meta => meta.source);
			if (!activeSources.length) return;

			toImportTagSources[tag] = activeSources;
		});

		const taskList = [];

		for (const [tag, sources] of Object.entries(toImportTagSources)) {
			const loaded = (loadedEntityInfos[tag] = {});
			const importableTag = ImportListAdventureBook._IMPORTABLE_TAGS[tag];

			for (const source of sources) {
								const hashes = new Set([...(MiscUtil.get(this._availableEntities, tag, source) || [])]);
				for (const hash of hashes) {
					taskList.push(new TaskClosure({
						fnGetPromise: ({taskRunner}) => this._pHandleRunButtonClick_pDoTagImport({importableTag, hash, taskRunner, loaded, tag}),
					}));
				}
			}

						const inlines = [...(MiscUtil.get(this._availableInlineData, tag) || [])];
			for (const inline of inlines) {
				taskList.push(new TaskClosure({
					fnGetPromise: ({taskRunner}) => this._pHandleRunButtonClick_pDoInlineTagImport({importableTag, inline, taskRunner}),
				}));
			}

			importableTag.pActivateSidebarTab();
		}

		return taskList;
	}

	async _pHandleRunButtonClick_pDoTagImport ({importableTag, hash, taskRunner, loaded, tag}) {
		const {folderType, id: importedId, importSummary} = await importableTag.pLoadHash(hash, {taskRunner});
		(loaded[tag] = loaded[tag] || {})[hash] = {folderType, importedId};
		return importSummary;
	}

	async _pHandleRunButtonClick_pDoInlineTagImport ({importableTag, inline, taskRunner}) {
						return importableTag.pLoadInline(inline, {taskRunner});
	}

	async _pHandleRunButtonClick_pGetTaskListImageGroups ({entryIdToJournalId}) {
		const toImportImageTypes = {};

		Object.entries(this._imageGroupCbMetas)
			.forEach(([imageGroup, metas]) => {
				const activeImageTypes = metas.filter(meta => meta.$cb.prop("checked")).map(meta => meta.imageType);
				if (!activeImageTypes.length) return;

				toImportImageTypes[imageGroup] = activeImageTypes;
			});

		return [
			new TaskClosure({
				fnGetPromise: ({taskRunner}) => this._pHandleRunButtonClick_pGetTaskListImageGroups_pMaps({toImportImageTypes, entryIdToJournalId, taskRunner}),
			}),
		];
	}

	async _pHandleRunButtonClick_pGetTaskListImageGroups_pMaps ({toImportImageTypes, entryIdToJournalId, taskRunner}) {
		const taskRunnerLineMeta = taskRunner.addLogLine(`Importing maps...`);
		taskRunner.pushDepth();

		const importListMap = await this.constructor._getImportListMap();

		try {
			await this._pHandleRunButtonClick_pGetTaskListImageGroups_pMaps_({toImportImageTypes, importListMap, entryIdToJournalId, taskRunner});
			this._pHandleRunButtonClick_pGetTaskListImageGroups_pMaps_success({taskRunner, taskRunnerLineMeta});
		} catch (e) {
			this._pHandleRunButtonClick_pGetTaskListImageGroups_pMaps_failure({taskRunner, taskRunnerLineMeta, e});
		}
	}

	_pHandleRunButtonClick_pGetTaskListImageGroups_pMaps_success ({taskRunner, taskRunnerLineMeta}) {
		taskRunner.popDepth();
		taskRunner.addLogLine(`Imported maps.`, {linkedLogLineMeta: taskRunnerLineMeta});
	}

	_pHandleRunButtonClick_pGetTaskListImageGroups_pMaps_failure ({taskRunner, taskRunnerLineMeta, e}) {
		console.error(...LGT, e);
		taskRunner.popDepth();
		taskRunner.addLogLine(`Failed to import maps! ${VeCt.STR_SEE_CONSOLE}`, {isError: true, linkedLogLineMeta: taskRunnerLineMeta});
	}

	async _pHandleRunButtonClick_pGetTaskListImageGroups_pMaps_ ({toImportImageTypes, importListMap, entryIdToJournalId, taskRunner}) {
		for (const imageTypes of Object.values(toImportImageTypes)) {
			for (const imageType of imageTypes) {
				const importableImageType = ImportListAdventureBook._IMPORTABLE_IMAGE_TYPES[imageType];

				const urlToEntry = this._availableMaps[imageType];

				await Object.values(urlToEntry)
					.pSerialAwaitMap(entry => this._pPostImportImportMap({importListMap, importableImageType, entryIdToJournalId, entry, taskRunner}));
			}
		}
	}

	async _pPostImportImportMap ({importListMap, entryIdToJournalId, entry, taskRunner}) {
		await this._pPostImportImportMap_({importListMap, entryIdToJournalId, entry, taskRunner});
	}

	async _pPostImportImportMap_ ({importListMap, entryIdToJournalId, entry, taskRunner}) {
		return importListMap.pImportEntry(
			entry,
			{
				entryIdToJournalId,
				taskRunner,
			},
		);
	}

	static async _getImportListMap () {
		const {ImportListMap} = await Promise.resolve().then(function () { return ImportListMap$1; });
		const importListMap = new ImportListMap();
		await importListMap.pInit();
		return importListMap;
	}

	async _pHandleRunButtonClick_pDoMainImport ({preloadedTagMetas, runInfo}) {
		if (!this._$cbText.prop("checked")) return null;

		const tagWalker2 = MiscUtil.getWalker({
			keyBlocklist: ImportListAdventureBook._TAG_WALKER_BLOCKLIST,
		});

		const handlers = {
			string: (str) => {
				const tagSplit = Renderer.splitByTags(str);
				const len = tagSplit.length;

				let stack = "";
				for (let i = 0; i < len; ++i) {
					const s = tagSplit[i];
					if (!s) continue;

					if (!s.startsWith("{@")) {
						stack += s;
						continue;
					}

					const [tag, text] = Renderer.splitFirstSpace(s.slice(1, -1));
					const importableTag = ImportListAdventureBook._IMPORTABLE_TAGS[tag];
					const preloadedMeta = preloadedTagMetas[tag];

					if (!importableTag || !preloadedMeta) {
						stack += s;
						continue;
					}

					const extractedTag = importableTag._extractTag(text);
					if (!extractedTag) {
						stack += s;
						continue;
					}

					const preloaded = MiscUtil.get(preloadedMeta, tag, extractedTag.hash);

					if (!preloaded) {
						stack += s;
						continue;
					}

															stack += `${DataConverter.SYM_AT}UUID[${preloaded.folderType}.${preloaded.importedId}]{${extractedTag.displayText}}`;
				}

				return stack;
			},
		};

		this._content.data = tagWalker2.walk(this._content.data, handlers);

		let wrappedJournalDatas;
		try {
			wrappedJournalDatas = await this._pGetJournalDatas();
		} catch (e) {
			ui.notifications.error(`Failed to build journal data! ${VeCt.STR_SEE_CONSOLE}`);
			throw e;
		}

		const folderIdMetaRoot = await this._pImportEntry_pGetFolderIdMeta(
			{
				name: this._content._contentMetadata.name,
				source: this._content._contentMetadata.source,
				published: this._content._contentMetadata.published,
			},
			{
				sorting: "m",
				isAddDefaultOwnershipFromConfig: true,
												isFoldersOnly: wrappedJournalDatas.some(({folderNames}) => folderNames?.length),
			},
		);

		const finalizeLinkLookup = {};
		const entryIdToJournalId = {};

		const taskListImport = [
			...wrappedJournalDatas
				.map(wrappedJournalData => {
					return new TaskClosure({
						fnGetPromise: ({taskRunner}) => this._pImportWrappedJournalData({finalizeLinkLookup, entryIdToJournalId, folderIdMetaRoot, wrappedJournalData, taskRunner}),
					});
				}),
			new TaskClosure({
				fnGetPromise: ({taskRunner}) => this._pFinalizeImport({finalizeLinkLookup, taskRunner}),
			}),
			...(await this._pHandleRunButtonClick_pGetTaskListImageGroups({entryIdToJournalId})),
		];

		if (!taskListImport.length) return entryIdToJournalId;

		const runResult = await (
			new AppTaskRunner({
				tasks: taskListImport,
				titleInitial: "Importing...",
				titleComplete: "Import Complete",
			})
		).pRun();
		if (runResult === ConstsTaskRunner.TASK_EXIT_CANCELLED) runInfo.isCancelled = true;

		ui.sidebar.activateTab("journal");
		game.journal.render();

		return entryIdToJournalId;
	}

	async _pImportWrappedJournalData ({finalizeLinkLookup, entryIdToJournalId, folderIdMetaRoot, wrappedJournalData, taskRunner}) {
		const taskRunnerLineMeta = taskRunner.addLogLine(`Importing <i>${wrappedJournalData.journalEntry.name}</i>...`);
		try {
			await this._pImportWrappedJournalData_({finalizeLinkLookup, entryIdToJournalId, folderIdMetaRoot, wrappedJournalData});
			taskRunner.addLogLine(`Imported ${wrappedJournalData.journalEntry.name}.`, {linkedLogLineMeta: taskRunnerLineMeta});
		} catch (e) {
			console.error(...LGT, e);
			taskRunner.addLogLine(`Failed to import ${wrappedJournalData.journalEntry.name}! ${VeCt.STR_SEE_CONSOLE}`, {isError: true, linkedLogLineMeta: taskRunnerLineMeta});
		}
	}

	async _pImportWrappedJournalData_ ({finalizeLinkLookup, entryIdToJournalId, folderIdMetaRoot, wrappedJournalData}) {
		const {journalEntry, folderNames} = wrappedJournalData;
		if (journalEntry.pages?.length !== 1) throw new Error(`Journal entry must have exactly one page! This is a bug!`);

				const duplicateMetaOpts = {
			name: journalEntry.name,
			flags: journalEntry?.flags?.[SharedConsts.MODULE_ID]?.source
				? {
					[SharedConsts.MODULE_ID]: {
						source: journalEntry.flags[SharedConsts.MODULE_ID].source,
					},
				}
				: null,
		};

				const duplicateMeta = Object.keys(duplicateMetaOpts.flags || {}).length
			? this._getDuplicateMeta(duplicateMetaOpts)
			: null;

		if (duplicateMeta?.isSkip || duplicateMeta?.isOverwrite) {
			(duplicateMeta.existing?.pages || []).forEach(page => {
				const entryIds = page?.flags?.[SharedConsts.MODULE_ID]?.entryIds || [];
				entryIds.forEach(id => entryIdToJournalId[id] = {
					journalEntryDoc: duplicateMeta.existing,
					journalPageDoc: page,
				});
			});
		}

		if (duplicateMeta?.isSkip) {
			return new ImportSummary({
				status: ConstsTaskRunner.TASK_EXIT_SKIPPED_DUPLICATE,
				imported: [
					new ImportedDocument({
						document: duplicateMeta.existing,
						isExisting: true,
					}),
				],
			});
		}

		if (duplicateMeta?.isOverwrite) {
			return this._pImportEntry_pDoUpdateExistingDirectoryEntity(duplicateMeta, journalEntry);
		}
		
						let journalEntryDoc, journalPageDoc;
		if (!folderIdMetaRoot.parentDocumentId) {
			journalEntryDoc = await JournalEntry.create(
				{
					...journalEntry,
					folder: folderIdMetaRoot.folderId,
				},
				{
					renderSheet: false,
					temporary: false,
				},
			);
			journalPageDoc = journalEntryDoc.pages[0];
		} else {
			journalEntryDoc = game.journal.get(folderIdMetaRoot.parentDocumentId);
			const importSummary = await this._pImportEntry_pImportToDirectoryGeneric_toDirectorySubEntities({
				parent: journalEntryDoc,
				embeddedDocDatas: journalEntry.pages,
				ClsEmbed: JournalEntryPage,
			});
			journalPageDoc = importSummary.imported[0].embeddedDocument;
		}

		const flags = journalPageDoc?.flags?.[SharedConsts.MODULE_ID];
		if (flags) {
			(finalizeLinkLookup[flags.ixChapter] = finalizeLinkLookup[flags.ixChapter] || {})[flags.ixFlat] = {
				journalEntryDoc,
				journalPageDoc,
			};
		}

		const entryIds = journalPageDoc?.flags?.[SharedConsts.MODULE_ID]?.entryIds || [];
		entryIds.forEach(id => entryIdToJournalId[id] = {
			journalEntryDoc,
			journalPageDoc,
		});
	}

	async _pFinalizeImport ({finalizeLinkLookup, taskRunner}) {
		const taskRunnerLineMeta = taskRunner.addLogLine(`Finalizing...`);
		try {
			await this._pFinalizeImport_({finalizeLinkLookup});
			taskRunner.addLogLine(`Finalized.`, {linkedLogLineMeta: taskRunnerLineMeta});
		} catch (e) {
			console.error(...LGT, e);
			taskRunner.addLogLine(`Failed to finalize! ${VeCt.STR_SEE_CONSOLE}`, {isError: true, linkedLogLineMeta: taskRunnerLineMeta});
		}
	}

	async _pFinalizeImport_ ({finalizeLinkLookup}) {
		if (!Object.keys(finalizeLinkLookup).length) return;

		const reLink = new RegExp(`%${SharedConsts.MODULE_ID_FAKE}_(\\d+)__(\\d+)_${SharedConsts.MODULE_ID_FAKE}%`, "gi");

		for (const metaChapters of Object.values(finalizeLinkLookup)) {
			for (const {journalEntryDoc, journalPageDoc} of Object.values(metaChapters)) {
				const contentNxt = journalPageDoc.text.content
					.replace(reLink, (...m) => {
						const [, ixChapterRaw, ixFlatRaw] = m;

						const linkedJournalDocs = finalizeLinkLookup[ixChapterRaw]?.[ixFlatRaw];
						if (!linkedJournalDocs) return m[0];

						const {journalEntryDoc: journalEntryDocLinked, journalPageDoc: journalPageDocLinked} = linkedJournalDocs;

						return `@UUID[JournalEntry.${journalEntryDocLinked?.id}.JournalEntryPage.${journalPageDocLinked?.id}]`;
					});

				if (contentNxt === journalPageDoc.text.content) continue;

				await UtilDocuments.pUpdateEmbeddedDocuments(
					journalEntryDoc,
					[
						{
							_id: journalPageDoc.id,
							text: {
								content: contentNxt,
							},
						},
					],
					{
						ClsEmbed: JournalEntryPage,
					},
				);
			}
		}
	}

		async _pGetJournalDatas () {
		throw new Error(`Unimplemented!`);
	}

		_getAdditionalContentForTag () { return null; }

	static _registerImportableTag (importableTagInstance) {
		this._IMPORTABLE_TAGS[importableTagInstance.tag] = importableTagInstance;
	}

	static _registerImportableImageType (importableImageTypeInstance) {
		this._IMPORTABLE_IMAGE_TYPES[importableImageTypeInstance.imageType] = importableImageTypeInstance;
	}
}
ImportListAdventureBook._IMPORTABLE_TAGS = {};
ImportListAdventureBook._IMPORTABLE_IMAGE_TYPES = {};
ImportListAdventureBook._HOMEBREW_OTHER_DATA = {};

ImportListAdventureBook._RunInfo = class {
	constructor () {
		this.isCancelled = false;
	}
};

ImportListAdventureBook.ImportableTag = class {
	constructor (opts) {
		this._displayName = opts.displayName;
		this._tag = opts.tag;
		this._props = opts.props;
		this._page = opts.page;
		this._defaultSource = opts.defaultSource;
		this._importer = opts.importer;
		this._fnGetInlineData = opts.fnGetInlineData;
		this._fnGetInlineHash = opts.fnGetInlineHash;
	}

	get displayName () { return this._displayName; }
	get tag () { return this._tag; }
	get page () { return this._page; }
	get importer () { return this._importer; }
	get fnGetInlineData () { return this._fnGetInlineData; }
	get fnGetInlineHash () { return this._fnGetInlineHash; }

	pLoadHash (hash, {taskRunner} = {}) {
		return this._pLoadGenericHash({hash, taskRunner});
	}

	pActivateSidebarTab () {
		this._importer.activateSidebarTab();
	}

	async _pLoadGenericHash ({hash, taskRunner}) {
		const [, source] = hash.split(HASH_LIST_SEP);

				const entity = await DataLoader.pCacheAndGet(this._page, source, hash, {isRequired: true});

		await this._importer.pInit();
		const importSummary = await this._importer.pImportEntry(entity, {taskRunner});

		return {
			importSummary,
			folderType: this._importer.constructor.FOLDER_TYPE,
			id: importSummary.imported?.[0]?.document?.id,
			hash,
		};
	}

	static _getExtractedGenericTag (page, defaultSource, tag) {
		const [name, rawSource, rawDisplayText] = Renderer.splitTagByPipe(tag);
		const source = (rawSource || defaultSource).toLowerCase();
		const hashEnt = {name, source};
		return {
			source,
			displayText: rawDisplayText || name,
			hash: UrlUtil.URL_TO_HASH_BUILDER[page](hashEnt),
		};
	}

	_extractTag (tag) {
		const out = ImportListAdventureBook.ImportableTag._getExtractedGenericTag(this._page, this._defaultSource, tag);
										const isExcluded = this._props.some(prop => ExcludeUtil.isExcluded(out.hash, prop, out.source, {isNoCount: true}));
		if (isExcluded) return null;
		return out;
	}

	async pLoadInline (inline, {taskRunner} = {}) {
		await this._importer.pInit();
		return this._importer.pImportEntry(inline, {taskRunner});
	}
};

ImportListAdventureBook.ImportableImageType = class {
	constructor ({group, groupName, groupNamePlural, displayName, imageType}) {
		this._group = group;
		this._groupName = groupName;
		this._groupNamePlural = groupNamePlural;
		this._displayName = displayName;
		this._imageType = imageType;
	}

	get group () { return this._group; }
	get groupName () { return this._groupName; }
	get groupNamePlural () { return this._groupNamePlural; }
	get displayName () { return this._displayName; }
	get imageType () { return this._imageType; }
};

ImportListAdventureBook._TAG_WALKER_BLOCKLIST = new Set([
	"name",
	"caption",
	"colLabels",
	"colLabelGroups",
	"style",
	"type",
	"href",
	"page",
]);

ImportListAdventureBook.IMPORTABLE_TAG_CREATURE = {
	displayName: "Creatures",
	tag: "@creature",
	props: ["monster"],
	page: UrlUtil.PG_BESTIARY,
	defaultSource: Parser.SRC_MM,
	importer: new ImportListCreature(),
};
ImportListAdventureBook._registerImportableTag(new ImportListAdventureBook.ImportableTag(ImportListAdventureBook.IMPORTABLE_TAG_CREATURE));

ImportListAdventureBook._registerImportableTag(new ImportListAdventureBook.ImportableTag({
	displayName: "Spells",
	tag: "@spell",
	props: ["spell"],
	page: UrlUtil.PG_SPELLS,
	defaultSource: Parser.SRC_PHB,
	importer: new ImportListSpell(),
}));

ImportListAdventureBook._registerImportableTag(new ImportListAdventureBook.ImportableTag({
	displayName: "Items",
	tag: "@item",
	props: ["item", "baseitem", "magicvariant", "itemGroup"],
	page: UrlUtil.PG_ITEMS,
	defaultSource: Parser.SRC_DMG,
	importer: new ImportListItem(),
}));

ImportListAdventureBook._registerImportableTag(new ImportListAdventureBook.ImportableTag({
	displayName: "Variant Rules",
	tag: "@variantrule",
	props: ["variantrule"],
	page: UrlUtil.PG_VARIANTRULES,
	defaultSource: Parser.SRC_DMG,
	importer: new ImportListVariantRule(),
}));

ImportListAdventureBook._registerImportableTag(new ImportListAdventureBook.ImportableTag({
	displayName: "Vehicle Upgrades",
	tag: "@vehupgrade",
	props: ["vehicleUpgrade"],
	page: UrlUtil.PG_VEHICLES,
	defaultSource: Parser.SRC_GoS,
	importer: new ImportListVehicleUpgrade(),
}));

ImportListAdventureBook._registerImportableTag(new ImportListAdventureBook.ImportableTag({
	displayName: "Tables",
	tag: "@table",
	props: ["table", "tableGroup"],
	page: UrlUtil.PG_TABLES,
	defaultSource: Parser.SRC_DMG,
	importer: new ImportListRollableTable(),
	fnGetInlineData: (pack, opts) => {
		const {table: inlineTables, tableGroup: inlineTableGroups} = UtilGenTables.getAdventureBookTables(pack, opts);
		inlineTables.forEach(it => it.__prop = "table");
		inlineTableGroups.forEach(it => it.__prop = "tableGroup");
		return [...inlineTables, ...inlineTableGroups];
	},
	fnGetInlineHash: it => {
		return UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_TABLES](it).toLowerCase();
	},
}));

ImportListAdventureBook._registerImportableImageType(new ImportListAdventureBook.ImportableImageType({
	group: "maps",
	groupName: "Map",
	groupNamePlural: "Maps",
	displayName: "Map",
	imageType: "map",
}));

ImportListAdventureBook._registerImportableImageType(new ImportListAdventureBook.ImportableImageType({
	group: "maps",
	groupName: "Map",
	groupNamePlural: "Maps",
	displayName: "Player Map",
	imageType: "mapPlayer",
}));

var ImportListAdventureBook$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ImportListAdventureBook: ImportListAdventureBook
});

class DataConverterAdventureBook extends DataConverterJournal {
		static async _pGetAdventureBookJournals (data, indexData, prop, opts) {
		const out = [];
		const contents = indexData.contents;

		Renderer.get().resetHeaderIndex();

		const len = Math.min(contents.length, data.length);

		for (let i = 0; i < len; ++i) {
			const content = contents[i];
			const chapter = data[i];

			await this._pGetAdventureBookJournals_byChapter({
				contentsItem: content,
				chapter,
				out,
				opts,
				indexData,
			});
		}

		return out;
	}

	static async _pGetAdventureBookJournals_byChapter ({contentsItem, chapter, out, opts, indexData, folderNames, isNested}) {
		const content = await this._pGetWithJournalDescriptionPlugins(() => {
			return Renderer.get()
				.setFirstSection(true)
				.render(chapter)
				.replace(new RegExp(DataConverter.SYM_AT, "g"), "@");
		});

		const numEntry = out.length;

		const name = isNested
			? UtilApplications.getCleanEntityName(`${contentsItem.name}`)
			: UtilApplications.getCleanEntityName(`${Parser.bookOrdinalToAbv(contentsItem.ordinal)}${contentsItem.name}`);
		const flags = {
			[SharedConsts.MODULE_ID]: {
				source: indexData.source,
				entryIds: this._getEntryIds({entry: chapter}),
			},
		};

		const journalEntry = {
			name,
			pages: this._getPages({
				name,
				content,
				flags,
			}),
									sort: CONFIG.JournalEntry.collection.instance.contents.length + (CONST.SORT_INTEGER_DENSITY * numEntry),
						flags,
		};

		this._mutOwnership(journalEntry, opts);

		out.push(new DataConverterAdventureBook.FolderizedJournalEntryBuilder({journalEntry, folderNames}));
	}

	static _getEntryIds ({entry}) {
		if (!entry) return [];

		const out = [];

		UtilDataConverter.WALKER_GENERIC.walk(
			entry,
			{
				object: (obj) => {
					if (obj.id) out.push(obj.id);
					return obj;
				},
			},
		);

		return out;
	}
}

DataConverterAdventureBook.FolderizedJournalEntryBuilder = class {
	constructor ({journalEntry, folderNames = []} = {}) {
		this.journalEntry = journalEntry;
		this.folderNames = folderNames;
	}
};

var DataConverterAdventureBook$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DataConverterAdventureBook: DataConverterAdventureBook
});

class DataConverterAdventure extends DataConverterAdventureBook {
	static get _CONFIG_GROUP () { return "importAdventure"; }

	static pGetAdventureJournals (data, indexData, opts) {
		return this._pGetAdventureBookJournals(data, indexData, "adventure", opts);
	}
}

var DataConverterAdventure$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DataConverterAdventure: DataConverterAdventure
});

class ImportListAdventure extends ImportListAdventureBook {
	static get ID () { return "adventures"; }
	static get DISPLAY_NAME_TYPE_SINGLE () { return "Adventure"; }
	static get DISPLAY_NAME_TYPE_PLURAL () { return "Adventures"; }

	static _ = this.registerImpl(this);

	_dirsHomebrew = ["adventure"];
	_titleSearch = "adventure";
	_defaultFolderPath = ["Adventures", {metaKey: "name"}];
	_configGroup = "importAdventure";
	_isFolderOnly = true;
	_namespace = "adventure";

	_fnGetIndex = Vetools.pGetAdventureIndex.bind(Vetools);
	_dataProp = "adventure";
	_brewDataProp = "adventureData";
	_title = "Adventure";

	async pPreRender (...args) {
		await super.pPreRender(...args);

				if (ImportListAdventure._ALL_CREATURES) return;
		ImportListAdventure._ALL_CREATURES = await Vetools.pGetAllCreatures();
	}

	_getAdditionalContentForTag (tag) {
		if (tag !== ImportListAdventureBook.IMPORTABLE_TAG_CREATURE.tag) return;

				const source = this._content?.[0]?._contentMetadata?.source;
		if (!Parser.SOURCE_JSON_TO_FULL[source]) return;

		return (ImportListAdventure._ALL_CREATURES?.monster || [])
			.filter(it => {
				if (it.source === source) return true;
				return it.otherSources && it.otherSources.some(os => os.source === source);
			})
			.map(it => ({source: it.source, hash: UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BESTIARY](it)}));
	}

	_pGetJournalDatas () {
		return DataConverterAdventure.pGetAdventureJournals(this._content.data, this._content._contentMetadata, {isAddDefaultOwnershipFromConfig: true});
	}
}

ImportListAdventure._ALL_CREATURES = null;

var ImportListAdventure$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ImportListAdventure: ImportListAdventure
});

class DataConverterBook extends DataConverterAdventureBook {
	static get _CONFIG_GROUP () { return "importBook"; }

	static pGetBookJournals (data, indexData, opts) {
		return this._pGetAdventureBookJournals(data, indexData, "book", opts);
	}
}

var DataConverterBook$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DataConverterBook: DataConverterBook
});

class ImportListBook extends ImportListAdventureBook {
	static get ID () { return "books"; }
	static get DISPLAY_NAME_TYPE_SINGLE () { return "Book"; }
	static get DISPLAY_NAME_TYPE_PLURAL () { return "Books"; }

	static _ = this.registerImpl(this);

	_dirsHomebrew = ["book"];
	_titleSearch = "book";
	_defaultFolderPath = ["Books", {metaKey: "name"}];
	_configGroup = "importBook";
	_isFolderOnly = true;
	_namespace = "book";

	_fnGetIndex = Vetools.pGetBookIndex.bind(Vetools);
	_dataProp = "book";
	_brewDataProp = "bookData";
	_title = "Book";

	_pGetJournalDatas () {
		return DataConverterBook.pGetBookJournals(this._content.data, this._content._contentMetadata, {isAddDefaultOwnershipFromConfig: true});
	}
}

var ImportListBook$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ImportListBook: ImportListBook
});

class DataConverterReward extends DataConverterFeature {
	static _SIDE_LOAD_OPTS = {
		propBrew: "foundryReward",
		fnLoadJson: async () => this._pGetPreloadSideData(),
		propJson: "reward",
	};

	static init () {
		PageFilterClassesFoundry.setImplSideData("reward", this);
	}

	static async pGetDereferencedFeatureItem (feature) {
				if (feature.entries) return MiscUtil.copy(feature);

		const hash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_REWARDS](feature);
		return DataLoader.pCacheAndGet(UrlUtil.PG_REWARDS, feature.source, hash, {isCopy: true});
	}

	static async pGetInitFeatureLoadeds (feature, {actor = null} = {}) {
		const asFeatRef = {reward: `${feature.name}|${feature.source}`};
				await PageFilterClassesFoundry.pInitRewardLoadeds({reward: asFeatRef, raw: feature, actor});
		return asFeatRef;
	}

		static async pGetDocumentJson (reward, opts) {
		opts = opts || {};
		if (opts.actor) opts.isActorItem = true;

		Renderer.get().resetHeaderIndex();

		const descriptionValue = await this._pGetGenericDescription(reward, "importReward");

		const img = await this._pGetSaveImagePath(reward, {propCompendium: "reward", taskRunner: opts.taskRunner});

		const additionalData = await this._pGetDataSideLoaded(reward);
		const additionalFlags = await this._pGetFlagsSideLoaded(reward);

		const effectsSideTuples = await this._pGetEffectsSideLoadedTuples({ent: reward, img, actor: opts.actor});
		effectsSideTuples.forEach(({effect, effectRaw}) => DataConverter.mutEffectDisabledTransfer(effect, "importReward", UtilActiveEffects.getDisabledTransferHintsSideData(effectRaw)));

		const out = {
			name: UtilApplications.getCleanEntityName(UtilDataConverter.getNameWithSourcePart(reward, {isActorItem: opts.isActorItem})),
			system: {
				source: UtilDataConverter.getSourceWithPagePart(reward),
				description: {
					value: descriptionValue,
					chat: "",
					unidentified: "",
				},

				activation: {type: "", cost: 0, condition: ""},
				duration: {value: 0, units: ""},
				target: {value: 0, units: "", type: ""},
				range: {value: 0, long: 0, units: null},
				uses: {value: 0, max: 0, per: ""},
				ability: "",
				actionType: "",
				attackBonus: null,
				chatFlavor: "",
				critical: {threshold: null, damage: ""},
				damage: {parts: [], versatile: ""},
				formula: "",
				save: {ability: "", dc: null},
				requirements: "",
				recharge: {value: 0, charged: true},

				...additionalData,
			},
			ownership: {default: 0},
			type: "feat",
			img,
			flags: {
				...this._getRewardFlags(reward, opts),
				...additionalFlags,
			},
			effects: DataConverter.getEffectsMutDedupeId(effectsSideTuples.map(it => it.effect)),
		};

		if (opts.defaultOwnership != null) out.ownership = {default: opts.defaultOwnership};
		else if (opts.isAddDefaultOwnershipFromConfig) out.ownership = {default: Config.get("importReward", "ownership")};
		if (opts.userOwnership) Object.assign(out.ownership, opts.userOwnership);

		return out;
	}

	static _getRewardFlags (reward, opts) {
		opts = opts || {};

		const out = {
			[SharedConsts.MODULE_ID]: {
				page: UrlUtil.PG_REWARDS,
				source: reward.source,
				hash: UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_REWARDS](reward),
			},
		};

		if (opts.isAddDataFlags) {
			out[SharedConsts.MODULE_ID].propDroppable = "reward";
			out[SharedConsts.MODULE_ID].filterValues = opts.filterValues;
		}

		return out;
	}

	static async _pGetPreloadSideData () {
		if (!this._SIDE_DATA) this._SIDE_DATA = await Vetools.pGetRewardSideData();
		return this._SIDE_DATA;
	}
}

var DataConverterReward$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DataConverterReward: DataConverterReward
});

class ImportListReward extends ImportListFeature {
		static init () {
		this._initCreateSheetItemHook({
			prop: "reward",
			importerName: "Reward",
		});
	}
	
	static get ID () { return "rewards"; }
	static get DISPLAY_NAME_TYPE_SINGLE () { return "Supernatural Gift or Reward"; }
	static get DISPLAY_NAME_TYPE_PLURAL () { return "Supernatural Gifts & Rewards"; }
	static get PROPS () { return ["reward"]; }

	static _ = this.registerImpl(this);

	_dirsHomebrew = ["reward"];
	_titleSearch = "supernatural gifts and reward";
	_sidebarTab = "items";
	_gameProp = "items";
	_defaultFolderPath = ["Supernatural Gifts and Rewards"];
	_pageFilter = new PageFilterRewards();
	_page = UrlUtil.PG_REWARDS;
	_isPreviewable = true;
	_isDedupable = true;
	_configGroup = "importReward";
	static _DataConverter = DataConverterReward;

	async _pGetSources () {
		return [
			new UtilDataSource.DataSourceUrl(
				Config.get("ui", "isStreamerMode") ? "SRD" : "5etools",
				Vetools.DATA_URL_REWARDS,
				{
					filterTypes: [UtilDataSource.SOURCE_TYP_OFFICIAL_ALL],
					isDefault: true,
				},
			),
			...UtilDataSource.getSourcesCustomUrl(),
			...UtilDataSource.getSourcesUploadFile(),
			...(await this._pGetSourcesPrerelease()),
			...(await this._pGetSourcesBrew()),
		];
	}

	_colWidthName = 7;

	_getData_cols_otherPre () {
		return [
			{
				name: "Type",
				width: 2,
				field: "type",
				rowClassName: "text-center",
			},
		];
	}

	_getData_row_mutGetAdditionalValues ({it, ix}) {
		return {
			type: it.type,
		};
	}

	_renderInner_absorbListItems_fnGetValues (it) {
		return {
			...super._renderInner_absorbListItems_fnGetValues(it),
			type: it.type,
		};
	}
}

ImportListReward.UserChoose = class extends MixinUserChooseImporter(ImportListReward) {};

var ImportListReward$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ImportListReward: ImportListReward
});

class DataConverterCharCreationOption extends DataConverterFeature {
	static _SIDE_LOAD_OPTS = {
		propBrew: "foundryCharoption",
		fnLoadJson: async () => this._pGetPreloadSideData(),
		propJson: "charoption",
	};

	static init () {
		PageFilterClassesFoundry.setImplSideData("charoption", this);
	}

	static async pGetDereferencedFeatureItem (feature) {
		const hash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CHAR_CREATION_OPTIONS](feature);
		return DataLoader.pCacheAndGet(UrlUtil.PG_CHAR_CREATION_OPTIONS, feature.source, hash, {isCopy: true});
	}

	static async pGetInitFeatureLoadeds (feature, {actor = null} = {}) {
		const asFeatRef = {charoption: `${feature.name}|${feature.source}`};
		await PageFilterClassesFoundry.pInitCharCreationOptionLoadeds({charoption: asFeatRef, raw: feature, actor});
		return asFeatRef;
	}

		static async pGetDocumentJson (ent, opts) {
		opts = opts || {};
		if (opts.actor) opts.isActorItem = true;

		Renderer.get().resetHeaderIndex();

		return this._pGetCharCreationOptionItem(ent, opts);
	}

	static async _pGetCharCreationOptionItem (ent, opts) {
		const descriptionValue = Config.get("importCharCreationOption", "isImportDescription")
			? await UtilDataConverter.pGetWithDescriptionPlugins(() => {
				const prerequisite = Renderer.utils.prerequisite.getHtml(ent.prerequisite);
				return `<div>
					${prerequisite ? `<p>${prerequisite}</p>` : ""}
					${Renderer.get().setFirstSection(true).render({entries: ent.entries}, 2)}
				</div>`;
			})
			: null;

		const img = await this._pGetSaveImagePath(ent, {propCompendium: "charoption", taskRunner: opts.taskRunner});

		const additionalData = await this._pGetDataSideLoaded(ent);
		const additionalFlags = await this._pGetFlagsSideLoaded(ent);

		const effectsSideTuples = await this._pGetEffectsSideLoadedTuples({ent, img, actor: opts.actor});
		effectsSideTuples.forEach(({effect, effectRaw}) => DataConverter.mutEffectDisabledTransfer(effect, "importCharCreationOption", UtilActiveEffects.getDisabledTransferHintsSideData(effectRaw)));

		const out = {
			name: UtilApplications.getCleanEntityName(UtilDataConverter.getNameWithSourcePart(ent, {isActorItem: opts.isActorItem})),
			system: {
				source: UtilDataConverter.getSourceWithPagePart(ent),
				description: {value: descriptionValue, chat: "", unidentified: ""},

				activation: {type: "", cost: 0, condition: ""},
				duration: {value: 0, units: ""},
				target: {value: 0, units: "", type: ""},
				range: {value: 0, long: 0, units: null},
				uses: {value: 0, max: 0, per: ""},
				ability: "",
				actionType: "",
				attackBonus: null,
				chatFlavor: "",
				critical: {threshold: null, damage: ""},
				damage: {parts: [], versatile: ""},
				formula: "",
				save: {ability: "", dc: null},
				requirements: "",
				recharge: {value: 0, charged: true},

				...additionalData,
			},
			ownership: {default: 0},
			type: "feat",
			img,
			flags: {
				...this._getCharCreationOptionFlags(ent, opts),
				...additionalFlags,
			},
			effects: DataConverter.getEffectsMutDedupeId(effectsSideTuples.map(it => it.effect)),
		};

		if (opts.defaultOwnership != null) out.ownership = {default: opts.defaultOwnership};
		else if (opts.isAddDefaultOwnershipFromConfig) out.ownership = {default: Config.get("importCharCreationOption", "ownership")};
		if (opts.userOwnership) Object.assign(out.ownership, opts.userOwnership);

		return out;
	}

	static _getCharCreationOptionFlags (ent, opts) {
		opts = opts || {};

		const out = {
			[SharedConsts.MODULE_ID]: {
				page: UrlUtil.PG_CHAR_CREATION_OPTIONS,
				source: ent.source,
				hash: UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CHAR_CREATION_OPTIONS](ent),
			},
		};

		if (opts.isAddDataFlags) {
			out[SharedConsts.MODULE_ID].propDroppable = "charoption";
			out[SharedConsts.MODULE_ID].filterValues = opts.filterValues;
		}

		return out;
	}

	static async _pGetPreloadSideData () {
		if (!this._SIDE_DATA) this._SIDE_DATA = await Vetools.pGetCharCreationOptionSideData();
		return this._SIDE_DATA;
	}
}

var DataConverterCharCreationOption$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DataConverterCharCreationOption: DataConverterCharCreationOption
});

class ImportListCharCreationOption extends ImportListFeature {
		static init () {
		this._initCreateSheetItemHook({
			prop: "charoption",
			importerName: "Character Creation Option",
		});
	}
	
	static get ID () { return "character-creation-options"; }
	static get DISPLAY_NAME_TYPE_SINGLE () { return "Character Creation Option"; }
	static get DISPLAY_NAME_TYPE_PLURAL () { return "Character Creation Options"; }
	static get PROPS () { return ["charoption"]; }

	static _ = this.registerImpl(this);

	_dirsHomebrew = ["charoption"];
	_titleSearch = "character creation option";
	_sidebarTab = "items";
	_gameProp = "items";
	_defaultFolderPath = ["Character Creation Options"];
	_pageFilter = new PageFilterCharCreationOptions();
	_page = UrlUtil.PG_CHAR_CREATION_OPTIONS;
	_isPreviewable = true;
	_isDedupable = true;
	_configGroup = "importCharCreationOption";
	static _DataConverter = DataConverterCharCreationOption;

	async _pGetSources () {
		return [
			new UtilDataSource.DataSourceUrl(
				Config.get("ui", "isStreamerMode") ? "SRD" : "5etools",
				Vetools.DATA_URL_CHAR_CREATION_OPTIONS,
				{
					filterTypes: [UtilDataSource.SOURCE_TYP_OFFICIAL_ALL],
					isDefault: true,
				},
			),
			...UtilDataSource.getSourcesCustomUrl(),
			...UtilDataSource.getSourcesUploadFile(),
			...(await this._pGetSourcesPrerelease()),
			...(await this._pGetSourcesBrew()),
		];
	}

	_colWidthName = 6;
	_colWidthSource = 1;

	_getData_cols_otherPre () {
		return [
			{
				name: "Type",
				width: 4,
				field: "type",
				rowClassName: "text-center",
			},
		];
	}

	_getData_row_mutGetAdditionalValues ({it, ix}) {
		return {
			type: it._fOptionType,
		};
	}

	_renderInner_absorbListItems_fnGetValues (it) {
		return {
			...super._renderInner_absorbListItems_fnGetValues(it),
			type: it._fOptionType,
		};
	}
}

ImportListCharCreationOption.UserChoose = class extends MixinUserChooseImporter(ImportListCharCreationOption) {};

var ImportListCharCreationOption$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ImportListCharCreationOption: ImportListCharCreationOption
});

class DataConverterDeity extends DataConverterJournal {
	static get _CONFIG_GROUP () { return "importDeity"; }

		static async pGetDocumentJson (deity, opts) {
		opts = opts || {};

		Renderer.get().resetHeaderIndex();

		const content = await UtilDataConverter.pGetWithDescriptionPlugins(() => {
			return `<div>
				${Renderer.deity.getOrderedParts(deity, `<p>`, `</p>`)}
				${deity.entries ? `<div>${Renderer.get().setFirstSection(true).render({entries: deity.entries}, 1)}</div>` : ""}
			</div>`;
		});

		const img = await this._pGetSaveImagePath(deity, {taskRunner: opts.taskRunner});

		const name = UtilApplications.getCleanEntityName(UtilDataConverter.getNameWithSourcePart(deity, {displayName: deity.title ? `${deity.name}, ${deity.title.toTitleCase()}` : null}));
		const out = {
			name,
			pages: this._getPages({name, content, img}),
			ownership: {default: 0},
			flags: {
				...this._getDeityFlags(deity, opts),
			},
		};

		this._mutOwnership(out, opts);

		return out;
	}

	static _getDeityFlags (deity) {
		return {
			[SharedConsts.MODULE_ID]: {
				page: UrlUtil.PG_DEITIES,
				source: deity.source,
				hash: UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_DEITIES](deity),
			},
		};
	}

	static _pGetImgCustom (deity) {
		return deity.symbolImg
			? Renderer.utils.getMediaUrl(deity.symbolImg, "href", "img")
			: null;
	}
}

var DataConverterDeity$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DataConverterDeity: DataConverterDeity
});

class ImportListDeity extends ImportListJournal {
	static get ID () { return "deities"; }
	static get DISPLAY_NAME_TYPE_PLURAL () { return "Deities"; }
	static get PROPS () { return ["deity"]; }

	static _ = this.registerImpl(this);

	static get FOLDER_TYPE () { return "JournalEntry"; }

	_dirsHomebrew = ["deity"];
	_titleSearch = "deity";
	_sidebarTab = "journal";
	_gameProp = "journal";
	_defaultFolderPath = ["Deities"];
	_pageFilter = new PageFilterDeities();
	_page = UrlUtil.PG_DEITIES;
	_isPreviewable = true;
	_isDedupable = true;
	_configGroup = "importDeity";
	static _DataConverter = DataConverterDeity;

	async _pGetSources () {
		return [
			new UtilDataSource.DataSourceUrl(
				Config.get("ui", "isStreamerMode") ? "SRD" : "5etools",
				Vetools.DATA_URL_DEITIES,
				{
					filterTypes: [UtilDataSource.SOURCE_TYP_OFFICIAL_ALL],
					isDefault: true,
				},
			),
			...UtilDataSource.getSourcesCustomUrl(),
			...UtilDataSource.getSourcesUploadFile(),
			...(await this._pGetSourcesPrerelease()),
			...(await this._pGetSourcesBrew()),
		];
	}

	_colWidthName = 3;

	_getData_cols_other () {
		return [
			{
				name: "Pantheon",
				width: 2,
				field: "pantheon",
				rowClassName: "text-center",
			},
			{
				name: "Alignment",
				width: 1,
				field: "alignment",
				rowClassName: "text-center",
			},
			{
				name: "Domains",
				width: 3,
				field: "domains",
			},
		];
	}

	_getData_row_mutGetAdditionalValues ({it, ix}) {
		it._lAlignment = it.alignment ? it.alignment.join("") : "\u2014";
		it._lDomains = it.domains ? it.domains.join(", ") : "";

		return {
			pantheon: it.pantheon,
			alignment: it._lAlignment,
			domains: it._lDomains,
		};
	}

	_renderInner_absorbListItems_fnGetValues (it) {
		return {
			...super._renderInner_absorbListItems_fnGetValues(it),
			pantheon: it.pantheon,
			alignment: it._lAlignment,
			domains: it._lDomains,
		};
	}

	_getAsTag (listItem) {
		const tag = Parser.getPropTag(this._content[listItem.ix].__prop);
		return `@${tag}[${DataUtil.deity.packUidDeity(this._content[listItem.ix])}]`;
	}
}

var ImportListDeity$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ImportListDeity: ImportListDeity
});

class DataConverterRecipe extends DataConverterJournal {
	static get _CONFIG_GROUP () { return "importRecipe"; }

		static async pGetDocumentJson (recipe, opts) {
		opts = opts || {};

		Renderer.get().resetHeaderIndex();

		const content = await this._pGetWithJournalDescriptionPlugins(() => Renderer.recipe.getBodyHtml(recipe));

		const fluff = await Renderer.utils.pGetFluff({
			entity: recipe,
			fluffUrl: `data/fluff-recipes.json`,
			fluffProp: "recipeFluff",
		});

		const imgMeta = await this._pGetSaveImagePathMeta(recipe, {fluff, taskRunner: opts.taskRunner});

		const name = UtilApplications.getCleanEntityName(UtilDataConverter.getNameWithSourcePart(recipe));
		const out = {
			name,
			pages: this._getPages({name, content, img: imgMeta?.isFallback ? null : imgMeta?.img}),
			ownership: {default: 0},
			flags: {
				...this._getRecipeFlags(recipe, opts),
			},
		};

		this._mutOwnership(out, opts);

		return out;
	}

	static _getRecipeFlags (recipe) {
		return {
			[SharedConsts.MODULE_ID]: {
				page: UrlUtil.PG_RECIPES,
				source: recipe.source,
				hash: UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_RECIPES](recipe),
			},
		};
	}
}

var DataConverterRecipe$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DataConverterRecipe: DataConverterRecipe
});

class ImportListRecipe extends ImportListJournal {
	static get ID () { return "recipes"; }
	static get DISPLAY_NAME_TYPE_PLURAL () { return "Recipes"; }
	static get PROPS () { return ["recipe"]; }

	static _ = this.registerImpl(this);

	static get FOLDER_TYPE () { return "JournalEntry"; }

	_dirsHomebrew = ["recipe"];
	_titleSearch = "recipe";
	_sidebarTab = "journal";
	_gameProp = "journal";
	_defaultFolderPath = ["Recipes"];
	_pageFilter = new PageFilterRecipes();
	_page = UrlUtil.PG_RECIPES;
	_isPreviewable = true;
	_isDedupable = true;
	_configGroup = "importRecipe";
	_pFnGetFluff = Renderer.recipe.pGetFluff.bind(Renderer.recipe);
	static _DataConverter = DataConverterRecipe;

	async _pPostLoad (fileData) {
		DataUtil.recipe.postProcessData(fileData);
		return fileData;
	}

	async _pGetSources () {
		const nxtOpts = {pPostLoad: this._pPostLoad.bind(this)};

		return [
			new UtilDataSource.DataSourceUrl(
				Config.get("ui", "isStreamerMode") ? "SRD" : "5etools",
				Vetools.DATA_URL_RECIPES,
				{
					...nxtOpts,
					filterTypes: [UtilDataSource.SOURCE_TYP_OFFICIAL_ALL],
					isDefault: true,
				},
			),
			...UtilDataSource.getSourcesCustomUrl({...nxtOpts}),
			...UtilDataSource.getSourcesUploadFile({...nxtOpts}),
			...(await this._pGetSourcesPrerelease(nxtOpts)),
			...(await this._pGetSourcesBrew(nxtOpts)),
		];
	}

	_renderInner_getListSyntax () {
		return new ListSyntaxRecipes({
			fnGetDataList: () => this._content,
			pFnGetFluff: this._pFnGetFluff,
		}).build();
	}

	_colWidthName = 5;

	_getData_cols_other () {
		return [
			{
				name: "Type",
				width: 4,
				field: "type",
			},
		];
	}

	_getData_row_mutGetAdditionalValues ({it, ix}) {
		it._lType = it.type || "\u2014";

		return {
			type: it._lType = it.type || "\u2014",
		};
	}

	_renderInner_absorbListItems_fnGetValues (it) {
		return {
			...super._renderInner_absorbListItems_fnGetValues(it),
			type: it._lType,
		};
	}
}

var ImportListRecipe$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ImportListRecipe: ImportListRecipe
});

class NoteImageCreator {
	static async pCreateImageGetUrl ({name}) {
		if (!name) throw new Error(`No puck name provided!`);

				if (NoteImageCreator._CACHE_URLS[name]) return NoteImageCreator._CACHE_URLS[name];

		const img = await this._pGetBlankPuckImage();
		const tokenBlob = await this._pGetPuckBlob({name, img});
		const out = await Vetools.pSaveImageToServerAndGetUrl({blob: tokenBlob, path: `puck/${name}.png`});

		NoteImageCreator._CACHE_URLS[name] = out;

		return out;
	}

	static async _pGetBlankPuckImage () {
		return UtilImage.pLoadTempImage(`modules/${SharedConsts.MODULE_ID}/media/img/puck.png`, {isCacheable: true});
	}

	static _pGetPuckBlob ({name, img}) {
		return UtilImage.pDrawTextGetBlob({
			text: name,
			img,
			bbX0: NoteImageCreator._BB_X0,
			bbX1: NoteImageCreator._BB_X1,
			bbY0: NoteImageCreator._BB_Y0,
			bbY1: NoteImageCreator._BB_Y1,
			color: NoteImageCreator._COLOR_TEXT,
			font: `"Times New Roman", Times, serif`,
			isBold: true,
		});
	}
}
NoteImageCreator._COLOR_TEXT = "#010101";
NoteImageCreator._BB_X0 = 12;
NoteImageCreator._BB_X1 = 128;
NoteImageCreator._BB_Y0 = 39;
NoteImageCreator._BB_Y1 = 105;

NoteImageCreator._CACHE_URLS = {};

class PageFilterMaps extends PageFilter {
	constructor () {
		super();
		this._sourceFilter = new SourceFilter();
		this._typeFilter = new Filter({
			header: "Type",
			items: ["map", "mapPlayer"],
			displayFn: Parser.imageTypeToFull,
		});
		this._gridTypeFilter = new Filter({
			header: "Grid Type",
			items: [
				...Object.keys(Parser.MAP_GRID_TYPE_TO_FULL),
				"Unknown",
			],
			displayFn: Parser.mapGridTypeToFull,
		});
		this._gridUnitFilter = new Filter({
			header: "Grid Units",
			items: [
				Parser.UNT_FEET,
				Parser.UNT_YARDS,
				Parser.UNT_MILES,
				"Unknown",
			],
			displayFn: Parser.spDistanceTypeToFull,
		});
	}

	static mutateForFilters (it) {
		it._fGridType = it.grid?.type || "Unknown";
		it._fGridUnit = it.grid?.units || Parser.UNT_FEET;
	}

	addToFilters (it, isExcluded) {
		if (isExcluded) return;

		this._sourceFilter.addItem(it.source);
		this._typeFilter.addItem(it.imageType);
		this._gridTypeFilter.addItem(it._fGridType);
		this._gridUnitFilter.addItem(it._fGridUnit);
	}

	async _pPopulateBoxOptions (opts) {
		opts.filters = [
			this._sourceFilter,
			this._typeFilter,
			this._gridTypeFilter,
			this._gridUnitFilter,
		];
	}

	toDisplay (values, it) {
		return this._filterBox.toDisplay(
			values,
			it.source,
			it.imageType,
			it._fGridType,
			it._fGridUnit,
		);
	}
}

class ImportListMap extends ImportList {
	static get ID () { return "maps"; }
	static get DISPLAY_NAME_TYPE_PLURAL () { return "Maps"; }
	static get PROPS () { return ["map"]; }

	static _ = this.registerImpl(this);

	static get FOLDER_TYPE () { return "Scene"; }

	_dirsHomebrew = ["adventure", "book"];
	_titleSearch = "map";
	_sidebarTab = "scenes";
	_gameProp = "scenes";
	_defaultFolderPath = [];
	_pageFilter = new PageFilterMaps();
	_page = UrlUtil.PG_MAPS;
	_isPreviewable = true;
	_isNotDroppable = true;
	_configGroup = "importMap";
	_namespace = "map";

	async _pGetSources () {
		const adventureIndex = await Vetools.pGetAdventureIndex();
		const bookIndex = await Vetools.pGetBookIndex();

		const vetIndex = [
			...adventureIndex.adventure,
			...bookIndex.book,
		]
			.sort((a, b) => SortUtil.ascSortDate(b._pubDate, a._pubDate) || SortUtil.ascSortLower(a.name, b.name));

		return [
			...vetIndex.map(it => new UtilDataSource.DataSourceUrl(
				it.name,
				it._url,
				{
					pPostLoad: this._pPostLoadVetools.bind(this),
					userData: it,
					filterTypes: UtilDataSource.getSourceFilterTypes(it.source),
					source: it.source,
				}),
			),
			...UtilDataSource.getSourcesCustomUrl({pPostLoad: this._pPostLoadOther.bind(this)}),
			...UtilDataSource.getSourcesUploadFile({pPostLoad: this._pPostLoadOther.bind(this)}),
			...(await this._pGetSourcesPrerelease({pPostLoad: this._pPostLoadOther.bind(this)})),
			...(await this._pGetSourcesBrew({pPostLoad: this._pPostLoadOther.bind(this)})),
		];
	}

	_pPostLoadVetools (json, userData) {
		return this._pPostLoadShared({head: userData, body: json});
	}

	_pPostLoadOther (data) {
		const objs = [
			{propData: "adventureData", prop: "adventure"},
			{propData: "bookData", prop: "book"},
		]
			.map(({prop, propData}) => {
				if (!data[prop] || !data[propData]) return null;

				const tuples = data[prop]
					.map(head => {
						const body = data[propData].find(it => it.id === head.id);
						if (!body) return null;
						return {
							head,
							body,
						};
					})
					.filter(Boolean);

				return tuples
					.map(it => this._pPostLoadShared({head: it.head, body: it.body}));
			})
			.filter(Boolean)
			.flat();

		return {map: objs.map(it => it.map).flat()};
	}

	_pPostLoadShared ({body, head}) {
		const mapEntries = [];

		const availableMaps = {}; 		const entryIdToMap = {};
		const entryIdToName = {};

		const walker = MiscUtil.getWalker({isNoModification: true});

		body.data.forEach((ch, ixCh) => {
			walker.walk(
				ch,
				{
					object: (obj, lastKey, stack) => {
						UtilAdventureBook.doProcessNode_mutAddMaps({
							availableMaps,
							entryIdToMap,
							entryIdToName,
							entry: obj,
							entryStack: stack,
							source: head.source,
							chapterInfo: head.contents?.[ixCh],
						});
						return obj;
					},
				},
				undefined,
				[],
			);
		});

				UtilAdventureBook.mutMapNames({availableMaps, entryIdToMap, entryIdToName});

				Object.values(availableMaps)
			.forEach(urlToEntry => {
				Object.values(urlToEntry)
					.forEach(entry => {
						mapEntries.push(entry);
					});
			});

		return {map: mapEntries};
	}

	_renderInner_getListSyntax () {
		return null;
	}

	_renderInner_absorbListItems_fnGetValues (it) {
		return {
			type: it.imageType,
			source: it.source,
		};
	}

	_getDuplicateCheckFlags (docData) {
		if (!docData.flags?.[SharedConsts.MODULE_ID]?.dedupeKey) return null;

		return {
			[SharedConsts.MODULE_ID]: {
				dedupeKey: docData.flags[SharedConsts.MODULE_ID].dedupeKey,
			},
		};
	}

	getFolderPathMeta () {
		return {
			...super.getFolderPathMeta(),
			chapterName: {
				label: "Chapter Name",
				getter: it => it._chapterName || "(Unnamed Chapter)",
			},
			type: {
				label: "Type",
				getter: it => Parser.imageTypeToFull(it.imageType),
			},
		};
	}

		async _pImportEntry (ent, importOpts, dataOpts) {
		importOpts = importOpts || {};

		console.log(...LGT, `Importing map "${ent.name}" (from "${Parser.sourceJsonToAbv(ent.source)}")`);

		if (this._actor) throw new Error(`Cannot import map content to actor!`);

		const importMeta = await this._pImportEntry_pImportToDirectoryGeneric(ent, importOpts);

		if (importMeta.status === ConstsTaskRunner.TASK_EXIT_SKIPPED_DUPLICATE) return importMeta;

		const scene = importMeta.imported?.[0]?.document;
		if (!scene) return importMeta;

				const dataThumbnail = await scene.createThumbnail();
		await scene.update({thumb: dataThumbnail.thumb}, {diff: false});
		
		await this._pImportScene_pFillScene({entry: ent, entryIdToJournalId: importOpts.entryIdToJournalId, scene});

		return importMeta;
	}

	async _pImportEntry_pImportToDirectoryGeneric_pGetImportableData (it, getItemOpts) {
		return this._pGetMapScene({entry: it});
	}

	async _pGetMapScene ({entry}) {
		let url = Vetools.getImageUrl(entry);
		url = await Vetools.pOptionallySaveImageToServerAndGetUrl(url);

		const {width, height} = await this.constructor._pGetImageDimensions({entry, url});

				const additionalRoot = entry.foundrySceneRoot || {};
		const additionalFlags = entry.foundrySceneFlags || {};

		return {
			name: entry.name,
			active: false,
			navigation: Config.get("importMap", "isSceneAddToNavigation"),
			width: Math.round(width * this._getGridScale({entry})),
			height: Math.round(height * this._getGridScale({entry})),

			background: {
				src: url,
				offsetX: this._getGridOffsetX({entry}),
				offsetY: this._getGridOffsetY({entry}),
				scaleX: 1,
				scaleY: 1,
			},

			padding: Config.get("importMap", "scenePadding"),
			backgroundColor: Config.get("importMap", "sceneBackgroundColor"),
			tokenVision: Config.get("importMap", "isSceneTokenVision"),
			fogExploration: Config.get("importMap", "isSceneFogExploration"),

			grid: {
				size: this._getGridSize({entry}),
				units: this._getGridUnits({entry}),
				distance: this._getGridDistance({entry}),
				type: this._getGridType({entry}),
			},

			...additionalRoot,

			flags: {
				...this._getMapFlags(entry),
				...additionalFlags,
			},

			_stats: {
				coreVersion: game.version,
			},
		};
	}

	_getGridScale ({entry}) {
		return entry.grid?.scale ?? 1;
	}

	_getGridDistance ({entry}) {
		const distance = entry.grid?.distance ?? 5;
		const unit = entry.grid?.units ?? "ft";
		return Config.getMetricNumberDistance({configGroup: "importMap", originalValue: distance, originalUnit: unit, configKey: "isSceneGridMetric"});
	}

	_getGridUnits ({entry}) {
		const unit = entry.grid?.units ?? Parser.UNT_FEET;
		return Config.getMetricUnitDistance({configGroup: "importMap", originalUnit: unit, configKey: "isSceneGridMetric"});
	}

	_getGridSize ({entry}) { return entry.grid?.size ?? 100; }
	_getGridOffsetX ({entry}) { return entry.grid?.offsetX ?? 0; }
	_getGridOffsetY ({entry}) { return entry.grid?.offsetY ?? 0; }

	_getGridType ({entry}) {
		if (!entry.grid?.type) return 1;
		switch (entry.grid.type) {
			case "none": return 0;
			case "square": return 1;
			case "hexRowsOdd": return 2;
			case "hexRowsEven": return 3;
			case "hexColsOdd": return 4;
			case "hexColsEven": return 5;
			default: throw new Error(`Unknown image grid type: "${entry.grid.type}"`);
		}
	}

	_getMapFlags (entry) {
		return {
			[SharedConsts.MODULE_ID]: {
												dedupeKey: (new URL(Vetools.getImageUrl(entry), document.baseURI)).pathname.replace(/^\/img\//, ""),
			},
		};
	}

	static async _pGetImageDimensions ({entry, url}) {
				if (entry.width && entry.height) return {width: entry.width, height: entry.height};

				const image = await UtilImage.pLoadImage(url);
		return {width: image.naturalWidth, height: image.naturalHeight};
	}

	async _pImportScene_pFillScene ({entry, entryIdToJournalId, scene}) {
		const parentEntry = entry._parentEntry;
		const mapRegions = entry.mapRegions || parentEntry?.mapRegions;

		if (!mapRegions?.length) return;

		const imageWidth = scene.width;
		const imageHeight = scene.height;

		const noteDatas = [];
		for (const mapRegion of mapRegions) {
			if (!mapRegion.area || !mapRegion.points?.length) continue;

			const areaJournalDocs = entryIdToJournalId?.[mapRegion.area];
			if (!areaJournalDocs) continue;

			const {journalEntryDoc, journalPageDoc} = areaJournalDocs;

			const name = mapRegion.name || "-";
			const puckName = this.constructor._getPuckName({name});

			const puckUrl = await NoteImageCreator.pCreateImageGetUrl({name: puckName});

			const mapRegionPoints = await this.constructor._pGetMapRegionPoints({mapRegion, entry, imageWidth, imageHeight, parentEntry});
			const position = UtilCanvas.getCentroid(mapRegionPoints);

			noteDatas.push(
				{
					entryId: journalEntryDoc.id,
					pageId: journalPageDoc.id,
					icon: puckUrl,
					iconSize: Math.ceil((scene?.grid?.size ?? 100) / 2),
					text: name,
															x: position[0] + (entry.grid?.offsetX || 0),
					y: position[1] + (entry.grid?.offsetY || 0),
				},
			);
		}

		await scene.createEmbeddedDocuments("Note", noteDatas);
	}

	static _getPuckName ({name}) {
				const nameSplit = name.split(/[.;:!]/g);
		return nameSplit.length === 1
						? nameSplit[0].replace(/[()"']/g, "").split(/ /g).map(it => it[0]).join(".")
			: nameSplit[0];
	}

	static async _pGetMapRegionPoints ({mapRegion, entry, imageWidth, imageHeight, parentEntry}) {
		if (!parentEntry) return mapRegion.points;

		const parentUrl = Vetools.getImageUrl(parentEntry);
		const {width: imageWidthParent, height: imageHeightParent} = await this._pGetImageDimensions({entry: parentEntry, url: parentUrl});

		const offsetX = entry.mapParent.offsetX || 0;
		const offsetY = entry.mapParent.offsetY || 0;
		const scaleX = entry.mapParent.scaleX ?? (entry.mapParent.scaleAuto ? (imageWidthParent / imageWidth) : 1);
		const scaleY = entry.mapParent.scaleY ?? (entry.mapParent.scaleAuto ? (imageHeightParent / imageHeight) : 1);

		return mapRegion.points.map(([x, y]) => {
			return [
				Math.round((x * (1 / scaleX)) + offsetX),
				Math.round((y * (1 / scaleY)) + offsetY),
			];
		});
	}

	_$getListPreviewStats (page, entity, opts) {
		return Renderer.hover.$getHoverContent_stats(
			"generic",
			entity,
			{
				isBookContent: true,
				isStatic: opts.isStatic,
			},
		);
	}

	_renderInner_initPreviewButton (item, btnShowHidePreview) {
		ListUiUtil.bindPreviewButton(
			this._page,
			this._content,
			item,
			btnShowHidePreview,
			{
				$fnGetPreviewStats: this._$getListPreviewStats.bind(this),
			},
		);
	}
}

var ImportListMap$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ImportListMap: ImportListMap
});

class PageFilterImportSpecialPackages extends PageFilter {
	constructor () {
		super();

		this._typeFilter = new Filter({header: "Type"});
		this._authorFilter = new Filter({header: "Author"});
	}

	static mutateForFilters (it) {
		it._fType = [];
		if (it.manifesturlModule) it._fType.push("Module");
		if (it.manifesturlWorld) it._fType.push("World");

		it._fAuthor = it._lAuthor || ["Unknown"];
	}

	addToFilters (it, isExcluded) {
		if (isExcluded) return;

		this._typeFilter.addItem(it._fType);
		this._authorFilter.addItem(it._fAuthor);
	}

	async _pPopulateBoxOptions (opts) {
		opts.filters = [
			this._typeFilter,
			this._authorFilter,
		];
	}

	toDisplay (values, it) {
		return this._filterBox.toDisplay(
			values,
			it._fType,
			it._fAuthor,
		);
	}
}

class _SpecialPackageDataNormalizer {
	static getNormalized (packageIndex) {
		const out = MiscUtil$1.copy(packageIndex);

		this._NORMALIZABLE_PROPS
			.forEach(prop => {
				if (!out[prop]) return;
				out[prop] = this._getNormalizedProp({arr: out[prop]});
			});

		return out;
	}

	static _NORMALIZABLE_PROPS = [
		"module",
		"world",
	];

	static _getNormalizedProp ({arr}) {
		return arr
			.filter(Boolean)
			.map(meta => {
								meta.manifest = meta.manifest || meta.manifesturl;
				delete meta.manifesturl;

								meta.title = meta.title || meta.name;
				delete meta.name;

								meta.id = meta.id || meta.source;
				delete meta.source;

								meta.description = meta.description || meta.entries;
				delete meta.entries;

								meta.authors = [
					meta.authors || [],
					meta.author,
				]
					.flat()
					.filter(Boolean)
					.map(author => {
						if (typeof author === "string") return {name: `${author}`.trim()};
						return author;
					});
				delete meta.author;

								if (!meta.compatibility && (meta.coreVersion || meta.compatibleCoreVersion)) {
					meta.compatibility = {};
					if (meta.coreVersion) meta.compatibility.minimum = meta.coreVersion;
					if (meta.compatibleCoreVersion) meta.compatibility.verified = meta.compatibleCoreVersion;
				}
				delete meta.coreVersion;
				delete meta.compatibleCoreVersion;

				return meta;
			});
	}
}

class ImportSpecialPackages extends Application {
	static getNonLegacyNoteHtml () {
		return `<p>Note that core worlds have been removed from the default index. These worlds were/are community-created, and discussing them in relation to this module is prohibited, for the safety of both communities.</p>
		<p>You may switch to an alternate index by setting the &quot;Package Index URL&quot; in your <a class="veapp__lnk imp-pkg__lnk-config">config</a>.</p>`;
	}

	static bindNonLegacyNoteHandlers ($html) {
		$html.find(`.imp-pkg__lnk-config`)
			.click(evt => {
				evt.preventDefault();
				evt.stopPropagation();
				Config.pHandleButtonClick(evt, "importAdventure");
			});
	}

	constructor () {
		super({
			title: "Package Importer",
			template: `${SharedConsts.MODULE_LOCATION}/template/ImportSpecialPackages.hbs`,
			height: Util.getMaxWindowHeight(),
			width: 800,
			resizable: true,
		});

		this._packageIndex = null;
		this._pageFilter = null;

		this._list = null;
		this._listSelectClickHandler = null;

		this._rows = null;
	}

	async pInit () {
		const packageIndex = await this.constructor._getPackageIndex();
		this._packageIndex = await this.constructor.getMergedPackageIndex(packageIndex);
		this._pageFilter = new PageFilterImportSpecialPackages();
	}

	static async _getPackageIndex () {
		try {
			return _SpecialPackageDataNormalizer.getNormalized(await Vetools.pGetPackageIndex());
		} catch (e) {
			console.error(...LGT, e);
			return {};
		}
	}

	static async getMergedPackageIndex (packageIndex = null) {
		packageIndex = packageIndex || await this._getPackageIndex();
		packageIndex = MiscUtil$1.copy(packageIndex);

				const packages = [];

		(packageIndex.module || [])
			.filter(Boolean)
			.forEach(moduleMeta => {
				packages.push(moduleMeta);

				moduleMeta.manifesturlModule = moduleMeta.manifest;
				delete moduleMeta.manifest;

				const baseManifestUrl = (moduleMeta.manifesturlModule || "").split("/").slice(0, -1).join("/");

				const ixWorld = (packageIndex.world || []).findIndex(it => {
					if (it.id !== moduleMeta.id) return false;
					const baseWorldManifestUrl = this._getBaseManifestUrl(it.manifest);
					return baseWorldManifestUrl === baseManifestUrl;
				});

				if (!~ixWorld) return;

				const [worldMeta] = (packageIndex.world || []).splice(ixWorld, 1);
				worldMeta.manifesturlWorld = worldMeta.manifest;
				delete worldMeta.manifest;

								Object.entries(worldMeta)
					.forEach(([k, v]) => {
						if (moduleMeta[k]) return;
						moduleMeta[k] = v;
					});
							});

				(packageIndex.world || [])
			.filter(Boolean)
			.forEach(worldMeta => {
				worldMeta.manifesturlWorld = worldMeta.manifest;
				delete worldMeta.manifest;
				packages.push(worldMeta);
			});

		packages.forEach(it => {
			it._lAuthor = it.authors
				.map(it => it.name)
				.filter(Boolean);
			if (it.size) {
				it._sizeHumanReadable = Parser.bytesToHumanReadable(it.size, {fixedDigits: 0});
				it._sizeHumanReadableTitle = Parser.bytesToHumanReadable(it.size, {fixedDigits: 3});
			}
		});

		return {
			supportURL: packageIndex.supportURL,
			packages,
		};
	}

	getData () {
		this._rows = this._packageIndex.packages;
		return {
			packages: this._rows,
			isLegacy: Config.get("importAdventure", "isUseLegacyImporter"),
			nonLegacyHeader: this.constructor.getNonLegacyNoteHtml(),
			supportUrl: this._packageIndex.supportURL,
		};
	}

	activateListeners ($html) {
		super.activateListeners($html);

		this.constructor.bindNonLegacyNoteHandlers($html);

		this._activateListeners_initBtnRun($html);
		this._activateListeners_initBtnReset($html);
		this._activateListeners_pInitListAndFilters($html);
	}

	_activateListeners_getSelectedRow () {
		const selItem = this._list.items.find(it => it.data.cbSel.checked);
		if (!selItem) {
			ui.notifications.warn(`Please select something to import!`);
			return null;
		}

		selItem.ele.classList.remove("list-multi-selected");
		selItem.data.cbSel.checked = false;

		return this._rows[selItem.ix];
	}

	static async _activateListeners_pGetManifestData (manifestUrl) {
		let manifestData;
		try {
			manifestData = await DataUtil.loadJSON(manifestUrl);
		} catch (e) {
			ui.notifications.error(`Failed to load manifest file! ${VeCt.STR_SEE_CONSOLE}`);
			throw e;
		}
		return manifestData;
	}

	static async _pInstallManifest (manifest) {
		const respCheck = await fetch(
			Config.backendEndpoint,
			{
				method: "post",
				headers: {
					"Content-Type": "application/json",
				},
				body: JSON.stringify({
					type: "checkPackage",
					manifest: {...manifest, id: null},
				}),
			},
		);
		const checkJson = await respCheck.json();
		if (checkJson?.errors?.length) {
			const msg = `Could not install manifest:\n${checkJson.errors.join("\n")}`;
			ui.notifications.error(msg);
			console.error(msg);
			return false;
		}

		const resp = await fetch(
			Config.backendEndpoint,
			{
				method: "post",
				headers: {
					"Content-Type": "application/json",
				},
				body: JSON.stringify({
					type: "installPackage",
					manifest,
				}),
			},
		);
		await resp.json();

		return true;
	}

	static async _activateListeners_pInstallDependencies (installType, manifestData) {
		if (!manifestData.dependencies) return;

		const toBeInstalledDependencies = (manifestData.dependencies || []).filter(x => !game.data.modules.some(m => m.id === x.name));

		if (!toBeInstalledDependencies.length) return;

		const isUserInstall = await InputUiUtil.pGetUserBoolean({
			title: `${installType} "${manifestData.title}" has ${toBeInstalledDependencies.length} module dependenc${toBeInstalledDependencies.length === 1 ? "y" : "ies"}. Would you like to install them?`,
		});
		if (!isUserInstall) return;

		let cntErrors = 0;
		SceneNavigation.displayProgressBar({label: `Installing (1/${toBeInstalledDependencies.length})`, pct: 0});
		for (let i = 0; i < toBeInstalledDependencies.length; ++i) {
			try {
				const isInstallSuccess = await this._pInstallManifest({
					type: "module",
					id: manifestData.id,
					manifest: toBeInstalledDependencies[i].manifest,
				});
				if (!isInstallSuccess) cntErrors++;
			} catch (e) {
				cntErrors++;
				console.error(e);
			}
			SceneNavigation.displayProgressBar({label: `Installing (${i + 2}/${toBeInstalledDependencies.length})`, pct: ((i + 1) / toBeInstalledDependencies.length) * 100});
		}
		const cntInstalled = toBeInstalledDependencies.length - cntErrors;
		ui.notifications[cntErrors ? "error" : "info"](`${cntInstalled} module${cntInstalled === 1 ? "" : "s"} installed.${cntErrors ? ` ${cntErrors} error${cntErrors === 1 ? "" : "s"}. ${VeCt.STR_SEE_CONSOLE}` : ""}`);

				if (!cntErrors && cntInstalled) game.shutDown();
	}

	static async pImportManifesturlModule (manifesturlModule) {
		const manifestData = await this._activateListeners_pGetManifestData(manifesturlModule);
		if (!manifestData) return;

		if (!(await UtilBackend.pGetBackendVersion()) || !Config.get("importAdventure", "isUseModdedInstaller")) return this._pDisplayManualLinks(manifestData);

		if (ImportSpecialPackages._ACTIVE_INSTALLATION) return ui.notifications.warn(`Please wait until the currently running installation completes!`);
		ImportSpecialPackages._ACTIVE_INSTALLATION = true;

		try {
			const isInstallSuccess = await this._pInstallManifest({
				type: "module",
				id: manifestData.id,
				manifest: manifesturlModule,
			});
			if (!isInstallSuccess) ui.notifications.error(`Failed to install module!`);
		} catch (e) {
			ui.notifications.error(`Failed to install module! ${VeCt.STR_SEE_CONSOLE}`);
			throw e;
		} finally {
			ImportSpecialPackages._ACTIVE_INSTALLATION = false;
		}

				await this._activateListeners_pInstallDependencies("Module", manifestData);

		try {
			game.shutDown();
		} catch (e) {
			ui.notifications.info(`Module "${manifestData.title}" installed successfully. You must return to setup for this change to take effect!`);
			console.error(...LGT, e);
		}
	}

	static async pImportManifesturlWorld (manifesturlWorld) {
		const manifestData = await this._activateListeners_pGetManifestData(manifesturlWorld);
		if (!manifestData) return;

		if (!(await UtilBackend.pGetBackendVersion()) || !Config.get("importAdventure", "isUseModdedInstaller")) return this._pDisplayManualLinks(manifestData);

		if (ImportSpecialPackages._ACTIVE_INSTALLATION) return ui.notifications.warn(`Please wait until the currently running installation completes!`);
		ImportSpecialPackages._ACTIVE_INSTALLATION = true;

		try {
			const isInstallSuccess = await this._pInstallManifest({
				type: "world",
				id: manifestData.id,
				manifest: manifesturlWorld,
			});
			if (!isInstallSuccess) ui.notifications.error(`Failed to install world!`);
		} catch (e) {
			ui.notifications.error(`Failed to install world! ${VeCt.STR_SEE_CONSOLE}`);
			throw e;
		} finally {
			ImportSpecialPackages._ACTIVE_INSTALLATION = false;
		}

						
		try {
			game.shutDown();
		} catch (e) {
			ui.notifications.info(`World "${manifestData.title}" installed successfully. You must return to setup for this change to take effect!`);
			console.error(...LGT, e);
		}
	}

	static async _pDisplayManualLinks (manifestData) {
		const {$modalInner, doClose, doAutoResize: doAutoResizeModal} = await UtilApplications.pGetShowApplicationModal({
			title: `Manual Installation${manifestData.title ? `\u2014${manifestData.title}` : ""}`,
		});

		const $btnClose = $(`<button class="btn btn-default btn-sm">Close</button>`)
			.click(() => doClose());

		const $btnCopyAll = $(`<button class="btn btn-primary mr-2">Copy Links</button>`)
			.click(async () => {
				const txt = `# Manifest URL:
${manifestData.manifest}

${manifestData.dependencies && manifestData.dependencies.length ? `# Dependency Manifest URLs:
${manifestData.dependencies.map(it => it.manifest).join("\n")}` : ""}`.trim();

				await MiscUtil$1.pCopyTextToClipboard(txt);
				JqueryUtil.showCopiedEffect($btnCopyAll);
			});

		const ptDeps = manifestData.dependencies && manifestData.dependencies.length
			? manifestData.dependencies.map(meta => {
				const $dispUrl = $(`<code class="copyable">${meta.manifest}</code>`)
					.click(async () => {
						await MiscUtil$1.pCopyTextToClipboard(meta.manifest);
						JqueryUtil.showCopiedEffect($dispUrl);
					});

				return $$`<div class="py-1 split-v-center">
					<div class="mr-1">&quot;${meta.title || "(Unnamed)"}&quot;${meta._lAuthor ? ` <i>by</i> ${meta._lAuthor.joinConjunct(", ", " and ")}` : ""}:</div>
					${$dispUrl}
				</div>`;
			})
			: null;

		const $dispUrl = $(`<code class="copyable">${manifestData.manifest}</code>`)
			.click(async () => {
				await MiscUtil$1.pCopyTextToClipboard(manifestData.manifest);
				JqueryUtil.showCopiedEffect($dispUrl);
			});

		const $dispZip = $(`<code class="copyable">${manifestData.download}</code>`)
			.click(async () => {
				await MiscUtil$1.pCopyTextToClipboard(manifestData.download);
				JqueryUtil.showCopiedEffect($dispZip);
			});

		$$($modalInner)`<div class="ve-flex-col h-100">
			<div class="mt-1 mb-2 italic">For manual installation, the following links should be copy-pasted into the appropriate input forms in Foundry's &quot;Setup&quot; UI. For automatic installation, you must install and enable the backend mod. Instructions on how to do so are included in the module README, or can be found on the <a href="https://wiki.tercept.net/en/Plutonium/Plutonium_Installation" target="_blank">wiki</a>.</div>

			<div class="py-1 split-v-center">
				<div class="mr-1 bold">Manifest:</div>
				${$dispUrl}
			</div>

			${ptDeps ? `<hr class="hr-1"><h4 class="my-1">Dependencies</h4>` : ""}
			${ptDeps}

			<hr class="hr-1">
			<div class="py-1 split-v-center ve-muted">
				<div class="mr-1 bold help--hover" title="If you wish to download the zip manually and add it to your Foundry data directory, use this link. Otherwise, use the above manifest link(s) via Foundry's &quot;Setup&quot; UI">ZIP:</div>
				${$dispZip}
			</div>

			<div class="mt-auto">
				<div class="ve-flex-h-right ve-small mb-2">
					<i class="w-50 block text-right">We recommended that you paste the links into a notepad before closing this window and returning to setup.</i>
				</div>
				<div class="ve-flex-h-right">${$btnCopyAll}${$btnClose}</div>
			</div>
		</div>`;

		doAutoResizeModal();
	}

	_activateListeners_initBtnRun ($html) {
		$html.find(`[name="btn-run--module"]`).click(async () => {
			if (!this._list) return;

			const row = this._activateListeners_getSelectedRow();
			if (!row) return;

			if (!row.manifesturlModule) return ui.notifications.warn(`Please select a package which includes a module!`);

			await this.constructor.pImportManifesturlModule(row.manifesturlModule);
		});

		$html.find(`[name="btn-run--world"]`).click(async () => {
			if (!this._list) return;

			const row = this._activateListeners_getSelectedRow();
			if (!row) return;

			if (!row.manifesturlWorld) return ui.notifications.warn(`Please select a package which includes a module!`);

			await this.constructor.pImportManifesturlWorld(row.manifesturlWorld);
		});
	}

	_activateListeners_initBtnReset ($html) {
		this._$btnReset = $html.find(`[name="btn-reset"]`).click(() => {
			$html.find(`.search`).val("");
			if (this._list) this._list.reset();
		});
	}

	_activateListeners_pInitListAndFilters ($html) {
		this._$iptSearch = $html.find(`.search`);

				this._list = new List({
			$iptSearch: this._$iptSearch,
			$wrpList: $html.find(`.veapp__list`),
		});
		SortUtil.initBtnSortHandlers($html.find(`[data-name="wrp-btns-sort"]`), this._list);
		this._listSelectClickHandler = new ListSelectClickHandler({list: this._list});

		return this._pageFilter.pInitFilterBox({
			$iptSearch: this._$iptSearch,
			$btnReset: this._$btnReset,
			$btnOpen: $html.find(`[name=btn-filter]`),
			$btnToggleSummaryHidden: $html.find(`[name=btn-toggle-summary]`),
			$wrpMiniPills: $html.find(`.fltr__mini-view`),
			namespace: `ImportSpecialPackages`,
		}).then(() => {
			this._rows.forEach(it => this._pageFilter.addToFilters(it));

			this._list.doAbsorbItems(
				this._rows,
				{
					fnGetName: it => it.title,
					fnGetValues: it => ({
						name: it.title,
						author: it._lAuthor,
						module: !!it.manifesturlModule,
						world: !!it.manifesturlWorld,
					}),
					fnGetData: UtilList2.absorbFnGetData,
					fnBindListeners: it => UtilList2.absorbFnBindListenersRadio(this._listSelectClickHandler, it),
				},
			);

			this._list.init();

			this._pageFilter.trimState();
			this._pageFilter.filterBox.render();

			this._pageFilter.filterBox.on(
				FilterBox.EVNT_VALCHANGE,
				this._handleFilterChange.bind(this),
			);

			this._handleFilterChange();
		});
	}

	_handleFilterChange () {
		const f = this._pageFilter.filterBox.getValues();
		this._list.filter(li => this._pageFilter.toDisplay(f, this._rows[li.ix]));
	}

	static _getBaseManifestUrl (manifestUrl) { return (manifestUrl || "").split("/").slice(0, -1).join("/"); }
}
ImportSpecialPackages._ACTIVE_INSTALLATION = null;

class DataConverterHazard extends DataConverterJournal {
	static get _CONFIG_GROUP () { return "importHazard"; }

		static async pGetDocumentJson (haz, opts) {
		opts = opts || {};

		Renderer.get().resetHeaderIndex();

		const content = this._pGetWithJournalDescriptionPlugins(() => {
			const subtitle = Renderer.traphazard.getSubtitle(haz);
			return `<div>
				${subtitle ? `<div class="mb-1 italic">${subtitle}</div>` : ""}
				${Renderer.get().setFirstSection(true).render({entries: haz.entries}, 2)}
			</div>`;
		});

		const imgMeta = await this._pGetSaveImagePathMeta(haz, {taskRunner: opts.taskRunner});

		const name = UtilApplications.getCleanEntityName(UtilDataConverter.getNameWithSourcePart(haz));
		const out = {
			name,
			pages: this._getPages({name, content, img: imgMeta?.isFallback ? null : imgMeta?.img}),
			ownership: {default: 0},
			flags: {
				...this._getHazardFlags(haz, opts),
			},
		};

		this._mutOwnership(out, opts);

		return out;
	}

	static _getHazardFlags (haz) {
		return {
			[SharedConsts.MODULE_ID]: {
				page: UrlUtil.PG_TRAPS_HAZARDS,
				source: haz.source,
				hash: UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_TRAPS_HAZARDS](haz),
			},
		};
	}
}

var DataConverterHazard$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DataConverterHazard: DataConverterHazard
});

class ImportListHazard extends ImportListJournal {
	static get ID () { return "hazards"; }
	static get DISPLAY_NAME_TYPE_PLURAL () { return "Hazards"; }
	static get PROPS () { return ["hazard"]; }

	static _ = this.registerImpl(this);

	static get FOLDER_TYPE () { return "JournalEntry"; }

	_dirsHomebrew = ["hazard"];
	_titleSearch = "hazard";
	_sidebarTab = "journal";
	_gameProp = "journal";
	_defaultFolderPath = ["Hazards"];
	_pageFilter = new PageFilterTrapsHazards();
	_page = UrlUtil.PG_TRAPS_HAZARDS;
	_isPreviewable = true;
	_isDedupable = true;
	_configGroup = "importHazard";
	static _DataConverter = DataConverterHazard;

	async _pGetSources () {
		return [
			new UtilDataSource.DataSourceUrl(
				Config.get("ui", "isStreamerMode") ? "SRD" : "5etools",
				Vetools.DATA_URL_TRAPS_HAZARDS,
				{
					filterTypes: [UtilDataSource.SOURCE_TYP_OFFICIAL_ALL],
					isDefault: true,
				},
			),
			...UtilDataSource.getSourcesCustomUrl(),
			...UtilDataSource.getSourcesUploadFile(),
			...(await this._pGetSourcesPrerelease()),
			...(await this._pGetSourcesBrew()),
		];
	}

	_renderInner_getListSyntax () {
		return new ListSyntaxTrapsHazards({
			fnGetDataList: () => this._content,
		}).build();
	}

	_colWidthName = 7;

	_getData_cols_otherPre () {
		return [
			{
				name: "Type",
				width: 2,
				field: "trapType",
				rowClassName: "text-center",
			},
		];
	}

	_getData_row_mutGetAdditionalValues ({it, ix}) {
		it._lTrapType = Parser.trapHazTypeToFull(it.trapHazType);

		return {
			trapType: it._lTrapType,
		};
	}

	_renderInner_absorbListItems_fnGetValues (it) {
		return {
			...super._renderInner_absorbListItems_fnGetValues(it),
			trapType: it._lTrapType,
		};
	}
}

var ImportListHazard$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ImportListHazard: ImportListHazard
});

class DataConverterTrap extends DataConverter {
	static _SIDE_LOAD_OPTS = {
		propBrew: "foundryTrap",
		fnLoadJson: Vetools.pGetTrapHazardSideData.bind(Vetools),
		propJson: "trap",
	};
}

var DataConverterTrap$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DataConverterTrap: DataConverterTrap
});

class ImportListTrap extends ImportListActor {
	static get ID () { return "traps"; }
	static get DISPLAY_NAME_TYPE_PLURAL () { return "Traps"; }
	static get PROPS () { return ["trap"]; }

	static _ = this.registerImpl(this);

	_dirsHomebrew = ["trap"];
	_titleSearch = "trap";
	_sidebarTab = "actors";
	_gameProp = "actors";
	_defaultFolderPath = ["Traps"];
	_pageFilter = new PageFilterTrapsHazards();
	_page = UrlUtil.PG_TRAPS_HAZARDS;
	_isPreviewable = true;
	_isDedupable = true;
	_configGroup = "importTrap";
	static _DataConverter = DataConverterTrap;

	_actorType = "npc";

	async _pGetSources () {
		return [
			new UtilDataSource.DataSourceUrl(
				Config.get("ui", "isStreamerMode") ? "SRD" : "5etools",
				Vetools.DATA_URL_TRAPS_HAZARDS,
				{
					filterTypes: [UtilDataSource.SOURCE_TYP_OFFICIAL_ALL],
					isDefault: true,
				},
			),
			...UtilDataSource.getSourcesCustomUrl(),
			...UtilDataSource.getSourcesUploadFile(),
			...(await this._pGetSourcesPrerelease()),
			...(await this._pGetSourcesBrew()),
		];
	}

	_renderInner_getListSyntax () {
		return new ListSyntaxTrapsHazards({
			fnGetDataList: () => this._content,
		}).build();
	}

	_colWidthName = 7;

	_getData_cols_otherPre () {
		return [
			{
				name: "Type",
				width: 2,
				field: "trapType",
				rowClassName: "text-center",
			},
		];
	}

	_getData_row_mutGetAdditionalValues ({it, ix}) {
		it._lTrapType = Parser.trapHazTypeToFull(it.trapHazType);

		return {
			trapType: it._lTrapType,
		};
	}

		async _pImportEntry (trap, importOpts, dataOpts) {
		importOpts = importOpts || {};

		if (trap.__prop === "hazard" || ImportListTrap._TRAP_HAZ_TYPES_HAZARD.has(trap.trapHazType)) {
			const {ImportListHazard} = await Promise.resolve().then(function () { return ImportListHazard$1; });
			const importListHazard = new ImportListHazard({});
			await importListHazard.pInit();
			await importListHazard.pSyncStateFrom(this);
			return importListHazard._pImportEntry(trap, importOpts, dataOpts);
		}

		return super._pImportEntry(trap, importOpts, dataOpts);
	}

	async _pImportEntry_pGetImportMetadata (actor, trap, importOpts, importOptsEntity) {
		const act = {};

		const dataBuilderOpts = new ImportListTrap.ImportEntryOpts({actor});

		await this._pImportEntry_pFillBase(trap, act, dataBuilderOpts.fluff, {img: ImportListTrap._IMG_TRAP, taskRunner: importOpts.taskRunner});

		act.system = {};

		await this._pImportEntry_pFillFolder(trap, act, importOpts, importOptsEntity);

		if (importOpts.defaultOwnership != null) act.ownership = {default: importOpts.defaultOwnership};
		else act.ownership = {default: Config.get(this._configGroup, "ownership")};
		if (importOpts.userOwnership) Object.assign(act.ownership, importOpts.userOwnership);

		this._pImportEntry_fillData_Abilities(trap, act.system, dataBuilderOpts);
		this._pImportEntry_fillData_Attributes(trap, act.system, dataBuilderOpts);
		await this._pImportEntry_pFillData_Details(trap, act.system, dataBuilderOpts);
		this._pImportEntry_fillData_Traits(trap, act.system, dataBuilderOpts);
		this._pImportEntry_fillData_Currency(trap, act.system, dataBuilderOpts);
		this._pImportEntry_fillData_Skills(trap, act.system, dataBuilderOpts);
		this._pImportEntry_fillData_Spells(trap, act.system, dataBuilderOpts);
		this._pImportEntry_fillData_Bonuses(trap, act.system, dataBuilderOpts);
		this._pImportEntry_fillData_Resources(trap, act.system, dataBuilderOpts);

		const additionalData = await this.constructor._DataConverter._pGetDataSideLoaded(trap);
		foundry.utils.mergeObject(act.system, additionalData);

		await this._pImportEntry_pFillToken({importable: trap, actorData: act, img: ImportListTrap._IMG_TRAP, flags: this._getTokenFlags({trap}), taskRunner: importOpts.taskRunner});

		return {dataBuilderOpts: dataBuilderOpts, actorData: act};
	}

	_pImportEntry_fillData_Attributes (trap, sys) {
		const out = {};

		out.ac = {calc: "custom", formula: "0"};
		out.hp = {value: 0, max: 0};
		out.movement = {walk: 0};
		out.spellcasting = null;

		sys.attributes = out;
	}

	async _pImportEntry_pFillData_Details (trap, sys, dataBuilderOpts) {
		const out = {};

		out.cr = 0;
		out.xp = {value: 0};

		out.alignment = (trap.tier ? Parser.tierToFullLevel(trap.tier) : Renderer.traphazard.getTrapLevelPart(trap)) || "";

		out.type = {
			value: "custom",
			subtype: "",
			swarm: "",
			custom: trap.trapHazType ? Parser.trapHazTypeToFull(trap.trapHazType) : "",
		};

		out.source = UtilDataConverter.getSourceWithPagePart(trap);

		sys.details = out;
	}

	_pImportEntry_fillData_Traits (trap, sys) {
		const out = {};

		out.size = UtilActors.VET_SIZE_TO_ABV[trap.size] || "med";

		sys.traits = out;
	}

	_pImportEntry_fillData_Currency (trap, sys) {
		sys.currency = {pp: 0, gp: 0, ep: 0, sp: 0, cp: 0}; 	}

	_pImportEntry_fillData_Skills (trap, sys) {  }

	_pImportEntry_fillData_Spells (trap, sys) {  }

	_pImportEntry_fillData_Bonuses (trap, sys) {  }

	_pImportEntry_fillData_Resources (trap, sys) {  }

	async _pImportEntry_pFillItems (trap, act, dataBuilderOpts, importOpts) {
		if (trap.entries) {
			dataBuilderOpts.items.push(await DataConverter.pGetItemActorPassive(
				{name: "Description", entries: trap.entries},
				{
					mode: "object",
					fvttType: "feat",
					entity: trap,
					source: trap.source,
					img: ImportListTrap._IMG_TRAP,
					foundryFlags: {
						[SharedConsts.MODULE_ID]: {
							dedupeId: "description",
						},
					},
				},
			));
		}

		if (trap.trigger) {
			const entry = {name: "Trigger", entries: trap.trigger};
			dataBuilderOpts.items.push(await DataConverter.pGetItemActorPassive(
				entry,
				{
					mode: "object",
					fvttType: "feat",
					activationType: "special",
					entity: trap,
					source: trap.source,
					img: ImportListTrap._IMG_TRAP,
					foundryFlags: this.constructor._getTrapChildFlags({
						trap,
						prop: "trigger",
						entry,
						dedupeId: "trigger",
					}),
				},
			));
		}

				if (trap.effect) {
			const fauxEntry = {name: "Effect", entries: trap.effect};

			const {
				damageTupleMetas,
				rangeShort,
				rangeLong,
				actionType,
				attackBonus,
				attackTypes,
			} = DataConverter.getParsedWeaponEntryData(trap, fauxEntry);

			const {damageParts, formula} = DataConverter.getDamagePartsAndOtherFormula(damageTupleMetas);

			dataBuilderOpts.items.push(await DataConverter.pGetItemActorPassive(
				fauxEntry,
				{
					mode: "object",
					fvttType: "feat",
					activationType: "special",
					entity: trap,
					source: trap.source,
					img: ImportListTrap._IMG_TRAP,

					damageParts,
					formula,
					rangeShort: rangeShort || (attackTypes.includes("m") ? 5 : null),
					rangeLong,
					attackBonus,
					actionType,

					foundryFlags: this.constructor._getTrapChildFlags({
						trap,
						prop: "effect",
						entry: fauxEntry,
						dedupeId: "effect",
					}),
				},
			));
		}

		const complexEffectMetas = [
			{prop: "eActive", name: "Active Elements"},
			{prop: "eDynamic", name: "Dynamic Elements"},
			{prop: "eConstant", name: "Constant Elements"},
		];
		for (const {prop, name} of complexEffectMetas) {
			if (!trap[prop]) continue;

						const entry = {name, entries: trap[prop]};
			dataBuilderOpts.items.push(await DataConverter.pGetItemActorPassive(
				entry,
				{
					mode: "object",
					fvttType: "feat",
					activationType: "special",
					entity: trap,
					source: trap.source,
					img: ImportListTrap._IMG_TRAP,
					foundryFlags: this.constructor._getTrapChildFlags({
						trap,
						prop: prop,
						entry,
						dedupeId: prop,
					}),
				},
			));
		}
		
		if (trap.initiative) {
			dataBuilderOpts.items.push(await DataConverter.pGetItemActorPassive(
				{name: "Initiative", entries: Renderer.trap.getTrapInitiativeEntries(trap)},
				{
					mode: "object",
					fvttType: "feat",
					entity: trap,
					source: trap.source,
					img: ImportListTrap._IMG_TRAP,
					foundryFlags: {
						[SharedConsts.MODULE_ID]: {
							dedupeId: "initiative",
						},
					},
				},
			));
		}

		if (trap.countermeasures) {
			const entry = {name: "Countermeasures", entries: trap.countermeasures};
			dataBuilderOpts.items.push(await DataConverter.pGetItemActorPassive(
				entry,
				{
					mode: "object",
					fvttType: "feat",
					entity: trap,
					source: trap.source,
					img: ImportListTrap._IMG_TRAP,
					foundryFlags: this.constructor._getTrapChildFlags({
						trap,
						prop: "countermeasures",
						entry,
						dedupeId: "countermeasures",
					}),
				},
			));
		}

		const isTemporary = importOpts.isTemp || this._pack != null;
		await UtilActors.pAddActorItems(dataBuilderOpts.actor, dataBuilderOpts.items, {isTemporary});
	}

	static _getTrapChildFlags ({trap, prop, entry, dedupeId}) {
		const propChild = `trap${prop.uppercaseFirst()}`;
		return {
			[SharedConsts.MODULE_ID]: {
				page: propChild,
				source: entry.source || trap.source,
				hash: UrlUtil.URL_TO_HASH_BUILDER[propChild]({
					source: trap.source,
					...entry,
					trapName: trap.name,
					trapSource: trap.source,
				}),
				dedupeId,
			},
		};
	}

	_getTokenFlags ({trap}) {
		if (!UtilCompat.isMonksLittleDetailsActive()) return null;
		return {[UtilCompat.MODULE_MONKS_BLOODSPLATS]: {"bloodsplat-colour": "#00000000"}};
	}
}
ImportListTrap._TRAP_HAZ_TYPES_HAZARD = new Set(["HAZ", "WTH", "ENV", "WLD", "GEN"]);
ImportListTrap._IMG_TRAP = "icons/svg/trap.svg";

ImportListTrap.ImportEntryOpts = class extends ImportListActor.ImportEntryOpts {};

var ImportListTrap$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ImportListTrap: ImportListTrap
});

class DataConverterDeck extends DataConverter {
	static _SIDE_LOAD_OPTS = {
		propBrew: "foundryDeck",
		fnLoadJson: Vetools.pGetDeckSideData,
		propJson: "deck",
	};

	static _IMG_FALLBACK = `icons/svg/card-hand.svg`;

		static async pGetDocumentJson (ent, opts) {
		opts = opts || {};

		Renderer.get().resetHeaderIndex();

		const content = await UtilDataConverter.pGetWithDescriptionPlugins(() => RendererMarkdown.get().setFirstSection(true).render({entries: ent.entries}, 1));

		const img = await Vetools.pOptionallySaveImageToServerAndGetUrl(await this._pGetBackImagePath(ent));

		const additionalRoot = await this._pGetRootSideLoaded(ent);
		const additionalFlags = await this._pGetFlagsSideLoaded(ent);

		const out = {
			description: content,
			img,
			...additionalRoot,

			name: UtilApplications.getCleanEntityName(UtilDataConverter.getNameWithSourcePart(ent, {isActorItem: opts.isActorItem})),
			type: "deck",
			ownership: {default: 0},
			cards: await (ent.cards || [])
				.pSerialAwaitMap((card, ixCard) => this._pGetCardCard({card, ixCard})),
			flags: {
				...this._getDeckFlags(ent),
				...additionalFlags,
			},
		};

		if (opts.defaultOwnership != null) out.ownership = {default: opts.defaultOwnership};
		else if (opts.isAddDefaultOwnershipFromConfig) out.ownership = {default: Config.get("importDeck", "ownership")};
		if (opts.userOwnership) Object.assign(out.ownership, opts.userOwnership);

		return out;
	}

	static _getDeckFlags (deck) {
		return {
			[SharedConsts.MODULE_ID]: {
				page: UrlUtil.PG_DECKS,
				source: deck.source,
				hash: UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_DECKS](deck),
				propDroppable: "deck",
			},
		};
	}

	static async _pGetBackImagePath (ent) {
		if (ent.foundryImg) return ent.foundryImg;
		if (!ent.back) return this._IMG_FALLBACK;
		return Renderer.utils.getMediaUrl(ent.back, "href", "img");
	}

	static async _pGetCardCard ({card, ixCard}) {
		const content = await UtilDataConverter.pGetWithDescriptionPlugins(() => RendererMarkdown.get().setFirstSection(true).render({entries: card.entries}, 1));

		const img = await Vetools.pOptionallySaveImageToServerAndGetUrl(await this._pGetCardFaceImagePath(card));

		const out = {
			name: "Card", 			type: "base",
			faces: [
				{
					name: card.name,
					img,
					text: content,
				},
			],
			face: 0,
			drawn: false,
			sort: ixCard * 1000,
			flags: {
				[SharedConsts.MODULE_ID]: {
					page: "card",
					source: card.source,
					hash: UrlUtil.URL_TO_HASH_BUILDER["card"](card),
				},
			},
		};

		if (card.suit) out.suit = card.suit;
		if (card.value != null) out.value = card.value;

		if (card.back) {
			const imgBack = await Vetools.pOptionallySaveImageToServerAndGetUrl(await this._pGetBackImagePath(card));
			out.back = {
				name: `${card.name} (Back)`,
				img: imgBack,
			};
		}

		return out;
	}

	static async _pGetCardFaceImagePath (card) {
		if (card.foundryImg) return card.foundryImg;
		if (!card.face) return this._IMG_FALLBACK;
		return Renderer.utils.getMediaUrl(card.face, "href", "img");
	}
}

var DataConverterDeck$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DataConverterDeck: DataConverterDeck
});

class ImportListDeck extends ImportList {
	static get ID () { return "decks"; }
	static get DISPLAY_NAME_TYPE_PLURAL () { return "Decks"; }
	static get PROPS () { return ["deck"]; }

	static _ = this.registerImpl(this);

	static get FOLDER_TYPE () { return "Cards"; }

	_dirsHomebrew = ["deck"];
	_titleSearch = "deck";
	_sidebarTab = "cards";
	_gameProp = "cards";
	_defaultFolderPath = ["Decks"];
	_pageFilter = new PageFilterDecks();
	_page = UrlUtil.PG_DECKS;
	_isPreviewable = true;
	_isDedupable = true;
	_configGroup = "importDeck";
	static _DataConverter = DataConverterDeck;

		static async _pPostLoad (
		{
			data,
			fnGetStored,
		},
	) {
		const props = ["card", "deck"];

		const sources = new Set();

		props.forEach(prop => (data[prop] || []).filter(it => it.source).forEach(it => sources.add(it.source)));

		const dataStored = await fnGetStored();

		return props.mergeMap(prop => ({[prop]: (dataStored[prop] || []).filter(it => !it.source || sources.has(it.source))}));
	}

	async _pGetSources () {
		const brewOpts = {
			pPostLoad: (data) => this.constructor._pPostLoad({data, fnGetStored: DataUtil.deck.loadBrew.bind(DataUtil.deck)}),
		};

		const prereleaseOpts = {
			pPostLoad: (data) => this.constructor._pPostLoad({data, fnGetStored: DataUtil.deck.loadPrerelease.bind(DataUtil.deck)}),
		};

		return [
			new UtilDataSource.DataSourceSpecial(
				Config.get("ui", "isStreamerMode") ? "SRD" : "5etools",
				() => Vetools.pGetDecks(),
				{
					cacheKey: "5etools-decks",
					filterTypes: [UtilDataSource.SOURCE_TYP_OFFICIAL_ALL],
					isDefault: true,
				},
			),
			...UtilDataSource.getSourcesCustomUrl({...brewOpts}),
			...UtilDataSource.getSourcesUploadFile({...brewOpts}),
			...(await this._pGetSourcesPrerelease(prereleaseOpts)),
			...(await this._pGetSourcesBrew(brewOpts)),
		];
	}
}

var ImportListDeck$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ImportListDeck: ImportListDeck
});

class ChooseImporter extends Application {
		static async api_pOpen ({actor, table} = {}) {
		if (game.user.role < Config.get("import", "minimumRole")) throw new Error(`You do not have sufficient permissions!`);

		if (actor && table) throw new Error(`Options "actor" and "table" are mutually exclusive!`);

		return this._pOpen({actor, table});
	}

	static async api_pGetImporter ({page = null, prop = null, actor = null, pack = null}) {
		if (!page && !prop) throw new Error(`One of "page" or "prop" must be provided!`);
		const imp = this.getImporter(page || prop, {actor, pack});
		if (!imp) return null;
		await imp.pInit();
		return imp;
	}

	/**
	 * 
	 * You really shouldn't be using this.
	 * @deprecated
	 */
	static async api_pImportAll () {
		for (const mode of ChooseImporter._MODES) {
			if (mode.isNotAllable || mode.Importer.FOLDER_TYPE === "JournalEntry") continue;

						if (!mode.Importer.ID) throw new Error(`Importer has no ID!`);
			if (!mode.Importer.DISPLAY_NAME_TYPE_PLURAL) throw new Error(`Importer has no display name!`);
			
			const importer = new mode.Importer();
			await importer.pInit();

			const packLabel = `${SharedConsts.MODULE_TITLE_FAKE} ${mode.Importer.DISPLAY_NAME_TYPE_PLURAL}`;
			const packName = `${SharedConsts.MODULE_ID_FAKE}-${mode.Importer.ID}`;

			const existingPack = game.packs.get(`world.${packName}`);
			if (existingPack) await existingPack.deleteCompendium();

			importer.pack = await CompendiumCollection.createCompendium({
				type: mode.Importer.FOLDER_TYPE,
				label: packLabel,
				name: packName,
				package: "world",
			});

			const sources = await importer.pGetSources();
			const source = sources.find(it => it.isDefault);
			if (!source) throw new Error(`No default source found for ${mode.Importer.DISPLAY_NAME_TYPE_PLURAL}`);

			const allContentMeta = await UtilDataSource.pGetAllContent({
				sources: [source],
				page: importer.page,
			});

			if (!allContentMeta) return;

			if (!importer.constructor.PROPS) throw new Error(`Importer "${importer.name}" did not have any "PROPS"!`);
			const propSet = new Set(importer.constructor.PROPS);

			let allContent = allContentMeta.dedupedAllContentMerged;
			Object.entries(allContent)
				.forEach(([k, arr]) => {
					allContent[k] = arr.filter(it => {
						if (!propSet.has(it.__prop)) return false;

												if (it.source.startsWith(Parser.SRC_UA_PREFIX) || it.source.startsWith(Parser.SRC_AL_PREFIX)) return false;

												if (it.__prop === "item" && it._category === "Specific Variant") return false;

						return true;
					});
				});

			let allContentFlat = [];
			Object.values(allContent)
				.forEach(arr => {
					allContentFlat = [...allContentFlat, ...arr];
				});

			const tStart = Date.now();
			const msgStart = `Importing ${allContentFlat.length} ${mode.Importer.DISPLAY_NAME_TYPE_PLURAL} to compendium ${packLabel}...`;
			ui.notifications.info(msgStart);
			console.warn(...LGT, msgStart);

			for (const ent of allContentFlat) {
				await importer.pImportEntry(ent);
			}

			const tDelta = Math.round((Date.now() - tStart) / 1000);
			const msgEnd = `Imported ${allContentFlat.length} ${mode.Importer.DISPLAY_NAME_TYPE_PLURAL} to compendium ${packLabel} in ${tDelta}s.`;
			ui.notifications.info(msgEnd);
			console.warn(...LGT, msgEnd);
		}
	}
	
		static prePreInit () {
		this._preInit_registerKeybinds();
		this._preInit_initCacheFlushHooks();
	}

	static _preInit_registerKeybinds () {
		const doKeybindingOpen = ({modeId = null} = {}) => {
			this._pOpen({modeId});
			return true;
		};

		const doKeybindingOpenForCharacter = ({modeId = null} = {}) => {
			const actor = UtilKeybinding.getPlayerActor({minRole: Config.get("import", "minimumRole")});
			if (!actor) return true;
			this._pOpen({modeId, actor});
			return true;
		};

		const doKeybindingOpenForCurrentSheet = ({modeId = null} = {}) => {
			const meta = UtilKeybinding.getCurrentImportableSheetDocumentMeta({isRequireOwnership: true, minRole: Config.get("import", "minimumRole")});
			if (!meta) return true;
			this._pOpen({modeId, ...meta});
			return true;
		};

		game.keybindings.register(
			SharedConsts.MODULE_ID,
			"ChooseImporter__open",
			{
				name: "Open Import Wizard",
				editable: [],
				onDown: () => doKeybindingOpen(),
				restricted: true,
			},
		);

		game.keybindings.register(
			SharedConsts.MODULE_ID,
			"ChooseImporter__openForCharacter",
			{
				name: "Open Import Wizard Targeting Player Character",
				editable: [],
				onDown: () => doKeybindingOpenForCharacter(),
			},
		);

		game.keybindings.register(
			SharedConsts.MODULE_ID,
			"ChooseImporter__openForCurrentSheet",
			{
				name: "Open Import Wizard Targeting Current Sheet",
				editable: [],
				onDown: () => doKeybindingOpenForCurrentSheet(),
			},
		);

		ChooseImporter._MODES.forEach(mode => {
			game.keybindings.register(
				SharedConsts.MODULE_ID,
				`ChooseImporter__open__${mode.id}`,
				{
					name: `Open Import Wizard (${mode.name})`,
					editable: [],
					onDown: () => doKeybindingOpen({modeId: mode.id}),
					restricted: true,
				},
			);

			if (mode.canTargetPlayerCharacter()) {
				game.keybindings.register(
					SharedConsts.MODULE_ID,
					`ChooseImporter__openForCharacter__${mode.id}`,
					{
						name: `Open Import Wizard (${mode.name}) Targeting Player Character`,
						editable: [],
						onDown: () => doKeybindingOpenForCharacter({modeId: mode.id}),
					},
				);
			}

			if (mode.canTargetSheets()) {
				game.keybindings.register(
					SharedConsts.MODULE_ID,
					`ChooseImporter__openForCurrentSheet__${mode.id}`,
					{
						name: `Open Import Wizard (${mode.name}) Targeting Current Sheet`,
						editable: [],
						onDown: () => doKeybindingOpenForCurrentSheet({modeId: mode.id}),
					},
				);
			}
		});

		this._IMPORTABLE_HOOK_METAS.forEach(meta => {
			game.keybindings.register(
				SharedConsts.MODULE_ID,
				`ChooseImporter__openLastUsed__${meta.propGame}`,
				{
					name: `Open Last Used Importer (${meta.propGame.toTitleCase()})`,
					editable: [],
					onDown: () => this._pDoReopenLastUsedImporter({hookName: meta.hookName}),
					restricted: true,
				},
			);
		});
	}

	static _preInit_initCacheFlushHooks () {
		UtilHooks.on(UtilHooks.HK_CONFIG_UPDATE, diff => {
			Object.entries(ChooseImporter._INSTANCE_CACHE)
				.forEach(([key, cachedInstanceMeta]) => {
					if (!cachedInstanceMeta.instance.isInvalidatedByConfigChange(diff)) return;

					this._uncacheInstance(key);
				});
		});
	}

	static _IMPORTABLE_HOOK_METAS = [
		{hookName: "renderSceneDirectory", propGame: "scenes", importerIdDefault: ImportListAdventure.ID},
		{hookName: "renderActorDirectory", propGame: "actors", importerIdDefault: ImportListCreature.ID},
		{hookName: "renderItemDirectory", propGame: "items", importerIdDefault: ImportListItem.ID},
		{hookName: "renderJournalDirectory", propGame: "journal", importerIdDefault: ImportListAdventure.ID},
		{hookName: "renderRollTableDirectory", propGame: "tables", importerIdDefault: ImportListRollableTable.ID},
		{hookName: "renderCardsDirectory", propGame: "cards", importerIdDefault: ImportListDeck.ID},
	];

	static isImportableFvttEntityHook (hookName) {
		return this._IMPORTABLE_HOOK_METAS.some(it => it.hookName === hookName);
	}

	static async pHandleButtonClick (evt, app, $html, data) {
		evt.preventDefault();
		await this._pOpen({actor: app.actor, table: app instanceof RollTableConfig ? app.document : null});
	}

	static async _pOpen ({actor, table, modeId = null} = {}) {
		const chooseImporter = new ChooseImporter({actor, table, modeId});
		await chooseImporter.render(true);
		return chooseImporter;
	}

	static $getDirButton (hookName) {
		return $(`<button class="imp__btn-open w-100 mx-0">${this._getButtonImportHtml()}</button>`)
			.click((evt) => {
				evt.preventDefault();
				const chooseImporter = new ChooseImporter();
				chooseImporter.render(true);
			});
	}

	static _getButtonImportHtml () { return `${UtilUi.getModuleFaIcon()} ${Config.get("ui", "isStreamerMode") ? "" : "Plutonium "}Import`; }
	static _getButtonImportQuickHtml () { return `<span class="fas fa-fw fa-heart"></span>`; }
	static _getButtonImportQuickTitle () { return `Re-open your last-used importer for this directory.`; }

	static $getDirButtonQuick (hookName) {
		return $(`<button class="imp__btn-open mx-0 w-initial ve-flex-vh-center"></button>`)
			.html(this._getButtonImportQuickHtml())
			.title(this._getButtonImportQuickTitle())
			.click(async evt => {
				evt.preventDefault();
				await this._pDoReopenLastUsedImporter({hookName});
			});
	}

	static async _pDoReopenLastUsedImporter ({hookName}) {
		const lastUsedModes = await StorageUtil.pGet(ChooseImporter._STORAGE_KEY_LAST_USED_MODE) || {};

		const chooseImporter = new ChooseImporter({modeId: this._pDoReopenLastUsedImporter_getModeId(hookName, lastUsedModes)});
		await chooseImporter.pDoQuickOpenUsingExistingSourceSelection();
	}

	static _pDoReopenLastUsedImporter_getModeId (hookName, lastUsedModes) {
		const meta = this._IMPORTABLE_HOOK_METAS.find(it => it.hookName === hookName);
		if (!meta) throw new Error(`Unhandled hook "${hookName}"!`);
		return lastUsedModes?.[meta.propGame] || meta.importerIdDefault;
	}

	static getImporterClassMeta (dataPropOrTagOrPage) {
		switch (dataPropOrTagOrPage) {
			case "feat":
			case UrlUtil.PG_FEATS: return {Class: ImportListFeat, isAcceptActor: true};
			case "creature":
			case "monster":
			case UrlUtil.PG_BESTIARY: return {Class: ImportListCreature};

																								
			case "spell":
			case UrlUtil.PG_SPELLS: return {Class: ImportListSpell, isAcceptActor: true};
			case "item":
			case "baseitem":
			case "magicvariant":
			case UrlUtil.PG_ITEMS: return {Class: ImportListItem, isAcceptActor: true};
			case "race":
			case UrlUtil.PG_RACES: return {Class: ImportListRace, isAcceptActor: true};
			case "raceFeature": return {Class: ImportListRaceFeature, isAcceptActor: true};
			case "class":
			case "subclass":
			case UrlUtil.PG_CLASSES: return {Class: ImportListClass, isAcceptActor: true};
			case "background":
			case UrlUtil.PG_BACKGROUNDS: return {Class: ImportListBackground, isAcceptActor: true};
			case "backgroundFeature": return {Class: ImportListBackgroundFeature, isAcceptActor: true};
			case "variantrule":
			case UrlUtil.PG_VARIANTRULES: return {Class: ImportListVariantRule};
			case "language":
			case UrlUtil.PG_LANGUAGES: return {Class: ImportListLanguage};
			case "table":
			case "tableGroup":
			case UrlUtil.PG_TABLES: return {Class: ImportListRollableTable};
			case "psionic":
			case UrlUtil.PG_PSIONICS: return {Class: ImportListPsionic, isAcceptActor: true};
			case "optfeature":
			case "optionalfeature":
			case UrlUtil.PG_OPT_FEATURES: return {Class: ImportListOptionalFeature, isAcceptActor: true};
			case "condition":
			case "disease":
			case "status":
			case UrlUtil.PG_CONDITIONS_DISEASES: return {Class: ImportListConditionDisease, isAcceptActor: true};
			case "action":
			case UrlUtil.PG_ACTIONS: return {Class: ImportListAction, isAcceptActor: true};
			case "cult":
			case "boon":
			case UrlUtil.PG_CULTS_BOONS: return {Class: ImportListCultBoon, isAcceptActor: true};
			case "reward":
			case UrlUtil.PG_REWARDS: return {Class: ImportListReward, isAcceptActor: true};
			case "classFeature":
			case "subclassFeature": return {Class: ImportListClassFeature, isAcceptActor: true};
			case "charoption":
			case UrlUtil.PG_CHAR_CREATION_OPTIONS: return {Class: ImportListCharCreationOption, isAcceptActor: true};
			case "vehicle":
			case UrlUtil.PG_VEHICLES: return {Class: ImportListVehicle};
			case "vehupgrade":
			case "vehicleUpgrade":
			case "vehicleupgrade": return {Class: ImportListVehicleUpgrade};
			case "object":
			case UrlUtil.PG_OBJECTS: return {Class: ImportListObject};
			case "deity":
			case UrlUtil.PG_DEITIES: return {Class: ImportListDeity};
			case "recipe":
			case UrlUtil.PG_RECIPES: return {Class: ImportListRecipe};
			case "trap":
			case UrlUtil.PG_TRAPS_HAZARDS: return {Class: ImportListTrap};
			case "hazard": return {Class: ImportListHazard};
			case "deck":
			case UrlUtil.PG_DECKS: return {Class: ImportListDeck};

			case "skill":
			case "sense": return {isViewOnly: true};

			default: return null;
		}
	}

	static getImporter (dataPropOrTagOrPage, {actor, pack, isIgnoreMismatchedPack = false} = {}) {
		if (actor && pack) throw new Error(`Only one of "actor" or "pack" may be specified!`);

		const meta = this.getImporterClassMeta(dataPropOrTagOrPage);
		if (!meta) return null;

		const {Class, isAcceptActor} = meta;
		const imp = isAcceptActor ? new Class({actor}) : new Class({});

		if (pack) {
			if (imp.constructor.FOLDER_TYPE !== pack.metadata.type) {
				if (!isIgnoreMismatchedPack) throw new Error(`Pack document type "${pack.metadata.type}" did not match importer document type "${imp.constructor.FOLDER_TYPE}"!`);
			} else {
				imp.pack = pack;
			}
		}

		return imp;
	}
	
		constructor (opts) {
		opts = opts || {};

				if (opts.actor && opts.table) throw new Error(`Both "actor" and "table" options were specified!`);

		if (!opts.mode && opts.modeId && !ChooseImporter._MODES.some(it => it.id === opts.modeId)) {
			const msg = `Could not find importer mode "${opts.modeId}"! The default importer will be shown instead.`;
			ui.notifications.warn(msg);
			console.warn(...LGT, msg);
			opts = {...opts};
			delete opts.modeId;
		}
		
		const width = (opts.mode || opts.modeId) ? Util.getMaxWindowWidth(1000) : Util.getMaxWindowWidth(1200);
		const template = (opts.mode || opts.modeId)
			? `${SharedConsts.MODULE_LOCATION}/template/ChooseImporterForMode.hbs`
			: `${SharedConsts.MODULE_LOCATION}/template/ChooseImporter.hbs`;

		super({
			width,
			height: Util.getMaxWindowHeight(970),
			title: MiscUtil.get(opts.mode, "wizardTitleWindow") || `Import Wizard${opts.actor || opts.table ? ": Importing to " : ""}${opts.actor ? `Actor "` : opts.table ? `Table "` : ""}${opts.actor?.name || opts.table?.name || ""}${opts.actor || opts.table ? `"` : ""}`,
			template,
			resizable: true,
		});

		this._actor = opts.actor;
		this._table = opts.table;
		this._predefinedMode = opts.mode;
		if (!this._predefinedMode && opts.modeId) this._predefinedMode = ChooseImporter._MODES.find(it => it.id === opts.modeId);
		this._namespace = opts.namespace || "default";
		this._isAlwaysCloseWindow = !!opts.isAlwaysCloseWindow;
		this._isTemp = !!opts.isTemp;
		this._importerPreRenderArgs = opts.importerPreRenderArgs;

				this.__comp = BaseComponent.fromObject(ChooseImporter._getDefaultState());
		this._comp = this.__comp.getPod();

		this._modes = [];
		if (this._predefinedMode) this._modes = [this._predefinedMode];

		this._deferredHooks = [];

		this._doSaveStateDebounced = null;

		this._$window = null;
		this._$panel1 = null;
		this._$panel2 = null;
		this._$panel2Head = null;
		this._$panel2WrpLoader = null;
		this._$panel2WrpList = null;
		this._$panel3 = null;
		this._$panel3Head = null;
		this._$panel3WrpLoader = null;
		this._$panel3WrpTabs = null;
		this._$panel3WrpConfig = null;
		this._$panel3_tab1 = null;
		this._$panel3_tab2 = null;
		this._$panel3_btnImportPackage = null;

		this._$btnOpenImporter = null;

		this._rowMetasMode = [];
		this._importer = null;

				this._appSourceSelector = null;

		this._$stgNone = null;
		this._$stgUpload = null;
		this._$stgUrl = null;
		this._$stgSpecial = null;
		
		this._packageIndex = null;
		this._pPackageIndex = null;
		this._uiHooks = {};
	}

	_trackUiHook (prop, hook) { (this._uiHooks[prop] = this._uiHooks[prop] || []).push(hook); }
	_resetUiHooks () {
		Object.entries(this._uiHooks)
			.forEach(([prop, hook]) => {
				this._comp.removeHook(prop, hook);
			});
		this._uiHooks = {};
	}

	_pDoSaveState () {
		return StorageUtil.pSet(this._getSelectedImporterStorageKey(), this.__comp.getSaveableState());
	}

		isMaybeSkippable () {
				if (!this._predefinedMode) return false;

						if (!this._actor && !this._table && !this._isTemp) return false;

		return true;
	}

		async pInitIsSubSkippable () {
		await this._pInitImporter(this._getMode());
		await this._pInitSourceSelector();

				return this._appSourceSelector.isForceSelectAllSources();
	}

	activateListeners ($html) {
		super.activateListeners($html);

		this._bindTargetEntityDeletedHooks();

		this._$window = $html;

		if (!this._predefinedMode) this._$panel1 = $html.find(`[data-panel="1"]`);
		else this._activateListeners_initPredefinedMode();
		this._$panel2 = $html.find(`[data-panel="2"]`);
		this._$panel3 = $html.find(`[data-panel="3"]`);

		if (!this._predefinedMode) {
			const status = this._activateListeners_fillPanel1(this._$panel1);

			if (status === VeCt.SYM_UI_SKIP) {
				ui.notifications.warn(`No available importers! You may need to un-hide some.`);

								if (this.element) this.element.hideVe();
				Hooks.once("renderChooseImporter", (app) => {
					if (app.appId !== this.appId) return;
										MiscUtil.pDelay(1).then(() => this._pForceClose());
					this._pForceClose();
				});
				return;
			}
		}

		this._activateListeners_fillPanel2(this._$panel2);
		this._activateListeners_fillPanel3(this._$panel3);

		this._doSaveStateDebounced = MiscUtil.debounce(() => this._pDoSaveState(), 50);

		StorageUtil.pGet(this._getSelectedImporterStorageKey())
			.then(save => {
				if (save) {
					if (save.state) save.state.modeId = save.state.modeId || this._modes[0].id;
					else save.state = {modeId: this._modes[0].id};
					this.__comp.setStateFrom(save);
				}

				this._deferredHooks.forEach(hk => hk());
				this._deferredHooks = [];

				this._comp.addHookAll(this._doSaveStateDebounced);
			});
	}

	_bindTargetEntityDeletedHooks () {
		if (this._actor) {
			Hooks.once("deleteActor", actor => {
				if (actor.id !== this._actor.id) return;
				this.close();
				if (this._importer) this._importer.close();
			});
		}

		if (this._table) {
			Hooks.once("deleteTable", table => {
				if (table.id !== this._table.id) return;
				this.close();
				if (this._importer) this._importer.close();
			});
		}
	}

	_activateListeners_initPredefinedMode () {
		this._comp.addHook("modeId", this._activateListeners_pHkMode.bind(this));
		this._deferredHooks.push(this._activateListeners_pHkMode.bind(this));
	}

	_activateListeners_fillPanel1 ($panel) {
		const hiddenIds = Config.get("import", "hiddenImporterIds");

		this._modes = ChooseImporter._MODES
			.filter(({id}) => !hiddenIds[id])
			.filter(mode => mode.canTargetContext({actor: this._actor, table: this._table}));

		if (!this._modes.length) return VeCt.SYM_UI_SKIP;

		this._rowMetasMode = this._modes.map(mode => {
			const $btn = $(`<button class="btn btn-sm btn-5et w-100">${mode.name}</button>`)
				.click(() => this._comp.set("modeId", mode.id));

			const $btnExternalArchive = mode.metaExternalArchive
				? $(`<a class="btn btn-sm btn-5et imp-wiz__btn-package-archive no-underline" rel="noreferrer noopener" href="${mode.metaExternalArchive.url}">${mode.metaExternalArchive.text} <i class="fas fa-fw fa-external-link-alt"></i></a>`)
				: null;

			const $btnOther = mode.metaOther
				? $(`<button class="btn btn-sm btn-5et px-1 imp-wiz__btn-package-archive h-100">${mode.metaOther.text}</button>`)
					.click(() => mode.metaOther.pFn())
				: null;

			const $btnQuick = $(`<button class="btn btn-sm btn-5et px-1 imp-wiz__btn-quick h-100" title="Open Last-Used Importer"><i class="fas fa-fw fa-forward mr-0"></i></button>`)
				.click(() => this._pDoQuickOpen(mode));

			const $row = $$`<div class="w-100 ve-flex-v-center input-group imp-wiz__row-mode">
				${$btn}
				${$btnExternalArchive}
				${$btnOther}
				${$btnQuick}
			</div>`;

			return {
				$btn,
				$row,
				modeId: mode.id,
			};
		});

		this._comp.addHook("modeId", this._activateListeners_pHkMode.bind(this));
		this._deferredHooks.push(this._activateListeners_pHkMode.bind(this));

		$$($panel)`
			<h4 class="imp-wiz__head-panel">1: Choose Importer</h4>

			<div class="ve-flex-col w-100 h-100 overflow-y-auto overflow-x-hidden">
				${this._rowMetasMode.map(it => it.$row)}
			</div>
		`;
	}

	_getMode () {
		if (this._predefinedMode) return this._predefinedMode;

		const modeId = this._comp.get("modeId");
		return this._modes.find(it => it.id === modeId) || this._modes[0];
	}

	async _activateListeners_pHkMode () {
		if (!this._$panel2Head || !this._$panel3Head) return;

		await this._comp.pLock("modeId");

		try {
			if (UtilApplications.isClosed(this)) return;

			const mode = this._getMode();

			this._rowMetasMode.forEach(meta => meta.$btn.toggleClass("btn--active", meta.modeId === mode.id));

			this._$panel2Head.text(`${this._predefinedMode ? 1 : 2}: Choose Data Source`);
			this._$panel3Head.text(`${this._predefinedMode ? 2 : 3}: ${MiscUtil.get(this._predefinedMode, "wizardTitlePanel3") || "Configure and Import"}`);
			const $ovrLoading2 = await UtilApplications.$pGetAddAppLoadingOverlay(this._$panel2WrpLoader);
			const $ovrLoading3 = await UtilApplications.$pGetAddAppLoadingOverlay(this._$panel3WrpLoader);
			try {
				if (UtilApplications.isClosed(this)) return;

				await this._pInitImporter(mode);
				if (UtilApplications.isClosed(this)) return;

				if (!await this._pIsTableImportAvailable()) { await this._pForceClose(); return; }
				if (UtilApplications.isClosed(this)) return;

				await this._pFillUi();
				if (UtilApplications.isClosed(this)) return;

				this._$panel2Head.text(`${this._predefinedMode ? 1 : 2}: ${mode.singleName ? `Choose ${mode.singleName} Data Source` : `Choose Data Source for ${mode.name}`}`);
				this._$panel3Head.text(`${this._predefinedMode ? 2 : 3}: ${mode.singleName ? `Configure and Import ${mode.singleName}` : `Configure and Import ${mode.name}`}`);

				const isDisplayPackages = mode.hasPackages && Config.get("importAdventure", "isUseLegacyImporter");
				this._$panel3WrpTabs.toggleVe(isDisplayPackages);
				if (!isDisplayPackages) this._comp.set("ixTabPanel3", 0);
			} catch (e) {
				ui.notifications.error(`Failed to load importer! ${VeCt.STR_SEE_CONSOLE}`);
				throw e;
			} finally {
				if ($ovrLoading2) $ovrLoading2.remove();
				if ($ovrLoading3) $ovrLoading3.remove();

				if (this._$btnOpenImporter) this._$btnOpenImporter.focus();
			}
		} finally {
			this._comp.unlock("modeId");
		}
	}

	async _pIsTableImportAvailable () {
		if (!this._table) return true; 		if (this._importer.isFolderOnly) throw new Error(`Attempting to import non-compendium-friendly mode to table! This is a bug!`);

		const packName = `${SharedConsts.MODULE_ID_FAKE}-table-backing-${this._importer.constructor.FOLDER_TYPE.toLowerCase()}`;
		const packKey = `world.${packName}`;

		const existingCompendium = game.packs.get(packKey);
		if (existingCompendium) {
			this._importer.pack = existingCompendium;
			return true;
		}

		if (!await InputUiUtil.pGetUserBoolean({title: "Create Backing Compendium?", htmlDescription: `In order to import ${this._importer.constructor.FOLDER_TYPE}s to a rollable table, a backing compendium must be created for ${this._importer.constructor.FOLDER_TYPE}s. Would you like to proceed?`})) {
			return false;
		}

		try {
			this._importer.pack = await CompendiumCollection.createCompendium({
				type: this._importer.constructor.FOLDER_TYPE,
				label: `Table-Backing ${this._importer.constructor.FOLDER_TYPE}s`,
				name: packName,
				package: "world",
			});
		} catch (e) {
			console.error(...LGT, e);
			return false;
		}

		return true;
	}

	async _pInitImporter (mode) {
		mode = mode || this._getMode();
		this._importer = mode.Importer ? new mode.Importer({actor: this._actor, table: this._table}) : mode.importerInstance;
		await this._importer.pInit();
	}

	_activateListeners_fillPanel2 ($panel) {
		this._$panel2Head = $(`<h4 class="imp-wiz__head-panel">${this._predefinedMode ? 1 : 2}: Choose Data Source</h4>`);

		this._$panel2WrpList = $(`<div class="ve-flex-col w-100 h-100"></div>`);

		this._$panel2WrpLoader = $$`<div class="ve-flex-col w-100 h-100 overflow-y-auto">
			${this._$panel2WrpList}
		</div>`;

		$$($panel)`
			${this._$panel2Head}
			${this._$panel2WrpLoader}
		`;
	}

	_activateListeners_fillPanel3 ($panel) {
		this._$panel3Head = $(`<h4 class="imp-wiz__head-panel">${this._predefinedMode ? 2 : 3}: Configure and Import</h4>`);

		this._$panel3WrpConfig = $(`<div class="ve-flex-col w-100 h-100 pb-3"></div>`); 
		this._$panel3WrpLoader = $$`<div class="ve-flex-col w-100 h-100 overflow-y-auto">
			${this._$panel3WrpConfig}
		</div>`;

		$$($panel)`
			${this._$panel3Head}
			${this._$panel3WrpLoader}
		`;
	}

	_getSelectedImporterStorageKey () {
		const ptMode = this._predefinedMode ? "predefinedMode" : "chooseMode";
		const ptType = this._actor ? "actor" : this._table ? "table" : "directory";
		return `chooseImporter_state_${[ptMode, ptType].join("_")}`;
	}

	static _getDefaultState () {
		return MiscUtil.copy(ChooseImporter._DEFAULT_STATE);
	}

	async _pFillUi () {
		this._resetUiHooks();
		this._$panel2WrpList.empty();
		this._$panel3WrpConfig.empty();

		await this._pFillUi_pFillSourceUi();
		await this._pFillUi_pFillConfigUi();
	}

	async _pInitSourceSelector () {
		const sourcesToDisplay = await this._importer.pGetSources();

		this._appSourceSelector = new AppSourceSelectorMulti({
			sourcesToDisplay,
			savedSelectionKey: this.constructor._getSourceSelectionKey(this._importer),
			filterNamespace: this._getFilterNamespace(),
			isRadio: this._importer.isRadio,
		});
	}

	async _pFillUi_pFillSourceUi () {
		await this._pInitSourceSelector();

				const {$stgNone, $stgUpload, $stgUrl, $stgSpecial} = await this._appSourceSelector.pGetElements(
			this._$panel2WrpList,

						(selSources) => {
				const mode = this._getMode();
				if (!mode.hasPackages || !selSources.length) return this._comp.set("packageSource", null);

												const selSource = selSources[0];
				this._comp.set("packageSource", (selSource.userData || {}).source || null);
			},
		);
		this._$stgNone = $stgNone;
		this._$stgUpload = $stgUpload;
		this._$stgUrl = $stgUrl;
		this._$stgSpecial = $stgSpecial;
	}

	async _pFillUi_pFillConfigUi () {
		const $wrpConfigSettings = await this._pFillUi_$pGetWrpConfigSettings();
		if (!$wrpConfigSettings) return;
		this._$btnOpenImporter = this._pFillUi_$getBtnOpenImporter();
		const $btnOpenConfig = this._pFillUi_$getBtnOpenConfig();

		this._$panel3_tab1 = $$`<div class="mb-1">Import From:</div>
			<div class="ve-flex-col w-100 min-h-0 max-h-40 overflow-y-auto mb-1">
				${this._$stgNone}
				${this._$stgUpload}
				${this._$stgUrl}
				${this._$stgSpecial}
			</div>
			${$wrpConfigSettings}
			<div class="ve-flex-v-center mt-auto">${this._$btnOpenImporter}${$btnOpenConfig}</div>`;

		const $wrpPackageImport = await this._pFillUi_$pGetWrpPackageImport();
		this._$panel3_btnImportPackage = this._$panel3_btnImportPackage || $(`<button class="mt-auto btn btn-5et" disabled>Import Package</button>`);

		this._$panel3_tab2 = $$`
			${$wrpPackageImport}
			${this._$panel3_btnImportPackage}`;

		this._$panel3WrpTabs = await this._pFillUi_$pGetPanel3WrpTabs();

		$$(this._$panel3WrpConfig)`
			${this._$panel3WrpTabs}
			${this._$panel3_tab1}
			${this._$panel3_tab2}
		`;
	}

	_pFillUi_$pGetPanel3WrpTabs () {
		const $btnTab1 = $(`<button class="btn btn-default w-50 btn-5et">Actors/Items/Journal</button>`)
			.click(() => this._comp.set("ixTabPanel3", 0));
		const $btnTab2 = $(`<button class="btn btn-default w-50 btn-5et">World/Module</button>`)
			.click(() => this._comp.set("ixTabPanel3", 1));
		const hkActiveTab = () => {
			const ixActiveTab = Number(this._comp.get("ixTabPanel3") || 0);
			$btnTab1.toggleClass("active", ixActiveTab === 0);
			$btnTab2.toggleClass("active", ixActiveTab === 1);
			this._$panel3_tab1.toggleVe(ixActiveTab === 0);
			this._$panel3_tab2.toggleVe(ixActiveTab === 1);
		};
		this._comp.addHook("ixTabPanel3", hkActiveTab);
		this._trackUiHook("ixTabPanel3", hkActiveTab);
		hkActiveTab();

		return $$`<div class="ve-flex btn-group mb-2 w-100">${$btnTab1}${$btnTab2}</div>`;
	}

		async _pFillUi_$pGetWrpPackageImport () {
		const $out = $(`<div class="ve-flex-col h-100 w-100"></div>`);

		const $ovrLoading = await UtilApplications.$pGetAddAppLoadingOverlay($out);

		this._pPackageIndex = this._pPackageIndex || (async () => {
			this._packageIndex = await ImportSpecialPackages.getMergedPackageIndex();
		})();

		this._pPackageIndex.then(() => {
			if ($ovrLoading) $ovrLoading.remove();

			const hkPackageSource = () => {
				const packageSourceClean = this._comp.get("packageSource") ? this._comp.get("packageSource").toLowerCase() : null;
				const availablePackage = (this._packageIndex?.packages || []).find(it => (it.source || "").toLowerCase() === packageSourceClean);

				if (availablePackage) {
					const hasModule = !!availablePackage.manifesturlModule;
					const hasWorld = !!availablePackage.manifesturlWorld;

					const $iptModule = $(`<input class="mr-1" type="radio" name="package-mode" ${hasModule ? "" : `disabled title="No module available."`} ${hasModule ? `checked` : ""}>`);
					const $iptWorld = $(`<input class="mr-1" type="radio" name="package-mode" ${hasWorld ? "" : `disabled title="No world available."`} ${!hasModule && hasWorld ? `checked` : ""}>`);

					$$($out.empty())`
						<div class="mb-1">Import As:</div>
						<label class="ve-flex-v-center mb-1">
							<div class="ve-flex-v-center col-3">${$iptModule}<b class="mr-1">Module</b></div>
							<div class="col-9">
								A resource which can be used in this and other worlds. Usually includes a selection of compendiums.
							</div>
						</label>
						<label class="ve-flex-v-center">
							<div class="ve-flex-v-center col-3">${$iptWorld}<b class="mr-1">World</b></div>
							<div class="col-9">
								A complete world, ready to be run. This is imported as a new, separate world; your current world will not be affected.
							</div>
						</label>
					`;

					this._$panel3_btnImportPackage
						.prop("disabled", false)
						.off("click")
						.click(async () => {
							const isModule = $iptModule.prop("checked");
							const isWorld = $iptWorld.prop("checked");

							if (isModule) await ImportSpecialPackages.pImportManifesturlModule(availablePackage.manifesturlModule);
							else if (isWorld) await ImportSpecialPackages.pImportManifesturlWorld(availablePackage.manifesturlWorld);
							else ui.notifications.warn(`Please select an import mode first!`);
						});
				} else {
					if (Config.get("importAdventure", "isUseLegacyImporter")) {
						$$($out.empty())`<div class="ve-flex-col mb-1">
							<p><i>No world/module package available.</i></p>
						</div>`;
					} else {
						$$($out.empty())`<div class="ve-flex-col mb-1">
							${ImportSpecialPackages.getNonLegacyNoteHtml()}
							<hr class="hr-2">
							<p><i class="ve-muted">No world/module package available.</i></p>
						</div>`;
						ImportSpecialPackages.bindNonLegacyNoteHandlers($out);
					}

					this._$panel3_btnImportPackage
						.prop("disabled", true)
						.off("click");
				}
			};
			this._comp.addHook("packageSource", hkPackageSource);
			this._trackUiHook("packageSource", hkPackageSource);
			hkPackageSource();
		}).catch(e => {
			$ovrLoading.remove();
			$out.append(`<div class="bold veapp__msg-error">Failed to load!</div>`);
			ui.notifications.error(`Failed to load package (worlds/modules) index! The package importer may not function correctly. ${VeCt.STR_SEE_CONSOLE}`);
			throw e;
		});

		return $out;
	}

	async _pFillUi_$pGetWrpConfigSettings () {
		const $cbKeepOpen = ComponentUiUtil.$getCbBool(this.__comp, "isRemainOpen");

		const $wrpSharedConfig = $$`<div class="w-100 ve-flex-col mb-1">
			${!this._isAlwaysCloseWindow ? $$`<label class="w-100 mb-1 split-v-center" title="If this Import Wizard window should be kept open after clicking &quot;Open Importer&quot;">
				<div>Keep Window Open</div>${$cbKeepOpen}
			</label>` : ""}
		</div>`;

		if (this._actor != null || this._isTemp) {
			this._importer.pack = null;
			return $wrpSharedConfig;
		}

		if (this._table != null) {
						return $wrpSharedConfig;
		}

		const $wrpEditFolderPath = $$`<div class="w-100 ve-flex-col"></div>`;
		const pathBuilder = new FolderPathBuilder({fpApp: this._importer, folderType: this._importer.constructor.FOLDER_TYPE});
		pathBuilder.render($wrpEditFolderPath);

		if (this._importer.isFolderOnly) {
			return $$`<div class="ve-flex-col w-100">
				${$wrpSharedConfig}
				${$wrpEditFolderPath}
			</div>`;
		}

		const availPacks = UtilCompendium.getAvailablePacks({folderType: this._importer.constructor.FOLDER_TYPE});

		let isImportToCompendium = await StorageUtil.pGet(this.constructor._getImportToPackKey(this._importer)) || false;

		const getSelectedCompendium = () => {
			const toFind = $selCompendium.val() == null ? availPacks.length ? availPacks[0].collection : null : $selCompendium.val();
			return UtilCompendium.getPackByCollection({collection: toFind});
		};

		const setCompendiumImport = (isCompendium) => {
			isImportToCompendium = isCompendium;

			const pack = getSelectedCompendium();
			if (!pack && isCompendium) {
				setCompendiumImport(false);
				ui.notifications.warn(`No unlocked/compatible compendiums found for type "${this._importer.constructor.FOLDER_TYPE}." You need to create one first! (If you have created one already, you may need to re-open the Wizard.)`);
				return;
			}

			$btnImportFolder.toggleClass("btn--active", !isImportToCompendium);
			$btnImportCompendium.toggleClass("btn--active", isImportToCompendium);

			$tabImportFolder.toggleVe(!isImportToCompendium);
			$tabImportCompendium.toggleVe(isImportToCompendium);

			this._importer.pack = isImportToCompendium ? getSelectedCompendium() : null;

			StorageUtil.pSet(this.constructor._getImportToPackKey(this._importer), isImportToCompendium).then(null);
			StorageUtil.pSet(this.constructor._getPackSelectionKey(this._importer), $selCompendium.val()).then(null);
		};

		const $btnImportFolder = $(`<button class="btn btn-5et imp-wiz__btn-tab-head imp-wiz__btn-tab-head--left w-50 ml-2 ${isImportToCompendium ? "" : "btn--active"}">Import to Folder</button>`)
			.click(() => setCompendiumImport(false));

		const $btnImportCompendium = $(`<button class="btn btn-5et imp-wiz__btn-tab-head imp-wiz__btn-tab-head--right w-50 mr-2 ${isImportToCompendium ? "" : "btn--active"}">Import to Compendium</button>`)
			.click(() => setCompendiumImport(true));

		const $selCompendium = UtilCompendium.$getSelCompendium({availablePacks: availPacks})
			.change(() => {
				setCompendiumImport(isImportToCompendium);
			});

		const savedCollectionId = await StorageUtil.pGet(this.constructor._getPackSelectionKey(this._importer));
		if (isImportToCompendium && availPacks.some(it => it.collection === savedCollectionId)) $selCompendium.val(savedCollectionId);
		else if (availPacks.length) $selCompendium.val(availPacks[0].collection);

		const $tabImportFolder = $$`<div class="w-100 h-100 ve-flex-col imp-wiz__tab-config py-1">
			${$wrpEditFolderPath}
		</div>`;

		const $tabImportCompendium = $$`<div class="w-100 h-100 ve-flex-col imp-wiz__tab-config py-1">
			<div class="mb-1">Compendium <span class="ve-muted ve-small">(<span class="code">${this._importer.constructor.FOLDER_TYPE}</span>)</span>:</div>
			${$selCompendium}
		</div>`;

		const $wrpConfig = $$`<div class="ve-flex-col w-100 min-h-0">
			${$wrpSharedConfig}
			<div class="ve-flex">${$btnImportFolder}${$btnImportCompendium}</div>
			${$tabImportFolder}
			${$tabImportCompendium}
		</div>`;

		setCompendiumImport(isImportToCompendium);

		return $wrpConfig;
	}

	async _pDoQuickOpen (mode) {
		const importer = mode.Importer ? new mode.Importer({actor: this._actor, table: this._table}) : mode.importerInstance;
		await importer.pInit();

		await this._pInitImporter(mode);
		await this._pInitSourceSelector();
		const sources = await this._appSourceSelector.pGetSelectedSources();
		if (!sources.length) return ui.notifications.error(`No source(s) selected!`);
		await this._pHandleOpenImporter(sources, {importer, mode});
	}

	async pDoQuickOpenUsingExistingSourceSelection ({isSilent = false, isBackground = false} = {}) {
		await this._pInitImporter(this._getMode());
		await this._pInitSourceSelector();
		const sources = await this._appSourceSelector.pGetSelectedSources();
		if (!isSilent && !sources.length) return ui.notifications.error(`No source(s) selected!`);
		await this._pHandleOpenImporter(sources, {isSilent, isBackground});
	}

	_pFillUi_$getBtnOpenImporter () {
		return $(`<button class="btn btn-5et w-100 mr-2">${this._predefinedMode?.wizardTitleButtonOpenImporter || "Open Importer"}</button>`)
			.click(async () => {
				const sources = await this._appSourceSelector.pGetSelectedSources();
				if (!sources.length) return ui.notifications.error(`No source selected!`);
				await this._pHandleOpenImporter(sources);
			});
	}

	_pFillUi_$getBtnOpenConfig () {
		return $(`<button class="btn btn-5et" title="Open ${Config.get("ui", "isStreamerMode") ? "" : "Plutonium "}Config for This Importer"><span class="fas fa-fw fa-cogs"></span></button>`)
			.click(evt => Config.pHandleButtonClick(evt, this._importer.configGroup));
	}

		async _pHandleOpenImporter (sources, {importer = null, mode = null, isSilent = false, isBackground = false} = {}) {
		importer = importer || this._importer;
		mode = mode || this._getMode();

		await this._pHandleOpenImporter_pSaveLastUsed(importer, mode);

		const allContentMeta = await this._pHandleOpenImporter_pGetAllContent({importer, sources, isBackground});
		if (!allContentMeta) return;

		const {dedupedAllContentMerged, cacheKeys, userData} = allContentMeta;

		importer.userData = userData;

		if (
			!isSilent
			&& (!Object.values(dedupedAllContentMerged || {}).length)
		) {
			ui.notifications.warn(`No importable content found in the selected source${sources.length === 1 ? "" : "s"}!`);
			return;
		}

				const cacheKey = cacheKeys.includes(null) ? null : cacheKeys.join("__");
		await this._pFillUi_handleOpenClick_pOpen(importer, dedupedAllContentMerged, cacheKey);
	}

	async _pHandleOpenImporter_pGetAllContent ({importer, sources, isBackground}) {
		const $ovrLoading = await UtilApplications.$pGetAddAppLoadingOverlay(this._$window);

		try {
			return (await importer.pGetAllContent({
				sources,
				isBackground,
				uploadedFileMetas: this._appSourceSelector.uploadedFileMetas,
				customUrls: this._appSourceSelector.getCustomUrls(),
			}));
		} catch (e) {
			ui.notifications.error(`Failed to load importer! ${VeCt.STR_SEE_CONSOLE}`);
			throw e;
		} finally {
			if ($ovrLoading) $ovrLoading.remove();
		}
	}

	async _pHandleOpenImporter_pSaveLastUsed (importer, mode) {
		if (!importer || !mode) return;
				try {
			const toSave = MiscUtil.copy((await StorageUtil.pGet(ChooseImporter._STORAGE_KEY_LAST_USED_MODE)) || {});
			toSave[importer.gameProp] = mode.id;
			await StorageUtil.pSet(ChooseImporter._STORAGE_KEY_LAST_USED_MODE, toSave);
		} catch (e) {
			console.error(...LGT, e);
		}
	}

	async _pFillUi_handleOpenClick_pOpen (importer, dedupedAllContentMerged, cacheKey) {
		if (dedupedAllContentMerged == null || !Object.keys(dedupedAllContentMerged).length) return;

		const isOpenedFromCache = await this._pGetUi_pCheckOpenCachedInstance(importer, {fnCheckHit: cached => cached.cacheKey && cached.cacheKey === cacheKey && cached.hasActor === !!this._actor && cached.hasTable === !!this._table});
		if (isOpenedFromCache) {
			if (this._isAlwaysCloseWindow || !this._comp.get("isRemainOpen")) this.close();
			return;
		}

		if (this._isAlwaysCloseWindow || !this._comp.get("isRemainOpen")) this.close();

		await importer.pSetContent(dedupedAllContentMerged);

		await importer.pPreRender(this._importerPreRenderArgs);
				const pRender = importer.showAndRender(true);

		this._pGetUi_cacheInstance(importer, {cacheKey: cacheKey, hasActor: !!this._actor, hasTable: !!this._table});

		await pRender;
		if (Config.get("ui", "isEnableSubPopouts") && PopoutSheet.isPoppedOut(this)) {
			PopoutSheet.doPopout(importer);
		}
	}

	async _pGetUi_pCheckOpenCachedInstance (importer, {fnCheckHit}) {
		const instanceCacheKey = this._getInstanceCacheKey(importer);
		const cachedInstanceMeta = ChooseImporter._INSTANCE_CACHE[instanceCacheKey];

		if (!cachedInstanceMeta) return false;

				if (!fnCheckHit(cachedInstanceMeta)) {
			this.constructor._uncacheInstance(instanceCacheKey);
			return false;
		}

				await cachedInstanceMeta.instance.pSyncStateFrom(importer);

		await cachedInstanceMeta.instance.pPreRender(this._importerPreRenderArgs);
		cachedInstanceMeta.instance.render(true);
		cachedInstanceMeta.instance.maximize();
		UtilApplications.bringToFront(cachedInstanceMeta.instance);

		return true;
	}

	_pGetUi_cacheInstance (importer, instanceMeta) {
		const instanceCacheKey = this._getInstanceCacheKey(importer);

		if (importer.isNonCacheableInstance || instanceMeta.cacheKey == null) return;

		importer.isClosable = false;
		ChooseImporter._INSTANCE_CACHE[instanceCacheKey] = {
			...instanceMeta,
			instance: importer,
		};
	}

	static _uncacheInstance (instanceCacheKey) {
		const cachedInstanceMeta = ChooseImporter._INSTANCE_CACHE[instanceCacheKey];
		delete ChooseImporter._INSTANCE_CACHE[instanceCacheKey];
		cachedInstanceMeta.instance.isClosable = true;
		cachedInstanceMeta.instance.close();
	}

	static _getSourceSelectionKey (importer) { return `ChooseImporter_source_${importer.propsNamespace}`; }
	static _getImportToPackKey (importer) { return `ChooseImporter_is_pack_${importer.propsNamespace}`; }
	static _getPackSelectionKey (importer) { return `ChooseImporter_pack_${importer.propsNamespace}`; }

		_getFilterNamespace () { return `ChooseImporter_source_filter`; }

	_getInstanceCacheKey (importer) {
		const sourceKey = this.constructor._getSourceSelectionKey(importer);
		return [sourceKey, this._namespace].join("_");
	}

	async close (...args) {
		if (this._appSourceSelector) this._appSourceSelector.handlePreClose();
		await super.close(...args);
		if (this._appSourceSelector) this._appSourceSelector.handlePostClose();
	}

	async _pForceClose () {
		this._isClosable = true;
		await this.close();
	}
}
ChooseImporter._DEFAULT_STATE = {
	modeId: "adventures",
	isRemainOpen: true,
	ixTabPanel3: 0,
	packageSource: null,
};

ChooseImporter._STORAGE_KEY_LAST_USED_MODE = "choose_importer_last_used_mode";

ChooseImporter.Mode = class {
	constructor (
		{
			Importer,
			hasDefaultSource,
			singleName,
			requires,
			metaExternalArchive,
			metaOther,
			hasPackages,
			id,
			name,
			isNotAllable,

			importerInstance,
			wizardTitleWindow,
			wizardTitlePanel3,
			wizardTitleButtonOpenImporter,
		},
	) {
		this.Importer = Importer;
		this.hasDefaultSource = hasDefaultSource;
		this.singleName = singleName;
		this._requires = requires;
		this.metaExternalArchive = metaExternalArchive;
		this.metaOther = metaOther;
		this.hasPackages = hasPackages;
		this._id = id;
		this._name = name;
		this.isNotAllable = !!isNotAllable;

		this.importerInstance = importerInstance;
		this.wizardTitleWindow = wizardTitleWindow;
		this.wizardTitlePanel3 = wizardTitlePanel3;
		this.wizardTitleButtonOpenImporter = wizardTitleButtonOpenImporter;
	}

	get id () { return this._id ?? this.Importer.ID; }
	get name () { return this._name ?? this.Importer.DISPLAY_NAME_TYPE_PLURAL; }

	canTargetPlayerCharacter () {
		if (!this._requires) return true;
		if (typeof this._requires.actor === "boolean") return this._requires.actor;
		return this._requires.actor.includes("character");
	}

		canTargetSheets () {
		if (!this._requires) return true;
		return this._requires.actor !== false
			|| this._requires.table !== false;
	}

	canTargetContext ({table, actor} = {}) {
		if (!this._requires) return true;

		if (actor && typeof this._requires.actor === "boolean") return this._requires.actor;
		if (table && typeof this._requires.table === "boolean") return this._requires.table;

		if (actor) return this._requires.actor.includes(actor.type);
		if (table) return this._requires.table.includes(table.type);

		return true;
	}
};

ChooseImporter._MODES = [
	new ChooseImporter.Mode({
		Importer: ImportListAction,
		hasDefaultSource: true,
	}),
	new ChooseImporter.Mode({
		singleName: "Adventure",
		Importer: ImportListAdventure,
		requires: {
			actor: false,
			table: false,
		},
												metaOther: {
			text: "Packages",
			pFn: async () => {
				const importSpecialPackages = new ImportSpecialPackages();
				await importSpecialPackages.pInit();
				return importSpecialPackages.render(true);
			},
		},
		hasPackages: true,
		isNotAllable: true,
	}),
	new ChooseImporter.Mode({
		Importer: ImportListBackground,
		hasDefaultSource: true,
	}),
	new ChooseImporter.Mode({
		Importer: ImportListBackgroundFeature,
		hasDefaultSource: true,
	}),
	new ChooseImporter.Mode({
		singleName: "Book",
		Importer: ImportListBook,
		requires: {
			actor: false,
			table: false,
		},
		hasPackages: true,
		isNotAllable: true,
	}),
	new ChooseImporter.Mode({
		Importer: ImportListCharCreationOption,
		hasDefaultSource: true,
	}),
	new ChooseImporter.Mode({
		Importer: ImportListClass,
		hasDefaultSource: true,
	}),
	new ChooseImporter.Mode({
		Importer: ImportListClassFeature,
		hasDefaultSource: true,
	}),
	new ChooseImporter.Mode({
		Importer: ImportListConditionDisease,
		hasDefaultSource: true,
	}),
	new ChooseImporter.Mode({
		Importer: ImportListCreature,
		requires: {
			actor: ["character", "npc"],
		},
		hasDefaultSource: true,
	}),
							new ChooseImporter.Mode({
		Importer: ImportListCultBoon,
		hasDefaultSource: true,
	}),
	new ChooseImporter.Mode({
		Importer: ImportListDeck,
		requires: {
			actor: false,
		},
		hasDefaultSource: true,
	}),
	new ChooseImporter.Mode({
		Importer: ImportListDeity,
		requires: {
			actor: false,
		},
		hasDefaultSource: true,
	}),
	new ChooseImporter.Mode({
		Importer: ImportListFeat,
		hasDefaultSource: true,
	}),
	new ChooseImporter.Mode({
		Importer: ImportListHazard,
		requires: {
			actor: false,
		},
		hasDefaultSource: true,
	}),
	new ChooseImporter.Mode({
		Importer: ImportListItem,
		hasDefaultSource: true,
	}),
	new ChooseImporter.Mode({
		Importer: ImportListLanguage,
		requires: {
			actor: false,
		},
		hasDefaultSource: true,
	}),
	new ChooseImporter.Mode({
		Importer: ImportListMap,
		requires: {
			actor: false,
		},
		isNotAllable: true,
	}),
	new ChooseImporter.Mode({
		Importer: ImportListObject,
		requires: {
			actor: false,
		},
		hasDefaultSource: true,
	}),
	new ChooseImporter.Mode({
		Importer: ImportListVariantRule,
		requires: {
			actor: false,
		},
		hasDefaultSource: true,
	}),
	new ChooseImporter.Mode({
		Importer: ImportListOptionalFeature,
		hasDefaultSource: true,
	}),
	new ChooseImporter.Mode({
		Importer: ImportListPsionic,
		hasDefaultSource: true,
	}),
	new ChooseImporter.Mode({
		Importer: ImportListRace,
		hasDefaultSource: true,
	}),
	new ChooseImporter.Mode({
		Importer: ImportListRaceFeature,
		hasDefaultSource: true,
	}),
	new ChooseImporter.Mode({
		Importer: ImportListRecipe,
		requires: {
			actor: false,
		},
		hasDefaultSource: true,
	}),
	new ChooseImporter.Mode({
		Importer: ImportListSpell,
		hasDefaultSource: true,
	}),
	new ChooseImporter.Mode({
		Importer: ImportListReward,
		hasDefaultSource: true,
	}),
	new ChooseImporter.Mode({
		Importer: ImportListRollableTable,
		requires: {
			actor: false,
		},
		hasDefaultSource: true,
	}),
	new ChooseImporter.Mode({
		Importer: ImportListTrap,
		requires: {
			actor: false,
		},
		hasDefaultSource: true,
	}),
	new ChooseImporter.Mode({
		Importer: ImportListVehicle,
		requires: {
			actor: false,
		},
		hasDefaultSource: true,
	}),
	new ChooseImporter.Mode({
		Importer: ImportListVehicleUpgrade,
		hasDefaultSource: true,
	}),
];
ChooseImporter._INSTANCE_CACHE = {};

var ChooseImporter$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ChooseImporter: ChooseImporter
});

class DocumentEmbeddedDocumentCleaner extends Application {
		static pHandleButtonClick (evt, app, $html, data) {
		const instance = new this(app.document);
		instance.render(true);
	}
	
	constructor ({title, doc, embedType, embedProp, displayName, displayNamePlural, namespace}) {
		super(
			{
				title,
				template: `${SharedConsts.MODULE_LOCATION}/template/DocumentEmbeddedDocumentCleaner.hbs`,
				width: 640,
				height: Util.getMaxWindowHeight(),
				resizable: true,
			},
		);

		this._doc = doc;
		this._embedType = embedType;
		this._embedProp = embedProp;
		this._displayName = displayName;
		this._displayNamePlural = displayNamePlural;
		this._namespace = namespace;

				this._pageFilter = new AppFilterBasic();

		this._list = null;
		this._listSelectClickHandler = null;
		this._$btnReset = null;
		this._$iptSearch = null;
	}

	_handleFilterChange () {
		const f = this._pageFilter.filterBox.getValues();
		this._list.filter(li => this._pageFilter.toDisplay(f, this._rows[li.ix]));
	}

	activateListeners ($html) {
		super.activateListeners($html);

		this._activateListeners_initBtnRun($html);
		this._activateListeners_initBtnReset($html);
		this._activateListeners_pInitListAndFilters($html);
	}

	_activateListeners_initBtnRun ($html) {
		$html.find(`[name="btn-run"]`).click(async () => {
			if (!this._list) return;

			const selIds = this._list.items
				.filter(it => $(it.ele).find(`input`).prop("checked"))
				.map(it => ({name: it.name, id: it.data.id}));

			const displayName = selIds.length === 1 ? this._displayName : this._displayNamePlural;
			const doDelete = await UtilApplications.pGetConfirmation({
				title: `Delete ${displayName}`.toTitleCase(),
				content: `<h3 class="b-0">Are you sure?</h3><p>${selIds.length} ${displayName} and ${selIds.length === 1 ? "its" : "their"} data will be permanently deleted.</p>`,
				confirmText: "Delete",
				faIcon: "fa-trash",
			});
			if (!doDelete) return;

			this.close();

			await this._doc.deleteEmbeddedDocuments(this._embedType, selIds.map(it => it.id));
			ui.notifications.info(`Deleted ${selIds.length} ${displayName}`);
		});
	}

	_activateListeners_initBtnReset ($html) {
		this._$btnReset = $html.find(`[name="btn-reset"]`).click(() => {
			$html.find(`.search`).val("");
			if (this._list) this._list.reset();
		});
	}

	_activateListeners_pInitListAndFilters ($html) {
		this._$iptSearch = $html.find(`.search`);

				this._list = new List({
			$iptSearch: this._$iptSearch,
			$wrpList: $html.find(`.veapp__list`),
			fnSort: this.constructor._sortEntities,
		});

		this._listSelectClickHandler = new ListSelectClickHandler({list: this._list});
		SortUtil.initBtnSortHandlers($html.find(`[data-name="wrp-btns-sort"]`), this._list);
		this._listSelectClickHandler.bindSelectAllCheckbox($html.find(`[name="cb-select-all"]`), this._list);

		return this._pageFilter.pInitFilterBox({
			$iptSearch: this._$iptSearch,
			$btnReset: this._$btnReset,
			$btnOpen: $html.find(`[name=btn-filter]`),
			$btnToggleSummaryHidden: $html.find(`[name=btn-toggle-summary]`),
			$wrpMiniPills: $html.find(`.fltr__mini-view`),
			namespace: this._namespace,
		}).then(() => {
			this._rows.forEach(it => this._pageFilter.addToFilters(it));

			this._list.doAbsorbItems(
				this._rows,
				{
					fnGetName: it => it.name,
					fnGetData: (li, di) => ({...di, ...UtilList2.absorbFnGetData(li)}),
					fnBindListeners: it => UtilList2.absorbFnBindListeners(this._listSelectClickHandler, it),
				},
			);

			this._list.init();

			this._pageFilter.trimState();
			this._pageFilter.filterBox.render();

			this._pageFilter.filterBox.on(
				FilterBox.EVNT_VALCHANGE,
				this._handleFilterChange.bind(this),
			);

			this._handleFilterChange();
		});
	}

	static _sortEntities (a, b, opts) { return SortUtil.listSort(a, b, opts); }

		getData () {
		this._rows = this._doc[this._embedProp].map((it, ix) => this._getData_getRow(it, ix));

		return {
			...super.getData(),
			rows: this._rows,
		};
	}

	_getData_getRow (doc, ix) {
		return {
			name: this._getData_getEmbeddedDocName(doc),
			id: doc.id,
			type: this._getData_getEmbeddedDocType(doc),
			hasPlutoniumFlags: doc.flags?.[SharedConsts.MODULE_ID],
			ix,
		};
	}

	_getData_getEmbeddedDocName (doc) { throw new Error(`Unimplemented!`); }
	_getData_getEmbeddedDocType (doc) { throw new Error(`Unimplemented!`); }

	close (...args) {
		this._pageFilter.teardown();
		return super.close(...args);
	}
}

class ActorItemCleaner extends DocumentEmbeddedDocumentCleaner {
	constructor (actor) {
		super({
			title: "Item Cleaner",
			doc: actor,
			embedType: "Item",
			embedProp: "items",
			displayName: "item",
			displayNamePlural: "items",
			namespace: `tool-actor-item-cleaner`,
		});
	}

	_getData_getEmbeddedDocName (doc) { return doc.name; }
	_getData_getEmbeddedDocType (doc) { return (doc.type || "").toTitleCase(); }
}

class ActorSpellPreparedToggler extends Application {
		static pHandleButtonClick (evt, app, $html, data) {
		const instance = new ActorSpellPreparedToggler(app.actor);
		instance.render(true);
	}
	
	constructor (actor) {
		super({
			title: "Spell Prepared Toggler",
			template: `${SharedConsts.MODULE_LOCATION}/template/ActorSpellPreparedToggler.hbs`,
			width: 480,
			height: Util.getMaxWindowHeight(),
			resizable: true,
		});

		this._actor = actor;
		this._actorItems = this._actor.items
						.filter(it => it.type === "spell" && it.system.level !== 0 && it.system.preparation && it.system.preparation.mode === "prepared");

				this._pageFilter = new ActorSpellPreparedToggler.AppFilter();

		this._$iptName = null;
		this._activeSaveId = null;
		this._compSaves = null;
		this._$wrpSaveRows = null;
		this._renderableCollectionRules = null;

		this._list = null;
		this._listSelectClickHandler = null;
		this._$btnReset = null;
		this._$iptSearch = null;
	}

	_handleFilterChange () {
		const f = this._pageFilter.filterBox.getValues();
		this._list.filter(li => this._pageFilter.toDisplay(f, this._rows[li.ix]));
	}

	activateListeners ($html) {
		super.activateListeners($html);

		this._activateListeners_initIptListName($html);
		this._activateListeners_initBtnListNew($html);
		this._activateListeners_initBtnListSave($html);
		this._activateListeners_initBtnListLoad($html);
		this._activateListeners_initBtnRun($html);
		this._activateListeners_initBtnReset($html);
		this._activateListeners_pInitListAndFilters($html)
			.then(() => this._pDoLoadInitialState());
	}

	_activateListeners_initIptListName ($html) {
		this._$iptName = $html.find(`[name="ipt-list-name"]`);
	}

	_activateListeners_initBtnListNew ($html) {
		$html.find(`[name="btn-list-new"]`)
			.click(async () => {
				this._activeSaveId = null;
				this._$iptName.val("");
			});
	}

	_getActiveSave ({activeSaveId = null} = {}) {
		activeSaveId = activeSaveId || this._activeSaveId;
		return this._compSaves.spellLists.find(it => it.id === activeSaveId);
	}

	_activateListeners_initBtnListSave ($html) {
		$html.find(`[name="btn-list-save"]`)
			.click(async () => {
				try {
					let activeSave = this._getActiveSave();
					if (!activeSave) {
						activeSave = {
							id: CryptUtil.uid(),
							entity: {
								name: "",
								spells: [],
							},
						};
						this._compSaves.spellLists.push(activeSave);
					}

					this._activeSaveId = activeSave.id;

					activeSave.entity.name = this._$iptName.val().trim() || "(Unnamed List)";
					this._$iptName.val(activeSave.entity.name);

					activeSave.entity.spells = this._list.items
						.map(li => {
														const spellItem = this._actor.items.get(li.data.spellItemId);
							if (!spellItem) return;

							return {
								id: li.data.spellItemId,
								isPrepared: li.data.getNextState(),
							};
						})
						.filter(Boolean);

										const existingActorFlags = this._actor.flags?.[SharedConsts.MODULE_ID];
					const nxtFlags = {...existingActorFlags || {}};
					MiscUtil.set(nxtFlags, this.constructor.name, "saveId", this._activeSaveId);
					await UtilDocuments.pUpdateDocument(this._actor, {flags: {[SharedConsts.MODULE_ID]: nxtFlags}});
					
					this._compSaves.triggerSpellListsCollectionUpdate();

					ui.notifications.info(`Saved as "${activeSave.entity.name}"!`);
				} catch (e) {
					ui.notifications.error(`Failed to save list! ${VeCt.STR_SEE_CONSOLE}`);
					console.error(...LGT, e);
				}
			});
	}

	_activateListeners_initBtnListLoad ($html) {
		$html.find(`[name="btn-list-load"]`)
			.click(async () => {
				try {
					const {$modalInner, doClose} = await UtilApplications.pGetShowApplicationModal({
						title: `Load Prepared Spell List`,
						cbClose: (save) => {
							this._$wrpSaveRows.detach();
							if (!save) return;
							this._doLoadSave(save);
							ui.notifications.info(`Loaded list "${this._getActiveSave().entity.name}"!`);
						},
					});

					if (!this._compSaves.spellLists.length) $modalInner.append(`<div class="italic ve-muted py-1">No saved spell lists found.</div>`);

					this._$wrpSaveRows = this._$wrpSaveRows || $(`<div class="ve-flex-col w-100 h-100"></div>`);
					this._$wrpSaveRows.appendTo($modalInner);

					if (!this._renderableCollectionRules) {
						this._renderableCollectionRules = new ActorSpellPreparedToggler.RenderableCollectionSpellLists(
							this._compSaves,
							this._$wrpSaveRows,
						);
						const hk = () => {
							this._renderableCollectionRules.render();

							StorageUtil.pSet(
								this._getStorageKeyAllLists(),
								this._compSaves.spellLists,
							);
						};
						this._compSaves.addHookSpellLists(hk);
						hk();
					}
					this._renderableCollectionRules.cbClose = doClose;
				} catch (e) {
					ui.notifications.error(`Failed to load list! ${VeCt.STR_SEE_CONSOLE}`);
					console.error(...LGT, e);
				}
			});
	}

	_activateListeners_initBtnRun ($html) {
		$html.find(`[name="btn-run"]`).click(async () => {
			for (const it of this._list.items) {
				await it.data.pCommitState();
			}
		});
	}

	_activateListeners_initBtnReset ($html) {
		this._$btnReset = $html.find(`[name="btn-reset"]`).click(() => {
			$html.find(`.search`).val("");
			if (!this._list) return;

			this._list.reset();
			this._list.items.forEach(it => it.data.resetNextState());
		});
	}

	_activateListeners_pInitListAndFilters ($html) {
		this._$iptSearch = $html.find(`.search`);

				this._list = new List({
			$iptSearch: this._$iptSearch,
			$wrpList: $html.find(`.veapp__list`),
			isUseJquery: true,
			fnSort: PageFilterSpells.sortSpells,
		});
		SortUtil.initBtnSortHandlers($html.find(`[data-name="wrp-btns-sort"]`), this._list);
		this._listSelectClickHandler = new ListSelectClickHandler({list: this._list});

		const $cbAll = $html.find(`[name="cb-select-all"]`).change(() => {
			const isChecked = $cbAll.prop("checked");
			this._list.visibleItems.forEach(it => it.data.setNextState(isChecked));
		});

		return this._pageFilter.pInitFilterBox({
			$iptSearch: this._$iptSearch,
			$btnReset: this._$btnReset,
			$btnOpen: $html.find(`[name=btn-filter]`),
			$btnToggleSummaryHidden: $html.find(`[name=btn-toggle-summary]`),
			$wrpMiniPills: $html.find(`.fltr__mini-view`),
			namespace: `tool-actor-spell-prepared-toggler`,
		}).then(() => {
			this._rows.forEach(it => this._pageFilter.addToFilters(it));

			this._list.doAbsorbItems(
				this._actorItems,
				{
					fnGetName: it => it.name,
					fnGetValues: it => ({
						level: MiscUtil.get(it, "system", "level") || -1,
					}),
					fnGetData: (li, it) => {
						const $li = $(li.ele);
						return ({
							spellItemId: it.id,
							cbSel: $li.find(`input`)[0],
							$dispModified: $li.find(`.act-sp-prep__disp-modified`),
						});
					},
					fnBindListeners: (li, it) => {
						const nxtState = {
							prepared: it.system.preparation.prepared,
						};

						const handleNextState = () => {
							li.data.cbSel.checked = nxtState.prepared;
							li.data.$dispModified.toggleClass("ve-hidden", it.system.preparation.prepared === nxtState.prepared);
						};

						const setNextState = (val) => {
							nxtState.prepared = val;
							handleNextState();
						};

						const resetNextState = () => {
							nxtState.prepared = it.system.preparation.prepared;
							handleNextState();
						};

						const getNextState = () => nxtState.prepared;

						const pCommitState = async () => {
							await DataConverterSpell.pSetSpellItemIsPrepared(it, nxtState.prepared);
							handleNextState();
						};

						li.data.setNextState = setNextState;
						li.data.resetNextState = resetNextState;
						li.data.getNextState = getNextState;
						li.data.pCommitState = pCommitState;

						li.ele.addEventListener("click", evt => {
							this._listSelectClickHandler.handleSelectClick(
								li,
								evt,
								{
									isNoHighlightSelection: true,
									fnOnSelectionChange: (li, setTo) => li.data.setNextState(setTo),
								},
							);
						});
					},
				},
			);

			this._list.init();

			this._pageFilter.trimState();
			this._pageFilter.filterBox.render();

			this._pageFilter.filterBox.on(
				FilterBox.EVNT_VALCHANGE,
				this._handleFilterChange.bind(this),
			);

			this._handleFilterChange();
		});
	}

	async _pDoLoadInitialState () {
				this._compSaves = new ActorSpellPreparedToggler.SavedSpellListComponent();

		const allSaves = await StorageUtil.pGet(this._getStorageKeyAllLists());
		if (!allSaves?.length) return;

		this._compSaves.spellLists = allSaves;
		
				const flags = this._actor.flags?.[SharedConsts.MODULE_ID];
		if (!flags?.[this.constructor.name]?.saveId) return;

		const save = allSaves.find(it => it.id === flags[this.constructor.name].saveId);
		if (!save) return;

		this._doLoadSave(save);
			}

	_doLoadSave (save) {
		if (!save?.entity.spells?.length) return;

		this._activeSaveId = save.id;
		this._$iptName.val(save.entity.name);

		save.entity.spells.forEach(({id, isPrepared}) => {
			const li = this._list.items.find(li => li.data.spellItemId === id);
			if (li) li.data.setNextState(isPrepared);
		});
	}

	_getStorageKeyAllLists () { return `${this.constructor.name}.saves`; }

	getData () {
		this._rows = this._actorItems.map((it, ix) => ({
			name: it.name,
			isPrepared: it.system.preparation.prepared,
			level: MiscUtil.get(it, "system", "level") || -1,
			concentration: !!MiscUtil.get(it, "system", "components", "concentration"),
			v: !!MiscUtil.get(it, "system", "components", "vocal"),
			s: !!MiscUtil.get(it, "system", "components", "somatic"),
			m: !!MiscUtil.get(it, "system", "components", "material"),
			ritual: !!MiscUtil.get(it, "system", "components", "ritual"),
			ix,
		}));

		return {
			...super.getData(),
			rows: this._rows,
		};
	}

	close (...args) {
		this._pageFilter.teardown();
		return super.close(...args);
	}
}

ActorSpellPreparedToggler.AppFilter = class extends AppFilter {
	constructor () {
		super();

		this._levelFilter = new Filter({
			header: "Level",
			items: [1, 2, 3, 4, 5, 6, 7, 8, 9],
			displayFn: lvl => ~lvl ? PageFilterSpells.getFltrSpellLevelStr(lvl) : "Unknown",
		});
		this._miscFilter = new Filter({
			header: "Components & Miscellaneous",
			items: ["Concentration", "Verbal", "Somatic", "Material", "Ritual"],
			itemSortFn: PageFilterSpells.sortMetaFilter,
		});
	}

	addToFilters (entity, isExcluded) {
		if (isExcluded) return;

		this._levelFilter.addItem(entity.level);
		entity._fMisc = [];
		if (entity.concentration) entity._fMisc.push("Concentration");
		if (entity.v) entity._fMisc.push("Verbal");
		if (entity.s) entity._fMisc.push("Somatic");
		if (entity.m) entity._fMisc.push("Material");
		if (entity.ritual) entity._fMisc.push("Ritual");
	}

	async _pPopulateBoxOptions (opts) {
		opts.filters = [
			this._levelFilter,
			this._miscFilter,
		];
	}

	toDisplay (values, ent) {
		return this._filterBox.toDisplay(
			values,
			ent.level,
			ent._fMisc,
		);
	}
};

ActorSpellPreparedToggler.SavedSpellListComponent = class extends BaseComponent {
	get spellLists () { return this._state[ActorSpellPreparedToggler.SavedSpellListComponent._PROP_SPELL_LISTS]; }
	set spellLists (val) { this._state[ActorSpellPreparedToggler.SavedSpellListComponent._PROP_SPELL_LISTS] = val; }

	addHookSpellLists (hk) { this._addHookBase(ActorSpellPreparedToggler.SavedSpellListComponent._PROP_SPELL_LISTS, hk); }

	triggerSpellListsCollectionUpdate () { this._triggerCollectionUpdate(ActorSpellPreparedToggler.SavedSpellListComponent._PROP_SPELL_LISTS); }

	_getDefaultState () {
		return {
			[ActorSpellPreparedToggler.SavedSpellListComponent._PROP_SPELL_LISTS]: [],
		};
	}
};
ActorSpellPreparedToggler.SavedSpellListComponent._PROP_SPELL_LISTS = "spellLists";

ActorSpellPreparedToggler.RenderableCollectionSpellLists = class extends RenderableCollectionBase {
	constructor (compSaves, $wrp) {
		super(compSaves, ActorSpellPreparedToggler.SavedSpellListComponent._PROP_SPELL_LISTS);
		this._$wrp = $wrp;
		this._cbClose = null;
	}

	set cbClose (fn) { this._cbClose = fn; }

	getNewRender (spellList) {
		const parentComp = this._comp;

		const comp = BaseComponent.fromObject(spellList.entity, "*");
		comp._addHookAll("state", () => {
			spellList.entity = comp.toObject("*");
			parentComp.triggerSpellListsCollectionUpdate();
		});

		const $btnLoad = $(`<button class="btn btn-xxs" title="Load"><span class="glyphicon glyphicon-ok"></span></button>`)
			.click(() => {
				this._cbClose(spellList);
			});

		const $btnDelete = $(`<button class="btn btn-xxs btn-danger" title="Delete"><span class="glyphicon glyphicon-trash"></span></button>`)
			.click(() => {
				parentComp.spellLists = parentComp.spellLists.filter(it => it !== spellList);
			});

		const $wrpRow = $$`<div class="ve-flex-v-center py-1 stripe-even toggsp__row">
			<div class="mr-2">${$btnLoad}</div>
			<div class="ve-flex-v-center w-100 mr-2">${comp._state.name}</div>
			<div class="">${$btnDelete}</div>
		</div>`.appendTo(this._$wrp);

		return {
			comp,
			$wrpRow,
			fnCleanup: () => {
							},
		};
	}

	doUpdateExistingRender (renderedMeta, spellList) {
		renderedMeta.comp._proxyAssignSimple("state", spellList.entity, true);
	}

	doDeleteExistingRender (renderedMeta) {
		renderedMeta.fnCleanup();
	}

	doReorderExistingComponent (renderedMeta, spellList) {
		const parent = this._comp;

		const ix = parent.spellLists.map(it => it.id).indexOf(spellList.id);
		const curIx = this._$wrp.find(`.toggsp__row`).index(renderedMeta.$wrpRow);

		const isMove = !this._$wrp.length || curIx !== ix;
		if (isMove) renderedMeta.$wrpRow.detach().appendTo(this._$wrp);
	}
};

class ActorPolymorpher {
		static prePreInit () {
		this._preInit_registerKeybinds();
	}

	static _preInit_registerKeybinds () {
		const doKeybindingOpenForCharacter = () => {
			const actor = UtilKeybinding.getPlayerActor({minRole: Config.get("tools", "minimumRolePolymorph")});
			if (!actor) return true;
			this._pOpen({actor});
			return true;
		};

		const doKeybindingOpenForCurrentSheet = () => {
			const meta = UtilKeybinding.getCurrentImportableSheetDocumentMeta({isRequireActor: true, isRequireOwnership: true, minRole: Config.get("tools", "minimumRolePolymorph")});
			if (!meta?.actor) return true;
			this._pOpen({...meta});
			return true;
		};

		game.keybindings.register(
			SharedConsts.MODULE_ID,
			"ActorPolymorpher__openForCharacter",
			{
				name: "Open Polymorpher Targeting Player Character",
				editable: [],
				onDown: () => doKeybindingOpenForCharacter(),
			},
		);

		game.keybindings.register(
			SharedConsts.MODULE_ID,
			"ActorPolymorpher__openForCurrentSheet",
			{
				name: "Open Polymorpher Targeting Current Sheet",
				editable: [],
				onDown: () => doKeybindingOpenForCurrentSheet(),
			},
		);
	}

	static init () {
		if (game.user.isGM) this._init_gm();
		else this._init_player();
	}

	static _isActorTransformed (actor) {
		if (MiscUtil.get(actor.flags, "dnd5e", "originalActor")) return true;
		if (MiscUtil.get(actor.flags, "dnd5e", "transformOptions")) return true;
		return false;
	}

	static _pSendPlayerUndoTransformationRequest ({actorId}) {
		const actor = CONFIG.Actor.collection.instance.get(actorId);
		return UtilChat.pSendGmOnlyMessage({
			content: `<p>${game.user.name} has transformed back into their original form, and requests you delete their temporary polymorphed actor "${actor.name.escapeQuotes()}." Proceed?</p><div><button data-plut-poly-actor-delete="${actorId}">Delete</button></div>`,
		});
	}

	static _pSendPlayerDeleteTempActorRequest ({actorId}) {
		const actor = CONFIG.Actor.collection.instance.get(actorId);
		return UtilChat.pSendGmOnlyMessage({
			content: `<p>${game.user.name} requests you delete their temporary polymorph template actor "${actor.name.escapeQuotes()}." Proceed?</p><div><button data-plut-poly-temp-actor-delete="${actorId}">Delete</button></div>`,
		});
	}

	static _init_player () {
				$(document.body)
			.on("click", `.restore-transformation`, evt => {
				const actorId = $(evt.currentTarget).closest(`.sheet.actor`).attr("id").replace("actor-", "");
				const actor = CONFIG.Actor.collection.instance.get(actorId);

				if (!this._isActorTransformed(actor)) {
					const msg = `This actor does not appear to be transformed\u2014this may be a bug!`;
					console.warn(msg);
					ui.notfications.warn(msg);
				}

				this._pSendPlayerUndoTransformationRequest({actorId});
			});
	}

	static _init_gm () {
		$(document.body)
			.on("click", `[data-plut-poly-actor-delete]`, async evt => {
				const actorId = $(evt.currentTarget).attr("data-plut-poly-actor-delete");
				const actor = CONFIG.Actor.collection.instance.get(actorId);
				if (!actor) return ui.notifications.warn(`Actor "${actorId}" not found!`);

				if (!this._isActorTransformed(actor)) {
					const isDeleteAnyway = await InputUiUtil.pGetUserBoolean({title: "Are You Sure?", htmlDescription: `This actor does not appear to be transformed. Are you sure you want to delete this actor, which may be an original actor?`});
					if (!isDeleteAnyway) return;
				}

				await actor.delete();
				ui.notifications.info(`Deleted actor "${actor.name}"`);

				await UtilChat.pDeleteMessage({ele: evt.currentTarget});
			})
			.on("click", `[data-plut-poly-temp-actor-delete]`, async evt => {
				const actorId = $(evt.currentTarget).attr("data-plut-poly-temp-actor-delete");
				const actor = CONFIG.Actor.collection.instance.get(actorId);
				if (!actor) return ui.notifications.warn(`Actor "${actorId}" not found!`);

				await actor.delete();
				ui.notifications.info(`Deleted actor "${actor.name}"`);

				await UtilChat.pDeleteMessage({ele: evt.currentTarget});
			});
	}

	static async pHandleButtonClick (evt, app, $html, data) {
		return this._pOpen({actor: app.actor});
	}

	static async _pOpen ({actor}) {
		if (!game.user.isGM) {
			const messages = [
				game.user.can("ACTOR_CREATE") ? "" : "you lack actor creation permissions",
												UtilGameSettings.getSafe("dnd5e", "allowPolymorphing") ? "" : "system-wide player polymorphing is disabled",
			].filter(Boolean);

			if (messages.length) return ui.notifications.warn(`Cannot polymorph: ${messages.join("; ")}`);
		}

		const sourceActor = await ActorPolymorpher.ImportList.pGetUserChoice(
			{
				id: "creatures-actorPolymorpher",
				name: "Creatures",
				singleName: "Creature",

				wizardTitleWindow: `Select Source (Polymorphing Actor "${actor.name}")`,
				wizardTitlePanel3: "Configure and Open List",
				wizardTitleButtonOpenImporter: "Open List",
			},
			"actorPolymorpher",
		);
		if (sourceActor == null) return;

		try {
			await this._doFakeActorDrop(actor, sourceActor);
		} catch (e) {
			console.error(e);
		}

		if (Util.Fvtt.canUserCreateFolders()) {
			if (sourceActor.folder.children.length || sourceActor.folder.contents.length > 1) {
				const isDeleteAnyway = await InputUiUtil.pGetUserBoolean({title: "Delete Temp Folder?", htmlDescription: `The temp folder "${Config.get("import", "tempFolderName")}" contains more contents than expected.<br>Delete it anyway?`});
				if (!isDeleteAnyway) return;
			}
			await sourceActor.folder.delete({deleteSubfolders: true, deleteContents: true});
			return;
		}

		this._pSendPlayerDeleteTempActorRequest({actorId: sourceActor.id});
	}

	
		static async _doFakeActorDrop (actor, sourceActor) {
				const rememberOptions = html => {
			const options = {};
			html.find("input").each((i, el) => {
				options[el.name] = el.checked;
			});
			const settings = foundry.utils.mergeObject(UtilGameSettings.getSafe("dnd5e", "polymorphSettings") ?? {}, options);
			game.settings.set("dnd5e", "polymorphSettings", settings);
			return settings;
		};

		if (UtilVersions.getSystemVersion().isVersionTwoOnePlus) {
						return new Dialog({
				title: game.i18n.localize("DND5E.PolymorphPromptTitle"),
				content: {
					options: game.settings.get("dnd5e", "polymorphSettings"),
					settings: CONFIG.DND5E.polymorphSettings,
					effectSettings: CONFIG.DND5E.polymorphEffectSettings,
					isToken: actor.isToken,
				},
				default: "accept",
				buttons: {
					accept: {
						icon: "<i class=\"fas fa-check\"></i>",
						label: game.i18n.localize("DND5E.PolymorphAcceptSettings"),
						callback: html => actor.transformInto(sourceActor, rememberOptions(html)),
					},
					wildshape: {
						icon: CONFIG.DND5E.transformationPresets.wildshape.icon,
						label: CONFIG.DND5E.transformationPresets.wildshape.label,
						callback: html => actor.transformInto(sourceActor, foundry.utils.mergeObject(
							CONFIG.DND5E.transformationPresets.wildshape.options,
							{ transformTokens: rememberOptions(html).transformTokens },
						)),
					},
					polymorph: {
						icon: CONFIG.DND5E.transformationPresets.polymorph.icon,
						label: CONFIG.DND5E.transformationPresets.polymorph.label,
						callback: html => actor.transformInto(sourceActor, foundry.utils.mergeObject(
							CONFIG.DND5E.transformationPresets.polymorph.options,
							{ transformTokens: rememberOptions(html).transformTokens },
						)),
					},
					self: {
						icon: CONFIG.DND5E.transformationPresets.polymorphSelf.icon,
						label: CONFIG.DND5E.transformationPresets.polymorphSelf.label,
						callback: html => actor.transformInto(sourceActor, foundry.utils.mergeObject(
							CONFIG.DND5E.transformationPresets.polymorphSelf.options,
							{ transformTokens: rememberOptions(html).transformTokens },
						)),
					},
					cancel: {
						icon: "<i class=\"fas fa-times\"></i>",
						label: game.i18n.localize("Cancel"),
					},
				},
			}, {
				classes: ["dialog", "dnd5e", "polymorph"],
				width: 900,
				template: "systems/dnd5e/templates/apps/polymorph-prompt.hbs",
			}).render(true);
		}

				return new Dialog({
			title: game.i18n.localize("DND5E.PolymorphPromptTitle"),
			content: {
				options: UtilGameSettings.getSafe("dnd5e", "polymorphSettings"),
				i18n: CONFIG.DND5E.polymorphSettings,
				isToken: actor.isToken,
			},
			default: "accept",
			buttons: {
				accept: {
					icon: `<i class="fas fa-fw fa-check"></i>`,
					label: game.i18n.localize("DND5E.PolymorphAcceptSettings"),
					callback: html => actor.transformInto(sourceActor, rememberOptions(html)),
				},
				wildshape: {
					icon: `<i class="fas fa-fw fa-paw"></i>`,
					label: game.i18n.localize("DND5E.PolymorphWildShape"),
					callback: html => actor.transformInto(sourceActor, {
						keepBio: true,
						keepClass: true,
						keepMental: true,
						mergeSaves: true,
						mergeSkills: true,
						transformTokens: rememberOptions(html).transformTokens,
					}),
				},
				polymorph: {
					icon: `<i class="fas fa-fw fa-pastafarianism"></i>`,
					label: game.i18n.localize("DND5E.Polymorph"),
					callback: html => actor.transformInto(sourceActor, {
						transformTokens: rememberOptions(html).transformTokens,
					}),
				},
				cancel: {
					icon: `<i class="fas fa-fw fa-times"></i>`,
					label: game.i18n.localize("Cancel"),
				},
			},
		}, {
			classes: ["dialog", "dnd5e"],
			width: 600,
			template: "systems/dnd5e/templates/apps/polymorph-prompt.hbs",
		}).render(true);
	}
	}

ActorPolymorpher.ImportList = class extends MixinUserChooseImporter(ImportListCreature) {
	_isForceImportToTempDirectory = true;

	getData () {
		const out = super.getData();
		out.buttonsAdditional = [
			{
				name: "btn-run-mods",
				text: "Customize and Select...",
			},
		];
		return out;
	}
};

class UtilSocket {
	static init () {
		game.socket.on(
			UtilSocket._EVENT_NAME,
			packedData => {
				if (!packedData.type) return;

				const data = this._getUnpackedData(packedData);
				const fnsToRun = UtilSocket._EVENT_LISTENERS[packedData.type] || [];
				fnsToRun.forEach(fn => fn(data));
			},
		);

				game.socket.on("progress", data => {
			this._doHandleProgressMessage(data);
		});
	}

		static _doHandleProgressMessage (data) {
		if (data?.action === "installPackage") SceneNavigation.displayProgressBar({label: data.step, pct: data.pct});
	}

	static pSendData (namespace, data) {
		const packedData = this._getPackedData(namespace, data);

		return new Promise((resolve) => {
			game.socket.emit(
				UtilSocket._EVENT_NAME,
				packedData, 				{}, 				unknown => { 					return resolve(unknown);
				},
			);
		});
	}

	static _getPackedData (namespace, data) {
		return {
			type: namespace,
			data,
		};
	}

	static _getUnpackedData (packedData) {
		if (!packedData.type) return packedData;
		return packedData.data;
	}

	static addSocketEventListener (namespace, fnListener) {
		const tgt = MiscUtil.getOrSet(UtilSocket._EVENT_LISTENERS, namespace, []);
		tgt.push(fnListener);
	}
}
UtilSocket._EVENT_NAME = `module.${SharedConsts.MODULE_ID}`;
UtilSocket._EVENT_LISTENERS = {};

class ShowSheet {
		static init () {
		UtilSocket.addSocketEventListener(
			ShowSheet._SOCKET_NAMESPACE,
			id => {
				ShowSheet._pShowSheet(id);
			},
		);
	}

	static pHandleButtonClick (evt, app, $html, data) {
		evt.preventDefault();
		return this._pHandleShowClick(app, data);
	}
	
	static async _pHandleShowClick (app, data) {
		const name = app.title || UtilApplications.getDataName(data);

				if (!UtilMigrate.isOwner(data)) throw new Error("You may only request to show sheets which you own.");

		const activeUsersWithoutPermissions = CONFIG.User.collection.instance.contents.filter(it => it.active).filter(user => !(app.actor || app.document).testUserPermission(user));
		if (activeUsersWithoutPermissions.length) {
			const isSetDefaultOwnership = await InputUiUtil.pGetUserBoolean({
				title: `Update Permissions`,
				textYes: `Make Visible to All Users`,
				textNo: `Show to Current Viewers`,
				htmlDescription: `${Parser.numberToText(activeUsersWithoutPermissions.length).uppercaseFirst()} ${activeUsersWithoutPermissions.length === 1 ? "user is" : "users are"} currently unable to view this sheet.<br>Would you like to update the default permissions for this sheet, to allow all users to view it?`,
			});

			if (isSetDefaultOwnership) {
				await UtilDocuments.pUpdateDocument(
					app.actor || app.document,
					{ownership: {default: CONST.DOCUMENT_OWNERSHIP_LEVELS.LIMITED}},
				);
			}
		}

		await UtilSocket.pSendData(ShowSheet._SOCKET_NAMESPACE, app.id);
		ShowSheet._pShowSheet(app.id);
		ui.notifications.info(`"${name}" show to authorized players.`);
	}

		static _pShowSheet (appId) {
		if (!appId) return;
		const [, type, id] = appId.split(/-/);

		let doc;

		const collection = CONFIG[type]?.collection;
		if (!collection) throw new Error(`Unsupported entity type "${type}"`);

		doc = collection.instance.get(id);

		if (!doc || !doc.visible) return;

		return doc.sheet.render(true);
	}
}
ShowSheet._SOCKET_NAMESPACE = "ShowSheet";

class MenuToolInfo {
	constructor (
		{
			name,
			streamerName,
			Class,
			iconClass,
			getIcon,
			getMinRole,
			isRequireOwner,
			additionalClassesButton,
			pFnOnClick,
			fnCheckRequirements,
		},
	) {
		this.name = name;
		this.streamerName = streamerName;
		this.Class = Class;
		this.iconClass = iconClass;
		this.getIcon = getIcon;
		this.getMinRole = getMinRole;
		this.isRequireOwner = isRequireOwner;
		this.additionalClassesButton = additionalClassesButton;
		this.pFnOnClick = pFnOnClick;
		this.fnCheckRequirements = fnCheckRequirements;
	}
}

class MenuTitleActor extends MenuTitle {}
MenuTitleActor._HOOK_NAME = "renderActorSheet";
MenuTitleActor._EVT_NAMESPACE = "plutonium-actor-title-menu";

MenuTitleActor._TOOL_LIST = [
	new MenuToolInfo({
		name: "Plutonium Import",
		streamerName: "Import",
		Class: ChooseImporter,
		getIcon: () => UtilUi.getModuleFaIcon(),
		getMinRole: () => Config.get("import", "minimumRole"),
		isRequireOwner: true,
	}),
	new MenuToolInfo({
		name: "Equipment Shop",
		Class: Charactermancer_StartingEquipment,
		iconClass: "fa-shopping-cart",
		getMinRole: () => Config.get("equipmentShop", "minimumRole"),
		isRequireOwner: true,
	}),
	new MenuToolInfo({
		name: "Polymorpher",
		Class: ActorPolymorpher,
		iconClass: "fa-paw",
		getMinRole: () => Config.get("tools", "minimumRolePolymorph"),
		isRequireOwner: true,
	}),
	new MenuToolInfo({
		name: "Item Cleaner",
		Class: ActorItemCleaner,
		iconClass: "fa-trash-alt",
		getMinRole: () => Config.get("tools", "minimumRoleActorTools"),
		isRequireOwner: true,
	}),
	new MenuToolInfo({
		name: "Prepared Spell Mass-Toggler",
		Class: ActorSpellPreparedToggler,
		iconClass: "fa-check-square",
		getMinRole: () => Config.get("tools", "minimumRoleActorTools"),
		isRequireOwner: true,
	}),
	new MenuToolInfo({
		name: "Set as Rivet Target",
		pFnOnClick: (evt, app) => {
			Config.setRivetTargetDocument({actor: app.actor});
		},
		iconClass: "fa-hammer",
		getMinRole: () => Config.get("rivet", "minimumRole"),
		isRequireOwner: true,
	}),
	new MenuToolInfo({
		name: "Show Players",
		Class: ShowSheet,
		iconClass: "fa-eye",
		isRequireOwner: true,
	}),
];

class MenuTitleItem extends MenuTitle {}
MenuTitleItem._HOOK_NAME = "renderItemSheet";
MenuTitleItem._EVT_NAMESPACE = "plutonium-item-title-menu";
MenuTitleItem._TOOL_LIST = [
	new MenuToolInfo({
		name: "Show Players",
		Class: ShowSheet,
		iconClass: "fa-eye",
		isRequireOwner: true,
	}),
];

class MenuTitleJournalSheet extends MenuTitle {}
MenuTitleJournalSheet._HOOK_NAME = "renderJournalSheet";
MenuTitleJournalSheet._EVT_NAMESPACE = "plutonium-journal-sheet-title-menu";
MenuTitleJournalSheet._TOOL_LIST = [];

class TableResultCleaner extends DocumentEmbeddedDocumentCleaner {
	constructor (table) {
		super({
			title: "Row Cleaner",
			doc: table,
			embedType: "TableResult",
			embedProp: "results",
			displayName: "row",
			displayNamePlural: "rows",
			namespace: `tool-table-result-cleaner`,
		});
	}

	static _sortEntities (a, b, opts) {
		return opts.sortBy === "name"
			? (SortUtil.ascSort(a.data.rangeLow, b.data.rangeLow) || super._sortEntities(a, b, opts))
			: super._sortEntities(a, b, opts);
	}

	_getData_getRow (doc, ix) {
		const out = super._getData_getRow(doc, ix);
		out.rangeLow = Math.min(...(doc.data.range || []));
		if (out.rangeLow === Infinity) out.rangeLow = Number.MIN_SAFE_INTEGER;
		return out;
	}

	_getData_getEmbeddedDocName (doc) {
		return [
			(doc.data.range || []).filter(it => it != null).join("\u2012"),
			doc.data.text,
		]
			.filter(Boolean)
			.join(" ");
	}

	_getData_getEmbeddedDocType (doc) {
		switch (doc.type) {
			case 0: return `Text`;
			case 1: return `Collection (${doc.data.collection})`;
			case 2: return `Compendium (${doc.data.collection})`;
			default: throw new Error(`Unhandled table result type "${doc.type}"`);
		}
	}
}

class MenuTitleRollTableConfig extends MenuTitle {}
MenuTitleRollTableConfig._HOOK_NAME = "renderRollTableConfig";
MenuTitleRollTableConfig._EVT_NAMESPACE = "plutonium-roll-table-config-title-menu";
MenuTitleRollTableConfig._TOOL_LIST = [
	new MenuToolInfo({
		name: "Plutonium Import",
		streamerName: "Import",
		Class: ChooseImporter,
		getIcon: () => UtilUi.getModuleFaIcon(),
		getMinRole: () => Config.get("import", "minimumRole"),
		isRequireOwner: true,
	}),
	new MenuToolInfo({
		name: "Row Cleaner",
		Class: TableResultCleaner,
		iconClass: "fa-trash-alt",
		getMinRole: () => Config.get("tools", "minimumRoleTableTools"),
		isRequireOwner: true,
	}),
];

class MenuTitleArtBrowserApp extends MenuTitle {}
MenuTitleArtBrowserApp._HOOK_NAME = "renderArtBrowserApp";
MenuTitleArtBrowserApp._EVT_NAMESPACE = "plutonium-art-browser-app-title-menu";
MenuTitleArtBrowserApp._TOOL_LIST = [];

class MenuTitleCompendium extends MenuTitle {}
MenuTitleCompendium._HOOK_NAME = "renderCompendium";
MenuTitleCompendium._EVT_NAMESPACE = "plutonium-compendium-title-menu";

class MenuTitleCompendiumCleaner {
	static async pHandleButtonClick (evt, app, $html, data) {
		const isSure = await InputUiUtil.pGetUserBoolean({
			title: `Are You Sure?${app.locked ? ` <b>This compendium is locked.</b>` : ""}`,
		});
		if (!isSure) return;

		const content = await data.collection.getDocuments();
		data.collection.documentClass.deleteDocuments(content.map(it => it.id), {pack: data.collection.collection});
	}
}

class MenuTitleCompendiumMassImporter {
	static async pHandleButtonClick (evt, app, $html, data) {
		data.collection.importDialog();
	}
}

MenuTitleCompendium._TOOL_LIST = [
	new MenuToolInfo({
		name: "Import All",
		Class: MenuTitleCompendiumMassImporter,
		iconClass: "fas fa-download",
	}),
	new MenuToolInfo({
		name: "Set as Rivet Target",
		pFnOnClick: (evt, app) => {
			Config.setRivetTargetDocument({pack: app.collection});
		},
		iconClass: "fa-hammer",
		getMinRole: () => Config.get("rivet", "minimumRole"),
	}),
	new MenuToolInfo({
		name: "Delete All",
		Class: MenuTitleCompendiumCleaner,
		iconClass: "fa-trash-alt",
	}),
];

class UtilWorldContentBlocklist {
	static _SETTINGS_KEY = "blacklist";

	static async pInit () {
		await game.settings.register(
			SharedConsts.MODULE_ID,
			this._SETTINGS_KEY,
			{
				name: "World Content Blocklist",
				default: [],
				type: Array,
				scope: "world",
				onChange: data => {
									},
			},
		);

				ExcludeUtil._pSave = async () => {
			await game.settings.set(SharedConsts.MODULE_ID, this._SETTINGS_KEY, MiscUtil.copy(ExcludeUtil._excludes));
		};

		ExcludeUtil.pInitialise = async () => {
			ExcludeUtil.pSave = MiscUtil.throttle(ExcludeUtil._pSave, 50);
			ExcludeUtil._excludes = UtilGameSettings.getSafe(SharedConsts.MODULE_ID, this._SETTINGS_KEY) || [];
			ExcludeUtil.isInitialised = true;
		};
		
		await ExcludeUtil.pInitialise();
	}

	static async pSaveState (saveableState, {message = "Saved!"} = {}) {
		await ExcludeUtil.pSetList(saveableState);
		await game.settings.set(SharedConsts.MODULE_ID, this._SETTINGS_KEY, saveableState);
		ui.notifications.info(`${message} Note that you (and connected players) may need to reload for any changes to take effect.`);
	}
}

class UtilImporter {
	static async pForceRenderImportedDocSheets (importSummary) {
		return Promise.all(
			(importSummary.imported || [])
				.map(it => it.document)
				.filter(Boolean)
				.map(doc => UtilApplications.pForceRenderApp(doc.sheet ? doc.sheet : doc)),
		);
	}
}

class RivetBridge {
	static init () {
		window.addEventListener("rivet.receive", evt => {
			console.log(...LGT, `Received Rivet message (JSON)`);
			return this._handlePacket(evt.detail);
		});

		window.addEventListener("rivet.receive-text", () => {
			console.log(...LGT, `Received Rivet message (text)`);
			const $ipts = $(`textarea.rivet-transfer`);
			const packetRaw = $ipts.last().val();
			$ipts.remove();
			return this._handlePacket(JSON.parse(packetRaw));
		});
	}

	static _handlePacket (packet) {
		if (game.user.role < Config.get("rivet", "minimumRole")) return;

		switch (packet.type) {
			case "roll": return this._pHandleRollMessage(packet);
			case "entity": return this._pHandleEntityMessage(packet);
			case "currency": return this._pHandleCurrencyMessage(packet);
			case "5etools.lootgen.loot": return this._pHandleSpecialMessage_5etools_lootgen_loot(packet);
			case "5etools.blocklist.excludes": return this._pHandleSpecialMessage_5etools_blocklist_excludes(packet);
			default: ui.notifications.error(`Unhandled Rivet message with type "${packet.type}"! You may need to update your extension.`);
		}
	}

	static async _pHandleRollMessage (pack) {
		const data = pack.data;

		if (!pack.settings.isSendRolls) return;

		const roll = new Roll(data.dice);
		const msgData = {
			speaker: {
				alias: data.rolledBy,
			},
			flavor: data.label,
			type: CONST.CHAT_MESSAGE_TYPES.ROLL,
		};
		if (pack.settings.isWhisper) {
			msgData.whisper = game.users
				.filter(it => it.active && (it.isGM || it.id === game.user.id))
				.map(it => it.id);
		}

				roll._evaluated = true;
		roll._total = data.result;
		
		await roll.toMessage(
			msgData,
			{
				rollMode: pack.settings.isWhisper ? CONFIG.Dice.rollModes.gmroll : CONFIG.Dice.rollModes.publicroll,
			},
		);
	}

		static async _pHandleEntityMessage (packet) {
		const minRole = Config.get("import", "minimumRole");
		if (game.user.role < minRole) return ui.notifications.warn(`You do not have the role required!`);

		const data = packet.data;
		const actor = this._getTargetActor();
		const pack = this._getTargetPack();

		const {ChooseImporter} = await Promise.resolve().then(function () { return ChooseImporter$1; });
		const importer = ChooseImporter.getImporter(data?.entity?.__prop || data.page, {actor, pack, isIgnoreMismatchedPack: true});
		if (!importer) return ui.notifications.error(`Plutonium does not yet support entities from "${data?.entity?.__prop || data.page}"! You may need to update your extension.`);
		try {
			await importer.pInit();
			const opts = {...(data.options || {})};
			if (data.isTemp) opts.isTemp = true;
			const importSummary = await importer.pImportEntry(data.entity, opts);
			UtilApplications.doShowImportedNotification(importSummary);
			if (opts.isTemp) await UtilImporter.pForceRenderImportedDocSheets(importSummary);
		} catch (e) {
			UtilApplications.doShowImportedNotification({entity: data, status: ConstsTaskRunner.TASK_EXIT_FAILED});
			setTimeout(() => { throw e; });
		}
	}

	static async _pHandleCurrencyMessage (packet) {
		const data = packet.data;
		const actor = this._getTargetActor();

		if (!actor) {
			await ChatMessage.create({
				content: `<div>Currency: ${Parser.getDisplayCurrency(data.currency)}</div>`,
				user: game.userId,
				type: CONST.CHAT_MESSAGE_TYPES.WHISPER,
				speaker: {alias: "Rivet"},
				whisper: game.users.contents.filter(it => it.isGM || it === game.user).map(it => it.id),
			});
			return;
		}

		try {
			await UtilActors.pAddCurrencyToActor({currency: data.currency, actor});
			ui.notifications.info(`Applied currency "${Parser.getDisplayCurrency(data.currency)}" to actor "${actor.name}"`);
		} catch (e) {
			ui.notifications.error(`Failed to apply currency "${Parser.getDisplayCurrency(data.currency)}" to actor "${actor.name}"`);
			setTimeout(() => { throw e; });
		}
	}

	static async _pHandleSpecialMessage_5etools_lootgen_loot (packet) {
		const {LootGeneratorApp} = await Promise.resolve().then(function () { return LootGeneratorApp$1; });

		const data = packet.data;
		const actor = this._getTargetActor();

		await LootGeneratorApp.pImportLoot({loot: data, actor, isLogToChat: true, isNotify: true});
	}

	static async _pHandleSpecialMessage_5etools_blocklist_excludes (packet) {
		await UtilWorldContentBlocklist.pSaveState(packet.data, {message: "Updated content blocklist!"});
	}

	
	static _getTargetActor () {
		const targetId = (Config.get("rivet", "targetDocumentId") || "").trim();
		if (!targetId) return null;

		if (targetId.startsWith("Compendium.")) return null;

		const mSceneToken = /^Scene\.(?<sceneId>[^.]+)\.Token\.(?<tokenId>[^.]+)$/.exec(targetId);
		if (mSceneToken) {
			const scene = game.scenes.get(mSceneToken.groups.sceneId);
			if (!scene) return null;

			const token = scene.tokens.get(mSceneToken.groups.tokenId);
			if (!token) return null;

			return token.actor;
		}

		const mActor = /^(Actor\.)?(?<actorId>[^.]+)$/.exec(targetId);
		if (!mActor) return null;

		return CONFIG.Actor.collection.instance.get(mActor.groups.actorId);
	}

	static _getTargetPack () {
		const targetId = (Config.get("rivet", "targetDocumentId") || "").trim();
		if (!targetId) return null;

		const mCompendium = /^Compendium\.(?<packageType>[^.]+)\.(?<packageName>[^.]+)$/.exec(targetId);
		if (!mCompendium) return null;

		return game.packs.get(`${mCompendium.groups.packageType}.${mCompendium.groups.packageName}`);
	}

	}

class Styler {
	static init () {
				this._handleConfigUpdate_handleGenericCssMod({
			condition: () => game.user.isGM,
			idStyle: Styler._ID_GM_ONLY,
			file: `css/optional-gm-only.css`,
		});

		this._handleConfigUpdate_handleGenericCssMod({
			condition: () => !game.user.isGM,
			idStyle: Styler._ID_PLAYER_ONLY,
			file: `css/optional-player-only.css`,
		});
		
		UtilHooks.on(UtilHooks.HK_CONFIG_UPDATE, () => this._handleConfigUpdate());
		this._handleConfigUpdate();

		Hooks.on("canvasReady", () => this._handleNameTabFromScene());
		Hooks.on("updateScene", () => this._handleNameTabFromScene());
				Hooks.on("deleteScene", () => setTimeout(() => this._handleNameTabFromScene(), 500));
	}

	static _handleConfigUpdate () {
		this._handleConfigUpdate_compactDirectories();
		this._handleConfigUpdate_compactDirectoryButtons();
		this._handleConfigUpdate_hidePlutoniumDirectoryButtons();
		this._handleConfigUpdate_showPopoutButton();
		this._handleConfigUpdate_compactSheetControls();
		this._handleConfigUpdate_compactChat();
		this._handleConfigUpdate_sheetLevelUpButton();
		this._handleConfigUpdate_wrapDirectories();
		this._handleConfigUpdate_fastTooltips();
		this._handleConfigUpdate_compatibilityPermissionViewer();
		this._handleConfigUpdate_compatibilityTwilightUi();
		this._handleConfigUpdate_compatibilityTidy5eSheet();
		this._handleBackendCheck();
		this._handleRivetCheck();
		this._handleNameTabFromScene();
	}

		static _handleConfigUpdate_handleGenericCssMod (opts) {
		if (!opts.css && !opts.file) throw new Error(`One of "css" or "file" must be specified!`);
		if (!(opts.configGroup && opts.configGroupKey) && !opts.condition) throw new Error(`One of "configGroup/Key" or "condition" must be specified!`);

		const $style = $(`#${opts.idStyle}`);

		const isActive = opts.condition && (opts.configGroup && opts.configGroupKey)
			? opts.condition(Config.get(opts.configGroup, opts.configGroupKey))
			: opts.condition
				? opts.condition()
				: Config.get(opts.configGroup, opts.configGroupKey);
		if (!isActive) return $style.remove();

		if ($style.length) return;

		if (opts.css) {
			$(`<style id="${opts.idStyle}">
				${opts.css}
			</style>`).appendTo(document.body);
		} else {
			$(`<link id="${opts.idStyle}" href="${SharedConsts.MODULE_LOCATION}/${opts.file}" rel="stylesheet" type="text/css" media="all">`).appendTo(document.head);
		}
	}

	static _handleConfigUpdate_compactDirectories () {
		this._handleConfigUpdate_handleGenericCssMod({
			configGroup: "ui",
			configGroupKey: "isCompactScenes",
			idStyle: Styler._ID_COMPACT_SCENES,
			file: `css/optional-compact-scenes.css`,
		});

		this._handleConfigUpdate_handleGenericCssMod({
			configGroup: "ui",
			configGroupKey: "isCompactActors",
			idStyle: Styler._ID_COMPACT_ACTORS,
			file: `css/optional-compact-actors.css`,
		});

		this._handleConfigUpdate_handleGenericCssMod({
			configGroup: "ui",
			configGroupKey: "isCompactItems",
			idStyle: Styler._ID_COMPACT_ITEMS,
			file: `css/optional-compact-items.css`,
		});

		this._handleConfigUpdate_handleGenericCssMod({
			configGroup: "ui",
			configGroupKey: "isCompactJournal",
			idStyle: Styler._ID_COMPACT_JOURNAL,
			file: `css/optional-compact-journal.css`,
		});

		this._handleConfigUpdate_handleGenericCssMod({
			configGroup: "ui",
			configGroupKey: "isCompactTables",
			idStyle: Styler._ID_COMPACT_TABLES,
			file: `css/optional-compact-tables.css`,
		});

		this._handleConfigUpdate_handleGenericCssMod({
			configGroup: "ui",
			configGroupKey: "isCompactCards",
			idStyle: Styler._ID_COMPACT_CARDS,
			file: `css/optional-compact-cards.css`,
		});

		this._handleConfigUpdate_handleGenericCssMod({
			configGroup: "ui",
			configGroupKey: "isCompactCompendiums",
			idStyle: Styler._ID_COMPACT_COMPENDIUMS,
			file: `css/optional-compact-compendiums.css`,
		});

		this._handleConfigUpdate_handleGenericCssMod({
			configGroup: "ui",
			configGroupKey: "isCompactMacros",
			idStyle: Styler._ID_COMPACT_MACROS,
			file: `css/optional-compact-macros.css`,
		});
	}

	static _handleConfigUpdate_compactDirectoryButtons () {
		this._handleConfigUpdate_handleGenericCssMod({
			configGroup: "ui",
			configGroupKey: "isCompactDirectoryButtons",
			idStyle: Styler._ID_COMPACT_DIRECTORY_BUTTONS,
			file: `css/optional-compact-directory-buttons.css`,
		});
	}

	static _handleConfigUpdate_hidePlutoniumDirectoryButtons () {
		this._handleConfigUpdate_handleGenericCssMod({
			configGroup: "ui",
			configGroupKey: "isHidePlutoniumDirectoryButtons",
			idStyle: Styler._ID_HIDE_PLUT_DIRECTORY_BUTTONS,
			file: `css/optional-hide-plut-directory-buttons.css`,
		});
	}

	static _handleConfigUpdate_showPopoutButton () {
		this._handleConfigUpdate_handleGenericCssMod({
			configGroup: "ui",
			configGroupKey: "isShowPopout",
			idStyle: Styler._ID_SHEET_POPOUT,
			file: `css/optional-sheet-popout.css`,
		});
	}

	static _handleConfigUpdate_compactSheetControls () {
		this._handleConfigUpdate_handleGenericCssMod({
			configGroup: "ui",
			configGroupKey: "isCompactWindowBar",
			idStyle: Styler._ID_SHEET_COMPACT_CONTROLS,
			file: `css/optional-sheet-compact-controls.css`,
		});
	}

	static _handleConfigUpdate_compactChat () {
		this._handleConfigUpdate_handleGenericCssMod({
			configGroup: "ui",
			configGroupKey: "isCompactChat",
			idStyle: Styler._ID_COMPACT_CHAT,
			file: `css/optional-compact-chat.css`,
		});
	}

	static _handleConfigUpdate_sheetLevelUpButton () {
		this._handleConfigUpdate_handleGenericCssMod({
			configGroup: "importClass",
			configGroupKey: "isAddLevelUpButton",
			idStyle: Styler._ID_SHEET_LEVEL_UP_BUTTON,
			file: `css/optional-sheet-level-up-button.css`,
		});
	}

	static _handleConfigUpdate_wrapDirectories () {
		this._handleConfigUpdate_handleGenericCssMod({
			configGroup: "ui",
			configGroupKey: "isEnableFolderNameWrap",
			idStyle: Styler._ID_WRAP_FOLDER_NAMES,
			file: `css/optional-wrap-folder-names.css`,
		});
	}

	static _handleConfigUpdate_fastTooltips () {
		this._handleConfigUpdate_handleGenericCssMod({
			configGroup: "ui",
			configGroupKey: "isFastTooltips",
			idStyle: Styler._ID_FAST_TOOLTIPS,
			file: `css/optional-fast-tooltips.css`,
		});
	}

	static _handleConfigUpdate_compatibilityPermissionViewer () {
		this._handleConfigUpdate_handleGenericCssMod({
			condition: () => {
				if (
					!UtilCompat.isPermissionViewerActive()
					|| (UtilCompat.isPermissionViewerActive() && UtilCompat.isSmolFoundryActive())
				) return false;

				const _UI_CONFIG_KEYS_COMPACT_DIRECTORY = [
					"isCompactScenes",
					"isCompactActors",
					"isCompactItems",
					"isCompactJournal",
					"isCompactTables",
					"isCompactCards",
					"isCompactCompendiums",
					"isCompactMacros",
				];
				return _UI_CONFIG_KEYS_COMPACT_DIRECTORY.some(it => Config.get("ui", it));
			},
			idStyle: Styler._ID_COMPATIBILITY_PERMISSION_VIEWER,
			file: `css/optional-compatibility-permission-viewer.css`,
		});
	}

	static _handleConfigUpdate_compatibilityTwilightUi () {
		this._handleConfigUpdate_handleGenericCssMod({
			condition: () => UtilCompat.isTwilightUiActive(),
			idStyle: Styler._ID_COMPATIBILITY_TWILIGHT_UI,
			file: `css/optional-compatibility-twilight-ui.css`,
		});
	}

	static _handleConfigUpdate_compatibilityTidy5eSheet () {
		this._handleConfigUpdate_handleGenericCssMod({
			condition: () => UtilCompat.isTidy5eSheetActive(),
			idStyle: Styler._ID_COMPATIBILITY_TIDY5E_SHEET,
			file: `css/optional-compatibility-tidy5e-sheet.css`,
		});
	}

	static _handleBackendCheck () {
		UtilBackend.pGetBackendVersionMeta()
			.then(async ({version, versionExpected, isBelowMin, isAboveMax, isInRange}) => {
				if (!version) return;

				await Styler._LOCK_GLITCH.pLock();
				try {
					const $styleLogoGlitch = $(`#${Styler._ID_LOGO_GLITCH}`);
					const $dispVersion = $(`#${Styler._ID_BACKEND_VERSION}`);

					const $imgLogo = $(`#logo`);

					if (!Config.get("ui", "isDisplayBackendStatus") || Config.get("ui", "isStreamerMode")) {
						$imgLogo.title("");
						$styleLogoGlitch.remove();
						$dispVersion.remove();
						return;
					}

					if (!$styleLogoGlitch.length) {
						const ptUpdateRequired = isBelowMin
							? `. An updated version (v${versionExpected}) is available!`
							: isAboveMax
								? `. This is above the maximum supported version (v${versionExpected})!`
								: "";
						const hueRotation = isInRange ? `100deg` : `310deg`;
						const saturation = isInRange ? `1.5` : `0.8`;

						$imgLogo.title(`Plutonium Backend Mod Active: v${version}${ptUpdateRequired}`);
						$(`<style id="${Styler._ID_LOGO_GLITCH}">
							#logo {
								filter: hue-rotate(${hueRotation}) saturate(${saturation});
							}
						</style>`).appendTo(document.body);
					}

					if (!$dispVersion.length) {
						$(`<div class="plutsrv__disp-version text-center" id="${Styler._ID_BACKEND_VERSION}" ${!isInRange ? `style="color: red;"` : ""}>${!isInRange ? "!" : ""}${version}${!isInRange ? "!" : ""}</div>`)
							.appendTo(document.getElementById("ui-left"));
					}
				} finally {
					Styler._LOCK_GLITCH.unlock();
				}
			});
	}

	static _handleRivetCheck () {
		if (!ExtensionUtil.ACTIVE) return;

		const $dispVersion = $(`#${Styler._ID_DISP_RIVET_DETECTED}`);

		if (!Config.get("rivet", "isDisplayStatus") || Config.get("ui", "isStreamerMode")) {
			$dispVersion.remove();
			return;
		}

		if (!$dispVersion.length) {
			$(`<div class="rivet__disp-active ve-flex-vh-center" id="${Styler._ID_DISP_RIVET_DETECTED}"><span class="glyphicon glyphicon-send"></span></div>`)
				.appendTo(document.getElementById("ui-left"));
		}
	}

	static _handleNameTabFromScene () {
		if (Styler._TAB_TITLE_DEFAULT == null) Styler._TAB_TITLE_DEFAULT = document.title;

		if (!Config.get("ui", "isNameTabFromScene")) {
			document.title = Styler._TAB_TITLE_DEFAULT;
			return;
		}

		const nameSuffix = Config.get("ui", "tabNameSuffix");
		const nameSuffixPart = nameSuffix && nameSuffix.trim() ? nameSuffix : "Foundry Virtual Tabletop";

		const sceneName = canvas.scene?.navName || canvas.scene?.name;
		document.title = sceneName ? `${sceneName} • ${nameSuffixPart}` : nameSuffixPart;
	}
}
Styler._ID_GM_ONLY = "plutonium__gm-only";
Styler._ID_PLAYER_ONLY = "plutonium__player-only";
Styler._ID_COMPACT_ACTORS = "plutonium__compact-actors";
Styler._ID_COMPACT_ITEMS = "plutonium__compact-items";
Styler._ID_COMPACT_JOURNAL = "plutonium__compact-journal";
Styler._ID_COMPACT_TABLES = "plutonium__compact-tables";
Styler._ID_COMPACT_CARDS = "plutonium__compact-cards";
Styler._ID_COMPACT_SCENES = "plutonium__compact-scenes";
Styler._ID_COMPACT_COMPENDIUMS = "plutonium__compact-compendiums";
Styler._ID_COMPACT_MACROS = "plutonium__compact-macros";
Styler._ID_COMPACT_CHAT = "plutonium__compact-chat";
Styler._ID_COMPACT_DIRECTORY_BUTTONS = "plutonium__compact-directory-buttons";
Styler._ID_HIDE_PLUT_DIRECTORY_BUTTONS = "plutonium__hide-plutonium-directory-buttons";
Styler._ID_HIDE_DIRECTORY_IMPORT_BUTTONS = "plutonium__hide-directory-import-buttons";
Styler._ID_SHEET_POPOUT = "plutonium__sheet-popout";
Styler._ID_SHEET_COMPACT_CONTROLS = "plutonium__sheet-compact-controls";
Styler._ID_SHEET_COMPACT_POPOUT = "plutonium__sheet-compact-popout";
Styler._LOCK_GLITCH = new VeLock();
Styler._ID_LOGO_GLITCH = "plutonium__logo-glitch";
Styler._ID_BACKEND_VERSION = "plutonium__backend-version";
Styler._ID_SHEET_LEVEL_UP_BUTTON = "plutonium__sheet-level-up-button";
Styler._ID_WRAP_FOLDER_NAMES = "plutonium__wrap-folder-names";
Styler._ID_FAST_TOOLTIPS = "plutonium__fast-tooltips";
Styler._ID_DISP_RIVET_DETECTED = "plutonium__disp-rivet-detected";
Styler._ID_COMPATIBILITY_PERMISSION_VIEWER = "plutonium__compatibility-permission-viewer";
Styler._ID_COMPATIBILITY_TWILIGHT_UI = "plutonium__compatibility-twilight-ui";
Styler._ID_COMPATIBILITY_TIDY5E_SHEET = "plutonium__compatibility-tidy5e-sheet";

Styler._TAB_TITLE_DEFAULT = null;

class ActorMultiattack {
	static init () {
		Hooks.on("createChatMessage", (chatMessage, renderOpts, actorId) => {
			this._pHandleCreateChatMessage(chatMessage, renderOpts, actorId);
		});
	}

		static async _pHandleCreateChatMessage (chatMessage, renderOpts, userId) {
				if (!Config.get("actor", "isAutoMultiattack")) return;
		if (userId !== game.userId) return;

		const actorId = chatMessage?.speaker?.actor;
		if (!actorId) return;

		const actor = CONFIG.Actor.collection.instance.get(actorId);
		if (!actor) return;

				const itemId = $(`<div>${chatMessage.content || ""}</div>`).children().first().attr("data-item-id");
		if (!itemId) return;

		const item = actor.items.get(itemId);
		if (!item) return; 
		const cleanLowerName = Util.getWithoutParens(item.name).toLowerCase();
		if (cleanLowerName !== "multiattack") return;

		const description = $(item.system.description.value).text().trim();
		if (!description) return;
		
		const toRuns = this._getToRuns({actor, description});
		const tDelay = this._getDelayBetweenAttacks();
		await this._pRunActions({toRuns, tDelay});
	}

	static _getDelayBetweenAttacks () {
		const tDelay = Config.get("actor", "autoMultiattackDelay");
		if (tDelay == null || isNaN(tDelay) || tDelay <= 0) return null;
		return tDelay;
	}

	static async _pRunActions ({toRuns, tDelay}) {
		if (UtilCompat.isMidiQolActive()) return this._pRunActions_pMidiQol({toRuns, tDelay});
		return this._pRunActions_pDefault({toRuns, tDelay});
	}

	static async _pRunActions_pDefault ({toRuns, tDelay}) {
		for (const toRun of toRuns) {
			for (let i = 0; i < toRun.count; ++i) {
				await toRun.item.roll(); 				await MiscUtil.pDelay(tDelay);
			}
		}
	}

	static async _pRunActions_pMidiQol ({toRuns, tDelay}) {
		const getPromiseMidiRoll = (item) => {
			return new Promise(resolve => {
				Hooks.once(`midi-qol.RollComplete.Actor.${item.actor.id}.Item.${item.id}`, () => resolve());
				item.roll().then(null);
			});
		};

		for (const toRun of toRuns) {
			for (let i = 0; i < toRun.count; ++i) {
				await getPromiseMidiRoll(toRun.item);
				await MiscUtil.pDelay(tDelay);
			}
		}
	}

	static _getToRuns ({actor, description}) {
		let sentences = Util.getSentences(description);
		const toRuns = [];
		let sentencesProc = this._pHandleCreateChatMessage_mutExtractNamedActions(actor, sentences, toRuns);
		sentencesProc = sentencesProc.flat();
		this._pHandleCreateChatMessage_mutExtractSimpleAttacks(actor, sentencesProc, toRuns);
		return toRuns;
	}

		static _pHandleCreateChatMessage_mutExtractNamedActions (actor, sentences, outStack) {
		sentences = MiscUtil.copy(sentences);

		for (let i = 0; i < sentences.length; ++i) {
			const sentence = sentences[i];

			const tokens = Util.getTokens(sentence);

						while ((Util.isPunctuation(tokens[0]) || Util.isCapsFirst(tokens[0])) && tokens.length) tokens.shift();

						const actionNameMetas = [];
			let tokenStack = [];
			let curMeta = {};

			const collectStack = () => {
				if (!tokenStack.filter(it => it !== " ").length) return;

								while (tokenStack.length) {
					if (StrUtil.TITLE_LOWER_WORDS.includes(tokenStack.last()) || tokenStack.last() === " ") {
						tokenStack.pop();
					} else {
						break;
					}
				}

				actionNameMetas.push({
					name: tokenStack.join(""),
					count: curMeta.count || 1,
				});

				tokenStack = [];
				curMeta = {};
			};

			for (let i = 0; i < tokens.length; ++i) {
				const token = tokens[i];

								if (!tokenStack.length && token === " ") continue;

				if (Util.isCapsFirst(token)) {
					tokenStack.push(token);
				} else if (tokenStack.length && (StrUtil.TITLE_LOWER_WORDS.includes(token) || token === " ")) {
					tokenStack.push(token);
				} else {
					const countAdverbs = Consts.TERMS_COUNT.find(meta => {
						const slice = tokens.slice(i, i + meta.tokens.length);
						return CollectionUtil.deepEquals(meta.tokens, slice);
					});

					if (tokenStack.length && countAdverbs) {
						i += countAdverbs.tokens.length - 1;
						curMeta.count = countAdverbs.count;
					}

					collectStack();
				}
			}
			collectStack();

			let sentenceOut = sentence;
			actionNameMetas.forEach(meta => {
				const cleanActionName = meta.name.toLowerCase().trim();
				if (cleanActionName.includes("multiattack")) return; 
				const item = actor.items.find(it => Util.getWithoutParens(it.name).toLowerCase() === cleanActionName);
				if (!item) return;

				outStack.push({
					item,
					count: meta.count || 1,
				});

																sentenceOut = sentenceOut.replace(meta.name, ActorMultiattack._MARKER_SPLIT);
			});

						sentences[i] = sentenceOut.split(ActorMultiattack._MARKER_SPLIT);
		}

		return sentences;
	}

		static _pHandleCreateChatMessage_mutExtractSimpleAttacks (actor, sentences, outStack) {
		sentences.forEach(sentence => {
						sentence = sentence.replace(/one (.*?) attack(?:[^:]|$)/gi, (...m) => this._doNamedActionReplace({outStack, actor, m}));

			sentence = sentence.replace(/(two|three|four|five|six|seven|eight) (.*?) attacks(?:[^:]|$)/gi, (...m) => this._doNamedActionReplace({outStack, actor, m}));
			
						sentence = sentence.replace(/makes (one|two|three|four|five|six|seven|eight) attacks? with its (.*?(?: or .*?)?)$/gi, (...m) => this._doWeaponChoiceReplace({outStack, actor, m}));

						sentence = sentence.replace(/makes (?:two|three|four|five|six|seven|eight)(?: melee| ranged)? attacks:(.*?)$/gi, (...m) => this._doComplexActionReplace({outStack, actor, m}));

						sentence = sentence.replace(/makes (two|three|four|five|six|seven|eight) attacks$/gi, (...m) => this._doAnyChoiceReplace({outStack, actor, m}));
		});
	}

	static _doNamedActionReplace ({outStack, actor, m}) {
		const rawActionCount = m[1].toLowerCase();
		const actionCount = Parser.textToNumber(rawActionCount);

		const actionNameClean = Util.getWithoutParens(m[2]).toLowerCase();
		if (actionNameClean.includes("multiattack")) return ""; 
		if (actionNameClean === "melee" || actionNameClean === "ranged") {
			this._pHandleCreateChatMessage_handleMeleeRangedAttacks(actor, actionNameClean, actionCount, outStack);
			return "";
		}

		const item = actor.items.find(it => Util.getWithoutParens(it.name).toLowerCase() === actionNameClean);

		if (!item) return m[0];

		outStack.push({
			item,
			count: actionCount,
		});

		return "";
	}

	static _doWeaponChoiceReplace ({outStack, actor, m}) {
		const rawActionCount = m[1];
		let ptAttacks = m[2];

		const allActionTokens = Util.getTokens(ptAttacks);

		while (allActionTokens.length) {
			const thisActionTokens = [];

			for (let i = 0; i < allActionTokens.length; ++i) {
				const cleanActionToken = allActionTokens[i].toLowerCase();

				if (
					cleanActionToken === "and" || cleanActionToken === "or" || cleanActionToken === "its" || cleanActionToken === "with"
					|| Util.isPunctuation(cleanActionToken)
				) {
					allActionTokens.shift(); 					break;
				} else {
					thisActionTokens.push(allActionTokens.shift());
					i--;
				}
			}

			if (thisActionTokens.length) {
				const thisActionName = thisActionTokens.join("").trim();
				if (thisActionName.toLowerCase().includes("multiattack")) continue; 
				const item = this._getActionByLowerName(actor, thisActionName);

				if (item) {
					outStack.push({
						item,
						count: Parser.textToNumber(rawActionCount),
					});
				}
			}
		}

		return allActionTokens.join("").trim();
	}

	static _doAnyChoiceReplace ({outStack, actor, m}) {
		const rawActionCount = m[1];
		const actionCount = Parser.textToNumber(rawActionCount);

		const attackItems = actor.items.filter(it => it.type === "weapon" && !it.name.toLowerCase().includes("multiattack"));

						attackItems.forEach(item => {
			outStack.push({
				item,
				count: actionCount,
			});
		});

		return "";
	}

	static _doComplexActionReplace ({outStack, actor, m}) {
		let ptAttacks = m[1];
		let foundAny = false;
		let lastPtAttacks = null;

		while (ptAttacks.length && ptAttacks !== lastPtAttacks) {
			lastPtAttacks = ptAttacks;

			ptAttacks = ptAttacks.replace(/(one|two|three|four|five|six|seven|eight) with (?:its |his |her )(.*)/gi, (...n) => {
				const rawActionCount = n[1];
				const rawActionPart = n[2];

				const thisActionTokens = [];
				const allActionTokens = Util.getTokens(rawActionPart);

				for (let i = 0; i < allActionTokens.length; ++i) {
					const cleanActionToken = allActionTokens[i].toLowerCase();

					if (cleanActionToken === "and" || cleanActionToken === "or" || Util.isPunctuation(cleanActionToken)) {
						allActionTokens.shift(); 						break;
					} else {
						thisActionTokens.push(allActionTokens.shift());
						i--;
					}
				}

				if (thisActionTokens.length) {
					const thisActionName = thisActionTokens.join("").trim();
					if (thisActionName.toLowerCase().includes("multiattack")) return allActionTokens.join("").trim(); 
					const item = this._getActionByLowerName(actor, thisActionName);

					if (item) {
						outStack.push({
							item,
							count: Parser.textToNumber(rawActionCount),
						});
					}
				}

				return allActionTokens.join("").trim();
			});
		}

		if (foundAny) return "";
		return m[0];
	}

		static _pHandleCreateChatMessage_handleMeleeRangedAttacks (actor, actionNameClean, actionCount, outStack) {
		let item;

		const meleeItems = [];
		const rangedItems = [];

		actor.items
			.filter(it => it.type === "weapon")
			.forEach(it => {
				const sys = MiscUtil.get(it, "system");
				if (!sys) return;

								const weaponType = MiscUtil.get(sys, "weaponType");
				switch (weaponType) {
					case "simpleM":
					case "martialM": {
						meleeItems.push(it);
						if (MiscUtil.get(sys, "properties", "thr")) rangedItems.push(it);
						return;
					}

					case "simpleR":
					case "martialR": {
						rangedItems.push(it);
						return;
					}
				}

								const actionType = MiscUtil.get(sys, "actionType");
				switch (actionType) {
					case "mwak": {
						meleeItems.push(it);
						if (MiscUtil.get(sys, "properties", "thr")) rangedItems.push(it);
						return;
					}
					case "rwak": {
						rangedItems.push(it);
						return;
					}
				}

								const cleanText = (MiscUtil.get(sys, "description", "value") || "")
					.replace(/[^a-zA-Z0-9:.,()]/g, "")
					.replace(/\s+/g, " ")
					.trim();
				if (/melee or ranged weapon attack:/i.test(cleanText)) {
					meleeItems.push(it);
					rangedItems.push(it);
				} else if (/melee weapon attack:/i.test(cleanText)) {
					meleeItems.push(it);
				} else if (/ranged weapon attack:/i.test(cleanText)) {
					rangedItems.push(it);
				}
			});

		const items = actionNameClean === "melee" ? meleeItems : rangedItems;

		item = items
			.map(item => {
				const damageParts = MiscUtil.get(item, "system", "damage", "parts");
				if (!damageParts) return null;

								const mappedParts = damageParts
					.map(pt => {
						try {
							const cleanPart = pt[0].replace(/@mod/gi, () => {
								const abilityScores = Charactermancer_Util.getCurrentAbilityScores(actor);
								const atr = MiscUtil.get(item, "system", "ability")
									|| Charactermancer_Util.getAttackAbilityScore(item, abilityScores, actionNameClean === "melee" ? "melee" : "ranged");
								const score = abilityScores?.[atr] || 10;
								return Parser.getAbilityModNumber(score);
							});

							const wrpTree = Renderer.dice.lang.getTree3(`avg(${cleanPart})`);
							return {
								type: pt[1],
								meanDamage: wrpTree.tree.evl({}),
							};
						} catch (e) {
							console.error(...LGT, `Failed to evaluate damage part "${pt[0]}"`, e);
							return null;
						}
					})
					.filter(Boolean);

				if (!mappedParts.length) return null;

																const typeToMeanDamage = {};
				mappedParts.forEach(it => typeToMeanDamage[it.type] = Math.max(it.meanDamage, typeToMeanDamage[it.type] || 0));

												const meanDamage = Object.values(typeToMeanDamage).reduce((a, b) => a + b, 0);

				return {
					item: item,
					meanDamage,
				};
			})
			.filter(Boolean)
			.sort((a, b) => SortUtil.ascSort(b.meanDamage, a.meanDamage))
			.map(it => it.item)
			.find(Boolean);

				if (!item && items[0]) item = items[0];
		else if (!item && !items[0]) return;

		outStack.push({
			item,
			count: actionCount,
		});
	}

	static _getActionByLowerName (actor, actionName) {
		let item = actor.items.find(it => Util.getWithoutParens(it.name).toLowerCase() === actionName);

				if (!item && actionName.endsWith("s")) {
			const thisActionNameSingular = actionName.slice(0, -1);
			item = actor.items.find(it => Util.getWithoutParens(it.name).toLowerCase() === thisActionNameSingular);
		}

		return item;
	}
}
ActorMultiattack._MARKER_SPLIT = "<PLUT_SPLIT_MARKER>";

class _Patcher_TokenUserInterface {
	static doUpdateDisplay (token) {
		try {
			this._doUpdateDisplay(token);
		} catch (e) {
						console.warn(...LGT, `Failed to update "damage dealt" display for token "${token.id}"!`, e);
		}
	}

	static _doUpdateDisplay (token) {
		this._doUpdateDisplay_textStyle(token);
		this._doUpdateDisplay_nameplatePosition(token);
	}

	static _doUpdateDisplay_textStyle (token) {
		const styles = token._getTextStyle();

		const fontSizeMult = Config.get("tokens", "nameplateFontSizeMultiplier");
		if (fontSizeMult != null) {
			if (styles.fontSize != null) styles.fontSize *= fontSizeMult;
		}

		const isAllowWrap = Config.get("tokens", "isAllowNameplateFontWrap");
		if (isAllowWrap !== ConfigConsts.C_USE_GAME_DEFAULT) {
			styles.wordWrap = !!isAllowWrap;
		}

		const fontWrapWidthMult = Config.get("tokens", "nameplateFontWrapWidthMultiplier");
		if (fontWrapWidthMult != null) {
			if (styles.wordWrapWidth != null) styles.wordWrapWidth *= fontWrapWidthMult;
		}

		for (const preciseText of [token.nameplate, token.tooltip]) {
			preciseText.style.fontSize = styles.fontSize;
			preciseText.style.wordWrap = styles.wordWrap;
			preciseText.style.wordWrapWidth = styles.wordWrapWidth;
		}
	}

	static _doUpdateDisplay_nameplatePosition (token) {
		if (!Config.get("tokens", "isNameplateOnToken")) {
						if (!token._plut_isAdjustedNameplatePosition) return;

			
						token.nameplate.anchor.set(0.5, 0);
			token.nameplate.position.set(token.w / 2, token.h + 2);
			
			delete token._plut_isAdjustedNameplatePosition;

			return;
		}

		token._plut_isAdjustedNameplatePosition = true;

		let heightBar = 0;
		let isBarVisible = false;

				const attr = token.document.getBarAttribute("bar1");
		if (attr?.type === "bar") isBarVisible = true;
		
		if (isBarVisible) {
						heightBar = Math.max((canvas.dimensions.size / 12), 8);
			if (token.document.height >= 2) heightBar *= 1.6; 					}

				token.nameplate.anchor.set(0.5, 1.0);
		token.nameplate.position.set(
			token.w / 2,
			(token.h + 2) - Math.round(heightBar),
		);
			}
}

class _Patcher_TokenMissingHealth {
	static _isForceDisabled (token) {
		if (
			UtilCompat.isMonksLittleDetailsActive()
			&& UtilGameSettings.getSafe(UtilCompat.MODULE_MONKS_BLOODSPLATS, "show-bloodsplat")
			&& UtilCompat.MonksLittleDetails.isDefeated(token)
		) return true;
		return false;
	}

	static handleConfigChange ({tokens}) {
		this._handleConfigChange_cleanup({tokens});
	}

	static _handleConfigChange_cleanup ({tokens}) {
		if (Config.get("tokens", "isDisplayDamageDealt")) return;

		for (const token of tokens) {
			try {
				this._doRemove(token);
			} catch (e) {
							}
		}
	}

	static _doRemove (token) {
		if (!token?.plut_dispDamageDealt) return;
		this._doDestroyText(token.removeChild(token?.plut_dispDamageDealt));
		delete token.plut_dispDamageDealt;
	}

	static doUpdateDisplay (token) {
		try {
			this._doUpdateDisplay(token);
		} catch (e) {
						console.warn(...LGT, `Failed to update "damage dealt" display for token "${token.id}"!`, e);
		}
	}

	static _doUpdateDisplay (token) {
		if (this._isForceDisabled(token)) {
			this._doRemove(token);
			return;
		}

		if (!Config.get("tokens", "isDisplayDamageDealt")) return;

		this._onDrawRefreshToken_doAddDisplay(token);

		const maxHp = foundry.utils.getProperty(token.actor, `system.${Config.get("tokens", "missingHealthAttribute")}.max`) || 0;
		const curHp = foundry.utils.getProperty(token.actor, `system.${Config.get("tokens", "missingHealthAttribute")}.value`) || 0;

		const damageDealt = Math.min(maxHp, Math.max(0, maxHp - curHp));
		token.plut_dispDamageDealt.text = `-${damageDealt}`;

		token.plut_dispDamageDealt.visible = !!damageDealt;

		const fontSizeMult = Config.get("tokens", "nameplateFontSizeMultiplier");

								if (Config.get("tokens", "isDamageDealtBelowToken")) {
			token.plut_dispDamageDealt.style.fontSize = 18 * (fontSizeMult ?? 1);

			token.plut_dispDamageDealt.anchor.set(0.5, 0);

			token.plut_dispDamageDealt.position.set(Math.round(token.w / 2), token.h + 1);
		} else {
			token.plut_dispDamageDealt.style.fontSize = 24 * (fontSizeMult ?? 1);

						token.plut_dispDamageDealt.anchor.set(1, 1);

						const barHeight = Math.max((canvas.dimensions.size / 12), 8) * (token.document.height >= 2 ? 1.6 : 1);

						token.plut_dispDamageDealt.position.set(token.w - 3, token.h - barHeight);
		}

		if (curHp <= Math.floor(maxHp * Config.get("tokens", "damageDealtBloodiedThreshold"))) token.plut_dispDamageDealt.style.fill = 0xFF0000;
		else token.plut_dispDamageDealt.style.fill = 0xFFFFFF;
	}

	static _onDrawRefreshToken_doAddDisplay (token) {
		if (
			token?.plut_dispDamageDealt
			&& token?.plut_dispDamageDealt.parent 		) return;

				if (token?.plut_dispDamageDealt && !token?.plut_dispDamageDealt?.parent) {
			token.removeChild(token?.plut_dispDamageDealt);
			this._doDestroyText(token?.plut_dispDamageDealt);
			token.plut_dispDamageDealt = null;
		}

						token.plut_dispDamageDealt = new PreciseText("", CONFIG.canvasTextStyle.clone());

		token.addChild(token?.plut_dispDamageDealt);
	}

	static _doDestroyText (text) {
		if (!text?.texture) return;
		text.destroy();
	}
}

class Patcher_Token {
	static init () {
		Hooks.on("drawToken", (token) => {
			if (!Config.get("tokens", "isDisplayDamageDealt")) return;
			Patcher_Token._onDrawRefreshToken(token);
		});

		Hooks.on("refreshToken", (token) => {
			if (!Config.get("tokens", "isDisplayDamageDealt")) return;
			Patcher_Token._onDrawRefreshToken(token);
		});
	}

	static handleConfigUpdate ({isInit = false, current, previous} = {}) {
		const tokens = MiscUtil.get(canvas, "tokens", "placeables") || [];

		_Patcher_TokenMissingHealth.handleConfigChange({isInit, tokens});

				if (!this._handleConfigUpdate_isDoOnDrawRefresh({isInit, current, previous})) return;

		tokens.forEach(token => Patcher_Token._onDrawRefreshToken(token));
	}

	static _handleConfigUpdate_isDoOnDrawRefresh ({isInit, current, previous}) {
		if (isInit) return true;
		if (!current || !previous) return false;

		const diffProps = [
			"isDisplayDamageDealt",
			"damageDealtBloodiedThreshold",
			"isDamageDealtBelowToken",
			"missingHealthAttribute",

			"nameplateFontSizeMultiplier",
			"isAllowNameplateFontWrap",
			"nameplateFontWrapWidthMultiplier",

			"isNameplateOnToken",
		];
		return diffProps.some(prop => MiscUtil.get(current, "tokens", prop) !== MiscUtil.get(previous, "tokens", prop));
	}

	static _onDrawRefreshToken (token) {
		_Patcher_TokenMissingHealth.doUpdateDisplay(token);
		_Patcher_TokenUserInterface.doUpdateDisplay(token);
	}
}

class Patcher_TextEditor {
	static prePreInit () {
				this._prePreInit_contentLinks();
		this._prePreInit_createContentLink();
		this._prePreInit_enrichers();
	}

	static _prePreInit_contentLinks () {
		try {
			this._prePreInit_contentLinks_();
		} catch (e) {
			Config.handleFailedInitConfigApplication("text", "isAutoRollActorItemTags");
			Config.handleFailedInitConfigApplication("text", "isJumpToFolderTags", e);
		}
	}

	static _prePreInit_contentLinks_ () {
		UtilLibWrapper.addPatch(
			"TextEditor._onClickContentLink",
			this._lw_TextEditor__onClickContentLink,
			UtilLibWrapper.LIBWRAPPER_MODE_MIXED,
		);
	}

	static _lw_TextEditor__onClickContentLink (fn, ...args) {
		const [evt, ...rest] = args;

		evt.preventDefault();

		if (!evt.currentTarget.dataset.uuid) return fn(...args);

				if (UtilDragDrop.isCustomUuid(evt.currentTarget.dataset.uuid)) return;

				const doc = Patcher_TextEditor._fromUuidSyncSafe(evt);
		if (!doc) return fn(evt, ...rest);

		if (doc instanceof Folder) {
			if (Patcher_TextEditor._handleContentLinkClick_folder(evt, doc)) return;
			return fn(evt, ...rest);
		}

		if (doc instanceof Item && doc.parent && doc.parent instanceof Actor) {
			if (Patcher_TextEditor._handleContentLinkClick_withParentActor(evt, doc)) return;
			return fn(evt, ...rest);
		}

		return fn(evt, ...rest);
	}

	static _fromUuidSyncSafe (evt) {
		try {
			return fromUuidSync(evt.currentTarget.dataset.uuid);
		} catch (e) {
			return null;
		}
	}

	static _handleContentLinkClick_folder (evt, doc) {
		if (!Config.get("text", "isJumpToFolderTags")) return false;

		if (evt?.shiftKey) return false;

		if (doc.ownership < CONST.DOCUMENT_OWNERSHIP_LEVELS.OBSERVER) {
			ui.notifications.warn(`You do not have sufficient ownership to view this Folder.`);
			return true;
		}

		const sidebarTabName = CONFIG[doc.type]?.documentClass?.metadata?.collection;
		if (!sidebarTabName) return false;

		(async () => {
			await ui.sidebar.activateTab(sidebarTabName);

			const sidebarTab = ui.sidebar.tabs[sidebarTabName];
			const $eleFolder = sidebarTab.element.find(`[data-folder-id="${doc.id}"]`);

			if (!doc.expanded) {
								game.folders._expanded[doc.id] = true;

				$eleFolder.removeClass("collapsed");

								if (sidebarTab.popOut) sidebarTab.setPosition();
							}

			$eleFolder[0].scrollIntoView({block: "center"});

						$eleFolder.addClass("jlnk__folder-pulse-1s");
			setTimeout(() => $eleFolder.removeClass("jlnk__folder-pulse-1s"), 1000);
		})()
			.then(null);

		return true;
	}

	static _handleContentLinkClick_withParentActor (evt, doc) {
		if (!Config.get("text", "isAutoRollActorItemTags")) return false;

		if (evt?.shiftKey) return false;

		if (doc.parent.ownership < CONST.DOCUMENT_OWNERSHIP_LEVELS.OBSERVER) {
			ui.notifications.warn(`You do not have sufficient ownership to view this ${doc.parent.documentName}.`);
			return true;
		}

		if (doc.ownership < CONST.DOCUMENT_OWNERSHIP_LEVELS.OBSERVER) {
			ui.notifications.warn(`You do not have sufficient ownership to view this ${doc.documentName}.`);
			return true;
		}

		doc.use();

		return true;
	}

	static _prePreInit_createContentLink () {
		try {
			this._prePreInit_createContentLink_();
		} catch (e) {
			console.error(...LGT, e);
		}
	}

	static _prePreInit_createContentLink_ () {
		UtilLibWrapper.addPatch(
			"TextEditor._createContentLink",
			this._lw_TextEditor__createContentLink,
			UtilLibWrapper.LIBWRAPPER_MODE_WRAPPER,
		);
	}

		static _lw_TextEditor__createContentLink (fn, ...args) {
		const link = fn(...args);
		if (!Config.get("text", "isShowLinkParent")) return link;

		const [, {relativeTo} = {}] = args;

		if (link instanceof Promise) {
			return link
				.then(async link => {
					const uuid = Patcher_TextEditor.ParentChildEntity.getValidUuid(link);
					if (!uuid) return link;
					const doc = await fromUuid(uuid, relativeTo);
					Patcher_TextEditor.ParentChildEntity.mutLink(link, doc);
					return link;
				});
		}

		const uuid = Patcher_TextEditor.ParentChildEntity.getValidUuid(link);
		if (!uuid) return link;

				let doc;
		try {
			doc = fromUuidSync(uuid, relativeTo);
		} catch (e) {
			return link;
		}

		Patcher_TextEditor.ParentChildEntity.mutLink(link, doc);
		return link;
	}

		static _SYNC_ENRICHERS = [];

	static _prePreInit_enrichers () {
		CONFIG.TextEditor.enrichers.push(
			Patcher_TextEditor.JournalEmbed.getEnricher(),
			Patcher_TextEditor.ContentLoader.getEnricher(),
		);

				this._SYNC_ENRICHERS = [
			Patcher_TextEditor.ContentLoader.getEnricher(),
		];

		UtilEvents.registerDocumentHandler({
			eventType: "click",
			selector: `.jemb__btn-toggle`,
			fnEvent: Patcher_TextEditor.JournalEmbed.handleToggleClick.bind(Patcher_TextEditor.JournalEmbed),
		});

		UtilEvents.registerDocumentHandler({
			eventType: "click",
			selector: `.jlnk__entity-link`,
			fnEvent: Patcher_TextEditor.ContentLoader.handleClick.bind(Patcher_TextEditor.JournalEmbed),
		});

		Patcher_TextEditor.ContentDragDrop.init();

				UtilLibWrapper.addPatch(
			"TextEditor.enrichHTML",
			this._lw_TextEditor_enrichHTML,
			UtilLibWrapper.LIBWRAPPER_MODE_WRAPPER,
		);
			}

	static _lw_TextEditor_enrichHTML (fn, ...args) {
		const [, options] = args;

						let out = fn(...args);
		if (options?.async) return out;

		if (!out?.length) return out;

						const html = document.createElement("div");
		html.innerHTML = String(out || "");

		let updateTextArray = true;
		let text = [];
		const fns = [];

		for (const config of Patcher_TextEditor._SYNC_ENRICHERS) {
			fns.push(this._applyCustomEnrichers.bind(this, config.pattern, config.enricher));
		}

		const enrich = (fn, update) => {
			if (update) text = this._getTextNodes(html);
			return fn(text, options);
		};

		for (const fn of fns) {
			updateTextArray = enrich(fn, updateTextArray);
		}

		return html.innerHTML;
			}
}

Patcher_TextEditor.Enricher = class {
		static get _RE () { throw new Error("Unimplemented!"); }

		static _enrich (match, opts) { throw new Error("Unimplemented!"); }

	static _getEntityPermissions (entity) {
		if (game.user.isGM) return CONST.DOCUMENT_OWNERSHIP_LEVELS.OWNER;
		return entity.permission;
	}

	static _getEntity (collection, entityNameOrId) {
				let entity = null;
		if (Consts.RE_ID.test(entityNameOrId)) entity = collection.get(entityNameOrId);
		if (!entity) entity = (collection.contents || collection.entries).find(e => e.name === entityNameOrId);
		return entity;
	}

	static getEnricher () {
		return {
			pattern: this._RE,
			enricher: this._enrich.bind(this),
		};
	}
};

Patcher_TextEditor.JournalEmbed = class extends Patcher_TextEditor.Enricher {
			static get _RE () { return /@Embed(UUID)\[([^#\]]+)(?:#([^\]]+))?](?:{([^}]+)})?/g; }

	static async _enrich (match, enrichOpts, ...args) {
		const [originalText, , target] = match;

		const doc = await fromUuid(target, enrichOpts?.relativeTo);
		if (doc?.documentName !== "JournalEntryPage" || !doc?.parent) return originalText;

		const lnkPage = await TextEditor._createContentLink(match, enrichOpts);

		if (
			this._getEntityPermissions(doc) < CONST.DOCUMENT_OWNERSHIP_LEVELS.OBSERVER
			|| this._getEntityPermissions(doc).parent < CONST.DOCUMENT_OWNERSHIP_LEVELS.OBSERVER
		) return lnkPage;

		const isAutoExpand = Config.get("journalEntries", "isAutoExpandJournalEmbeds");
		switch (doc.type) {
			case "text": {
								const isTooDeep = enrichOpts.depth === Patcher_TextEditor.JournalEmbed._MAX_RECURSION_DEPTH;
				const subContent = isTooDeep
					? doc.text.content
					: await TextEditor.enrichHTML(doc.text.content, {...enrichOpts, depth: enrichOpts.depth + 1});

				return e_({
					outer: `<div class="w-100 ve-flex-col">
						<div class="ve-flex-v-center mb-1 jemb__wrp-lnk">${lnkPage.outerHTML}${this._getBtnHtmlToggle(isAutoExpand)}</div>
						${isTooDeep ? `<div class="mb-1 bold veapp__msg-error">Warning: too many recursive embeds! Have you made an infinite loop?</div>` : ""}
						<div class="w-100 jemb__wrp-content ${isAutoExpand ? "" : "ve-hidden"}">${subContent}</div>
					</div>`,
				});
			}

			case "image": {
				return e_({
					outer: `<div class="w-100 ve-flex-col">
						<div class="ve-flex-v-center mb-1 jemb__wrp-lnk">${lnkPage.outerHTML}${this._getBtnHtmlToggle(isAutoExpand)}</div>
						<div class="ve-flex-vh-center jemb__wrp-content ${isAutoExpand ? "" : "ve-hidden"}"><a target="_blank w-100" href="${doc.src}"><img src="${doc.src}" class="jemb__img"></a></div>
					</div>`,
				});
			}

			case "class":
			case "video":
			case "pdf": {
																																												return lnkPage;
			}

			default: {
				return lnkPage;
			}
		}
	}

	static handleToggleClick (event) {
		const $btn = $(event.currentTarget);
		const isExpanded = $btn.attr("data-plut-is-expanded") === "1";

		if (event.shiftKey) {
			event.preventDefault();

			const $editor = $btn.closest(`.editor`);
			$editor.find(`button[data-plut-is-expanded]`).each((i, e) => this._handleExpandCollapse($(e), isExpanded));
			return;
		}

		this._handleExpandCollapse($btn, isExpanded);
	}

	static _handleExpandCollapse ($btn, isExpanded) {
		const $wrp = $btn.parent().next();
		$wrp.toggleClass("ve-hidden", isExpanded);
		$btn
			.attr("data-plut-is-expanded", isExpanded ? "0" : "1")
			.html(isExpanded ? `<i class="fa fa-caret-square-left"></i>` : `<i class="fa fa-caret-square-down"></i>`)
			.title(`${isExpanded ? `Expand` : `Collapse`} Journal Entry (SHIFT for All Entries)`);
	}

	static _getBtnHtmlToggle (isAutoExpand) {
		return `<button class="btn btn-xxs btn-5et btn-default ve-flex-vh-center mx-1 jemb__btn-toggle" data-plut-is-expanded="${isAutoExpand ? 1 : 0}" title="${isAutoExpand ? "Collapse" : "Expand"} Journal Entry (SHIFT for All Entries)" type="button">${isAutoExpand ? `<i class="fa fa-caret-square-down"></i>` : `<i class="fa fa-caret-square-left"></i>`}</button>`;
	}
};
Patcher_TextEditor.JournalEmbed._MAX_RECURSION_DEPTH = 69; 
Patcher_TextEditor.ContentLoader = class extends Patcher_TextEditor.Enricher {
	static get _RE () { return RegExp(`@(${Renderer.tag.TAGS.filter(it => it.defaultSource).map(it => it.tagName).join("|")})\\[([^\\]]+)](?:{([^}]+)})?`, "g"); }

	static _enrich (match, opts) {
		const [fullText, tag, pipeParts, displayText] = match;

		const importerMeta = ChooseImporter.getImporterClassMeta(tag);
		const name = (Renderer.splitTagByPipe(pipeParts)[0] || "");

		if (!importerMeta) {
			return e_({
				tag: "a",
				clazz: "entity-link broken",
				title: `Unknown Tag "${tag.qq()}"`,
				children: [
					e_({
						tag: "i",
						clazz: "fas fa-unlink",
					}),
					` ${displayText || name}`,
				],
			});
		}

		const {Class: Importer, isViewOnly} = importerMeta;

		const {displayText: displayTextPipe, page, pageHover, source, hash, preloadId, hashPreEncoded, hashHover, hashPreEncodedHover, subhashes, subhashesHover} = Renderer.utils.getTagMeta(`@${tag}`, pipeParts);

		const attrsHover = {
			"data-plut-hover-page": page,
			"data-plut-hover-page-hover": pageHover || undefined,
			"data-plut-hover-source": source,
			"data-plut-hover-hash": hash,
			"data-plut-hover-tag": tag,
			"data-plut-hover-preload-id": preloadId || undefined,
			"data-plut-hover-hash-pre-encoded": hashPreEncoded || undefined,
			"data-plut-hover-hash-hover": hashHover || undefined,
			"data-plut-hover-hash-pre-encoded-hover": hashPreEncodedHover || undefined,
			"data-plut-hover-subhashes": subhashes?.length ? JSON.stringify(subhashes) : undefined,
			"data-plut-hover-subhashes-hover": subhashesHover?.length ? JSON.stringify(subhashesHover) : undefined,
			"data-plut-hover-is-faux-page": isViewOnly ? true : undefined,
			"data-plut-hover": Config.get("text", "isEnableHoverForLinkTags") || isViewOnly ? true : undefined,
		};

		if (isViewOnly) {
			return e_({
				tag: "span",
				clazz: "help help--hover",
				attrs: {
					...attrsHover,
				},
				html: `${StrUtil.qq(displayTextPipe || displayText || name)}`,
			});
		}

		const config = CONFIG[Importer.FOLDER_TYPE];

				if (!config) {
			return e_({
				tag: "a",
				clazz: "entity-link broken",
				title: `No CONFIG found for type "${Importer.FOLDER_TYPE}"\u2014this is a bug!`,
				children: [
					e_({
						tag: "i",
						clazz: "fas fa-unlink",
					}),
					` ${displayText || name}`,
				],
			});
		}

		return e_({
			tag: "a",
			clazz: "jlnk__entity-link",
			attrs: {
				"draggable": true,
				...attrsHover,
				"data-plut-rich-link": true,
				"data-plut-rich-link-entity-type": Importer.FOLDER_TYPE,
								"data-plut-rich-link-original-text": fullText.slice(1).qq(),
			},
			children: [
				e_({
					tag: "i",
					clazz: `fas ${config.sidebarIcon}`,
				}),
				` ${displayTextPipe || displayText || name}`,
			],
		});
	}

	static handleClick (evt) {
		evt.stopPropagation();
		evt.preventDefault();

				const originalText = `@${evt.currentTarget.dataset.plutRichLinkOriginalText}`;

		const tag = evt.currentTarget.dataset.plutHoverTag;
		const page = evt.currentTarget.dataset.plutHoverPage;
		const source = evt.currentTarget.dataset.plutHoverSource;
		let hash = evt.currentTarget.dataset.plutHoverHash;
		const hashPreEncoded = !!evt.currentTarget.dataset.plutHoverHashPreEncoded;
		const pageHover = evt.currentTarget.dataset.plutHoverPageHover || page;
		let hashHover = evt.currentTarget.dataset.plutHoverHashHover;
		const hashPreEncodedHover = !!evt.currentTarget.dataset.plutHoverHashPreEncodedHover;
		const subhashesHover = evt.currentTarget.dataset.plutHoverSubhashesHover;

		if (!pageHover || !source || !hash) return;

		const importer = ChooseImporter.getImporter(tag) || ChooseImporter.getImporter(page);

		if (!hashPreEncoded) hash = UrlUtil.encodeForHash(hash);
		if (hashHover && !hashPreEncodedHover) hashHover = UrlUtil.encodeForHash(hashHover);
		if (!hashHover) hashHover = hash;

		if (subhashesHover) {
			const parsed = JSON.parse(subhashesHover);
			hashHover += Renderer.utils.getLinkSubhashString(parsed);
		}

		const isPermanent = !!evt.shiftKey
			&& (
				(game.user.can("ACTOR_CREATE") && importer.gameProp === "actors")
				|| (game.user.can("ITEM_CREATE") && importer.gameProp === "items")
				|| (game.user.can("JOURNAL_CREATE") && importer.gameProp === "journal")
				|| (game.user.can("ROLL_TABLE_CREATE") && importer.gameProp === "tables")
			);
		const isPopout = evt.view !== window && Config.get("ui", "isEnableSubPopouts");

		DataLoader.pCacheAndGet(pageHover, source, hashHover)
			.then(async ent => {
				const msgErrorBase = `Could not load content for tag "${originalText}"!`;

				if (!ent) {
					const msgError = `${msgErrorBase} Could not find matching entity.`;
					console.error(...LGT, msgError);
					return ui.notifications.error(msgError);
				}

				await importer.pInit();

				importer.pImportEntry(
					ent,
					{
						isTemp: !isPermanent,
						defaultOwnership: !isPermanent
							? UtilDataConverter.getTempDocumentDefaultOwnership({documentType: importer.constructor.FOLDER_TYPE})
							: undefined,
					},
				)
					.then(async importSummary => {
						if (isPermanent) UtilApplications.doShowImportedNotification(importSummary);

						const renderMetas = UtilImporter.pForceRenderImportedDocSheets(importSummary);

						if (!isPopout) return;
						renderMetas.filter(Boolean).forEach(({app, data}) => PopoutSheet.doPopout(app, data));
					})
					.catch(err => {
						console.error(...LGT, err);
						ui.notifications.error(`${msgErrorBase} ${VeCt.STR_SEE_CONSOLE}`);
					});
			});
	}
};

Patcher_TextEditor.ParentChildEntity = class {
	static getValidUuid (link) {
		const uuid = link?.dataset?.uuid;
		if (!uuid) return null;

				if (UtilDragDrop.isCustomUuid(link?.dataset?.uuid)) return null;

		const parts = uuid.split(".");
		if (parts.length !== 4) return null;

		return uuid;
	}

	static mutLink (link, doc) {
		if (!doc?.parent) return;

		const configParent = CONFIG[doc.parent.documentName];
		if (!configParent) return;

		link.prepend(" ");

		link.prepend(e_({
			tag: "i",
			clazz: configParent.sidebarIcon,
		}));

		const textNode = [...link.childNodes].last();
		textNode.textContent = `${doc.parent.name} / ${textNode.textContent}`;
	}
};

Patcher_TextEditor.ContentDragDrop = class {
	static init () {
		UtilLibWrapper.addPatch(
			"ActorSheet.prototype._onDragStart",
			this._lw_ActorSheet_prototype__onDragStart,
			UtilLibWrapper.LIBWRAPPER_MODE_MIXED,
		);

		UtilLibWrapper.addPatch(
			"TextEditor.getContentLink",
			this._lw_TextEditor_getContentLink,
			UtilLibWrapper.LIBWRAPPER_MODE_MIXED,
		);
	}

	static _lw_ActorSheet_prototype__onDragStart (fn, ...args) {
		const evt = args[0];
		if (evt.target.dataset.plutRichLink) return;
		return fn(...args);
	}

	static async _lw_TextEditor_getContentLink (fn, ...args) {
		const [data] = args;
		if (!Object.keys(data).length) return fn(...args);

				if (data?.subType === UtilEvents.EVT_DATA_SUBTYPE__IMPORT) {
			return data.tag;
		}
		
		if (data?.subType !== UtilEvents.EVT_DATA_SUBTYPE__HOVER) return fn(...args);

				return `@${data.originalText}`;
	}
};

class Patcher_ChatMessage {
	static handleConfigUpdate ({isInit = false} = {}) {
		try {
			return this._handleConfigUpdate_();
		} catch (e) {
			if (!isInit) throw e;
			Config.handleFailedInitConfigApplication("ui", "isCompactChat", e);
		}
	}

	static _handleConfigUpdate_ () {
				if (Patcher_ChatMessage._LAST_CONFIG_STATE == null || Patcher_ChatMessage._LAST_CONFIG_STATE !== Config.get("ui", "isCompactChat")) {
			Patcher_ChatMessage._LAST_CONFIG_STATE = Config.get("ui", "isCompactChat");
			if (Patcher_ChatMessage._LAST_CONFIG_STATE) this._doAddToExistingMessages();
			else this._doRemoveFromExistingMessages();
		}
	}

	static _doAddToExistingMessages () {
		const $messages = ui.chat.element.find(`.message`);
		$messages.each((i, e) => {
			const $ele = $(e);
			const chatMessage = CONFIG.ChatMessage.collection.instance.get(e.dataset.messageId);
			this._handleRenderChatMessage(chatMessage, $ele, true);
		});
	}

	static _doRemoveFromExistingMessages () {
		const $messages = ui.chat.element.find(`.message`);
		$messages.each((i, e) => {
			e.classList.remove(`chatmsg__trim-top`);
			e.classList.remove(`chatmsg__trim-bottom`);
			$(e)
				.off(`mousemove.${Patcher_ChatMessage._EVENT_NAMESPACE}`)
				.off(`mouseover.${Patcher_ChatMessage._EVENT_NAMESPACE}`)
				.off(`mouseleave.${Patcher_ChatMessage._EVENT_NAMESPACE}`);
		});
	}

	static init () {
		Hooks.on("renderChatMessage", (chatMessage, $ele) => {
			if (!Config.get("ui", "isCompactChat")) return;

			this._handleRenderChatMessage(chatMessage, $ele);
		});

		Hooks.on("deleteChatMessage", (...args) => {
			if (!Config.get("ui", "isCompactChat")) return;

			this._handleDeleteChatMessage(...args);
		});
	}

	static _handleRenderChatMessage (chatMessage, $ele, isIgnoreExisting) {
				if (!isIgnoreExisting) {
			const $eleExisting = this._$getExistingRender(chatMessage);
			if ($eleExisting && $eleExisting.length) {
				return this._doHandleExistingMessage(chatMessage, $ele, $eleExisting);
			}
		}
		
		if (!this._isMetaMatch(chatMessage)) {
			Patcher_ChatMessage._LAST_MESSAGE_META = this._getMessageMeta(chatMessage, $ele);
			return;
		}

				Patcher_ChatMessage._LAST_MESSAGE_META.$ele.addClass(`chatmsg__trim-bottom`);
		
				const nxtMeta = this._getMessageMeta(chatMessage, $ele);

		nxtMeta.$ele.addClass(`chatmsg__trim-top`);
		this._doBindTrimmedTopEventHandlers(nxtMeta.$ele);
		
		Patcher_ChatMessage._LAST_MESSAGE_META = nxtMeta;
	}

	static _getMessageMeta (chatMessage, $ele) {
		const $header = $ele.find(`header.message-header`);

		return {
			$ele,
			$header,
			chatMessage,
		};
	}

	static _$getExistingRender (chatMessage) {
								return ui.chat.element.find(`.message[data-message-id="${chatMessage.id}"]`);
	}

	static _doHandleExistingMessage (chatMessage, $ele, $eleExisting) {
		if ($eleExisting.hasClass("chatmsg__trim-bottom")) $ele.addClass("chatmsg__trim-bottom");

		if ($eleExisting.hasClass("chatmsg__trim-top")) {
			$ele.addClass("chatmsg__trim-top");
			this._doBindTrimmedTopEventHandlers($ele);
		}
	}

	static _isMetaMatch (chatMessage) {
		if (!Patcher_ChatMessage._LAST_MESSAGE_META) return false;

		const {chatMessage: lastChatMessage} = Patcher_ChatMessage._LAST_MESSAGE_META;
		if (!lastChatMessage || !chatMessage) return false;

				if (lastChatMessage.timestamp < chatMessage.timestamp - Patcher_ChatMessage._SPEAKER_TIMEOUT_MSEC) return false;

		if (lastChatMessage.user?.id !== chatMessage.user?.id) return false;
		if (lastChatMessage.user?.color !== chatMessage.user?.color) return false;
		if (lastChatMessage.alias !== chatMessage.alias) return false;
		if (!CollectionUtil.deepEquals(lastChatMessage?.whisper, chatMessage?.whisper)) return false;
		if (lastChatMessage?.blind !== chatMessage?.blind) return false;

		return true;
	}

	static _handleDeleteChatMessage (chatMessage) {
		const $ele = ui.chat.element.find(`.message[data-message-id="${chatMessage.id}"]`);

		const $prevEle = $ele.prev();
		const $nxtEle = $ele.next();

				if ($nxtEle.length) {
			if (!$ele.hasClass(`chatmsg__trim-top`) && $ele.hasClass(`chatmsg__trim-bottom`)) {
				$nxtEle.removeClass(`chatmsg__trim-top`);
			}
		}

				if ($prevEle.length) {
			if ($ele.hasClass(`chatmsg__trim-top`) && !$ele.hasClass(`chatmsg__trim-bottom`)) {
				$prevEle.removeClass(`chatmsg__trim-bottom`);
			}
		}

				if (Patcher_ChatMessage._LAST_MESSAGE_META) {
			const {chatMessage: lastChatMessage} = Patcher_ChatMessage._LAST_MESSAGE_META;
			if (lastChatMessage === chatMessage) Patcher_ChatMessage._LAST_MESSAGE_META = null;
		}
	}

	static _doBindTrimmedTopEventHandlers ($ele) {
		$ele
			.on(`mousemove.${Patcher_ChatMessage._EVENT_NAMESPACE}`, evt => {
				if (!evt.shiftKey) return;
				$ele.addClass(`chatmsg__trim-top--inspecting`);
			})
			.on(`mouseover.${Patcher_ChatMessage._EVENT_NAMESPACE}`, evt => {
				if (!evt.shiftKey) return;
				$ele.addClass(`chatmsg__trim-top--inspecting`);
			})
			.on(`mouseleave.${Patcher_ChatMessage._EVENT_NAMESPACE}`, () => {
				$ele.removeClass(`chatmsg__trim-top--inspecting`);
			});
	}
}
Patcher_ChatMessage._LAST_CONFIG_STATE = null;
Patcher_ChatMessage._SPEAKER_TIMEOUT_MSEC = 30_000;
Patcher_ChatMessage._LAST_MESSAGE_META = null;
Patcher_ChatMessage._EVENT_NAMESPACE = `${SharedConsts.MODULE_ID}-chat`;

class UtilPatch {
			static cacheMethod (obj, methodName, opts) {
		opts = opts || {};

		const existing = UtilPatch.getCachedMethod(obj, methodName);
		if (existing != null) return existing;

		const toCache = opts.isBind ? obj[methodName].bind(obj) : obj[methodName];

				obj[`_plutoniumCache${methodName}`] = toCache;

		if (!UtilPatch._CACHE_METHODS.has(obj)) UtilPatch._CACHE_METHODS.set(obj, {});

		const store = UtilPatch._CACHE_METHODS.get(obj);
		store[methodName] = toCache;

		return toCache;
	}

	static getCachedMethod (obj, methodName) {
		if (!UtilPatch._CACHE_METHODS.has(obj)) return null;
		const store = UtilPatch._CACHE_METHODS.get(obj);
		return store[methodName] || null;
	}

	static restoreCachedMethod (obj, methodName) {
		const method = UtilPatch.getCachedMethod(obj, methodName);
		if (!method) return;
		obj[methodName] = method;
	}
	
			static cacheGetter (obj, getterName, opts) {
		opts = opts || {};

		const existing = UtilPatch.getCachedMethod(obj, getterName);
		if (existing != null) return;

		const getterMeta = this._getGetterMeta(obj, getterName);
		getterMeta.fnGet = opts.isBind ? getterMeta.fnGet.bind(getterMeta.obj) : getterMeta.fnGet;

				Object.defineProperty(
			getterMeta.obj,
			`_plutoniumCache${getterName}`,
			{
				configurable: true,
				get: getterMeta.fnGet,
			},
		);

		if (!UtilPatch._CACHE_METHODS.has(obj)) UtilPatch._CACHE_METHODS.set(obj, {});

		const store = UtilPatch._CACHE_METHODS.get(obj);
		store[getterName] = getterMeta;
	}

	static _getGetterMeta (obj, getterName) {
		const ownProp = Object.getOwnPropertyDescriptor(obj, getterName);
		if (ownProp && ownProp.get) {
			return {
				fnGet: ownProp.get,
				obj,
			};
		}

		while (Object.getPrototypeOf(obj) !== null) {
			obj = Object.getPrototypeOf(obj);
			const parentProp = Object.getOwnPropertyDescriptor(obj, getterName);
			if (parentProp && parentProp.get) {
				return {
					fnGet: parentProp.get,
					obj,
				};
			}
		}

		throw new Error(`Could not find getter "${getterName}" on object`);
	}

	static getCachedGetterMeta (obj, getterName) {
		const getterMeta = UtilPatch.getCachedMethod(obj, getterName);
		if (getterMeta) return getterMeta;

		while (Object.getPrototypeOf(obj) !== null) {
			obj = Object.getPrototypeOf(obj);
			const getterMeta = UtilPatch.getCachedMethod(obj, getterName);
			if (getterMeta) return getterMeta;
		}
	}

	static restoreCachedGetter (obj, getterName) {
		const getterMeta = UtilPatch.getCachedGetterMeta(obj, getterName);
		if (!getterMeta) return;
		Object.defineProperty(
			getterMeta.obj,
			getterName,
			{
				configurable: true,
				get: getterMeta.fnGet,
			},
		);
	}
	}
UtilPatch._CACHE_METHODS = new Map();
UtilPatch._CACHE_GETTERS = new Map();

class UtilPatcher {
		static findPlutoniumTextNodes (ele) {
		const stack = [];
		this._findPlutoniumTextNodes(ele, {stack});
		return stack;
	}

	static _findPlutoniumTextNodes (ele, {stack}) {
		if (!ele) return;

		if (ele.nodeName === "#text") {
			const txt = (ele.data || "").trim();
			if (txt.startsWith(SharedConsts.MODULE_TITLE)) stack.push(ele);
		}

		for (let i = 0; i < ele.childNodes.length; ++i) {
			const node = ele.childNodes[i];
			this._findPlutoniumTextNodes(node, {stack});
		}
	}
}

class Patcher_SettingsConfig {
	static init () {
		Hooks.on("renderSettingsConfig", (app, $html) => {
			if (!Config.get("ui", "isStreamerMode")) return;

			const elesHeaders = $html.find(`.module-header`).get();
			for (const eleHeader of elesHeaders) {
				const toReplace = UtilPatcher.findPlutoniumTextNodes(eleHeader);
				toReplace.forEach(node => node.data = node.data.replace(SharedConsts.MODULE_TITLE, SharedConsts.MODULE_TITLE_FAKE));
			}
		});
	}
}

class _UtilPatcher_CanvasAnimation {
	static _IS_ONLY_MOVEMENT_KEYS = new Set(["_id", "x", "y"]);
	static isOnlyMovement (updateData) {
		const otherKeys = Object.keys(updateData).filter(it => !this._IS_ONLY_MOVEMENT_KEYS.has(it));
		return !otherKeys.length;
	}

	static isTokenMovingAlongRuler (token) {
		return canvas.controls.rulers.children.some(it => it._state === Ruler.STATES.MOVING && it._plut_tokenLastMoving === token);
	}
}

class Patcher_CanvasAnimation {
	static init () {
		if (UtilVersions.getCoreVersion().isVersionElevenPlus) return Patcher_CanvasAnimation._v11.init();
		return Patcher_CanvasAnimation._v10.init();
	}
}

Patcher_CanvasAnimation._v10 = class {
	static init () {
				UtilLibWrapper.addPatch(
			"Token.prototype._onUpdateAppearance",
			this._lw_Token_prototype__onUpdateAppearance,
			UtilLibWrapper.LIBWRAPPER_MODE_WRAPPER,
		);

		UtilLibWrapper.addPatch(
			"Ruler.prototype._getMovementToken",
			this._lw_Ruler_prototype__getMovementToken,
			UtilLibWrapper.LIBWRAPPER_MODE_WRAPPER,
		);
		
				UtilLibWrapper.addPatch(
			"Token.prototype.animate",
			this._lw_Token_prototype_animate,
			UtilLibWrapper.LIBWRAPPER_MODE_WRAPPER,
		);
			}

	static _lw_Token_prototype__onUpdateAppearance (fn, data, changed, opts, ...otherArgs) {
		if (
			Config.get("tokens", "isDisableAnimations")
			&& _UtilPatcher_CanvasAnimation.isOnlyMovement(data)
			&& (
				!Config.get("tokens", "isIgnoreDisableAnimationsForWaypointMovement")
				|| !_UtilPatcher_CanvasAnimation.isTokenMovingAlongRuler(this)
			)
		) {
			opts = opts || {};
			opts.animate = false;
		}
		return fn(data, changed, opts, ...otherArgs);
	}

	static _lw_Ruler_prototype__getMovementToken (fn) {
		const out = fn();
		this._plut_tokenLastMoving = out;
		return out;
	}

	static _lw_Token_prototype_animate (fn, updateData, opts, ...otherArgs) {
		const mult = Config.get("tokens", "animationSpeedMultiplier");
		if (mult == null) return fn(updateData, opts, ...otherArgs);

		opts = {...opts || {}};
		if (opts.movementSpeed == null) opts.movementSpeed = 6; 		opts.movementSpeed *= mult;

		return fn(updateData, opts, ...otherArgs);
	}
};

Patcher_CanvasAnimation._v11 = class {
	static init () {
				UtilLibWrapper.addPatchMultiMutatesArgs(
			"Token.prototype._onUpdate",
			this._lwMulti_Token_prototype__onUpdate,
			UtilLibWrapper.LIBWRAPPER_MODE_WRAPPER,
		);

		UtilLibWrapper.addPatch(
			"Ruler.prototype._getMovementToken",
			this._lw_Ruler_prototype__getMovementToken,
			UtilLibWrapper.LIBWRAPPER_MODE_WRAPPER,
		);
		
				UtilLibWrapper.addPatch(
			"Token.prototype.animate",
			this._lw_Token_prototype_animate,
			UtilLibWrapper.LIBWRAPPER_MODE_WRAPPER,
		);
			}

	static _lwMulti_Token_prototype__onUpdate ({args}) {
		let [data, opts, ...otherArgs] = args;

		if (
			Config.get("tokens", "isDisableAnimations")
			&& _UtilPatcher_CanvasAnimation.isOnlyMovement(data)
			&& (
				!Config.get("tokens", "isIgnoreDisableAnimationsForWaypointMovement")
				|| !_UtilPatcher_CanvasAnimation.isTokenMovingAlongRuler(this)
			)
		) {
			opts = opts || {};
			opts.animate = false;
		}

		return [data, opts, ...otherArgs];
	}

	static _lw_Ruler_prototype__getMovementToken (fn) {
		const out = fn();
		this._plut_tokenLastMoving = out;
		return out;
	}

	static _lw_Token_prototype_animate (fn, updateData, opts, ...otherArgs) {
		const mult = Config.get("tokens", "animationSpeedMultiplier");
		if (mult == null) return fn(updateData, opts, ...otherArgs);

		opts = {...opts || {}};
		if (opts.movementSpeed == null) opts.movementSpeed = 6; 		opts.movementSpeed *= mult;

		return fn(updateData, opts, ...otherArgs);
	}
};

class Patcher_Jquery {
	static init () {
		UtilLibWrapper.addPatch(
			"$.prototype.animate",
			this._lw_$_prototype_animate,
			UtilLibWrapper.LIBWRAPPER_MODE_WRAPPER,
		);
	}

	static _lw_$_prototype_animate (fn, ...args) {
		return fn(...Patcher_Jquery._getNextArgs(...args));
	}

	static _getNextArgs (...args) {
		let nxtArgs = [...args];

		if (Config.get("ui", "isFastAnimations")) {
			for (let i = 0; i < nxtArgs.length; ++i) {
				const arg = nxtArgs[i];

																								if (typeof arg === "object" && arg.duration != null) {
					if (arg.duration > 33) arg.duration = 33;
					break;
				} else if (typeof arg === "number") {
					if (arg > 33) nxtArgs[i] = 33;
					break;
				}
			}
		}

		return nxtArgs;
	}
}

class Patcher_GameKeyboard {
	static prePreInit () {
		this._init_registerKeybindEsc();
	}

	static init () {
		Hooks.on(`${SharedConsts.MODULE_ID_FAKE}.configUpdate`, () => this._pHandleConfigUpdate());
		this._pHandleConfigUpdate();

		this._init_patchEscapeMethods();
	}

	static _init_patchEscapeMethods () {
						UtilLibWrapper.addPatch(
			"game.keyboard._handleKeyboardEvent",
			this._lw_game_keyboard__handleKeyboardEvent,
			UtilLibWrapper.LIBWRAPPER_MODE_WRAPPER,
		);
		
		UtilLibWrapper.addPatch(
			"game.keyboard.hasFocus",
			this._lw_game_keyboard_hasFocus,
			UtilLibWrapper.LIBWRAPPER_MODE_WRAPPER,
		);
	}

	static _lw_game_keyboard__handleKeyboardEvent (fn, ...args) {
		const val = fn(...args);
		Patcher_GameKeyboard._LAST_KEYBOARD_EVENT_INFO = {event: args[0], isUp: args[1]};
		return val;
	}

	static _lw_game_keyboard_hasFocus (fn, ...args) {
		const val = fn(...args);
		if (!Config.get("ui", "isFixEscapeKey")) return val;
		if (Patcher_GameKeyboard._LAST_KEYBOARD_EVENT_INFO?.event?.key !== "Escape") return val;
				return false;
	}

	static async _pHandleConfigUpdate () {
		try {
			await Patcher_GameKeyboard._LOCK_EDIT_KEYBINDS.pLock();
			await this._pHandleConfigUpdate_();
		} finally {
			Patcher_GameKeyboard._LOCK_EDIT_KEYBINDS.unlock();
		}
	}

	static async _pHandleConfigUpdate_ () {
						game.keybindings.set(SharedConsts.MODULE_ID, Patcher_GameKeyboard._ACTION_DISMISS);
		if (!Config.get("ui", "isFixEscapeKey")) return;
		game.keybindings.set(SharedConsts.MODULE_ID, Patcher_GameKeyboard._ACTION_DISMISS, [{key: "Escape"}]);
	}

	static _init_registerKeybindEsc () {
		game.keybindings.register(
			SharedConsts.MODULE_ID,
			Patcher_GameKeyboard._ACTION_DISMISS,
			{
				name: "KEYBINDINGS.Dismiss",
				hint: `An improved version of Foundry's built-in binding. Bind the "Escape" key to (in this order): de-select active input fields; de-select selected canvas elements; close context menus; close individual windows in most-recently-active-first order; toggle the main menu.`,
				onDown: (context) => {
					const {event} = context;

					if (UiUtil._MODAL_STACK && UiUtil._MODAL_STACK.length) return true;

										if (UtilUi.isGameMenuOpen()) {
						ui.menu.toggle();
						return true;
					}

										if (document.hasFocus() && Patcher_GameKeyboard._ELEMENTS_WITH_FOCUS.has(event.target.nodeName)) {
						event.target.blur();
						return true;
					}

										if (canvas.ready) canvas.fog.commit();

										if (ui.context && ui.context.menu.length) {
						ui.context.close();
						return true;
					}

										if (Menu.closeAllMenus()) {
						return true;
					}

										if (canvas.activeLayer && canvas.activeLayer.controlled?.length) {
						if (!canvas.activeLayer.preview?.children.length) canvas.activeLayer.releaseAll();
						return true;
					}

										const appsOpen = UtilApplications.getOpenAppsSortedByZindex({isFilterInvalid: true})
						.filter(app => (app.isEscapeable == null || app.isEscapeable === true) && !PopoutSheet.isPoppedOut(app));
					if (appsOpen.length) {
												appsOpen
							.last()
							.close();
						return true;
					}

										ui.menu.toggle();

										if (canvas.ready) canvas.fog.save();

					return true;
				},
				restricted: false,
				precedence: CONST.KEYBINDING_PRECEDENCE.PRIORITY,
			},
		);
	}
}
Patcher_GameKeyboard._ACTION_DISMISS = "KEYBINDINGS.Dismiss";
Patcher_GameKeyboard._ELEMENTS_WITH_FOCUS = new Set(["INPUT", "TEXTAREA"]);
Patcher_GameKeyboard._LOCK_EDIT_KEYBINDS = new VeLock();
Patcher_GameKeyboard._LAST_KEYBOARD_EVENT_INFO = null;

class Patcher_ActiveEffectConfig {
	static init () {
		UtilLibWrapper.addPatch(
			"ActiveEffectConfig.defaultOptions",
			this._lw_ActiveEffectConfig_defaultOptions,
			UtilLibWrapper.LIBWRAPPER_MODE_WRAPPER,
		);

		Hooks.on("renderActiveEffectConfig", (app, $html, opts) => {
			this._onHookActiveEffectConfig(app, $html, opts);
		});
	}

	static _lw_ActiveEffectConfig_defaultOptions (fn, ...args) {
		const base = fn(...args);
		if (!Config.get("actor", "isUseExtendedActiveEffectsParser")) return base;
		base.width = 640;
		base.resizable = true;
		return base;
	}

	static _onHookActiveEffectConfig (app, $html, opts) {
		if (!Config.get("ui", "isExpandActiveEffectConfig") || UtilCompat.isDaeActive()) return;

				const $rowHeader = $html.find(`.effect-change.effects-header`);
		$rowHeader.find(`.key`).css({marginLeft: 24});
		$rowHeader.find(`.effect-controls`).before(`<div class="priority">Priority</div>`);

		$html.find(`.changes-list .effect-change`)
			.each((i, row) => {
				const $row = $(row);
				const ixChange = Number(row.dataset.index);

				const $iptKey = $row.find(`.key input`)
					.addClass("bbl-0 btl-0 h-27p");
				const $selMode = $row.find(`.mode select`);
				const $iptValue = $row.find(`.value input`)
					.addClass("h-27p");

				$(`<button class="no-grow no-shrink text-center p-0 m-0 btr-0 bbr-0 br-0 aeff__btn-inline" title="Find Active Effect Attribute Key"><i class="fas fa-fw fa-search mr-0"></i></button>`)
					.click(async evt => {
						evt.preventDefault();
						evt.stopPropagation();

						const availableEffects = UtilActiveEffects.getAvailableEffects(app.object.parent, opts);

						const {$modalInner, doClose, doAutoResize} = await UtilApplications.pGetShowApplicationModal({
							title: `Find Active Effect Attribute Key`,
							isWidth100: true,
							isHeight100: true,
						});

						const $iptSearch = $(`<input type="search" class="search w-100 form-control h-initial" placeholder="Find keys...">`);
						const $btnReset = $(`<button class="btn-5et veapp__btn-list-reset" name="btn-reset">${game.i18n.localize("PLUT.Reset")}</button>`)
							.click(() => list.reset());
						const $wrpBtnsSort = $$`<div class="ve-flex-v-stretch input-group input-group--bottom mb-1">
							<button class="btn-5et col-4-5 sort" data-sort="name">Name</button>
							<button class="btn-5et col-2-5 sort" data-sort="value">Current Value</button>
							<button class="btn-5et col-2-5 sort" data-sort="baseValue" title="The underlying value, without any current effects/etc. applied.">Current Base Value</button>
							<button class="btn-5et col-2-5 sort" data-sort="default">Default Value</button>
						</div>`;
						const $wrpList = $(`<div class="veapp__list h-100 mb-1"></div>`);

						const list = new List({
							isUseJquery: true,
							$iptSearch,
							$wrpList,
						});

						SortUtil.initBtnSortHandlers($wrpBtnsSort, list);

						availableEffects.forEach((ae, ix) => {
							const val = MiscUtil.get(app.object.parent.system, ...ae.path.split("."));
							const _val = MiscUtil.get(app.object.parent.system._source, ...ae.path.split("."));

							const $ele = $$`<label class="ve-flex w-100 veapp__list-row clickable veapp__list-row-hoverable">
								<span class="col-4-5 px-2">${ae.path}</span>
								<span class="col-2-5 text-center code">${JSON.stringify(val)}</span>
								<span class="col-2-5 text-center code">${JSON.stringify(_val)}</span>
								<span class="col-2-5 text-center code">${JSON.stringify(ae.default)}</span>
							</label>`
								.click(() => {
									const cleanDefault = ae.default == null
										? ae.default
										: typeof ae.default === "object" ? JSON.stringify(ae.default) : ae.default;

									$iptKey.val(ae.path);
									$selMode.val(`${CONST.ACTIVE_EFFECT_MODES.OVERRIDE}`);
									if (!($iptValue.val() || "").trim()) $iptValue.val(cleanDefault);

									doClose();
								});

							const listItem = new ListItem(
								ix,
								$ele,
								ae.path,
								{
									value: val ? MiscUtil.copy(val) : val,
									default: ae.default,
									baseValue: _val ? MiscUtil.copy(_val) : _val,
								},
							);
							list.addItem(listItem);
						});
						list.init();
						list.update();

						$$($modalInner)`<div class="ve-flex-col h-100 min-h-0">
							<div class="ve-flex-v-stretch input-group input-group--top">
								${$iptSearch}
								${$btnReset}
							</div>
							${$wrpBtnsSort}
							${$wrpList}
						</div>`;

						doAutoResize();
					})
					.prependTo($row);

				const $wrpControls = $row.find(`.effect-controls`);

				const $iptPriority = $(`<input class="btr-0 bbr-0 h-27p" type="number" name="changes.${ixChange}.priority" value="${app?.object?.changes?.[ixChange]?.priority || ""}">`);

				const $btnPriorityHelp = $(`<button class="no-grow no-shrink text-center p-0 m-0 aeff__btn-inline btl-0 bbl-0 bl-0" title="Priority Help"><i class="fas fa-fw fa-question-circle mr-0"></i></button>`)
					.click(evt => {
						evt.stopPropagation();
						evt.preventDefault();

						const numModes = Object.keys(CONST.ACTIVE_EFFECT_MODES).length;
						const rows = Object.entries(CONST.ACTIVE_EFFECT_MODES).map(([k, v], i) => {
							return `<div class="ve-flex-v-center py-1 stripe-even">
								<div class="col-4-5 ve-flex-vh-center">${game.i18n.localize(`EFFECT.MODE_${k}`)}</div>
								<div class="col-4-5 text-center">${v * 10}</div>
								<div class="col-3 text-center">${i === 0 || i === (numModes - 1) ? `<i class="ve-muted ml-2">Applied ${i === 0 ? "first" : "last"}</i>` : ""}</div>
							</div>`;
						});

						new Dialog({
							title: "Active Effects Priority Help",
							content: `<div>
								<p>Active Effects are applied with the following priorities by default:</p>
								<div class="ve-flex-v-center">
									<div class="bold col-4-5 text-center">Change Mode</div>
									<div class="bold col-4-5 text-center">Priority</div>
									<div class="bold col-3 text-center"></div>
								</div>
								<div>
									${rows.join("")}
								</div>
								<p>Setting a &quot;priority&quot; value allows you to change this, and apply the effects in any order you choose.</p>
								<p>For example, if you wished to create an Active Effect for your plate armor and an Active Effect for your shield, you could create an &quot;Override&quot; effect for the plate, with 18 AC, and an &quot;Add&quot; effect for the shield, with 2 AC. You would then set the plate's priority to a number in the range 0\u201319, so it is applied before the shield. If you did not, it would default to &quot;50&quot;, and thus be applied after (and override/ignore) your shield.</p>
							</div>`,
							buttons: {
								one: {
									icon: `<i class="fas fa-fw fa-times"></i>`,
									label: "Close",
								},
							},
						}).render(true);
					});

				$$`<div class="ve-flex-v-center">
					${$iptPriority}
					${$btnPriorityHelp}
				</div>`.insertBefore($wrpControls);
			});
	}
}

class Patcher_RollData {
	static init () {
		if (game.user.isGM) return;
		this._init_player_bindCharacterUpdateHook();
	}

		static _init_player_bindCharacterUpdateHook () {
		Hooks.on("updateActor", (actor) => {
			if (!Config.get("actor", "isRefreshOtherOwnedSheets")) return;
			if (game.user.character?.id !== actor?.id) return;

			const toRefresh = game.actors.contents.filter(act => {
				if (game.user.character.id === act.id || !act.isOwner) return false;

				let found = false;
				Patcher_RollData._PLAYER_CONTROLLED_NON_CHARS_WALKER.walk(
					act.system._source,
					{
						string: (str) => {
							if (!str.includes(Patcher_RollData._PLAYER_CONTROLLED_NON_CHARS_SENTINEL)) return;
							return found = true;
						},
					},
				);
				return found;
			});

			toRefresh.forEach(act => {
				act.prepareData();
				if (act.sheet?.element?.length) act.sheet.render();
			});
		});
	}

	static addAdditionalRollDataBase (rollData, entity) {
		const userChar = Patcher_RollData._getUserChar(entity);

						const pb = userChar?.system?.attributes?.prof;
		let baseSpellAttackMod = null;
		if (userChar) {
			const scAbility = userChar ? userChar.system.attributes?.spellcasting || "int" : null;
			baseSpellAttackMod = (userChar.system?.abilities?.[scAbility].mod ?? 0)
				+ (pb ?? 0);
		}

		const additionalRollData = {
						name: entity.name,
			[SharedConsts.MODULE_ID_FAKE]: {
				name: {
										[entity.name.toLowerCase().replace(/[^a-zA-Z0-9]/g, "")]: 1,
				},
				user: {
					id: game.user.id,
				},
				userchar: {
					id: userChar?.id,
					pb,
					spellAttackRanged: baseSpellAttackMod,
					spellAttackMelee: baseSpellAttackMod,

					abilities: userChar?.system?.abilities,
					attributes: userChar?.system?.attributes,
					details: userChar?.system?.details,
					traits: userChar?.system?.traits,
					currency: userChar?.system?.currency,
					skills: userChar?.system?.skills,
					spells: userChar?.system?.spells,
					bonuses: userChar?.system?.bonuses,
					resources: userChar?.system?.resources,
					movement: userChar?.system?.movement,

					classes: userChar?.classes
						? this._getRollData_userChar_classes({userChar})
						: undefined,
				},
			},
		};

		Object.assign(rollData, additionalRollData);

				if (userChar && baseSpellAttackMod != null) {
			rollData[SharedConsts.MODULE_ID_FAKE].userchar.spellAttackRanged += UtilDocuments.getEvaluatedExpression(entity, userChar.system?.bonuses?.rsak?.attack, rollData);
			rollData[SharedConsts.MODULE_ID_FAKE].userchar.spellAttackMelee += UtilDocuments.getEvaluatedExpression(entity, userChar.system?.bonuses?.msak?.attack, rollData);
		}
		
		const idAddItemsFeat = Config.get("actor", "isAddRollDataItemsFeat");
		const idAddItemsItem = Config.get("actor", "isAddRollDataItemsItem");
		const idAddItemsSpell = Config.get("actor", "isAddRollDataItemsSpell");
		const idAddItemsOther = Config.get("actor", "isAddRollDataItemsOther");
		if (
			(
				idAddItemsFeat
				|| idAddItemsItem
				|| idAddItemsSpell
				|| idAddItemsOther
			) && entity.items?.size
		) {
			rollData.items = {};

			entity.items
				.filter(itm => {
					if (itm.type === "feat") return idAddItemsFeat;
					if (itm.type === "spell") return idAddItemsSpell;
					if (UtilItem.TYPES_ITEM.has(itm.type)) return idAddItemsItem;
					return idAddItemsOther;
				})
				.forEach(itm => {
					rollData.items[UtilItem.getNameAsIdentifier(itm.name)] = {...itm};
				});
		}

		return additionalRollData;
	}

	static _getUserChar (entity) {
		if (!game.user.isGM) return game.user.character;

		for (let i = 0; i < 3 && entity?.parent; ++i) {
						if (entity.parent instanceof TokenDocument) break;
			entity = entity.parent;
		}
		if (!entity) return null; 
				if (game.users.contents.some(it => it.character?.id === entity.id)) return entity;

		const ownership = entity.ownership;

		const potentialUsers = Object.entries(ownership)
			.filter(([userId, permLevel]) => permLevel >= CONST.DOCUMENT_OWNERSHIP_LEVELS.OWNER && !game.users.get(userId)?.isGM)
			.map(([userId]) => userId);

		if (potentialUsers.length !== 1) return null;

		return game.users.get(potentialUsers[0])?.character;
	}

	static _getRollData_userChar_classes ({userChar}) {
		const cpy = {...userChar.classes};

		Object.entries(cpy)
			.forEach(([k, item]) => {
				cpy[k] = item?.system;
			});

		return cpy;
	}

		static addBabeleCompatibilityRollData (rollData, actor) {
		if (!UtilCompat.isBabeleActive()) return;

		actor.items.filter(it => it.type === "class")
			.forEach(item => {
				const originalName = item.getFlag("babele", "originalName");
				if (!originalName || originalName === item.name) return;

								const originalNameSlug = Util.Slugify.slugifyFast.call(originalName, {strict: true});

								if (rollData?.classes?.[originalNameSlug]) return;

				MiscUtil.set(rollData, "classes", originalNameSlug, item.system);
			});
	}
}
Patcher_RollData._PLAYER_CONTROLLED_NON_CHARS_WALKER = MiscUtil.getWalker({isNoModification: true, isBreakOnReturn: true});
Patcher_RollData._PLAYER_CONTROLLED_NON_CHARS_SENTINEL = `@${SharedConsts.MODULE_ID_FAKE}.userchar.`;

class Patcher_Actor {
	static init () {
		this._init_tryPatchGetRollData();
		this._init_tryPatchApplyActiveEffects();
	}

	static _init_tryPatchGetRollData () {
		try {
			UtilLibWrapper.addPatch(
				"CONFIG.Actor.documentClass.prototype.getRollData",
				this._lw_CONFIG_Actor_documentClass_prototype_getRollData,
				UtilLibWrapper.LIBWRAPPER_MODE_WRAPPER,
			);
		} catch (e) {
			console.error(...LGT, `Failed to bind getRollData handler!`, e);
		}
	}

	static _HAS_RUN_LATE_INIT_PREPARE_ACTOR_DATA = false;
	static lateInit () {
		if (!Config.get("actor", "isUseExtendedActiveEffectsParser")) return;

		if (!UtilCompat.isObsidianActive()) return this._lateInit_resetActorData();
		Hooks.once("obsidian.actorsPrepared", () => this._lateInit_resetActorData());
	}

	static _lateInit_resetActorData () {
		(CONFIG.Actor.collection.instance.contents || []).forEach(ent => {
			try {
				ent.reset();
			} catch (e) {
				const msg = `Failed to apply custom active effect parsing to actor "${ent.id}"!`;
				ui.notifications.error(`${msg} ${VeCt.STR_SEE_CONSOLE}`);
				console.error(...LGT, msg);
				console.error(e);
			}
		});

		this._HAS_RUN_LATE_INIT_PREPARE_ACTOR_DATA = true;
	}

	static _lw_CONFIG_Actor_documentClass_prototype_getRollData (fn, ...args) {
		const out = fn(...args);
		return Patcher_Actor._getRollData(this, out);
	}

	static _getRollData (actor, rollData) {
		if (!rollData) return rollData;
		Patcher_RollData.addAdditionalRollDataBase(rollData, actor);
		Patcher_RollData.addBabeleCompatibilityRollData(rollData, actor);
		return rollData;
	}

	static _init_tryPatchApplyActiveEffects () {
		UtilLibWrapper.addPatch(
			"Actor.prototype.applyActiveEffects",
			this._lw_Actor_prototype_applyActiveEffects,
			UtilLibWrapper.LIBWRAPPER_MODE_MIXED,
		);

		UtilHooks.on(UtilHooks.HK_CONFIG_UPDATE, () => this._handleConfigUpdate());
	}

	static _lw_Actor_prototype_applyActiveEffects (fn, ...args) {
		if (!Config.get("actor", "isUseExtendedActiveEffectsParser")) return fn(...args);
		return Patcher_Actor._applyActiveEffects(this, ...args);
	}

	static _handleConfigUpdate () {
		if (!this._HAS_RUN_LATE_INIT_PREPARE_ACTOR_DATA) return;

		CONFIG.Actor.collection.instance.contents.forEach(act => {
			act.prepareData();
			if (act.sheet?.element?.length) act.sheet.render();
		});
	}

		static _applyActiveEffects (actor) {
		if (!actor.effects || (!actor.effects.size && !actor.effects.length)) {
			actor.overrides = {};
			return;
		}

		const overrides = {};

				const changes = actor.effects.reduce((changes, e) => {
			if (e.disabled || e.isSuppressed) return changes;
			return changes.concat(e.changes.map(c => {
				c = foundry.utils.duplicate(c);
				c.effect = e;
				c.priority = c.priority ?? (c.mode * 10);
				return c;
			}));
		}, []);
		changes.sort((a, b) => a.priority - b.priority);

		Patcher_Actor._applyActiveEffects_mutValues(actor, changes);

				for (let change of changes) {
			if (!change.key) continue;
			const changes = change.effect.apply(actor, change);
			Object.assign(overrides, changes);
		}

				actor.overrides = foundry.utils.expandObject(overrides);
	}

	static _applyActiveEffects_mutValues (actor, changes) {
		if (!changes.length) return;

								let rollData; 		const activeEffectsLookup = UtilActiveEffects.getAvailableEffectsLookup(actor, {isActorEffect: true});

		changes.forEach(it => {
						if (typeof it.value !== "string") return;

			const type = UtilActiveEffects.getActiveEffectType(activeEffectsLookup, it.key);

			switch (type) {
								case "object":
				case "array": {
					try {
												it.value = eval(it.value);
					} catch (e) {
												if (Util.isDebug()) console.error(...LGT, e);
					}
					break;
				}

								case undefined:
				case null:
				case "null":
				case "number": 				case "boolean": { 					if (!rollData) rollData = Patcher_Actor._applyActiveEffects_getFullRollData(actor);

					try {
						it.value = UtilDocuments.getEvaluatedExpression(actor, it.value, rollData);

												if (type === "boolean") it.value = !!it.value;
					} catch (e) {
												if (Util.isDebug()) console.error(...LGT, e);
					}

					break;
				}

				case "string": 				case "undefined": 				default: break;
			}
		});
			}

	static _applyActiveEffects_getFullRollData (actor) {
		const cpyActorData = MiscUtil.copy(actor.toObject());
		cpyActorData.effects = [];
				const cpyActor = new CONFIG.Actor.documentClass({...cpyActorData});
		cpyActor.prepareData();
		return cpyActor.getRollData();
	}

		static handleHookApplyActiveEffect (actor, change) {
		if (!Config.get("actor", "isUseExtendedActiveEffectsParser")) return;
		if (!(change.key || "").startsWith(SharedConsts.MODULE_ID_FAKE)) return;

		const key = UtilActiveEffects.getKeyFromCustomKey(change.key);

		switch (key) {
									case "system.attributes.ac.flat": {
								const {value} = change;
				const current = foundry.utils.getProperty(actor.system, key);
				if ((typeof (current) === "number") && (current >= Number(value))) return null;
				setProperty(actor.system, key, value);
				return;
							}
			
			default: console.warn(...LGT, `Unhandled custom active effect key: ${key}`);
		}
	}
}

class Patcher_Drawing {
	static handleConfigUpdate ({isInit = false} = {}) {
		try {
			return this._handleConfigUpdate_();
		} catch (e) {
			if (!isInit) throw e;
			Config.handleFailedInitConfigApplication("ui", "isFixDrawingFreehandMinDistance", e);
		}
	}

	static _handleConfigUpdate_ () {
		
		if (!MiscUtil.get(canvas, "mouseInteractionManager", "options")) return;

		if (Config.get("ui", "isFixDrawingFreehandMinDistance")) {
			if (Patcher_Drawing._CACHED_MOUSE_INTERACTION_MANAGER_OPTIONS == null) Patcher_Drawing._CACHED_MOUSE_INTERACTION_MANAGER_OPTIONS = canvas.mouseInteractionManager.options;
			canvas.mouseInteractionManager.options.dragResistance = 1;
		} else {
			if (Patcher_Drawing._CACHED_MOUSE_INTERACTION_MANAGER_OPTIONS != null) canvas.mouseInteractionManager.options = Patcher_Drawing._CACHED_MOUSE_INTERACTION_MANAGER_OPTIONS;
		}
	}
}
Patcher_Drawing._CACHED_MOUSE_INTERACTION_MANAGER_OPTIONS = null;

class Patcher_JournalSheet {
	static init () {
		this._init_sheets();
		this._init_sheetsLegacy();
	}

	static _init_sheets () {
		DocumentSheetConfig.registerSheet(JournalEntryPage, SharedConsts.MODULE_ID, JournalUrlPageSheet, {
			types: [`${SharedConsts.MODULE_ID}.url`],
			makeDefault: true,
			label: "Embedded URL",
		});

					}

	static _init_sheetsLegacy () {
		DocumentSheetConfig.registerSheet(JournalEntryPage, SharedConsts.MODULE_ID, JournalUrlPageSheetLegacy, {
												types: ["text"],
			makeDefault: false,
			label: "Embedded URL (Legacy)",
		});

		DocumentSheetConfig.registerSheet(JournalEntry, SharedConsts.MODULE_ID, JournalSheetUrlLegacy, {
			makeDefault: false,
			label: "Embedded URL",
		});
	}
}


class _JournalUrlPageSheetBase extends JournalPageSheet {
	activateListeners ($html) {
		$html
															.parent().addClass("w-100 h-100 overflow-y-hidden");
	}
}

class JournalUrlPageSheet extends _JournalUrlPageSheetBase {
	get template () {
		return `${SharedConsts.MODULE_LOCATION}/mod-template/journal/page-url-${this.isEditable ? "edit" : "view"}.hbs`;
	}
}

class JournalUrlPageSheetLegacy extends _JournalUrlPageSheetBase {
	get template () {
		return `${SharedConsts.MODULE_LOCATION}/mod-template/journal/page-url-${this.isEditable ? "edit" : "view"}-legacy.hbs`;
	}
}


class JournalSheetUrlLegacy extends DocumentSheet {
	_lastRenderedUrl = null;

	static get defaultOptions () {
		return {
			...super.defaultOptions,
			template: `${SharedConsts.MODULE_LOCATION}/mod-template/journal/sheet.hbs`,
			width: 960,
			height: 800,
			resizable: true,
			submitOnChange: true,
			submitOnClose: true,
			closeOnSubmit: false,
		};
	}

	get title () { return this.document.name; }

	async close (...args) {
		if (this.object && this.object.getFlag(SharedConsts.MODULE_ID, Consts.FLAG_IFRAME_URL)) {
			this.element.hideVe();
									this._state = Application.RENDER_STATES.CLOSED;
			return;
		}

		return super.close(...args);
	}

	render (...args) {
		const url = this.object ? this.object.getFlag(SharedConsts.MODULE_ID, Consts.FLAG_IFRAME_URL) : null;

		if (
			url === this._lastRenderedUrl
			&& this.element && this.element.length 		) {
			this.element.showVe();
			this.maximize();
			UtilApplications.bringToFront(this);
			this._state = Application.RENDER_STATES.RENDERED;
			return;
		}

		this._lastRenderedUrl = url;

		return super.render(...args);
	}
}

class Patcher_Item {
	static init () {
		this._init_tryPatchGetRollData();
	}

	static _init_tryPatchGetRollData () {
		try {
			UtilLibWrapper.addPatch(
				"CONFIG.Item.documentClass.prototype.getRollData",
				this._lw_CONFIG_Item_documentClass_prototype_getRollData,
				UtilLibWrapper.LIBWRAPPER_MODE_WRAPPER,
			);
		} catch (e) {
			console.error(...LGT, `Failed to bind getRollData handler!`, e);
		}
	}

	static handleConfigUpdate ({isInit = false} = {}) {
		this._handleConfigUpdate_togglePatches();
		try {
			return this._handleConfigUpdate_();
		} catch (e) {
			if (!isInit) throw e;
			Config.handleFailedInitConfigApplication("importSpell", "spellPointsMode");
			Config.handleFailedInitConfigApplication("importSpell", "spellPointsModeNpc", e);
		}
	}

	static _lw_CONFIG_Item_documentClass_prototype_getRollData (fn, ...args) {
		const out = fn(...args);
		return Patcher_Item._getRollData(this, out);
	}

	static _getRollData (item, rollData) {
		if (!rollData) return rollData;
		Patcher_RollData.addAdditionalRollDataBase(rollData, item);
		return rollData;
	}

	static _handleConfigUpdate_ () {
		this._handleConfigUpdate_togglePatches();
	}

	static _handleConfigUpdate_togglePatches () {
		UtilLibWrapper.togglePatch(
			"CONFIG.Item.documentClass.prototype._getUsageUpdates",
			this._lw_CONFIG_Item_documentClass_prototype_getUsageUpdates,
			UtilLibWrapper.LIBWRAPPER_MODE_WRAPPER,
			Config.get("importSpell", "spellPointsMode") !== ConfigConsts.C_SPELL_POINTS_MODE__DISABLED
			|| Config.get("importSpell", "spellPointsModeNpc") !== ConfigConsts.C_SPELL_POINTS_MODE__DISABLED,
		);
	}

	static _lw_CONFIG_Item_documentClass_prototype_getUsageUpdates (fn, ...args) {
		const out = fn(...args);
		if (!out) return out;

		const {consumeSpellLevel} = args[0];
		if (!consumeSpellLevel) return out;

		if (this?.type !== "spell") return out;

		if (!(this.parent instanceof Actor)) return out;

		const configKeyMode = Config.getSpellPointsKey({actorType: this.parent.type});

		const spellPointsMode = Config.get("importSpell", configKeyMode);
		if (spellPointsMode === ConfigConsts.C_SPELL_POINTS_MODE__DISABLED) return out;

		const mSpellLevel = /^spell(?<castAtLevel>\d+)$/.exec(`${consumeSpellLevel}`);
		if (!mSpellLevel) return out;

		const originalItem = this.parent.items.get(this.id);
		if (!originalItem) return out;

		const originalLevel = originalItem.system.level;
		if (isNaN(originalLevel)) return out;

		const castAtLevel = Number(mSpellLevel.groups.castAtLevel);
		if (castAtLevel === originalLevel) return out;

		const resource = Config.getSpellPointsResource({isValueKey: true});
		const consumeAmountBase = Parser.spLevelToSpellPoints(originalLevel);
		const consumeAmountCurrent = Parser.spLevelToSpellPoints(castAtLevel);

		const delta = Math.max(0, consumeAmountCurrent - consumeAmountBase);

		if (resource === ConfigConsts.C_SPELL_POINTS_RESOURCE__SHEET_ITEM) {
			const spellPointsItem = UtilActors.getActorSpellPointsItem({actor: this.parent});
			if (!spellPointsItem) return out;

			const toUpdate = out.resourceUpdates.find(it => it._id === spellPointsItem.id);
			if (!toUpdate) return out;

			if (toUpdate["system.uses.value"] == null) return out;

			toUpdate["system.uses.value"] -= delta;

			return out;
		}

		if (out.actorUpdates[`system.${resource}`] == null) return out;

		out.actorUpdates[`system.${resource}`] -= delta;

		return out;
	}
}

class Patcher_ModuleManagement {
	static init () {
		Hooks.on("renderModuleManagement", (app, $html) => {
			if (!Config.get("ui", "isStreamerMode")) return;

			
			const eleContent = $html.find(`.window-content`)[0] || $html[0];
			if (!eleContent) return;

			const toReplace = UtilPatcher.findPlutoniumTextNodes(eleContent);
			toReplace.forEach(node => node.data = node.data.replace(SharedConsts.MODULE_TITLE, SharedConsts.MODULE_TITLE_FAKE));
		});
	}
}

class Patcher_Application {
	static init () {
		Patcher_Application._Render.init();

		UtilLibWrapper.addPatch(
			"Application.defaultOptions",
			this._lw_Application_defaultOptions,
			UtilLibWrapper.LIBWRAPPER_MODE_WRAPPER,
		);
	}

	static _lw_Application_defaultOptions (fn, ...args) {
		if (!Config.get("ui", "isAlwaysResizableApps")) return fn(...args);
		const out = fn(...args);
		out.resizable = true;
		return out;
	}
}

Patcher_Application._Render = class {
	static init () {
		[
			"ActorSheet.prototype._render",
			"ItemSheet.prototype._render",
		]
			.forEach(it => {
				UtilLibWrapper.addPatch(
					it,
					this._lw_ActorSheetOrItemSheet_prototype__render,
					UtilLibWrapper.LIBWRAPPER_MODE_MIXED,
				);

				UtilLibWrapper.addPatch(
					`${it}Inner`,
					this._lw_ActorSheetOrItemSheet_prototype__renderInner,
					UtilLibWrapper.LIBWRAPPER_MODE_WRAPPER,
				);
			});
	}

	static _lw_ActorSheetOrItemSheet_prototype__render (fn, ...args) {
		if (!Patcher_Application._Render._isUseCustomRender(this)) return fn(...args);
		return Patcher_Application._Render._pRenderApplication.bind(this)(...args);
	}

	static async _lw_ActorSheetOrItemSheet_prototype__renderInner (fn, ...args) {
		if (!Patcher_Application._Render._isUseCustomRender(this)) return fn(...args);

						const curForm = this.form;
		const out = await fn(...args);
		this.form = curForm;
		return out;
	}

	static _isUseCustomRender (app) {
		if (!app.popOut) return false;
		if (!Config.get("ui", "isLazyActorAndItemRendering")) return false;
		return !!app.element?.length;
	}

		static async _pRenderApplication (force = false, options = {}) {
				const states = Application.RENDER_STATES;
		this._priorState = this._state;
		if ([states.CLOSING, states.RENDERING].includes(this._state)) return;

				if (!force && (this._state <= states.NONE)) return;

				if ([states.NONE, states.CLOSED, states.ERROR].includes(this._state)) {
			console.log(`${vtt} | Rendering ${this.constructor.name}`);
		}
		this._state = states.RENDERING;

				foundry.utils.mergeObject(this.options, options, { insertKeys: false });

						const data = await this.getData(this.options);

				const inner = await this._renderInner(data);

				const $inner = inner instanceof jQuery ? inner : $(inner);

		const $innerExisting = Patcher_Application._Render._doMergeElements.bind(this)({$inner});

				$innerExisting.find("*").off();

				this._activateCoreListeners($innerExisting);
		this.activateListeners($innerExisting);
		
		this._state = states.RENDERED;
	}

		static _doMergeElements ({$inner}) {
		const $element = UtilApplications.$getAppElement(this);

		if (!this.popOut) {
			throw new Error(`Application was not a popout?!`);
					}

						$element.find(".window-title").text(this.title);

		const cur = $element.find(".window-content")[0];
		const nxt = cur.cloneNode(false);

				if (cur.childNodes[0]?.nodeType === 3) {
			nxt.innerHTML = cur.childNodes[0].textContent;
		}
		nxt.appendChild($inner[0]);

						Patcher_Application._Render._recurse({cur, nxt});

		return $(cur);
	}

	static _getNodeType (node) {
		switch (node.nodeType) {
			case 3: return "fromType_text";
			case 8: return "fromType_comment";
			default: return node.tagName.toLowerCase();
		}
	}

	static _getNodeContents (node) {
		if (node.childNodes && node.childNodes.length > 0) return null;
		return node.textContent;
	}

	static _recurse ({cur, nxt}) {
		Patcher_Application._Render._recurse_updateAttributes({cur, nxt});
		Patcher_Application._Render._recurse_removeExtraChildren({cur, nxt});

		const nodesCur = [...cur.childNodes];

		[...nxt.childNodes].forEach((nodeNxt, ix) => {
			const nodeCur = nodesCur[ix];

						if (!nodeCur) {
				cur.appendChild(nodeNxt.cloneNode(true));
				return;
			}

			const typeCur = Patcher_Application._Render._getNodeType(nodeCur);

						if (Patcher_Application._Render._getNodeType(nodeNxt) !== typeCur) {
				nodeCur.parentNode.replaceChild(nodeNxt.cloneNode(true), nodeCur);
				return;
			}

						if (["fromType_text", "fromType_comment"].includes(typeCur)) {
				if (nodeCur.textContent !== nodeNxt.textContent) nodeCur.textContent = nodeNxt.textContent;
				return;
			}

			Patcher_Application._Render._recurse_updateAttributes({cur: nodeCur, nxt: nodeNxt});
			Patcher_Application._Render._recurse({cur: nodeCur, nxt: nodeNxt});

														});
	}

	static _recurse_removeExtraChildren ({cur, nxt}) {
		const nodesCur = [...cur.childNodes];
		const nodesNxt = [...nxt.childNodes];

		if ((nodesCur.length - nodesNxt.length) <= 0) return;

		const typesCur = nodesCur.map(it => Patcher_Application._Render._getNodeType(it));
		const typesNxt = nodesNxt.map(it => Patcher_Application._Render._getNodeType(it));

		const ixsCurToUse = [];

		let offsetCur = 0;
		for (let ixNxt = 0; ixNxt < typesNxt.length; ++ixNxt) {
			const ixCur = ixNxt + offsetCur;

			const typeCur = typesCur[ixCur];
			const typeNxt = typesNxt[ixNxt];

						if (typeCur === typeNxt) {
				ixsCurToUse.push(ixCur);
				continue;
			}

						for (let ixTmp = ixCur; ixTmp < typesCur.length; ++ixTmp) {
				const typeCurTmp = typesCur[ixTmp];

				if (typeCurTmp === typeNxt) {
					ixsCurToUse.push(ixTmp);
					offsetCur += ixTmp - ixCur;
					break;
				}
			}
		}

				if (!ixsCurToUse.length) {
			cur.innerHTML = "";
			return;
		}

				const ixsCurToUseSet = new Set(ixsCurToUse);
		for (let ixCur = nodesCur.length - 1; ixCur >= 0; --ixCur) {
			if (!ixsCurToUseSet.has(ixCur)) cur.removeChild(cur.childNodes[ixCur]);
		}
	}

	static _recurse_updateAttributes ({cur, nxt}) {
		const attsCur = [...cur.attributes].map(({name, textContent}) => ({name, textContent}));
		const attsNxt = [...nxt.attributes].map(({name, textContent}) => ({name, textContent}));
		if (CollectionUtil.deepEquals(attsCur, attsNxt)) return;

		const setDelete = new Set([...cur.attributes].map(it => it.name));
		[...nxt.attributes]
			.forEach(({name, textContent}) => {
				setDelete.delete(name);
				if (cur.getAttribute(name) !== nxt.getAttribute(name)) cur.setAttribute(name, textContent);
			});
		setDelete.forEach(name => nxt.removeAttribute(name));
	}
};

class Patcher_ChatLog {
	static prePreInit () {
			}
}

const _IMG = `icons/containers/chest/chest-worn-oak-tan.webp`;

class LootGenUiFvtt extends LootGenUi {
	static _er (...args) {
		return Vetools.withUnpatchedDiceRendering(() => Renderer.get().setFirstSection(true).render(...args));
	}
}

class LootGeneratorApp extends Application {
		static prePreInit () {
		this._preInit_registerKeybinds();
	}

	static _preInit_registerKeybinds () {
		game.keybindings.register(
			SharedConsts.MODULE_ID,
			"LootGeneratorApp__open",
			{
				name: "Open Loot Generator",
				editable: [],
				onDown: () => {
					const app = new this();
					app.render(true);
					return true;
				},
				restricted: true,
			},
		);
	}

	static init () {
		if (!UtilGameSettings.getSafe("core", "noCanvas")) {
			document.getElementById("board").addEventListener("drop", this._pHandleBoardDrop.bind(this));
		}
	}
	
	constructor () {
		super(
			{
				title: "Loot Generator",
				template: `${SharedConsts.MODULE_LOCATION}/template/LootGeneratorApp.hbs`,
				width: 960,
				height: Util.getMaxWindowHeight(),
				resizable: true,
			},
		);

		this._lootGenUi = null;
	}

	activateListeners ($html) {
		super.activateListeners($html);

		this._pRender($html).then(null);
	}

	async _pRender ($html) {
		this._lootGenUi = new LootGenUiFvtt({
			spells: await this._pLoadSpells(),
			items: await this._pLoadItems(),
			ClsLootGenOutput: LootGenOutputFvtt,
		});

		const $stgLhs = $html.find(`[data-name="wrp-lhs"]`);
		const $stgRhs = $html.find(`[data-name="wrp-rhs"]`);

		await this._lootGenUi.pInit();
		this._lootGenUi.render({$stgLhs, $stgRhs});
	}

	async _pLoadSpells () {
		const [stockSpells, prerelease, brew] = await Promise.all([
			DataUtil.spell.pLoadAll(),
			PrereleaseUtil.pGetBrewProcessed(),
			BrewUtil2.pGetBrewProcessed(),
		]);
		return stockSpells
			.concat(prerelease?.spell || [])
			.concat(brew?.spell || []);
	}

	async _pLoadItems () {
		const stockItems = (await Renderer.item.pBuildList()).filter(it => !it._isItemGroup);
		return stockItems
			.concat(await Renderer.item.pGetItemsFromPrerelease())
			.concat(await Renderer.item.pGetItemsFromBrew());
	}

	static async pImportLoot ({loot, actor = null, isLogToChat = false, isNotify = false, folderId, pack, isSkipCurrencies = false}) {
		if (pack && actor) throw new Error(`Only one of "pack" or "actor" may be specified!`);

		try {
			const out = await this._pImportLoot({loot, actor, isLogToChat, folderId, pack, isSkipCurrencies});
			if (isNotify) ui.notifications.info(`Imported loot${actor ? ` to actor "${actor.name}"` : ""}!`);
			return out;
		} catch (e) {
			ui.notifications.error(`Failed to import loot${actor ? ` to actor "${actor.name}"` : ""}. ${VeCt.STR_SEE_CONSOLE}`);
			setTimeout(() => { throw e; });
		}
	}

	static async _pImportLoot ({loot, actor, isLogToChat, folderId, pack, isSkipCurrencies}) {
		const cacheImporter = {}; 
		const baseOpts = {};
		if (loot.isTemp) baseOpts.isTemp = true;

		if (loot.currency && !isSkipCurrencies) {
			if (actor) await UtilActors.pAddCurrencyToActor({currency: loot.currency, actor});
			else {
				const itemImporter = await this._pImportLoot_pGetCacheImporter({cacheImporter, page: UrlUtil.PG_ITEMS, actor, pack});
				const importOpts = {...baseOpts, folderId};
				await itemImporter.pImportCurrency(loot.currency, importOpts);
			}
		}

		const importSummaries = [];
		for (const {page, entity, options} of loot.entityInfos || []) {
			const importer = await this._pImportLoot_pGetCacheImporter({cacheImporter, page, actor, pack});
			const importOpts = {...baseOpts, ...(options || {}), folderId};
			const importSummary = await importer.pImportEntry(entity, importOpts);
			importSummaries.push({importSummary: importSummary, count: options?.quantity});
		}

		const {errorMessage, htmlSummary} = this._getSummaryHtml({loot, importSummaries});

		if (errorMessage) {
			console.error(...LGT, errorMessage);
			ui.notifications.error(`Error occurred during item linking! ${VeCt.STR_SEE_CONSOLE}`);
		}

		if (isLogToChat) await this._pDoLogToChat({loot, htmlSummary, actor});

		return importSummaries;
	}

	static async _pImportLoot_pGetCacheImporter ({cacheImporter, page, actor, pack}) {
		if (!cacheImporter[page]) {
			cacheImporter[page] = ChooseImporter.getImporter(page, {actor});
			if (pack) cacheImporter[page].pack = pack;
			await cacheImporter[page].pInit();
		}

		return cacheImporter[page];
	}

	static _getSummaryHtml ({loot, importSummaries}) {
		let errorMessage = "";
		const lisImportedDatas = importSummaries
			.map(({importSummary, count}) => {
				count = count ?? 1;

				return (importSummary.imported || [])
					.map(importedDocument => {
						const ptCount = count === 1 ? "" : `${count}× `;

												if (importedDocument.embeddedDocument && importedDocument.actor) {
							return `<li class="py-1">${ptCount}@UUID[Actor.${importedDocument.actor.id}.Item.${importedDocument.embeddedDocument.id}]</li>`;
						}

												if (importedDocument.document) {
							if (importedDocument.pack) {
								return `<li class="py-1">${ptCount}@UUID[Compendium.${importedDocument.pack.metadata.packageName}.${importedDocument.pack.metadata.name}.${importedDocument.document.id}]</li>`;
							}
							return `<li class="py-1">${ptCount}@UUID[Item.${importedDocument.document.id}]</li>`;
						}

						errorMessage = `Unhandled imported document type--${Object.entries(importedDocument).map(([k, v]) => `${k}=${!!v}`).join(", ")}`;
					});
			})
			.flat();

		const htmlSummary = `<ul>
			${loot.currency ? `<li class="py-1">Currency: ${Parser.getDisplayCurrency(loot.currency)}</li>` : ""}
			${lisImportedDatas.join("")}
		</ul>`;

		return {errorMessage, htmlSummary};
	}

	static async _pDoLogToChat ({loot, htmlSummary, actor}) {
		await ChatMessage.create({
			content: `<div>
					${actor ? `<p><i>Added to the inventory of:</i> @UUID[Actor.${actor.id}]</p>` : ""}
					${htmlSummary}
				</div>`,
			user: game.userId,
			type: CONST.CHAT_MESSAGE_TYPES.WHISPER,
			speaker: {
				alias: "Loot Generator",
			},
			whisper: game.users.contents.filter(it => it.isGM || it === game.user).map(it => it.id),
		});
	}

	static async patcher_pHandleActorDrop (...args) {
		const evt = args[0];

				const data = UtilEvents.getDropJson(evt);
		if (data?.type === VeCt.DRAG_TYPE_LOOT) {
			await LootGeneratorApp.pImportLoot({loot: data.data, actor: this.actor});
			return true;
		}

				if (data?.type === "JournalEntryPage") {
			const doc = await fromUuid(data.uuid);
			if (doc?.flags?.[SharedConsts.MODULE_ID]?.type === LootGenOutputFvtt.FLAG_TYPE__LOOT) {
				await LootGeneratorApp.pImportLoot({
					loot: doc.flags[SharedConsts.MODULE_ID].loot,
					actor: this.actor,
				});
				return true;
			}
		}
	}

	static _pHandleBoardDrop (evt) {
		const data = UtilEvents.getDropJson(evt);

		if (data?.type !== VeCt.DRAG_TYPE_LOOT) return;

		if (UtilCompat.isItemPilesActive()) {
			LootGenOutputFvtt.pImportToItemPile({loot: data.data, evt}).then(null);
			return false;
		}

		const canvasPos = UtilCanvas.getPosCanvasSpace(evt, "NotesLayer");
		const canvasPosSnapped = canvas.grid.getSnappedPosition(canvasPos.x, canvasPos.y);

		LootGenOutputFvtt.pImportToJournal({loot: data.data})
			.then(async journalDocument => {
				await canvas.scene.createEmbeddedDocuments(
					"Note",
					[
						{
							entryId: journalDocument.id,
							icon: _IMG,
							iconSize: canvas.grid.size,
							text: "",
							x: canvasPosSnapped.x - (canvas.grid.size / 2),
							y: canvasPosSnapped.y - (canvas.grid.size / 2),
						},
					],
				);
			});

				return false;
	}
}

class LootGenOutputFvtt extends LootGenOutput {
	_$getEleTitleSplit () {
		const $btnImportToJournal = $(`<button title="Import to Journal" class="btn btn-xs btn-default"><i class="fas fa-fw fa-book-open mr-0"></i></button>`)
			.click(() => this._pImportToJournal());

		const $btnImportToFolder = $(`<button title="Import to Items Folder" class="btn btn-xs btn-default"><i class="fas fa-fw fa-folder mr-0"></i></button>`)
			.click(async () => this.constructor._pImportToFolder({loot: await this._pGetFoundryForm()}));

		const $btnImportToCompendium = $(`<button title="Import to Compendium" class="btn btn-xs btn-default"><i class="fas fa-fw fa-atlas mr-0"></i></button>`)
			.click(() => this._pImportToCompendium());

		return $$`<div class="ve-flex-v-center btn-group">
			${$btnImportToFolder}
			${$btnImportToJournal}
			${$btnImportToCompendium}
		</div>`;
	}

	static async pImportToJournal ({loot}) {
		const lisLinks = [];
		for (const {page, entity, options} of loot.entityInfos || []) {
			const tagName = page === UrlUtil.PG_ITEMS ? "item" : "spell";
			const count = options?.quantity ?? 1;
			const ptCount = count === 1 ? "" : `${count}× `;
			lisLinks.push(`<li class="py-1">${ptCount}@${tagName}[${entity.name}|${entity.source}]{${entity.name}}</li>`);
		}

		const htmlSummary = `<ul>
			${loot.currency ? `<li class="py-1">Currency: ${Parser.getDisplayCurrency(loot.currency)}</li>` : ""}
			${lisLinks.join("")}
		</ul>`;

		const existingJournal = game.journal.find(it => it.flags?.[SharedConsts.MODULE_ID]?.type === LootGenOutputFvtt.FLAG_TYPE__LOOT_BINDER);

		const name = `Loot (${Renderer.stripTags(loot.name)})`;
		const page = 	{
			name,
			type: "text",
			text: {
				format: 1,
				content: htmlSummary,
			},
			sort: (existingJournal?.pages?.size ?? 0) * 100000,
			flags: {
				[SharedConsts.MODULE_ID]: {
					type: LootGenOutputFvtt.FLAG_TYPE__LOOT,
					loot,
				},
			},
		};

		if (existingJournal) {
			UtilDocuments.pCreateEmbeddedDocuments(
				existingJournal,
				[
					page,
				],
				{
					ClsEmbed: JournalEntryPage,
				},
			);

			ui.sidebar.activateTab("journal");
			ui.notifications.info(`Imported loot to journal entry "${existingJournal.name}"`);

			return;
		}

		const journalData = {
			name: "Loot",
			pages: [
				page,
			],
			ownership: {default: 0},
			flags: {
				[SharedConsts.MODULE_ID]: {
					type: LootGenOutputFvtt.FLAG_TYPE__LOOT_BINDER,
				},
			},
		};

		const docJournal = await CONFIG.JournalEntry.documentClass.create(journalData, {renderSheet: false, temporary: false});
		ui.sidebar.activateTab("journal");
		ui.notifications.info(`Imported loot to journal entry "${docJournal.name}"`);
	}

	async _pImportToJournal () {
		const loot = await this._pGetFoundryForm();
		await this.constructor.pImportToJournal({loot});
	}

	static async _pImportToFolder ({loot, isSkipCurrencies = false}) {
		const {$modalInner, doClose, pGetResolved, doAutoResize: doAutoResizeModal} = await UtilApplications.pGetShowApplicationModal({
			title: `Import Loot to Items Folder`,
		});

		const $wrpEditFolderPath = $$`<div class="w-100 ve-flex-col"></div>`;
		const pathBuilder = new FolderPathBuilder({
			defaultFolderPathSpec: [
				"Loot",
				loot.type,
				`(Unnamed ${DatetimeUtil.getDatetimeStr({date: new Date(loot.dateTimeGenerated), isPlainText: true})})`,
			],
			fnOnRowKeydown: evt => {
				if (evt.key !== "Enter") return;
				$btnOk.click();
			},
			folderType: "Item",
		});
		pathBuilder.render($wrpEditFolderPath);

		const $btnOk = $(`<button class="btn btn-primary mr-2">OK</button>`)
			.click(() => doClose(true, pathBuilder.getFolderPathStrings()));

		const $btnCancel = $(`<button class="btn btn-default">Cancel</button>`)
			.click(() => doClose(false));

		$$($modalInner)`<div class="ve-flex-col w-100 h-100 pt-2">
			${$wrpEditFolderPath}

			<div class="ve-flex-v-center ve-flex-h-right no-shrink pb-1 pt-1 px-1 mt-auto mr-3">${$btnOk}${$btnCancel}</div>
		</div>`;

		doAutoResizeModal();

		const [isDataEntered, folderPathStrings] = (await pGetResolved());
		if (!isDataEntered || !folderPathStrings) return;

		const folderId = await UtilFolders.pCreateFoldersGetId({
			folderType: "Item",
			folderNames: folderPathStrings,
		});

		const out = await LootGeneratorApp.pImportLoot({loot, folderId, isSkipCurrencies});
		ui.sidebar.activateTab("items");
		ui.notifications.info(folderPathStrings.length ? `Imported loot to items folder "${folderPathStrings.join("/")}".` : `Imported loot to items directory.`);
		return out;
	}

	async _pImportToCompendium () {
		let selPack = null;

		if (!UtilCompendium.getAvailablePacks({folderType: "Item"}).length) {
			const isCreate = await InputUiUtil.pGetUserBoolean({
				title: `Create Compendium`,
				htmlDescription: `No unlocked "Item"-type compendiums currently exist. Would you like to create one?`,
				textYes: "Yes",
				textNo: "No",
			});
			if (!isCreate) return;

			selPack = await UtilCompendium.pGetUserCreatePack({folderType: "Item"});
			if (!selPack) return;
		}

		if (!selPack) {
			const {$modalInner, doClose, pGetResolved, doAutoResize: doAutoResizeModal} = await UtilApplications.pGetShowApplicationModal({
				title: `Import Loot to Items Compendium`,
			});

			const setSelPack = () => selPack = UtilCompendium.getPackByCollection({collection: $selCompendium.val()});

			const $selCompendium = UtilCompendium.$getSelCompendium({folderType: "Item"})
				.change(() => setSelPack());
			setSelPack();

			const $btnOk = $(`<button class="btn btn-primary mr-2">OK</button>`)
				.click(() => doClose(true));

			const $btnCancel = $(`<button class="btn btn-default">Cancel</button>`)
				.click(() => doClose(false));

			$$($modalInner)`<div class="ve-flex-col w-100 h-100 pt-2">
				${$selCompendium}
				<div class="ve-flex-v-center ve-flex-h-right no-shrink pb-1 pt-1 px-1 mt-auto mr-3">${$btnOk}${$btnCancel}</div>
			</div>`;

			doAutoResizeModal();

			const [isSel] = await pGetResolved();
			if (!isSel) selPack = null;
		}

		if (!selPack) return;

		const loot = await this._pGetFoundryForm();
		const out = await LootGeneratorApp.pImportLoot({loot, pack: selPack});
		ui.sidebar.activateTab("compendium");
		ui.notifications.info(`Imported loot to compendium "${selPack.metadata.label}"`);
		return out;
	}

	static async pImportToItemPile ({loot, evt}) {
		const canvasPos = UtilCanvas.getPosCanvasSpace(evt, "TokenLayer");
		const canvasPosSnapped = canvas.grid.getSnappedPosition(canvasPos.x, canvasPos.y);

		const importSummaries = await this._pImportToFolder({loot, isSkipCurrencies: true});

		const items = importSummaries
			.map(({importSummary}) => (importSummary?.imported || []).map(it => it.document).filter(Boolean))
			.flat();

		const pileTokenUuid = await ItemPiles.API.createItemPile(canvasPosSnapped, {items});

		const target = await fromUuid(pileTokenUuid);

		if (!loot.currency) return;

								const toAdd = Object.entries(loot.currency)
			.mergeMap(([coin, amount]) => ({[`system.currency.${coin}`]: amount}));
		await ItemPiles.API.addAttributes(target, toAdd);
	}
}
LootGenOutputFvtt._STO_K_FOLDER_PATH_SPEC = "LootGenOutputFvtt.folderKeyPathSpec";
LootGenOutputFvtt.FLAG_TYPE__LOOT_BINDER = "lootBinder";
LootGenOutputFvtt.FLAG_TYPE__LOOT = "loot";

var LootGeneratorApp$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    LootGeneratorApp: LootGeneratorApp
});

class Patcher_ActorSheet {
	static init () {
						UtilLibWrapper.addPatch(
			"ActorSheet.prototype._onDrop",
			this._lw_ActorSheet_prototype__onDrop,
			UtilLibWrapper.LIBWRAPPER_MODE_MIXED,
		);
			}

	static async _lw_ActorSheet_prototype__onDrop (fn, ...args) {
		const fnsSub = [
			ImportList.patcher_pHandleActorDrop,
			LootGeneratorApp.patcher_pHandleActorDrop,
		];
		for (const fn of fnsSub) {
			const out = await fn.bind(this)(...args);
			if (out) return out; 		}
		return fn(...args);
	}
}

class Patcher_Notifications {
	static _MARKER = "__PLUT_REPLACE_MARKER__";
	static _CACHE_STRING_START = null;
	static _CACHE_STRING_END = null;

	static init () {
		UtilLibWrapper.addPatch(
			"ui.notifications.notify",
			this._lw_ui_notifications_notify,
			UtilLibWrapper.LIBWRAPPER_MODE_MIXED,
		);

		const sampleMessage = game.i18n.format("DICE.WarnMissingData", {match: Patcher_Notifications._MARKER});
		const [start, end] = sampleMessage.split(Patcher_Notifications._MARKER);
		Patcher_Notifications._CACHE_STRING_START = start;
		Patcher_Notifications._CACHE_STRING_END = end;
	}

	static _lw_ui_notifications_notify (fn, ...args) {
		if (!Config.get("ui", "isSuppressMissingRollDataNotifications")) return fn(...args);

		if (!Patcher_Notifications._isSuppressed(...args)) return fn(...args);

		const [message] = args;
		if (!UtilNotifications.isAddSeen({message})) console.warn(...LGT, message);
	}

	static _isSuppressed (message, type) {
		if (type !== "warning") return false;
		if (typeof message !== "string") return false;
		if (!message.startsWith(Patcher_Notifications._CACHE_STRING_START) || !message.endsWith(Patcher_Notifications._CACHE_STRING_END)) return false;
		return true;
	}
}

class Patcher_KeybindingsConfig {
	static init () {
		Hooks.on("renderKeybindingsConfig", (app, $html) => {
			if (!Config.get("ui", "isStreamerMode")) return;

						$html.find(`.filter[data-category="${SharedConsts.MODULE_ID}"]`).html(SharedConsts.MODULE_TITLE_FAKE);

						$html.find(`.category[data-category-id="${SharedConsts.MODULE_ID}"] h3.category-title`).html(SharedConsts.MODULE_TITLE_FAKE);
		});
	}
}

class Patcher_SceneControls {
	
	static prePreInit () {
		this._addMissingBoxSelectControls();

		this._addBoxSelectSupport_measure();
		this._addBoxSelectSupport_lighting();
		this._addBoxSelectSupport_sounds();
		this._addBoxSelectSupport_notes();
	}

	
	static _BOX_SELECT_TOOL_METAS = [
		{
			groupName: "measure",
			title: "CONTROLS.MeasureSelect",
		},
		{
			groupName: "lighting",
			title: "CONTROLS.LightSelect",
		},
		{
			groupName: "sounds",
			title: "CONTROLS.SoundSelect",
		},
	];

	static _addMissingBoxSelectControls () {
		Hooks.on("getSceneControlButtons", (buttonMetas) => {
			if (!game.user.isGM) return;

			this._BOX_SELECT_TOOL_METAS.forEach(addMeta => {
				const buttonMeta = buttonMetas.find(it => it.name === addMeta.groupName);
				const isExists = buttonMeta.tools.some(it => it.name === "select");

				if (isExists) return;
				buttonMeta.tools.unshift({
					name: "select",
					title: addMeta.title,
					icon: "fas fa-expand",
				});
			});
		});
	}

	static _addBoxSelectSupport_measure () {
		UtilLibWrapper.addPatch(
			"TemplateLayer.layerOptions",
			this._lw_TemplateLayer_layerOptions,
			UtilLibWrapper.LIBWRAPPER_MODE_WRAPPER,
		);

		UtilLibWrapper.addPatch(
			"TemplateLayer.prototype._onDeleteKey",
			this._lw_TemplateLayer_prototype__onDeleteKey,
			UtilLibWrapper.LIBWRAPPER_MODE_OVERRIDE,
		);

		UtilLibWrapper.addPatch(
			"MeasuredTemplate.prototype.refresh",
			this._lw_MeasuredTemplate_prototype_refresh,
			UtilLibWrapper.LIBWRAPPER_MODE_WRAPPER,
		);
	}

	static _lw_TemplateLayer_layerOptions (fn, ...args) {
		const out = fn(...args);
		out.controllableObjects = true;
		return out;
	}

	static _lw_TemplateLayer_prototype__onDeleteKey (fn, ...args) {
		return Patcher_SceneControls._placeablesLayer_onDeleteKey_controlledOrHover.bind(this)(...args);
	}

	static _lw_MeasuredTemplate_prototype_refresh (fn, ...args) {
		const out = fn(...args);
		this.controlIcon.border.visible = this.hover || this.controlled;
		return out;
	}

	static _addBoxSelectSupport_lighting () {
		UtilLibWrapper.addPatch(
			"LightingLayer.layerOptions",
			this._lw_LightingLayer_layerOptions,
			UtilLibWrapper.LIBWRAPPER_MODE_WRAPPER,
		);

		UtilLibWrapper.addPatch(
			"LightingLayer.prototype._onDeleteKey",
			this._lw_LightingLayer_prototype__onDeleteKey,
			UtilLibWrapper.LIBWRAPPER_MODE_OVERRIDE,
		);

		UtilLibWrapper.addPatch(
			"AmbientLight.prototype.refreshControl",
			this._lw_AmbientLight_prototype_refreshControl,
		);

																
		UtilLibWrapper.addPatch(
			"PointSource.prototype.destroy",
			this._lw_PointSource_prototype_destroy,
			UtilLibWrapper.LIBWRAPPER_MODE_WRAPPER,
		);

		UtilLibWrapper.addPatch(
			"LightSource.prototype.drawMeshes",
			this._lw_LightSource_prototype_drawMeshes,
			UtilLibWrapper.LIBWRAPPER_MODE_MIXED,
		);

			}

	static _lw_LightingLayer_layerOptions (fn, ...args) {
		const out = fn(...args);
		out.controllableObjects = true;
		return out;
	}

	static _lw_LightingLayer_prototype__onDeleteKey (...args) {
		return Patcher_SceneControls._placeablesLayer_onDeleteKey_controlledOrHover.bind(this)(...args);
	}

	static _lw_AmbientLight_prototype_refreshControl (fn, ...args) {
		const out = fn(...args);
		this.controlIcon.border.visible = this.hover || this.controlled;
		return out;
	}

	static _lw_PointSource_prototype_destroy (fn, ...args) {
		this._meshesDestroyed = true;
		return fn(...args);
	}

	static _lw_LightSource_prototype_drawMeshes (fn, ...args) {
		if (this._meshesDestroyed) return {};
		return fn(...args);
	}

	static _addBoxSelectSupport_sounds () {
		UtilLibWrapper.addPatch(
			"SoundsLayer.layerOptions",
			this._lw_SoundsLayer_layerOptions,
			UtilLibWrapper.LIBWRAPPER_MODE_WRAPPER,
		);

		UtilLibWrapper.addPatch(
			"SoundsLayer.prototype._onDeleteKey",
			this._lw_SoundsLayer_prototype__onDeleteKey,
			UtilLibWrapper.LIBWRAPPER_MODE_OVERRIDE,
		);

		UtilLibWrapper.addPatch(
			"AmbientSound.prototype.refreshControl",
			this._lw_AmbientSound_prototype_refreshControl,
			UtilLibWrapper.LIBWRAPPER_MODE_WRAPPER,
		);
	}

	static _lw_SoundsLayer_layerOptions (fn, ...args) {
		const out = fn(...args);
		out.controllableObjects = true;
		return out;
	}

	static _lw_SoundsLayer_prototype__onDeleteKey (...args) {
		return Patcher_SceneControls._placeablesLayer_onDeleteKey_controlledOrHover.bind(this)(...args);
	}

	static _lw_AmbientSound_prototype_refreshControl (fn, ...args) {
		const out = fn(...args);
		this.controlIcon.border.visible = this.hover || this.controlled;
		return out;
	}

	static _addBoxSelectSupport_notes () {
		UtilLibWrapper.addPatch(
			"NotesLayer.layerOptions",
			this._lw_NotesLayer_layerOptions,
			UtilLibWrapper.LIBWRAPPER_MODE_WRAPPER,
		);

		UtilLibWrapper.addPatch(
			"NotesLayer.prototype._onDeleteKey",
			this._lw_NotesLayer_prototype__onDeleteKey,
			UtilLibWrapper.LIBWRAPPER_MODE_OVERRIDE,
		);

		UtilLibWrapper.addPatch(
			"Note.prototype.refresh",
			this._lw_Note_prototype_refresh,
			UtilLibWrapper.LIBWRAPPER_MODE_WRAPPER,
		);
	}

	static _lw_NotesLayer_layerOptions (fn, ...args) {
		const out = fn(...args);
		out.controllableObjects = true;
		return out;
	}

	static _lw_NotesLayer_prototype__onDeleteKey (...args) {
		return Patcher_SceneControls._placeablesLayer_onDeleteKey_controlledOrHover.bind(this)(...args);
	}

	static _lw_Note_prototype_refresh (fn, ...args) {
		const out = fn(...args);
		this.controlIcon.border.visible = this.hover || this.controlled;
		return out;
	}

		static _placeablesLayer_onDeleteKey_controlledOrHover = async function (evt) {
						let objects = this.options.controllableObjects && this.controlled?.length
			? this.controlled
			: (this.hover ? [this.hover] : []);
		if (!objects.length) return;

				const ids = objects.reduce((ids, o) => {
			if (o.document.locked || !o.document.canUserModify(game.user, "delete")) return ids;
			ids.push(o.id);
			return ids;
		}, []);
		if (ids.length) return canvas.scene.deleteEmbeddedDocuments(this.constructor.documentName, ids);
	};
}

class Patcher_Tooltips {
	static _ACTIVATION_MS_FAST = 300;
	static _ACTIVATION_MS_DEFAULT = null;

	static init () {
		this._ACTIVATION_MS_DEFAULT = TooltipManager.TOOLTIP_ACTIVATION_MS || 500;

		Hooks.on(`${SharedConsts.MODULE_ID_FAKE}.configUpdate`, () => this._handleConfigUpdate());
		this._handleConfigUpdate();
	}

	static _handleConfigUpdate () {
		if (!Config.get("ui", "isFastTooltips")) {
			TooltipManager.TOOLTIP_ACTIVATION_MS = this._ACTIVATION_MS_DEFAULT;
			return;
		}
		TooltipManager.TOOLTIP_ACTIVATION_MS = this._ACTIVATION_MS_FAST;
	}
}

class Patcher_QuickInsert {
	static init () {
		if (!UtilCompat.isQuickInsertActive()) return;
		if (!Config.get("integrationQuickInsert", "isEnabled")) return;

		this._init_doPatch();
	}

	static _init_doPatch () {
		let value = null;

		Object.defineProperty(
			globalThis.QuickInsert,
			"searchLib",
			{
				get () { return value; },
				set (valueNxt) {
					const cache = valueNxt.indexCompendiums.bind(valueNxt);
					valueNxt.indexCompendiums = async function (...args) {
						const out = await cache(...args);
						await Patcher_QuickInsert._pDoIndexPlutoniumData();
						return out;
					};
					value = valueNxt;
				},
			},
		);
	}

	static _NO_INDEX_CATS = new Set([
		Parser.CAT_ID_SKILLS,
		Parser.CAT_ID_SENSES,
		Parser.CAT_ID_ADVENTURE,
		Parser.CAT_ID_BOOK,
	]);

	static async _pDoIndexPlutoniumData () {
		const data = Omnidexer.decompressIndex(await DataUtil.loadJSON(`${Renderer.get().baseUrl}search/index-foundry.json`));

		const quickInsertIndexingDisabled = UtilGameSettings.getSafe(UtilCompat.MODULE_QUICK_INSERT, "indexingDisabled");

		const isFilterUa = Config.get("integrationQuickInsert", "isFilterSourcesUa");
		const filteredPages = Config.get("integrationQuickInsert", "pagesHidden");
		const seenUuids = new Set();

		let id = 0;

		for (const d of data) {
			if (!d.h) continue; 
			if (Patcher_QuickInsert._NO_INDEX_CATS.has(d.c)) continue;

			const page = UrlUtil.categoryToHoverPage(d.c);
			if (!page) continue;

			if (filteredPages[page]) continue;

			const importerMeta = ChooseImporter.getImporterClassMeta(d.t);
			if (!importerMeta) continue;

			if (isFilterUa && SourceUtil.isNonstandardSource(d.s)) continue;

			if (await this._isIndexItemBlocklisted(d)) continue;

			const {Class: Importer} = importerMeta;

			if (this._isDocumentTypeIgnored({quickInsertIndexingDisabled, Importer})) continue;

			const searchItem = new PlutoniumSearchItem({
								id: d.id,
				name: d.n,
				hash: d.u,
				page,
				source: d.s,
												tag: d.t,
				uid: d.uu,
				img: Vetools.getInternalImageUrl(d.m, {isSkipEncode: true}),
								Importer,
			});
			id = Math.max(d.id, id);

						if (seenUuids.has(searchItem.uuid)) {
				console.error(`Duplicate UUID: ${searchItem.uuid}`);
				continue;
			}
			seenUuids.add(searchItem.uuid);

			QuickInsert.searchLib.addItem(searchItem);
		}

				if (!UtilWorldDataSourceSelector.isSourceSelectionActive()) return;

		const sources = await this._pGetSources();

		if (UtilDataSource.isTooManySources({cntSources: sources.length})) {
			console.log(...LGT, `Skipped loading prerelease/homebrew\u2014too many sources selected! Increase the "Auto-Selected Source Count Warning Threshold" Data Sources Config option, or reduce the number of sources auto-selected by the "Force Select All for ..." Data Sources Config Option.`);
			return;
		}

		const allContentMeta = await UtilDataSource.pGetAllContent({
			sources,
			isAutoSelectAll: true,
		});
		if (!allContentMeta) return null;

		for (const [prop, arr] of Object.entries(allContentMeta.dedupedAllContentMerged)) {
			if (!(arr instanceof Array)) continue;

			if (!UrlUtil.URL_TO_HASH_BUILDER[prop]) continue;

			const tag = Parser.getPropTag(prop);
			const importerMeta = ChooseImporter.getImporterClassMeta(tag);
			if (!importerMeta) continue;

			const {Class: Importer} = importerMeta;

			if (this._isDocumentTypeIgnored({quickInsertIndexingDisabled, Importer})) continue;

			const page = Renderer.tag.getPage(tag);
			if (!page) continue;

			for (const ent of arr) {
				if (this._isEntityBlocklisted({prop, ent})) continue;

				const searchItem = new PlutoniumSearchItem({
					id: ++id,
					name: ent.name,
					hash: UrlUtil.URL_TO_HASH_BUILDER[prop](ent),
					page,
					source: ent.source,

					tag,
					uid: DataUtil.proxy.getUid(prop, ent),
					img: await this._pGetPrereleaseBrewImageUrl({prop, ent}),

					Importer,
				});

								if (seenUuids.has(searchItem.uuid)) {
					console.error(`Duplicate UUID: ${searchItem.uuid}`);
					continue;
				}
				seenUuids.add(searchItem.uuid);

				QuickInsert.searchLib.addItem(searchItem);
			}
		}
	}

	static async _isIndexItemBlocklisted (d) {
		const prop = Parser.pageCategoryToProp(d.c);
		if (prop !== "item") {
			return ExcludeUtil.isExcluded(d.u, prop, d.s, {isNoCount: true});
		}

		const item = await DataLoader.pCacheAndGetHash(UrlUtil.PG_ITEMS, d.u);
		return Renderer.item.isExcluded(item, {hash: d.u});
	}

	static _isEntityBlocklisted ({prop, ent}) {
		const hash = UrlUtil.URL_TO_HASH_BUILDER[prop](ent);
		if (prop !== "item") return ExcludeUtil.isExcluded(hash, prop, ent.source, {isNoCount: true});
		return Renderer.item.isExcluded(ent, {hash});
	}

	static _isDocumentTypeIgnored ({quickInsertIndexingDisabled, Importer}) {
		return quickInsertIndexingDisabled?.entities?.[Importer.FOLDER_TYPE]?.includes
			&& quickInsertIndexingDisabled.entities[Importer.FOLDER_TYPE].includes(game.user?.role);
	}

	static async _pGetPrereleaseBrewImageUrl ({prop, ent}) {
		if (await Vetools.pHasTokenUrl(prop, ent, {isSilent: true})) return Vetools.pGetTokenUrl(prop, ent);

		const fluff = await Renderer.utils.pGetPredefinedFluff(ent, `${prop}Fluff`);
		return Vetools.pGetImageUrlFromFluff(fluff);
	}

	static async _pGetSources () {
		return [
			...(await UtilDataSource.pGetSourcesBrew(["*"], {pPostLoad: this._pPostLoad.bind(this, {isBrew: true})})),
			...(await UtilDataSource.pGetSourcesPrerelease(["*"], {pPostLoad: this._pPostLoad.bind(this, {isPrerelease: true})})),
		].filter(dataSource => !UtilWorldDataSourceSelector.isFiltered(dataSource));
	}

	static async _pPostLoad ({isBrew = false, isPrerelease = false}, out) {
		out = await UtilDataSource.pPostLoadGeneric({isBrew, isPrerelease}, out);
		return out;
	}
}

class PlutoniumSearchItem {
	constructor (
		{
			id,
			name,
			hash,
			page,
			source,
			tag,
			uid,
			Importer,
			img,
		},
	) {
		this.id = `${id}`.padStart(16, "0");
		this.name = name;
		this.documentType = Importer.FOLDER_TYPE;
		this.img = img;

		this._uid = uid;
		this._name = name;
		this._hash = hash;
		this._page = page;
		this._source = source;
		this._tag = tag;
		this._Importer = Importer;
	}

	get dragData () {
		return {
			type: this.documentType,
			subType: UtilEvents.EVT_DATA_SUBTYPE__HOVER,
			page: this._page,
			source: this._source,
			hash: this._hash,
									originalText: `${this._tag}[${this._uid.split("|").map((it, i) => i !== 0 ? it : it.uppercaseFirst()).join("|")}]`,
			uuid: this.uuid,
		};
	}

	get uuid () {
		return `@${this._tag}[${this._uid}|${this._name}]`;
	}

	get icon () {
		return `<i class="${CONFIG[this.documentType].sidebarIcon} entity-icon"></i>`;
	}

	get journalLink () {
		return `@${this._tag}[${this._uid}]`;
	}

	get script () {
		return `DataLoader.pCacheAndGet("${this._page}", "${this._source}", "${this._hash}")`;
	}

	get tagline () {
		return `${this._Importer.DISPLAY_NAME_TYPE_PLURAL} (${Config.get("ui", "isStreamerMode") ? SharedConsts.MODULE_TITLE_FAKE : SharedConsts.MODULE_TITLE})`;
	}

	async show () {
		(await this.get())?.sheet?.render(true);
	}

	async get () {
		const ent = await DataLoader.pCacheAndGet(this._page, this._source, this._hash);
		if (!ent) {
			console.error(...LGT, `Failed to load "${this._hash}" for page "${this._page}"!`);
			return null;
		}

		const importer = ChooseImporter.getImporter(this._tag) || ChooseImporter.getImporter(this._page);
		await importer.pInit();

		const userOwnership = game.user.isGM ? null : {[game.user.id]: CONST.DOCUMENT_OWNERSHIP_LEVELS.OWNER};

		const importSummary = await importer.pImportEntry(
			ent,
			{
				isTemp: true,
				userOwnership,
				isAddDefaultOwnershipFromConfig: false,
			},
		);

		return (importSummary.imported || [])
			.map(it => it.document)
			.filter(Boolean)[0];
	}

	get tooltip () {
		const type = game.i18n.localize(CONFIG[this.documentType]?.documentClass?.metadata?.label);
		return `${type}, ${this.tagline}`;
	}
}

class Patcher_Utils {
	static init () {
		this._doPatchSlugify();
		this._doPatchFromUuid();
	}

	static _doPatchSlugify () {
		if (!UtilVersions.getCoreVersion().isVersionElevenPlus) {
			String.prototype.slugify = Util.Slugify.slugifyFast;
		}
	}

	static _doPatchFromUuid () {
		if (!Config.get("misc", "isPatchFromUuid")) return;

		const fromUuidOriginal = UtilPatch.cacheMethod(globalThis, "fromUuid");
		globalThis.fromUuid = this._lwx_fromUuid.bind(window, fromUuidOriginal);
	}

	static async _lwx_fromUuid (fn, uuid, relative, ...argsRest) {
		if (relative) return fn(uuid, relative, ...argsRest);
		if (!uuid) return fn(uuid, relative, ...argsRest);
		if (!UtilDragDrop.isCustomUuid(uuid)) return fn(uuid, relative, ...argsRest);

		const mParts = /^@(?<tag>[a-z][a-zA-Z]+)\[(?<text>[^\]]+)]$/.exec(uuid);
		if (!mParts) {
			console.error(...LGT, `Failed to parse custom UUID "${uuid}"!`);
			return null;
		}

		const {tag, text} = mParts.groups;

		const {ChooseImporter} = await Promise.resolve().then(function () { return ChooseImporter$1; });
		const importer = ChooseImporter.getImporter(tag);

		const {page, pageHover, source, hash, hashHover} = Renderer.utils.getTagMeta(`@${tag}`, text);

		const ent = await DataLoader.pCacheAndGet(pageHover || page, source, hashHover || hash, {isCopy: true});

		if (!ent) {
			console.error(...LGT, `Failed to load "${hashHover || hash}" for page "${pageHover || page}"!`);
			return null;
		}

		await importer.pInit();
		const importSummary = await importer.pImportEntry(
			ent,
			{
												userOwnership: game.user.isGM ? null : {[game.user.id]: CONST.DOCUMENT_OWNERSHIP_LEVELS.OWNER},
				isAddDefaultOwnershipFromConfig: false,
			},
		);

		UtilApplications.doShowImportedNotification(importSummary);

		return importSummary?.getPrimaryDocument();
	}
}

class Patcher {
	static prePreInit () {
		Patcher_ChatLog.prePreInit();
		Patcher_GameKeyboard.prePreInit();
		Patcher_SceneControls.prePreInit();
		Patcher_TextEditor.prePreInit();
	}

	static init () {
		Patcher_Notifications.init();

		Hooks.on("applyActiveEffect", Patcher_Actor.handleHookApplyActiveEffect.bind(Patcher_Actor));

		this._doPatchNavContextMenuOptions();
		this._doPatchContextMenuOptions();
		this._doPatchTempSheetHeaderButtons();
		Patcher_Utils.init();
		Patcher_Application.init();
		Patcher_Token.init();
		Patcher_ChatMessage.init();
		Patcher_SettingsConfig.init();
		Patcher_CanvasAnimation.init();
		Patcher_Jquery.init();
		Patcher_GameKeyboard.init();
		Patcher_ActiveEffectConfig.init();
		Patcher_Actor.init();
		Patcher_ActorSheet.init();
		Patcher_Item.init();
		Patcher_RollData.init();
		Patcher_ModuleManagement.init();
		Patcher_KeybindingsConfig.init();
		Patcher_JournalSheet.init();
		Patcher_Tooltips.init();
		Patcher_QuickInsert.init();

		UtilHooks.on(UtilHooks.HK_CONFIG_UPDATE, (diff) => this._handleConfigUpdate(diff));
		this._handleConfigUpdate({isInit: true});

				Patcher_Actor.lateInit();

				Hooks.on("canvasReady", () => {
			Patcher_Drawing.handleConfigUpdate();
		});
			}

	static _handleConfigUpdate ({isInit = false, ...diff} = {}) {
		this._handleConfigUpdate_folderMaxDepth({isInit});
		Patcher_Token.handleConfigUpdate({isInit, ...diff});
		Patcher_Drawing.handleConfigUpdate({isInit});
		Patcher_ChatMessage.handleConfigUpdate({isInit});
		Patcher_Item.handleConfigUpdate({isInit});

				if (ui.nav?.element) ui.nav.render();
	}

	static _doPatchNavContextMenuOptions () {
		Hooks.on("getSceneNavigationContext", ($html, options) => {
			if (!Config.get("ui", "isAddDeleteToSceneNavOptions")) return;

			const ixConfigure = options.findIndex(it => it.name === "SCENES.Configure");
			const toAdd = {
				name: "SIDEBAR.Delete",
				icon: `<i class="fas fa-fw fa-trash"></i>`,
				condition: $li => {
					const scene = game.scenes.get($li.data("sceneId"));
					return game.user.isGM && !scene.active;
				},
				callback: $li => {
					const document = CONFIG.Scene.collection.instance.get($li.data("sceneId"));
					if (!document) return;
					const {top, left} = $li[0].getBoundingClientRect();
					return document.deleteDialog({
						top: Math.min(top + 70, window.innerHeight - 350),
						left: Math.min(left, window.innerWidth - 720),
					});
				},
			};

			if (~ixConfigure) options.splice(ixConfigure + 1, 0, toAdd);
			else options.push(toAdd);

			return options;
		});
	}

	static _doPatchContextMenuOptions () {
		Hooks.on("getActorDirectoryEntryContext", ($html, options) => {
			if (game.user.role >= Config.get("rivet", "minimumRole")) {
				options.push({
					name: "Set as Rivet Target",
					icon: `<i class="fas fa-fw fa-hammer"></i>`,
					condition: li => {
						const entity = ActorDirectory.collection.get(li.data("documentId"));
						return entity.isOwner;
					},
					callback: li => {
						const entity = ActorDirectory.collection.get(li.data("documentId"));
						const actor = game.actors.get(entity.id);
						Config.setRivetTargetDocument({actor});
					},
				});
			}

			return options;
		});

		Hooks.on("getCompendiumDirectoryEntryContext", ($html, options) => {
			if (game.user.role >= Config.get("rivet", "minimumRole")) {
				options.push({
					name: "Set as Rivet Target",
					icon: `<i class="fas fa-fw fa-hammer"></i>`,
					callback: li => {
						const pack = game.packs.get(li.data("pack"));
						Config.setRivetTargetDocument({pack});
					},
				});
			}

			return options;
		});

		[
			{Clazz: Scene},
			{Clazz: Actor},
			{Clazz: Item},
			{Clazz: JournalEntry, hookName: "Journal"},
			{Clazz: RollTable},
		]
			.forEach(({Clazz, hookName}) => {
				hookName = hookName || Clazz.name;

				Hooks.on(`get${hookName}DirectoryEntryContext`, ($html, options) => {
					if (Config.get("tools", "isAddClearFlagsContextMenu")) {
						options.push({
							name: `Clear ${Config.get("ui", "isStreamerMode") ? SharedConsts.MODULE_TITLE_FAKE : SharedConsts.MODULE_TITLE} Flags`,
							title: "Cringe",
							icon: `<i class="fas fa-fw fa-location-slash"></i>`,
							condition: li => {
								const doc = game[Clazz.metadata.collection].get(li.data("documentId"));
								return doc.isOwner;
							},
							callback: async li => {
								const doc = game[Clazz.metadata.collection].get(li.data("documentId"));

								await doc.update({
									[`flags.-=${SharedConsts.MODULE_ID}`]: null,
								});

								for (const [embedName, propData] of Object.entries(Clazz.metadata.embedded)) {
									await UtilDocuments.pUpdateEmbeddedDocuments(
										doc,
										doc[propData]
											.map(embed => ({
												_id: embed.id,
												[`flags.-=${SharedConsts.MODULE_ID}`]: null,
											})),
										{
											propData,
											embedName,
										},
									);
								}

								ui.notifications.info(`Cleared ${Config.get("ui", "isStreamerMode") ? SharedConsts.MODULE_TITLE_FAKE : SharedConsts.MODULE_TITLE} flags!`);
							},
						});
					}
				});
			});
	}

	static _doPatchTempSheetHeaderButtons () {
		[
			{
				hookName: "getActorSheetHeaderButtons",
				clazz: Actor,
			},
			{
				hookName: "getItemSheetHeaderButtons",
				clazz: Item,
			},
			{
				hookName: "getJournalSheetHeaderButtons",
				clazz: JournalEntry,
			},
			{
				hookName: "getRollTableConfigHeaderButtons",
				clazz: RollTable,
			},
		].forEach(({hookName, clazz}) => {
			Hooks.on(hookName, (sheet, buttonMetas) => {
				if (!UtilDocuments.isTempDocument({doc: sheet?.document})) return;
				if (!sheet?.document?.flags?.[SharedConsts.MODULE_ID]) return;

				if (!game.user.can(clazz.metadata.permissions.create)) return;

				buttonMetas.unshift({
					label: "Import",
					class: "import",
					icon: "fas fa-download",
					onclick: async () => {
						await clazz.create(sheet.document.toJSON());
						ui.sidebar.activateTab(clazz.metadata.collection);
						sheet.close();
					},
				});
			});
		});
	}

	static _handleConfigUpdate_folderMaxDepth ({isInit = false} = {}) {
		try {
			return this._handleConfigUpdate_folderMaxDepth_();
		} catch (e) {
			if (!isInit) throw e;
			Config.handleFailedInitConfigApplication("ui", "isEnableIncreasedFolderDepth", e);
		}
	}

	static _handleConfigUpdate_folderMaxDepth_ () {
		if (Patcher._CONST_ORIGINAL == null) Patcher._CONST_ORIGINAL = window.CONST;

		if (Config.get("ui", "isEnableIncreasedFolderDepth") && !UtilCompat.isBetterRolltablesActive()) {
			if (CONST.FOLDER_MAX_DEPTH >= Patcher._FOLDER_MAX_DEPTH) return;

																											window.CONST = MiscUtil.copy(Patcher._CONST_ORIGINAL);

			CONST.FOLDER_MAX_DEPTH__ORIGINAL = CONST.FOLDER_MAX_DEPTH;
			CONST.FOLDER_MAX_DEPTH = Patcher._FOLDER_MAX_DEPTH;
		} else {
			window.CONST = Patcher._CONST_ORIGINAL;
		}
	}
}
Patcher._CONST_ORIGINAL = null;
Patcher._FOLDER_MAX_DEPTH = 9;

class MenuTitleActorDirectory extends MenuTitle {}
MenuTitleActorDirectory._HOOK_NAME = "renderActorDirectory";
MenuTitleActorDirectory._EVT_NAMESPACE = "plutonium-actor-directory-title-menu";
MenuTitleActorDirectory._TOOL_LIST = [];

class MenuTitleItemDirectory extends MenuTitle {}
MenuTitleItemDirectory._HOOK_NAME = "renderItemDirectory";
MenuTitleItemDirectory._EVT_NAMESPACE = "plutonium-item-directory-title-menu";
MenuTitleItemDirectory._TOOL_LIST = [];

class MenuTitleJournalDirectory extends MenuTitle {}
MenuTitleJournalDirectory._HOOK_NAME = "renderJournalDirectory";
MenuTitleJournalDirectory._EVT_NAMESPACE = "plutonium-journal-directory-title-menu";
MenuTitleJournalDirectory._TOOL_LIST = [];

class MenuTitleCardsDirectory extends MenuTitle {}
MenuTitleCardsDirectory._HOOK_NAME = "renderCardsDirectory";
MenuTitleCardsDirectory._EVT_NAMESPACE = "plutonium-cards-directory-title-menu";
MenuTitleCardsDirectory._TOOL_LIST = [];

class MenuTitlePlaylistDirectory extends MenuTitle {}
MenuTitlePlaylistDirectory._HOOK_NAME = "renderPlaylistDirectory";
MenuTitlePlaylistDirectory._EVT_NAMESPACE = "plutonium-playlist-directory-title-menu";
MenuTitlePlaylistDirectory._TOOL_LIST = [];

class MenuTitleCompendiumDirectory extends MenuTitle {}
MenuTitleCompendiumDirectory._HOOK_NAME = "renderCompendiumDirectory";
MenuTitleCompendiumDirectory._EVT_NAMESPACE = "plutonium-compendium-directory-title-menu";
MenuTitleCompendiumDirectory._TOOL_LIST = [];

class MenuTitleCombatTracker extends MenuTitle {}
MenuTitleCombatTracker._HOOK_NAME = "renderCombatTracker";
MenuTitleCombatTracker._EVT_NAMESPACE = "plutonium-combat-tracker-title-menu";
MenuTitleCombatTracker._TOOL_LIST = [];

class MenuTitleSceneDirectory extends MenuTitle {}
MenuTitleSceneDirectory._HOOK_NAME = "renderSceneDirectory";
MenuTitleSceneDirectory._EVT_NAMESPACE = "plutonium-scene-directory-title-menu";
MenuTitleSceneDirectory._TOOL_LIST = [];

class MenuTitleRollTableDirectory extends MenuTitle {}
MenuTitleRollTableDirectory._HOOK_NAME = "renderRollTableDirectory";
MenuTitleRollTableDirectory._EVT_NAMESPACE = "plutonium-roll-table-directory-title-menu";
MenuTitleRollTableDirectory._TOOL_LIST = [];

class MenuTitleMacroDirectory extends MenuTitle {}
MenuTitleMacroDirectory._HOOK_NAME = "renderMacroDirectory";
MenuTitleMacroDirectory._EVT_NAMESPACE = "plutonium-macro-directory-title-menu";
MenuTitleMacroDirectory._TOOL_LIST = [];

class MenuTitleSettings extends MenuTitle {}
MenuTitleSettings._HOOK_NAME = "renderSettings";
MenuTitleSettings._EVT_NAMESPACE = "plutonium-settings-title-menu";
MenuTitleSettings._TOOL_LIST = [];

class NamedTokenCreator {
	static async pCreateToken ({name, xScene, yScene, width = 1, height = 1, scale = 1}) {
		if (!canvas.scene) throw new Error(`There is currently no active scene!`);

		const img = await this._pGetBlankTokenImage();
		const tokenBlob = await this._pGetTokenBlob({name, img});
		const url = await Vetools.pSaveImageToServerAndGetUrl({blob: tokenBlob, path: `named-token/${name}.png`});
		return this._pCreateToken({name, url, xScene, yScene, width, height, scale});
	}

	static async _pGetBlankTokenImage () {
		return UtilImage.pLoadTempImage(`modules/${SharedConsts.MODULE_ID}/media/img/blank.png`, {isCacheable: true});
	}

	static _pGetTokenBlob ({name, img}) {
		return UtilImage.pDrawTextGetBlob({
			text: name,
			img,
			bbX0: NamedTokenCreator._BB_X0,
			bbX1: NamedTokenCreator._BB_X1,
			bbY0: NamedTokenCreator._BB_Y0,
			bbY1: NamedTokenCreator._BB_Y1,
			color: "#d0c04c",
			font: `"Modesto Condensed", "Palatino Linotype", serif`,
		});
	}

	static _pCreateToken ({name, url, xScene, yScene, width, height, scale}) {
		return TokenDocument.create(
			{
				name,
				x: xScene,
				y: yScene,
				img: url,
				width: width,
				height: height,
				scale: scale,
			},
			{
				parent: canvas.scene,
			},
		);
	}
}
NamedTokenCreator._BB_X0 = 31;
NamedTokenCreator._BB_X1 = 246;
NamedTokenCreator._BB_Y0 = 93;
NamedTokenCreator._BB_Y1 = 182;

NamedTokenCreator._CACHE_IMAGE = null;

class ModuleMacroBase {
	static pExec () { throw new Error("Unimplemented!"); }
}

class ImportToSelectedTokens extends ModuleMacroBase {
	static async pExec () {
		try {
			await this._pExec();
		} catch (e) {
			ui.notifications.error(`Importing failed! ${VeCt.STR_SEE_CONSOLE}`);
			throw e;
		}
	}

	static async _pExec () {
		const tokens = [...canvas.tokens.controlled].filter(it => it.actor);
		if (!tokens.length) return ui.notifications.warn(`Please select some tokens (which have actors) first!`);

		const actors = tokens.map(it => it.actor).unique();
		if (!actors.length) return ui.notifications.warn(`Please select some tokens (which have actors) first!`);

				if (actors.length === 1) {
			await ChooseImporter.api_pOpen({actor: actors[0]});
			return;
		}

				const ACTOR_TYPE_PREFERENCE = ["character", "npc", "vehicle"];
		const actorTypes = actors
			.map(it => it.type)
			.unique()
			.sort((a, b) => ACTOR_TYPE_PREFERENCE.indexOf(a) - ACTOR_TYPE_PREFERENCE.indexOf(b));

		if (actorTypes.length > 1) ui.notifications.warn(`Multiple actor types found in selected tokens\u2014the importer will run as though importing to a "${actorTypes[0]}"-type actor.`);

		ui.notifications.info(`You are importing to ${actors.length} actors\u2014updates will be applied, as a batch, when the importer is closed.`);

		const dummyActor = await UtilDocuments.pCreateDocument(
			Actor,
			{
				name: "Temp",
				type: actorTypes[0],
				flags: {[SharedConsts.MODULE_ID]: {isImporterTempActor: true}},
			},
			{isTemporary: true},
		);
		const baseData = dummyActor.toJSON();
				delete baseData.flags[SharedConsts.MODULE_ID];

		const importer = await ChooseImporter.api_pOpen({actor: dummyActor});

		await UtilApplications.pAwaitAppClose(importer);

		ui.notifications.info(`Applying updates...`);

		const finalData = dummyActor.toJSON();

				MiscUtil.delete(finalData, "flags", SharedConsts.MODULE_ID, "isImporterTempActor");
		if (!Object.keys(MiscUtil.get(finalData, "flags", SharedConsts.MODULE_ID) || {}).length) MiscUtil.delete(finalData, "flags", SharedConsts.MODULE_ID);

		let isAnyUpdate = false;

		const DIFF_OBJECT_PROPS = ["system", "prototypeToken", "flags"];
		for (const prop of DIFF_OBJECT_PROPS) {
			if (!baseData[prop] && !finalData[prop]) continue;

			const diff = foundry.utils.diffObject(baseData[prop], finalData[prop]);

			if (!Object.keys(diff).length) continue;
			isAnyUpdate = true;

			for (const actor of actors) await actor.update({[prop]: diff});
		}

		const DIFF_EMBEDDED_PROPS = [
			{prop: "items", documentName: "Item"},
			{prop: "effects", documentName: "ActiveEffect"},
		];
		for (const {prop, documentName} of DIFF_EMBEDDED_PROPS) {
			if (!finalData[prop]?.length) continue;
			isAnyUpdate = true;

			for (const actor of actors) {
				const cpyEmbeds = MiscUtil.copy(finalData[prop]);

				const [toCreates, toUpdates] = cpyEmbeds.segregate(embed => {
										if (embed.origin && typeof embed.origin === "string") {
						const originSpl = embed.origin.split(".");
																		if (originSpl.length === 4 && originSpl[1] === "null") {
							originSpl[1] = actor.id;
							embed.origin = originSpl.join(".");
						}
					}

					return actor[prop].get(embed._id) == null;
				});

				if (toCreates.length) await actor.createEmbeddedDocuments(documentName, toCreates, {keepId: true});
				if (toUpdates.length) await actor.updateEmbeddedDocuments(documentName, toUpdates);
			}
		}

		if (isAnyUpdate) ui.notifications.info(`Updates applied!`);
		else ui.notifications.warn(`Found no updates to apply!`);
			}
}

class CreateNamedToken extends ModuleMacroBase {
	static pExec () {
		canvas.stage.once("click", async evt => {
			try {
				const {x, y} = evt.data.getLocalPosition(canvas.stage);

				const name = await InputUiUtil.pGetUserString({title: "Token Name"});
				if (!name) return;

				const size = await InputUiUtil.pGetUserEnum({
					values: Parser.SIZE_ABVS.filter(sz => sz !== Parser.SZ_VARIES),
					title: "Select Token Size",
					fnDisplay: it => Parser.sizeAbvToFull(it),
					isResolveItem: true,
				});
				if (!size) return;

				const {dimensions = 1, scale = 1} = UtilTokens.getTokenDimensionsAndScale(size);

				await NamedTokenCreator.pCreateToken({
					name,
					xScene: x,
					yScene: y,
					width: dimensions,
					height: dimensions,
					scale,
				});
			} catch (e) {
				ui.notifications.error(`Failed to create token! ${VeCt.STR_SEE_CONSOLE}`);
				throw e;
			}
		});

		ui.notifications.info("Click on the canvas to spawn a token!");
	}
}

class CreateTokenFromUrl extends ModuleMacroBase {
	static pExec () {
		canvas.stage.once("click", async evt => {
			try {
				const {x, y} = evt.data.getLocalPosition(canvas.stage);

				const url = await InputUiUtil.pGetUserString({title: "Image URL"});
				if (!url) return;

				const size = await InputUiUtil.pGetUserEnum({
					values: Parser.SIZE_ABVS.filter(sz => sz !== Parser.SZ_VARIES),
					title: "Select Token Size",
					fnDisplay: it => Parser.sizeAbvToFull(it),
					isResolveItem: true,
				});
				if (!size) return;

				const {dimensions = 1, scale = 1} = UtilTokens.getTokenDimensionsAndScale(size);

				await TokenDocument.create(
					{
						name,
						x: x,
						y: y,
						img: url,
						width: dimensions,
						height: dimensions,
						scale: scale,
					},
					{
						parent: canvas.scene,
					},
				);
			} catch (e) {
				ui.notifications.error(`Failed to create token! ${VeCt.STR_SEE_CONSOLE}`);
				throw e;
			}
		});

		ui.notifications.info("Click on the canvas to spawn a token!");
	}
}

class GetThreeDiTokenDump extends ModuleMacroBase {
	static async pExec () {
		if (!UtilCompat.isThreeDiTokensActive()) throw new Error(`Required modules are not active!`);

		const TokenBrowser = game.Levels3DPreview.CONFIG.UI.TokenBrowser;
		const tokenBrowser = new TokenBrowser();
		const data = await tokenBrowser.getData();
		const out = data.materials.map(({displayName: name, output: path}) => ({name, path}));
		DataUtil.userDownload("3d-tokens-dump", out, {isSkipAdditionalMetadata: true});
		ui.notifications.info("Exported as JSON download!");
	}
}

class ModuleMacro {
	static api_importToSelectedTokens () { return ImportToSelectedTokens.pExec(); }
	static api_createNamedToken () { return CreateNamedToken.pExec(); }
	static api_createTokenFromUrl () { return CreateTokenFromUrl.pExec(); }
	static dev_getThreeDiTokenDump () { return GetThreeDiTokenDump.pExec(); }
}

class Api {
	static _API = {
		importer: {
			pOpen: ChooseImporter.api_pOpen.bind(ChooseImporter),
			pImportAll: ChooseImporter.api_pImportAll.bind(ChooseImporter),
			pGetImporter: ChooseImporter.api_pGetImporter.bind(ChooseImporter),
			creature: {
				pImportEntry: ImportListCreature.api_pImportEntry.bind(ImportListCreature),
			},
			spell: {
				pImportEntry: ImportListSpell.api_pImportEntry.bind(ImportListSpell),
			},
		},
		token: {
			pCreateToken: NamedTokenCreator.pCreateToken.bind(NamedTokenCreator),
		},
		util: {
			apps: {
				doAutoResize: UtilApplications.autoResizeApplication.bind(UtilApplications),
				$getAppElement: UtilApplications.$getAppElement.bind(UtilApplications),
				pAwaitAppClose: UtilApplications.pAwaitAppClose.bind(UtilApplications),
			},
			actors: {
				isImporterTempActor: UtilActors.isImporterTempActor.bind(UtilActors),
			},
			tokens: {
				getTokenDimensionsAndScale: UtilTokens.getTokenDimensionsAndScale.bind(UtilTokens),
			},
			requests: {
				pSaveImageToServerAndGetUrl: Vetools.pSaveImageToServerAndGetUrl.bind(Vetools),
			},
			folders: {
				pCreateFoldersGetId: UtilFolders.pCreateFoldersGetId.bind(UtilFolders),
			},
			image: {
				pLoadTempImage: UtilImage.pLoadTempImage.bind(UtilImage),
			},
		},
		hooks: {
			on: UtilHooks.on.bind(UtilHooks),
			off: UtilHooks.off.bind(UtilHooks),
		},
		moduleMacro: {
			importToSelectedTokens: ModuleMacro.api_importToSelectedTokens.bind(ModuleMacro),
			createNamedToken: ModuleMacro.api_createNamedToken.bind(ModuleMacro),
			createTokenFromUrl: ModuleMacro.api_createTokenFromUrl.bind(ModuleMacro),

			dev_getThreeDiTokenDump: ModuleMacro.dev_getThreeDiTokenDump.bind(ModuleMacro),
		},
		config: {
			getWikiSummary: Config.api_getWikiSummary.bind(Config),
			getWikiSummaryMarkdown: Config.api_getWikiSummaryMarkdown.bind(Config),
		},
	};

	static init () {
		this._init_addFakeModule();

		UtilLibWrapper.addPatch(
			"ModuleManagement.prototype.getData",
			this._lw_ModuleManagement_prototype_getData,
			UtilLibWrapper.LIBWRAPPER_MODE_WRAPPER,
		);
	}

		static _init_addFakeModule () {
		const clone = new Module(game.modules.get(SharedConsts.MODULE_ID).toObject());

		game.modules.get(SharedConsts.MODULE_ID).api = Api._API;

		clone.id = SharedConsts.MODULE_ID_FAKE;
		clone.api = Api._API;

		game.modules.set(SharedConsts.MODULE_ID_FAKE, clone);
	}

	static _lw_ModuleManagement_prototype_getData (fn, ...args) {
		const clone = game.modules.get(SharedConsts.MODULE_ID);
		game.modules.delete(SharedConsts.MODULE_ID_FAKE);

		const out = fn(...args);

		game.modules.set(SharedConsts.MODULE_ID_FAKE, clone);

		return out;
	}
}

class TokenHpRoller {
	static init () {
		Hooks.on("createToken", async (docToken) => {
			if (!game.user.isGM || !docToken.isOwner) return;

			const rollMode = Config.get("tokens", "npcHpRollMode");
			if (rollMode === ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_NONE) return;

			if (
				docToken.actor?.type !== "npc"
				|| docToken.isLinked
				|| !docToken.actor?.system?.attributes?.hp?.formula
			) return;

			const roll = new Roll(docToken.actor.system.attributes.hp.formula);
			try {
				await roll.evaluate({
					async: true,
					minimize: rollMode === ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_MIN,
					maximize: rollMode === ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_MAX,
				});
				const messageRollMode = this._getMessageRollMode(rollMode);
				if (messageRollMode) roll.toMessage({sound: null}, {rollMode: messageRollMode});
			} catch (e) {
				console.warn(...LGT, `Failed to roll HP formula "${docToken.actor.system.attributes.hp.formula}" for token "${docToken.name}" (${docToken.id})! The default HP value will be used instead.`);
				return;
			}

															await Promise.race([
				this._pDoWaitForTokenBars(docToken),
				MiscUtil.pDelay(300),
			]);

			await UtilDocuments.pUpdateDocument(
				docToken.actor,
				{
					system: {
						attributes: {
							hp: {
								value: roll.total,
								max: roll.total,
							},
						},
					},
				},
			);
		});
	}

	static async _pDoWaitForTokenBars (docToken) {
		for (let attempts = 0; attempts < 100; ++attempts) {
			if (docToken.bars) break;
			await MiscUtil.pDelay(10);
		}
	}

	static _getMessageRollMode (rollMode) {
		switch (rollMode) {
			case ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_STANDARD: return "roll";
			case ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_GM: return "gmroll";
			case ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_BLIND: return "blindroll";
			case ConfigConsts.C_TOKEN_NPC_HP_ROLL_MODE_SELF: return "selfroll";
			default: return null;
		}
	}
}

class _DocTypeMeta {
	constructor (
		{
			Cls,
			pathsDefaultSkipUpdate,
			isEmbedOnly = false,
			isIncludeScene = false,
		},
	) {
		this.Cls = Cls;
		this.pathsDefaultSkipUpdate = pathsDefaultSkipUpdate;
		this.isEmbedOnly = isEmbedOnly;
		this.isIncludeScene = isIncludeScene;
	}
}

class ContentUpdaterConsts {
	static APP_TITLE = "Content Updater";

	static DOC_TYPE_METAS = {
		Actor: new _DocTypeMeta({
			Cls: Actor,
			pathsDefaultSkipUpdate: [
				...Consts.USER_DATA_TRACKING_KEYS__ACTOR,

				"prototypeToken.name",
				"prototypeToken.texture.src",
			],
			isIncludeScene: true,
		}),
		Item: new _DocTypeMeta({
			Cls: Item,
			pathsDefaultSkipUpdate: [
				"system.description.value",
				"system.attunement",
				"system.equipped",
				"system.identified",
				"system.quantity",

								"system.save.scaling",
				"system.ability",
				"system.preparation.prepared",
				"system.preparation.mode",
				
								"flags.plutonium.parentClassName",
				"flags.plutonium.parentClassSource",
				"flags.plutonium.parentSubclassName",
				"flags.plutonium.parentSubclassSource",
							],
		}),
		RollTable: new _DocTypeMeta({
			Cls: RollTable,
			pathsDefaultSkipUpdate: [
				"description",

				"replacement",
				"displayRoll",
			],
		}),
		Cards: new _DocTypeMeta({
			Cls: Cards,
			pathsDefaultSkipUpdate: [
				"description",

				"width",
				"height",
				"rotation",
			],
		}),

		ActiveEffect: new _DocTypeMeta({
			Cls: ActiveEffect,
			pathsDefaultSkipUpdate: [
				"name",
				"icon",
				"tint",
			],
			isEmbedOnly: true,
		}),
		TableResult: new _DocTypeMeta({
			Cls: TableResult,
			pathsDefaultSkipUpdate: [
				"drawn",
			],
			isEmbedOnly: true,
		}),
		Card: new _DocTypeMeta({
			Cls: Card,
			pathsDefaultSkipUpdate: [
				"description",

				"drawn",

				"width",
				"height",
				"rotation",
			],
			isEmbedOnly: true,
		}),
	};
}

class _DiffUpdateBase {
	constructor () {
				this._base = {};

		this._collectionsAdd = new Map();
		this._collectionsRemove = new Map();
		this._collectionsModify = new Map();
			}

	
	setBase (k, v) {
		this._base[k] = v;
	}

	setCollectionsRemove (ClsDocSub, id) {
		this._collectionsRemove
			.getOrSet(ClsDocSub, [])
			.push(id);
	}

	setCollectionsAdd (ClsDocSub, docSub) {
		this._collectionsAdd
			.getOrSet(ClsDocSub, [])
			.push(docSub);
	}

	setCollectionModify (ClsDocSub, diffUpdateSub) {
		this._collectionsModify
			.getOrSet(ClsDocSub, [])
			.push(diffUpdateSub);
	}

	
	async pApply (document) {
		await this._pApply_base({document});
		await this._pApply_collectionsAdd({document});
		await this._pApply_collectionsRemove({document});
		await this._pApply_collectionsModify({document});
	}

		async _pApply_base ({document}) { throw new Error("Unimplemented!"); }
		async _pApply_collectionsAdd ({document}) { throw new Error("Unimplemented!"); }
		async _pApply_collectionsRemove ({document}) { throw new Error("Unimplemented!"); }
		async _pApply_collectionsModify ({document}) { throw new Error("Unimplemented!"); }
}

class DiffUpdate extends _DiffUpdateBase {
	
	async _pApply_base ({document}) {
		if (!Object.keys(this._base).length) return;

		await UtilDocuments.pUpdateDocument(
			document,
			this.constructor._getPostProcessedUpdate(this._base),
		);
	}

	async _pApply_collectionsAdd ({document}) {
		if (!this._collectionsAdd.size) return;

				for (const [ClsEmbedDocSub, arr] of this._collectionsAdd.entries()) {
			await UtilDocuments.pCreateEmbeddedDocuments(
				document.document,
				arr,
				{
					ClsEmbed: ClsEmbedDocSub,
				},
			);
		}
	}

	async _pApply_collectionsRemove ({document}) {
		if (!this._collectionsRemove.size) return;

		for (const [ClsEmbedDocSub, arr] of this._collectionsRemove.entries()) {
			await UtilDocuments.pDeleteEmbeddedDocuments(
				document,
				arr,
				{
					ClsEmbed: ClsEmbedDocSub,
				},
			);
		}
	}

	async _pApply_collectionsModify ({document}) {
		if (!this._collectionsModify.size) return;

		for (const [ClsEmbedDocSub, arr] of this._collectionsModify.entries()) {
			await UtilDocuments.pUpdateEmbeddedDocuments(
				document,
				arr.map(diffUpdateSub => diffUpdateSub.getBaseUpdate()),
				{
					ClsEmbed: ClsEmbedDocSub,
				},
			);

																					for (const diffUpdateSub of arr) {
								const docSub = diffUpdateSub.getEmbeddedDocument(document);
			}
		}
	}

	
		static _getPostProcessedUpdate (upd) {
		const out = foundry.utils.deepClone(upd);

		Object.entries(out)
			.forEach(([k, v]) => {
				if (v !== undefined) return;

				const pts = k.split(".");
				const kNxt = [
					...pts.slice(0, -1),
					`-=${pts.last()}`,
				]
					.join(".");

				out[kNxt] = null;
			});

		return out;
	}
}

class DiffUpdateSub extends DiffUpdate {
	constructor (
		{
			ClsEmbedDocSub,
			docSubId,
		},
	) {
		super();
		this._ClsEmbedDocSub = ClsEmbedDocSub;
		this._docSubId = docSubId;
	}

	
	async _pApply_base () {  }

	
	getBaseUpdate () {
		return this.constructor._getPostProcessedUpdate({
			...this._base,
			_id: this._docSubId,
		});
	}

	getEmbeddedDocument (docParent) {
		return docParent[this._ClsEmbedDocSub.metadata.collection].get(this._docSubId);
	}
}

class DiffUpdater {
	constructor ({list, docMeta, listItem}) {
		this._list = list;
		this._listItem = listItem;
		this._docMeta = docMeta;
	}

	get name () { return this._docMeta.displayName; }

		async pDoUpdate () {
		const diffUpdate = new DiffUpdate();

		this._docMeta.rdDiffs.forEach(rdDiff => rdDiff.mutUpdate({diffUpdate}));

		await diffUpdate.pApply(this._docMeta.document);

						this._docMeta.rdDiffs.forEach(rdDiff => rdDiff.updateAppliedState());

		if (this._docMeta.rdDiffs.every(it => it.isApplied)) this._list.removeItem(this._listItem);
	}
}

class RenderedDiffSelectClickHandler extends ListSelectClickHandlerBase {
	constructor () {
		super();
		this._rdDiffs = [];
	}

	
	get _visibleItems () {
		return this._rdDiffs
			.filter(rdDiff => !rdDiff.isApplied);
	}

	get _allItems () { return this._rdDiffs; }

	_getCb (rdDiff, opts = {}) {
		return rdDiff.cbApply;
	}

	_setCheckbox (rdDiff, {toVal = true} = {}) {
		if (rdDiff.cbApply.disabled) return;
		rdDiff.cbApply.checked = !!toVal;
		this._setHighlighted(rdDiff, toVal);
	}

	_setHighlighted (rdDiff, isHighlighted) {
		if (isHighlighted) rdDiff.wrpRow.classList.add("list-multi-selected");
		else rdDiff.wrpRow.classList.remove("list-multi-selected");
	}

	
	add (rdDiff) {
		this._rdDiffs.push(rdDiff);
		rdDiff.wrpRow.onClick(evt => this.handleSelectClick(rdDiff, evt));
	}
}

class DefaultSelectionManager {
	static async pShow () {
		const {$modalInner, doClose} = await UtilApplications.pGetShowApplicationModal({
			title: `Configure Skipped Fields`,
		});

		const comp = new _DefaultSelectionConfigComp();
		await comp.pInit();
		comp.render($modalInner, doClose);
	}

	static async pGetDefaultSkipSelections () {
		const comp = new _DefaultSelectionConfigComp();
		await comp.pInit();
		return comp.getDefaultSkipSelections();
	}
}

class _DefaultSelectionConfigComp extends BaseComponent {
	static _STORAGE_KEY = "contentUpdater_defaultSelectionConfig";

	constructor () {
		super();
		this._renderableCollectionSelections = null;
	}

	async pInit () {
		const savedState = await StorageUtil.pGet(this.constructor._STORAGE_KEY);
		if (savedState) {
			try {
				this.setBaseSaveableStateFrom(savedState);
			} catch (ignored) {
							}
		}

		this._renderableCollectionSelections = new _DefaultSelectionConfigComp._RenderableCollectionSelection(this);
	}

	get defaultSelections () { return this._state.defaultSelections; }
	set defaultSelections (val) { this._state.defaultSelections = val; }

	render ($wrp, doClose) {
		const $wrpCollection = $(`<div class="ve-flex-col overflow-y-auto w-100 h-100 min-h-0 relative"></div>`);

		this._renderableCollectionSelections.$wrp = $wrpCollection;

		this._addHookBase(
			"defaultSelections",
			() => {
				this._renderableCollectionSelections.render();
			},
		)();

		const $btnAddRow = $(`<button class="btn btn-xs btn-default" title="Add">Add Row <span class="glyphicon glyphicon-plus"></span></button>`)
			.click(() => {
				this._state.defaultSelections = [...this._state.defaultSelections, this._getNewDefaultSelection()];
			});

		const $btnReset = $(`<button class="btn btn-xs btn-default" title="Reset"><span class="glyphicon glyphicon-refresh"></span></button>`)
			.click(async () => {
				if (!await InputUiUtil.pGetUserBoolean({title: "Are You Sure?"})) return;
				this._state.defaultSelections = this._getDefaultState_defaultSelections();
			});

		const $btnSave = $(`<button class="btn-5et">Save</button>`)
			.click(async () => {
				await StorageUtil.pSet(
					this.constructor._STORAGE_KEY,
					this.getBaseSaveableState(),
				);
				doClose();
			});

		$$($wrp)`<div class="ve-flex-col h-100 w-100 min-h-0">
			<div class="mb-2">
				When analyzing a document to determine which fields should be updated, a field listed here will be <b>skipped</b> by default.
			</div>
			<div class="split-v-center">
				<div></div>
				<div class="btn-group ml-auto ve-flex-v-center">
					${$btnAddRow}
					${$btnReset}
				</div>
			</div>
			<hr class="hr-2">
			${$wrpCollection}
			<hr class="hr-2 mt-auto">
			<div class="ve-flex-v-center">
				${$btnSave}
			</div>
		</div>`;
	}

	getDefaultSkipSelections () {
		const out = {};
		this._state.defaultSelections
			.map(({entity: {docType, path}}) => {
				(out[docType] = out[docType] || new Set()).add(path);
			});
		return out;
	}

	_getNewDefaultSelection ({docType = "Actor", path = ""} = {}) {
		return {
			id: CryptUtil.uid(),
			entity: {
				docType,
				path,
			},
		};
	}

	_getDefaultState_defaultSelections () {
		return Object.values(ContentUpdaterConsts.DOC_TYPE_METAS)
			.flatMap(({Cls, pathsDefaultSkipUpdate}) => {
				const paths = [...pathsDefaultSkipUpdate].sort(SortUtil.ascSortLower);

				return paths
					.map(path => this._getNewDefaultSelection({docType: Cls.metadata.name, path}));
			});
	}

	_getDefaultState () {
		return {
			defaultSelections: this._getDefaultState_defaultSelections(),
		};
	}
}

_DefaultSelectionConfigComp._RenderableCollectionSelection = class extends RenderableCollectionBase {
	constructor (comp) {
		super(comp, "defaultSelections");
		this._$wrp = null;

		this._renderedMetas = [];
	}

	set $wrp (val) { this._$wrp = val; }

	_swapRowPositions (ixA, ixB) {
		const a = this._renderedMetas[ixA];
		this._renderedMetas[ixA] = this._renderedMetas[ixB];
		this._renderedMetas[ixB] = a;

		this._renderedMetas.forEach(it => it.$wrpRow.detach().appendTo(this._$wrp));
	}

	getNewRender (rowData) {
		const parentComp = this._comp;

		const comp = BaseComponent.fromObject(rowData.entity, "*");
		comp._addHookAll("state", () => {
			rowData.entity = comp.toObject("*");
			parentComp._triggerCollectionUpdate("defaultSelections");
		});

		const $selDocType = ComponentUiUtil.$getSelEnum(
			comp,
			"docType",
			{
				values: Object.values(ContentUpdaterConsts.DOC_TYPE_METAS)
					.map(({Cls}) => Cls.metadata.name)
					.sort(SortUtil.ascSortLower),
				isAllowNull: false,
			},
		);

		const $iptPath = ComponentUiUtil.$getIptStr(comp, "path", {placeholder: "system.abilities.str.value"})
			.addClass("code");

		const $btnDelete = $(`<button class="btn btn-xxs btn-danger" title="Delete"><span class="glyphicon glyphicon-trash"></span></button>`)
			.click(() => {
				parentComp.defaultSelections = parentComp.defaultSelections.filter(it => it !== rowData);
				this._renderedMetas.splice(this._renderedMetas.indexOf(renderedMeta), 1);
			});

		const $padDrag = DragReorderUiUtil.$getDragPadOpts(
			() => $wrpRow,
			{
				$parent: this._$wrp,
				swapRowPositions: this._swapRowPositions.bind(this),
				$getChildren: () => this._renderedMetas.map(it => it.$wrpRow),
				fnOnDragComplete: () => {
					const byId = parentComp._state.defaultSelections.mergeMap(rowData => ({[rowData.id]: rowData}));
					parentComp._state.defaultSelections = this._renderedMetas.map(it => byId[it.id]).filter(Boolean);
				},
			},
		);

		const $wrpRow = $$`<div class="ve-flex-v-center py-1p pr-1p" data-comp-type="row">
			<div class="w-200p mr-2">${$selDocType}</div>
			<div class="w-100 min-w-0 mr-2">${$iptPath}</div>
			<div class="ve-flex-vh-center mr-2">${$btnDelete}</div>
			<div class="ve-flex-vh-center">${$padDrag}</div>
		</div>`.appendTo(this._$wrp);

		const renderedMeta = {
			id: rowData.id,
			comp,
			$wrpRow,
			fnCleanup: () => {
							},
		};

		this._renderedMetas.push(renderedMeta);

		return renderedMeta;
	}

	doUpdateExistingRender (renderedMeta, rowData) {
		renderedMeta.comp._proxyAssignSimple("state", rowData.entity, true);
	}

	doDeleteExistingRender (renderedMeta) {
		renderedMeta.fnCleanup();
	}

	doReorderExistingComponent (renderedMeta, rowData) {
		const parentComp = this._comp;

		const ix = parentComp.defaultSelections.map(it => it.id).indexOf(rowData.id);
		const curIx = this._$wrp.find(`[data-comp-type="row"]`).index(renderedMeta.$wrpRow);

		const isMove = !this._$wrp.length || curIx !== ix;
		if (!isMove) return;

		renderedMeta.$wrpRow.detach().appendTo(this._$wrp);

		this._renderedMetas.splice(this._renderedMetas.indexOf(renderedMeta), 1);
		this._renderedMetas.push(renderedMeta);
	}
};

class ContentUpdaterProgressBarManager {
	constructor () {
		this._cntChunks = null;
		this._ixChunk = null;

		this._cntSubChunks = null;
		this._ixSubChunk = null;

		this._msg = null;
	}

	
	setChunkCount (cnt) {
		this._cntChunks = cnt;
		this._ixChunk = 0;
	}

	incrementChunk (context) {
		this._ixChunk++;
		if (this._ixChunk > this._cntChunks) throw new Error(`Incremented past chunk limit! (Context was "${context}".)`);

		this._resetSubChunks();

		this._refresh();
	}

	setChunkSubCount (cnt) {
		if (!cnt) {
			this._resetSubChunks();
			return;
		}

		this._cntSubChunks = cnt;
		this._ixSubChunk = 0;
	}

	incrementSubChunk (context) {
		this._ixSubChunk++;
		if (this._ixSubChunk > this._cntSubChunks) throw new Error(`Incremented past sub-chunk limit! (Context was "${context}".)`);

		this._refresh();
	}

	_resetSubChunks () {
		this._cntSubChunks = null;
		this._ixSubChunk = null;
	}

	
	start (message) {
		this._msg = message;

		this._ixChunk = null;
		this._ixSubChunk = null;

		this._refresh();
	}

	stop (message) {
		this._msg = message;

		if (this._cntSubChunks != null) {
			this._ixChunk = this._cntChunks - 1;
			this._ixSubChunk = this._cntSubChunks;
		} else {
			this._ixChunk = this._cntChunks;
		}

		this._refresh();
	}

	setMessage (message) {
		this._msg = message;

		this._refresh();
	}

	
	_getMsg () {
		return this._msg || "";
	}

	_getPct () {
		if (this._ixChunk == null) return 0;

		const chunkSize = 100 / this._cntChunks;
		const fromChunk = this._ixChunk * chunkSize;

		if (this._ixSubChunk == null) return Util.getRounded(fromChunk, 2);

		const subChunkSize = chunkSize / this._cntSubChunks;
		const fromSubChunk = this._ixSubChunk * subChunkSize;

		return Util.getRounded(fromChunk + fromSubChunk, 2);
	}

	_refresh () {
		SceneNavigation.displayProgressBar({label: this._getMsg(), pct: this._getPct()});
	}
}

class ContentUpdaterConfigurationManager {
	static async pShow () {
		const {$modalInner, doClose, doAutoResize} = await UtilApplications.pGetShowApplicationModal({
			title: `Configure Content Updater`,
		});

		const comp = new _ContentUpdaterConfigurationManagerComp();
		await comp.pInit();
		comp.render($modalInner, doClose);

		doAutoResize();
	}

	static async pGetConfig () {
		const comp = new _ContentUpdaterConfigurationManagerComp();
		await comp.pInit();
		return comp.getConfig();
	}
}

class _ContentUpdaterConfigurationManagerComp extends BaseComponent {
	static _STORAGE_KEY = "contentUpdater_config";

	async pInit () {
		const savedState = await StorageUtil.pGet(this.constructor._STORAGE_KEY);
		if (savedState) {
			try {
				this.setBaseSaveableStateFrom(savedState);
			} catch (ignored) {
							}
		}
	}

	render ($wrp, doClose) {
		const $cbDirectories = ComponentUiUtil.$getCbBool(this, "isRunOnDirectory");
		const $cbDirectoriesSub = ComponentUiUtil.$getCbBool(this, "isRunOnDirectorySub");
		const $cbScene = ComponentUiUtil.$getCbBool(this, "isRunOnScene");

		const $cbSkipEmbedAddMissing = ComponentUiUtil.$getCbBool(this, "isSkipEmbedAddMissing");
		const $cbSkipEmbedRemoveExtra = ComponentUiUtil.$getCbBool(this, "isSkipEmbedRemoveExtra");

		const $btnConfigureDefaultSelection = $(`<button class="btn btn-default btn-sm">Configure Skipped Fields</button>`)
			.click(() => DefaultSelectionManager.pShow());

		const $btnSave = $(`<button class="btn-5et">Save</button>`)
			.click(async () => {
				await StorageUtil.pSet(
					this.constructor._STORAGE_KEY,
					this.getBaseSaveableState(),
				);
				doClose();
			});

		$$($wrp)`<div class="ve-flex-col h-100 w-100 min-h-0">
			<label class="split-v-center mb-2">
				<span>Run on Directories</span>
				${$cbDirectories}
			</label>

			<label class="split-v-center mb-2">
				<span title="If the diff should be run on embedded entities which do not belong to a Plutonium-imported parent document (for example, a character sheet to which Plutonium content has been imported)." class="help">Run on Directories (Embeds)</span>
				${$cbDirectoriesSub}
			</label>

			<label class="split-v-center mb-2">
				<span>Run on Current Scene</span>
				${$cbScene}
			</label>

			<hr class="hr-2">

			<label class="split-v-center mb-2">
				<span>Skip Adding Missing Embeds by Default</span>
				${$cbSkipEmbedAddMissing}
			</label>

			<label class="split-v-center mb-2">
				<span>Skip Deleting Unknown Embeds by Default</span>
				${$cbSkipEmbedRemoveExtra}
			</label>

			<div class="ve-flex-h-right mb-2">${$btnConfigureDefaultSelection}</div>

			<hr class="hr-2 mt-auto">
			<div class="ve-flex-v-center">
				${$btnSave}
			</div>
		</div>`;
	}

	getConfig () {
		return MiscUtil.copyFast(this._state);
	}

	_getDefaultState () {
		return {
			isRunOnDirectory: true,
			isRunOnDirectorySub: true,
									isRunOnPacks: false,
			isRunOnScene: false,

			isSkipEmbedAddMissing: false,
			isSkipEmbedRemoveExtra: true,
		};
	}
}

class _DiffApplyState {
	static NONE = "NONE";
	static APPLYING = "APPLYING";
	static APPLIED = "APPLIED";
}

class _BaseRenderedDiff {
	constructor ({cbApply, wrpRow}) {
		this._cbApply = cbApply;
		this._wrpRow = wrpRow;

		this._applyState = _DiffApplyState.NONE;
	}

	get cbApply () { return this._cbApply; }
	get wrpRow () { return this._wrpRow; }

	get isApplied () { return this._applyState === _DiffApplyState.APPLIED; }

	updateAppliedState () {
		if (this._applyState === _DiffApplyState.APPLIED) return;

		if (this._applyState === _DiffApplyState.APPLYING) this._applyState = _DiffApplyState.APPLIED;
		else this._applyState = _DiffApplyState.NONE;

				if (this._applyState === _DiffApplyState.APPLIED) this._wrpRow.detach();
	}

	mutUpdate ({diffUpdate}) {
		if (this._cbApply.disabled || !this._cbApply.checked || this.isApplied) return;

		return this._mutUpdate({diffUpdate});
	}

		_mutUpdate ({diffUpdate}) {
		throw new Error("Unimplemented!");
	}
}

class RenderedFieldDiff extends _BaseRenderedDiff {
	constructor ({prop, valueNu, ...rest}) {
		super({...rest});
		this._prop = prop;
		this._valueNu = valueNu;
	}

	_mutUpdate ({diffUpdate}) {
		diffUpdate.setBase(this._prop, this._valueNu);

		this._applyState = _DiffApplyState.APPLYING;
	}
}

class RenderedEmbeddedDocumentExtraDiff extends _BaseRenderedDiff {
	constructor ({ClsEmbedDocSub, docOld, ...rest}) {
		super({...rest});
		this._ClsEmbedDocSub = ClsEmbedDocSub;
		this._docOld = docOld;
	}

	_mutUpdate ({diffUpdate}) {
		diffUpdate.setCollectionsRemove(
			this._ClsEmbedDocSub,
			this._docOld._id || this._docOld.id,
		);

		this._applyState = _DiffApplyState.APPLYING;
	}
}

class RenderedEmbeddedDocumentMissingDiff extends _BaseRenderedDiff {
	constructor ({ClsEmbedDocSub, docNu, ...rest}) {
		super({...rest});
		this._ClsEmbedDocSub = ClsEmbedDocSub;
		this._docNu = docNu;
	}

	_mutUpdate ({diffUpdate}) {
		diffUpdate.setCollectionsAdd(
			this._ClsEmbedDocSub,
			foundry.utils.deepClone(this._docNu),
		);

		this._applyState = _DiffApplyState.APPLYING;
	}
}

class RenderedEmbeddedDocumentDiff extends _BaseRenderedDiff {
	constructor ({rdsChildren, ClsEmbedDocSub, docOld, ...rest}) {
		super({...rest});
		this._rdsChildren = rdsChildren;
		this._ClsEmbedDocSub = ClsEmbedDocSub;
		this._docOld = docOld;
	}

	get isApplied () {
		return super.isApplied
			&& this._rdsChildren.every(rd => rd.isApplied);
	}

	updateAppliedState () {
		if (this._applyState === _DiffApplyState.APPLIED) return;

		this._rdsChildren.forEach(rd => rd.updateAppliedState());

				if (this._rdsChildren.some(it => !it.isApplied)) this._applyState = _DiffApplyState.NONE;

		super.updateAppliedState();
	}

	_mutUpdate ({diffUpdate}) {
		const diffUpdateSub = new DiffUpdateSub({
			ClsEmbedDocSub: this._ClsEmbedDocSub,
			docSubId: this._docOld._id,
		});

		this._rdsChildren.forEach(rd => rd.mutUpdate({diffUpdate: diffUpdateSub}));

		diffUpdate.setCollectionModify(this._ClsEmbedDocSub, diffUpdateSub);

		this._applyState = _DiffApplyState.APPLYING;
	}
}

class _BaseDiff {
	constructor ({config, defaultSkipSelections}) {
		if (!config) throw new Error(`No "defaultSkipSelections" option provided!`);
		if (!defaultSkipSelections) throw new Error(`No "defaultSkipSelections" option provided!`);
		this._config = config;
		this._defaultSkipSelections = defaultSkipSelections;
	}

		render ({selectClickHandler, depth = 0}) { throw new Error("Unimplemented!"); }

	get _isDefaultApply () { return true; }

		get isNonFalsy () { return true; }

	_getDisplayName ({Cls, doc}) {
		switch (Cls.metadata.name) {
			case "Card": {
								if (doc.faces[0]?.name) return doc.faces[0].name;
				break;
			}

			case "ActiveEffect": {
				if (doc.name) return doc.name;
				break;
			}

			case "TableResult": {
				if (doc.text) return doc.text;
				break;
			}
		}

				if (doc.name) return doc.name;

		return `(Unknown)`;
	}

	_getCbApply ({isDisabled = false} = {}) {
		return e_({
			tag: "input",
			type: "checkbox",
			clazz: "mr-2 no-events",
			attrs: {
				checked: !isDisabled && this._isDefaultApply,
				disabled: isDisabled,
			},
		});
	}
}

class FieldDiff extends _BaseDiff {
	static _DEPTH_LIMIT = 2; 
	static _getDisplayValue (val) {
		if (val == null) return `${val}`;
		return JSON.stringify(val, null, " ");
	}

	constructor ({ClsDoc, prop, valueOld, valueNu, ...rest}) {
		super({...rest});
		this._ClsDoc = ClsDoc;
		this._prop = prop;
		this._valueOld = valueOld;
		this._valueNu = valueNu;
	}

	static _IS_DEFAULT_SKIP_UPDATE_GENERIC = new Set([
		"name",
		"img",

		"system.source", 	]);

	get _isDefaultApply () {
		if (this._prop.startsWith("flags.")) return this._isDefaultApply_flags();
		if (this.constructor._IS_DEFAULT_SKIP_UPDATE_GENERIC.has(this._prop)) return false;
		if (this._isDefaultApplySkipSelections()) return false;
		return super._isDefaultApply;
	}

	_isDefaultApplySkipSelections (prop) { return this._defaultSkipSelections[this._ClsDoc.metadata.name]?.has(prop ?? this._prop); }

		_isDefaultApply_flags () {
		const [, moduleId] = this._prop.split(".");

		switch (moduleId) {
						case SharedConsts.MODULE_ID:
			case SharedConsts.MODULE_ID_FAKE:
				return !this._isDefaultApplySkipSelections(this._prop.replace(`flags.${SharedConsts.MODULE_ID_FAKE}.`, `flags.${SharedConsts.MODULE_ID}.`));

			default: {
								if (this.constructor._isValueNonFalsy(this._valueNu)) return true;

								return false;
			}
		}
	}

	static _isValueNonFalsy (val) { return !!val && !foundry.utils.isEmpty(val); }

	get isNonFalsy () {
		return this.constructor._isValueNonFalsy(this._valueOld)
			|| this.constructor._isValueNonFalsy(this._valueNu);
	}

	_getMessageDisabled ({depth}) {
				if (depth >= this.constructor._DEPTH_LIMIT) return `Managing an Embedded Document within an Owned Document is not currently supported, and will be added in a subsequent update.`;

				if (this._prop === "type") return `Changing the "type" of a document is not supported.`;

		return null;
	}

	render ({selectClickHandler, depth = 0}) {
		const msgDisabled = this._getMessageDisabled({depth});

		const cbApply = this._getCbApply({isDisabled: !!msgDisabled});

		const isSelected = !msgDisabled && this._isDefaultApply;

		const wrpRow = e_({
						tag: "section",
			clazz: `ve-flex-v-center conu__row-field-diff ${msgDisabled ? "conu__row-field-diff--disabled" : ""} w-100 ${isSelected ? "list-multi-selected" : ""}`,
			children: [
				e_({
					tag: "label",
					clazz: "ve-flex-v-center w-100",
					children: [
						cbApply,
						e_({
							tag: "div",
							clazz: "ve-flex-v-center w-100 no-wrap min-w-0",
							children: [
								e_({
									tag: "span",
									clazz: "code no-wrap no-shrink mr-3 w-140p overflow-ellipsis text-right text-rtl",
									title: this._prop,
									text: this._prop,
								}),
								e_({
									tag: "div",
									clazz: "ve-self-flex-stretch ve-flex-1 code conu__disp-diff conu__disp-diff--old px-1 conu__disp-diff-border-y min-w-0 overflow-x-auto whitespace-normal word-break-all user-select-text",
									text: this.constructor._getDisplayValue(this._valueOld),
									click: evt => {
										evt.stopPropagation();
									},
								}),
								e_({
									tag: "div",
									clazz: "ve-self-flex-stretch ve-flex-vh-center no-shrink conu__vr-diff px-1p conu__disp-diff-border-y",
									text: "\u2192",
								}),
								e_({
									tag: "div",
									clazz: "ve-self-flex-stretch ve-flex-1 code conu__disp-diff conu__disp-diff--nu px-1 conu__disp-diff-border-y min-w-0 overflow-x-auto whitespace-normal word-break-all user-select-text",
									text: this.constructor._getDisplayValue(this._valueNu),
									click: evt => {
										evt.stopPropagation();
									},
								}),
							],
						}),
					],
				}),
			],
			title: msgDisabled,
		});

		const rd = new RenderedFieldDiff({
			cbApply,
			wrpRow,
			prop: this._prop,
			valueNu: this._valueNu,
		});

		selectClickHandler.add(rd);

		return rd;
	}
}

class _BaseEmbeddedDocumentExtraMissingDiff extends _BaseDiff {
	_prefix;
	_propDoc;
	_ClsRendered;

	constructor ({ClsEmbedDocSub, propCollection, docOld = null, docNu = null, ...rest}) {
		super({...rest});
		this._ClsEmbedDocSub = ClsEmbedDocSub;
		this._propCollection = propCollection;
		this._docOld = docOld;
		this._docNu = docNu;
	}

	_getDisplayName () {
		return super._getDisplayName({
			Cls: this._ClsEmbedDocSub,
			doc: this[`_${this._propDoc}`],
		});
	}

	render ({selectClickHandler, depth = 0}) {
		const cbApply = this._getCbApply();

		const wrpRow = e_({
			tag: "label",
			clazz: `ve-flex-v-center ${this._isDefaultApply ? "list-multi-selected" : ""}`,
			children: [
				cbApply,
				e_({
					outer: `<div class="ve-flex-v-center w-100 no-wrap">
							<div class="no-wrap no-shrink mr-3 w-140p overflow-ellipsis text-right">${this._prefix} <span class="code">${game.i18n.localize(this._ClsEmbedDocSub.metadata.label)}</span></div>
							<div>&quot;${this._getDisplayName()}&quot;</div>
						</div>`,
				}),
			],
		});

		const rd = new this._ClsRendered({
			cbApply,
			wrpRow,
			ClsEmbedDocSub: this._ClsEmbedDocSub,
			[this._propDoc]: this[`_${this._propDoc}`],
		});

		selectClickHandler.add(rd);

		return rd;
	}
}

class EmbeddedDocumentExtraDiff extends _BaseEmbeddedDocumentExtraMissingDiff {
	_prefix = "Delete";
	_propDoc = "docOld";
	_ClsRendered = RenderedEmbeddedDocumentExtraDiff;

	get _isDefaultApply () { return !!this._config.isSkipEmbedRemoveExtra; }
}

class EmbeddedDocumentMissingDiff extends _BaseEmbeddedDocumentExtraMissingDiff {
	_prefix = "Add";
	_propDoc = "docNu";
	_ClsRendered = RenderedEmbeddedDocumentMissingDiff;

	get _isDefaultApply () { return !!this._config.isSkipEmbedAddMissing; }
}

class EmbeddedDocumentDiff extends _BaseDiff {
	constructor ({ClsEmbedDocSub, propCollection, docOld, docNu, fieldDiffs, ...rest}) {
		super({...rest});
		this._ClsEmbedDocSub = ClsEmbedDocSub;
		this._propCollection = propCollection;
		this._docOld = docOld;
		this._docNu = docNu;
		this._fieldDiffs = fieldDiffs;
	}

	get isNonFalsy () { return this._fieldDiffs.some(diff => diff.isNonFalsy); }

	render ({selectClickHandler, depth = 0}) {
		const selectClickHandlerSub = new RenderedDiffSelectClickHandler();

		const rdsChildren = this._fieldDiffs
			.filter(diff => diff.isNonFalsy)
			.map(diff => diff.render({selectClickHandler: selectClickHandlerSub, depth: depth + 1}));

		const cbApply = this._getCbApply();

		const wrpRow = e_({
			tag: "div",
			clazz: `ve-flex-v-center ${this._isDefaultApply ? "list-multi-selected" : ""}`,
			children: [
				cbApply,
				e_({
					tag: "div",
					clazz: "ve-flex w-100 no-wrap",
					children: [
						e_({
							tag: "div",
							clazz: "ve-flex-v-center ve-flex-h-right mr-3 no-shrink w-140p whitespace-normal py-1p",
							children: [
								e_({
									tag: "div",
									clazz: "ve-flex-col",
									children: [
										e_({
											tag: "span",
											clazz: "word-break-all text-center",
											text: `\u201C${this._getDisplayName({Cls: this._ClsEmbedDocSub, doc: this._docOld})}\u201D`,
											title: this._getDisplayName({Cls: this._ClsEmbedDocSub, doc: this._docOld}),
										}),
										e_({
											tag: "span",
											clazz: "py-1 text-center",
											text: "\u2192",
										}),
										e_({
											tag: "span",
											clazz: "word-break-all text-center",
											text: `\u201C${this._getDisplayName({Cls: this._ClsEmbedDocSub, doc: this._docNu})}\u201D`,
											title: this._getDisplayName({Cls: this._ClsEmbedDocSub, doc: this._docNu}),
										}),
									],
								}),
							],
						}),
						e_({
							tag: "div",
							clazz: "ve-flex-h-center ve-flex-col w-100 p-2 b-1p conu__wrp-embedded-diff my-1p",
							children: rdsChildren.map(it => it.wrpRow),
						}),
					],
				}),
			],
		});

		const rd = new RenderedEmbeddedDocumentDiff({
			cbApply,
			wrpRow,
			rdsChildren,
			ClsEmbedDocSub: this._ClsEmbedDocSub,
			docOld: this._docOld,
		});

		selectClickHandler.add(rd);

		return rd;
	}
}

class ImportedContentDiffer {
	static _State = class {
		constructor () {
			this.diffs = [];
			this.propPath = [];
		}
	};

	static getDiff ({config, defaultSkipSelections, pair, idSwapper}) {
		const jsonOld = foundry.utils.deepClone(pair.old);
		const jsonNu = foundry.utils.deepClone(pair.nu);

		this._mutRemoveIgnored({jsonOld, jsonNu});

		idSwapper.mutPairJsons({pair, jsonOld, jsonNu});

		const subDiffs = this._getSubDiffs({config, defaultSkipSelections, pair, idSwapper});

		const jsonFlatOld = foundry.utils.flattenObject(jsonOld);
		const jsonFlatNu = foundry.utils.flattenObject(jsonNu);

		const state = new this._State();

		this._recurseDiff({config, defaultSkipSelections, ClsDoc: pair.ClsDoc, old: jsonFlatOld, nu: jsonFlatNu, state, idSwapper});

		return [
			...state.diffs,
			...subDiffs,
		];
	}

	static getSubDiffs ({config, defaultSkipSelections, pair, idSwapper}) {
		return this._getSubDiffs({config, defaultSkipSelections, pair, idSwapper});
	}

	static _mutRemoveIgnored ({jsonOld, jsonNu}) {
				[
			"_id",
			"_stats",
			"sort",
			"ownership",
			"folder",
		]
			.forEach(kIgnore => {
				delete jsonOld[kIgnore];
				delete jsonNu[kIgnore];
			});

				[
			"exportSource",
		]
			.forEach(flagIgnore => {
				delete jsonOld.flags?.[flagIgnore];
				delete jsonNu.flags?.[flagIgnore];
			});

		[
			["core", "sourceId"],
			[SharedConsts.MODULE_ID, Consts.FLAG_IS_DEV_CLEANUP],
		]
			.forEach(flagIgnorePath => {
				MiscUtil.delete(jsonOld.flags, ...flagIgnorePath);
				MiscUtil.delete(jsonNu.flags, ...flagIgnorePath);
			});
			}

	static _getSubDiffs ({config, defaultSkipSelections, pair, idSwapper}) {
										return pair.children
			.map(pair => {
				if (!pair.old && !pair.nu) throw new Error(`Should never occur!`);

				if (!pair.nu) {
					return new EmbeddedDocumentExtraDiff({
						config,
						defaultSkipSelections,
						ClsEmbedDocSub: pair.ClsDoc,
						propCollection: pair.propCollection,
						docOld: pair.old,
					});
				}

				if (!pair.old) {
					return new EmbeddedDocumentMissingDiff({
						config,
						defaultSkipSelections,
						ClsEmbedDocSub: pair.ClsDoc,
						propCollection: pair.propCollection,
						docNu: pair.nu,
					});
				}

				const fieldDiffs = ImportedContentDiffer.getDiff({config, defaultSkipSelections, pair, idSwapper});
				if (!fieldDiffs.length) return null;

				return new EmbeddedDocumentDiff({
					config,
					defaultSkipSelections,
					ClsEmbedDocSub: pair.ClsDoc,
					propCollection: pair.propCollection,
					docOld: pair.old,
					docNu: pair.nu,
					fieldDiffs,
				});
			})
			.filter(Boolean);
	}

	static _getProp (state) {
		return state.propPath.join(".");
	}

	static _recurseDiff ({config, defaultSkipSelections, ClsDoc, old, nu, state, idSwapper}) {
		if (old == null && nu == null) return;

		const toA = typeof old;
		const toB = typeof nu;

		if (toA !== toB) {
			state.diffs.push(
				new FieldDiff({
					config,
					defaultSkipSelections,
					ClsDoc,
					prop: this._getProp(state),
					valueOld: old,
					valueNu: nu,
				}),
			);
			return;
		}

		switch (toA) {
						case "boolean":
			case "number": {
				if (old !== nu) {
					state.diffs.push(
						new FieldDiff({
							config,
							defaultSkipSelections,
							ClsDoc,
							prop: this._getProp(state),
							valueOld: old,
							valueNu: nu,
						}),
					);
				}
				break;
			}

			case "string": {
				const nuSwapped = idSwapper.getSwapped(nu);
				if (old !== nuSwapped) {
					state.diffs.push(
						new FieldDiff({
							config,
							defaultSkipSelections,
							ClsDoc,
							prop: this._getProp(state),
							valueOld: old,
							valueNu: nuSwapped,
						}),
					);
				}
				break;
			}

						case "object": {
				const isArrA = old instanceof Array;
				const isArrB = nu instanceof Array;

								if (isArrA !== isArrB) {
					state.diffs.push(
						new FieldDiff({
							config,
							defaultSkipSelections,
							ClsDoc,
							prop: this._getProp(state),
							valueOld: old,
							valueNu: nu,
						}),
					);
					break;
				}

								if (isArrA) {
					if (!CollectionUtil.deepEquals(old, nu)) {
						state.diffs.push(
							new FieldDiff({
								config,
								defaultSkipSelections,
								ClsDoc,
								prop: this._getProp(state),
								valueOld: old,
								valueNu: nu,
							}),
						);
					}
					break;
				}

				[
					...Object.keys(old),
					...Object.keys(nu),
				]
					.unique()
					.forEach(k => {
						state.propPath.push(k);
						this._recurseDiff({config, defaultSkipSelections, ClsDoc, old: old[k], nu: nu[k], state, idSwapper});
						state.propPath.pop();
					});
			}
		}
	}
}

class IdSwapper {
	constructor (pair) {
		const {swapMapUuid, swapMapId} = this._getSwapMaps({pair});
		this._swapMapUuid = swapMapUuid;
		this._swapMapId = swapMapId;

		const {regexesUuid, regexesId} = this._getRegexes({pair});
		this._regexesUuid = regexesUuid;
		this._regexesId = regexesId;
	}

	_getSwapMaps ({pair}) {
		const outUuid = {};
		const outId = {};

		const recurse = (pair, keyStack = []) => {
			if (!pair.old || !pair.nu) return;

			const nuId = pair.nu._id || pair.nu.id;

			const ptKey = `${pair.ClsDoc.metadata.name}.${nuId}`;

			const key = [...keyStack, ptKey].join(".");
			outUuid[key] = pair;

						if (keyStack.length) outId[nuId] = pair;

			pair.children.forEach(child => recurse(child, [...keyStack, ptKey]));
		};

		recurse(pair);

		return {swapMapUuid: outUuid, swapMapId: outId};
	}

	_getRegexes ({pair}) {
		const outUuid = [];
		const outId = [
						new RegExp(`(?<pre>^)(?<uuid>${Consts.RE_ID_STR})(?<post>$)`, "g"),
		];

		const recurse = (ClsDoc, ClsDocStack = []) => {
			const ptMiddle = [...ClsDocStack, ClsDoc]
				.map(Cls => `${Cls.metadata.name}\\.${Consts.RE_ID_STR}`)
				.join("\\.");

			outUuid.push(
				new RegExp(
					`(?<pre>^|\\[)(?<uuid>${ptMiddle})(?<post>]|$)`,
					"g",
				),
			);

			Object.keys(ClsDoc.metadata.embedded || {})
				.forEach(clazzName => {
										const ClsEmbedDocSub = eval(clazzName);

					recurse(ClsEmbedDocSub, [...ClsDocStack, ClsDoc]);
				});
		};

		recurse(pair.ClsDoc);

				outUuid.reverse();

		return {regexesUuid: outUuid, regexesId: outId};
	}

	getSwapped (str) {
		[
			{
				swapMap: this._swapMapUuid,
				regexes: this._regexesUuid,
				fnGetReplacement: pair => pair.getUuidOld(),
			},
			{
				swapMap: this._swapMapId,
				regexes: this._regexesId,
				fnGetReplacement: pair => pair.getIdOld(),
			},
		]
			.forEach(({swapMap, regexes, fnGetReplacement}) => {
				regexes
					.forEach(re => {
						str = str
							.replace(re, (...m) => {
								const pair = swapMap[m.last().uuid];
								if (!pair) return m[0];

								return [
									m.last().pre,
									fnGetReplacement(pair),
									m.last().post,
								]
									.join("");
							});
					});
			});

		return str;
	}

	
	mutPairJsons ({pair, jsonOld, jsonNu}) {
		this._mutPairJsons_Item_class({pair, jsonOld, jsonNu});
	}

	_mutPairJsons_Item_class ({pair, jsonOld, jsonNu}) {
		if (pair.ClsDoc !== Item || jsonOld.type !== "class") return;

						if (jsonOld.system.advancement?.length && jsonNu.system.advancement?.length) {
			this._mutPairJsons_Item_class_getAdvancementPairs({jsonOld, jsonNu})
				.forEach(({old, nu}) => nu._id = old._id);
		}
	}

	_mutPairJsons_Item_class_getAdvancementPairs ({jsonOld, jsonNu}) {
		const pairs = [];

		jsonOld.system.advancement
			.forEach(advOld => {
				const ident = advOld.configuration?.identifier;
				if (!ident) return;

				const advNu = jsonNu.system.advancement
					.find(adv => adv.configuration?.identifier === ident);
				if (!advNu) return;

				pairs.push({old: advOld, nu: advNu});
			});

		const hpOlds = jsonOld.system.advancement.filter(adv => adv.type === "HitPoints");
		const hpNus = jsonNu.system.advancement.filter(adv => adv.type === "HitPoints");

		if (hpOlds.length === 1 && hpNus.length === 1) pairs.push({old: hpOlds[0], nu: hpNus[0]});

		return pairs;
	}
}

class _ContentPair {
	constructor ({ClsDoc, propCollection, old, nu, parent = null, children}) {
		this.ClsDoc = ClsDoc;
		this.propCollection = propCollection;
		this.old = old;
		this.nu = nu;
		this.parent = parent;
		this.children = children;
	}

	getNodesAtDepth (depth) {
		if (isNaN(depth) || depth < 0) throw new Error(`Depth must be >= 0! This is a bug!`);
		if (depth === 0) return [this];

		const out = [];

		const recurse = (node, recurseDepth) => {
			if (recurseDepth === depth) return out.push(node);
			(node.children || []).forEach(n => recurse(n, recurseDepth + 1));
		};

		return out;
	}

	getUuidOld () {
		const uuid = `${this.ClsDoc.metadata.name}.${this.getIdOld()}`;
		if (!this.parent) return uuid;

		return [
			this.parent.getUuidOld(),
			uuid,
		].join(".");
	}

	getIdOld () {
		return this.old._id || this.old.id;
	}
}

class ContentPairer {
	static getPair (ClsDoc, jsonOld, jsonNu, {propCollection = null, parent = null} = {}) {
		const pair = new _ContentPair({
			ClsDoc,
			propCollection,
			old: jsonOld,
			nu: jsonNu,
			parent,
		});

		pair.children = this._getPair_getChildren({ClsDoc, jsonOld, jsonNu, parent: pair});

		return pair;
	}

		static getFauxEmbedPair (
		{
			ClsDoc,
			json,
			ClsEmbedDocSub,
			propCollection,
			jsonEmbedOld,
			jsonEmbedNu,
		},
	) {
		const pair = new _ContentPair({
			ClsDoc,
			propCollection: null,
			old: json,
			nu: json,
			parent: null,
		});

		pair.children = this._getPair_getChildrenFromEmbeddedCollection({
			ClsEmbedDocSub,
			propCollection,
			arrSubOld: [jsonEmbedOld],
			arrSubNu: [jsonEmbedNu],
			parent: null,
		});

		return pair;
	}

	static _getPair_getChildren ({ClsDoc, jsonOld, jsonNu, parent}) {
		if (!jsonOld || !jsonNu) return [];

		return Object.entries(ClsDoc.metadata.embedded || {})
			.flatMap(([clazzName, propCollection]) => {
								const ClsEmbedDocSub = eval(clazzName);

				const arrSubOld = jsonOld[propCollection];
				const arrSubNu = jsonNu[propCollection];
				delete jsonOld[propCollection];
				delete jsonNu[propCollection];

				return this._getPair_getChildrenFromEmbeddedCollection({
					ClsEmbedDocSub,
					propCollection,
					arrSubOld,
					arrSubNu,
					parent,
				});
			});
	}

	static _getPair_getChildrenFromEmbeddedCollection ({ClsEmbedDocSub, propCollection, arrSubOld, arrSubNu, parent}) {
		const pairsRaw = [];

		const toPairOld = [...arrSubOld];
		const toPairNu = [...arrSubNu];

		toPairOld
			.forEach(docJsonOld => {
				const pair = {
					old: docJsonOld,
					nu: null,
				};
				pairsRaw.push(pair);

				const plutFlags = docJsonOld.flags?.[SharedConsts.MODULE_ID];
				if (!plutFlags) return;

				const {page, source, hash, dedupeId} = plutFlags;
				if (
					(!page || !source || !hash)
					&& !dedupeId
				) return;

				const ixNu = toPairNu.findIndex(docJsonNu => {
					const {page: pageNu, source: sourceNu, hash: hashNu, dedupeId: dedupeIdNu} = docJsonNu.flags?.[SharedConsts.MODULE_ID] || {};
					return (
						[
							page,
							pageNu,
							source,
							sourceNu,
							hash,
							hashNu,
						].every(Boolean)
							&& page === pageNu
							&& source === sourceNu
							&& hash === hashNu
					)
						|| (
							[
								dedupeId,
								dedupeIdNu,
							].every(Boolean)
							&& dedupeId === dedupeIdNu
						);
				});

				if (!~ixNu) return;

				pair.nu = toPairNu[ixNu];
				toPairNu.splice(ixNu, 1);
			});

		toPairNu
			.forEach(docJsonNu => {
				pairsRaw.push({
					old: null,
					nu: docJsonNu,
				});
			});

		return pairsRaw
			.map(pair => {
				return ContentPairer.getPair(
					ClsEmbedDocSub,
					pair.old,
					pair.nu,
					{
						propCollection,
						parent,
					},
				);
			});
	}
}

class _UpdatableContentMeta {
	static LOCATION_TYPES = {
		DIRECTORY: "DIRECTORY",
		PACK: "PACK",
		SCENE: "SCENE",
	};

	constructor (
		{
			document,
			locationType,
			location = null,
		},
	) {
		this.document = document;
		this.locationType = locationType;
		this.location = location;
		this.diffs = [];
		this.rdDiffs = [];
	}

	get displayName () { return this.document.name; }
	get documentType () { return this.document.constructor.metadata.name; }
	get documentSubtype () { return this.document.type; }

	get displayLocation () {
		switch (this.locationType) {
			case this.constructor.LOCATION_TYPES.DIRECTORY: return "Directory";
			case this.constructor.LOCATION_TYPES.PACK: return `Compendium (${this.location.metadata.label})`;
			case this.constructor.LOCATION_TYPES.SCENE: return `Scene (${this.location.name})`;
			default: throw new Error(`Unhandled location type "${this.locationType}"`);
		}
	}
}

class _UpdatableDocMetaBuilderBase {
	_LOCATION_TYPE;

	constructor ({importerCache, docTypeMeta, config, defaultSkipSelections}) {
		this._config = config;
		this._importerCache = importerCache;
		this._docTypeMeta = docTypeMeta;
		this._config = config;
		this._defaultSkipSelections = defaultSkipSelections;
	}

		get _isRun () { throw new Error("Unimplemented!"); }

		getApproxGetDocsCount () { throw new Error("Unimplemented!"); }

	async pGetImportableDocs (progressBarManager) {
		if (!this._isRun) return [];
		return this._pGetImportableDocs({progressBarManager});
	}

		async _pGetImportableDocs ({progressBarManager}) { throw new Error("Unimplemented!"); }

	async pGetUpdatableContentMetas (progressBarManager, docs) {
		if (!this._isRun) return [];
		return (await docs.pSerialAwaitMap(async doc => this._pGetUpdatableContentMeta({progressBarManager, doc})))
			.filter(Boolean);
	}

		_getLocation () { throw new Error("Unimplemented!"); }

	_getProgressContext (doc) { return `${this.constructor.name}-${doc.constructor.name}-${doc.id || doc._id}`; }

	async _pGetUpdatableContentMeta ({progressBarManager, doc}) {
		const meta = new _UpdatableContentMeta({
			document: doc,
			locationType: this._LOCATION_TYPE,
			location: this._getLocation(),
		});

		const importer = await this._importerCache.pGetImporter(doc);

		const ent = await DataLoader.pCacheAndGet(
			doc.flags[SharedConsts.MODULE_ID].page,
			doc.flags[SharedConsts.MODULE_ID].source,
			doc.flags[SharedConsts.MODULE_ID].hash,
		);
		if (!ent) return void progressBarManager.incrementSubChunk(this._getProgressContext(doc));

		const importSummary = await importer.pImportEntry(
			ent,
			{
				isImportToTempDirectory: true,
				filterValues: doc.flags[SharedConsts.MODULE_ID].filterValues,
			},
		);
		if (!importSummary.getPrimaryDocument()) return void progressBarManager.incrementSubChunk(this._getProgressContext(doc));

		const pair = ContentPairer.getPair(
			this._docTypeMeta.Cls,
			doc.toObject({source: true}),
			importSummary.getPrimaryDocument().toObject({source: true}),
		);

		const diffs = ImportedContentDiffer.getDiff({
			config: this._config,
			defaultSkipSelections: this._defaultSkipSelections,
			pair,
			idSwapper: new IdSwapper(pair),
		});

		if (!diffs.length) return void progressBarManager.incrementSubChunk(this._getProgressContext(doc));

		meta.diffs = diffs;

		progressBarManager.incrementSubChunk(this._getProgressContext(doc));

		return meta;
	}

	
	static _REQUIRED_FLAG_PROPS = [
		"page",
		"source",
		"hash",
	];

	_isUpdatableDoc (doc) { return this.constructor._REQUIRED_FLAG_PROPS.every(prop => doc.flags?.[SharedConsts.MODULE_ID]?.[prop]); }

	async _pIsImportableDoc (progressBarManager, doc) {
		const out = (await this._importerCache.pGetImporter(doc)) !== this.constructor._SYM_NO_IMPORTER;
		if (progressBarManager) progressBarManager.incrementSubChunk(this._getProgressContext(doc));
		return out;
	}
}

class UpdatableDocMetaBuilderDirectory extends _UpdatableDocMetaBuilderBase {
	_LOCATION_TYPE = _UpdatableContentMeta.LOCATION_TYPES.DIRECTORY;

	constructor ({folderIdTemp, ...rest}) {
		super({...rest});
		this._folderIdTemp = folderIdTemp;
	}

	get _isRun () { return !!this._config.isRunOnDirectory; }

	_getCandidateDocs () {
		return game[this._docTypeMeta.Cls.metadata.collection]
			.filter(doc => doc.folder?.id !== this._folderIdTemp)
			.filter(this._isUpdatableDoc.bind(this));
	}

	getApproxGetDocsCount () { return this._getCandidateDocs().length; }

	async _pGetImportableDocs ({progressBarManager}) {
		progressBarManager.setMessage(`Analyzing ${game.i18n.localize(this._docTypeMeta.Cls.metadata.labelPlural)} directory...`);

		return this._getCandidateDocs()
			.pSerialAwaitFilter(this._pIsImportableDoc.bind(this, progressBarManager));
	}

	_getLocation () { return null; }
}

class UpdatableDocMetaBuilderDirectorySub extends _UpdatableDocMetaBuilderBase {
				static _VALID_PAGES = new Set([
		UrlUtil.PG_SPELLS,
		UrlUtil.PG_ITEMS,
	]);

	_LOCATION_TYPE = _UpdatableContentMeta.LOCATION_TYPES.DIRECTORY;

	constructor ({folderIdTemp, ...rest}) {
		super({...rest});
		this._folderIdTemp = folderIdTemp;
	}

	get _isRun () { return !!this._config.isRunOnDirectorySub; }

	_getCandidateDocs () {
		return game[this._docTypeMeta.Cls.metadata.collection]
			.filter(doc => doc.folder?.id !== this._folderIdTemp)
			.filter(doc => {
				if (this._isUpdatableDoc(doc)) return false;
				return Object.values(this._docTypeMeta.Cls.metadata.embedded)
					.some(prop => doc[prop].some(docSub => this._isUpdatableDoc(docSub)));
			});
	}

	getApproxGetDocsCount () { return this._getCandidateDocs().length; }

	async _pGetImportableDocs ({progressBarManager}) {
		progressBarManager.setMessage(`Analyzing ${game.i18n.localize(this._docTypeMeta.Cls.metadata.labelPlural)} directory embeds...`);

		return this._getCandidateDocs()
			.pSerialAwaitFilter(doc => {
				return Object.values(this._docTypeMeta.Cls.metadata.embedded)
					.pSerialAwaitFilter(prop => [...doc[prop]]
						.filter(this._isUpdatableDoc.bind(this))
						.pSerialAwaitSome(docSub => this._pIsImportableDoc(progressBarManager, docSub)),
					);
			});
	}

	_getLocation () { return null; }

	
	async _pGetUpdatableContentMeta ({progressBarManager, doc}) {
		const meta = new _UpdatableContentMeta({
			document: doc,
			locationType: this._LOCATION_TYPE,
			location: this._getLocation(),
		});

				const cpyObject = doc.toObject({source: true});
		delete cpyObject.id;
		delete cpyObject._id;
		cpyObject.folder = await UtilFolders.pCreateTempFolderGetId({folderType: this._docTypeMeta.Cls.metadata.name});
		Object.values(this._docTypeMeta.Cls.metadata.embedded)
			.forEach(propCollection => delete cpyObject[propCollection]);
		const docTmp = await this._docTypeMeta.Cls.create(cpyObject);
		
		const diffs = [];

		for (const [clazzName, propCollection] of Object.entries(this._docTypeMeta.Cls.metadata.embedded)) {
			if (!CONFIG.Folder.sheetClasses[clazzName]) continue;

			const updatableDocsSub = await doc[propCollection]
				.filter(docSub => this._isUpdatableDoc(docSub))
				.pSerialAwaitFilter(docSub => this._pIsImportableDoc(null, docSub));

			if (!updatableDocsSub.length) continue;

						const ClsEmbedDocSub = eval(clazzName);

			for (const updatableDocSub of updatableDocsSub) {
				if (!this.constructor._VALID_PAGES.has(updatableDocSub.flags[SharedConsts.MODULE_ID].page)) continue;

				const importer = await this._importerCache.pGetImporter(updatableDocSub, {docParent: docTmp});

				const ent = await DataLoader.pCacheAndGet(
					updatableDocSub.flags[SharedConsts.MODULE_ID].page,
					updatableDocSub.flags[SharedConsts.MODULE_ID].source,
					updatableDocSub.flags[SharedConsts.MODULE_ID].hash,
				);
				if (!ent) continue;

				const importSummary = await importer.pImportEntry(
					ent,
					{
						isImportToTempDirectory: true,
						filterValues: updatableDocSub.flags[SharedConsts.MODULE_ID].filterValues,
					},
				);
				if (!importSummary.getPrimaryDocument()) continue;

				const pair = ContentPairer.getFauxEmbedPair(
					{
						ClsDoc: this._docTypeMeta.Cls,
						json: doc.toObject({source: true}),
						ClsEmbedDocSub,
						propCollection,
						jsonEmbedOld: updatableDocSub.toObject({source: true}),
						jsonEmbedNu: importSummary.getPrimaryDocument().toObject({source: true}),
					},
				);

				const diffsSub = ImportedContentDiffer.getSubDiffs({
					config: this._config,
					defaultSkipSelections: this._defaultSkipSelections,
					pair,
					idSwapper: new IdSwapper(pair),
				});

				diffs.push(...diffsSub);
			}

			this._importerCache.flushParentCache();
		}

		await docTmp.delete();

		if (!diffs.length) return void progressBarManager.incrementSubChunk(this._getProgressContext(doc));

		meta.diffs = diffs;

		progressBarManager.incrementSubChunk(this._getProgressContext(doc));

		return meta;
	}
}

class UpdatableDocMetaBuilderPack extends _UpdatableDocMetaBuilderBase {
	_LOCATION_TYPE = _UpdatableContentMeta.LOCATION_TYPES.PACK;

	constructor ({pack, ...rest}) {
		super({...rest});
		this._pack = pack;
	}

	get _isRun () { return !!this._config.isRunOnPacks; }

	_getLocation () { return this._pack; }

	getApproxGetDocsCount () { return this._pack.index.size; }

	async _pGetImportableDocs ({progressBarManager}) {
		progressBarManager.setMessage(`Analyzing ${game.i18n.localize(this._docTypeMeta.Cls.metadata.labelPlural)} compendium "${this._pack.metadata.label}"...`);

				return (await this._pack.getDocuments())
			.filter(this._isUpdatableDoc.bind(this))
			.pSerialAwaitFilter(this._pIsImportableDoc.bind(this, progressBarManager));
	}
}

class UpdatableDocMetaBuilderScene extends _UpdatableDocMetaBuilderBase {
	_LOCATION_TYPE = _UpdatableContentMeta.LOCATION_TYPES.SCENE;

	constructor ({scene, ...rest}) {
		super({...rest});
		this._scene = scene;
	}

	get _isRun () { return !!this._config.isRunOnScene && !!this._docTypeMeta.isIncludeScene; }

	_getCandidateDocs () {
		return canvas.tokens.placeables
			.map(tk => tk.actor)
			.filter(Boolean)
			.filter(act => act.isToken)
			.unique(act => act.uuid) 			.filter(this._isUpdatableDoc.bind(this));
	}

	_getLocation () { return this._scene; }

	getApproxGetDocsCount () { return this._getCandidateDocs().length; }

	async _pGetImportableDocs ({progressBarManager}) {
		progressBarManager.setMessage(`Analyzing ${game.i18n.localize(this._docTypeMeta.Cls.metadata.labelPlural)} in current scene...`);

		return this._getCandidateDocs()
			.pSerialAwaitFilter(this._pIsImportableDoc.bind(this, progressBarManager));
	}
}

class ContentUpdaterApp extends Application {
	constructor ({data}) {
		super(
			{
				title: ContentUpdaterConsts.APP_TITLE,
				template: `${SharedConsts.MODULE_LOCATION}/template/ContentUpdater.hbs`,
				width: 960,
				height: Util.getMaxWindowHeight(),
				resizable: true,
			},
		);

		this._impl = new _ContentUpdaterImpl({data});
	}

	activateListeners ($html) {
		super.activateListeners($html);

		this._pRender($html).then(null);
	}

	async _pRender ($html) {
		$$($html)`
			${this._pRender_$getControlsTop()}
			<hr class="hr-2">
			${await this._pRender_$pGetStgDocuments()}
		`;
	}

	_pRender_$getControlsTop () {
		return $$`<div class="ve-flex-v-center">
			<div class="btn-group ve-flex-v-center">
				${this._impl.$getBtnConfigureDefaultSelection()}
				${this._impl.$getBtnHelp()}
			</div>

			<div class="btn-group ve-flex-v-center ml-auto">
				${this._impl.$getBtnAnalyze()}
				${this._impl.$getBtnUpdate()}
			</div>
		</div>`;
	}

	async _pRender_$pGetStgDocuments () {
		const $stg = $(`<div class="ve-flex-col w-100 h-100 min-h-0"></div>`);
		this._impl.render($stg);
		return $stg;
	}
}

class _ListRenderState {
	constructor (
		{
			docMetas,
		},
	) {
		this.docMetas = docMetas;
		this.list = null;

		this._$btnToggleAll = null;
	}

	set $btnToggleAll ($btn) { this._$btnToggleAll = $btn; }

	doExpandAllListItems () {
		this._doToggleAllListItems(false);
	}

	doCollapseAllListItems () {
		this._doToggleAllListItems(true);
	}

	_doToggleAllListItems (isHidden) {
		const nxtHtml = isHidden ? ListUiUtil.HTML_GLYPHICON_EXPAND : ListUiUtil.HTML_GLYPHICON_CONTRACT;
		this._$btnToggleAll.html(nxtHtml);

		this.list.items.forEach(it => {
			it.data.btnTogglePreview.innerHTML = nxtHtml;
			it.data.eleWrpConfig.classList.toggle("ve-hidden", isHidden);
		});
	}

	doToggleAllListItems () {
		if (this._$btnToggleAll.html().trim() === ListUiUtil.HTML_GLYPHICON_EXPAND) return this.doExpandAllListItems();
		else this.doCollapseAllListItems();
	}
}

class _AppFilterListContentUpdater extends AppFilter {
	constructor () {
		super();

		this._typeFilter = new Filter({header: "Type"});
		this._subtypeFilter = new Filter({header: "Subtype"});
	}

	addToFilters (docMeta, isExcluded) {
		if (isExcluded) return;

		this._typeFilter.addItem(docMeta.documentType);
		this._subtypeFilter.addItem(docMeta.documentSubtype);
	}

	async _pPopulateBoxOptions (opts) {
		opts.filters = [
			this._typeFilter,
			this._subtypeFilter,
		];
	}

	toDisplay (values, docMeta) {
		return this._filterBox.toDisplay(
			values,
			docMeta.documentType,
			docMeta.documentSubtype,
		);
	}
}

class _ListManager {
	constructor () {
		this._pageFilter = new _AppFilterListContentUpdater();
		this._rdState = null;
	}

	getUpdaters () {
		const liLookup = this._rdState.list.items
			.mergeMap(li => ({[li.ix]: li}));

		return this._rdState.docMetas
			.map((docMeta, ix) => {
				const listItem = liLookup[ix];
				if (!listItem) return null;

				if (!listItem?.data?.cbSel?.checked) return null;

				return {
					docMeta,
					listItem,
				};
			})
			.filter(Boolean)
			.map(({docMeta, listItem}) => new DiffUpdater({docMeta, list: this._rdState.list, listItem}));
	}

	updateList () { this._rdState.list.update(); }

	static _sortList (a, b, o) {
		const base = SortUtil.ascSort(a.values[o.sortBy], b.values[o.sortBy]);
		switch (o.sortBy) {
			case "documentType": return base
				|| SortUtil.ascSort(a.values.documentSubtype, b.values.documentSubtype)
				|| SortUtil.compareListNames(a, b);
			case "documentSubtype": return base
				|| SortUtil.ascSort(a.values.documentType, b.values.documentType)
				|| SortUtil.ascSort(a.values.documentSubtype, b.values.documentSubtype)
				|| SortUtil.compareListNames(a, b);
			default: return base
				|| SortUtil.compareListNames(a, b);
		}
	}

	async pRender ({docMetas}) {
		const rdState = this._rdState = new _ListRenderState({docMetas});

		const $btnFilter = this._render_$getBtnFilter();
		const $btnToggleFilterSummary = this._render_$getBtnToggleFilterSummary();
		const $iptSearch = this._render_$getIptSearch();
		const $btnReset = this._render_$getBtnReset({$iptSearch, rdState});

		const $wrpMinis = this._render_$getWrpMinis();

		const $cbSelectAll = this._render_$getCbSelectAll();
		const $btnToggleAll = this._render_$getBtnToggleAll({rdState});
		rdState.$btnToggleAll = $btnToggleAll;
		const $wrpBtnsSort = this._render_$getWrpBtnsSort({$cbSelectAll, $btnToggleAll});

		const $wrpList = this._render_$pGetStgList();

		const $out = $$`<div class="ve-flex-col ve-window min-h-0 h-100">
			<div class="ve-flex-v-stretch input-group input-group--top">
				${$btnFilter}
				${$btnToggleFilterSummary}
				${$iptSearch}
				${$btnReset}
			</div>
			${$wrpMinis}
			${$wrpBtnsSort}
			${$wrpList}
		</div>`;

				rdState.list = new List({
			$iptSearch,
			$wrpList,
			fnSort: this.constructor._sortList.bind(this.constructor),
		});
		SortUtil.initBtnSortHandlers($wrpBtnsSort, rdState.list);
		rdState.listSelectClickHandler = new ListSelectClickHandler({list: rdState.list});
		this._render_doBindSelectAll($cbSelectAll, rdState);

		await this._pageFilter.pInitFilterBox({
			$iptSearch,
			$btnReset,
			$btnOpen: $btnFilter,
			$btnToggleSummaryHidden: $btnToggleFilterSummary,
			$wrpMiniPills: $wrpMinis,
			namespace: `content-updater`,
		});

		for (let i = 0; i < docMetas.length; ++i) {
			const docMeta = docMetas[i];
			this._pageFilter.addToFilters(docMeta);
			const rowMeta = this._render_getRowMeta(rdState, docMeta, i);
			if (!rowMeta) continue;
			rdState.list.addItem(rowMeta.listItem);
		}
		rdState.list.update();

		rdState.list.init();

		this._pageFilter.trimState();
		this._pageFilter.filterBox.render();

		const boundFilterChange = this._handleFilterChange.bind(this, rdState);

		this._pageFilter.filterBox.off(FilterBox.EVNT_VALCHANGE);
		this._pageFilter.filterBox.on(FilterBox.EVNT_VALCHANGE, boundFilterChange);
		boundFilterChange();

		return $out;
	}

	_handleFilterChange (rdState) {
		const f = this._pageFilter.filterBox.getValues();
		rdState.list.filter(li => this._pageFilter.toDisplay(f, rdState.docMetas[li.ix]));
	}

	_render_doBindSelectAll ($cbAll, rdState) { rdState.listSelectClickHandler.bindSelectAllCheckbox($cbAll); }

	_render_$getBtnFilter () {
		return $(`<button class="btn-5et veapp__btn-filter" name="btn-filter">Filter</button>`);
	}

	_render_$getBtnToggleFilterSummary () {
		return $(`<button class="btn btn-5et" title="Toggle Filter Summary Display" name="btn-toggle-summary"><span class="glyphicon glyphicon-resize-small"></span></button>`);
	}

	_render_$getIptSearch () {
		return $(`<input type="search" class="search w-100 form-control h-initial" placeholder="Find documents...">`);
	}

	_render_$getBtnReset ({$iptSearch, rdState}) {
		return $(`<button class="btn-5et veapp__btn-list-reset" name="btn-reset" title="Reset filters. SHIFT to reset everything.">Reset</button>`)
			.click(evt => {
				$iptSearch.val("");
				if (rdState.list) {
					if (evt.shiftKey) rdState.doCollapseAllListItems();
					rdState.list.reset();
				}
			});
	}

	_render_$getWrpMinis () {
		return $(`<div class="fltr__mini-view btn-group"></div>`);
	}

	_render_$getCbSelectAll () {
		return $(`<input type="checkbox" name="cb-select-all">`);
	}

	_render_$getBtnToggleAll ({rdState}) {
		return $(`<button type="button" class="btn-5et col-0-5 px-1 ve-muted">${ListUiUtil.HTML_GLYPHICON_EXPAND}</button>`)
			.click(evt => {
				evt.stopPropagation();
				evt.preventDefault();

				rdState.doToggleAllListItems();
			});
	}

	_render_$getWrpBtnsSort ({$cbSelectAll, $btnToggleAll}) {
		return $$`<div class="ve-flex-v-stretch input-group input-group--bottom mb-1" data-name="wrp-btns-sort">
			<label class="btn btn-5et col-0-5 ve-flex-vh-center">${$cbSelectAll}</label>
			${$btnToggleAll}
			<button class="btn-5et col-4-5 sort name" data-sort="name">Name</button>
			<button class="btn-5et col-1-2 sort" data-sort="documentType">Type</button>
			<button class="btn-5et col-1-2 sort" data-sort="documentSubtype">Subtype</button>
			<button class="btn-5et col-4-1 sort" data-sort="documentSubtype">Location</button>
		</div>`;
	}

	_render_$pGetStgList () {
		return $(`<div class="veapp__list h-100 mb-1"></div>`);
	}

	
	_render_getRowMeta (rdState, docMeta, ix) {
		const cbSel = e_({
			tag: "input",
			clazz: "no-events",
			type: "checkbox",
		});

		const btnTogglePreview = e_({
			tag: "span",
			clazz: `ui-list__btn-inline`,
			title: "Toggle Configuration",
			html: ListUiUtil.HTML_GLYPHICON_EXPAND,
			click: evt => {
				evt.stopPropagation();
				evt.preventDefault();

				const nxtHtml = btnTogglePreview.innerHTML.trim() === ListUiUtil.HTML_GLYPHICON_EXPAND ? ListUiUtil.HTML_GLYPHICON_CONTRACT : ListUiUtil.HTML_GLYPHICON_EXPAND;
				const isHidden = nxtHtml === ListUiUtil.HTML_GLYPHICON_EXPAND;
				btnTogglePreview.innerHTML = nxtHtml;

				eleWrpConfig.classList.toggle("ve-hidden", isHidden);
			},
		});

		const selectClickHandler = new RenderedDiffSelectClickHandler();

		docMeta.rdDiffs = docMeta.diffs
			.filter(diff => diff.isNonFalsy)
			.map(diff => diff.render({selectClickHandler}));

		if (!docMeta.rdDiffs.length) return null;

		const eleWrpConfig = e_({
			tag: "div",
			clazz: "ve-flex w-100 py-2 ve-hidden",
			children: [
				e_({tag: "div", clazz: "col-1 no-shrink"}),
				e_({
					tag: "div",
					clazz: "col-11 ve-flex-col py-1 pr-1 conu__wrp-details btr-0 btl-0",
					children: docMeta.rdDiffs.map(({wrpRow}) => wrpRow),
					click: evt => {
						evt.stopPropagation();
					},
				}),
			],
		});

		const eleLi = e_({
			tag: "div",
			clazz: `ve-flex-col w-100 veapp__list-row no-select py-2p`,
			children: [
								e_({
					tag: "div",
					clazz: `ve-flex w-100 veapp__list-row-hoverable`,
					children: [
						e_({
							tag: "label",
							clazz: `col-0-5 ve-flex-vh-center ve-self-flex-stretch`,
							children: [cbSel],
						}),
						e_({
							tag: "label",
							clazz: `col-0-5 ve-flex-vh-center ve-flex-vh-center`,
							children: [btnTogglePreview],
						}),
						e_({tag: "span", clazz: "col-4-5", text: docMeta.displayName}),
						e_({tag: "span", clazz: "col-1-2 ve-flex-vh-center code", text: docMeta.documentType}),
						e_({tag: "span", clazz: "col-1-2 ve-flex-vh-center code", text: docMeta.documentSubtype}),
						e_({tag: "span", clazz: "col-4-1", text: docMeta.displayLocation}),
					],
					keydown: evt => this._pHandleKeydown_row(evt, {rdState, listItem}),
					attrs: {
						tabindex: 0,
					},
				}),

				eleWrpConfig,
			],
		});

		const listItem = new ListItem(
			ix,
			eleLi,
			docMeta.displayName,
			{
				documentType: docMeta.documentType,
				documentSubtype: docMeta.documentSubtype,
				displayLocation: docMeta.displayLocation,
			},
			{
				cbSel,
				btnTogglePreview,

				eleWrpConfig,
			},
		);

		eleLi.addEventListener("click", evt => rdState.listSelectClickHandler.handleSelectClick(listItem, evt, {isPassThroughEvents: true}));

		return {
			listItem,
		};
	}

	async _pHandleKeydown_row (evt, {rdState, listItem}) {
		switch (evt.key) {
			case "Enter": {
				rdState.listSelectClickHandler.handleSelectClick(listItem, evt, {isPassThroughEvents: true});
				return;
			}

			case "ArrowUp": {
				const ixCur = rdState.list.visibleItems.indexOf(listItem);

				if (~ixCur) {
					const prevItem = rdState.list.visibleItems[ixCur - 1];
					if (prevItem) {
						evt.stopPropagation();
						evt.preventDefault();
						prevItem.ele.focus();
					}
					return;
				}

				const firstItem = rdState.list.visibleItems[0];
				if (firstItem) {
					evt.stopPropagation();
					evt.preventDefault();
					firstItem.ele.focus();
				}
				return;
			}

			case "ArrowDown": {
				const ixCur = rdState.list.visibleItems.indexOf(listItem);

				if (~ixCur) {
					const nxtItem = rdState.list.visibleItems[ixCur + 1];
					if (nxtItem) {
						evt.stopPropagation();
						evt.preventDefault();
						nxtItem.ele.focus();
					}
					return;
				}

				const lastItem = rdState.list.visibleItems.last();
				if (lastItem) {
					evt.stopPropagation();
					evt.preventDefault();
					lastItem.ele.focus();
				}
			}
		}
	}
}

class _ImporterCache {
	constructor () {
		this._importers = {};
		this._importersParents = {};
	}

	async pGetImporter (doc, {docParent} = {}) {
		if (docParent && !(docParent instanceof Actor)) throw new Error(`Only "Actor" is supported as a parent document type!`);

		const tgt = docParent ? this._importersParents : this._importers;

		const page = doc.flags[SharedConsts.MODULE_ID].page;

		if (tgt[page]) return tgt[page];

		const importer = docParent
			? ChooseImporter.getImporter(page, {actor: docParent})
			: ChooseImporter.getImporter(page);
		if (!importer) return tgt[page] = this.constructor._SYM_NO_IMPORTER;

		return tgt[page] = (async () => {
			await importer.pInit();
			return importer;
		})();
	}

	flushParentCache () {
		this._importersParents = {};
	}
}

class _ContentUpdaterImpl extends BaseComponent {
	static _SYM_NO_IMPORTER = Symbol("NO_IMPORTER");

	constructor ({data}) {
		super();
		this._data = data;

		this._lock_triggerOperation = new VeLock({name: "trigger operation"});
		this._lock_refreshDocuments = new VeLock({name: "refresh documents"});

		this._listManager = new _ListManager();
	}

	_getDefaultState () {
		return {
			docMetas: [],
		};
	}

	
	render ($parent) {
		const pHk = this._addHookBase("docMetas", async () => {
			await this._pDoDocumentRefresh({$parent});
		});
		pHk();
	}

	async _pDoDocumentRefresh ({$parent}) {
		const docMetas = [
			...this._state.docMetas,
		];

		try {
			await this._lock_refreshDocuments.pLock();
			const $stg = await this._listManager.pRender({docMetas});
			$parent.empty().append($stg);
		} finally {
			this._lock_refreshDocuments.unlock();
		}
	}

	
	$getBtnHelp () {
		return $(`<button class="btn btn-default" type="button" title="Help"><i class="fa fa-question-circle"></i></button>`)
			.click(async () => {
				const {$modalInner, doAutoResize} = await UtilApplications.pGetShowApplicationModal({
					title: `Help`,
				});

				$$($modalInner)`<div class="ve-flex-col w-100">
					<p>This tool can be used to update Plutonium-imported content. These updates are destructive, so ensure you <b>create a backup of your world</b> before running the tool. To use the tool:</p>
					<ol>
						<li>&quot;Analyze&quot; the contents of your world. During this phase, Plutonium will import a fresh, temporary, copy of each document in your world, and compare your current documents with the fresh versions. A &quot;diff&quot; view will then be displayed, highlighting any differences between the two.</li>
						<li>Select documents from the list to be updated. You can expand each document to control which fields (or sub-documents) will receive updates. Note that some fields are <b>not updated by default</b>; you can customize this behaviour by using the &quot;Configure&quot; dialogue.</li>
						<li>&quot;Update Selected&quot;. Note that the tool will remain open, displaying any remaining diffs, should you wish to make further changes.</li>
					</ol>
				</div>`;

				doAutoResize();
			});
	}

	$getBtnConfigureDefaultSelection () {
		return $(`<button class="btn btn-default" type="button"><i class="fa fa-cogs"></i> Configure</button>`)
			.click(async () => {
				await ContentUpdaterConfigurationManager.pShow({});
			});
	}

	$getBtnAnalyze () {
		const $btn = $(`<button class="btn btn-default" type="button"><i class="fa fa-crosshairs"></i> Analyze</button>`)
			.click(async () => {
				try {
					$btn.prop("disabled", true);
					await this._lock_triggerOperation.pLock();
					this._state.docMetas = await this._pGetUpdatableDocMetas();
					if (!this._state.docMetas.length) ui.notifications.warn(`No updates required!`);
				} finally {
					this._lock_triggerOperation.unlock();
					$btn.prop("disabled", false);
				}
			});

		return $btn;
	}

	$getBtnUpdate () {
		const $btn = $(`<button class="btn btn-default" type="button"><i class="fa fa-play"></i> Update Selected</button>`)
			.click(async () => {
				try {
					$btn.prop("disabled", true);
					await this._lock_triggerOperation.pLock();
					const diffUpdaters = this._listManager.getUpdaters();
					if (!diffUpdaters.length) return ui.notifications.warn(`Please select some documents to update first!`);
					await this._pDoUpdates(diffUpdaters);
				} finally {
					this._lock_triggerOperation.unlock();
					$btn.prop("disabled", false);
					this._listManager.updateList();
				}
			});

		return $btn;
	}

	
	async _pGetUpdatableDocMetas () {
		const progressBarManager = new ContentUpdaterProgressBarManager();

		try {
			return (await this._pGetUpdatableDocMetas_({progressBarManager}));
		} catch (e) {
			progressBarManager.stop(`Analysis failed!`);
			throw e;
		}
	}

	async _pGetUpdatableDocMetas_ ({progressBarManager}) {
		progressBarManager.start(`Analyzing...`);

		const out = [];

		const importerCache = new _ImporterCache();
		const packs = game.packs
			.filter(pack => !pack.locked);
		const config = await ContentUpdaterConfigurationManager.pGetConfig();
		const defaultSkipSelections = await DefaultSelectionManager.pGetDefaultSkipSelections();
		const docTypeMetaList = Object.values(ContentUpdaterConsts.DOC_TYPE_METAS)
			.filter(docTypeMeta => !docTypeMeta.isEmbedOnly);

		progressBarManager.setChunkCount(docTypeMetaList.length * 2); 
		for (const docTypeMeta of docTypeMetaList) {
						const packsDocType = packs
				.filter(pack => pack.metadata.type === docTypeMeta.Cls.metadata.name);

			const folderIdTemp = await UtilFolders.pCreateTempFolderGetId({folderType: docTypeMeta.Cls.name});

			const docMetaBuilders = [
				new UpdatableDocMetaBuilderDirectory({
					config,
					defaultSkipSelections,
					importerCache,
					docTypeMeta,
					folderIdTemp,
				}),
								new UpdatableDocMetaBuilderDirectorySub({
					config,
					defaultSkipSelections,
					importerCache,
					docTypeMeta,
					folderIdTemp,
				}),
				...packsDocType.map(pack => {
					return new UpdatableDocMetaBuilderPack({
						config,
						defaultSkipSelections,
						importerCache,
						docTypeMeta,
						pack,
					});
				}),
				new UpdatableDocMetaBuilderScene({
					config,
					defaultSkipSelections,
					importerCache,
					docTypeMeta,
					scene: game.scenes.active,
				}),
			];

			const docsPerBuilder = [];
			
						progressBarManager.setChunkSubCount(
				docMetaBuilders
					.map(docMetaBuilder => docMetaBuilder.getApproxGetDocsCount())
					.reduce((a, b) => a + b, 0),
			);

			for (let i = 0; i < docMetaBuilders.length; ++i) {
				docsPerBuilder[i] = await docMetaBuilders[i].pGetImportableDocs(progressBarManager);
			}

			progressBarManager.incrementChunk(`${docTypeMeta.Cls.metadata.name}-0`);
			
						progressBarManager.setChunkSubCount(
				docsPerBuilder.reduce((cnt, docs) => cnt + docs.length, 0),
			);

			for (let i = 0; i < docMetaBuilders.length; ++i) {
				const docMetaBuilder = docMetaBuilders[i];
				const docs = docsPerBuilder[i];
				out.push(...(await docMetaBuilder.pGetUpdatableContentMetas(progressBarManager, docs)));
			}

			await game.folders.get(folderIdTemp)?.delete({deleteSubfolders: true, deleteContents: true});

			progressBarManager.incrementChunk(`${docTypeMeta.Cls.metadata.name}-1`);
					}

		progressBarManager.stop(`Analyzed!`);

		return out;
	}

	async _pDoUpdates (diffUpdaters) {
		await (
			new AppTaskRunnerBasic({
				verbPresent: "updating",
				verbPast: "updated",
				verbInfinitive: "update",
				fnGetLogName: ({dataItem: diffUpdater}) => diffUpdater.name,
				pFnRun: this._pDoUpdate.bind(this),
				data: diffUpdaters,
			})
		).pRun();
	}

	async _pDoUpdate ({dataItem: diffUpdater}) {
		await diffUpdater.pDoUpdate();
	}
}

class ContentUpdaterSourceSelector extends AppSourceSelectorMulti {
		static prePreInit () {
		this._prePreInit_registerKeybinds();
	}

	static _prePreInit_registerKeybinds () {
		game.keybindings.register(
			SharedConsts.MODULE_ID,
			"ContentUpdaterSourceSelector__open",
			{
				name: `Open ${ContentUpdaterConsts.APP_TITLE}`,
				editable: [],
				onDown: () => {
					this._pOpen().then(null);
					return true;
				},
				restricted: true,
			},
		);
	}

	static async pHandleButtonClick () {
		return this._pOpen();
	}

	static async _pOpen () {
		const sources = await this._pGetSources();
		const appSourceSelector = new ContentUpdaterSourceSelector({
			title: `Content Updater: Select Sources`,
			filterNamespace: `ContentUpdaterSourceSelector_filter`,
			savedSelectionKey: `ContentUpdaterSourceSelector_savedSelection`,
			sourcesToDisplay: sources,
		});

		const loadedData = await appSourceSelector.pWaitForUserInput();
		if (loadedData == null) return;

		const mergedData = UtilDataSource.getMergedData([loadedData], {isFilterBlocklisted: false});

		const app = new ContentUpdaterApp({
			data: mergedData,
		});
		app.render(true);
	}
	
	static async _pGetSources () {
		return [
			new UtilDataSource.DataSourceSpecial(
				Config.get("ui", "isStreamerMode") ? "SRD" : "5etools",
				() => BlocklistUtil.pLoadData(),
				{
					cacheKey: "5etools-content-updater",
					filterTypes: [UtilDataSource.SOURCE_TYP_OFFICIAL_ALL],
					isDefault: true,
					pPostLoad: UtilDataSource.pPostLoadGeneric.bind(this, {isVetools: true}),
				},
			),
			...UtilDataSource.getSourcesCustomUrl({pPostLoad: UtilDataSource.pPostLoadGeneric.bind(this, {isVetools: false})}),
			...UtilDataSource.getSourcesUploadFile({pPostLoad: UtilDataSource.pPostLoadGeneric.bind(this, {isVetools: false})}),
			...(await UtilDataSource.pGetSourcesPrerelease("*", {pPostLoad: UtilDataSource.pPostLoadGeneric.bind(this, {isVetools: false})})),
			...(await UtilDataSource.pGetSourcesBrew("*", {pPostLoad: UtilDataSource.pPostLoadGeneric.bind(this, {isVetools: false})})),
		].filter(dataSource => !UtilWorldDataSourceSelector.isFiltered(dataSource));
	}
}

const APP_TITLE = ContentUpdaterConsts.APP_TITLE;

console.log(...LGT, `Initialising`);

let isFail = false;

function handleError (err) {
	isFail = true;
	console.error(...LGT, err);
	window.alert(`Failed to initialise ${SharedConsts.MODULE_TITLE}! ${VeCt.STR_SEE_CONSOLE} (${err.message})`);
}


function handleInit () {
		if (!UtilCompat.isLibWrapperActive()) throw new Error(`Plutonium depends on libWrapper! Please ensure libWrapper is installed and up-to-date.`);

	UtilGameSettings.prePreInit();

	Vetools.doMonkeyPatchPreConfig();
	Config.prePreInit();
	UtilBackend.pPrePreInit().then(null); 	Vetools.doMonkeyPatchPostConfig(); 
	ArtBrowserApp.prePreInit();
	Patcher.prePreInit();
	ChooseImporter.prePreInit();
	Charactermancer_StartingEquipment.prePreInit();
	LootGeneratorApp.prePreInit();
	ActorPolymorpher.prePreInit();
	ContentUpdaterSourceSelector.prePreInit();
}

Hooks.on("init", () => {
	if (isFail) return;
	console.log(...LGT, `Firing "init" hook...`);
	try {
		handleInit();
	} catch (e) {
		handleError(e);
	}
});


function handleSetup () {
	ImportList.preInit();
}

Hooks.on("setup", () => {
	if (isFail) return;
	console.log(...LGT, `Firing "setup" hook...`);
	try {
		handleSetup();
	} catch (e) {
		handleError(e);
	}
});


async function handleReady () {
	await Config.pInit();

	UtilActors.init();

	await Vetools.pDoPreload();

	Patcher.init();
	UtilSocket.init();
	await UtilUi.pInit();
	UtilRenderer.init();
	GameStorage.init();
	DataConverterClass.init();
	DataConverterClassSubclassFeature.init();
	DataConverterOptionalfeature.init();
	DataConverterFeat.init();
	DataConverterReward.init();
	DataConverterCharCreationOption.init();
	DataConverterVehicleUpgrade.init();
	ImportList.init();
	ImportListBackground.init();
	ImportListClass.init();
	ImportListFeat.init();
	ImportListItem.init();
	ImportListClassFeature.init();
	ImportListOptionalFeature.init();
	ImportListPsionic.init();
	ImportListRace.init();
	ImportListReward.init();
	ImportListCharCreationOption.init();
	ImportListVehicleUpgrade.init();
	Charactermancer_StartingEquipment.init();
	PopoutSheet.init();
	ShowSheet.init();
	MenuTitleSceneConfig.init();
	MenuTitleActor.init();
	MenuTitleItem.init();
	MenuTitleJournalSheet.init();
	MenuTitleRollTableConfig.init();
	MenuTitleCompendium.init();
	MenuTitleArtBrowserApp.init();
	MenuTitleCombatTracker.init();
	MenuTitleSceneDirectory.init();
	MenuTitleActorDirectory.init();
	MenuTitleItemDirectory.init();
	MenuTitleJournalDirectory.init();
	MenuTitleRollTableDirectory.init();
	MenuTitleCardsDirectory.init();
	MenuTitlePlaylistDirectory.init();
	MenuTitleCompendiumDirectory.init();
	MenuTitleMacroDirectory.init();
	MenuTitleSettings.init();
	ArtBrowserApp.init();
	LootGeneratorApp.init();
	ActorPolymorpher.init();
	ActorMultiattack.init();
	TokenHpRoller.init();
	UtilEvents.init();
	UtilChat.init();
	RivetBridge.init();
	Styler.init();
	UtilActiveEffects.init();
	UtilCompendium.init();
	UtilCompat.init();
	await UtilHandlebars.pInit();
	await UtilWorldDataSourceSelector.pInit();
	await UtilWorldContentBlocklist.pInit();
	await ChatNotificationHandlers.pInit();

	Api.init();

		game.scenes.render();
	game.actors.render();
	game.items.render();
	game.journal.render();
	game.tables.render();
	game.cards.render();

				ui.chat.render();

	console.log(...LGT, `Initialisation complete!`);
}

Hooks.on("ready", () => {
	if (isFail) return;
	console.log(...LGT, `Firing "ready" hook...`);
	handleReady().catch(e => {
		handleError(e);
	});
});

class Changelog extends Application {
	constructor () {
		super({
			width: 600,
			height: 800,
			title: "Changelog",
			template: `${SharedConsts.MODULE_LOCATION}/template/Changelog.hbs`,
			resizable: true,
		});
	}

	activateListeners ($html) {
		super.activateListeners($html);
		Vetools.pGetChangelog()
			.then(changelog => {
				const $wrp = $html.empty();
				UtilsChangelog.renderChangelog(changelog, $wrp);
			});
	}

	static open () {
		const changelog = new Changelog();
		changelog.render(true);
	}
}

var Changelog$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Changelog: Changelog
});

class AppBugReport extends Application {
	constructor () {
		super({
			title: "Report a Bug",
			template: `${SharedConsts.MODULE_LOCATION}/template/_Generic.hbs`,
			width: 800,
			height: 600,
			resizable: true,
		});
	}

	activateListeners ($html) {
		const $btnCopy = $(`<button name="btn-copy" class="btn btn-5et btn-xs">Copy to Clipboard</button>`)
			.click(async () => {
				await MiscUtil.pCopyTextToClipboard($iptReport.val());
				JqueryUtil.showCopiedEffect($btnCopy);
			});

		const $iptReport = $(`<textarea name="ipt-report mb-3" class="w-100 h-100"></textarea>`);

		UtilBackend.pGetBackendVersion().then(ver => {
			$iptReport
				.val(`**Support Request**

**Issue Description**: PLEASE FILL, e.g. "When I import a goblin, my game crashes"
**Environment/OS**: PLEASE FILL, e.g. "Self hosted on Windows"/"The Forge"/etc.
**Browser Extensions**: FILL IF RELEVANT, e.g. "Beyond20"

**Reproduction Steps**: PLEASE FILL, e.g. "1) Create a new actor compendium; 2) Import a goblin to that compendium"

**Console Log**: PLEASE FILL [${VeCt.STR_SEE_CONSOLE}]

---

**Browser**: ${navigator.userAgent}
**Backend installed**: ${ver}
**Foundry & DND system Version**: Foundry ${game.version}, ${game.system.id} ${game.system.version}
**Modules Installed**:
${game.modules.contents.filter(it => it.active).map(it => `${it.id}==${it?.version}`).sort(SortUtil.ascSortLower).join("\n")}
`);
		});

		$$`<p>Please copy and fill out the following form, and post the result in our <a href="https://discord.gg/nGvRCDs" target="_blank" rel="noopener noreferrer">Discord</a> (<span class="code">#issues-general</span> channel):</p>
					<div class="ve-flex-h-right mb-2">${$btnCopy}</div>
					${$iptReport}`.appendTo($html);
	}
}

var AppBugReport$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    AppBugReport: AppBugReport
});

class BaseCollectionTool extends Application {
	static _sortNamePathRows (a, b) {
		if (a.path == null && b.path == null) return SortUtil.ascSortLower(a.name, b.name);
		if (a.path != null && b.path == null) return -1;
		if (a.path == null && b.path != null) return 1;
		return SortUtil.ascSortLower(a.path, b.path) || SortUtil.ascSortLower(a.name, b.name);
	}

	static _listSortNamePathRows (a, b, o) { 		const nxtA = {name: a.name, path: a.values.path};
		const nxtB = {name: b.name, path: b.values.path};
		return BaseCollectionTool._sortNamePathRows(nxtA, nxtB);
	}

	constructor (applicationOpts, documentClass) {
		super(applicationOpts);

		this._list = null;
		this._listSelectClickHandler = null;

		this._documentClass = documentClass;
	}

	_mapEntitiesToRows ({isIgnorePrivileged = false} = {}) {
		const out = game[this._documentClass.metadata.collection].contents
			.map((it, ix) => {
				const path = UtilApplications.getFolderPath(it, {isAddTrailingSlash: true});
				return {
					path,
					name: it.name,
					displayName: `${path || ""}${it.name}`,
					id: it.id,
					type: it?.type || "unknown",
					hasPlutoniumFlags: it.flags?.[SharedConsts.MODULE_ID],
					ix,
				};
			})
			.sort(BaseCollectionTool._sortNamePathRows);

		if (!isIgnorePrivileged) return out;

		if (this._documentClass !== Item && !UtilCompat.isDfredsConvenientEffectsActive()) return out;

		const privilegedId = UtilCompat.DfredsConvenientEffects.getCustomEffectsItemId();
		return out
			.filter(it => it.id !== privilegedId);
	}

	_handleFilterChange () {
		const f = this._pageFilter.filterBox.getValues();
		this._list.filter(li => this._pageFilter.toDisplay(f, this._rows[li.ix]));
	}

	_activateListeners_initBtnReset ($html) {
		this._$btnReset = $html.find(`[name="btn-reset"]`).click(() => {
			$html.find(`.search`).val("");
			if (this._list) this._list.reset();
		});
	}

		_activateListeners_listAbsorbGetData (li) { return UtilList2.absorbFnGetData(li); }
	_activateListeners_doBindSelectAll ($cbAll) { this._listSelectClickHandler.bindSelectAllCheckbox($cbAll); }

	_activateListeners_pInitListAndFilters ($html) {
		this._$iptSearch = $html.find(`.search`);

				this._list = new List({
			$iptSearch: this._$iptSearch,
			$wrpList: $html.find(`.veapp__list`),
			fnSort: BaseCollectionTool._listSortNamePathRows,
		});
		this._listSelectClickHandler = new ListSelectClickHandler({list: this._list});
		SortUtil.initBtnSortHandlers($html.find(`[data-name="wrp-btns-sort"]`), this._list);
		this._activateListeners_doBindSelectAll($html.find(`[name="cb-select-all"]`));

		return this._pageFilter.pInitFilterBox({
			$iptSearch: this._$iptSearch,
			$btnReset: this._$btnReset,
			$btnOpen: $html.find(`[name=btn-filter]`),
			$btnToggleSummaryHidden: $html.find(`[name=btn-toggle-summary]`),
			$wrpMiniPills: $html.find(`.fltr__mini-view`),
			namespace: `tool-${this._documentClass.metadata.collection}`,
		}).then(() => {
			this._rows.forEach(it => this._pageFilter.addToFilters(it));

			this._list.doAbsorbItems(
				this._rows,
				{
					fnGetName: it => it.name,
					fnGetValues: it => ({
						id: it.id,
						path: it.path,
					}),
					fnGetData: this._activateListeners_listAbsorbGetData.bind(this),
					fnBindListeners: it => UtilList2.absorbFnBindListeners(this._listSelectClickHandler, it),
				},
			);

			this._list.init();

			this._pageFilter.trimState();
			this._pageFilter.filterBox.render();

			this._pageFilter.filterBox.on(
				FilterBox.EVNT_VALCHANGE,
				this._handleFilterChange.bind(this),
			);

			this._handleFilterChange();
		});
	}

	_getSelectedIds () {
		return this._list.items
			.filter(it => $(it.ele).find(`input`).prop("checked"))
			.map(it => ({name: it.name, id: it.values.id}));
	}

	_activateListeners_initBtnPrune ($html) {
		$html.find(`[name="btn-prune"]`).click(async () => {
			const doDelete = await UtilApplications.pGetConfirmation({
				title: `Delete Folders`,
				content: `<h3 class="b-0">Are you sure?</h3><p>Any empty folders will be permanently deleted.</p>`,
				confirmText: "Delete",
				faIcon: "fa-trash",
			});
			if (!doDelete) return;

			await this._pDoPruneFolders();
		});
	}

	async _pDoDelete ($cbPruneAuto) {
		if (!this._list) return;

		let selIds = this._getSelectedIds();

		if (!selIds.length) return ui.notifications.warn(`Please select something to delete!`);

		const collectionTitle = game.i18n.localize(this._documentClass.metadata.label);
		const pluralStr = selIds.length !== 1 ? "s" : "";
		const doDelete = await UtilApplications.pGetConfirmation({
			title: `Delete ${collectionTitle}${pluralStr}`,
			content: `<h3 class="b-0">Are you sure?</h3><p>${selIds.length} ${collectionTitle}${pluralStr} and ${pluralStr ? "their" : "its"} data will be permanently deleted.</p>`,
			confirmText: "Delete",
			faIcon: "fa-trash",
		});
		if (!doDelete) return;

		this.close();

						let cntPruned = 0;
		if ($cbPruneAuto.prop("checked")) {
			const delIds = await this._pDoPruneFolders(selIds.map(({id}) => id));
			cntPruned = delIds.size;
			selIds = selIds.filter(({id}) => !delIds.has(id));
		}

		const nameSingle = game.i18n.localize(this._documentClass.metadata.label).toLowerCase();
		const namePlural = game.i18n.localize(this._documentClass.metadata.labelPlural).toLowerCase();

		await this._documentClass.deleteDocuments(selIds.map(({id}) => id));
		ui.notifications.info(`Deleted ${selIds.length} ${selIds.length === 1 ? nameSingle : namePlural}.`);

		if ($cbPruneAuto.prop("checked")) await this._pDoPruneFolders();

		ui.sidebar.activateTab(this._documentClass.metadata.collection);
		game[this._documentClass.metadata.collection].render();
	}

		async _pDoPruneFolders (toDeleteEntityIds) {
		const getFolders = () => CONFIG.Folder.collection.instance.contents.filter(it => it.type === this._documentClass.metadata.name);

		const setSelectedIds = toDeleteEntityIds ? new Set(toDeleteEntityIds) : null;
		const setDeleted = new Set();

		let cntPruned = 0;
		let cntFoldersPrev = null;
		let cntFolders = getFolders().length;
		do {
			let dirsToDelete;
			if (setSelectedIds) {
				dirsToDelete = getFolders().filter(it => {
					if (!it.children || !it.children.length) {
						if (!it.contents.length) return true;

												const selContentIds = it.contents.map(c => c.id).filter(id => setSelectedIds.has(id));
						if (selContentIds.length === it.contents.length) {
							selContentIds.forEach(id => setDeleted.add(id));
							return true;
						}
					}
					return false;
				});
			} else {
				dirsToDelete = getFolders().filter(it => !it.contents.length && (!it.children || !it.children.length));
			}

			for (const dir of dirsToDelete) {
				await dir.delete({deleteSubfolders: true, deleteContents: true});
				cntPruned++;
			}

			cntFoldersPrev = cntFolders;
			cntFolders = getFolders().length;
		} while (cntFolders !== cntFoldersPrev);

		if (cntPruned) ui.notifications.info(`Deleted ${cntPruned} folder${cntPruned === 1 ? "" : "s"}.`);

		return setDeleted;
	}
}

class CollectionCleaner extends BaseCollectionTool {
	constructor (documentClass) {
		super(
			{
				title: "Directory Cleaner",
				template: `${SharedConsts.MODULE_LOCATION}/template/CollectionCleaner.hbs`,
				height: Util.getMaxWindowHeight(),
				width: 640,
				resizable: true,
			},
			documentClass,
		);

				this._pageFilter = new AppFilterBasic();

		this._list = null;
		this._$btnReset = null;
	}

	activateListeners ($html) {
		super.activateListeners($html);

		this._activateListeners_initBtnRun($html);
		this._activateListeners_initBtnPrune($html);
		this._activateListeners_initBtnReset($html);
		this._activateListeners_pInitListAndFilters($html);
	}

	_activateListeners_initBtnRun ($html) {
		const $cbPruneAuto = $html.find(`[name="cb-prune-auto"]`);
		$html.find(`[name="btn-run"]`).click(() => this._pDoDelete($cbPruneAuto));
	}

		getData () {
		this._rows = this._rows = this._mapEntitiesToRows({isIgnorePrivileged: true});

		return {
			...super.getData(),
			titleSearch: game.i18n.localize(this._documentClass.metadata.labelPlural).toLowerCase(),
			rows: this._rows,
		};
	}

	close (...args) {
		this._pageFilter.teardown();
		return super.close(...args);
	}
}

class CollectionFolderizer extends BaseCollectionTool {
	constructor (documentClass) {
		super(
			{
				title: "Bulk Directory Mover",
				template: `${SharedConsts.MODULE_LOCATION}/template/CollectionFolderizer.hbs`,
				height: Util.getMaxWindowHeight(),
				width: 640,
				resizable: true,
			},
			documentClass,
		);

				this._pageFilter = new AppFilterBasic();

		this._list = null;
		this._$btnReset = null;
	}

	activateListeners ($html) {
		super.activateListeners($html);

		this._activateListeners_initBtnRun($html);
		this._activateListeners_initBtnReset($html);
		this._activateListeners_pInitListAndFilters($html);
	}

	_activateListeners_initBtnRun ($html) {
		$html.find(`[name="btn-run"]`).click(async () => {
			if (!this._list) return;

			const targetFolder = $html.find(`[name="sel-folder"]`).val();
			if (!targetFolder) return ui.notifications.warn("No target folder selected!");

			const selIds = this._getSelectedIds();

			if (!selIds.length) return ui.notifications.warn(`Please select something to folderize!`);

			this.close();

			await (
				new AppTaskRunnerBasic({
					verbPresent: "moving",
					verbPast: "moved",
					verbInfinitive: "move",
					fnGetLogName: ({dataItem: {name}}) => name,
					pFnRun: this._pMoveItem.bind(this),
					data: selIds.map(({id, name}) => ({id, name, targetFolder})),
				})
			).pRun();

			ui.sidebar.activateTab(this._documentClass.metadata.collection);
			game[this._documentClass.metadata.collection].render();
		});
	}

	async _pMoveItem ({dataItem: {id, targetFolder}}) {
		await game[this._documentClass.metadata.collection].get(id).update({folder: targetFolder});
	}

		getData () {
		this._rows = this._mapEntitiesToRows({isIgnorePrivileged: true});

		return {
			...super.getData(),
			titleSearch: game.i18n.localize(this._documentClass.metadata.labelPlural).toLowerCase(),
			folders: UtilApplications.getFolderList(this._documentClass.metadata.name)
				.map(it => ({id: it.id, name: `${it.depth > 1 ? ` ${"-".repeat(it.depth - 1)} ` : ""}${it.name}`})),
			rows: this._rows,
		};
	}

	close (...args) {
		this._pageFilter.teardown();
		return super.close(...args);
	}
}

class CollectionOwnershipUpdaterFilter extends AppFilterBasic {
	static _FOLDER_NONE = "(None)";

	constructor () {
		super();

		this._folderFilter = new Filter({header: "Folder"});
	}

	addToFilters (entity, isExcluded) {
		super.addToFilters(entity, isExcluded);

		if (isExcluded) return;

		this._folderFilter.addItem(entity.path || this.constructor._FOLDER_NONE);
	}

	async _pPopulateBoxOptions (opts) {
		opts.filters = [
			this._typeFilter,
			this._folderFilter,
			this._miscFilter,
		];
	}

	toDisplay (values, ent) {
		return this._filterBox.toDisplay(
			values,
			ent.type,
			ent.path || this.constructor._FOLDER_NONE,
			this._getMiscFilterValues(ent),
		);
	}
}

class CollectionOwnershipUpdater extends BaseCollectionTool {
	constructor (documentClass) {
		super(
			{
				title: "Bulk Ownership Editor",
				template: `${SharedConsts.MODULE_LOCATION}/template/CollectionOwnershipUpdater.hbs`,
				width: 960,
				height: Util.getMaxWindowHeight(),
				resizable: true,
			},
			documentClass,
		);

				this._pageFilter = new CollectionOwnershipUpdaterFilter();

		this._list = null;
		this._listSelectClickHandler = new ListSelectClickHandler({list: this._list});
		this._$cbAll = null;
		this._$rowHeaders = null;
		this._$cbEach = null;
		this._$btnRun = null;
		this._$iptSearch = null;
		this._$btnReset = null;

				this._players = null;
		this._entities = null;
			}

	static _SEL_DESELECTED_VALUE = "-2";
	static _STORAGE_KEY_PLAYERS_VISIBLE = `${this.name}__playersVisible`;

	activateListeners ($html) {
		super.activateListeners($html);

				const eleScroller = $html[0].children[2];
		const elesToScroll = $(eleScroller).find(".permu__cell-ent-name").map((i, e) => e).get();
		eleScroller.addEventListener("scroll", () => {
			const scrollPos = eleScroller.scrollLeft;
			elesToScroll.forEach(it => it.style.left = `${scrollPos}px`);
		});

		this._$rowHeaders = $(eleScroller.children[0].children[1]);

		this._activateListeners_controlsGod($html);
		this._activateListeners_controlsPlayers($html, eleScroller);
		this._activateListeners_rows($html);

		this._activateListeners_list($html);

		this._$btnRun = $html.find(`[name="btn-save"]`).click(async () => this._pHandleBtnClick_run());
	}

	_activateListeners_controlsGod ($html) {
				const $selAll = this._$rowHeaders.find(`select[name="permu__sel-all-players-all-entities"]`)
			.change(() => {
				const toVal = $selAll.val();

				this._list.visibleItems.forEach(li => {
					if (!li.data.cbAllPlayers.checked) return;
					li.data.selAllPlayers.value = toVal;
					li.data.selAllPlayers.setAttribute("data-permu-value", toVal);
				});

				$selAll.val(this.constructor._SEL_DESELECTED_VALUE);
			});

		this._$cbAll = this._$rowHeaders.find(`input[name="permu__cb-all-players-all-entities"]`)
			.change(() => {
				const toVal = this._$cbAll.prop("checked");

				this._setMassAllPlayerCheckboxValues(toVal);

				this._list.visibleItems.forEach(li => {
					li.data.cbAllPlayers.checked = toVal;
				});
			});
		
				const $selEach = this._$rowHeaders.find(`select[name="permu__sel-each-player-all-entities"]`)
			.change(() => {
				const toVal = $selEach.val();
				const len = this._list.items[0] ? this._list.items[0].data.cbsPlayers.length : 0;

				for (let i = 0; i < len; ++i) {
					this._list.visibleItems.forEach(li => {
						if (!li.data.cbsPlayers[i].checked) return;
						if (this._players[i]?.isHidden) return;
						li.data.selsPlayers[i].value = toVal;
						li.data.selsPlayers[i].setAttribute("data-permu-value", toVal);
					});
				}

				$selEach.val(this.constructor._SEL_DESELECTED_VALUE);
			});

		this._$cbEach = this._$rowHeaders.find(`input[name="permu__cb-each-player-all-entities"]`)
			.change(() => {
				const toVal = this._$cbEach.prop("checked");

				this._setMassCheckboxValues(toVal);

				this._list.visibleItems.forEach(li => {
					li.data.cbEachPlayer.checked = toVal;
					li.data.cbsPlayers
						.forEach((cb, i) => {
							if (this._players[i]?.isHidden) return;
							cb.checked = toVal;
						});
				});
			});
			}

	_activateListeners_controlsPlayers ($html, eleScroller) {
				$(eleScroller.children[0]).find(`[name="btn-filter-players"]`)
			.click(async () => {
				const {$modalInner, doClose, doAutoResize: doAutoResizeModal} = await UtilApplications.pGetShowApplicationModal({
					title: `Filter Players`,
				});

				const comp = BaseComponent.fromObject(
					this._players
						.mergeMap(({id, isHidden}) => ({[id]: !isHidden})),
					"*",
				);

				const $cbAll = $(`<input type="checkbox">`)
					.change(() => {
						const toVal = $cbAll.prop("checked");
						comp._proxyAssignSimple("state", Object.keys(comp._state).mergeMap(k => ({[k]: toVal})));
					});
				const hkAll = () => {
					$cbAll.prop("checked", Object.values(comp._state).every(Boolean));
				};
				comp._addHookAllBase(hkAll);
				hkAll();

				const rowMetas = this._players
					.map(ply => {
						const $cb = ComponentUiUtil.$getCbBool(comp, ply.id);

						const $row = $$`<label class="split-v-center py-1p">
							<span class="mr-2">${ply.name}</span>
							${$cb}
						</label>`;

						return {$row};
					});

				const $btnFilter = $(`<button class="btn btn-default w-100">Save</button>`)
					.click(async () => {
						this._players
							.forEach(ply => {
								ply.isHidden = !comp._state[ply.id];
							});

						StorageUtil.pSet(this.constructor._STORAGE_KEY_PLAYERS_VISIBLE, MiscUtil.copyFast(comp.__state));

						const cellsHeaderPlayerControls = this._$rowHeaders[0].querySelectorAll(`[data-permu-type="wrp-header-player"]`);
						cellsHeaderPlayerControls.forEach((cell, i) => {
							const player = this._players[i];
							cell.classList.toggle("ve-hidden", !!player?.isHidden);
						});

						this._list.items
							.forEach(li => {
								const cellFirst = li.ele.querySelector(`[data-permu-type="lbl-entity-player"]`);
								const ixCell = Array.from(cellFirst.parentNode.children).indexOf(cellFirst);
								const cells = [...cellFirst.parentNode.children].slice(ixCell);

								cells.forEach((cell, i) => {
									const player = this._players[i];
									cell.classList.toggle("ve-hidden", !!player?.isHidden);
								});
							});

						return doClose(true);
					});

				$$($modalInner)`
				<div class="ve-flex-h-right">${$cbAll}</div>
				<hr class="hr-1">
				<div class="ve-flex-col overflow-y-auto min-h-0">
					${rowMetas.map(it => it.$row)}
				</div>
				<hr class="hr-1">
				<div class="ve-flex-v-center no-shrink pb-1 pt-1 px-1">${$btnFilter}</div>`;

				doAutoResizeModal();
			});
		
				this._$rowHeaders.on(`change`, `select[data-permu-type="sel-player-all-entities"]`, (evt) => {
			const $sel = $(evt.target);

			const toVal = $sel.val();

			const playerId = $sel.attr("data-permu-player-id");
			const ixPlayers = this._players.findIndex(it => it.id === playerId);

			this._list.visibleItems.forEach(li => {
				if (!li.data.cbsPlayers[ixPlayers].checked) return;
				li.data.selsPlayers[ixPlayers].value = toVal;
				li.data.selsPlayers[ixPlayers].setAttribute("data-permu-value", toVal);
			});

			$sel.val(this.constructor._SEL_DESELECTED_VALUE);
		});

		this._$rowHeaders.on(`click`, `label[data-permu-type="lbl-player-all-entities"]`, (evt) => {
			if (evt.target.tagName === "SELECT") return;

			const $row = $(evt.target).closest(`.permu__cell-player`);
			const $cb = $row.find(`input`);

			const toVal = $cb.prop("checked");

			const playerId = $cb.attr("data-permu-player-id");
			const ixPlayers = this._players.findIndex(it => it.id === playerId);

			this._list.visibleItems.forEach(li => {
				li.data.cbsPlayers[ixPlayers].checked = toVal;
			});
		});
		
				$html.on(`change`, `select[data-permu-type="sel-entity-all-players"]`, (evt) => {
			const $sel = $(evt.target);
			$sel.attr("data-permu-value", $sel.val());
		});

		$html.on(`click`, `label[data-permu-type="lbl-entity-all-players"]`, (evt) => {
			if (evt.target.tagName === "SELECT") return;

			const $row = $(evt.target).closest(`.permu__row-ent`);

			const entityId = $row.attr("data-permu-entity-id");

			const li = this._list.items.find(it => it.values.id === entityId);

			this._listSelectClickHandler.handleSelectClick(
				li,
				evt,
				{
					fnGetCb: li => li.data.cbAllPlayers,
					isNoHighlightSelection: true,
					fnOnSelectionChange: (item, toVal) => {
						item.data.cbAllPlayers.checked = toVal;
					},
				},
			);
		});
			}

	_activateListeners_rows ($html) {
				$html.on(`change`, `select[data-permu-type="sel-entity-each-player"]`, (evt) => {
			const $sel = $(evt.target);

			const toVal = $sel.val();

			const $row = $sel.closest(`.permu__row-ent`);
			const entityId = $row.attr("data-permu-entity-id");

			const li = this._list.items.find(it => it.values.id === entityId);

			const len = li.data.cbsPlayers.length;
			for (let i = 0; i < len; ++i) {
				if (!li.data.cbsPlayers[i].checked) continue;
				li.data.selsPlayers[i].value = toVal;
				li.data.selsPlayers[i].setAttribute("data-permu-value", toVal);
			}

			$sel.val(this.constructor._SEL_DESELECTED_VALUE);
		});

		$html.on(`click`, `label[data-permu-type="lbl-entity-each-player"]`, (evt) => {
			if (evt.target.tagName === "SELECT") return;

			const $row = $(evt.target).closest(`.permu__row-ent`);

			const entityId = $row.attr("data-permu-entity-id");

			const li = this._list.items.find(it => it.values.id === entityId);

			this._listSelectClickHandler.handleSelectClick(
				li,
				evt,
				{
					fnGetCb: li => li.data.cbEachPlayer,
					isNoHighlightSelection: true,
					fnOnSelectionChange: (item, toVal) => {
						item.data.cbsPlayers
							.forEach((cb, i) => {
								if (this._players[i]?.isHidden) return;
								cb.checked = toVal;
							});
					},
				},
			);
		});
		
				$html.on(`change`, `select[data-permu-type="sel-entity"]`, (evt) => {
			const $sel = $(evt.target);
			$sel.attr("data-permu-value", $sel.val());
		});
		
				$html.on(`click`, `label[data-permu-type="lbl-entity-player"]`, (evt) => {
			if (evt.target.tagName === "SELECT") return;

			const $row = $(evt.target).closest(`.permu__row-ent`);
			const $cb = $(evt.target).closest(`.permu__cell-player`).find(`input[data-permu-player-id]`);

			const entityId = $row.attr("data-permu-entity-id");
			const playerId = $cb.attr("data-permu-player-id");

			const ixPlayer = this._players.findIndex(it => it.id === playerId);

			const li = this._list.items.find(it => it.values.id === entityId);

			this._listSelectClickHandler.handleSelectClick(
				li,
				evt,
				{
					fnGetCb: li => li.data.cbsPlayers[ixPlayer],
					isNoHighlightSelection: true,
					fnOnSelectionChange: (item, toVal) => {
						item.data.cbsPlayers[ixPlayer].checked = toVal;
					},
				},
			);
		});
			}

	_activateListeners_list ($html) {
		this._$iptSearch = $html.find(`.search`);
		this._$btnReset = $html.find(`[name="btn-reset"]`).click(() => this._pHandleBtnClick_reset());

				this._list = new List({
			$iptSearch: $html.find(`.search`),
			$wrpList: $html.find(`.veapp__list`),
			fnSort: CollectionOwnershipUpdater._sortEntities,
		});

		this._pageFilter.pInitFilterBox({
			$iptSearch: this._$iptSearch,
			$btnReset: this._$btnReset,
			$btnOpen: $html.find(`[name=btn-filter]`),
			$btnToggleSummaryHidden: $html.find(`[name=btn-toggle-summary]`),
			$wrpMiniPills: $html.find(`.fltr__mini-view`),
			namespace: `tool-permissions_${this._documentClass.metadata.collection}`,
		}).then(() => {
			this._entities.forEach(it => this._pageFilter.addToFilters(it));

			this._list.doAbsorbItems(
				this._entities,
				{
					fnGetName: it => it.name,
					fnGetValues: it => ({
						id: it.id,
						path: it.path,
					}),
					fnGetData: CollectionOwnershipUpdater._absorbFnGetData,
				},
			);
			this._list.init();

			this._pageFilter.trimState();
			this._pageFilter.filterBox.render();

			this._pageFilter.filterBox.on(
				FilterBox.EVNT_VALCHANGE,
				this._handleFilterChange.bind(this),
			);

			this._handleFilterChange();
		});
	}

	async _pHandleBtnClick_run () {
		if (!this._list) return;

		const toSaves = [];

		this._entities.forEach(ent => {
			const row = this._list.items.find(it => it.values.id === ent.id);

			let allPlayerUpdate = null;
			const metasPlayerUpdates = [];

			const originalAllValue = `${ent.allPlayerOwnership}`;
			if (row.data.selAllPlayers.value !== originalAllValue) allPlayerUpdate = row.data.selAllPlayers.value;

			row.data.selsPlayers.forEach((eleSel, i) => {
				const playerId = this._players[i].id;
				const originalVal = `${ent.playerOwnership[playerId]}`;

				if (eleSel.value !== originalVal) metasPlayerUpdates.push({value: eleSel.value, playerId});
			});

			if (allPlayerUpdate != null || metasPlayerUpdates.length) toSaves.push({entityMeta: ent, metasPlayerUpdates, allPlayerUpdate});
		});

		if (!toSaves) return ui.notifications.warn(`Please make some changes first!`);

		this._$btnRun.attr("disabled", true).text("Saving...");

		await (
			new AppTaskRunnerBasic({
				verbPresent: "updating",
				verbPast: "updated",
				verbInfinitive: "update",
				fnGetLogName: ({dataItem}) => `${dataItem.entityMeta.path}${dataItem.entityMeta.name}`,
				pFnRun: this._pUpdateItemOwnership.bind(this),
				data: toSaves,
			})
		).pRun();

		this._$btnRun.attr("disabled", false).text("Saved!");
		setTimeout(() => this._$btnRun.text("Save"), VeCt.DUR_INLINE_NOTIFY);
	}

	async _pUpdateItemOwnership ({dataItem: toSave}) {
		const entity = game[this._documentClass.metadata.collection].get(toSave.entityMeta.id);

		const nxtOwnership = {...entity.system.ownership};

		if (toSave.allPlayerUpdate != null) {
			nxtOwnership.default = Number(toSave.allPlayerUpdate);
		}

		(toSave.metasPlayerUpdates || []).forEach(meta => {
			const {playerId, value} = meta;
									if (!~value) return delete nxtOwnership[playerId];
			nxtOwnership[playerId] = Number(value);
		});

		if (!CollectionUtil.deepEquals(entity.system.ownership, nxtOwnership)) {
									await entity.update({ownership: nxtOwnership}, {diff: false, recursive: false, noHook: true});
		}

				if (toSave.allPlayerUpdate != null) {
			toSave.entityMeta.allPlayerOwnership = `${toSave.allPlayerUpdate}`;
		}

		(toSave.metasPlayerUpdates || []).forEach(meta => {
			const {playerId, value} = meta;
			toSave.entityMeta.playerOwnership[playerId] = `${value}`;
		});
	}

	async _pHandleBtnClick_reset () {
		this._$iptSearch.val("");

		this._$cbAll.prop("checked", false);
		this._setMassAllPlayerCheckboxValues(false);

		this._$cbEach.prop("checked", false);
		this._setMassCheckboxValues(false);

		this._entities.forEach(ent => {
			const row = this._list.items.find(it => it.values.id === ent.id);

			row.data.cbEachPlayer.checked = false;
			row.data.cbsPlayers.forEach(cb => cb.checked = false);

			row.data.selsPlayers.forEach((sel, i) => {
				const playerId = this._players[i].id;
				const toVal = `${ent.playerOwnership[playerId]}`;
				sel.value = toVal;
				sel.setAttribute("data-permu-value", toVal);
			});
		});
	}

	_setMassAllPlayerCheckboxValues (toVal) {
				this._list.visibleItems.forEach(li => li.data.cbAllPlayers.checked = toVal);
	}

	_setMassCheckboxValues (toVal) {
				this._$rowHeaders[0].querySelectorAll(`input[data-permu-player-id]`).forEach((cb, i) => {
			const player = this._players[i];
			if (player?.isHidden) return;
			cb.checked = toVal;
		});
	}

	_handleFilterChange () {
		const f = this._pageFilter.filterBox.getValues();
		this._list.filter(li => this._pageFilter.toDisplay(f, this._entities[li.ix]));
	}

	static _absorbFnGetData (li) {
		const eleCellControlsAllPlayers = li.ele.children[2];
		const eleCellControlsEachPlayer = li.ele.children[3];
		const eleCellsControlPlayer = [...li.ele.children].slice(4);

		return ({
			cbAllPlayers: eleCellControlsAllPlayers.children[0],
			selAllPlayers: eleCellControlsAllPlayers.children[1],

			cbEachPlayer: eleCellControlsEachPlayer.children[0],
			selEachPlayer: eleCellControlsEachPlayer.children[1],

			cbsPlayers: eleCellsControlPlayer.map(ele => ele.children[0]),
			selsPlayers: eleCellsControlPlayer.map(ele => ele.children[1]),
		});
	}

	static _sortEntities (a, b) {
		const aPath = a.values ? a.values.path : a.path;
		const bPath = b.values ? b.values.path : b.path;
		if (aPath && !bPath) return -1;
		if (!aPath && bPath) return 1;
		return SortUtil.ascSortLower(aPath, bPath) || SortUtil.ascSortLower(a.name, b.name);
	}

		async getData (...args) {
		const savedPlayerVisibility = await StorageUtil.pGet(this.constructor._STORAGE_KEY_PLAYERS_VISIBLE);

				this._players = game.users.contents.map(it => ({
			id: it.id,
			name: it.name,
			isHidden: savedPlayerVisibility?.[it.id] === false,
		}));

		this._entities = game[this._documentClass.metadata.collection].contents.map((it, ix) => {
			const path = UtilApplications.getFolderPath(it, {isAddTrailingSlash: true});
			const permObject = (it.system || {}).ownership || {};

			const ownershipLevelAll = permObject.default != null ? permObject.default : 0;

			return {
				id: it.id,
				name: it.name,
				allPlayerOwnership: ownershipLevelAll,
				playerOwnership: this._players.map(player => player.id).mergeMap(id => {
					const ownershipLevel = permObject[id] != null ? permObject[id] : -1;
					return {[id]: ownershipLevel};
				}),
				type: it?.type || "unknown",
				folderId: it.folder ? it.folder.id : null,
				path: path || "",
				hasPlutoniumFlags: it.flags?.[SharedConsts.MODULE_ID],
				ix,
			};
		});

		this._entities.sort(CollectionOwnershipUpdater._sortEntities);

		return {
			...(await super.getData(...args)),
			titleSearch: game.i18n.localize(this._documentClass.metadata.labelPlural).toLowerCase(),
			players: this._players,
			entities: this._entities,
			ownershipAll: Util.Fvtt.getOwnershipEnum(),
			ownership: Util.Fvtt.getOwnershipEnum({isIncludeDefault: true}),
		};
	}

	close (...args) {
		this._pageFilter.teardown();
		return super.close(...args);
	}
}

class CollectionTokenUpdater extends BaseCollectionTool {
	constructor (documentClass) {
		super(
			{
				title: "Bulk Prototype Token Editor",
				template: `${SharedConsts.MODULE_LOCATION}/template/CollectionTokenUpdater.hbs`,
				width: 960,
				height: Util.getMaxWindowHeight(),
				resizable: true,
			},
			documentClass,
		);

				this._pageFilter = new AppFilterBasic();

		this._list = null;
		this._$btnReset = null;
	}

	activateListeners ($html) {
		super.activateListeners($html);

		this._activateListeners_initBtnRun($html);
		this._activateListeners_initBtnEditTemplate($html);
		this._activateListeners_initBtnReset($html);
		this._activateListeners_pInitListAndFilters($html);
	}

	_activateListeners_initBtnRun ($html) {
		$html.find(`[name="btn-run"]`)
			.click(async () => {
				if (!this._list) return;

				const selIds = this._getSelectedIds();

				if (!selIds.length) return ui.notifications.warn(`Please select something to update!`);

				const template = await CollectionTokenUpdater.Template.pGetState();
				if (template.IS_DEFAULT) {
					const isAcceptDefaults = await InputUiUtil.pGetUserBoolean({
						title: "Updated Not Configured",
						htmlDescription: "You have not yet configured the updater. Are you sure you wish to proceed?",
						textNo: "Cancel",
						textYes: "Continue",
					});
					if (!isAcceptDefaults) return;
				}

				this.close();

				await (
					new AppTaskRunnerBasic({
						verbPresent: "updating",
						verbPast: "updated",
						verbInfinitive: "update",
						fnGetLogName: ({dataItem: {name}}) => name,
						pFnRun: this._pUpdateToken.bind(this),
						data: selIds.map(({id, name}) => ({id, name, template})),
					})
				).pRun();

				ui.sidebar.activateTab(this._documentClass.metadata.collection);
				game[this._documentClass.metadata.collection].render();
			});
	}

	_activateListeners_initBtnEditTemplate ($html) {
		$html.find(`[name="btn-set-template"]`)
			.click(() => {
				const templateApp = new CollectionTokenUpdater.Template();
				templateApp.render(true);
			});
	}

	getData () {
		this._rows = this._rows = this._mapEntitiesToRows();

		return {
			...super.getData(),
			titleSearch: this._documentClass.metadata.collection,
			rows: this._rows,
		};
	}

	async _pUpdateToken ({dataItem: {id: actorId, template}}) {
		const actor = CONFIG.Actor.collection.instance.get(actorId);
		if (!actor) return;

		const update = {};
		const updateActor = {};

		const isUpdates = [
			this._pUpdateToken_populateLinkUpdate(actor, template, update, updateActor),
			this._pUpdateToken_populateNameUpdate(actor, template, update, updateActor),
			this._pUpdateToken_populateDispositionUpdate(actor, template, update, updateActor),
			this._pUpdateToken_populateImageUpdate(actor, template, update, updateActor),
			this._pUpdateToken_populateResourcesUpdate(actor, template, update, updateActor),
			this._pUpdateToken_populateVisionUpdate(actor, template, update, updateActor),
		];

		if (!isUpdates.some(Boolean)) return;

		await UtilDocuments.pUpdateDocument(actor, {...updateActor, prototypeToken: update});
	}

	_pUpdateToken_populateLinkUpdate (actor, template, update) {
		if (!template.isLinkActive) return false;

		update.actorLink = template.isLinkActorData;

		return true;
	}

	_pUpdateToken_populateNameUpdate (actor, template, update) {
		if (!template.isNameActive) return false;

		let anyChanges = false;

		const getFirstName = () => actor.name.split(" ")[0].trim().replace(/,;$/, "").trim();
		const getLastName = () => actor.name.split(" ").last().trim();

		const getQuotedNamePart = () => {
			const re = template.isNameParseDoubleQuotes && template.isNameParseSingleQuotes
				? `["']([^"']*?)["']`
				: template.isNameParseDoubleQuotes
					? `"([^"]*?)"`
					: template.isNameParseSingleQuotes
						? `'([^']*?)'`
						: "^$";

			const m = new RegExp(re).exec(actor.name);
			if (!m) return null;
			return m[1].trim();
		};

		if (template.nameMode != null) {
			anyChanges = true;

			switch (template.nameMode) {
				case "Full Name": update.name = actor.name; break;
				case "First Name": update.name = getFirstName(); break;
				case "Last Name": update.name = getLastName(); break;
				case "Quoted Part or Full Name": {
					const quotedPart = getQuotedNamePart();
					update.name = quotedPart || actor.name;
					break;
				}
				case "Quoted Part or First Name": {
					const quotedPart = getQuotedNamePart();
					update.name = quotedPart || getFirstName();
					break;
				}
				case "Quoted Part or Last Name": {
					const quotedPart = getQuotedNamePart();
					update.name = quotedPart || getLastName();
					break;
				}
				case "Regex": {
					const m = new RegExp(template.nameRegexFormula, template.isNameRegexIgnoreCase ? "i" : "").exec(actor.name);
					if (m) update.name = m[1];
					break;
				}
			}
		}

		if (template.namePermissions != null) {
			anyChanges = true;

			update.displayName = Number(template.namePermissions);
		}

		return anyChanges;
	}

	_pUpdateToken_populateDispositionUpdate (actor, template, update) {
		if (!template.isDispositionActive) return false;

		if (template.disposition != null) {
			update.disposition = template.disposition;
			return true;
		}

		return false;
	}

	_pUpdateToken_populateImageUpdate (actor, template, update, updateActor) {
		if (!template.isImageActive) return false;

		let anyChanges = false;

		if (template.imageSyncMode === 0) {
			update.img = actor.img;
			anyChanges = true;
		} else if (template.imageSyncMode === 1) {
			updateActor.img = actor.prototypeToken.texture.src;
			anyChanges = true;
		}

		if (template.scale != null) {
			update.scale = template.scale;
			anyChanges = true;
		}

		return anyChanges;
	}

	_pUpdateToken_populateResourcesUpdate (actor, template, update) {
		if (!template.isResourcesActive) return false;

		let anyChanges = false;

		if (template.barPermissions != null) {
			anyChanges = true;
			update.displayBars = Number(template.barPermissions);
		}

		if (actor.type === "character") {
			if (template.barAttributeCharacter1 != null) {
				anyChanges = true;
				update.bar1 = {attribute: template.barAttributeCharacter1 === "(None)" ? null : template.barAttributeCharacter1};
			}

			if (template.barAttributeCharacter2 != null) {
				anyChanges = true;
				update.bar2 = {attribute: template.barAttributeCharacter2 === "(None)" ? null : template.barAttributeCharacter2};
			}
		}

		if (actor.type === "npc") {
			if (template.barAttributeNpc1 != null) {
				anyChanges = true;
				update.bar1 = {attribute: template.barAttributeNpc1 === "(None)" ? null : template.barAttributeNpc1};
			}

			if (template.barAttributeNpc2 != null) {
				anyChanges = true;
				update.bar2 = {attribute: template.barAttributeNpc2 === "(None)" ? null : template.barAttributeNpc2};
			}
		}

		return anyChanges;
	}

	_pUpdateToken_populateVisionUpdate (actor, template, update) {
		if (!template.isVisionActive) return false;

		let anyChanges = false;

		if (template.isHasVision != null) {
			if (actor.prototypeToken.vision !== template.isHasVision) {
				update.vision = template.isHasVision;

				anyChanges = true;
			}
		}

		if (template.visionDim != null) {
			if (actor.prototypeToken.dimSight !== template.visionDim) {
				update.dimSight = template.visionDim;

				anyChanges = true;
			}
		}

		if (template.visionBright != null) {
			if (actor.prototypeToken.brightSight !== template.visionBright) {
				update.brightSight = template.visionBright;

				anyChanges = true;
			}
		}

		if (template.visionAngle != null) {
			if (actor.prototypeToken.sightAngle !== template.visionAngle) {
				update.sightAngle = template.visionAngle;

				anyChanges = true;
			}
		}

		if (template.lightDim != null) {
			if (actor.prototypeToken.dimLight !== template.lightDim) {
				update.dimLight = template.lightDim;

				anyChanges = true;
			}
		}

		if (template.lightBright != null) {
			if (actor.prototypeToken.brightLight !== template.lightBright) {
				update.brightLight = template.lightBright;

				anyChanges = true;
			}
		}

		if (template.lightAngle != null) {
			if (actor.prototypeToken.lightAngle !== template.lightAngle) {
				update.lightAngle = template.lightAngle;

				anyChanges = true;
			}
		}

		if (template.lightOpacity != null) {
			if (actor.prototypeToken.lightAlpha !== template.lightOpacity) {
				update.lightAlpha = template.lightOpacity;

				anyChanges = true;
			}
		}

		return anyChanges;
	}

	close (...args) {
		this._pageFilter.teardown();
		return super.close(...args);
	}
}

CollectionTokenUpdater.Template = class extends Application {
	constructor () {
		super({
			title: `Prototype Token Updater Configuration`,
			template: `${SharedConsts.MODULE_LOCATION}/template/CollectionTokenUpdaterTemplate.hbs`,
			width: 600,
			height: Util.getMaxWindowHeight(900),
			resizable: true,
		});
	}

	activateListeners ($html) {
		$html.empty();
		this._activateListeners_pDoLoadAndRender($html);
	}

	static async pGetState () {
		const saved = await StorageUtil.pGet(CollectionTokenUpdater.Template._STORAGE_KEY);
		return saved || CollectionTokenUpdater.Template._DEFAULTS;
	}

	async _activateListeners_pDoLoadAndRender ($html) {
		const prevValues = await StorageUtil.pGet(CollectionTokenUpdater.Template._STORAGE_KEY);

		const _comp = BaseComponent.fromObject(prevValues || CollectionTokenUpdater.Template._DEFAULTS);
		const comp = _comp.getPod();
		const pSaveState = () => {
			const out = _comp.toObject();
			delete out.IS_DEFAULT;
			StorageUtil.pSet(CollectionTokenUpdater.Template._STORAGE_KEY, out);
		};
		const saveStateDebounced = MiscUtil.debounce(pSaveState, 100);
		_comp._addHookAll("state", saveStateDebounced);

				const $cbSectName = ComponentUiUtil.$getCbBool(_comp, "isNameActive");

		const $cbParseNameDoubleQuotes = ComponentUiUtil.$getCbBool(_comp, "isNameParseDoubleQuotes");
		const $cbParseNameSingleQuotes = ComponentUiUtil.$getCbBool(_comp, "isNameParseSingleQuotes");

		const $stageNameQuotes = $$`<div class="ve-flex-v-center toku__row">
			<label class="ve-flex-v-center mr-2 ml-auto"><div class="mr-1">Accept Double Quotes</div>${$cbParseNameDoubleQuotes}</label>
			<label class="ve-flex-v-center"><div class="mr-1">Accept Single Quotes</div>${$cbParseNameSingleQuotes}</label>
		</div>`;

		const $iptRegex = ComponentUiUtil.$getIptStr(_comp, "nameRegexFormula", {html: `<input class="code" type="text">`});
		const $cbIgnoreCase = ComponentUiUtil.$getCbBool(_comp, "isNameRegexIgnoreCase");

		const $stageNameRegex = $$`<div class="ve-flex-col w=100">
			<label class="ve-flex-v-center ve-flex-h-right toku__row">
				<div class="mr-2 help" title="The first capture group will be used, if the expression matches">Expression</div>${$iptRegex}
			</label>

			<label class="ve-flex-v-center ve-flex-h-right toku__row">
				<div class="mr-1">Ignore Case</div>${$cbIgnoreCase}
			</label>
		</div>`;

		const NAME_UPDATE_MODES = [
			new CollectionTokenUpdater.Template.NameUpdateMode("Full Name", $stageNameQuotes, $stageNameRegex),
			new CollectionTokenUpdater.Template.NameUpdateMode("First Name", $stageNameQuotes, $stageNameRegex),
			new CollectionTokenUpdater.Template.NameUpdateMode("Last Name", $stageNameQuotes, $stageNameRegex),
			new CollectionTokenUpdater.Template.NameUpdateMode("Quoted Part or Full Name", $stageNameQuotes, $stageNameRegex),
			new CollectionTokenUpdater.Template.NameUpdateMode("Quoted Part or First Name", $stageNameQuotes, $stageNameRegex),
			new CollectionTokenUpdater.Template.NameUpdateMode("Quoted Part or Last Name", $stageNameQuotes, $stageNameRegex),
			new CollectionTokenUpdater.Template.NameUpdateMode("Regex", $stageNameQuotes, $stageNameRegex),
		];
		const $selNameMode = ComponentUiUtil.$getSelEnum(_comp, "nameMode", {values: NAME_UPDATE_MODES.map(it => it.name), isAllowNull: true, displayNullAs: "(No update)"});
		const hkNameMode = () => {
			const found = NAME_UPDATE_MODES.find(it => comp.get("nameMode") === it.name);
			if (found) found.activate();
			else {
				$stageNameQuotes.hideVe();
				$stageNameRegex.hideVe();
			}
		};
		_comp._addHookBase("nameMode", hkNameMode);
		hkNameMode();

		const INVERTED_TOKEN_DISPLAY_MODES = {};
		Object.entries(CONST.TOKEN_DISPLAY_MODES)
			.sort(([, valueA], [, valueB]) => SortUtil.ascSort(valueA, valueB))
			.forEach(([name, value]) => INVERTED_TOKEN_DISPLAY_MODES[value] = game.i18n.localize(`TOKEN.DISPLAY_${name}`));
		const $selNamePermissions = ComponentUiUtil.$getSelEnum(_comp, "namePermissions", {values: Object.keys(INVERTED_TOKEN_DISPLAY_MODES), fnDisplay: it => INVERTED_TOKEN_DISPLAY_MODES[it], isAllowNull: true, displayNullAs: "(No update)"});
		
				const $cbSectLink = ComponentUiUtil.$getCbBool(_comp, "isLinkActive");

		const $cbLinkActorData = ComponentUiUtil.$getCbBool(_comp, "isLinkActorData");
		
				const $cbSectDisposition = ComponentUiUtil.$getCbBool(_comp, "isDispositionActive");

		const $selDisposition = ComponentUiUtil.$getSelEnum(_comp, "disposition", {values: Object.values(CONST.TOKEN_DISPOSITIONS), fnDisplay: it => game.i18n.localize(`TOKEN.DISPOSITION.${Parser._parse_bToA(CONST.TOKEN_DISPOSITIONS, it)}`), isAllowNull: true, displayNullAs: "(No update)"});
		
				const $cbSectImage = ComponentUiUtil.$getCbBool(_comp, "isImageActive");

		const USE_IMAGE_MODE = ["Use Sheet Image", "Set Sheet to Use Token Image (Update Actor from Token)"];
		const $selImageSyncMode = ComponentUiUtil.$getSelEnum(_comp, "imageSyncMode", {values: [0, 1], isAllowNull: true, fnDisplay: it => USE_IMAGE_MODE[it], displayNullAs: "(No update)"});

		const $sliderScale = ComponentUiUtil.$getSliderNumber(_comp, "scale", {min: 0.2, max: 3, step: 0.1});

		const $iptScale = ComponentUiUtil.$getIptNumber(
			_comp,
			"scale",
			null,
			{
				$ele: $(`<input class="range-value ml-2 form-control form-control--minimal">`),
				isAllowNull: true,
				fallbackOnNaN: null,
				min: 0.2,
				max: 3,
			},
		);

		const hkScale = () => $iptScale.title(_comp._state.scale == null ? `(No update)` : `Set scale to ${_comp._state.scale}`);
		_comp._addHookBase("scale", hkScale);
		hkScale();

		const $btnResetScale = $(`<button class="btn btn-5et btn-xs ml-2" title="Reset to &quot;Do not update&quot;"><span class="glyphicon glyphicon-refresh"></span></button>`).click(() => _comp._state.scale = null);
		
				const $cbSectResources = ComponentUiUtil.$getCbBool(_comp, "isResourcesActive");

		const $selBarPermissions = ComponentUiUtil.$getSelEnum(_comp, "barPermissions", {values: Object.keys(INVERTED_TOKEN_DISPLAY_MODES), fnDisplay: it => INVERTED_TOKEN_DISPLAY_MODES[it], isAllowNull: true, displayNullAs: "(No update)"});

		const CHAR_TOKEN_ATTRIBUTES_OBJ = CollectionTokenUpdater.Template._getAllAvailableActorBarAttributes("character");
		const CHAR_TOKEN_ATTRIBUTES = ["(None)", ...Object.values(CHAR_TOKEN_ATTRIBUTES_OBJ).flat()];

		const NPC_TOKEN_ATTRIBUTES_OBJ = CollectionTokenUpdater.Template._getAllAvailableActorBarAttributes("npc");
		const NPC_TOKEN_ATTRIBUTES = ["(None)", ...Object.values(NPC_TOKEN_ATTRIBUTES_OBJ).flat()];

		const $selBarAttributeCharacter1 = ComponentUiUtil.$getSelEnum(_comp, "barAttributeCharacter1", {values: CHAR_TOKEN_ATTRIBUTES, isAllowNull: true, displayNullAs: "(No update)"});
		const $selBarAttributeCharacter2 = ComponentUiUtil.$getSelEnum(_comp, "barAttributeCharacter2", {values: CHAR_TOKEN_ATTRIBUTES, isAllowNull: true, displayNullAs: "(No update)"});

		const $selBarAttributeNpc1 = ComponentUiUtil.$getSelEnum(_comp, "barAttributeNpc1", {values: NPC_TOKEN_ATTRIBUTES, isAllowNull: true, displayNullAs: "(No update)"});
		const $selBarAttributeNpc2 = ComponentUiUtil.$getSelEnum(_comp, "barAttributeNpc2", {values: NPC_TOKEN_ATTRIBUTES, isAllowNull: true, displayNullAs: "(No update)"});
		
				const $cbSectVision = ComponentUiUtil.$getCbBool(_comp, "isVisionActive");

		const $cbHasVision = ComponentUiUtil.$getCbBool(_comp, "isHasVision");
		const $iptDimVision = ComponentUiUtil.$getIptInt(_comp, "visionDim", null, {min: 0, isAllowNull: true, html: `<input class="code text-right" type="text" placeholder="(No update)">`});
		const $iptBrightVision = ComponentUiUtil.$getIptInt(_comp, "visionBright", null, {min: 0, isAllowNull: true, html: `<input class="code text-right" type="text" placeholder="(No update)">`});
		const $iptVisionAngle = ComponentUiUtil.$getIptInt(_comp, "visionAngle", null, {min: 0, max: 360, isAllowNull: true, html: `<input class="code text-right" type="text" placeholder="(No update)">`});
		const $iptDimLight = ComponentUiUtil.$getIptInt(_comp, "lightDim", null, {min: 0, isAllowNull: true, html: `<input class="code text-right" type="text" placeholder="(No update)">`});
		const $iptBrightLight = ComponentUiUtil.$getIptInt(_comp, "lightBright", null, {min: 0, isAllowNull: true, html: `<input class="code text-right" type="text" placeholder="(No update)">`});
		const $iptLightAngle = ComponentUiUtil.$getIptInt(_comp, "lightAngle", null, {min: 0, max: 360, isAllowNull: true, html: `<input class="code text-right" type="text" placeholder="(No update)">`});
		const $iptLightOpacity = ComponentUiUtil.$getIptNumber(_comp, "lightOpacity", null, {min: 0, max: 1, isAllowNull: true, html: `<input class="code text-right" type="text" placeholder="(No update)">`});
		
				const $btnSave = $(`<button class="btn-5et w-100">Save</button>`)
			.click(async () => {
				try {
					await pSaveState();
					ui.notifications.info(`Saved!`);
				} catch (e) {
					ui.notifications.error(`Failed to save! ${VeCt.STR_SEE_CONSOLE}`);
					throw e;
				}
				this.close();
			});
		
		$html.addClass(`toku__form`);
		$$($html)`
		<div class="ve-flex-col h-100 min-h-0 w-100 overflow-y-auto overflow-x-hidden pr-1">
			<label class="split-v-center mb-1" title="Update Token Name">
				<div class="toku__sect-head">Name</div>
				${$cbSectName.addClass("toku__cb-head")}
			</label>
			<div class="ve-flex-col w-100">
				<label class="my-1 split-v-center toku__row"><div>Update Mode</div>${$selNameMode}</label>
				${$stageNameQuotes}
				${$stageNameRegex}
				<label class="my-1 split-v-center toku__row"><div>Display Name</div>${$selNamePermissions}</label>
			</div>

			<hr class="hr-1">

			<label class="split-v-center mb-1" title="Update Token Link">
				<div class="toku__sect-head">Link</div>
				${$cbSectLink.addClass("toku__cb-head")}
			</label>
			<div class="ve-flex-col w-100">
				<label class="my-1 split-v-center toku__row"><div>Link Actor Data</div>${$cbLinkActorData}</label>
			</div>

			<hr class="hr-1">

			<label class="split-v-center mb-1" title="Update Token Disposition">
				<div class="toku__sect-head">Disposition</div>
				${$cbSectDisposition.addClass("toku__cb-head")}
			</label>
			<div class="ve-flex-col w-100">
				<label class="my-1 split-v-center toku__row"><div>Token Disposition</div>${$selDisposition}</label>
			</div>

			<hr class="hr-1">

			<label class="split-v-center mb-1" title="Update Token Image">
				<div class="toku__sect-head">Image</div>
				${$cbSectImage.addClass("toku__cb-head")}
			</label>
			<div class="ve-flex-col w-100">
				<label class="my-1 split-v-center toku__row"><div>Image</div>${$selImageSyncMode}</label>
				<label class="my-1 split-v-center toku__row">
					<div>Scale</div>
					<div class="ve-flex-v-center max-w-200p w-100">${$sliderScale}${$iptScale}${$btnResetScale}</div>
				</label>
			</div>

			<hr class="hr-1">

			<label class="split-v-center mb-1" title="Update Token Resources">
				<div class="toku__sect-head">Resources</div>
				${$cbSectResources.addClass("toku__cb-head")}
			</label>
			<div class="ve-flex-col w-100">
				<label class="my-1 split-v-center toku__row"><div>Display Bars</div>${$selBarPermissions}</label>
				<label class="my-1 split-v-center toku__row"><div>Bar 1 Attribute (Characters)</div>${$selBarAttributeCharacter1}</label>
				<label class="my-1 split-v-center toku__row"><div>Bar 2 Attribute (Characters)</div>${$selBarAttributeCharacter2}</label>
				<label class="my-1 split-v-center toku__row"><div>Bar 1 Attribute (NPCs)</div>${$selBarAttributeNpc1}</label>
				<label class="my-1 split-v-center toku__row"><div>Bar 2 Attribute (NPCs)</div>${$selBarAttributeNpc2}</label>
			</div>

			<hr class="hr-1">

			<label class="split-v-center mb-1" title="Update Token Vision">
				<div class="toku__sect-head">Vision</div>
				${$cbSectVision.addClass("toku__cb-head")}
			</label>
			<div class="ve-flex-col w-100">
				<label class="my-1 split-v-center toku__row"><div>Has Vision</div>${$cbHasVision}</label>
				<label class="my-1 split-v-center toku__row"><div>Dim Vision <span class="ve-muted ve-small">(Distance)</span></div>${$iptDimVision}</label>
				<label class="my-1 split-v-center toku__row"><div>Bright Vision <span class="ve-muted ve-small">(Distance)</span></div>${$iptBrightVision}</label>
				<label class="my-1 split-v-center toku__row"><div>Sight Angle <span class="ve-muted ve-small">(Degrees)</span></div>${$iptVisionAngle}</label>
				<label class="my-1 split-v-center toku__row"><div>Emit Dim <span class="ve-muted ve-small">(Distance)</span></div>${$iptDimLight}</label>
				<label class="my-1 split-v-center toku__row"><div>Emit Bright <span class="ve-muted ve-small">(Distance)</span></div>${$iptBrightLight}</label>
				<label class="my-1 split-v-center toku__row"><div>Emission Angle <span class="ve-muted ve-small">(Degrees)</span></div>${$iptLightAngle}</label>
				<label class="my-1 split-v-center toku__row"><div>Light Opacity <span class="ve-muted ve-small">(0-1)</span></div>${$iptLightOpacity}</label>
			</div>
		</div>

		<div class="mt-auto">
			${$btnSave}
		</div>
		`;
	}

		static _getAllAvailableActorBarAttributes (actorType) {
		const actors = CONFIG.Actor.collection.instance.contents.filter(it => it.type === actorType);
				actors.push({system: game.system.model.Actor[actorType]});

		const out = {};
		const seenSets = {};
		const keys = [
			game.i18n.localize("TOKEN.BarAttributes"),
			game.i18n.localize("TOKEN.BarValues"),
		];

		actors.forEach(actor => {
			const barAttributes = UtilActors.getActorBarAttributes(actor);

			keys.forEach(k => {
				(barAttributes[k] || []).forEach(atr => {
					const seenSet = (seenSets[k] = seenSets[k] || new Set());
					if (seenSet.has(atr)) return;
					seenSet.add(atr);
					(out[k] = out[k] || []).push(atr);
				});
			});
		});

		keys.forEach(k => {
			(out[k] || []).sort((a, b) => a.localeCompare(b));
		});

		return out;
	}
};
CollectionTokenUpdater.Template._STORAGE_KEY = `collection_token_updater`;
CollectionTokenUpdater.Template._DEFAULTS = {
	IS_DEFAULT: true, 
	isCharacterActive: false,
	isNameActive: true,
	isDispositionActive: true,
	isImageActive: true,
	isResourcesActive: true,
	isVisionActive: true,
	isNameParseDoubleQuotes: true,
	isNameParseSingleQuotes: true,
};

CollectionTokenUpdater.Template.NameUpdateMode = class {
	constructor (name, $stageNameQuotes, $stageNameRegex) {
		this.name = name;
		this._$stageNameQuotes = $stageNameQuotes;
		this._$stageNameRegex = $stageNameRegex;
	}

	activate () {
		switch (this.name) {
			case "Full Name":
			case "First Name":
			case "Last Name":
				this._$stageNameQuotes.hideVe(); this._$stageNameRegex.hideVe(); break;
			case "Quoted Part or Full Name":
			case "Quoted Part or First Name":
			case "Quoted Part or Last Name":
				this._$stageNameQuotes.showVe(); this._$stageNameRegex.hideVe(); break;
			case "Regex":
				this._$stageNameQuotes.hideVe(); this._$stageNameRegex.showVe(); break;
		}
	}
};

class CollectionDeduplicator extends BaseCollectionTool {
	constructor (documentClass) {
		super(
			{
				title: "Directory Deduplicator",
				template: `${SharedConsts.MODULE_LOCATION}/template/CollectionDeduplicator.hbs`,
				height: Util.getMaxWindowHeight(),
				width: 640,
				resizable: true,
			},
			documentClass,
		);

				this._pageFilter = new AppFilterBasic();

		this._list = null;
		this._$btnReset = null;
	}

	activateListeners ($html) {
		super.activateListeners($html);

		this._activateListeners_initBtnRun($html);
		this._activateListeners_initBtnPrune($html);
		this._activateListeners_initBtnReset($html);
		this._activateListeners_pInitListAndFilters($html);
	}

	_activateListeners_initBtnRun ($html) {
		const $cbPruneAuto = $html.find(`[name="cb-prune-auto"]`);
		$html.find(`[name="btn-run"]`).click(() => this._pDoDelete($cbPruneAuto));
	}

	_activateListeners_listAbsorbGetData (li, di) {
		return {
			...UtilList2.absorbFnGetData(li),
			isPrime: !!di.isPrime,
		};
	}

	_activateListeners_doBindSelectAll ($cbAll) {
		$cbAll.change(() => {
			const isAllChecked = $cbAll.prop("checked");
			this._list.visibleItems.forEach(it => {
				const isChecked = isAllChecked ? !it.data.isPrime : false;
				it.data.cbSel.checked = isChecked;

				if (isChecked) it.ele.classList.add("list-multi-selected");
				else it.ele.classList.remove("list-multi-selected");
			});
		});
	}

		getData () {
		const rows = this._mapEntitiesToRows();

		const isIgnoreType = Config.get("tools", "isDeduplicateIgnoreType");
		const getUid = row => {
			const name = (row.name || "").trim().toLowerCase();
			return isIgnoreType ? name : `${name}__${row.type}`;
		};

		const uidToRows = {};
		rows.forEach(row => {
			const uid = getUid(row);
			(uidToRows[uid] = uidToRows[uid] || []).push(row);
		});

		this._rows = Object.values(uidToRows)
			.filter(it => it.length > 1)
			.map(dupeArr => {
								dupeArr.forEach((it, i) => it.isPrime = i === 0);
				return dupeArr;
			})
			.flat();

		return {
			...super.getData(),
			titleSearch: game.i18n.localize(this._documentClass.metadata.labelPlural).toLowerCase(),
			rows: this._rows,
		};
	}

	close (...args) {
		this._pageFilter.teardown();
		return super.close(...args);
	}
}

class BaseCompendiumListTool extends Application {
	static _listSortLabel (a, b) { return SortUtil.ascSortLower(a.name, b.name); }

	constructor (...args) {
		super(...args);

		this._list = null;
		this._listSelectClickHandler = null;
	}

	_mapEntitiesToRows () {
		return game.packs.contents
			.map((it, ix) => {
				return {
					name: it.metadata.label,
					id: it.metadata.id,
					documentName: it.metadata.type,
					packageName: it.metadata.packageName,
					packageType: it.metadata.packageType,
					system: it.metadata.system || "(none)",
					ix,
				};
			})
			.sort(BaseCompendiumListTool._listSortLabel);
	}

	_handleFilterChange () {
		const f = this._pageFilter.filterBox.getValues();
		this._list.filter(li => this._pageFilter.toDisplay(f, this._rows[li.ix]));
	}

	_activateListeners_initBtnReset ($html) {
		this._$btnReset = $html.find(`[name="btn-reset"]`).click(() => {
			$html.find(`.search`).val("");
			if (this._list) this._list.reset();
		});
	}

		_activateListeners_listAbsorbGetData (li) { return UtilList2.absorbFnGetData(li); }
	_activateListeners_doBindSelectAll ($cbAll) { this._listSelectClickHandler.bindSelectAllCheckbox($cbAll); }

	_activateListeners_pInitListAndFilters ($html) {
		this._$iptSearch = $html.find(`.search`);

				this._list = new List({
			$iptSearch: this._$iptSearch,
			$wrpList: $html.find(`.veapp__list`),
			fnSort: BaseCompendiumListTool._listSortLabel,
		});
		this._listSelectClickHandler = new ListSelectClickHandler({list: this._list});
		SortUtil.initBtnSortHandlers($html.find(`[data-name="wrp-btns-sort"]`), this._list);
		this._activateListeners_doBindSelectAll($html.find(`[name="cb-select-all"]`));

		return this._pageFilter.pInitFilterBox({
			$iptSearch: this._$iptSearch,
			$btnReset: this._$btnReset,
			$btnOpen: $html.find(`[name=btn-filter]`),
			$btnToggleSummaryHidden: $html.find(`[name=btn-toggle-summary]`),
			$wrpMiniPills: $html.find(`.fltr__mini-view`),
			namespace: `tool-compendium`,
		}).then(() => {
			this._rows.forEach(it => this._pageFilter.addToFilters(it));

			this._list.doAbsorbItems(
				this._rows,
				{
					fnGetName: it => it.name,
					fnGetValues: it => ({
						id: it.id,
						path: it.path,
						documentName: it.documentName,
						packageName: it.packageName,
						packageType: it.packageType,
						system: it.system,
					}),
					fnGetData: this._activateListeners_listAbsorbGetData.bind(this),
					fnBindListeners: it => UtilList2.absorbFnBindListeners(this._listSelectClickHandler, it),
				},
			);

			this._list.init();

			this._pageFilter.trimState();
			this._pageFilter.filterBox.render();

			this._pageFilter.filterBox.on(
				FilterBox.EVNT_VALCHANGE,
				this._handleFilterChange.bind(this),
			);

			this._handleFilterChange();
		});
	}

	_getSelectedIds () {
		return this._list.items
			.filter(it => $(it.ele).find(`input`).prop("checked"))
			.map(it => ({name: it.name, id: it.values.id}));
	}
}

class CompendiumListOwnershipUpdater extends BaseCompendiumListTool {
	constructor (collectionName) {
		super(
			{
				title: "Compendium Ownership Updater",
				template: `${SharedConsts.MODULE_LOCATION}/template/CompendiumListOwnershipUpdater.hbs`,
				height: Util.getMaxWindowHeight(),
				width: 640,
				resizable: true,
			},
			collectionName,
		);

				this._pageFilter = new AppFilterCompendiumList();

		this._list = null;
	}

	activateListeners ($html) {
		super.activateListeners($html);

		this._activateListeners_initBtnRun($html);
		this._activateListeners_initBtnReset($html);
		this._activateListeners_pInitListAndFilters($html);
	}

	_activateListeners_initBtnRun ($html) {
		$html.find(`[name="btn-run"]`).click(() => this._pRun($html));
	}

	async _pRun ($html) {
		if (!this._list) return;

		const selIdMetas = this._getSelectedIds();
		if (!selIdMetas.length) return ui.notifications.warn(`Please select some compendiums!`);

		const ownership = Object.entries(CONST.USER_ROLES)
			.filter(([, v]) => v !== CONST.USER_ROLES.NONE)
			.mergeMap(([k, v]) => {
				if (v === CONST.USER_ROLES.GAMEMASTER) return {[k]: "OWNER"};

				const val = $html.find(`[name="sel-ownership-${v}"]`).val();
				if (!val || val === "DEFAULT") return {[`-=${k}`]: null};

				return {[k]: val};
			});

		this.close();

		for (const selIdMeta of selIdMetas) {
			const pack = game.packs.get(selIdMeta.id);
			if (pack) await pack.configure({ownership});
		}
		ui.notifications.info(`Configured ownership on ${selIdMetas.length} ${selIdMetas.length === 1 ? "compendium" : "compendiums"}.`);

		if (this._sidebarTab) ui.sidebar.activateTab("compendium");
	}

	getData () {
		this._rows = this._rows = this._mapEntitiesToRows();
		return {
			...super.getData(),
			rows: this._rows,
			userMetas: Object.entries(CONST.USER_ROLES)
				.filter(([, v]) => ![CONST.USER_ROLES.NONE, CONST.USER_ROLES.GAMEMASTER].includes(v))
				.map(([k, v]) => {
					return {
						name: game.i18n.localize(`USER.Role${k.titleCase()}`),
						formName: `${v}`,
						ownershipMetas: [
							{name: "Default", value: "DEFAULT", isSelected: true},
							...Object.entries(CONST.DOCUMENT_OWNERSHIP_LEVELS)
								.filter(([, v]) => v !== CONST.DOCUMENT_OWNERSHIP_LEVELS.INHERIT)
								.map(([k]) => ({name: game.i18n.localize(`OWNERSHIP.${k}`), value: k})),
						],
					};
				}),
		};
	}

	close (...args) {
		this._pageFilter.teardown();
		return super.close(...args);
	}
}

class WorldDataSourceSelector extends Application {
	static APP_TITLE = "World Data Source Selector";

	constructor () {
		super(
			{
				title: WorldDataSourceSelector.APP_TITLE,
				template: `${SharedConsts.MODULE_LOCATION}/template/WorldDataSourceSelector.hbs`,
				width: 960,
				height: Util.getMaxWindowHeight(),
				resizable: true,
			},
		);

		this._comp = null;
	}

	activateListeners ($html) {
		super.activateListeners($html);

		this._pRender($html).then(null);
	}

	async _pRender ($html) {
		const $stgTop = $html.find(`[data-name="wrp-top"]`);
		const $stgLhs = $html.find(`[data-name="wrp-lhs"]`);
		const $stgRhs = $html.find(`[data-name="wrp-rhs"]`);
		const $stgBot = $html.find(`[data-name="wrp-bot"]`);

		const sourceLists = await this._pRender_pLoadSources();
		const savedState = UtilWorldDataSourceSelector.loadState();

		this._comp = new _WorldDataSourceSelectorComp({sourceLists, savedState});

		await this._comp.pRender({
			$stgTop,
			$stgBot,
			$stgLhs,
			$stgRhs,
		});
	}

	async _pRender_pLoadSources () {
		return (
			await [...ImportList.IMPLS.values()].pMap(async Impl => {
				const sources = (await (new Impl()).pGetSources({isApplyWorldDataSourceFilter: false}))
					.filter(it => it.isWorldSelectable);
				return new _SourceList({
					name: Impl.DISPLAY_NAME_TYPE_PLURAL,
					sources,
					propState: Impl.ID,
				});
			})
		).sort(SortUtil.ascSortLowerProp.bind(SortUtil, "name"));
	}
}

class _SourceList {
	constructor ({name, sources, propState}) {
		this.name = name;
		this.sources = sources;
		this.propState = propState;
	}
}

class _WorldDataSourceSelectorComp extends BaseComponent {
	static _Render = class {
		constructor () {
			this.lists = [];
			this.pageFilter = null;
		}
	};

	constructor ({sourceLists, savedState}) {
		super();

		this.__meta = {
			...sourceLists.mergeMap(({propState}) => ({[this._getProps(propState).propIsSectionVisible]: true})),
		};
		this._meta = this._getProxy("meta", this.__meta);

		this._sourceLists = sourceLists;

		if (savedState != null) this.setStateFrom(savedState);
	}

	_getProps (propState) {
		return {
			propIsSectionVisible: `${propState}_isSectionVisible`,
			propIsSectionCollapsed: `${propState}_isSectionCollapsed`,
		};
	}

	async pRender ({$stgTop, $stgLhs, $stgRhs, $stgBot}) {
		const render = new this.constructor._Render();
		this._pRender_top({render, $stgTop});
		this._pRender_lhs({render, $stgLhs});
		await this._pRender_pRhs({render, $stgRhs});
		this._pRender_bot({render, $stgBot});
	}

	_pRender_top ({render, $stgTop}) {
		const $btnExport = $(`<button class="btn btn-5et btn-xs"><i class="fas fa-file-export fa-fw"></i> Export Selection</button>`)
			.click(() => {
				DataUtil.userDownload(
					`${SharedConsts.MODULE_ID}-world-data-source-selection`,
					this.getSaveableState(),
					{
						propVersion: "moduleVersion",
						fileType: "world-data-source-selection",
						valVersion: game.modules.get(SharedConsts.MODULE_ID).version,
					},
				);
			});

		const $btnImport = $(`<button class="btn btn-5et btn-xs"><i class="fas fa-file-import fa-fw"></i> Import Selection</button>`)
			.click(async () => {
				const {jsons, errors} = await DataUtil.pUserUpload({
					expectedFileTypes: ["world-data-source-selection"],
					propVersion: "moduleVersion",
				});

				DataUtil.doHandleFileLoadErrorsGeneric(errors);

				if (!jsons?.length) return;

				this.setStateFrom(jsons[0]);

				await UtilWorldDataSourceSelector.pSaveState(this.getSaveableState());
			});

		const $btnResetAll = $(`<button class="btn btn-5et btn-xs ml-1" title="Reset All"><i class="fa fa-undo-alt mr-0"></i></button>`)
			.click(async () => {
				const isContinue = await InputUiUtil.pGetUserBoolean({
					title: "Reset All",
					htmlDescription: "Are you sure you want to reset your world data source selection?",
					textNo: "Cancel",
					textYes: "Continue",
				});
				if (!isContinue) return;

				this._proxyAssignSimple("state", this._getDefaultState(), true);
			});

		$$($stgTop.empty())`<div class="ve-flex-h-right w-100">
			<div class="btn-group ve-flex-vh-center">
				${$btnExport}
				${$btnImport}
			</div>
			${$btnResetAll}
		</div>
		<hr class="hr-2">`;
	}

	_pRender_lhs ({render, $stgLhs}) {
		const $cbAll = $(`<input type="checkbox">`)
			.prop("checked", true)
			.change(() => {
				const val = $cbAll.prop("checked");
				this._proxyAssignSimple("meta", this._sourceLists.mergeMap(({propState}) => ({[this._getProps(propState).propIsSectionVisible]: val})));
			});

		const $rows = this._sourceLists.map(({name, propState}) => {
			const {propIsSectionVisible} = this._getProps(propState);

			const $cbToggle = ComponentUiUtil.$getCbBool(this, propIsSectionVisible, {stateName: "meta"});

			return $$`<label class="split-v-center py-1 veapp__ele-hoverable">
				<div>${name}</div>
				${$cbToggle}
			</label>`.click(evt => {
		if (!evt.shiftKey) return;
		evt.stopPropagation();
		evt.preventDefault();

		const nxtState = this._sourceLists.mergeMap(({propState}) => ({[this._getProps(propState).propIsSectionVisible]: false}));
		nxtState[propIsSectionVisible] = true;
		this._proxyAssignSimple("meta", nxtState);
	});
		});

		$$($stgLhs.empty())`<div class="ve-flex-col h-100 w-100 overflow-y-auto">
			<label class="split-v-center py-1 veapp__ele-hoverable">
				<div>All</div>
				${$cbAll}
			</label>

			<hr class="hr-1">

			${$rows}
		</div>`;
	}

	async _pRender_pRhs ({render, $stgRhs}) {
		render.pageFilter = new AppSourceSelectorMulti.AppSourceSelectorAppFilter();

		const {
			$cbAll,
			$wrpFilterControls,
			$wrpMiniPills,
			$wrpBtnsSort,
			$list,
			$btnOpenFilter,
			$iptSearch,
			$btnReset,
			$btnToggleSummaryHidden,
		} = AppSourceSelectorMulti.$getFilterListElements();

		render.listMetas = this._sourceLists
			.map(({name, sources, propState}, ixSourceList) => {
				const {propIsSectionVisible, propIsSectionCollapsed} = this._getProps(propState);

				const $listSub = $$`<div class="flex-col w-100 min-h-0 smooth-scroll"></div>`;

				const $btnToggleExpanded = $(`<div class="clickable mr-2"></div>`)
					.click(() => {
						this._meta[propIsSectionCollapsed] = !this._meta[propIsSectionCollapsed];
					});
				const hkIsExpanded = () => {
					$listSub.toggleVe(!this._meta[propIsSectionCollapsed]);
					$btnToggleExpanded.text(this._meta[propIsSectionCollapsed] ? "[+]" : "[\u2013]");
				};
				this._addHook("meta", propIsSectionCollapsed, hkIsExpanded);
				hkIsExpanded();

				const $stgList = $$`<div class="ve-flex-col">
					<label class="split-v-center">
						<div class="py-1 bold">${name}</div>
						${$btnToggleExpanded}
					</label>
					${$listSub}
					<hr class="hr-0 mt-1">
				</div>`.appendTo($list);

				const list = new List({
					$iptSearch,
					$wrpList: $listSub,
					fnSort: UtilDataSource.sortListItems.bind(UtilDataSource),
				});

				const listSelectClickHandler = new ListSelectClickHandler({list});

				if (!ixSourceList) SortUtil.initBtnSortHandlers($wrpBtnsSort, list);
				else SortUtil.initBtnSortHandlersAdditional($wrpBtnsSort, list);
				listSelectClickHandler.bindSelectAllCheckbox($cbAll, list);

				const hkAll = () => {
					const val = $cbAll.prop("checked");

					list.visibleItems.forEach(li => {
						if (!val) delete this._state[li.data.identifierWorld];
						else this._state[li.data.identifierWorld] = val;
					});
				};
				$cbAll.change(hkAll);

				sources.forEach((src, srcI) => {
					const listItem = AppSourceSelectorMulti.getListItem({
						pageFilter: render.pageFilter,
						list,
						listSelectClickHandler,
						src,
						srcI,
						fnOnClick: () => {
							this._state[src.identifierWorld] = listItem.data.cbSel.checked;
						},
						isSelected: this._state[src.identifierWorld],
					});

					const hk = () => {
						listSelectClickHandler.setCheckbox(listItem, {toVal: !!this._state[src.identifierWorld]});
					};
					this._addHookBase(src.identifierWorld, hk);

					list.addItem(listItem);
				});

				list.on("updated", () => $stgList.toggleVe(list.visibleItems.length));

				return {
					$stgList,
					list,
					sources,
					propIsSectionVisible,
				};
			});

		await render.pageFilter.pInitFilterBox({
			$iptSearch: render.$iptSearch,
			$btnReset,
			$btnOpen: $btnOpenFilter,
			$btnToggleSummaryHidden,
			$wrpMiniPills,
			namespace: `WorldDataSourceSelector.filter`,
		});

		$$($stgRhs)`
			${$wrpFilterControls}
			${$wrpMiniPills}
			${$wrpBtnsSort}
			${$list}
		`;

		render.listMetas.forEach(({list}) => list.init());

		render.pageFilter.trimState();
		render.pageFilter.filterBox.render();

		const handleFilterChange = () => {
			const f = render.pageFilter.filterBox.getValues();
			render.listMetas.forEach(({list, sources, propIsSectionVisible}) => {
				list.filter(li => this._meta[propIsSectionVisible] && render.pageFilter.toDisplay(f, sources[li.ix]));
			});
		};

		render.pageFilter.filterBox.on(
			FilterBox.EVNT_VALCHANGE,
			handleFilterChange,
		);

		render.listMetas.forEach(({propIsSectionVisible}) => {
			this._addHook("meta", propIsSectionVisible, handleFilterChange);
		});

		handleFilterChange();
	}

	_pRender_bot ({render, $stgBot}) {
		const $btnSave = $(`<button class="btn btn-5et btn-default w-100">Save</button>`)
			.click(async () => {
				await UtilWorldDataSourceSelector.pSaveState(this.getSaveableState());
			});

		$$($stgBot.empty())`<div class="ve-flex-v-center">
			${$btnSave}
		</div>`;
	}
}

class WorldContentBlocklistSourceSelector extends AppSourceSelectorMulti {
		static async pHandleButtonClick () {
		return this._pOpen();
	}

	static async _pOpen () {
		const sources = await this._pGetSources();
		const appSourceSelector = new WorldContentBlocklistSourceSelector({
			title: `World Content Blocklist: Select Sources`,
			filterNamespace: `WorldContentBlocklistSourceSelector_filter`,
			savedSelectionKey: `WorldContentBlocklistSourceSelector_savedSelection`,
			sourcesToDisplay: sources,
		});

		const loadedData = await appSourceSelector.pWaitForUserInput();
		if (loadedData == null) return;

		const mergedData = UtilDataSource.getMergedData([loadedData], {isFilterBlocklisted: false});

		const appB = new WorldContentBlocklist({
			data: mergedData,
		});
		appB.render(true);
	}
	
	static async _pGetSources () {
		return [
			new UtilDataSource.DataSourceSpecial(
				Config.get("ui", "isStreamerMode") ? "SRD" : "5etools",
				() => BlocklistUtil.pLoadData(),
				{
					cacheKey: "5etools-blocklist",
					filterTypes: [UtilDataSource.SOURCE_TYP_OFFICIAL_ALL],
					isDefault: true,
					pPostLoad: UtilDataSource.pPostLoadGeneric.bind(this, {}),
				},
			),
			...UtilDataSource.getSourcesCustomUrl({pPostLoad: UtilDataSource.pPostLoadGeneric.bind(this, {isBrew: true})}),
			...UtilDataSource.getSourcesUploadFile({pPostLoad: UtilDataSource.pPostLoadGeneric.bind(this, {isBrew: true})}),
			...(await UtilDataSource.pGetSourcesPrerelease(WorldContentBlocklistSourceSelector._BREW_DIRS, {pPostLoad: UtilDataSource.pPostLoadGeneric.bind(this, {isPrerelease: true})})),
			...(await UtilDataSource.pGetSourcesBrew(WorldContentBlocklistSourceSelector._BREW_DIRS, {pPostLoad: UtilDataSource.pPostLoadGeneric.bind(this, {isBrew: true})})),
		].filter(dataSource => !UtilWorldDataSourceSelector.isFiltered(dataSource));
	}
}
WorldContentBlocklistSourceSelector._BREW_DIRS = [
	"action",
	"adventure",
	"background",
	"book",
	"boon",
	"charoption",
	"class",
	"condition",
	"creature",
	"cult",
	"deity",
	"disease",
	"feat",
	"hazard",
	"item",
	"magicvariant",
	"object",
	"optionalfeature",
	"psionic",
	"race",
	"recipe",
	"reward",
	"spell",
	"subclass",
	"subrace",
	"trap",
	"variantrule",
	"vehicle",
	"classFeature",
	"subclassFeature",
];

class BlocklistUiFvtt extends BlocklistUi {
	_export () {
		DataUtil.userDownload(
			`content-blocklist`,
			{
				blocklist: ExcludeUtil.getList(),
			},
			{
				fileType: "content-blocklist",
				propVersion: "moduleVersion",
				valVersion: game.modules.get(SharedConsts.MODULE_ID).version,
			},
		);
	}

	async _pImport_getUserUpload () {
		return DataUtil.pUserUpload({
			expectedFileTypes: ["content-blocklist"],
			propVersion: "moduleVersion",
		});
	}

	_addListItem_getItemStyles () { return `no-click ve-flex-v-center veapp__list-row-hoverable`; }

	async pSave () {
		await UtilWorldContentBlocklist.pSaveState(MiscUtil.copy(this._excludes));
	}
}

class WorldContentBlocklist extends Application {
	static APP_TITLE = "World Content Blocklist";

	constructor ({data}) {
		super(
			{
				title: WorldContentBlocklist.APP_TITLE,
				template: `${SharedConsts.MODULE_LOCATION}/template/WorldContentBlocklist.hbs`,
				width: 960,
				height: Util.getMaxWindowHeight(),
				resizable: true,
			},
		);
		this._data = data;

		this._ui = null;
	}

	activateListeners ($html) {
		super.activateListeners($html);

		this._pRender($html).then(null);
	}

	async _pRender ($html) {
		const $stgMid = $html.find(`[data-name="wrp-mid"]`);
		const $stgBot = $html.find(`[data-name="wrp-bot"]`);

		await this._pRender_pMid({$stgMid});
		this._pRender_bot({$stgBot});
	}

	async _pRender_pMid ({$stgMid}) {
		this._ui = new BlocklistUiFvtt({
			$wrpContent: $stgMid,
			data: this._data,
			isCompactUi: true,
			isAutoSave: false,
		});
		await this._ui.pInit();
	}

	_pRender_bot ({$stgBot}) {
		const $btnSave = $(`<button class="btn btn-5et btn-default w-100">Save</button>`)
			.click(async () => {
				await this._ui.pSave();
			});

		$$($stgBot.empty())`<div class="ve-flex-v-center">
			${$btnSave}
		</div>`;
	}
}

class ImportSpecialImagePreloader extends Application {
	static APP_TITLE = "Importer Image Preloader";

	constructor () {
		super(
			{
				title: ImportSpecialImagePreloader.APP_TITLE,
				template: `${SharedConsts.MODULE_LOCATION}/template/ImportSpecialImagePreloader.hbs`,
				width: 640,
				height: 360,
				resizable: true,
			},
		);
		this._comp = null;
	}

	activateListeners ($html) {
		super.activateListeners($html);

		const $stgTop = $html.find(`[data-name="wrp-top"]`);
		const $stgMid = $html.find(`[data-name="wrp-mid"]`);

		this._comp = new _ImportSpecialImagePreloaderComp();

		this._comp.render({$stgTop, $stgMid});

		UtilApplications.autoResizeApplication(this);
	}
}

class _ImportSpecialImagePreloaderComp extends BaseComponent {
	static _EXTS_IMG = new Set(["jpg", "jpeg", "png", "webp", "bmp"]);

	static _Render = class {
		constructor () {
			this.$iptToken = null;
			this.linksDirs = [];
		}
	};

	render ({$stgTop, $stgMid}) {
		const render = new this.constructor._Render();

		this._render_top({render, $stgTop});
		this._render_mid({render, $stgMid});
	}

	_render_top ({render, $stgTop}) {
		render.$iptToken = ComponentUiUtil.$getIptStr(this, "ghToken");

		$$($stgTop)`
			<div class="ve-flex-col">
				<div class="mb-2">To make use of this tool, you must first create a <b>GitHub Personal access token</b>. This increases the number of requests you can make to GitHub, where the images are stored, from 60/hour to 5,000/hour.</div>

				<ol>
					<li>(Create a <a href="https://github.com/" target="_blank">GitHub account</a>)</li>
					<li>Go to your <a href="https://github.com/settings/tokens" target="_blank">GitHub Developer settings</a> &rarr; <code>Personal access tokens</code></li>
					<li>
						<code>Generate a new token</code>. Enter e.g. &quot;Image Downloader&quot; as the <code>Note</code>, and set the <code>Expiration</code> to &quot;<span title="Or less, if you prefer. Since we're not enabling any scopes, the token we generate is &quot;harmless.&quot;" class="help--hover">Never</span>&quot;. Scroll to the bottom of the page (<b>do not</b> enable any scopes) and <code>Generate Token</code>.
					</li>
					<li>Copy the token (<code>ghp_...</code>) and enter it below. <b>Keep a note of your token</b> so you can re-use it in future!</li>
				</ol>

				<div class="ve-flex-col">
					<label class="ve-flex-v-center">
						<div class="mr-2 no-shrink">GitHub <code>Personal access token</code></div>
						${render.$iptToken}
					</label>
				</div>
			</div>
		`;
	}

	_render_mid ({render, $stgMid}) {
		const $iptRepoUrl = ComponentUiUtil.$getIptStr(this, "ghRepoUrl");

		const $dispsCntLinks = [$(`<div class="mr-2"></div>`), $(`<div class="mr-2"></div>`)];
		const hkLinks = () => $dispsCntLinks.forEach($dispsCntLink => $dispsCntLink.text(this._state.linksFiles.length));
		this._addHookBase("linksFiles", hkLinks);
		hkLinks();

		const $dispCntDownloads = $(`<div class="mr-1"></div>`);
		const hkCntDownloads = () => $dispCntDownloads.text(this._state.linksFilesDownloaded.length);
		this._addHookBase("linksFilesDownloaded", hkCntDownloads);
		hkCntDownloads();

		const $btnStartStopLinks = $(`<button class="btn btn-5et btn-xs"></button>`)
			.click(() => {
				if (!this._state.isRunningLinks) {
					this._state.isRunningLinks = !this._state.isRunningLinks;
					if (!this._state.ghToken) return ui.notifications.error(`You must enter a GitHub Personal access token first!`);
					if (!this._state.ghRepoUrl) return ui.notifications.error(`You must enter a GitHub API URL first!`);
					return this._pFetchLinks(render);
				}
				this._state.isRunningLinks = !this._state.isRunningLinks;
			});
		const hkIsRunningLinks = () => {
			$btnStartStopLinks.html(this._state.isRunningLinks ? `<i class="fa fa-pause"></i> Pause` : `<i class="fa fa-play"></i> Fetch`);
			$iptRepoUrl.prop("disabled", this._state.isRunningLinks);
			render.$iptToken.prop("disabled", this._state.isRunningLinks);
		};
		this._addHookBase("isRunningLinks", hkIsRunningLinks);
		hkIsRunningLinks();

		const $btnStartStopDownloads = $(`<button class="btn btn-5et btn-xs"></button>`)
			.click(() => {
				if (!this._state.isRunningDownloads) {
					this._state.isRunningDownloads = !this._state.isRunningDownloads;
					return this._pDownloadLinks();
				}
				this._state.isRunningDownloads = !this._state.isRunningDownloads;
			});
		const hkIsRunningDownloads = () => $btnStartStopDownloads.html(this._state.isRunningDownloads ? `<i class="fa fa-pause"></i> Pause` : `<i class="fa fa-play"></i> Download`);
		this._addHookBase("isRunningDownloads", hkIsRunningDownloads);
		hkIsRunningDownloads();

		$$($stgMid)`<div class="ve-flex-col">
			<div class="ve-flex-col mb-2">
				<label class="ve-flex-v-center">
					<div class="mr-2 no-shrink">GitHub API URL</code></div>
					${$iptRepoUrl}
				</label>
			</div>

			<div class="ve-flex-v-center mb-2">
				<div class="mr-2 bold">Links:</div>
				${$dispsCntLinks[0]}
				${$btnStartStopLinks}
			</div>

			<div class="ve-flex-v-center">
				<div class="mr-2 bold">Downloads:</div>
				${$dispCntDownloads}
				<div class="mr-1">/</div>
				${$dispsCntLinks[1]}
				${$btnStartStopDownloads}
			</div>
		</div>`;
	}

	async _pFetchLinks (render) {
		if (!this._state.linksFiles.length && !render.linksDirs.length) {
			const {urlsDirs, urlsFiles} = await this._pFetchLinks_pFetchDir(this._state.ghRepoUrl);
			render.linksDirs.push(...urlsDirs);
			this._state.linksFiles = [...urlsFiles];
		}

		const workers = [...new Array(8)]
			.map(async () => {
				while (render.linksDirs.length) {
					const url = render.linksDirs.pop();
					const {urlsDirs, urlsFiles} = await this._pFetchLinks_pFetchDir(url);
					render.linksDirs.push(...urlsDirs);
					this._state.linksFiles = [...this._state.linksFiles, ...urlsFiles];
					if (!this._state.isRunningLinks) break;
				}
			});

		await Promise.all(workers);

		if (this._state.isRunningLinks) this._state.isRunningLinks = false;
	}

	async _pFetchLinks_pFetchDir (url) {
		const resp = await fetch(
			url,
			{
				headers: {
					Authorization: `token ${this._state.ghToken}`,
				},
			},
		);

		const json = await resp.json();

		if (json.message) {
			ui.notifications.error(json.message);
			console.error(json.message);
			return {urlsDirs: [], urlsFiles: []};
		}

		const [dirs, files] = json
			.filter(it => it.type === "dir" || this.constructor._EXTS_IMG.has((it.name || "").split(".").last().trim().toLowerCase()))
			.map(it => it.type === "dir"
				? ({type: it.type, url: it.url})
				: ({type: it.type, url: this.constructor._getImageDownloadUrl(it.download_url)}),
			)
			.filter(it => it.type && it.url)
			.segregate(it => it.type === "dir");

		return {urlsDirs: dirs.map(({url}) => url), urlsFiles: files.map(({url}) => url)};
	}

	static _getImageDownloadUrl (downloadUrl) {
		
		
		return downloadUrl.replace(
			/^https:\/\/raw\.githubusercontent\.com\/5etools-mirror-1\/5etools-mirror-1\.github\.io\/master\//,
			"https://5etools-mirror-1.github.io/",
		);
	}

	async _pDownloadLinks () {
		const linksFilesDownloadedSet = new Set(this._state.linksFilesDownloaded);
		const linksToDownload = MiscUtil.copy(this._state.linksFiles);

		const workers = [...new Array(8)]
			.map(async () => {
				while (linksToDownload.length) {
					const url = linksToDownload.pop();
					if (linksFilesDownloadedSet.has(url)) continue;

					await Vetools.pSaveImageToServerAndGetUrl({originalUrl: url, force: true});

					linksFilesDownloadedSet.add(url);
					this._state.linksFilesDownloaded.push(url);
					this._triggerCollectionUpdate("linksFilesDownloaded");

					if (!this._state.isRunningDownloads) break;
				}
			});

		await Promise.all(workers);

		if (this._state.isRunningDownloads) this._state.isRunningDownloads = false;
	}

	_getDefaultState () {
		return {
			ghToken: null,
			ghRepoUrl: "https://api.github.com/repos/5etools-mirror-1/5etools-mirror-1/contents/img?ref=master",
			linksFiles: [],
			linksFilesDownloaded: [],
			isRunningLinks: false,
			isRunningDownloads: false,
		};
	}
}

class MenuCollectionTools extends Menu {
		static $getDirButton (hookName) {
		return $(`<button class="ml-0 mr-1 w-initial" title="Open ${Config.get("ui", "isStreamerMode") ? "" : "Plutonium "}Tools List"><span class="fas fa-fw fa-toolbox"></span></button>`)
			.click(evt => {
				const menu = new MenuCollectionTools();
				return menu._pHandleButtonClick(evt, hookName);
			});
	}
	
	constructor () {
		super({
			eventNamespace: MenuCollectionTools._EVT_NAMESPACE,
			toolsList: MenuCollectionTools._TOOL_LIST,
			direction: "down",
		});
	}

	_pHandleButtonClick (evt, hookName) {
		evt.preventDefault();
		evt.stopPropagation();

		let documentClass;
		switch (hookName) {
			case "renderSceneDirectory": documentClass = Scene; break;
			case "renderActorDirectory": documentClass = Actor; break;
			case "renderItemDirectory": documentClass = Item; break;
			case "renderJournalDirectory": documentClass = JournalEntry; break;
			case "renderRollTableDirectory": documentClass = RollTable; break;
			case "renderMacroDirectory": documentClass = Macro; break;
			case "renderCompendiumDirectory": documentClass = CompendiumCollection; break;
			case "renderCardsDirectory": documentClass = Cards; break;
			default: throw new Error(`Unhandled hook type "${hookName}"`);
		}

		return this._pOpenMenu(evt, documentClass);
	}
}
MenuCollectionTools._EVT_NAMESPACE = "plutonium-collection-tools-menu";
MenuCollectionTools._TOOL_LIST = [
	new MenuToolInfo({
		name: "Directory Cleaner",
		Class: CollectionCleaner,
		iconClass: "fa-trash-alt",
		fnCheckRequirements: type => ![CompendiumCollection].includes(type),
	}),
	new MenuToolInfo({
		name: "Directory Deduplicator",
		Class: CollectionDeduplicator,
		iconClass: "fa-object-group",
		fnCheckRequirements: type => ![CompendiumCollection].includes(type),
	}),
	new MenuToolInfo({
		name: "Bulk Directory Mover",
		Class: CollectionFolderizer,
		iconClass: "fa-sitemap",
		fnCheckRequirements: type => ![CompendiumCollection].includes(type),
	}),
	new MenuToolInfo({
		name: "Bulk Ownership Editor",
		Class: CollectionOwnershipUpdater,
		iconClass: "fa-id-card",
		fnCheckRequirements: type => ![Scene, CompendiumCollection].includes(type),
	}),
	new MenuToolInfo({
		name: "Bulk Prototype Token Editor",
		Class: CollectionTokenUpdater,
		iconClass: "fa-user-circle",
		fnCheckRequirements: type => type === Actor,
	}),
	new MenuToolInfo({
		name: "Ownership Updater",
		Class: CompendiumListOwnershipUpdater,
		iconClass: "fa-eye",
		fnCheckRequirements: type => [CompendiumCollection].includes(type),
	}),
	null,
	new MenuToolInfo({
		name: "Loot Generator",
		Class: LootGeneratorApp,
		iconClass: "fa-search-dollar",
		fnCheckRequirements: type => [
			Item,
			JournalEntry,
			CompendiumCollection,
		].includes(type),
	}),
	null,
	new MenuToolInfo({
		name: WorldDataSourceSelector.APP_TITLE,
		Class: WorldDataSourceSelector,
		iconClass: "fa-globe-africa",
		fnCheckRequirements: type => ![CompendiumCollection].includes(type) && game.user.isGM,
	}),
	new MenuToolInfo({
		name: WorldContentBlocklist.APP_TITLE,
		Class: WorldContentBlocklistSourceSelector,
		iconClass: "fa-ban",
		fnCheckRequirements: type => ![CompendiumCollection].includes(type) && game.user.isGM,
	}),
	null,
	new MenuToolInfo({
		name: APP_TITLE,
		Class: ContentUpdaterSourceSelector,
		iconClass: "fa-arrows-rotate",
		fnCheckRequirements: type => [
			Actor,
			Item,
			RollTable,
			Cards,
			CompendiumCollection,
		].includes(type) && game.user.isGM,
	}),
	new MenuToolInfo({
		name: "Package Importer",
		Class: ImportSpecialPackages,
		iconClass: "fa-cube",
		fnCheckRequirements: type => ![CompendiumCollection].includes(type),
	}),
	new MenuToolInfo({
		name: ImportSpecialImagePreloader.APP_TITLE,
		Class: ImportSpecialImagePreloader,
		iconClass: "fa-file-image",
	}),
];

var MenuCollectionTools$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    MenuCollectionTools: MenuCollectionTools
});

class DataConverterCreatureFeature extends DataConverterActor {
		static _SIDE_LOAD_OPTS = {
		propBrew: "TODO",
		fnLoadJson: async () => this._pGetPreloadSideData(),
		propJson: "TODO",
		propsMatch: ["monsterSource", "monsterName", "source", "name"],
	};

	static _IMG_FALLBACK = `modules/${SharedConsts.MODULE_ID}/media/icon/mighty-force.svg`;

	static getFauxCreatureFeature (mon, entry, prop) {
		const out = {
			source: entry.source || mon.source,
			monsterName: mon.name,
			monsterSource: mon.source,
			srd: !!mon.srd,
			basicRules: !!mon.basicRules,
			page: entry.page ?? mon.page,
			...MiscUtil.copy(entry),
			_monsterParsedCr: mon._pCr,
			_monsterFilterCr: mon._fCr,
			__prop: prop,
		};

		if (out.name) out.name = Renderer.stripTags(out.name);

		return out;
	}

		static async pGetDocumentJson (ent, opts) {
		Renderer.get().resetHeaderIndex();

		return {name: ent.name, type: "feat", data: {description: {value: "Unimplemented"}}};
	}
}

var DataConverterCreatureFeature$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DataConverterCreatureFeature: DataConverterCreatureFeature
});

class PageFilterCreatureFeature extends PageFilter {
	constructor () {
		super();
		this._typeFilter = new Filter({
			header: "Type",
			labelDisplayFn: it => Parser.getPropDisplayName(it.replace(/^monster/, "").lowercaseFirst()),
		});
		this._crFilter = new RangeFilter({
			header: "Challenge Rating",
			isLabelled: true,
			labelSortFn: SortUtil.ascSortCr,
			labels: [...Parser.CRS, "Unknown", "\u2014"],
			labelDisplayFn: it => it === "\u2014" ? "None" : it,
		});
		this._miscFilter = new Filter({
			header: "Miscellaneous",
			items: ["SRD", "Basic Rules"],
			isMiscFilter: true,
		});
	}

	static mutateForFilters (ent) {
		ent._fMisc = ent.srd ? ["SRD"] : [];
		if (ent.basicRules) ent._fMisc.push("Basic Rules");
	}

	addToFilters (it, isExcluded) {
		if (isExcluded) return;

		this._sourceFilter.addItem(it.source);
		this._crFilter.addItem(it._monsterFilterCr);
		this._typeFilter.addItem(it.__prop);
		this._miscFilter.addItem(it._fMisc);
	}

	async _pPopulateBoxOptions (opts) {
		opts.filters = [
			this._sourceFilter,
			this._typeFilter,
			this._crFilter,
			this._miscFilter,
		];
	}

	toDisplay (values, it) {
		return this._filterBox.toDisplay(
			values,
			it.source,
			it.__prop,
			it._monsterFilterCr,
			it._fMisc,
		);
	}
}

class ImportListCreatureFeature extends ImportListCharacter {
	static get ID () { return "creature-features"; }
	static get DISPLAY_NAME_TYPE_PLURAL () { return "Creature Features"; }
	static get PROPS () { return Renderer.monster.CHILD_PROPS_EXTENDED.map(it => `monster${it.uppercaseFirst()}`); }

	static _ = this.registerImpl(this);

	_dirsHomebrew = ["creature"];
	_titleSearch = "creature feature";
	_sidebarTab = "items";
	_gameProp = "items";
	_defaultFolderPath = ["Creature Features"];
	_pageFilter = new PageFilterCreatureFeature();
	_isPreviewable = true;
	_isDedupable = true;
	_configGroup = "importCreatureFeature";
	static _DataConverter = DataConverterCreatureFeature;

	async pInit () {
		if (await super.pInit()) return true;

		await DataUtil.monster.pPreloadMeta();
	}

	_pPostLoad_getFeaturesFromSingleSourceCreatures (src, data) {
		data = {...data};
		data.monster = data.monster.filter(mon => mon.source === src);

		return this._pPostLoad_getFeaturesFromCreatures(data);
	}

	_pPostLoad_getFeaturesFromCreatures (data) {
		const out = {};

		for (const mon of data.monster) {
			Renderer.monster.initParsed(mon);

			const legendaryMeta = DataUtil.monster.getMetaGroup(mon);

			Renderer.monster.CHILD_PROPS_EXTENDED.forEach(prop => {
								if (prop === "spellcasting") return;

				const outProp = `monster${prop.uppercaseFirst()}`;

				(mon[prop] || legendaryMeta?.[prop] || [])
					.filter(ent => ent.name && ent.entries)
					.forEach(ent => {
						out[outProp] = out[outProp] || [];
						out[outProp].push(DataConverterCreatureFeature.getFauxCreatureFeature(mon, ent, `monster${prop.uppercaseFirst()}`));
					});
			});
		}

		return out;
	}

	async _pGetSources () {
		const argsShared = {pPostLoad: (data) => this._pPostLoad_getFeaturesFromCreatures(data)};

		return [
			new UtilDataSource.DataSourceSpecial(
				Config.get("ui", "isStreamerMode") ? "SRD" : "5etools",
				Vetools.pGetAllCreatures.bind(Vetools),
				{
					...argsShared,
					cacheKey: "5etools-creature-features",
					filterTypes: [UtilDataSource.SOURCE_TYP_OFFICIAL_ALL],
					isDefault: true,
				},
			),
			...UtilDataSource.getSourcesCustomUrl({...argsShared}),
			...UtilDataSource.getSourcesUploadFile({...argsShared}),
			...Object.keys(await DataUtil.monster.pLoadIndex()).map(src => new UtilDataSource.DataSourceSpecial(
				Parser.sourceJsonToFull(src),
				() => DataUtil.monster.pLoadSingleSource(src),
				{
					...argsShared,
					cacheKey: `5etools-creature-features-${src}`,
					pPostLoad: (data) => this._pPostLoad_getFeaturesFromSingleSourceCreatures(src, data),
					filterTypes: UtilDataSource.getSourceFilterTypes(src),
				},
			)),
			...(await this._pGetSourcesPrerelease({...argsShared})),
			...(await this._pGetSourcesBrew({...argsShared})),
		];
	}

	_colWidthName = 4;
	_colWidthSource = 1;

	_getData_cols_other () {
		return [
			{
				name: "Type",
				width: 2,
				field: "type",
				rowClassName: "text-center",
			},
			{
				name: "Creature",
				width: 3,
				field: "monsterName",
			},
			{
				name: "CR",
				width: 1,
				field: "cr",
				rowClassName: "text-center",
			},
		];
	}

	_getData_row_mutGetAdditionalValues ({it, ix}) {
		it._vCr = it._monsterParsedCr || "\u2014";
		it._vType = Parser.getPropDisplayName(it.__prop.replace(/^monster/, "").lowercaseFirst());

		return {
			type: it._vType,
			cr: it._vCr,
			monsterName: it.monsterName,
		};
	}

	_renderInner_absorbListItems_fnGetValues (it) {
		return {
			...super._renderInner_absorbListItems_fnGetValues(it),
			type: it._vType,
			cr: it._vCr,
			monsterName: it.monsterName,
		};
	}

	async _pImportEntry_pImportToActor (ent, importOpts) {
		const dataBuilderOpts = new ImportListCharacter.ImportEntryOpts({});

		await this._pImportEntry_pFillItems(ent, dataBuilderOpts);
		if (dataBuilderOpts.isCancelled) return ImportSummary.cancelled();

		if (this._actor.isToken) this._actor.sheet.render();

		return new ImportSummary({
			status: ConstsTaskRunner.TASK_EXIT_COMPLETE,
			imported: [
				new ImportedDocument({
					name: ent.name,
					actor: this._actor,
				}),
			],
		});
	}

	async _pImportEntry_pFillItems () {
									}
}

var ImportListCreatureFeature$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ImportListCreatureFeature: ImportListCreatureFeature
});
